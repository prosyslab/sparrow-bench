/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 97 "/usr/include/stdio.h"
typedef __off64_t off64_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 142 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
typedef unsigned char uint8_t;
#line 188 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
typedef unsigned int uint32_t;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 818
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
#line 819
extern __off64_t ftello64(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 259 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
off64_t strtoofft(char const   *s_start , char **endptr , int base ) 
{ 
  off64_t max ;
  off64_t min ;
  char const   *s ;
  off64_t accumulator ;
  off64_t limit_tens ;
  off64_t limit_ones ;
  int c ;
  int negative ;
  int anyinput ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 260
  max = ((1L << (sizeof(off64_t ) * 8UL - 2UL)) - 1L) + (1L << (sizeof(off64_t ) * 8UL - 2UL));
#line 263
  min = -1L - max;
#line 264
  s = s_start;
#line 269
  negative = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    tmp = s;
#line 272
    s ++;
#line 272
    c = (int )*tmp;
#line 271
    tmp___0 = __ctype_b_loc();
    }
#line 271
    if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 271
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  if (c == 45) {
#line 275
    negative = 1;
#line 276
    tmp___1 = s;
#line 276
    s ++;
#line 276
    c = (int )*tmp___1;
  } else
#line 277
  if (c == 43) {
#line 278
    tmp___2 = s;
#line 278
    s ++;
#line 278
    c = (int )*tmp___2;
  }
#line 280
  if (base == 0) {
#line 280
    goto _L;
  } else
#line 280
  if (base == 16) {
    _L: /* CIL Label */ 
#line 280
    if (c == 48) {
#line 280
      if ((int const   )*s == 120) {
#line 284
        c = (int )*(s + 1);
#line 285
        s += 2;
#line 286
        base = 16;
      } else
#line 280
      if ((int const   )*s == 88) {
#line 284
        c = (int )*(s + 1);
#line 285
        s += 2;
#line 286
        base = 16;
      }
    }
  }
#line 288
  if (! base) {
#line 289
    if (c == 48) {
#line 289
      base = 8;
    } else {
#line 289
      base = 10;
    }
  }
#line 291
  limit_ones = max % (off64_t )base;
#line 292
  limit_tens = max / (off64_t )base;
#line 293
  if (negative) {
#line 294
    limit_ones ++;
#line 295
    if (limit_ones >= (off64_t )base) {
#line 295
      limit_ones = (off64_t )0;
#line 295
      limit_tens ++;
    }
  }
#line 297
  accumulator = (off64_t )0;
#line 297
  anyinput = 0;
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 298
    tmp___8 = __ctype_b_loc();
    }
#line 298
    if ((int const   )*(*tmp___8 + c) & 2048) {
#line 299
      c -= 48;
    } else {
      {
#line 300
      tmp___7 = __ctype_b_loc();
      }
#line 300
      if ((int const   )*(*tmp___7 + c) & 1024) {
        {
#line 301
        tmp___6 = __ctype_b_loc();
        }
#line 301
        if ((int const   )*(*tmp___6 + c) & 256) {
#line 301
          tmp___5 = 55;
        } else {
#line 301
          tmp___5 = 87;
        }
#line 301
        c -= tmp___5;
      } else {
#line 303
        goto while_break___0;
      }
    }
#line 305
    if (c >= base) {
#line 305
      goto while_break___0;
    }
#line 306
    if (anyinput < 0) {
#line 312
      anyinput = -1;
    } else
#line 306
    if (accumulator < 0L) {
#line 312
      anyinput = -1;
    } else
#line 306
    if (accumulator > limit_tens) {
#line 312
      anyinput = -1;
    } else
#line 306
    if (accumulator == limit_tens) {
#line 306
      if ((off64_t )c > limit_ones) {
#line 312
        anyinput = -1;
      } else {
#line 314
        anyinput = 1;
#line 315
        accumulator *= (off64_t )base;
#line 316
        accumulator += (off64_t )c;
      }
    } else {
#line 314
      anyinput = 1;
#line 315
      accumulator *= (off64_t )base;
#line 316
      accumulator += (off64_t )c;
    }
#line 297
    tmp___3 = s;
#line 297
    s ++;
#line 297
    c = (int )*tmp___3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 319
  if (anyinput < 0) {
#line 320
    if (negative) {
#line 320
      accumulator = min;
    } else {
#line 320
      accumulator = max;
    }
    {
#line 321
    tmp___9 = __errno_location();
#line 321
    *tmp___9 = 34;
    }
  } else
#line 322
  if (negative) {
#line 323
    accumulator = - accumulator;
  }
#line 325
  if (endptr) {
#line 326
    if (anyinput) {
#line 326
      tmp___10 = (char const   *)((char *)s - 1);
    } else {
#line 326
      tmp___10 = s_start;
    }
#line 326
    *endptr = (char *)tmp___10;
  }
#line 328
  return (accumulator);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
void fprinthex(FILE *f , off64_t off , int min_digits ) 
{ 
  unsigned int anydigit ;
  int place ;
  unsigned int digit ;

  {
#line 335
  anydigit = 0U;
#line 337
  place = (int )(2UL * sizeof(off64_t ) - 1UL);
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (place >= 0)) {
#line 337
      goto while_break;
    }
#line 338
    if (sizeof(off64_t ) > (size_t )place / 2UL) {
#line 339
      digit = (unsigned int )((off >> 4 * place) & 15L);
#line 340
      anydigit |= digit;
#line 341
      if (anydigit) {
        {
#line 342
        fputc((int )*("0123456789ABCDEF" + digit), f);
        }
      } else
#line 341
      if (place < min_digits) {
        {
#line 342
        fputc((int )*("0123456789ABCDEF" + digit), f);
        }
      }
    }
#line 337
    place --;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
static void fprintdec_digit(FILE *f , off64_t off ) 
{ 


  {
#line 349
  if (off == 0L) {
#line 349
    return;
  }
#line 350
  if (off >= 10L) {
    {
#line 351
    fprintdec_digit(f, off / 10L);
#line 352
    off %= 10L;
    }
  }
  {
#line 354
  fputc((int )(48L + off), f);
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
void fprintdec(FILE *f , off64_t off ) 
{ 
  off64_t ones ;

  {
#line 358
  if (off == 0L) {
    {
#line 359
    fputc('0', f);
    }
#line 360
    return;
  }
#line 362
  if (off < 0L) {
    {
#line 363
    fputc('-', f);
#line 364
    off = - off;
    }
#line 365
    if (off < 0L) {
      {
#line 366
      ones = off % 10L;
#line 367
      off /= 10L;
#line 368
      off = - off;
#line 369
      fprintdec_digit(f, off);
#line 370
      fputc((int )(48L - ones), f);
      }
#line 371
      return;
    }
  }
  {
#line 374
  fprintdec_digit(f, off);
  }
#line 375
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
void normalize_argv0(char *argv0 ) 
{ 
  size_t i ;
  size_t start ;
  int c ;
  size_t tmp ;

  {
#line 536
  start = (size_t )0;
#line 538
  i = (size_t )0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! *(argv0 + i)) {
#line 538
      goto while_break;
    }
#line 539
    if ((int )*(argv0 + i) == 47) {
#line 540
      start = i + 1UL;
    } else
#line 539
    if ((int )*(argv0 + i) == 92) {
#line 540
      start = i + 1UL;
    }
#line 538
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  i = (size_t )0;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 545
    c = (int )((unsigned char )*(argv0 + (start + i)));
#line 546
    if (c == 46) {
#line 546
      c = 0;
    }
#line 547
    if (c != 0) {
      {
#line 547
      c = tolower(c);
      }
    }
#line 548
    tmp = i;
#line 548
    i ++;
#line 548
    *(argv0 + tmp) = (char )c;
#line 544
    if (! (c != 0)) {
#line 544
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 550
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
void printfileerror(FILE *f , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 555
  tmp = __errno_location();
#line 555
  e = *tmp;
#line 556
  printf((char const   */* __restrict  */)"Error: ");
  }
#line 557
  if (name) {
    {
#line 557
    printf((char const   */* __restrict  */)"%s: ", name);
    }
  }
#line 558
  if (f) {
    {
#line 558
    tmp___3 = feof(f);
    }
#line 558
    if (tmp___3) {
#line 558
      tmp___2 = "Unexpected end-of-file";
    } else {
      {
#line 558
      tmp___1 = strerror(e);
#line 558
      tmp___2 = (char const   *)tmp___1;
      }
    }
  } else {
    {
#line 558
    tmp___1 = strerror(e);
#line 558
    tmp___2 = (char const   *)tmp___1;
    }
  }
  {
#line 558
  printf((char const   */* __restrict  */)"%s\n", tmp___2);
  }
#line 559
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
void commandlinewarning(void) 
{ 


  {
#line 620
  return;
}
}
#line 3 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/banner.h"
void banner_ok(void) 
{ 
  char const   *tmp ;

  {
#line 4
  if (sizeof(off64_t ) > 4UL) {
#line 4
    if (sizeof(off64_t ) > sizeof(size_t )) {
#line 4
      tmp = ", large file support";
    } else {
#line 4
      tmp = "";
    }
  } else {
#line 4
    tmp = "";
  }
  {
#line 4
  printf((char const   */* __restrict  */)"ecm-compress - Encoder/decoder for Error Code Modeler format\n  Copyright (C) 2002-2011 Neill Corlett\n  from Command-Line Pack v1.03 (%d-bit Linux%s)\n  http://www.neillcorlett.com/cmdpack/\n\n",
         (int )(sizeof(size_t ) * 8UL), tmp);
  }
#line 54
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/banner.h"
void banner_error(void) 
{ 


  {
  {
#line 57
  printf((char const   */* __restrict  */)"Configuration error\n");
#line 58
  exit(1);
  }
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/banner.h"
static void banner(void) 
{ 
  void (*tmp)(void) ;

  {
#line 62
  if (sizeof(off64_t ) >= sizeof(size_t )) {
#line 62
    tmp = & banner_ok;
  } else {
#line 62
    tmp = & banner_error;
  }
  {
#line 62
  (*tmp)();
#line 67
  atexit(& commandlinewarning);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint32_t get32lsb(uint8_t const   *src ) 
{ 


  {
#line 71
  return ((((uint32_t )*(src + 0) | ((uint32_t )*(src + 1) << 8)) | ((uint32_t )*(src + 2) << 16)) | ((uint32_t )*(src + 3) << 24));
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void put32lsb(uint8_t *dest , uint32_t value ) 
{ 


  {
#line 79
  *(dest + 0) = (uint8_t )value;
#line 80
  *(dest + 1) = (uint8_t )(value >> 8);
#line 81
  *(dest + 2) = (uint8_t )(value >> 16);
#line 82
  *(dest + 3) = (uint8_t )(value >> 24);
#line 83
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t ecc_f_lut[256]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t ecc_b_lut[256]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint32_t edc_lut[256]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void eccedc_init(void) 
{ 
  size_t i ;
  uint32_t edc ;
  size_t j ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 95
  i = (size_t )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 256UL)) {
#line 95
      goto while_break;
    }
#line 96
    edc = (uint32_t )i;
#line 97
    if (i & 128UL) {
#line 97
      tmp = 285;
    } else {
#line 97
      tmp = 0;
    }
#line 97
    j = (i << 1) ^ (unsigned long )tmp;
#line 98
    ecc_f_lut[i] = (uint8_t )j;
#line 99
    ecc_b_lut[i ^ j] = (uint8_t )i;
#line 100
    j = (size_t )0;
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < 8UL)) {
#line 100
        goto while_break___0;
      }
#line 101
      if (edc & 1U) {
#line 101
        tmp___0 = 3623976961U;
      } else {
#line 101
        tmp___0 = 0U;
      }
#line 101
      edc = (edc >> 1) ^ tmp___0;
#line 100
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    edc_lut[i] = edc;
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint32_t edc_compute(uint32_t edc , uint8_t const   *src , size_t size ) 
{ 
  uint8_t const   *tmp ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! size) {
#line 116
      goto while_break;
    }
#line 117
    tmp = src;
#line 117
    src ++;
#line 117
    edc = (edc >> 8) ^ edc_lut[(edc ^ (unsigned int )*tmp) & 255U];
#line 116
    size --;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (edc);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t ecc_checkpq(uint8_t const   *address , uint8_t const   *data , size_t major_count ,
                          size_t minor_count , size_t major_mult , size_t minor_inc ,
                          uint8_t const   *ecc ) 
{ 
  size_t size ;
  size_t major ;
  size_t index___0 ;
  uint8_t ecc_a ;
  uint8_t ecc_b ;
  size_t minor ;
  uint8_t temp ;

  {
#line 136
  size = major_count * minor_count;
#line 138
  major = (size_t )0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (major < major_count)) {
#line 138
      goto while_break;
    }
#line 139
    index___0 = (major >> 1) * major_mult + (major & 1UL);
#line 140
    ecc_a = (uint8_t )0;
#line 141
    ecc_b = (uint8_t )0;
#line 143
    minor = (size_t )0;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! (minor < minor_count)) {
#line 143
        goto while_break___0;
      }
#line 145
      if (index___0 < 4UL) {
#line 146
        temp = (uint8_t )*(address + index___0);
      } else {
#line 148
        temp = (uint8_t )*(data + (index___0 - 4UL));
      }
#line 150
      index___0 += minor_inc;
#line 151
      if (index___0 >= size) {
#line 151
        index___0 -= size;
      }
#line 152
      ecc_a = (uint8_t )((int )ecc_a ^ (int )temp);
#line 153
      ecc_b = (uint8_t )((int )ecc_b ^ (int )temp);
#line 154
      ecc_a = ecc_f_lut[ecc_a];
#line 143
      minor ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    ecc_a = ecc_b_lut[(int )ecc_f_lut[ecc_a] ^ (int )ecc_b];
#line 157
    if ((int const   )*(ecc + major) != (int const   )ecc_a) {
#line 161
      return ((int8_t )0);
    } else
#line 157
    if ((int const   )*(ecc + (major + major_count)) != (int const   )((int )ecc_a ^ (int )ecc_b)) {
#line 161
      return ((int8_t )0);
    }
#line 138
    major ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return ((int8_t )1);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void ecc_writepq(uint8_t const   *address , uint8_t const   *data , size_t major_count ,
                        size_t minor_count , size_t major_mult , size_t minor_inc ,
                        uint8_t *ecc ) 
{ 
  size_t size ;
  size_t major ;
  size_t index___0 ;
  uint8_t ecc_a ;
  uint8_t ecc_b ;
  size_t minor ;
  uint8_t temp ;

  {
#line 179
  size = major_count * minor_count;
#line 181
  major = (size_t )0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (major < major_count)) {
#line 181
      goto while_break;
    }
#line 182
    index___0 = (major >> 1) * major_mult + (major & 1UL);
#line 183
    ecc_a = (uint8_t )0;
#line 184
    ecc_b = (uint8_t )0;
#line 186
    minor = (size_t )0;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! (minor < minor_count)) {
#line 186
        goto while_break___0;
      }
#line 188
      if (index___0 < 4UL) {
#line 189
        temp = (uint8_t )*(address + index___0);
      } else {
#line 191
        temp = (uint8_t )*(data + (index___0 - 4UL));
      }
#line 193
      index___0 += minor_inc;
#line 194
      if (index___0 >= size) {
#line 194
        index___0 -= size;
      }
#line 195
      ecc_a = (uint8_t )((int )ecc_a ^ (int )temp);
#line 196
      ecc_b = (uint8_t )((int )ecc_b ^ (int )temp);
#line 197
      ecc_a = ecc_f_lut[ecc_a];
#line 186
      minor ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 199
    ecc_a = ecc_b_lut[(int )ecc_f_lut[ecc_a] ^ (int )ecc_b];
#line 200
    *(ecc + major) = ecc_a;
#line 201
    *(ecc + (major + major_count)) = (uint8_t )((int )ecc_a ^ (int )ecc_b);
#line 181
    major ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t ecc_checksector(uint8_t const   *address , uint8_t const   *data , uint8_t const   *ecc ) 
{ 
  int8_t tmp ;
  int8_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 214
  tmp = ecc_checkpq(address, data, (size_t )86, (size_t )24, (size_t )2, (size_t )86,
                    ecc);
  }
#line 214
  if (tmp) {
    {
#line 214
    tmp___0 = ecc_checkpq(address, data, (size_t )52, (size_t )43, (size_t )86, (size_t )88,
                          ecc + 172);
    }
#line 214
    if (tmp___0) {
#line 214
      tmp___1 = 1;
    } else {
#line 214
      tmp___1 = 0;
    }
  } else {
#line 214
    tmp___1 = 0;
  }
#line 214
  return ((int8_t )tmp___1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void ecc_writesector(uint8_t const   *address , uint8_t const   *data , uint8_t *ecc ) 
{ 


  {
  {
#line 227
  ecc_writepq(address, data, (size_t )86, (size_t )24, (size_t )2, (size_t )86, ecc);
#line 228
  ecc_writepq(address, data, (size_t )52, (size_t )43, (size_t )86, (size_t )88, ecc + 172);
  }
#line 229
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t const   zeroaddress[4]  = {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 245 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t detect_sector(uint8_t const   *sector , size_t size_available ) 
{ 
  int8_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int8_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 246
  if (size_available >= 2352UL) {
#line 246
    if ((int const   )*(sector + 0) == 0) {
#line 246
      if ((int const   )*(sector + 1) == 255) {
#line 246
        if ((int const   )*(sector + 2) == 255) {
#line 246
          if ((int const   )*(sector + 3) == 255) {
#line 246
            if ((int const   )*(sector + 4) == 255) {
#line 246
              if ((int const   )*(sector + 5) == 255) {
#line 246
                if ((int const   )*(sector + 6) == 255) {
#line 246
                  if ((int const   )*(sector + 7) == 255) {
#line 246
                    if ((int const   )*(sector + 8) == 255) {
#line 246
                      if ((int const   )*(sector + 9) == 255) {
#line 246
                        if ((int const   )*(sector + 10) == 255) {
#line 246
                          if ((int const   )*(sector + 11) == 0) {
#line 246
                            if ((int const   )*(sector + 15) == 1) {
#line 246
                              if ((int const   )*(sector + 2068) == 0) {
#line 246
                                if ((int const   )*(sector + 2069) == 0) {
#line 246
                                  if ((int const   )*(sector + 2070) == 0) {
#line 246
                                    if ((int const   )*(sector + 2071) == 0) {
#line 246
                                      if ((int const   )*(sector + 2072) == 0) {
#line 246
                                        if ((int const   )*(sector + 2073) == 0) {
#line 246
                                          if ((int const   )*(sector + 2074) == 0) {
#line 246
                                            if ((int const   )*(sector + 2075) == 0) {
                                              {
#line 273
                                              tmp = ecc_checksector(sector + 12, sector + 16,
                                                                    sector + 2076);
                                              }
#line 273
                                              if (tmp) {
                                                {
#line 273
                                                tmp___0 = edc_compute((uint32_t )0,
                                                                      sector, (size_t )2064);
#line 273
                                                tmp___1 = get32lsb(sector + 2064);
                                                }
#line 273
                                                if (tmp___0 == tmp___1) {
#line 281
                                                  return ((int8_t )1);
                                                }
                                              }
                                            } else {
#line 246
                                              goto _L___19;
                                            }
                                          } else {
#line 246
                                            goto _L___19;
                                          }
                                        } else {
#line 246
                                          goto _L___19;
                                        }
                                      } else {
#line 246
                                        goto _L___19;
                                      }
                                    } else {
#line 246
                                      goto _L___19;
                                    }
                                  } else {
#line 246
                                    goto _L___19;
                                  }
                                } else {
#line 246
                                  goto _L___19;
                                }
                              } else {
#line 246
                                goto _L___19;
                              }
                            } else {
#line 246
                              goto _L___19;
                            }
                          } else {
#line 246
                            goto _L___19;
                          }
                        } else {
#line 246
                          goto _L___19;
                        }
                      } else {
#line 246
                        goto _L___19;
                      }
                    } else {
#line 246
                      goto _L___19;
                    }
                  } else {
#line 246
                    goto _L___19;
                  }
                } else {
#line 246
                  goto _L___19;
                }
              } else {
#line 246
                goto _L___19;
              }
            } else {
#line 246
              goto _L___19;
            }
          } else {
#line 246
            goto _L___19;
          }
        } else {
#line 246
          goto _L___19;
        }
      } else {
#line 246
        goto _L___19;
      }
    } else {
#line 246
      goto _L___19;
    }
  } else
  _L___19: /* CIL Label */ 
#line 284
  if (size_available >= 2336UL) {
#line 284
    if ((int const   )*(sector + 0) == (int const   )*(sector + 4)) {
#line 284
      if ((int const   )*(sector + 1) == (int const   )*(sector + 5)) {
#line 284
        if ((int const   )*(sector + 2) == (int const   )*(sector + 6)) {
#line 284
          if ((int const   )*(sector + 3) == (int const   )*(sector + 7)) {
            {
#line 294
            tmp___2 = ecc_checksector(zeroaddress, sector, sector + 2060);
            }
#line 294
            if (tmp___2) {
              {
#line 294
              tmp___3 = edc_compute((uint32_t )0, sector, (size_t )2056);
#line 294
              tmp___4 = get32lsb(sector + 2056);
              }
#line 294
              if (tmp___3 == tmp___4) {
#line 302
                return ((int8_t )2);
              }
            }
            {
#line 307
            tmp___5 = edc_compute((uint32_t )0, sector, (size_t )2332);
#line 307
            tmp___6 = get32lsb(sector + 2332);
            }
#line 307
            if (tmp___5 == tmp___6) {
#line 310
              return ((int8_t )3);
            }
          }
        }
      }
    }
  }
#line 317
  return ((int8_t )0);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void reconstruct_sector(uint8_t *sector , int8_t type ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 331
  *(sector + 0) = (uint8_t )0;
#line 332
  *(sector + 1) = (uint8_t )255;
#line 333
  *(sector + 2) = (uint8_t )255;
#line 334
  *(sector + 3) = (uint8_t )255;
#line 335
  *(sector + 4) = (uint8_t )255;
#line 336
  *(sector + 5) = (uint8_t )255;
#line 337
  *(sector + 6) = (uint8_t )255;
#line 338
  *(sector + 7) = (uint8_t )255;
#line 339
  *(sector + 8) = (uint8_t )255;
#line 340
  *(sector + 9) = (uint8_t )255;
#line 341
  *(sector + 10) = (uint8_t )255;
#line 342
  *(sector + 11) = (uint8_t )0;
  {
#line 345
  if ((int )type == 1) {
#line 345
    goto case_1;
  }
#line 363
  if ((int )type == 3) {
#line 363
    goto case_3;
  }
#line 363
  if ((int )type == 2) {
#line 363
    goto case_3;
  }
#line 344
  goto switch_break;
  case_1: /* CIL Label */ 
#line 349
  *(sector + 15) = (uint8_t )1;
#line 353
  *(sector + 2068) = (uint8_t )0;
#line 354
  *(sector + 2069) = (uint8_t )0;
#line 355
  *(sector + 2070) = (uint8_t )0;
#line 356
  *(sector + 2071) = (uint8_t )0;
#line 357
  *(sector + 2072) = (uint8_t )0;
#line 358
  *(sector + 2073) = (uint8_t )0;
#line 359
  *(sector + 2074) = (uint8_t )0;
#line 360
  *(sector + 2075) = (uint8_t )0;
#line 361
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 367
  *(sector + 15) = (uint8_t )2;
#line 371
  *(sector + 16) = *(sector + 20);
#line 372
  *(sector + 17) = *(sector + 21);
#line 373
  *(sector + 18) = *(sector + 22);
#line 374
  *(sector + 19) = *(sector + 23);
#line 375
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 382
  if ((int )type == 1) {
#line 382
    goto case_1___0;
  }
#line 383
  if ((int )type == 2) {
#line 383
    goto case_2___0;
  }
#line 384
  if ((int )type == 3) {
#line 384
    goto case_3___0;
  }
#line 381
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 382
  tmp = edc_compute((uint32_t )0, (uint8_t const   *)sector, (size_t )2064);
#line 382
  put32lsb(sector + 2064, tmp);
  }
#line 382
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 383
  tmp___0 = edc_compute((uint32_t )0, (uint8_t const   *)(sector + 16), (size_t )2056);
#line 383
  put32lsb(sector + 2072, tmp___0);
  }
#line 383
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 384
  tmp___1 = edc_compute((uint32_t )0, (uint8_t const   *)(sector + 16), (size_t )2332);
#line 384
  put32lsb(sector + 2348, tmp___1);
  }
#line 384
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 391
  if ((int )type == 1) {
#line 391
    goto case_1___1;
  }
#line 392
  if ((int )type == 2) {
#line 392
    goto case_2___1;
  }
#line 390
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 391
  ecc_writesector((uint8_t const   *)(sector + 12), (uint8_t const   *)(sector + 16),
                  sector + 2076);
  }
#line 391
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 392
  ecc_writesector(zeroaddress, (uint8_t const   *)(sector + 16), sector + 2076);
  }
#line 392
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 398
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t write_type_count(char const   *outfilename , FILE *out , int8_t type ,
                               uint32_t count ) 
{ 
  int8_t returncode ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 412
  returncode = (int8_t )0;
#line 414
  count --;
#line 415
  tmp = fputc((int )(((unsigned int )((count >= 32U) << 7) | ((count & 31U) << 2)) | (unsigned int )type),
              out);
  }
#line 415
  if (tmp == -1) {
#line 416
    goto error_out;
  }
#line 418
  count >>= 5;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! count) {
#line 419
      goto while_break;
    }
    {
#line 420
    tmp___0 = fputc((int )((unsigned int )((count >= 128U) << 7) | (count & 127U)),
                    out);
    }
#line 420
    if (tmp___0 == -1) {
#line 421
      goto error_out;
    }
#line 423
    count >>= 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  returncode = (int8_t )0;
#line 429
  goto done;
  error_out: 
  {
#line 432
  printfileerror(out, outfilename);
  }
#line 433
  goto error;
  error: 
#line 436
  returncode = (int8_t )1;
#line 437
  goto done;
  done: 
#line 440
  return (returncode);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t sector_buffer[2352]  ;
#line 449 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_analyze  =    (off64_t )-1;
#line 450 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_encode  =    (off64_t )-1;
#line 451 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_decode  =    (off64_t )-1;
#line 452 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_total  =    (off64_t )0;
#line 454 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void resetcounter(off64_t total ) 
{ 


  {
#line 455
  mycounter_analyze = (off64_t )-1;
#line 456
  mycounter_encode = (off64_t )-1;
#line 457
  mycounter_decode = (off64_t )-1;
#line 458
  mycounter_total = total;
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void encode_progress(void) 
{ 
  off64_t a ;
  off64_t e ;
  off64_t t ;

  {
#line 462
  a = (mycounter_analyze + 64L) / 128L;
#line 463
  e = (mycounter_encode + 64L) / 128L;
#line 464
  t = (mycounter_total + 64L) / 128L;
#line 465
  if (! t) {
#line 465
    t = (off64_t )1;
  }
  {
#line 466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Analyze(%02u%%) Encode(%02u%%)\r",
          (unsigned int )((100L * a) / t), (unsigned int )((100L * e) / t));
  }
#line 471
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void decode_progress(void) 
{ 
  off64_t d ;
  off64_t t ;

  {
#line 474
  d = (mycounter_decode + 64L) / 128L;
#line 475
  t = (mycounter_total + 64L) / 128L;
#line 476
  if (! t) {
#line 476
    t = (off64_t )1;
  }
  {
#line 477
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decode(%02u%%)\r",
          (unsigned int )((100L * d) / t));
  }
#line 481
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void setcounter_analyze(off64_t n ) 
{ 
  int8_t p ;

  {
#line 484
  p = (int8_t )(n >> 20 != mycounter_analyze >> 20);
#line 485
  mycounter_analyze = n;
#line 486
  if (p) {
    {
#line 486
    encode_progress();
    }
  }
#line 487
  return;
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void setcounter_encode(off64_t n ) 
{ 
  int8_t p ;

  {
#line 490
  p = (int8_t )(n >> 20 != mycounter_encode >> 20);
#line 491
  mycounter_encode = n;
#line 492
  if (p) {
    {
#line 492
    encode_progress();
    }
  }
#line 493
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void setcounter_decode(off64_t n ) 
{ 
  int8_t p ;

  {
#line 496
  p = (int8_t )(n >> 20 != mycounter_decode >> 20);
#line 497
  mycounter_decode = n;
#line 498
  if (p) {
    {
#line 498
    decode_progress();
    }
  }
#line 499
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t write_sectors(int8_t type , uint32_t count , char const   *infilename ,
                            char const   *outfilename , FILE *in , FILE *out ) 
{ 
  int8_t returncode ;
  int8_t tmp ;
  uint32_t b ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  __off64_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  __off64_t tmp___10 ;

  {
  {
#line 515
  returncode = (int8_t )0;
#line 517
  tmp = write_type_count(outfilename, out, type, count);
  }
#line 517
  if (tmp) {
#line 517
    goto error;
  }
#line 519
  if ((int )type == 0) {
    {
#line 520
    while (1) {
      while_continue: /* CIL Label */ ;
#line 520
      if (! count) {
#line 520
        goto while_break;
      }
#line 521
      b = count;
#line 522
      if ((unsigned long )b > sizeof(sector_buffer)) {
#line 522
        b = (uint32_t )sizeof(sector_buffer);
      }
      {
#line 523
      tmp___0 = fread((void */* __restrict  */)(sector_buffer), (size_t )1, (size_t )b,
                      (FILE */* __restrict  */)in);
      }
#line 523
      if (tmp___0 != (size_t )b) {
#line 523
        goto error_in;
      }
      {
#line 524
      tmp___1 = fwrite((void const   */* __restrict  */)(sector_buffer), (size_t )1,
                       (size_t )b, (FILE */* __restrict  */)out);
      }
#line 524
      if (tmp___1 != (size_t )b) {
#line 524
        goto error_out;
      }
      {
#line 525
      count -= b;
#line 526
      tmp___2 = ftello64(in);
#line 526
      setcounter_encode(tmp___2);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 528
    return ((int8_t )0);
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! count) {
#line 530
      goto while_break___0;
    }
    {
#line 532
    if ((int )type == 1) {
#line 532
      goto case_1;
    }
#line 537
    if ((int )type == 2) {
#line 537
      goto case_2;
    }
#line 541
    if ((int )type == 3) {
#line 541
      goto case_3;
    }
#line 531
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 533
    tmp___3 = fread((void */* __restrict  */)(sector_buffer), (size_t )1, (size_t )2352,
                    (FILE */* __restrict  */)in);
    }
#line 533
    if (tmp___3 != 2352UL) {
#line 533
      goto error_in;
    }
    {
#line 534
    tmp___4 = fwrite((void const   */* __restrict  */)(sector_buffer + 12), (size_t )1,
                     (size_t )3, (FILE */* __restrict  */)out);
    }
#line 534
    if (tmp___4 != 3UL) {
#line 534
      goto error_out;
    }
    {
#line 535
    tmp___5 = fwrite((void const   */* __restrict  */)(sector_buffer + 16), (size_t )1,
                     (size_t )2048, (FILE */* __restrict  */)out);
    }
#line 535
    if (tmp___5 != 2048UL) {
#line 535
      goto error_out;
    }
#line 536
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 538
    tmp___6 = fread((void */* __restrict  */)(sector_buffer), (size_t )1, (size_t )2336,
                    (FILE */* __restrict  */)in);
    }
#line 538
    if (tmp___6 != 2336UL) {
#line 538
      goto error_in;
    }
    {
#line 539
    tmp___7 = fwrite((void const   */* __restrict  */)(sector_buffer + 4), (size_t )1,
                     (size_t )2052, (FILE */* __restrict  */)out);
    }
#line 539
    if (tmp___7 != 2052UL) {
#line 539
      goto error_out;
    }
#line 540
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 542
    tmp___8 = fread((void */* __restrict  */)(sector_buffer), (size_t )1, (size_t )2336,
                    (FILE */* __restrict  */)in);
    }
#line 542
    if (tmp___8 != 2336UL) {
#line 542
      goto error_in;
    }
    {
#line 543
    tmp___9 = fwrite((void const   */* __restrict  */)(sector_buffer + 4), (size_t )1,
                     (size_t )2328, (FILE */* __restrict  */)out);
    }
#line 543
    if (tmp___9 != 2328UL) {
#line 543
      goto error_out;
    }
#line 544
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 546
    tmp___10 = ftello64(in);
#line 546
    setcounter_encode(tmp___10);
#line 530
    count --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 551
  returncode = (int8_t )0;
#line 552
  goto done;
  error_in: 
  {
#line 555
  printfileerror(in, infilename);
  }
#line 556
  goto error;
  error_out: 
  {
#line 559
  printfileerror(out, outfilename);
  }
#line 560
  goto error;
  error: 
#line 563
  returncode = (int8_t )1;
#line 564
  goto done;
  done: 
#line 567
  return (returncode);
}
}
#line 604
static int8_t ecmify(char const   *infilename , char const   *outfilename ) ;
#line 604 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static size_t const   sectorsize[4]  = {      (size_t const   )1,      (size_t const   )2352,      (size_t const   )2336,      (size_t const   )2336};
#line 574 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t ecmify(char const   *infilename , char const   *outfilename ) 
{ 
  int8_t returncode ;
  FILE *in ;
  FILE *out ;
  uint8_t *queue ;
  size_t queue_start_ofs ;
  size_t queue_bytes_available ;
  uint32_t input_edc ;
  int8_t curtype ;
  uint32_t curtype_count ;
  off64_t curtype_in_start ;
  uint32_t literal_skip ;
  off64_t input_file_length ;
  off64_t input_bytes_checked ;
  off64_t input_bytes_queued ;
  off64_t typetally[4] ;
  size_t queue_size ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int8_t detecttype ;
  off64_t willread ;
  off64_t maxread ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int8_t tmp___8 ;
  int8_t tmp___9 ;
  size_t tmp___10 ;
  __off64_t tmp___11 ;

  {
#line 578
  returncode = (int8_t )0;
#line 580
  in = (FILE *)((void *)0);
#line 581
  out = (FILE *)((void *)0);
#line 583
  queue = (uint8_t *)((void *)0);
#line 584
  queue_start_ofs = (size_t )0;
#line 585
  queue_bytes_available = (size_t )0;
#line 587
  input_edc = (uint32_t )0;
#line 592
  curtype = (int8_t )-1;
#line 593
  curtype_count = (uint32_t )0;
#line 594
  curtype_in_start = (off64_t )0;
#line 596
  literal_skip = (uint32_t )0;
#line 599
  input_bytes_checked = (off64_t )0;
#line 600
  input_bytes_queued = (off64_t )0;
#line 602
  typetally[0] = (off64_t )0;
#line 602
  typetally[1] = (off64_t )0;
#line 602
  typetally[2] = (off64_t )0;
#line 602
  typetally[3] = (off64_t )0;
#line 611
  queue_size = 0xfffffffffffff000UL;
#line 612
  if (queue_size > 262144UL) {
#line 613
    queue_size = 262144UL;
  }
  {
#line 619
  tmp = malloc(queue_size);
#line 619
  queue = (uint8_t *)tmp;
  }
#line 620
  if (! queue) {
    {
#line 621
    printf((char const   */* __restrict  */)"Out of memory\n");
    }
#line 622
    goto error;
  }
  {
#line 628
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"rb");
  }
#line 629
  if (out) {
    {
#line 630
    printf((char const   */* __restrict  */)"Error: %s exists; refusing to overwrite\n",
           outfilename);
    }
#line 631
    goto error;
  }
  {
#line 637
  in = fopen((char const   */* __restrict  */)infilename, (char const   */* __restrict  */)"rb");
  }
#line 638
  if (! in) {
#line 638
    goto error_in;
  }
  {
#line 640
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"wb");
  }
#line 641
  if (! out) {
#line 641
    goto error_out;
  }
  {
#line 643
  printf((char const   */* __restrict  */)"Encoding %s to %s...\n", infilename, outfilename);
#line 648
  tmp___0 = fseeko64(in, (__off64_t )0, 2);
  }
#line 648
  if (tmp___0 != 0) {
#line 648
    goto error_in;
  }
  {
#line 649
  input_file_length = ftello64(in);
  }
#line 650
  if (input_file_length < 0L) {
#line 650
    goto error_in;
  }
  {
#line 652
  resetcounter(input_file_length);
#line 657
  tmp___1 = fputc('E', out);
  }
#line 657
  if (tmp___1 == -1) {
#line 657
    goto error_out;
  }
  {
#line 658
  tmp___2 = fputc('C', out);
  }
#line 658
  if (tmp___2 == -1) {
#line 658
    goto error_out;
  }
  {
#line 659
  tmp___3 = fputc('M', out);
  }
#line 659
  if (tmp___3 == -1) {
#line 659
    goto error_out;
  }
  {
#line 660
  tmp___4 = fputc(0, out);
  }
#line 660
  if (tmp___4 == -1) {
#line 660
    goto error_out;
  }
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (queue_bytes_available < 2352UL) {
#line 668
      if ((off64_t )queue_bytes_available < input_file_length - input_bytes_queued) {
#line 675
        willread = input_file_length - input_bytes_queued;
#line 676
        maxread = (off64_t )(queue_size - queue_bytes_available);
#line 677
        if (willread > maxread) {
#line 678
          willread = maxread;
        }
#line 681
        if (queue_start_ofs > 0UL) {
          {
#line 682
          memmove((void *)queue, (void const   *)(queue + queue_start_ofs), queue_bytes_available);
#line 683
          queue_start_ofs = (size_t )0;
          }
        }
#line 685
        if (willread) {
          {
#line 686
          setcounter_analyze(input_bytes_queued);
#line 688
          tmp___5 = fseeko64(in, input_bytes_queued, 0);
          }
#line 688
          if (tmp___5 != 0) {
#line 689
            goto error_in;
          }
          {
#line 691
          tmp___6 = fread((void */* __restrict  */)(queue + queue_bytes_available),
                          (size_t )1, (size_t )willread, (FILE */* __restrict  */)in);
          }
#line 691
          if (tmp___6 != (size_t )willread) {
#line 692
            goto error_in;
          }
          {
#line 695
          input_edc = edc_compute(input_edc, (uint8_t const   *)(queue + queue_bytes_available),
                                  (size_t )willread);
#line 701
          input_bytes_queued += willread;
#line 702
          queue_bytes_available += (size_t )willread;
          }
        }
      }
    }
#line 706
    if (queue_bytes_available == 0UL) {
#line 710
      detecttype = (int8_t )-1;
    } else
#line 712
    if (literal_skip > 0U) {
#line 716
      literal_skip --;
#line 717
      detecttype = (int8_t )0;
    } else
#line 723
    if ((int )curtype >= 2) {
#line 723
      if (queue_bytes_available >= 16UL) {
#line 723
        if ((int )*(queue + queue_start_ofs) == 0) {
#line 723
          if ((int )*(queue + (queue_start_ofs + 1UL)) == 255) {
#line 723
            if ((int )*(queue + (queue_start_ofs + 2UL)) == 255) {
#line 723
              if ((int )*(queue + (queue_start_ofs + 3UL)) == 255) {
#line 723
                if ((int )*(queue + (queue_start_ofs + 4UL)) == 255) {
#line 723
                  if ((int )*(queue + (queue_start_ofs + 5UL)) == 255) {
#line 723
                    if ((int )*(queue + (queue_start_ofs + 6UL)) == 255) {
#line 723
                      if ((int )*(queue + (queue_start_ofs + 7UL)) == 255) {
#line 723
                        if ((int )*(queue + (queue_start_ofs + 8UL)) == 255) {
#line 723
                          if ((int )*(queue + (queue_start_ofs + 9UL)) == 255) {
#line 723
                            if ((int )*(queue + (queue_start_ofs + 10UL)) == 255) {
#line 723
                              if ((int )*(queue + (queue_start_ofs + 11UL)) == 0) {
#line 723
                                if ((int )*(queue + (queue_start_ofs + 15UL)) == 2) {
#line 741
                                  detecttype = (int8_t )0;
#line 743
                                  literal_skip = (uint32_t )15;
                                } else {
                                  {
#line 748
                                  detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                             queue_bytes_available);
                                  }
                                }
                              } else {
                                {
#line 748
                                detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                           queue_bytes_available);
                                }
                              }
                            } else {
                              {
#line 748
                              detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                         queue_bytes_available);
                              }
                            }
                          } else {
                            {
#line 748
                            detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                       queue_bytes_available);
                            }
                          }
                        } else {
                          {
#line 748
                          detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                     queue_bytes_available);
                          }
                        }
                      } else {
                        {
#line 748
                        detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                   queue_bytes_available);
                        }
                      }
                    } else {
                      {
#line 748
                      detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                                 queue_bytes_available);
                      }
                    }
                  } else {
                    {
#line 748
                    detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                               queue_bytes_available);
                    }
                  }
                } else {
                  {
#line 748
                  detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                             queue_bytes_available);
                  }
                }
              } else {
                {
#line 748
                detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                           queue_bytes_available);
                }
              }
            } else {
              {
#line 748
              detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                         queue_bytes_available);
              }
            }
          } else {
            {
#line 748
            detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                       queue_bytes_available);
            }
          }
        } else {
          {
#line 748
          detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs),
                                     queue_bytes_available);
          }
        }
      } else {
        {
#line 748
        detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs), queue_bytes_available);
        }
      }
    } else {
      {
#line 748
      detecttype = detect_sector((uint8_t const   *)(queue + queue_start_ofs), queue_bytes_available);
      }
    }
#line 752
    if ((int )detecttype == (int )curtype) {
#line 752
      if (curtype_count <= 2147483647U) {
#line 759
        curtype_count ++;
      } else {
#line 752
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 765
      if (curtype_count > 0U) {
        {
#line 766
        tmp___7 = fseeko64(in, curtype_in_start, 0);
        }
#line 766
        if (tmp___7 != 0) {
#line 766
          goto error_in;
        }
        {
#line 767
        typetally[curtype] += (off64_t )curtype_count;
#line 768
        tmp___8 = write_sectors(curtype, curtype_count, infilename, outfilename, in,
                                out);
        }
#line 768
        if (tmp___8) {
#line 775
          goto error;
        }
      }
#line 777
      curtype = detecttype;
#line 778
      curtype_in_start = input_bytes_checked;
#line 779
      curtype_count = (uint32_t )1;
    }
#line 786
    if ((int )curtype < 0) {
#line 786
      goto while_break;
    }
#line 791
    input_bytes_checked = (off64_t )((size_t const   )input_bytes_checked + sectorsize[curtype]);
#line 792
    queue_start_ofs += (size_t )sectorsize[curtype];
#line 793
    queue_bytes_available -= (size_t )sectorsize[curtype];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 800
  tmp___9 = write_type_count(outfilename, out, (int8_t )0, (uint32_t )0);
  }
#line 800
  if (tmp___9) {
#line 800
    goto error;
  }
  {
#line 805
  put32lsb(sector_buffer, input_edc);
#line 806
  tmp___10 = fwrite((void const   */* __restrict  */)(sector_buffer), (size_t )1,
                    (size_t )4, (FILE */* __restrict  */)out);
  }
#line 806
  if (tmp___10 != 4UL) {
#line 806
    goto error_out;
  }
  {
#line 811
  printf((char const   */* __restrict  */)"Literal bytes........... ");
#line 811
  fprintdec(stdout, typetally[0]);
#line 811
  printf((char const   */* __restrict  */)"\n");
#line 812
  printf((char const   */* __restrict  */)"Mode 1 sectors.......... ");
#line 812
  fprintdec(stdout, typetally[1]);
#line 812
  printf((char const   */* __restrict  */)"\n");
#line 813
  printf((char const   */* __restrict  */)"Mode 2 form 1 sectors... ");
#line 813
  fprintdec(stdout, typetally[2]);
#line 813
  printf((char const   */* __restrict  */)"\n");
#line 814
  printf((char const   */* __restrict  */)"Mode 2 form 2 sectors... ");
#line 814
  fprintdec(stdout, typetally[3]);
#line 814
  printf((char const   */* __restrict  */)"\n");
#line 815
  printf((char const   */* __restrict  */)"Encoded ");
#line 816
  fprintdec(stdout, input_file_length);
#line 817
  printf((char const   */* __restrict  */)" bytes -> ");
#line 818
  tmp___11 = ftello64(out);
#line 818
  fprintdec(stdout, tmp___11);
#line 819
  printf((char const   */* __restrict  */)" bytes\n");
#line 824
  printf((char const   */* __restrict  */)"Done\n");
#line 825
  returncode = (int8_t )0;
  }
#line 826
  goto done;
  error_in: 
  {
#line 829
  printfileerror(in, infilename);
  }
#line 830
  goto error;
  error_out: 
  {
#line 833
  printfileerror(out, outfilename);
  }
#line 834
  goto error;
  error: 
#line 837
  returncode = (int8_t )1;
#line 838
  goto done;
  done: 
#line 841
  if ((unsigned long )queue != (unsigned long )((void *)0)) {
    {
#line 841
    free((void *)queue);
    }
  }
#line 842
  if ((unsigned long )in != (unsigned long )((void *)0)) {
    {
#line 842
    fclose(in);
    }
  }
#line 843
  if ((unsigned long )out != (unsigned long )((void *)0)) {
    {
#line 843
    fclose(out);
    }
  }
#line 845
  return (returncode);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t unecmify(char const   *infilename , char const   *outfilename ) 
{ 
  int8_t returncode ;
  FILE *in ;
  FILE *out ;
  off64_t input_file_length ;
  uint32_t output_edc ;
  int8_t type ;
  uint32_t num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int c ;
  int tmp___5 ;
  int bits ;
  uint32_t b ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  __off64_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  __off64_t tmp___16 ;
  size_t tmp___17 ;
  __off64_t tmp___18 ;
  __off64_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;

  {
  {
#line 856
  returncode = (int8_t )0;
#line 858
  in = (FILE *)((void *)0);
#line 859
  out = (FILE *)((void *)0);
#line 863
  output_edc = (uint32_t )0;
#line 870
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"rb");
  }
#line 871
  if (out) {
    {
#line 872
    printf((char const   */* __restrict  */)"Error: %s exists; refusing to overwrite\n",
           outfilename);
    }
#line 873
    goto error;
  }
  {
#line 879
  in = fopen((char const   */* __restrict  */)infilename, (char const   */* __restrict  */)"rb");
  }
#line 880
  if (! in) {
#line 880
    goto error_in;
  }
  {
#line 885
  tmp = fseeko64(in, (__off64_t )0, 2);
  }
#line 885
  if (tmp != 0) {
#line 885
    goto error_in;
  }
  {
#line 886
  input_file_length = ftello64(in);
  }
#line 887
  if (input_file_length < 0L) {
#line 887
    goto error_in;
  }
  {
#line 889
  resetcounter(input_file_length);
#line 891
  tmp___0 = fseeko64(in, (__off64_t )0, 0);
  }
#line 891
  if (tmp___0 != 0) {
#line 891
    goto error_in;
  }
  {
#line 896
  tmp___1 = fgetc(in);
  }
#line 896
  if (tmp___1 != 69) {
    {
#line 902
    printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
    }
#line 903
    goto error;
  } else {
    {
#line 896
    tmp___2 = fgetc(in);
    }
#line 896
    if (tmp___2 != 67) {
      {
#line 902
      printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
      }
#line 903
      goto error;
    } else {
      {
#line 896
      tmp___3 = fgetc(in);
      }
#line 896
      if (tmp___3 != 77) {
        {
#line 902
        printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
        }
#line 903
        goto error;
      } else {
        {
#line 896
        tmp___4 = fgetc(in);
        }
#line 896
        if (tmp___4 != 0) {
          {
#line 902
          printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
          }
#line 903
          goto error;
        }
      }
    }
  }
  {
#line 909
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"wb");
  }
#line 910
  if (! out) {
#line 910
    goto error_out;
  }
  {
#line 912
  printf((char const   */* __restrict  */)"Decoding %s to %s...\n", infilename, outfilename);
  }
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 915
    tmp___5 = fgetc(in);
#line 915
    c = tmp___5;
#line 916
    bits = 5;
    }
#line 917
    if (c == -1) {
#line 917
      goto error_in;
    }
#line 918
    type = (int8_t )(c & 3);
#line 919
    num = (uint32_t )((c >> 2) & 31);
    {
#line 920
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 920
      if (! (c & 128)) {
#line 920
        goto while_break___0;
      }
      {
#line 921
      c = fgetc(in);
      }
#line 922
      if (c == -1) {
#line 922
        goto error_in;
      }
#line 923
      if (bits > 31) {
        {
#line 927
        printf((char const   */* __restrict  */)"Corrupt ECM file; invalid sector count\n");
        }
#line 928
        goto error;
      } else
#line 923
      if ((uint32_t )(c & 127) >= 2147483648U >> (bits - 1)) {
        {
#line 927
        printf((char const   */* __restrict  */)"Corrupt ECM file; invalid sector count\n");
        }
#line 928
        goto error;
      }
#line 930
      num |= (uint32_t )(c & 127) << bits;
#line 931
      bits += 7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 933
    if (num == 4294967295U) {
#line 935
      goto while_break;
    }
#line 937
    num ++;
#line 938
    if ((int )type == 0) {
      {
#line 939
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 939
        if (! num) {
#line 939
          goto while_break___1;
        }
#line 940
        b = num;
#line 941
        if ((unsigned long )b > sizeof(sector_buffer)) {
#line 941
          b = (uint32_t )sizeof(sector_buffer);
        }
        {
#line 942
        tmp___6 = fread((void */* __restrict  */)(sector_buffer), (size_t )1, (size_t )b,
                        (FILE */* __restrict  */)in);
        }
#line 942
        if (tmp___6 != (size_t )b) {
#line 943
          goto error_in;
        }
        {
#line 945
        output_edc = edc_compute(output_edc, (uint8_t const   *)(sector_buffer), (size_t )b);
#line 946
        tmp___7 = fwrite((void const   */* __restrict  */)(sector_buffer), (size_t )1,
                         (size_t )b, (FILE */* __restrict  */)out);
        }
#line 946
        if (tmp___7 != (size_t )b) {
#line 947
          goto error_out;
        }
        {
#line 949
        num -= b;
#line 950
        tmp___8 = ftello64(in);
#line 950
        setcounter_decode(tmp___8);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 953
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 953
        if (! num) {
#line 953
          goto while_break___2;
        }
        {
#line 955
        if ((int )type == 1) {
#line 955
          goto case_1;
        }
#line 962
        if ((int )type == 2) {
#line 962
          goto case_2;
        }
#line 968
        if ((int )type == 3) {
#line 968
          goto case_3;
        }
#line 954
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 956
        tmp___9 = fread((void */* __restrict  */)(sector_buffer + 12), (size_t )1,
                        (size_t )3, (FILE */* __restrict  */)in);
        }
#line 956
        if (tmp___9 != 3UL) {
#line 956
          goto error_in;
        }
        {
#line 957
        tmp___10 = fread((void */* __restrict  */)(sector_buffer + 16), (size_t )1,
                         (size_t )2048, (FILE */* __restrict  */)in);
        }
#line 957
        if (tmp___10 != 2048UL) {
#line 957
          goto error_in;
        }
        {
#line 958
        reconstruct_sector(sector_buffer, (int8_t )1);
#line 959
        output_edc = edc_compute(output_edc, (uint8_t const   *)(sector_buffer), (size_t )2352);
#line 960
        tmp___11 = fwrite((void const   */* __restrict  */)(sector_buffer), (size_t )1,
                          (size_t )2352, (FILE */* __restrict  */)out);
        }
#line 960
        if (tmp___11 != 2352UL) {
#line 960
          goto error_out;
        }
#line 961
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 963
        tmp___12 = fread((void */* __restrict  */)(sector_buffer + 20), (size_t )1,
                         (size_t )2052, (FILE */* __restrict  */)in);
        }
#line 963
        if (tmp___12 != 2052UL) {
#line 963
          goto error_in;
        }
        {
#line 964
        reconstruct_sector(sector_buffer, (int8_t )2);
#line 965
        output_edc = edc_compute(output_edc, (uint8_t const   *)(sector_buffer + 16),
                                 (size_t )2336);
#line 966
        tmp___13 = fwrite((void const   */* __restrict  */)(sector_buffer + 16), (size_t )1,
                          (size_t )2336, (FILE */* __restrict  */)out);
        }
#line 966
        if (tmp___13 != 2336UL) {
#line 966
          goto error_out;
        }
#line 967
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 969
        tmp___14 = fread((void */* __restrict  */)(sector_buffer + 20), (size_t )1,
                         (size_t )2328, (FILE */* __restrict  */)in);
        }
#line 969
        if (tmp___14 != 2328UL) {
#line 969
          goto error_in;
        }
        {
#line 970
        reconstruct_sector(sector_buffer, (int8_t )3);
#line 971
        output_edc = edc_compute(output_edc, (uint8_t const   *)(sector_buffer + 16),
                                 (size_t )2336);
#line 972
        tmp___15 = fwrite((void const   */* __restrict  */)(sector_buffer + 16), (size_t )1,
                          (size_t )2336, (FILE */* __restrict  */)out);
        }
#line 972
        if (tmp___15 != 2336UL) {
#line 972
          goto error_out;
        }
#line 973
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 975
        tmp___16 = ftello64(in);
#line 975
        setcounter_decode(tmp___16);
#line 953
        num --;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 982
  tmp___17 = fread((void */* __restrict  */)(sector_buffer), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)in);
  }
#line 982
  if (tmp___17 != 4UL) {
#line 982
    goto error_in;
  }
  {
#line 984
  printf((char const   */* __restrict  */)"Decoded ");
#line 985
  tmp___18 = ftello64(in);
#line 985
  fprintdec(stdout, tmp___18);
#line 986
  printf((char const   */* __restrict  */)" bytes -> ");
#line 987
  tmp___19 = ftello64(out);
#line 987
  fprintdec(stdout, tmp___19);
#line 988
  printf((char const   */* __restrict  */)" bytes\n");
#line 990
  tmp___21 = get32lsb((uint8_t const   *)(sector_buffer));
  }
#line 990
  if (tmp___21 != output_edc) {
    {
#line 991
    tmp___20 = get32lsb((uint8_t const   *)(sector_buffer));
#line 991
    printf((char const   */* __restrict  */)"Checksum error (0x%08lX, should be 0x%08lX)\n",
           (unsigned long )output_edc, (unsigned long )tmp___20);
    }
#line 995
    goto error;
  }
  {
#line 1001
  printf((char const   */* __restrict  */)"Done\n");
#line 1002
  returncode = (int8_t )0;
  }
#line 1003
  goto done;
  error_in: 
  {
#line 1006
  printfileerror(in, infilename);
  }
#line 1007
  goto error;
  error_out: 
  {
#line 1010
  printfileerror(out, outfilename);
  }
#line 1011
  goto error;
  error: 
#line 1014
  returncode = (int8_t )1;
#line 1015
  goto done;
  done: 
#line 1018
  if ((unsigned long )in != (unsigned long )((void *)0)) {
    {
#line 1018
    fclose(in);
    }
  }
#line 1019
  if ((unsigned long )out != (unsigned long )((void *)0)) {
    {
#line 1019
    fclose(out);
    }
  }
#line 1021
  return (returncode);
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
int main(int argc , char **argv ) 
{ 
  int returncode ;
  int8_t encode ;
  char *infilename ;
  char *outfilename ;
  char *tempfilename ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t l ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int8_t tmp___9 ;
  int8_t tmp___10 ;

  {
  {
#line 1027
  returncode = 0;
#line 1028
  encode = (int8_t )0;
#line 1029
  infilename = (char *)((void *)0);
#line 1030
  outfilename = (char *)((void *)0);
#line 1031
  tempfilename = (char *)((void *)0);
#line 1033
  normalize_argv0(*(argv + 0));
  }
  {
#line 1039
  if (argc == 2) {
#line 1039
    goto case_2;
  }
#line 1083
  if (argc == 3) {
#line 1083
    goto case_3;
  }
#line 1093
  if (argc == 4) {
#line 1093
    goto case_4;
  }
#line 1109
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1044
  tmp = strcmp((char const   *)*(argv + 0), "ecm-uncompress");
#line 1044
  encode = (int8_t )(tmp != 0);
#line 1045
  infilename = *(argv + 1);
#line 1047
  tmp___0 = strlen((char const   *)infilename);
#line 1047
  tmp___1 = malloc(tmp___0 + 7UL);
#line 1047
  tempfilename = (char *)tmp___1;
  }
#line 1048
  if (! tempfilename) {
    {
#line 1049
    printf((char const   */* __restrict  */)"Out of memory\n");
    }
#line 1050
    goto error;
  }
  {
#line 1053
  strcpy((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)infilename);
  }
#line 1055
  if (encode) {
    {
#line 1059
    strcat((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)".ecm");
    }
  } else {
    {
#line 1064
    tmp___2 = strlen((char const   *)tempfilename);
#line 1064
    l = tmp___2;
    }
#line 1065
    if (l > 4UL) {
#line 1065
      if ((int )*(tempfilename + (l - 4UL)) == 46) {
        {
#line 1065
        tmp___3 = tolower((int )*(tempfilename + (l - 3UL)));
        }
#line 1065
        if (tmp___3 == 101) {
          {
#line 1065
          tmp___4 = tolower((int )*(tempfilename + (l - 2UL)));
          }
#line 1065
          if (tmp___4 == 99) {
            {
#line 1065
            tmp___5 = tolower((int )*(tempfilename + (l - 1UL)));
            }
#line 1065
            if (tmp___5 == 109) {
#line 1072
              *(tempfilename + (l - 4UL)) = (char)0;
            } else {
              {
#line 1077
              strcat((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)".unecm");
              }
            }
          } else {
            {
#line 1077
            strcat((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)".unecm");
            }
          }
        } else {
          {
#line 1077
          strcat((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)".unecm");
          }
        }
      } else {
        {
#line 1077
        strcat((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)".unecm");
        }
      }
    } else {
      {
#line 1077
      strcat((char */* __restrict  */)tempfilename, (char const   */* __restrict  */)".unecm");
      }
    }
  }
#line 1080
  outfilename = tempfilename;
#line 1081
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1088
  tmp___6 = strcmp((char const   *)*(argv + 0), "ecm-uncompress");
#line 1088
  encode = (int8_t )(tmp___6 != 0);
#line 1089
  infilename = *(argv + 1);
#line 1090
  outfilename = *(argv + 2);
  }
#line 1091
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1098
  tmp___8 = strcmp((char const   *)*(argv + 1), "e");
  }
#line 1098
  if (tmp___8) {
    {
#line 1100
    tmp___7 = strcmp((char const   *)*(argv + 1), "d");
    }
#line 1100
    if (tmp___7) {
#line 1103
      goto usage;
    } else {
#line 1101
      encode = (int8_t )0;
    }
  } else {
#line 1099
    encode = (int8_t )1;
  }
#line 1105
  infilename = *(argv + 2);
#line 1106
  outfilename = *(argv + 3);
#line 1107
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1110
  goto usage;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1116
  eccedc_init();
  }
#line 1121
  if (encode) {
    {
#line 1122
    tmp___9 = ecmify((char const   *)infilename, (char const   *)outfilename);
    }
#line 1122
    if (tmp___9) {
#line 1122
      goto error;
    }
  } else {
    {
#line 1124
    tmp___10 = unecmify((char const   *)infilename, (char const   *)outfilename);
    }
#line 1124
    if (tmp___10) {
#line 1124
      goto error;
    }
  }
#line 1130
  returncode = 0;
#line 1131
  goto done;
  usage: 
  {
#line 1134
  banner();
#line 1135
  printf((char const   */* __restrict  */)"Usage:\n\nTo encode:\n    ecm-compress cdimagefile\n    ecm-compress cdimagefile ecmfile\n    ecm-compress e cdimagefile ecmfile\n\nTo decode:\n    ecm-uncompress ecmfile\n    ecm-uncompress ecmfile cdimagefile\n    ecm-compress d ecmfile cdimagefile\n");
  }
  error: 
#line 1150
  returncode = 1;
#line 1151
  goto done;
  done: 
#line 1154
  if (tempfilename) {
    {
#line 1154
    free((void *)tempfilename);
    }
  }
#line 1155
  return (returncode);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/common.h"
static void fprintdec_digit___0(FILE *f , off64_t off ) 
{ 


  {
#line 349
  if (off == 0L) {
#line 349
    return;
  }
#line 350
  if (off >= 10L) {
    {
#line 351
    fprintdec_digit___0(f, off / 10L);
#line 352
    off %= 10L;
    }
  }
  {
#line 354
  fputc((int )(48L + off), f);
  }
#line 355
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/banner.h"
static void banner___0(void) 
{ 
  void (*tmp)(void) ;

  {
#line 62
  if (sizeof(off64_t ) >= sizeof(size_t )) {
#line 62
    tmp = & banner_ok;
  } else {
#line 62
    tmp = & banner_error;
  }
  {
#line 62
  (*tmp)();
#line 67
  atexit(& commandlinewarning);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint32_t get32lsb___0(uint8_t const   *src ) 
{ 


  {
#line 71
  return ((((uint32_t )*(src + 0) | ((uint32_t )*(src + 1) << 8)) | ((uint32_t )*(src + 2) << 16)) | ((uint32_t )*(src + 3) << 24));
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void put32lsb___0(uint8_t *dest , uint32_t value ) 
{ 


  {
#line 79
  *(dest + 0) = (uint8_t )value;
#line 80
  *(dest + 1) = (uint8_t )(value >> 8);
#line 81
  *(dest + 2) = (uint8_t )(value >> 16);
#line 82
  *(dest + 3) = (uint8_t )(value >> 24);
#line 83
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t ecc_f_lut___0[256]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t ecc_b_lut___0[256]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint32_t edc_lut___0[256]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void eccedc_init___0(void) 
{ 
  size_t i ;
  uint32_t edc ;
  size_t j ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 95
  i = (size_t )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 256UL)) {
#line 95
      goto while_break;
    }
#line 96
    edc = (uint32_t )i;
#line 97
    if (i & 128UL) {
#line 97
      tmp = 285;
    } else {
#line 97
      tmp = 0;
    }
#line 97
    j = (i << 1) ^ (unsigned long )tmp;
#line 98
    ecc_f_lut___0[i] = (uint8_t )j;
#line 99
    ecc_b_lut___0[i ^ j] = (uint8_t )i;
#line 100
    j = (size_t )0;
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < 8UL)) {
#line 100
        goto while_break___0;
      }
#line 101
      if (edc & 1U) {
#line 101
        tmp___0 = 3623976961U;
      } else {
#line 101
        tmp___0 = 0U;
      }
#line 101
      edc = (edc >> 1) ^ tmp___0;
#line 100
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    edc_lut___0[i] = edc;
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint32_t edc_compute___0(uint32_t edc , uint8_t const   *src , size_t size ) 
{ 
  uint8_t const   *tmp ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! size) {
#line 116
      goto while_break;
    }
#line 117
    tmp = src;
#line 117
    src ++;
#line 117
    edc = (edc >> 8) ^ edc_lut___0[(edc ^ (unsigned int )*tmp) & 255U];
#line 116
    size --;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (edc);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t ecc_checkpq___0(uint8_t const   *address , uint8_t const   *data , size_t major_count ,
                              size_t minor_count , size_t major_mult , size_t minor_inc ,
                              uint8_t const   *ecc ) 
{ 
  size_t size ;
  size_t major ;
  size_t index___0 ;
  uint8_t ecc_a ;
  uint8_t ecc_b ;
  size_t minor ;
  uint8_t temp ;

  {
#line 136
  size = major_count * minor_count;
#line 138
  major = (size_t )0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (major < major_count)) {
#line 138
      goto while_break;
    }
#line 139
    index___0 = (major >> 1) * major_mult + (major & 1UL);
#line 140
    ecc_a = (uint8_t )0;
#line 141
    ecc_b = (uint8_t )0;
#line 143
    minor = (size_t )0;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! (minor < minor_count)) {
#line 143
        goto while_break___0;
      }
#line 145
      if (index___0 < 4UL) {
#line 146
        temp = (uint8_t )*(address + index___0);
      } else {
#line 148
        temp = (uint8_t )*(data + (index___0 - 4UL));
      }
#line 150
      index___0 += minor_inc;
#line 151
      if (index___0 >= size) {
#line 151
        index___0 -= size;
      }
#line 152
      ecc_a = (uint8_t )((int )ecc_a ^ (int )temp);
#line 153
      ecc_b = (uint8_t )((int )ecc_b ^ (int )temp);
#line 154
      ecc_a = ecc_f_lut___0[ecc_a];
#line 143
      minor ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    ecc_a = ecc_b_lut___0[(int )ecc_f_lut___0[ecc_a] ^ (int )ecc_b];
#line 157
    if ((int const   )*(ecc + major) != (int const   )ecc_a) {
#line 161
      return ((int8_t )0);
    } else
#line 157
    if ((int const   )*(ecc + (major + major_count)) != (int const   )((int )ecc_a ^ (int )ecc_b)) {
#line 161
      return ((int8_t )0);
    }
#line 138
    major ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return ((int8_t )1);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void ecc_writepq___0(uint8_t const   *address , uint8_t const   *data , size_t major_count ,
                            size_t minor_count , size_t major_mult , size_t minor_inc ,
                            uint8_t *ecc ) 
{ 
  size_t size ;
  size_t major ;
  size_t index___0 ;
  uint8_t ecc_a ;
  uint8_t ecc_b ;
  size_t minor ;
  uint8_t temp ;

  {
#line 179
  size = major_count * minor_count;
#line 181
  major = (size_t )0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (major < major_count)) {
#line 181
      goto while_break;
    }
#line 182
    index___0 = (major >> 1) * major_mult + (major & 1UL);
#line 183
    ecc_a = (uint8_t )0;
#line 184
    ecc_b = (uint8_t )0;
#line 186
    minor = (size_t )0;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! (minor < minor_count)) {
#line 186
        goto while_break___0;
      }
#line 188
      if (index___0 < 4UL) {
#line 189
        temp = (uint8_t )*(address + index___0);
      } else {
#line 191
        temp = (uint8_t )*(data + (index___0 - 4UL));
      }
#line 193
      index___0 += minor_inc;
#line 194
      if (index___0 >= size) {
#line 194
        index___0 -= size;
      }
#line 195
      ecc_a = (uint8_t )((int )ecc_a ^ (int )temp);
#line 196
      ecc_b = (uint8_t )((int )ecc_b ^ (int )temp);
#line 197
      ecc_a = ecc_f_lut___0[ecc_a];
#line 186
      minor ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 199
    ecc_a = ecc_b_lut___0[(int )ecc_f_lut___0[ecc_a] ^ (int )ecc_b];
#line 200
    *(ecc + major) = ecc_a;
#line 201
    *(ecc + (major + major_count)) = (uint8_t )((int )ecc_a ^ (int )ecc_b);
#line 181
    major ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t ecc_checksector___0(uint8_t const   *address , uint8_t const   *data ,
                                  uint8_t const   *ecc ) 
{ 
  int8_t tmp ;
  int8_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 214
  tmp = ecc_checkpq___0(address, data, (size_t )86, (size_t )24, (size_t )2, (size_t )86,
                        ecc);
  }
#line 214
  if (tmp) {
    {
#line 214
    tmp___0 = ecc_checkpq___0(address, data, (size_t )52, (size_t )43, (size_t )86,
                              (size_t )88, ecc + 172);
    }
#line 214
    if (tmp___0) {
#line 214
      tmp___1 = 1;
    } else {
#line 214
      tmp___1 = 0;
    }
  } else {
#line 214
    tmp___1 = 0;
  }
#line 214
  return ((int8_t )tmp___1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void ecc_writesector___0(uint8_t const   *address , uint8_t const   *data ,
                                uint8_t *ecc ) 
{ 


  {
  {
#line 227
  ecc_writepq___0(address, data, (size_t )86, (size_t )24, (size_t )2, (size_t )86,
                  ecc);
#line 228
  ecc_writepq___0(address, data, (size_t )52, (size_t )43, (size_t )86, (size_t )88,
                  ecc + 172);
  }
#line 229
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t const   zeroaddress___0[4]  = {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0};
#line 245 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t detect_sector___0(uint8_t const   *sector , size_t size_available ) 
{ 
  int8_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int8_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 246
  if (size_available >= 2352UL) {
#line 246
    if ((int const   )*(sector + 0) == 0) {
#line 246
      if ((int const   )*(sector + 1) == 255) {
#line 246
        if ((int const   )*(sector + 2) == 255) {
#line 246
          if ((int const   )*(sector + 3) == 255) {
#line 246
            if ((int const   )*(sector + 4) == 255) {
#line 246
              if ((int const   )*(sector + 5) == 255) {
#line 246
                if ((int const   )*(sector + 6) == 255) {
#line 246
                  if ((int const   )*(sector + 7) == 255) {
#line 246
                    if ((int const   )*(sector + 8) == 255) {
#line 246
                      if ((int const   )*(sector + 9) == 255) {
#line 246
                        if ((int const   )*(sector + 10) == 255) {
#line 246
                          if ((int const   )*(sector + 11) == 0) {
#line 246
                            if ((int const   )*(sector + 15) == 1) {
#line 246
                              if ((int const   )*(sector + 2068) == 0) {
#line 246
                                if ((int const   )*(sector + 2069) == 0) {
#line 246
                                  if ((int const   )*(sector + 2070) == 0) {
#line 246
                                    if ((int const   )*(sector + 2071) == 0) {
#line 246
                                      if ((int const   )*(sector + 2072) == 0) {
#line 246
                                        if ((int const   )*(sector + 2073) == 0) {
#line 246
                                          if ((int const   )*(sector + 2074) == 0) {
#line 246
                                            if ((int const   )*(sector + 2075) == 0) {
                                              {
#line 273
                                              tmp = ecc_checksector___0(sector + 12,
                                                                        sector + 16,
                                                                        sector + 2076);
                                              }
#line 273
                                              if (tmp) {
                                                {
#line 273
                                                tmp___0 = edc_compute___0((uint32_t )0,
                                                                          sector,
                                                                          (size_t )2064);
#line 273
                                                tmp___1 = get32lsb___0(sector + 2064);
                                                }
#line 273
                                                if (tmp___0 == tmp___1) {
#line 281
                                                  return ((int8_t )1);
                                                }
                                              }
                                            } else {
#line 246
                                              goto _L___19;
                                            }
                                          } else {
#line 246
                                            goto _L___19;
                                          }
                                        } else {
#line 246
                                          goto _L___19;
                                        }
                                      } else {
#line 246
                                        goto _L___19;
                                      }
                                    } else {
#line 246
                                      goto _L___19;
                                    }
                                  } else {
#line 246
                                    goto _L___19;
                                  }
                                } else {
#line 246
                                  goto _L___19;
                                }
                              } else {
#line 246
                                goto _L___19;
                              }
                            } else {
#line 246
                              goto _L___19;
                            }
                          } else {
#line 246
                            goto _L___19;
                          }
                        } else {
#line 246
                          goto _L___19;
                        }
                      } else {
#line 246
                        goto _L___19;
                      }
                    } else {
#line 246
                      goto _L___19;
                    }
                  } else {
#line 246
                    goto _L___19;
                  }
                } else {
#line 246
                  goto _L___19;
                }
              } else {
#line 246
                goto _L___19;
              }
            } else {
#line 246
              goto _L___19;
            }
          } else {
#line 246
            goto _L___19;
          }
        } else {
#line 246
          goto _L___19;
        }
      } else {
#line 246
        goto _L___19;
      }
    } else {
#line 246
      goto _L___19;
    }
  } else
  _L___19: /* CIL Label */ 
#line 284
  if (size_available >= 2336UL) {
#line 284
    if ((int const   )*(sector + 0) == (int const   )*(sector + 4)) {
#line 284
      if ((int const   )*(sector + 1) == (int const   )*(sector + 5)) {
#line 284
        if ((int const   )*(sector + 2) == (int const   )*(sector + 6)) {
#line 284
          if ((int const   )*(sector + 3) == (int const   )*(sector + 7)) {
            {
#line 294
            tmp___2 = ecc_checksector___0(zeroaddress___0, sector, sector + 2060);
            }
#line 294
            if (tmp___2) {
              {
#line 294
              tmp___3 = edc_compute___0((uint32_t )0, sector, (size_t )2056);
#line 294
              tmp___4 = get32lsb___0(sector + 2056);
              }
#line 294
              if (tmp___3 == tmp___4) {
#line 302
                return ((int8_t )2);
              }
            }
            {
#line 307
            tmp___5 = edc_compute___0((uint32_t )0, sector, (size_t )2332);
#line 307
            tmp___6 = get32lsb___0(sector + 2332);
            }
#line 307
            if (tmp___5 == tmp___6) {
#line 310
              return ((int8_t )3);
            }
          }
        }
      }
    }
  }
#line 317
  return ((int8_t )0);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void reconstruct_sector___0(uint8_t *sector , int8_t type ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 331
  *(sector + 0) = (uint8_t )0;
#line 332
  *(sector + 1) = (uint8_t )255;
#line 333
  *(sector + 2) = (uint8_t )255;
#line 334
  *(sector + 3) = (uint8_t )255;
#line 335
  *(sector + 4) = (uint8_t )255;
#line 336
  *(sector + 5) = (uint8_t )255;
#line 337
  *(sector + 6) = (uint8_t )255;
#line 338
  *(sector + 7) = (uint8_t )255;
#line 339
  *(sector + 8) = (uint8_t )255;
#line 340
  *(sector + 9) = (uint8_t )255;
#line 341
  *(sector + 10) = (uint8_t )255;
#line 342
  *(sector + 11) = (uint8_t )0;
  {
#line 345
  if ((int )type == 1) {
#line 345
    goto case_1;
  }
#line 363
  if ((int )type == 3) {
#line 363
    goto case_3;
  }
#line 363
  if ((int )type == 2) {
#line 363
    goto case_3;
  }
#line 344
  goto switch_break;
  case_1: /* CIL Label */ 
#line 349
  *(sector + 15) = (uint8_t )1;
#line 353
  *(sector + 2068) = (uint8_t )0;
#line 354
  *(sector + 2069) = (uint8_t )0;
#line 355
  *(sector + 2070) = (uint8_t )0;
#line 356
  *(sector + 2071) = (uint8_t )0;
#line 357
  *(sector + 2072) = (uint8_t )0;
#line 358
  *(sector + 2073) = (uint8_t )0;
#line 359
  *(sector + 2074) = (uint8_t )0;
#line 360
  *(sector + 2075) = (uint8_t )0;
#line 361
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 367
  *(sector + 15) = (uint8_t )2;
#line 371
  *(sector + 16) = *(sector + 20);
#line 372
  *(sector + 17) = *(sector + 21);
#line 373
  *(sector + 18) = *(sector + 22);
#line 374
  *(sector + 19) = *(sector + 23);
#line 375
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 382
  if ((int )type == 1) {
#line 382
    goto case_1___0;
  }
#line 383
  if ((int )type == 2) {
#line 383
    goto case_2___0;
  }
#line 384
  if ((int )type == 3) {
#line 384
    goto case_3___0;
  }
#line 381
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 382
  tmp = edc_compute___0((uint32_t )0, (uint8_t const   *)sector, (size_t )2064);
#line 382
  put32lsb___0(sector + 2064, tmp);
  }
#line 382
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 383
  tmp___0 = edc_compute___0((uint32_t )0, (uint8_t const   *)(sector + 16), (size_t )2056);
#line 383
  put32lsb___0(sector + 2072, tmp___0);
  }
#line 383
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 384
  tmp___1 = edc_compute___0((uint32_t )0, (uint8_t const   *)(sector + 16), (size_t )2332);
#line 384
  put32lsb___0(sector + 2348, tmp___1);
  }
#line 384
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 391
  if ((int )type == 1) {
#line 391
    goto case_1___1;
  }
#line 392
  if ((int )type == 2) {
#line 392
    goto case_2___1;
  }
#line 390
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 391
  ecc_writesector___0((uint8_t const   *)(sector + 12), (uint8_t const   *)(sector + 16),
                      sector + 2076);
  }
#line 391
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 392
  ecc_writesector___0(zeroaddress___0, (uint8_t const   *)(sector + 16), sector + 2076);
  }
#line 392
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 398
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t write_type_count___0(char const   *outfilename , FILE *out , int8_t type ,
                                   uint32_t count ) 
{ 
  int8_t returncode ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 412
  returncode = (int8_t )0;
#line 414
  count --;
#line 415
  tmp = fputc((int )(((unsigned int )((count >= 32U) << 7) | ((count & 31U) << 2)) | (unsigned int )type),
              out);
  }
#line 415
  if (tmp == -1) {
#line 416
    goto error_out;
  }
#line 418
  count >>= 5;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! count) {
#line 419
      goto while_break;
    }
    {
#line 420
    tmp___0 = fputc((int )((unsigned int )((count >= 128U) << 7) | (count & 127U)),
                    out);
    }
#line 420
    if (tmp___0 == -1) {
#line 421
      goto error_out;
    }
#line 423
    count >>= 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  returncode = (int8_t )0;
#line 429
  goto done;
  error_out: 
  {
#line 432
  printfileerror(out, outfilename);
  }
#line 433
  goto error;
  error: 
#line 436
  returncode = (int8_t )1;
#line 437
  goto done;
  done: 
#line 440
  return (returncode);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static uint8_t sector_buffer___0[2352]  ;
#line 449 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_analyze___0  =    (off64_t )-1;
#line 450 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_encode___0  =    (off64_t )-1;
#line 451 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_decode___0  =    (off64_t )-1;
#line 452 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static off64_t mycounter_total___0  =    (off64_t )0;
#line 454 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void resetcounter___0(off64_t total ) 
{ 


  {
#line 455
  mycounter_analyze___0 = (off64_t )-1;
#line 456
  mycounter_encode___0 = (off64_t )-1;
#line 457
  mycounter_decode___0 = (off64_t )-1;
#line 458
  mycounter_total___0 = total;
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void encode_progress___0(void) 
{ 
  off64_t a ;
  off64_t e ;
  off64_t t ;

  {
#line 462
  a = (mycounter_analyze___0 + 64L) / 128L;
#line 463
  e = (mycounter_encode___0 + 64L) / 128L;
#line 464
  t = (mycounter_total___0 + 64L) / 128L;
#line 465
  if (! t) {
#line 465
    t = (off64_t )1;
  }
  {
#line 466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Analyze(%02u%%) Encode(%02u%%)\r",
          (unsigned int )((100L * a) / t), (unsigned int )((100L * e) / t));
  }
#line 471
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void decode_progress___0(void) 
{ 
  off64_t d ;
  off64_t t ;

  {
#line 474
  d = (mycounter_decode___0 + 64L) / 128L;
#line 475
  t = (mycounter_total___0 + 64L) / 128L;
#line 476
  if (! t) {
#line 476
    t = (off64_t )1;
  }
  {
#line 477
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decode(%02u%%)\r",
          (unsigned int )((100L * d) / t));
  }
#line 481
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void setcounter_analyze___0(off64_t n ) 
{ 
  int8_t p ;

  {
#line 484
  p = (int8_t )(n >> 20 != mycounter_analyze___0 >> 20);
#line 485
  mycounter_analyze___0 = n;
#line 486
  if (p) {
    {
#line 486
    encode_progress___0();
    }
  }
#line 487
  return;
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void setcounter_encode___0(off64_t n ) 
{ 
  int8_t p ;

  {
#line 490
  p = (int8_t )(n >> 20 != mycounter_encode___0 >> 20);
#line 491
  mycounter_encode___0 = n;
#line 492
  if (p) {
    {
#line 492
    encode_progress___0();
    }
  }
#line 493
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static void setcounter_decode___0(off64_t n ) 
{ 
  int8_t p ;

  {
#line 496
  p = (int8_t )(n >> 20 != mycounter_decode___0 >> 20);
#line 497
  mycounter_decode___0 = n;
#line 498
  if (p) {
    {
#line 498
    decode_progress___0();
    }
  }
#line 499
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t write_sectors___0(int8_t type , uint32_t count , char const   *infilename ,
                                char const   *outfilename , FILE *in , FILE *out ) 
{ 
  int8_t returncode ;
  int8_t tmp ;
  uint32_t b ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  __off64_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  __off64_t tmp___10 ;

  {
  {
#line 515
  returncode = (int8_t )0;
#line 517
  tmp = write_type_count___0(outfilename, out, type, count);
  }
#line 517
  if (tmp) {
#line 517
    goto error;
  }
#line 519
  if ((int )type == 0) {
    {
#line 520
    while (1) {
      while_continue: /* CIL Label */ ;
#line 520
      if (! count) {
#line 520
        goto while_break;
      }
#line 521
      b = count;
#line 522
      if ((unsigned long )b > sizeof(sector_buffer___0)) {
#line 522
        b = (uint32_t )sizeof(sector_buffer___0);
      }
      {
#line 523
      tmp___0 = fread((void */* __restrict  */)(sector_buffer___0), (size_t )1, (size_t )b,
                      (FILE */* __restrict  */)in);
      }
#line 523
      if (tmp___0 != (size_t )b) {
#line 523
        goto error_in;
      }
      {
#line 524
      tmp___1 = fwrite((void const   */* __restrict  */)(sector_buffer___0), (size_t )1,
                       (size_t )b, (FILE */* __restrict  */)out);
      }
#line 524
      if (tmp___1 != (size_t )b) {
#line 524
        goto error_out;
      }
      {
#line 525
      count -= b;
#line 526
      tmp___2 = ftello64(in);
#line 526
      setcounter_encode___0(tmp___2);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 528
    return ((int8_t )0);
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! count) {
#line 530
      goto while_break___0;
    }
    {
#line 532
    if ((int )type == 1) {
#line 532
      goto case_1;
    }
#line 537
    if ((int )type == 2) {
#line 537
      goto case_2;
    }
#line 541
    if ((int )type == 3) {
#line 541
      goto case_3;
    }
#line 531
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 533
    tmp___3 = fread((void */* __restrict  */)(sector_buffer___0), (size_t )1, (size_t )2352,
                    (FILE */* __restrict  */)in);
    }
#line 533
    if (tmp___3 != 2352UL) {
#line 533
      goto error_in;
    }
    {
#line 534
    tmp___4 = fwrite((void const   */* __restrict  */)(sector_buffer___0 + 12), (size_t )1,
                     (size_t )3, (FILE */* __restrict  */)out);
    }
#line 534
    if (tmp___4 != 3UL) {
#line 534
      goto error_out;
    }
    {
#line 535
    tmp___5 = fwrite((void const   */* __restrict  */)(sector_buffer___0 + 16), (size_t )1,
                     (size_t )2048, (FILE */* __restrict  */)out);
    }
#line 535
    if (tmp___5 != 2048UL) {
#line 535
      goto error_out;
    }
#line 536
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 538
    tmp___6 = fread((void */* __restrict  */)(sector_buffer___0), (size_t )1, (size_t )2336,
                    (FILE */* __restrict  */)in);
    }
#line 538
    if (tmp___6 != 2336UL) {
#line 538
      goto error_in;
    }
    {
#line 539
    tmp___7 = fwrite((void const   */* __restrict  */)(sector_buffer___0 + 4), (size_t )1,
                     (size_t )2052, (FILE */* __restrict  */)out);
    }
#line 539
    if (tmp___7 != 2052UL) {
#line 539
      goto error_out;
    }
#line 540
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 542
    tmp___8 = fread((void */* __restrict  */)(sector_buffer___0), (size_t )1, (size_t )2336,
                    (FILE */* __restrict  */)in);
    }
#line 542
    if (tmp___8 != 2336UL) {
#line 542
      goto error_in;
    }
    {
#line 543
    tmp___9 = fwrite((void const   */* __restrict  */)(sector_buffer___0 + 4), (size_t )1,
                     (size_t )2328, (FILE */* __restrict  */)out);
    }
#line 543
    if (tmp___9 != 2328UL) {
#line 543
      goto error_out;
    }
#line 544
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 546
    tmp___10 = ftello64(in);
#line 546
    setcounter_encode___0(tmp___10);
#line 530
    count --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 551
  returncode = (int8_t )0;
#line 552
  goto done;
  error_in: 
  {
#line 555
  printfileerror(in, infilename);
  }
#line 556
  goto error;
  error_out: 
  {
#line 559
  printfileerror(out, outfilename);
  }
#line 560
  goto error;
  error: 
#line 563
  returncode = (int8_t )1;
#line 564
  goto done;
  done: 
#line 567
  return (returncode);
}
}
#line 604
static int8_t ecmify___0(char const   *infilename , char const   *outfilename ) ;
#line 604 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static size_t const   sectorsize___0[4]  = {      (size_t const   )1,      (size_t const   )2352,      (size_t const   )2336,      (size_t const   )2336};
#line 574 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t ecmify___0(char const   *infilename , char const   *outfilename ) 
{ 
  int8_t returncode ;
  FILE *in ;
  FILE *out ;
  uint8_t *queue ;
  size_t queue_start_ofs ;
  size_t queue_bytes_available ;
  uint32_t input_edc ;
  int8_t curtype ;
  uint32_t curtype_count ;
  off64_t curtype_in_start ;
  uint32_t literal_skip ;
  off64_t input_file_length ;
  off64_t input_bytes_checked ;
  off64_t input_bytes_queued ;
  off64_t typetally[4] ;
  size_t queue_size ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int8_t detecttype ;
  off64_t willread ;
  off64_t maxread ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int8_t tmp___8 ;
  int8_t tmp___9 ;
  size_t tmp___10 ;
  __off64_t tmp___11 ;

  {
#line 578
  returncode = (int8_t )0;
#line 580
  in = (FILE *)((void *)0);
#line 581
  out = (FILE *)((void *)0);
#line 583
  queue = (uint8_t *)((void *)0);
#line 584
  queue_start_ofs = (size_t )0;
#line 585
  queue_bytes_available = (size_t )0;
#line 587
  input_edc = (uint32_t )0;
#line 592
  curtype = (int8_t )-1;
#line 593
  curtype_count = (uint32_t )0;
#line 594
  curtype_in_start = (off64_t )0;
#line 596
  literal_skip = (uint32_t )0;
#line 599
  input_bytes_checked = (off64_t )0;
#line 600
  input_bytes_queued = (off64_t )0;
#line 602
  typetally[0] = (off64_t )0;
#line 602
  typetally[1] = (off64_t )0;
#line 602
  typetally[2] = (off64_t )0;
#line 602
  typetally[3] = (off64_t )0;
#line 611
  queue_size = 0xfffffffffffff000UL;
#line 612
  if (queue_size > 262144UL) {
#line 613
    queue_size = 262144UL;
  }
  {
#line 619
  tmp = malloc(queue_size);
#line 619
  queue = (uint8_t *)tmp;
  }
#line 620
  if (! queue) {
    {
#line 621
    printf((char const   */* __restrict  */)"Out of memory\n");
    }
#line 622
    goto error;
  }
  {
#line 628
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"rb");
  }
#line 629
  if (out) {
    {
#line 630
    printf((char const   */* __restrict  */)"Error: %s exists; refusing to overwrite\n",
           outfilename);
    }
#line 631
    goto error;
  }
  {
#line 637
  in = fopen((char const   */* __restrict  */)infilename, (char const   */* __restrict  */)"rb");
  }
#line 638
  if (! in) {
#line 638
    goto error_in;
  }
  {
#line 640
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"wb");
  }
#line 641
  if (! out) {
#line 641
    goto error_out;
  }
  {
#line 643
  printf((char const   */* __restrict  */)"Encoding %s to %s...\n", infilename, outfilename);
#line 648
  tmp___0 = fseeko64(in, (__off64_t )0, 2);
  }
#line 648
  if (tmp___0 != 0) {
#line 648
    goto error_in;
  }
  {
#line 649
  input_file_length = ftello64(in);
  }
#line 650
  if (input_file_length < 0L) {
#line 650
    goto error_in;
  }
  {
#line 652
  resetcounter___0(input_file_length);
#line 657
  tmp___1 = fputc('E', out);
  }
#line 657
  if (tmp___1 == -1) {
#line 657
    goto error_out;
  }
  {
#line 658
  tmp___2 = fputc('C', out);
  }
#line 658
  if (tmp___2 == -1) {
#line 658
    goto error_out;
  }
  {
#line 659
  tmp___3 = fputc('M', out);
  }
#line 659
  if (tmp___3 == -1) {
#line 659
    goto error_out;
  }
  {
#line 660
  tmp___4 = fputc(0, out);
  }
#line 660
  if (tmp___4 == -1) {
#line 660
    goto error_out;
  }
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (queue_bytes_available < 2352UL) {
#line 668
      if ((off64_t )queue_bytes_available < input_file_length - input_bytes_queued) {
#line 675
        willread = input_file_length - input_bytes_queued;
#line 676
        maxread = (off64_t )(queue_size - queue_bytes_available);
#line 677
        if (willread > maxread) {
#line 678
          willread = maxread;
        }
#line 681
        if (queue_start_ofs > 0UL) {
          {
#line 682
          memmove((void *)queue, (void const   *)(queue + queue_start_ofs), queue_bytes_available);
#line 683
          queue_start_ofs = (size_t )0;
          }
        }
#line 685
        if (willread) {
          {
#line 686
          setcounter_analyze___0(input_bytes_queued);
#line 688
          tmp___5 = fseeko64(in, input_bytes_queued, 0);
          }
#line 688
          if (tmp___5 != 0) {
#line 689
            goto error_in;
          }
          {
#line 691
          tmp___6 = fread((void */* __restrict  */)(queue + queue_bytes_available),
                          (size_t )1, (size_t )willread, (FILE */* __restrict  */)in);
          }
#line 691
          if (tmp___6 != (size_t )willread) {
#line 692
            goto error_in;
          }
          {
#line 695
          input_edc = edc_compute___0(input_edc, (uint8_t const   *)(queue + queue_bytes_available),
                                      (size_t )willread);
#line 701
          input_bytes_queued += willread;
#line 702
          queue_bytes_available += (size_t )willread;
          }
        }
      }
    }
#line 706
    if (queue_bytes_available == 0UL) {
#line 710
      detecttype = (int8_t )-1;
    } else
#line 712
    if (literal_skip > 0U) {
#line 716
      literal_skip --;
#line 717
      detecttype = (int8_t )0;
    } else
#line 723
    if ((int )curtype >= 2) {
#line 723
      if (queue_bytes_available >= 16UL) {
#line 723
        if ((int )*(queue + queue_start_ofs) == 0) {
#line 723
          if ((int )*(queue + (queue_start_ofs + 1UL)) == 255) {
#line 723
            if ((int )*(queue + (queue_start_ofs + 2UL)) == 255) {
#line 723
              if ((int )*(queue + (queue_start_ofs + 3UL)) == 255) {
#line 723
                if ((int )*(queue + (queue_start_ofs + 4UL)) == 255) {
#line 723
                  if ((int )*(queue + (queue_start_ofs + 5UL)) == 255) {
#line 723
                    if ((int )*(queue + (queue_start_ofs + 6UL)) == 255) {
#line 723
                      if ((int )*(queue + (queue_start_ofs + 7UL)) == 255) {
#line 723
                        if ((int )*(queue + (queue_start_ofs + 8UL)) == 255) {
#line 723
                          if ((int )*(queue + (queue_start_ofs + 9UL)) == 255) {
#line 723
                            if ((int )*(queue + (queue_start_ofs + 10UL)) == 255) {
#line 723
                              if ((int )*(queue + (queue_start_ofs + 11UL)) == 0) {
#line 723
                                if ((int )*(queue + (queue_start_ofs + 15UL)) == 2) {
#line 741
                                  detecttype = (int8_t )0;
#line 743
                                  literal_skip = (uint32_t )15;
                                } else {
                                  {
#line 748
                                  detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                                 queue_bytes_available);
                                  }
                                }
                              } else {
                                {
#line 748
                                detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                               queue_bytes_available);
                                }
                              }
                            } else {
                              {
#line 748
                              detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                             queue_bytes_available);
                              }
                            }
                          } else {
                            {
#line 748
                            detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                           queue_bytes_available);
                            }
                          }
                        } else {
                          {
#line 748
                          detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                         queue_bytes_available);
                          }
                        }
                      } else {
                        {
#line 748
                        detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                       queue_bytes_available);
                        }
                      }
                    } else {
                      {
#line 748
                      detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                     queue_bytes_available);
                      }
                    }
                  } else {
                    {
#line 748
                    detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                   queue_bytes_available);
                    }
                  }
                } else {
                  {
#line 748
                  detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                                 queue_bytes_available);
                  }
                }
              } else {
                {
#line 748
                detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                               queue_bytes_available);
                }
              }
            } else {
              {
#line 748
              detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                             queue_bytes_available);
              }
            }
          } else {
            {
#line 748
            detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                           queue_bytes_available);
            }
          }
        } else {
          {
#line 748
          detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                         queue_bytes_available);
          }
        }
      } else {
        {
#line 748
        detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                       queue_bytes_available);
        }
      }
    } else {
      {
#line 748
      detecttype = detect_sector___0((uint8_t const   *)(queue + queue_start_ofs),
                                     queue_bytes_available);
      }
    }
#line 752
    if ((int )detecttype == (int )curtype) {
#line 752
      if (curtype_count <= 2147483647U) {
#line 759
        curtype_count ++;
      } else {
#line 752
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 765
      if (curtype_count > 0U) {
        {
#line 766
        tmp___7 = fseeko64(in, curtype_in_start, 0);
        }
#line 766
        if (tmp___7 != 0) {
#line 766
          goto error_in;
        }
        {
#line 767
        typetally[curtype] += (off64_t )curtype_count;
#line 768
        tmp___8 = write_sectors___0(curtype, curtype_count, infilename, outfilename,
                                    in, out);
        }
#line 768
        if (tmp___8) {
#line 775
          goto error;
        }
      }
#line 777
      curtype = detecttype;
#line 778
      curtype_in_start = input_bytes_checked;
#line 779
      curtype_count = (uint32_t )1;
    }
#line 786
    if ((int )curtype < 0) {
#line 786
      goto while_break;
    }
#line 791
    input_bytes_checked = (off64_t )((size_t const   )input_bytes_checked + sectorsize___0[curtype]);
#line 792
    queue_start_ofs += (size_t )sectorsize___0[curtype];
#line 793
    queue_bytes_available -= (size_t )sectorsize___0[curtype];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 800
  tmp___9 = write_type_count___0(outfilename, out, (int8_t )0, (uint32_t )0);
  }
#line 800
  if (tmp___9) {
#line 800
    goto error;
  }
  {
#line 805
  put32lsb___0(sector_buffer___0, input_edc);
#line 806
  tmp___10 = fwrite((void const   */* __restrict  */)(sector_buffer___0), (size_t )1,
                    (size_t )4, (FILE */* __restrict  */)out);
  }
#line 806
  if (tmp___10 != 4UL) {
#line 806
    goto error_out;
  }
  {
#line 811
  printf((char const   */* __restrict  */)"Literal bytes........... ");
#line 811
  fprintdec(stdout, typetally[0]);
#line 811
  printf((char const   */* __restrict  */)"\n");
#line 812
  printf((char const   */* __restrict  */)"Mode 1 sectors.......... ");
#line 812
  fprintdec(stdout, typetally[1]);
#line 812
  printf((char const   */* __restrict  */)"\n");
#line 813
  printf((char const   */* __restrict  */)"Mode 2 form 1 sectors... ");
#line 813
  fprintdec(stdout, typetally[2]);
#line 813
  printf((char const   */* __restrict  */)"\n");
#line 814
  printf((char const   */* __restrict  */)"Mode 2 form 2 sectors... ");
#line 814
  fprintdec(stdout, typetally[3]);
#line 814
  printf((char const   */* __restrict  */)"\n");
#line 815
  printf((char const   */* __restrict  */)"Encoded ");
#line 816
  fprintdec(stdout, input_file_length);
#line 817
  printf((char const   */* __restrict  */)" bytes -> ");
#line 818
  tmp___11 = ftello64(out);
#line 818
  fprintdec(stdout, tmp___11);
#line 819
  printf((char const   */* __restrict  */)" bytes\n");
#line 824
  printf((char const   */* __restrict  */)"Done\n");
#line 825
  returncode = (int8_t )0;
  }
#line 826
  goto done;
  error_in: 
  {
#line 829
  printfileerror(in, infilename);
  }
#line 830
  goto error;
  error_out: 
  {
#line 833
  printfileerror(out, outfilename);
  }
#line 834
  goto error;
  error: 
#line 837
  returncode = (int8_t )1;
#line 838
  goto done;
  done: 
#line 841
  if ((unsigned long )queue != (unsigned long )((void *)0)) {
    {
#line 841
    free((void *)queue);
    }
  }
#line 842
  if ((unsigned long )in != (unsigned long )((void *)0)) {
    {
#line 842
    fclose(in);
    }
  }
#line 843
  if ((unsigned long )out != (unsigned long )((void *)0)) {
    {
#line 843
    fclose(out);
    }
  }
#line 845
  return (returncode);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/cmdpack-1.03/src/ecm.c"
static int8_t unecmify___0(char const   *infilename , char const   *outfilename ) 
{ 
  int8_t returncode ;
  FILE *in ;
  FILE *out ;
  off64_t input_file_length ;
  uint32_t output_edc ;
  int8_t type ;
  uint32_t num ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int c ;
  int tmp___5 ;
  int bits ;
  uint32_t b ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  __off64_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  __off64_t tmp___16 ;
  size_t tmp___17 ;
  __off64_t tmp___18 ;
  __off64_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;

  {
  {
#line 856
  returncode = (int8_t )0;
#line 858
  in = (FILE *)((void *)0);
#line 859
  out = (FILE *)((void *)0);
#line 863
  output_edc = (uint32_t )0;
#line 870
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"rb");
  }
#line 871
  if (out) {
    {
#line 872
    printf((char const   */* __restrict  */)"Error: %s exists; refusing to overwrite\n",
           outfilename);
    }
#line 873
    goto error;
  }
  {
#line 879
  in = fopen((char const   */* __restrict  */)infilename, (char const   */* __restrict  */)"rb");
  }
#line 880
  if (! in) {
#line 880
    goto error_in;
  }
  {
#line 885
  tmp = fseeko64(in, (__off64_t )0, 2);
  }
#line 885
  if (tmp != 0) {
#line 885
    goto error_in;
  }
  {
#line 886
  input_file_length = ftello64(in);
  }
#line 887
  if (input_file_length < 0L) {
#line 887
    goto error_in;
  }
  {
#line 889
  resetcounter___0(input_file_length);
#line 891
  tmp___0 = fseeko64(in, (__off64_t )0, 0);
  }
#line 891
  if (tmp___0 != 0) {
#line 891
    goto error_in;
  }
  {
#line 896
  tmp___1 = fgetc(in);
  }
#line 896
  if (tmp___1 != 69) {
    {
#line 902
    printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
    }
#line 903
    goto error;
  } else {
    {
#line 896
    tmp___2 = fgetc(in);
    }
#line 896
    if (tmp___2 != 67) {
      {
#line 902
      printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
      }
#line 903
      goto error;
    } else {
      {
#line 896
      tmp___3 = fgetc(in);
      }
#line 896
      if (tmp___3 != 77) {
        {
#line 902
        printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
        }
#line 903
        goto error;
      } else {
        {
#line 896
        tmp___4 = fgetc(in);
        }
#line 896
        if (tmp___4 != 0) {
          {
#line 902
          printf((char const   */* __restrict  */)"Header missing; does not appear to be an ECM file\n");
          }
#line 903
          goto error;
        }
      }
    }
  }
  {
#line 909
  out = fopen((char const   */* __restrict  */)outfilename, (char const   */* __restrict  */)"wb");
  }
#line 910
  if (! out) {
#line 910
    goto error_out;
  }
  {
#line 912
  printf((char const   */* __restrict  */)"Decoding %s to %s...\n", infilename, outfilename);
  }
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 915
    tmp___5 = fgetc(in);
#line 915
    c = tmp___5;
#line 916
    bits = 5;
    }
#line 917
    if (c == -1) {
#line 917
      goto error_in;
    }
#line 918
    type = (int8_t )(c & 3);
#line 919
    num = (uint32_t )((c >> 2) & 31);
    {
#line 920
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 920
      if (! (c & 128)) {
#line 920
        goto while_break___0;
      }
      {
#line 921
      c = fgetc(in);
      }
#line 922
      if (c == -1) {
#line 922
        goto error_in;
      }
#line 923
      if (bits > 31) {
        {
#line 927
        printf((char const   */* __restrict  */)"Corrupt ECM file; invalid sector count\n");
        }
#line 928
        goto error;
      } else
#line 923
      if ((uint32_t )(c & 127) >= 2147483648U >> (bits - 1)) {
        {
#line 927
        printf((char const   */* __restrict  */)"Corrupt ECM file; invalid sector count\n");
        }
#line 928
        goto error;
      }
#line 930
      num |= (uint32_t )(c & 127) << bits;
#line 931
      bits += 7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 933
    if (num == 4294967295U) {
#line 935
      goto while_break;
    }
#line 937
    num ++;
#line 938
    if ((int )type == 0) {
      {
#line 939
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 939
        if (! num) {
#line 939
          goto while_break___1;
        }
#line 940
        b = num;
#line 941
        if ((unsigned long )b > sizeof(sector_buffer___0)) {
#line 941
          b = (uint32_t )sizeof(sector_buffer___0);
        }
        {
#line 942
        tmp___6 = fread((void */* __restrict  */)(sector_buffer___0), (size_t )1,
                        (size_t )b, (FILE */* __restrict  */)in);
        }
#line 942
        if (tmp___6 != (size_t )b) {
#line 943
          goto error_in;
        }
        {
#line 945
        output_edc = edc_compute___0(output_edc, (uint8_t const   *)(sector_buffer___0),
                                     (size_t )b);
#line 946
        tmp___7 = fwrite((void const   */* __restrict  */)(sector_buffer___0), (size_t )1,
                         (size_t )b, (FILE */* __restrict  */)out);
        }
#line 946
        if (tmp___7 != (size_t )b) {
#line 947
          goto error_out;
        }
        {
#line 949
        num -= b;
#line 950
        tmp___8 = ftello64(in);
#line 950
        setcounter_decode___0(tmp___8);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 953
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 953
        if (! num) {
#line 953
          goto while_break___2;
        }
        {
#line 955
        if ((int )type == 1) {
#line 955
          goto case_1;
        }
#line 962
        if ((int )type == 2) {
#line 962
          goto case_2;
        }
#line 968
        if ((int )type == 3) {
#line 968
          goto case_3;
        }
#line 954
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 956
        tmp___9 = fread((void */* __restrict  */)(sector_buffer___0 + 12), (size_t )1,
                        (size_t )3, (FILE */* __restrict  */)in);
        }
#line 956
        if (tmp___9 != 3UL) {
#line 956
          goto error_in;
        }
        {
#line 957
        tmp___10 = fread((void */* __restrict  */)(sector_buffer___0 + 16), (size_t )1,
                         (size_t )2048, (FILE */* __restrict  */)in);
        }
#line 957
        if (tmp___10 != 2048UL) {
#line 957
          goto error_in;
        }
        {
#line 958
        reconstruct_sector___0(sector_buffer___0, (int8_t )1);
#line 959
        output_edc = edc_compute___0(output_edc, (uint8_t const   *)(sector_buffer___0),
                                     (size_t )2352);
#line 960
        tmp___11 = fwrite((void const   */* __restrict  */)(sector_buffer___0), (size_t )1,
                          (size_t )2352, (FILE */* __restrict  */)out);
        }
#line 960
        if (tmp___11 != 2352UL) {
#line 960
          goto error_out;
        }
#line 961
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 963
        tmp___12 = fread((void */* __restrict  */)(sector_buffer___0 + 20), (size_t )1,
                         (size_t )2052, (FILE */* __restrict  */)in);
        }
#line 963
        if (tmp___12 != 2052UL) {
#line 963
          goto error_in;
        }
        {
#line 964
        reconstruct_sector___0(sector_buffer___0, (int8_t )2);
#line 965
        output_edc = edc_compute___0(output_edc, (uint8_t const   *)(sector_buffer___0 + 16),
                                     (size_t )2336);
#line 966
        tmp___13 = fwrite((void const   */* __restrict  */)(sector_buffer___0 + 16),
                          (size_t )1, (size_t )2336, (FILE */* __restrict  */)out);
        }
#line 966
        if (tmp___13 != 2336UL) {
#line 966
          goto error_out;
        }
#line 967
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 969
        tmp___14 = fread((void */* __restrict  */)(sector_buffer___0 + 20), (size_t )1,
                         (size_t )2328, (FILE */* __restrict  */)in);
        }
#line 969
        if (tmp___14 != 2328UL) {
#line 969
          goto error_in;
        }
        {
#line 970
        reconstruct_sector___0(sector_buffer___0, (int8_t )3);
#line 971
        output_edc = edc_compute___0(output_edc, (uint8_t const   *)(sector_buffer___0 + 16),
                                     (size_t )2336);
#line 972
        tmp___15 = fwrite((void const   */* __restrict  */)(sector_buffer___0 + 16),
                          (size_t )1, (size_t )2336, (FILE */* __restrict  */)out);
        }
#line 972
        if (tmp___15 != 2336UL) {
#line 972
          goto error_out;
        }
#line 973
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 975
        tmp___16 = ftello64(in);
#line 975
        setcounter_decode___0(tmp___16);
#line 953
        num --;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 982
  tmp___17 = fread((void */* __restrict  */)(sector_buffer___0), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)in);
  }
#line 982
  if (tmp___17 != 4UL) {
#line 982
    goto error_in;
  }
  {
#line 984
  printf((char const   */* __restrict  */)"Decoded ");
#line 985
  tmp___18 = ftello64(in);
#line 985
  fprintdec(stdout, tmp___18);
#line 986
  printf((char const   */* __restrict  */)" bytes -> ");
#line 987
  tmp___19 = ftello64(out);
#line 987
  fprintdec(stdout, tmp___19);
#line 988
  printf((char const   */* __restrict  */)" bytes\n");
#line 990
  tmp___21 = get32lsb___0((uint8_t const   *)(sector_buffer___0));
  }
#line 990
  if (tmp___21 != output_edc) {
    {
#line 991
    tmp___20 = get32lsb___0((uint8_t const   *)(sector_buffer___0));
#line 991
    printf((char const   */* __restrict  */)"Checksum error (0x%08lX, should be 0x%08lX)\n",
           (unsigned long )output_edc, (unsigned long )tmp___20);
    }
#line 995
    goto error;
  }
  {
#line 1001
  printf((char const   */* __restrict  */)"Done\n");
#line 1002
  returncode = (int8_t )0;
  }
#line 1003
  goto done;
  error_in: 
  {
#line 1006
  printfileerror(in, infilename);
  }
#line 1007
  goto error;
  error_out: 
  {
#line 1010
  printfileerror(out, outfilename);
  }
#line 1011
  goto error;
  error: 
#line 1014
  returncode = (int8_t )1;
#line 1015
  goto done;
  done: 
#line 1018
  if ((unsigned long )in != (unsigned long )((void *)0)) {
    {
#line 1018
    fclose(in);
    }
  }
#line 1019
  if ((unsigned long )out != (unsigned long )((void *)0)) {
    {
#line 1019
    fclose(out);
    }
  }
#line 1021
  return (returncode);
}
}
