/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 36 "/usr/include/stdint.h"
typedef signed char int8_t;
#line 37 "/usr/include/stdint.h"
typedef short int16_t;
#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 40 "/usr/include/stdint.h"
typedef long int64_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 150 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
struct __anonstruct_DBFHEADER_30 {
   int8_t signature ;
   int8_t year ;
   int8_t month ;
   int8_t day ;
   uint32_t recordcount ;
   uint16_t headerlength ;
   uint16_t recordlength ;
   int8_t reserved1[2] ;
   int8_t incomplete ;
   int8_t encrypted ;
   int8_t reserved2[4] ;
   int8_t reserved3[8] ;
   int8_t mdx ;
   int8_t language ;
   int8_t reserved4[2] ;
};
#line 150 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
typedef struct __anonstruct_DBFHEADER_30 DBFHEADER;
#line 168 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
struct __anonstruct_DBFFIELD_31 {
   char name[11] ;
   char type ;
   int32_t memaddress ;
   uint8_t length ;
   uint8_t decimals ;
   int16_t flags ;
   char workareaid ;
   char reserved1[2] ;
   char setfields ;
   char reserved2[7] ;
   char indexfield ;
};
#line 168 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
typedef struct __anonstruct_DBFFIELD_31 DBFFIELD;
#line 182 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
struct __anonstruct_MEMOHEADER_32 {
   char nextblock[4] ;
   char reserved1[2] ;
   char blocksize[2] ;
   char reserved2[504] ;
};
#line 182 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
typedef struct __anonstruct_MEMOHEADER_32 MEMOHEADER;
#line 189 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
struct __anonstruct_PGFIELD_33 {
   char *formatstring ;
   int memonumbering ;
};
#line 189 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
typedef struct __anonstruct_PGFIELD_33 PGFIELD;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 60 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static char staticbuf[4194305]  ;
#line 67 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static char const   *RESERVEDWORDS[80]  = 
#line 67
  {      "all",      "analyse",      "analyze",      "and", 
        "any",      "array",      "as",      "asc", 
        "asymmetric",      "both",      "case",      "cast", 
        "check",      "collate",      "column",      "constraint", 
        "create",      "current_catalog",      "current_date",      "current_role", 
        "current_time",      "current_timestamp",      "current_user",      "default", 
        "deferrable",      "desc",      "distinct",      "do", 
        "else",      "end",      "except",      "false", 
        "fetch",      "for",      "foreign",      "from", 
        "grant",      "group",      "having",      "in", 
        "initially",      "intersect",      "into",      "leading", 
        "limit",      "localtime",      "localtimestamp",      "new", 
        "not",      "null",      "off",      "offset", 
        "old",      "on",      "only",      "or", 
        "order",      "placing",      "primary",      "references", 
        "returning",      "select",      "session_user",      "some", 
        "symmetric",      "table",      "then",      "to", 
        "trailing",      "true",      "union",      "unique", 
        "user",      "using",      "variadic",      "when", 
        "where",      "window",      "with",      (char const   *)((void *)0)};
#line 195 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static iconv_t conv_desc  =    (void *)0;
#line 197 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static char *convertcharset(char const   *inputstring , size_t *inputsize ) 
{ 
  char *inbuf ;
  char *outbuf ;
  size_t inbytesleft ;
  size_t outbyteslen ;
  size_t outbytesleft ;
  void *tmp ;
  char *outbufstart ;
  size_t iconv_value ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 205
  inbuf = (char *)inputstring;
#line 206
  inbytesleft = *inputsize;
#line 207
  outbyteslen = inbytesleft * 4UL + 1UL;
#line 208
  outbytesleft = outbyteslen;
#line 209
  tmp = calloc(outbyteslen, (size_t )1);
#line 209
  outbuf = (char *)tmp;
#line 211
  outbufstart = outbuf;
#line 213
  tmp___0 = iconv(conv_desc, (char **/* __restrict  */)(& inbuf), (size_t */* __restrict  */)(& inbytesleft),
                  (char **/* __restrict  */)(& outbuf), (size_t */* __restrict  */)(& outbytesleft));
#line 213
  iconv_value = tmp___0;
  }
#line 216
  if (iconv_value == 0xffffffffffffffffUL) {
    {
#line 217
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iconv failed\n");
#line 218
    tmp___1 = __errno_location();
    }
    {
#line 219
    if (*tmp___1 == 84) {
#line 219
      goto case_84;
    }
#line 222
    if (*tmp___1 == 22) {
#line 222
      goto case_22;
    }
#line 225
    if (*tmp___1 == 7) {
#line 225
      goto case_7;
    }
#line 228
    goto switch_default;
    case_84: /* CIL Label */ 
    {
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid multibyte sequence.\n");
    }
#line 221
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incomplete multibyte sequence.\n");
    }
#line 224
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No more room (increase size of outbuf in pgdbf.h).\n");
    }
#line 227
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 229
    tmp___2 = __errno_location();
#line 229
    tmp___3 = strerror(*tmp___2);
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s.\n",
            tmp___3);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 231
    exit(1);
    }
  }
#line 234
  *inputsize = outbyteslen - outbytesleft;
#line 236
  return (outbufstart);
}
}
#line 240 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static void exitwitherror(char const   *message , int const   systemerror ) 
{ 


  {
#line 243
  if (systemerror) {
    {
#line 244
    perror(message);
    }
  } else {
    {
#line 246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            message);
    }
  }
  {
#line 248
  exit(1);
  }
}
}
#line 251 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static void safeprintbuf(char const   *buf , size_t const   inputsize ) 
{ 
  char *convbuf ;
  char *targetbuf ;
  char const   *s ;
  char const   *lastchar ;
  char *t ;
  size_t realsize ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 259
  realsize = (size_t )0;
#line 262
  if ((int const   )*buf == 0) {
#line 263
    return;
  }
#line 267
  s = (buf + inputsize) - 1;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((unsigned long )s >= (unsigned long )buf)) {
#line 267
      goto while_break;
    }
#line 268
    if ((int const   )*s != 32) {
#line 268
      if ((int const   )*s != 0) {
#line 269
        goto while_break;
      }
    }
#line 267
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  if ((unsigned long )s < (unsigned long )buf) {
#line 275
    return;
  }
#line 278
  lastchar = s;
#line 279
  realsize = (size_t )((s - buf) + 1L);
#line 280
  convbuf = (char *)buf;
#line 283
  if ((unsigned long )conv_desc != (unsigned long )((void *)0)) {
    {
#line 284
    convbuf = convertcharset(buf, & realsize);
#line 285
    lastchar = (char const   *)((convbuf + realsize) - 1);
    }
  }
#line 289
  if (realsize * 2UL < 4194304UL) {
#line 290
    targetbuf = staticbuf;
  } else {
    {
#line 292
    tmp = malloc(realsize * 2UL + 1UL);
#line 292
    targetbuf = (char *)tmp;
    }
#line 293
    if ((unsigned long )targetbuf == (unsigned long )((void *)0)) {
      {
#line 294
      exitwitherror("Unable to malloc the escape output buffer", (int const   )1);
      }
    }
  }
#line 299
  t = targetbuf;
#line 300
  s = (char const   *)convbuf;
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (! ((unsigned long )s <= (unsigned long )lastchar)) {
#line 300
      goto while_break___0;
    }
    {
#line 302
    if ((int const   )*s == 92) {
#line 302
      goto case_92;
    }
#line 306
    if ((int const   )*s == 10) {
#line 306
      goto case_10;
    }
#line 310
    if ((int const   )*s == 13) {
#line 310
      goto case_13;
    }
#line 314
    if ((int const   )*s == 9) {
#line 314
      goto case_9;
    }
#line 318
    goto switch_default;
    case_92: /* CIL Label */ 
#line 303
    tmp___0 = t;
#line 303
    t ++;
#line 303
    *tmp___0 = (char )'\\';
#line 304
    tmp___1 = t;
#line 304
    t ++;
#line 304
    *tmp___1 = (char )'\\';
#line 305
    goto switch_break;
    case_10: /* CIL Label */ 
#line 307
    tmp___2 = t;
#line 307
    t ++;
#line 307
    *tmp___2 = (char )'\\';
#line 308
    tmp___3 = t;
#line 308
    t ++;
#line 308
    *tmp___3 = (char )'n';
#line 309
    goto switch_break;
    case_13: /* CIL Label */ 
#line 311
    tmp___4 = t;
#line 311
    t ++;
#line 311
    *tmp___4 = (char )'\\';
#line 312
    tmp___5 = t;
#line 312
    t ++;
#line 312
    *tmp___5 = (char )'r';
#line 313
    goto switch_break;
    case_9: /* CIL Label */ 
#line 315
    tmp___6 = t;
#line 315
    t ++;
#line 315
    *tmp___6 = (char )'\\';
#line 316
    tmp___7 = t;
#line 316
    t ++;
#line 316
    *tmp___7 = (char )'t';
#line 317
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 319
    tmp___8 = t;
#line 319
    t ++;
#line 319
    *tmp___8 = (char )*s;
    switch_break: /* CIL Label */ ;
    }
#line 300
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 322
  *t = (char )'\000';
#line 324
  printf((char const   */* __restrict  */)"%s", targetbuf);
  }
#line 327
  if ((unsigned long )conv_desc != (unsigned long )((void *)0)) {
    {
#line 328
    free((void *)convbuf);
    }
  }
#line 332
  if ((unsigned long )targetbuf != (unsigned long )(staticbuf)) {
    {
#line 333
    free((void *)targetbuf);
    }
  }
#line 335
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
int progressdots  =    1;
#line 339 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
void updateprogressbar(int percent ) 
{ 
  int newprogressdots ;

  {
#line 340
  newprogressdots = percent / 2;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (progressdots <= newprogressdots)) {
#line 341
      goto while_break;
    }
    {
#line 342
    _IO_putc('.', stderr);
    }
#line 343
    if (progressdots) {
#line 343
      if (! (progressdots % 5)) {
        {
#line 344
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d",
                progressdots * 2);
        }
      }
    }
#line 341
    progressdots ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if (percent == 100) {
    {
#line 348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 350
  fflush(stderr);
  }
#line 351
  return;
}
}
#line 400 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static int32_t nativeint32_t(int32_t const   rightend ) 
{ 


  {
#line 402
  return ((int32_t )rightend);
}
}
#line 410 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static int16_t nativeint16_t(int16_t const   rightend ) 
{ 


  {
#line 412
  return ((int16_t )rightend);
}
}
#line 422 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static int64_t snativeint64_t(char const   *buf ) 
{ 
  int64_t output ;

  {
  {
#line 425
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )8);
  }
#line 426
  return (output);
}
}
#line 434 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static int32_t snativeint32_t(char const   *buf ) 
{ 
  int32_t output ;

  {
  {
#line 437
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )4);
  }
#line 438
  return (output);
}
}
#line 441 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static int32_t sswappedint32_t(char const   *buf ) 
{ 
  char const   *src ;
  int32_t rightend ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 443
  src = buf + 3;
#line 443
  tmp = src;
#line 443
  src --;
#line 443
  memcpy((void */* __restrict  */)((char *)(& rightend)), (void const   */* __restrict  */)tmp,
         (size_t )1);
#line 443
  tmp___0 = src;
#line 443
  src --;
#line 443
  memcpy((void */* __restrict  */)((char *)(& rightend) + 1), (void const   */* __restrict  */)tmp___0,
         (size_t )1);
#line 443
  tmp___1 = src;
#line 443
  src --;
#line 443
  memcpy((void */* __restrict  */)((char *)(& rightend) + 2), (void const   */* __restrict  */)tmp___1,
         (size_t )1);
#line 443
  memcpy((void */* __restrict  */)((char *)(& rightend) + 3), (void const   */* __restrict  */)src,
         (size_t )1);
  }
#line 443
  return (rightend);
}
}
#line 453 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static int16_t sswappedint16_t(char const   *buf ) 
{ 
  char const   *src ;
  int16_t rightend ;
  char const   *tmp ;

  {
  {
#line 455
  src = buf + 1;
#line 455
  tmp = src;
#line 455
  src --;
#line 455
  memcpy((void */* __restrict  */)((char *)(& rightend)), (void const   */* __restrict  */)tmp,
         (size_t )1);
#line 455
  memcpy((void */* __restrict  */)((char *)(& rightend) + 1), (void const   */* __restrict  */)src,
         (size_t )1);
  }
#line 455
  return (rightend);
}
}
#line 506 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.h"
static double sdouble(char const   *buf ) 
{ 
  double output ;

  {
  {
#line 509
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )8);
  }
#line 510
  return (output);
}
}
#line 533 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.c"
extern int ( /* missing proto */  asprintf)() ;
#line 36 "/home/wheatley/newnew/temp/pgdbf-0.6.2/src/pgdbf.c"
int main(int argc , char **argv ) 
{ 
  char *dbffilename ;
  FILE *dbffile ;
  DBFHEADER dbfheader ;
  DBFFIELD *fields ;
  PGFIELD *pgfields ;
  size_t dbffieldsize ;
  size_t fieldcount ;
  unsigned int recordbase ;
  unsigned int dbfbatchsize ;
  unsigned int batchindex ;
  int skipbytes ;
  int fieldarraysize ;
  int fieldnum ;
  uint8_t terminator ;
  MEMOHEADER *memoheader ;
  char *memofilename ;
  int memofd ;
  struct stat memostat ;
  int32_t memoblocknumber ;
  int memofileisdbase3 ;
  void *memomap ;
  char *memorecord ;
  size_t memoblocksize ;
  size_t memofilesize ;
  size_t memorecordoffset ;
  char *inputbuffer ;
  char *outputbuffer ;
  char *bufoffset ;
  char *s ;
  char *t ;
  char *u ;
  int lastcharwasreplaced ;
  int i ;
  int j ;
  int isreservedname ;
  int printed ;
  size_t blocksread ;
  size_t longestfield ;
  int32_t juliandays ;
  int32_t seconds ;
  int hours ;
  int minutes ;
  int opt ;
  int optexitcode ;
  char optvalidargs[sizeof("cCdDeEhm:nNpPqQtTuU") + 3UL] ;
  int optnumericasnumeric ;
  int optshowprogress ;
  int optusecreatetable ;
  int optusedroptable ;
  int optuseifexists ;
  int optusequotedtablename ;
  int optusetransaction ;
  int optusetruncatetable ;
  char *tablename ;
  char *baretablename ;
  char (*fieldnames)[18] ;
  int isuniquename ;
  char basename[18] ;
  int serial ;
  char *optinputcharset ;
  char const   *outputcharset ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int16_t tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  int16_t tmp___21 ;
  int tmp___22 ;
  int16_t tmp___23 ;
  void *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int16_t tmp___32 ;
  int16_t tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  int16_t tmp___36 ;
  int32_t tmp___37 ;
  int16_t tmp___38 ;
  double tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int32_t tmp___51 ;
  int32_t tmp___52 ;
  int32_t tmp___53 ;
  int64_t tmp___54 ;
  int tmp___55 ;
  int32_t tmp___56 ;
  int32_t tmp___57 ;
  unsigned short const   **tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;

  {
  {
#line 58
  memofilename = (char *)((void *)0);
#line 62
  memofileisdbase3 = 0;
#line 64
  memomap = (void *)0;
#line 66
  memoblocksize = (size_t )0;
#line 77
  lastcharwasreplaced = 0;
#line 83
  longestfield = (size_t )32;
#line 95
  optexitcode = -1;
#line 102
  optnumericasnumeric = 1;
#line 103
  optshowprogress = 0;
#line 104
  optusecreatetable = 1;
#line 105
  optusedroptable = 1;
#line 106
  optuseifexists = 1;
#line 107
  optusequotedtablename = 0;
#line 108
  optusetransaction = 1;
#line 109
  optusetruncatetable = 0;
#line 121
  optinputcharset = (char *)((void *)0);
#line 124
  strcpy((char */* __restrict  */)(optvalidargs), (char const   */* __restrict  */)"cCdDeEhm:nNpPqQtTuU");
#line 130
  strcat((char */* __restrict  */)(optvalidargs), (char const   */* __restrict  */)"s:");
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    opt = getopt(argc, (char * const  *)argv, (char const   *)(optvalidargs));
    }
#line 134
    if (! (opt != -1)) {
#line 134
      goto while_break;
    }
    {
#line 136
    if (opt == 99) {
#line 136
      goto case_99;
    }
#line 140
    if (opt == 67) {
#line 140
      goto case_67;
    }
#line 143
    if (opt == 100) {
#line 143
      goto case_100;
    }
#line 147
    if (opt == 68) {
#line 147
      goto case_68;
    }
#line 150
    if (opt == 101) {
#line 150
      goto case_101;
    }
#line 153
    if (opt == 69) {
#line 153
      goto case_69;
    }
#line 156
    if (opt == 109) {
#line 156
      goto case_109;
    }
#line 159
    if (opt == 110) {
#line 159
      goto case_110;
    }
#line 162
    if (opt == 78) {
#line 162
      goto case_78;
    }
#line 165
    if (opt == 112) {
#line 165
      goto case_112;
    }
#line 168
    if (opt == 80) {
#line 168
      goto case_80;
    }
#line 171
    if (opt == 113) {
#line 171
      goto case_113;
    }
#line 174
    if (opt == 81) {
#line 174
      goto case_81;
    }
#line 178
    if (opt == 115) {
#line 178
      goto case_115;
    }
#line 182
    if (opt == 116) {
#line 182
      goto case_116;
    }
#line 185
    if (opt == 84) {
#line 185
      goto case_84;
    }
#line 188
    if (opt == 117) {
#line 188
      goto case_117;
    }
#line 193
    if (opt == 85) {
#line 193
      goto case_85;
    }
#line 197
    goto switch_default;
    case_99: /* CIL Label */ 
#line 137
    optusecreatetable = 1;
#line 138
    optusetruncatetable = 0;
#line 139
    goto switch_break;
    case_67: /* CIL Label */ 
#line 141
    optusecreatetable = 0;
#line 142
    goto switch_break;
    case_100: /* CIL Label */ 
#line 144
    optusedroptable = 1;
#line 145
    optusetruncatetable = 0;
#line 146
    goto switch_break;
    case_68: /* CIL Label */ 
#line 148
    optusedroptable = 0;
#line 149
    goto switch_break;
    case_101: /* CIL Label */ 
#line 151
    optuseifexists = 1;
#line 152
    goto switch_break;
    case_69: /* CIL Label */ 
#line 154
    optuseifexists = 0;
#line 155
    goto switch_break;
    case_109: /* CIL Label */ 
#line 157
    memofilename = optarg;
#line 158
    goto switch_break;
    case_110: /* CIL Label */ 
#line 160
    optnumericasnumeric = 1;
#line 161
    goto switch_break;
    case_78: /* CIL Label */ 
#line 163
    optnumericasnumeric = 0;
#line 164
    goto switch_break;
    case_112: /* CIL Label */ 
#line 166
    optshowprogress = 1;
#line 167
    goto switch_break;
    case_80: /* CIL Label */ 
#line 169
    optshowprogress = 0;
#line 170
    goto switch_break;
    case_113: /* CIL Label */ 
#line 172
    optusequotedtablename = 1;
#line 173
    goto switch_break;
    case_81: /* CIL Label */ 
#line 175
    optusequotedtablename = 0;
#line 176
    goto switch_break;
    case_115: /* CIL Label */ 
#line 179
    optinputcharset = optarg;
#line 180
    goto switch_break;
    case_116: /* CIL Label */ 
#line 183
    optusetransaction = 1;
#line 184
    goto switch_break;
    case_84: /* CIL Label */ 
#line 186
    optusetransaction = 0;
#line 187
    goto switch_break;
    case_117: /* CIL Label */ 
#line 189
    optusetruncatetable = 1;
#line 190
    optusecreatetable = 0;
#line 191
    optusedroptable = 0;
#line 192
    goto switch_break;
    case_85: /* CIL Label */ 
#line 194
    optusetruncatetable = 0;
#line 195
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 201
    if ((int )((char )opt) == 104) {
#line 201
      optexitcode = 0;
    } else {
#line 201
      optexitcode = 1;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  if (optexitcode != 0) {
#line 207
    if (optind > argc - 1) {
#line 208
      optexitcode = 1;
    }
  }
#line 211
  if (optexitcode != -1) {
    {
#line 212
    printf((char const   */* __restrict  */)"Usage: %s [-cCdDeEhtTuU] [-s encoding] [-m memofilename] filename [indexcolumn ...]\nConvert the named XBase file into PostgreSQL format\n\n  -c  issue a \'CREATE TABLE\' command to create the table (default)\n  -C  do not issue a \'CREATE TABLE\' command\n  -d  issue a \'DROP TABLE\' command before creating the table (default)\n  -D  do not issue a \'DROP TABLE\' command\n  -e  use \'IF EXISTS\' when dropping tables (PostgreSQL 8.2+) (default)\n  -E  do not use \'IF EXISTS\' when dropping tables (PostgreSQL 8.1 and older)\n  -h  print this message and exit\n  -m  the name of the associated memo file (if necessary)\n  -n  use type \'NUMERIC\' for NUMERIC fields (default)\n  -N  use type \'TEXT\' for NUMERIC fields\n  -p  show a progress bar during processing\n  -P  do not show a progress bar\n  -q  enclose the table name in quotation marks whenever used in statements\n  -Q  do not enclose the table name in quotation marks (default)\n  -s  the encoding used in the file, to be converted to UTF-8\n  -t  wrap a transaction around the entire series of statements (default)\n  -T  do not use an enclosing transaction\n  -u  issue a \'TRUNCATE\' command before inserting data\n  -U  do not issue a \'TRUNCATE\' command before inserting data (default)\n\nIf you don\'t specify an encoding via \'-s\', the data will be printed as is.\nUsing \'-u\' implies \'-C -D\'. Using \'-c\' or \'-d\' implies \'-U\'.\n\n%s is copyright 2008-2012 kirk@strauser.com.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nReport bugs to <%s>\n",
           "pgdbf", "PgDBF 0.6.2", "kirk@strauser.com");
#line 252
    exit(optexitcode);
    }
  }
#line 256
  if (! optusecreatetable) {
#line 259
    optusedroptable = 0;
  }
#line 264
  if ((unsigned long )optinputcharset != (unsigned long )((void *)0)) {
    {
#line 265
    outputcharset = "UTF-8";
#line 266
    conv_desc = iconv_open(outputcharset, (char const   *)optinputcharset);
    }
#line 268
    if ((unsigned long )conv_desc == (unsigned long )((iconv_t )-1)) {
      {
#line 269
      tmp___1 = __errno_location();
      }
#line 269
      if (*tmp___1 == 22) {
        {
#line 270
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Conversion from \'%s\' to \'%s\' is not supported.\n",
                optinputcharset, outputcharset);
        }
      } else {
        {
#line 272
        tmp = __errno_location();
#line 272
        tmp___0 = strerror(*tmp);
#line 272
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Initialization failure: %s\n",
                tmp___0);
        }
      }
      {
#line 275
      exit(1);
      }
    }
  }
  {
#line 281
  dbffilename = *(argv + optind);
#line 282
  tmp___2 = strlen((char const   *)dbffilename);
#line 282
  tmp___3 = malloc(tmp___2 + 1UL);
#line 282
  tablename = (char *)tmp___3;
  }
#line 283
  if ((unsigned long )tablename == (unsigned long )((void *)0)) {
    {
#line 284
    exitwitherror("Unable to allocate the tablename buffer", (int const   )1);
    }
  }
  {
#line 291
  tmp___4 = strlen((char const   *)dbffilename);
#line 291
  tmp___5 = malloc((tmp___4 + 1UL) + (size_t )(optusequotedtablename * 2));
#line 291
  baretablename = (char *)tmp___5;
  }
#line 292
  if ((unsigned long )baretablename == (unsigned long )((void *)0)) {
    {
#line 293
    exitwitherror("Unable to allocate the bare tablename buffer", (int const   )1);
    }
  }
  {
#line 298
  tmp___6 = strlen((char const   *)dbffilename);
#line 298
  s = (dbffilename + tmp___6) - 1;
  }
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    if (! ((unsigned long )s != (unsigned long )dbffilename)) {
#line 298
      goto while_break___0;
    }
#line 299
    if ((int )*s == 47) {
#line 300
      s ++;
#line 301
      goto while_break___0;
    }
#line 298
    s --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  t = tablename;
#line 306
  u = baretablename;
#line 307
  if (optusequotedtablename) {
#line 307
    tmp___7 = u;
#line 307
    u ++;
#line 307
    *tmp___7 = (char )'\"';
  }
  {
#line 308
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 308
    if (! *s) {
#line 308
      goto while_break___1;
    }
#line 309
    if ((int )*s == 46) {
#line 310
      goto while_break___1;
    }
    {
#line 312
    tmp___8 = s;
#line 312
    s ++;
#line 312
    tmp___9 = tolower((int )*tmp___8);
#line 312
    *t = (char )tmp___9;
#line 313
    tmp___10 = u;
#line 313
    u ++;
#line 313
    *tmp___10 = *t;
#line 314
    t ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 316
  if (optusequotedtablename) {
#line 316
    tmp___11 = u;
#line 316
    u ++;
#line 316
    *tmp___11 = (char )'\"';
  }
  {
#line 317
  *t = (char )'\000';
#line 318
  *u = (char )'\000';
#line 321
  dbffile = fopen((char const   */* __restrict  */)dbffilename, (char const   */* __restrict  */)"rb");
  }
#line 322
  if ((unsigned long )dbffile == (unsigned long )((void *)0)) {
    {
#line 323
    exitwitherror("Unable to open the DBF file", (int const   )1);
    }
  }
  {
#line 325
  tmp___12 = setvbuf((FILE */* __restrict  */)dbffile, (char */* __restrict  */)((void *)0),
                     0, (size_t )16777216);
  }
#line 325
  if (tmp___12) {
    {
#line 326
    exitwitherror("Unable to set the buffer for the dbf file", (int const   )1);
    }
  }
  {
#line 328
  tmp___13 = fread((void */* __restrict  */)(& dbfheader), sizeof(dbfheader), (size_t )1,
                   (FILE */* __restrict  */)dbffile);
  }
#line 328
  if (tmp___13 != 1UL) {
    {
#line 329
    exitwitherror("Unable to read the entire DBF header", (int const   )1);
    }
  }
#line 332
  if ((int )dbfheader.signature == 48) {
#line 336
    skipbytes = 263;
  } else {
#line 338
    skipbytes = 0;
  }
  {
#line 342
  dbffieldsize = sizeof(DBFFIELD );
#line 343
  tmp___14 = nativeint16_t((int16_t const   )dbfheader.headerlength);
#line 343
  fieldarraysize = (int )((((unsigned long )tmp___14 - sizeof(dbfheader)) - (unsigned long )skipbytes) - 1UL);
  }
#line 344
  if ((unsigned long )fieldarraysize % dbffieldsize == 1UL) {
#line 349
    skipbytes ++;
#line 350
    fieldarraysize --;
  } else
#line 351
  if ((unsigned long )fieldarraysize % dbffieldsize) {
    {
#line 352
    exitwitherror("The field array size is not an even multiple of the database field size",
                  (int const   )0);
    }
  }
  {
#line 354
  fieldcount = (size_t )fieldarraysize / dbffieldsize;
#line 357
  tmp___15 = malloc((size_t )fieldarraysize);
#line 357
  fields = (DBFFIELD *)tmp___15;
  }
#line 358
  if ((unsigned long )fields == (unsigned long )((void *)0)) {
    {
#line 359
    exitwitherror("Unable to malloc the field descriptions", (int const   )1);
    }
  }
  {
#line 361
  tmp___16 = fread((void */* __restrict  */)fields, dbffieldsize, fieldcount, (FILE */* __restrict  */)dbffile);
  }
#line 361
  if (tmp___16 != fieldcount) {
    {
#line 362
    exitwitherror("Unable to read all of the field descriptions", (int const   )1);
    }
  }
  {
#line 366
  tmp___17 = malloc(fieldcount * sizeof(PGFIELD ));
#line 366
  pgfields = (PGFIELD *)tmp___17;
  }
#line 367
  if ((unsigned long )pgfields == (unsigned long )((void *)0)) {
    {
#line 368
    exitwitherror("Unable to malloc the output parameter list", (int const   )1);
    }
  }
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 370
    if (! ((size_t )i < fieldcount)) {
#line 370
      goto while_break___2;
    }
#line 371
    (pgfields + i)->formatstring = (char *)((void *)0);
#line 370
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 375
  tmp___18 = fread((void */* __restrict  */)(& terminator), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)dbffile);
  }
#line 375
  if (tmp___18 != 1UL) {
    {
#line 376
    exitwitherror("Unable to read the terminator byte", (int const   )1);
    }
  }
#line 378
  if ((int )terminator != 13) {
    {
#line 379
    exitwitherror("Invalid terminator byte", (int const   )0);
    }
  }
  {
#line 383
  tmp___19 = fseek(dbffile, (long )skipbytes, 1);
  }
#line 383
  if (tmp___19) {
    {
#line 384
    exitwitherror("Unable to seek in the DBF file", (int const   )1);
    }
  }
  {
#line 388
  tmp___20 = ftell(dbffile);
#line 388
  tmp___21 = nativeint16_t((int16_t const   )dbfheader.headerlength);
  }
#line 388
  if (tmp___20 != (long )tmp___21) {
    {
#line 389
    exitwitherror("At an unexpected offset in the DBF file", (int const   )0);
    }
  }
#line 393
  if ((unsigned long )memofilename != (unsigned long )((void *)0)) {
    {
#line 394
    memofd = open((char const   *)memofilename, 0);
    }
#line 395
    if (memofd == -1) {
      {
#line 396
      exitwitherror("Unable to open the memofile", (int const   )1);
      }
    }
    {
#line 398
    tmp___22 = fstat(memofd, & memostat);
    }
#line 398
    if (tmp___22 == -1) {
      {
#line 399
      exitwitherror("Unable to fstat the memofile", (int const   )1);
      }
    }
    {
#line 401
    memofilesize = (size_t )memostat.st_size;
#line 402
    memomap = mmap((void *)0, memofilesize, 1, 2, memofd, (__off_t )0);
    }
#line 403
    if ((unsigned long )memomap == (unsigned long )((void *)-1)) {
      {
#line 404
      exitwitherror("Unable to mmap the memofile", (int const   )1);
      }
    }
#line 409
    memoheader = (MEMOHEADER *)memomap;
#line 410
    memofileisdbase3 = (int )dbfheader.signature == -125;
#line 411
    if (memofileisdbase3) {
      {
#line 412
      memoblocknumber = snativeint32_t((char const   *)(memoheader->nextblock));
      }
    } else {
      {
#line 414
      memoblocknumber = sswappedint32_t((char const   *)(memoheader->nextblock));
      }
    }
#line 416
    if (memoblocknumber < 0) {
      {
#line 417
      exitwitherror("The next memofile block is negative. The specified memofile probably isn\'t really a memofile.",
                    (int const   )0);
      }
    }
#line 420
    if (memofileisdbase3) {
#line 421
      memoblocksize = (size_t )512;
    } else {
      {
#line 423
      tmp___23 = sswappedint16_t((char const   *)(memoheader->blocksize));
#line 423
      memoblocksize = (size_t )tmp___23;
      }
    }
  }
#line 428
  if (optusetransaction) {
    {
#line 429
    printf((char const   */* __restrict  */)"BEGIN;\n");
    }
  }
#line 433
  if (optusedroptable) {
    {
#line 434
    printf((char const   */* __restrict  */)"SET statement_timeout=60000; DROP TABLE");
    }
#line 437
    if (optuseifexists) {
      {
#line 438
      printf((char const   */* __restrict  */)" IF EXISTS");
      }
    }
    {
#line 440
    printf((char const   */* __restrict  */)" %s; SET statement_timeout=0;\n", baretablename);
    }
  }
#line 446
  if (optusecreatetable) {
    {
#line 447
    tmp___24 = calloc(fieldcount, (size_t )18);
#line 447
    fieldnames = (char (*)[18])tmp___24;
    }
#line 448
    if ((unsigned long )fieldnames == (unsigned long )((void *)0)) {
      {
#line 449
      exitwitherror("Unable to allocate the columnname uniqification buffer", (int const   )1);
      }
    }
#line 451
    fieldnum = 0;
    {
#line 451
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 451
      if (! ((size_t )fieldnum < fieldcount)) {
#line 451
        goto while_break___3;
      }
#line 453
      s = (fields + fieldnum)->name;
#line 454
      t = *(fieldnames + fieldnum);
      {
#line 455
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 455
        if (! *s) {
#line 455
          goto while_break___4;
        }
        {
#line 456
        tmp___25 = t;
#line 456
        t ++;
#line 456
        tmp___26 = s;
#line 456
        s ++;
#line 456
        tmp___27 = tolower((int )*tmp___26);
#line 456
        *tmp___25 = (char )tmp___27;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 458
      *t = (char )'\000';
#line 451
      fieldnum ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 460
    i = 1;
    {
#line 460
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 460
      if (! ((size_t )i < fieldcount)) {
#line 460
        goto while_break___5;
      }
#line 462
      isuniquename = 1;
#line 463
      j = 0;
      {
#line 463
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 463
        if (! (j < i)) {
#line 463
          goto while_break___6;
        }
#line 464
        if (i != j) {
          {
#line 464
          tmp___28 = strcmp((char const   *)(*(fieldnames + i)), (char const   *)(*(fieldnames + j)));
          }
#line 464
          if (! tmp___28) {
#line 465
            isuniquename = 0;
#line 466
            goto while_break___6;
          }
        }
#line 463
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 470
      if (isuniquename) {
#line 471
        goto __Cont;
      }
      {
#line 477
      strcpy((char */* __restrict  */)(basename), (char const   */* __restrict  */)(*(fieldnames + i)));
#line 478
      serial = 2;
      }
      {
#line 479
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 479
        if (! (! isuniquename)) {
#line 479
          goto while_break___7;
        }
        {
#line 485
        sprintf((char */* __restrict  */)(*(fieldnames + i)), (char const   */* __restrict  */)"%s_%d",
                basename, serial);
#line 486
        isuniquename = 1;
#line 487
        j = 0;
        }
        {
#line 487
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 487
          if (! ((size_t )j < fieldcount)) {
#line 487
            goto while_break___8;
          }
#line 488
          if (j != i) {
            {
#line 488
            tmp___29 = strcmp((char const   *)(*(fieldnames + i)), (char const   *)(*(fieldnames + j)));
            }
#line 488
            if (! tmp___29) {
#line 489
              isuniquename = 0;
#line 490
              goto while_break___8;
            }
          }
#line 487
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 493
        serial ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 460
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 502
  if (optusecreatetable) {
    {
#line 502
    printf((char const   */* __restrict  */)"CREATE TABLE %s (", baretablename);
    }
  }
#line 503
  printed = 0;
#line 504
  fieldnum = 0;
  {
#line 504
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 504
    if (! ((size_t )fieldnum < fieldcount)) {
#line 504
      goto while_break___9;
    }
#line 505
    if ((int )(fields + fieldnum)->type == 48) {
#line 506
      goto __Cont___0;
    }
#line 508
    if (printed) {
#line 508
      if (optusecreatetable) {
#line 509
        if (optusecreatetable) {
          {
#line 509
          printf((char const   */* __restrict  */)", ");
          }
        }
      } else {
#line 512
        printed = 1;
      }
    } else {
#line 512
      printed = 1;
    }
#line 515
    if (optusecreatetable) {
#line 518
      isreservedname = 0;
#line 519
      i = 0;
      {
#line 519
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 519
        if (! RESERVEDWORDS[i]) {
#line 519
          goto while_break___10;
        }
        {
#line 520
        tmp___30 = strcmp((char const   *)(*(fieldnames + fieldnum)), RESERVEDWORDS[i]);
        }
#line 520
        if (! tmp___30) {
          {
#line 521
          printf((char const   */* __restrict  */)"%s_%s ", tablename, *(fieldnames + fieldnum));
#line 522
          isreservedname = 1;
          }
#line 523
          goto while_break___10;
        }
#line 519
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 526
      if (! isreservedname) {
        {
#line 526
        printf((char const   */* __restrict  */)"%s ", *(fieldnames + fieldnum));
        }
      }
    }
    {
#line 530
    if ((int )(fields + fieldnum)->type == 66) {
#line 530
      goto case_66;
    }
#line 538
    if ((int )(fields + fieldnum)->type == 67) {
#line 538
      goto case_67___0;
    }
#line 541
    if ((int )(fields + fieldnum)->type == 68) {
#line 541
      goto case_68___0;
    }
#line 544
    if ((int )(fields + fieldnum)->type == 70) {
#line 544
      goto case_70;
    }
#line 547
    if ((int )(fields + fieldnum)->type == 71) {
#line 547
      goto case_71;
    }
#line 550
    if ((int )(fields + fieldnum)->type == 73) {
#line 550
      goto case_73;
    }
#line 553
    if ((int )(fields + fieldnum)->type == 76) {
#line 553
      goto case_76;
    }
#line 557
    if ((int )(fields + fieldnum)->type == 77) {
#line 557
      goto case_77;
    }
#line 574
    if ((int )(fields + fieldnum)->type == 78) {
#line 574
      goto case_78___0;
    }
#line 587
    if ((int )(fields + fieldnum)->type == 84) {
#line 587
      goto case_84___0;
    }
#line 590
    if ((int )(fields + fieldnum)->type == 89) {
#line 590
      goto case_89;
    }
#line 593
    goto switch_default___0;
    case_66: /* CIL Label */ 
    {
#line 533
    tmp___31 = asprintf(& (pgfields + fieldnum)->formatstring, "%%.%dlf", (int )(fields + fieldnum)->decimals);
    }
#line 533
    if (tmp___31 < 0) {
      {
#line 534
      exitwitherror("Unable to allocate a format string", (int const   )1);
      }
    }
#line 536
    if (optusecreatetable) {
      {
#line 536
      printf((char const   */* __restrict  */)"DOUBLE PRECISION");
      }
    }
#line 537
    goto switch_break___0;
    case_67___0: /* CIL Label */ 
#line 539
    if (optusecreatetable) {
      {
#line 539
      printf((char const   */* __restrict  */)"VARCHAR(%d)", (int )(fields + fieldnum)->length);
      }
    }
#line 540
    goto switch_break___0;
    case_68___0: /* CIL Label */ 
#line 542
    if (optusecreatetable) {
      {
#line 542
      printf((char const   */* __restrict  */)"DATE");
      }
    }
#line 543
    goto switch_break___0;
    case_70: /* CIL Label */ 
#line 545
    if (optusecreatetable) {
      {
#line 545
      printf((char const   */* __restrict  */)"NUMERIC(%d)", (int )(fields + fieldnum)->decimals);
      }
    }
#line 546
    goto switch_break___0;
    case_71: /* CIL Label */ 
#line 548
    if (optusecreatetable) {
      {
#line 548
      printf((char const   */* __restrict  */)"BYTEA");
      }
    }
#line 549
    goto switch_break___0;
    case_73: /* CIL Label */ 
#line 551
    if (optusecreatetable) {
      {
#line 551
      printf((char const   */* __restrict  */)"INTEGER");
      }
    }
#line 552
    goto switch_break___0;
    case_76: /* CIL Label */ 
#line 555
    if (optusecreatetable) {
      {
#line 555
      printf((char const   */* __restrict  */)"BOOLEAN");
      }
    }
#line 556
    goto switch_break___0;
    case_77: /* CIL Label */ 
#line 558
    if ((unsigned long )memofilename == (unsigned long )((void *)0)) {
      {
#line 559
      printf((char const   */* __restrict  */)"\n");
#line 560
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Table %s has memo fields, but couldn\'t open the related memo file\n",
              tablename);
#line 561
      exit(1);
      }
    }
#line 563
    if (optusecreatetable) {
      {
#line 563
      printf((char const   */* __restrict  */)"TEXT");
      }
    }
#line 566
    if ((int )(fields + fieldnum)->length == 4) {
#line 567
      (pgfields + fieldnum)->memonumbering = 1;
    } else
#line 568
    if ((int )(fields + fieldnum)->length == 10) {
#line 569
      (pgfields + fieldnum)->memonumbering = 0;
    } else {
      {
#line 571
      exitwitherror("Unknown memo record number style", (int const   )0);
      }
    }
#line 573
    goto switch_break___0;
    case_78___0: /* CIL Label */ 
#line 575
    if (optusecreatetable) {
#line 576
      if (optnumericasnumeric) {
#line 577
        if ((int )(fields + fieldnum)->decimals > 0) {
          {
#line 578
          printf((char const   */* __restrict  */)"NUMERIC(%d, %d)", (int )(fields + fieldnum)->length,
                 (int )(fields + fieldnum)->decimals);
          }
        } else {
          {
#line 580
          printf((char const   */* __restrict  */)"NUMERIC(%d)", (int )(fields + fieldnum)->length);
          }
        }
      } else {
        {
#line 583
        printf((char const   */* __restrict  */)"TEXT");
        }
      }
    }
#line 586
    goto switch_break___0;
    case_84___0: /* CIL Label */ 
#line 588
    if (optusecreatetable) {
      {
#line 588
      printf((char const   */* __restrict  */)"TIMESTAMP");
      }
    }
#line 589
    goto switch_break___0;
    case_89: /* CIL Label */ 
#line 591
    if (optusecreatetable) {
      {
#line 591
      printf((char const   */* __restrict  */)"DECIMAL(4)");
      }
    }
#line 592
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 594
    if (optusecreatetable) {
      {
#line 594
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 595
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unhandled field type: %c\n",
            (int )(fields + fieldnum)->type);
#line 596
    exit(1);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 598
    if ((size_t )(fields + fieldnum)->length > longestfield) {
#line 599
      longestfield = (size_t )(fields + fieldnum)->length;
    }
    __Cont___0: /* CIL Label */ 
#line 504
    fieldnum ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 602
  if (optusecreatetable) {
    {
#line 602
    printf((char const   */* __restrict  */)");\n");
    }
  }
#line 605
  if (optusetruncatetable) {
    {
#line 606
    printf((char const   */* __restrict  */)"TRUNCATE TABLE %s;\n", baretablename);
    }
  }
  {
#line 610
  printf((char const   */* __restrict  */)"\\COPY %s FROM STDIN\n", baretablename);
#line 612
  tmp___32 = nativeint16_t((int16_t const   )dbfheader.recordlength);
#line 612
  dbfbatchsize = (unsigned int )(16777216 / (int )tmp___32);
  }
#line 613
  if (! dbfbatchsize) {
#line 614
    dbfbatchsize = 1U;
  }
  {
#line 616
  tmp___33 = nativeint16_t((int16_t const   )dbfheader.recordlength);
#line 616
  tmp___34 = malloc((size_t )((unsigned int )tmp___33 * dbfbatchsize));
#line 616
  inputbuffer = (char *)tmp___34;
  }
#line 617
  if ((unsigned long )inputbuffer == (unsigned long )((void *)0)) {
    {
#line 618
    exitwitherror("Unable to malloc a record buffer", (int const   )1);
    }
  }
  {
#line 620
  tmp___35 = malloc(longestfield + 1UL);
#line 620
  outputbuffer = (char *)tmp___35;
  }
#line 621
  if ((unsigned long )outputbuffer == (unsigned long )((void *)0)) {
    {
#line 622
    exitwitherror("Unable to malloc the output buffer", (int const   )1);
    }
  }
#line 627
  if (optshowprogress) {
    {
#line 628
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Progress: 0");
#line 629
    fflush(stderr);
    }
  }
#line 631
  recordbase = 0U;
  {
#line 631
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 631
    tmp___57 = nativeint32_t((int32_t const   )dbfheader.recordcount);
    }
#line 631
    if (! (recordbase < (unsigned int )tmp___57)) {
#line 631
      goto while_break___11;
    }
    {
#line 632
    tmp___36 = nativeint16_t((int16_t const   )dbfheader.recordlength);
#line 632
    blocksread = fread((void */* __restrict  */)inputbuffer, (size_t )tmp___36, (size_t )dbfbatchsize,
                       (FILE */* __restrict  */)dbffile);
    }
#line 633
    if (blocksread != (size_t )dbfbatchsize) {
      {
#line 633
      tmp___37 = nativeint32_t((int32_t const   )dbfheader.recordcount);
      }
#line 633
      if ((size_t )recordbase + blocksread < (size_t )tmp___37) {
        {
#line 635
        exitwitherror("Unable to read an entire record", (int const   )1);
        }
      }
    }
#line 637
    batchindex = 0U;
    {
#line 637
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 637
      if (! ((size_t )batchindex < blocksread)) {
#line 637
        goto while_break___12;
      }
      {
#line 638
      tmp___38 = nativeint16_t((int16_t const   )dbfheader.recordlength);
#line 638
      bufoffset = inputbuffer + (unsigned int )tmp___38 * batchindex;
      }
#line 640
      if ((int )*(bufoffset + 0) == 42) {
#line 641
        goto __Cont___1;
      }
#line 643
      bufoffset ++;
#line 644
      fieldnum = 0;
      {
#line 644
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 644
        if (! ((size_t )fieldnum < fieldcount)) {
#line 644
          goto while_break___13;
        }
#line 645
        if ((int )(fields + fieldnum)->type == 48) {
#line 646
          goto __Cont___2;
        }
#line 648
        if (fieldnum) {
          {
#line 649
          printf((char const   */* __restrict  */)"\t");
          }
        }
        {
#line 652
        if ((int )(fields + fieldnum)->type == 66) {
#line 652
          goto case_66___0;
        }
#line 656
        if ((int )(fields + fieldnum)->type == 67) {
#line 656
          goto case_67___1;
        }
#line 660
        if ((int )(fields + fieldnum)->type == 68) {
#line 660
          goto case_68___1;
        }
#line 680
        if ((int )(fields + fieldnum)->type == 71) {
#line 680
          goto case_71___0;
        }
#line 687
        if ((int )(fields + fieldnum)->type == 73) {
#line 687
          goto case_73___0;
        }
#line 691
        if ((int )(fields + fieldnum)->type == 76) {
#line 691
          goto case_76___0;
        }
#line 703
        if ((int )(fields + fieldnum)->type == 77) {
#line 703
          goto case_77___0;
        }
#line 734
        if ((int )(fields + fieldnum)->type == 78) {
#line 734
          goto case_78___1;
        }
#line 734
        if ((int )(fields + fieldnum)->type == 70) {
#line 734
          goto case_78___1;
        }
#line 749
        if ((int )(fields + fieldnum)->type == 84) {
#line 749
          goto case_84___2;
        }
#line 763
        if ((int )(fields + fieldnum)->type == 89) {
#line 763
          goto case_89___1;
        }
#line 651
        goto switch_break___1;
        case_66___0: /* CIL Label */ 
        {
#line 654
        tmp___39 = sdouble((char const   *)bufoffset);
#line 654
        printf((char const   */* __restrict  */)(pgfields + fieldnum)->formatstring,
               tmp___39);
        }
#line 655
        goto switch_break___1;
        case_67___1: /* CIL Label */ 
        {
#line 658
        safeprintbuf((char const   *)bufoffset, (size_t const   )(fields + fieldnum)->length);
        }
#line 659
        goto switch_break___1;
        case_68___1: /* CIL Label */ 
#line 662
        if ((int )*(bufoffset + 0) == 32) {
          {
#line 663
          printf((char const   */* __restrict  */)"\\N");
          }
        } else
#line 662
        if ((int )*(bufoffset + 0) == 0) {
          {
#line 663
          printf((char const   */* __restrict  */)"\\N");
          }
        } else {
          {
#line 665
          s = outputbuffer;
#line 666
          tmp___40 = s;
#line 666
          s ++;
#line 666
          *tmp___40 = *(bufoffset + 0);
#line 667
          tmp___41 = s;
#line 667
          s ++;
#line 667
          *tmp___41 = *(bufoffset + 1);
#line 668
          tmp___42 = s;
#line 668
          s ++;
#line 668
          *tmp___42 = *(bufoffset + 2);
#line 669
          tmp___43 = s;
#line 669
          s ++;
#line 669
          *tmp___43 = *(bufoffset + 3);
#line 670
          tmp___44 = s;
#line 670
          s ++;
#line 670
          *tmp___44 = (char )'-';
#line 671
          tmp___45 = s;
#line 671
          s ++;
#line 671
          *tmp___45 = *(bufoffset + 4);
#line 672
          tmp___46 = s;
#line 672
          s ++;
#line 672
          *tmp___46 = *(bufoffset + 5);
#line 673
          tmp___47 = s;
#line 673
          s ++;
#line 673
          *tmp___47 = (char )'-';
#line 674
          tmp___48 = s;
#line 674
          s ++;
#line 674
          *tmp___48 = *(bufoffset + 6);
#line 675
          tmp___49 = s;
#line 675
          s ++;
#line 675
          *tmp___49 = *(bufoffset + 7);
#line 676
          tmp___50 = s;
#line 676
          s ++;
#line 676
          *tmp___50 = (char )'\000';
#line 677
          printf((char const   */* __restrict  */)"%s", outputbuffer);
          }
        }
#line 679
        goto switch_break___1;
        case_71___0: /* CIL Label */ 
#line 686
        goto switch_break___1;
        case_73___0: /* CIL Label */ 
        {
#line 689
        tmp___51 = snativeint32_t((char const   *)bufoffset);
#line 689
        printf((char const   */* __restrict  */)"%d", tmp___51);
        }
#line 690
        goto switch_break___1;
        case_76___0: /* CIL Label */ 
        {
#line 695
        if ((int )*(bufoffset + 0) == 84) {
#line 695
          goto case_84___1;
        }
#line 695
        if ((int )*(bufoffset + 0) == 89) {
#line 695
          goto case_84___1;
        }
#line 698
        goto switch_default___1;
        case_84___1: /* CIL Label */ 
        case_89___0: /* CIL Label */ 
        {
#line 696
        putchar('t');
        }
#line 697
        goto switch_break___2;
        switch_default___1: /* CIL Label */ 
        {
#line 699
        putchar('f');
        }
#line 700
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 702
        goto switch_break___1;
        case_77___0: /* CIL Label */ 
#line 705
        if ((pgfields + fieldnum)->memonumbering == 1) {
          {
#line 706
          memoblocknumber = snativeint32_t((char const   *)bufoffset);
          }
        } else {
#line 708
          memoblocknumber = 0;
#line 709
          s = bufoffset;
#line 710
          i = 0;
          {
#line 710
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 710
            if (! (i < 10)) {
#line 710
              goto while_break___14;
            }
#line 711
            if ((int )*s != 32) {
#line 714
              memoblocknumber = (memoblocknumber * 10 + (int32_t )*s) - 48;
            }
#line 716
            s ++;
#line 710
            i ++;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 719
        if (memoblocknumber) {
#line 720
          memorecordoffset = memoblocksize * (size_t )memoblocknumber;
#line 721
          if (memorecordoffset >= memofilesize) {
            {
#line 722
            exitwitherror("A memo record past the end of the memofile was requested",
                          (int const   )0);
            }
          }
#line 724
          memorecord = (char *)(memomap + memorecordoffset);
#line 725
          if (memofileisdbase3) {
            {
#line 726
            t = strchr((char const   *)memorecord, 26);
#line 727
            safeprintbuf((char const   *)memorecord, (size_t const   )(t - memorecord));
            }
          } else {
            {
#line 729
            tmp___52 = sswappedint32_t((char const   *)(memorecord + 4));
#line 729
            safeprintbuf((char const   *)(memorecord + 8), (size_t const   )tmp___52);
            }
          }
        }
#line 732
        goto switch_break___1;
        case_78___1: /* CIL Label */ 
        case_70___0: /* CIL Label */ 
        {
#line 736
        strncpy((char */* __restrict  */)outputbuffer, (char const   */* __restrict  */)bufoffset,
                (size_t )(fields + fieldnum)->length);
#line 737
        *(outputbuffer + (fields + fieldnum)->length) = (char )'\000';
#line 739
        s = outputbuffer;
        }
        {
#line 740
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 740
          if (! ((int )*s == 32)) {
#line 740
            goto while_break___15;
          }
#line 741
          s ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 743
        if ((int )*s == 0) {
          {
#line 744
          printf((char const   */* __restrict  */)"\\N");
          }
        } else {
          {
#line 746
          printf((char const   */* __restrict  */)"%s", s);
          }
        }
#line 748
        goto switch_break___1;
        case_84___2: /* CIL Label */ 
        {
#line 751
        juliandays = snativeint32_t((char const   *)bufoffset);
#line 752
        tmp___53 = snativeint32_t((char const   *)(bufoffset + 4));
#line 752
        seconds = (tmp___53 + 1) / 1000;
        }
#line 753
        if (juliandays) {
          {
#line 756
          hours = seconds / 3600;
#line 757
          seconds -= hours * 3600;
#line 758
          minutes = seconds / 60;
#line 759
          seconds -= minutes * 60;
#line 760
          printf((char const   */* __restrict  */)"J%d %02d:%02d:%02d", juliandays,
                 hours, minutes, seconds);
          }
        } else
#line 753
        if (seconds) {
          {
#line 756
          hours = seconds / 3600;
#line 757
          seconds -= hours * 3600;
#line 758
          minutes = seconds / 60;
#line 759
          seconds -= minutes * 60;
#line 760
          printf((char const   */* __restrict  */)"J%d %02d:%02d:%02d", juliandays,
                 hours, minutes, seconds);
          }
        } else {
          {
#line 754
          printf((char const   */* __restrict  */)"\\N");
          }
        }
#line 762
        goto switch_break___1;
        case_89___1: /* CIL Label */ 
        {
#line 765
        tmp___54 = snativeint64_t((char const   *)bufoffset);
#line 765
        tmp___55 = sprintf((char */* __restrict  */)outputbuffer, (char const   */* __restrict  */)"%05ld",
                           tmp___54);
#line 765
        t = outputbuffer + tmp___55;
#line 766
        *(t + 1) = (char )'\000';
#line 767
        *t = *(t - 1);
#line 768
        *(t - 1) = *(t - 2);
#line 769
        *(t - 2) = *(t - 3);
#line 770
        *(t - 3) = *(t - 4);
#line 771
        *(t - 4) = (char )'.';
#line 772
        printf((char const   */* __restrict  */)"%s", outputbuffer);
        }
#line 773
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 775
        bufoffset += (int )(fields + fieldnum)->length;
        __Cont___2: /* CIL Label */ 
#line 644
        fieldnum ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 777
      printf((char const   */* __restrict  */)"\n");
      }
      __Cont___1: /* CIL Label */ 
#line 637
      batchindex ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 779
    if (optshowprogress) {
      {
#line 780
      tmp___56 = nativeint32_t((int32_t const   )dbfheader.recordcount);
#line 780
      updateprogressbar((int )((100UL * ((size_t )recordbase + blocksread)) / (size_t )tmp___56));
      }
    }
#line 631
    recordbase += dbfbatchsize;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 783
  if (optshowprogress) {
    {
#line 783
    updateprogressbar(100);
    }
  }
  {
#line 784
  free((void *)inputbuffer);
#line 785
  free((void *)outputbuffer);
#line 786
  printf((char const   */* __restrict  */)"\\.\n");
  }
#line 789
  if (optusetransaction) {
    {
#line 790
    printf((char const   */* __restrict  */)"COMMIT;\n");
    }
  }
#line 794
  i = optind + 1;
  {
#line 794
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 794
    if (! (i < argc)) {
#line 794
      goto while_break___16;
    }
    {
#line 795
    printf((char const   */* __restrict  */)"CREATE INDEX %s_", tablename);
#line 796
    s = *(argv + i);
    }
    {
#line 796
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 796
      if (! *s) {
#line 796
        goto while_break___17;
      }
      {
#line 797
      tmp___58 = __ctype_b_loc();
      }
#line 797
      if ((int const   )*(*tmp___58 + (int )*s) & 8) {
        {
#line 798
        putchar((int )*s);
#line 799
        lastcharwasreplaced = 0;
        }
      } else
#line 802
      if (! lastcharwasreplaced) {
        {
#line 803
        putchar('_');
#line 804
        lastcharwasreplaced = 1;
        }
      }
#line 796
      s ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 808
    printf((char const   */* __restrict  */)" ON %s(%s);\n", baretablename, *(argv + i));
#line 794
    i ++;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 811
  free((void *)tablename);
#line 812
  free((void *)baretablename);
#line 813
  free((void *)fields);
#line 814
  fieldnum = 0;
  }
  {
#line 814
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 814
    if (! ((size_t )fieldnum < fieldcount)) {
#line 814
      goto while_break___18;
    }
#line 815
    if ((unsigned long )(pgfields + fieldnum)->formatstring != (unsigned long )((void *)0)) {
      {
#line 816
      free((void *)(pgfields + fieldnum)->formatstring);
      }
    }
#line 814
    fieldnum ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 819
  free((void *)pgfields);
#line 820
  fclose(dbffile);
  }
#line 821
  if ((unsigned long )memomap != (unsigned long )((void *)0)) {
    {
#line 822
    tmp___59 = munmap(memomap, (size_t )memostat.st_size);
    }
#line 822
    if (tmp___59 == -1) {
      {
#line 823
      exitwitherror("Unable to munmap the memofile", (int const   )1);
      }
    }
    {
#line 825
    close(memofd);
    }
  }
#line 829
  if ((unsigned long )conv_desc != (unsigned long )((void *)0)) {
    {
#line 830
    tmp___62 = iconv_close(conv_desc);
    }
#line 830
    if (tmp___62 != 0) {
      {
#line 831
      tmp___60 = __errno_location();
#line 831
      tmp___61 = strerror(*tmp___60);
#line 831
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iconv_close failed: %s\n",
              tmp___61);
#line 832
      exit(1);
      }
    }
  }
#line 837
  return (0);
}
}
