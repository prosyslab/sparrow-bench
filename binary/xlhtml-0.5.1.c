/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 43 "../cole/internal.h"
struct pps_block {
   char name[32] ;
   char filename[18] ;
   unsigned char type ;
   unsigned int size ;
   unsigned int next ;
   unsigned int dir ;
   unsigned short level ;
   unsigned int seconds1 ;
   unsigned int seconds2 ;
   unsigned int days1 ;
   unsigned int days2 ;
   unsigned int start ;
   unsigned int previous ;
   unsigned int ppsnumber ;
};
#line 65 "../cole/internal.h"
typedef struct pps_block pps_entry;
#line 98 "../cole/internal.h"
struct _COLEFS {
   pps_entry *tree ;
   unsigned int root ;
   unsigned char *BDepot ;
   unsigned char *SDepot ;
   FILE *sbfile ;
   char *sbfilename ;
   FILE *file ;
};
#line 108
struct _COLEDIR;
#line 108 "../cole/internal.h"
struct _COLEDIRENT {
   unsigned int entry ;
   struct _COLEDIR *dir ;
};
#line 113 "../cole/internal.h"
struct _COLEDIR {
   unsigned int entry ;
   struct _COLEDIRENT visited_entry ;
   struct _COLEFS *fs ;
};
#line 119 "../cole/internal.h"
struct _COLEFILE {
   unsigned int entry ;
   FILE *file ;
   char *filename ;
   unsigned int filesize ;
   struct _COLEFS *fs ;
   unsigned int pos ;
};
#line 68 "../cole/cole.h"
enum _COLERRNO {
    COLE_EFIRST = 0,
    COLE_EMEMORY = 1,
    COLE_EOPENFILE = 2,
    COLE_ECLOSEFILE = 3,
    COLE_EREAD = 4,
    COLE_EWRITE = 5,
    COLE_EREMOVE = 6,
    COLE_ETMPNAM = 7,
    COLE_ESEEK = 8,
    COLE_EERRNO = 9,
    COLE_ENOFILESYSTEM = 10,
    COLE_EINVALIDFILESYSTEM = 11,
    COLE_EISNOTDIR = 12,
    COLE_EISNOTFILE = 13,
    COLE_EFILENOTFOUND = 14,
    COLE_EOF = 15,
    COLE_EMEMBERISNOTDIR = 16,
    COLE_EBROKENFILENAME = 17,
    COLE_EFILENAMEISNOTFILE = 18,
    COLE_EFSEEKDELTA = 19,
    COLE_EFSEEKFLAG = 20,
    COLE_EUNKNOWN = 21,
    COLE_ELAST = 22
} ;
#line 96 "../cole/cole.h"
typedef enum _COLERRNO COLERRNO;
#line 120 "../cole/cole.h"
typedef struct _COLEFS COLEFS;
#line 122 "../cole/cole.h"
typedef struct _COLEDIRENT COLEDIRENT;
#line 123 "../cole/cole.h"
typedef struct _COLEFILE COLEFILE;
#line 139 "../cole/cole.h"
typedef void COLE_LOCATE_ACTION_FUNC(COLEDIRENT *coledirentry , void *info );
#line 47 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
enum __anonenum_type_26 {
    real = 0,
    MY_FILE_list = 1,
    block_list = 2,
    root_list___0 = 3
} ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
struct str_real {
   char *name ;
   unsigned int ppsnumber ;
};
#line 47 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
union union_file {
   struct str_real real ;
   struct str_MY_FILE *MY_FILE_list ;
   unsigned int *block_list ;
   unsigned char *root_list ;
};
#line 47 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
struct str_MY_FILE {
   enum __anonenum_type_26 type ;
   unsigned int size ;
   unsigned int *blocks ;
   union union_file file ;
};
#line 68 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
typedef struct str_MY_FILE MY_FILE;
#line 105 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
enum _COLE_SEEK_FLAG {
    COLE_SEEK_SET = 0,
    COLE_SEEK_FORWARD = 1,
    COLE_SEEK_BACKWARD = 2,
    COLE_SEEK_END = 3
} ;
#line 112 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
typedef enum _COLE_SEEK_FLAG COLE_SEEK_FLAG;
#line 121 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
typedef struct _COLEDIR COLEDIR;
#line 131 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
typedef int COLE_RECURSE_DIR_FUNC(COLEDIR *coledir , void *info , COLERRNO *colerrno );
#line 134 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
typedef int COLE_RECURSE_DIRENT_FUNC(COLEDIRENT *coledirentry , void *info , COLERRNO *colerrno );
#line 137 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
typedef int COLE_RECURSE_VISIT_DIR_FUNC(COLEDIR *coledir , void *info );
#line 580 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
struct _cole_fopen_info {
   COLEFILE *file ;
   int succ ;
   COLERRNO colerrno ;
};
#line 1091 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
struct __cole_locate_filenameinfo {
   COLE_LOCATE_ACTION_FUNC *action ;
   void *info ;
   char *filename ;
   char *current ;
   int visitdir ;
};
#line 208 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
typedef int swords[2];
#line 217 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
union __anonunion_27 {
   swords sw ;
   double dub ;
};
#line 218 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
union __anonunion_29 {
   swords sw ;
   double dub ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_uni_string_28 {
   unsigned char uni ;
   unsigned char *str ;
   unsigned short len ;
   unsigned char *fmt_run ;
   unsigned char crun_cnt ;
};
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_uni_string_28 uni_string;
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_cell_29 {
   unsigned short xfmt ;
   unsigned short type ;
   unsigned short spanned ;
   uni_string ustr ;
   unsigned short rowspan ;
   unsigned short colspan ;
   uni_string h_link ;
};
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_cell_29 cell;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_work_sheet_30 {
   unsigned int first_row ;
   int biggest_row ;
   unsigned int max_rows ;
   unsigned short first_col ;
   short biggest_col ;
   unsigned short max_cols ;
   uni_string ws_title ;
   cell **c_array ;
   unsigned short spanned ;
};
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_work_sheet_30 work_sheet;
#line 107 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_font_attr_31 {
   unsigned short size ;
   unsigned short attr ;
   unsigned short c_idx ;
   unsigned short bold ;
   unsigned short super ;
   unsigned char underline ;
   uni_string name ;
};
#line 107 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_font_attr_31 font_attr;
#line 118 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_fnt_cnt_32 {
   uni_string *name ;
   unsigned short cnt ;
};
#line 118 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_fnt_cnt_32 fnt_cnt;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_xf_attr_33 {
   unsigned short fnt_idx ;
   unsigned short fmt_idx ;
   unsigned short gen ;
   unsigned short align ;
   unsigned short indent ;
   unsigned short b_style ;
   unsigned short b_l_color ;
   unsigned int b_t_color ;
   unsigned short cell_color ;
};
#line 125 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_xf_attr_33 xf_attr;
#line 139 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
struct __anonstruct_html_attr_34 {
   int fflag ;
   int bflag ;
   int iflag ;
   int sflag ;
   int uflag ;
   int sbflag ;
   int spflag ;
};
#line 139 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
typedef struct __anonstruct_html_attr_34 html_attr;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 98 "../cole/cole.h"
void cole_perror(char const   *s , COLERRNO colerrno ) ;
#line 150
COLEFS *cole_mount(char *filename___4 , COLERRNO *colerrno ) ;
#line 152
int cole_umount(COLEFS *colefilesystem , COLERRNO *colerrno ) ;
#line 156
int cole_locate_filename(COLEFS *colefilesystem , char *filename___4 , void *info ,
                         COLE_LOCATE_ACTION_FUNC *action , COLERRNO *colerrno ) ;
#line 177
COLEFILE *cole_fopen_direntry(COLEDIRENT *coledirentry , COLERRNO *colerrno ) ;
#line 179
int cole_fclose(COLEFILE *colefile , COLERRNO *colerrno ) ;
#line 182
size_t cole_fread(COLEFILE *colefile , void *ptr , size_t size , COLERRNO *colerrno ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xldump.c"
static char FileName[2][12]  = { {        (char )'/',        (char )'W',        (char )'o',        (char )'r', 
            (char )'k',        (char )'b',        (char )'o',        (char )'o', 
            (char )'k',        (char )'\000'}, 
   {        (char )'/',        (char )'B',        (char )'o',        (char )'o', 
            (char )'k',        (char )'\000'}};
#line 48
void dump_file(COLEDIRENT *cde , void *_info ) ;
#line 50
static void output_opcode_string(int opcode ) ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xldump.c"
static char filename___0[128]  ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xldump.c"
int main(int argc , char **argv ) 
{ 
  int f_ptr ;
  COLEFS *cfs ;
  COLERRNO colerrno ;
  int tmp ;
  int tmp___0 ;

  {
#line 58
  f_ptr = 0;
#line 62
  if (argc < 2) {
    {
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dump - Outputs excel file records for analysis.\nUsage: xldump <FILE>\n");
#line 66
    exit(1);
    }
  } else {
    {
#line 70
    strncpy((char */* __restrict  */)(filename___0), (char const   */* __restrict  */)*(argv + 1),
            (size_t )124);
#line 71
    cfs = cole_mount(filename___0, & colerrno);
    }
#line 72
    if ((unsigned long )cfs == (unsigned long )((void *)0)) {
      {
#line 74
      cole_perror("xldump", colerrno);
#line 75
      exit(1);
      }
    }
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp = cole_locate_filename(cfs, FileName[f_ptr], (void *)0, & dump_file, & colerrno);
    }
#line 79
    if (! tmp) {
#line 79
      goto while_break;
    }
#line 81
    if (f_ptr) {
      {
#line 83
      cole_perror("xldump", colerrno);
      }
#line 84
      goto while_break;
    } else {
#line 87
      f_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp___0 = cole_umount(cfs, & colerrno);
  }
#line 90
  if (tmp___0) {
    {
#line 92
    cole_perror("travel", colerrno);
#line 93
    exit(1);
    }
  }
#line 96
  return (0);
}
}
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xldump.c"
void dump_file(COLEDIRENT *cde , void *_info ) 
{ 
  unsigned int length ;
  unsigned int opcode ;
  unsigned int target ;
  unsigned int count ;
  unsigned char buf[16] ;
  COLEFILE *cf ;
  COLERRNO err ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;

  {
  {
#line 102
  length = 0U;
#line 102
  opcode = 0U;
#line 102
  target = 0U;
#line 102
  count = 0U;
#line 107
  cf = cole_fopen_direntry(cde, & err);
#line 110
  printf((char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n");
#line 111
  printf((char const   */* __restrict  */)"<HTML><HEAD><TITLE>%s", filename___0);
#line 112
  printf((char const   */* __restrict  */)"</TITLE></HEAD><BODY>\n");
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp___0 = cole_fread(cf, (void *)(buf), (size_t )1, & err);
    }
#line 118
    if (! tmp___0) {
#line 118
      goto while_break;
    }
#line 123
    if (count == 0U) {
      {
#line 125
      length = 0U;
#line 126
      opcode = (unsigned int )buf[0];
#line 127
      target = 80U;
#line 128
      printf((char const   */* __restrict  */)"<br>");
      }
    } else
#line 130
    if (count == 1U) {
#line 131
      opcode = (unsigned int )((long )opcode | ((long )((int )buf[0] << 8) & 65535L));
    } else
#line 132
    if (count == 2U) {
#line 133
      length = (unsigned int )buf[0];
    } else
#line 134
    if (count == 3U) {
      {
#line 136
      length |= (unsigned int )((int )buf[0] << 8);
#line 137
      target = length;
#line 138
      printf((char const   */* __restrict  */)"<br>\nLength:%04X Opcode:%04X - ",
             length, opcode);
#line 139
      output_opcode_string((int )opcode);
#line 140
      puts("<br>\n");
      }
    }
#line 142
    if (count > 3U) {
      {
#line 146
      tmp = __ctype_b_loc();
      }
#line 146
      if ((int const   )*(*tmp + (int )buf[0]) & 16384) {
        {
#line 147
        _IO_putc((int )buf[0], stdout);
        }
      }
    }
#line 154
    if (count == target + 3U) {
#line 155
      count = 0U;
    } else {
#line 157
      count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  printf((char const   */* __restrict  */)"</BODY></HTML>\n");
#line 174
  cole_fclose(cf, & err);
  }
#line 175
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xldump.c"
static void output_opcode_string(int opcode ) 
{ 


  {
  {
#line 189
  if ((opcode & 255) == 10) {
#line 189
    goto case_10;
  }
#line 192
  if ((opcode & 255) == 12) {
#line 192
    goto case_12;
  }
#line 195
  if ((opcode & 255) == 13) {
#line 195
    goto case_13;
  }
#line 198
  if ((opcode & 255) == 14) {
#line 198
    goto case_14;
  }
#line 201
  if ((opcode & 255) == 15) {
#line 201
    goto case_15;
  }
#line 204
  if ((opcode & 255) == 16) {
#line 204
    goto case_16;
  }
#line 207
  if ((opcode & 255) == 17) {
#line 207
    goto case_17;
  }
#line 210
  if ((opcode & 255) == 18) {
#line 210
    goto case_18;
  }
#line 213
  if ((opcode & 255) == 19) {
#line 213
    goto case_19;
  }
#line 216
  if ((opcode & 255) == 20) {
#line 216
    goto case_20;
  }
#line 219
  if ((opcode & 255) == 21) {
#line 219
    goto case_21;
  }
#line 222
  if ((opcode & 255) == 22) {
#line 222
    goto case_22;
  }
#line 225
  if ((opcode & 255) == 23) {
#line 225
    goto case_23;
  }
#line 228
  if ((opcode & 255) == 24) {
#line 228
    goto case_24;
  }
#line 231
  if ((opcode & 255) == 25) {
#line 231
    goto case_25;
  }
#line 234
  if ((opcode & 255) == 26) {
#line 234
    goto case_26;
  }
#line 237
  if ((opcode & 255) == 27) {
#line 237
    goto case_27;
  }
#line 240
  if ((opcode & 255) == 28) {
#line 240
    goto case_28;
  }
#line 243
  if ((opcode & 255) == 29) {
#line 243
    goto case_29;
  }
#line 246
  if ((opcode & 255) == 34) {
#line 246
    goto case_34;
  }
#line 249
  if ((opcode & 255) == 38) {
#line 249
    goto case_38;
  }
#line 252
  if ((opcode & 255) == 39) {
#line 252
    goto case_39;
  }
#line 255
  if ((opcode & 255) == 40) {
#line 255
    goto case_40;
  }
#line 258
  if ((opcode & 255) == 41) {
#line 258
    goto case_41;
  }
#line 261
  if ((opcode & 255) == 42) {
#line 261
    goto case_42;
  }
#line 264
  if ((opcode & 255) == 43) {
#line 264
    goto case_43;
  }
#line 267
  if ((opcode & 255) == 47) {
#line 267
    goto case_47;
  }
#line 270
  if ((opcode & 255) == 49) {
#line 270
    goto case_49;
  }
#line 273
  if ((opcode & 255) == 60) {
#line 273
    goto case_60;
  }
#line 276
  if ((opcode & 255) == 61) {
#line 276
    goto case_61;
  }
#line 279
  if ((opcode & 255) == 64) {
#line 279
    goto case_64;
  }
#line 282
  if ((opcode & 255) == 65) {
#line 282
    goto case_65;
  }
#line 285
  if ((opcode & 255) == 66) {
#line 285
    goto case_66;
  }
#line 288
  if ((opcode & 255) == 77) {
#line 288
    goto case_77;
  }
#line 291
  if ((opcode & 255) == 80) {
#line 291
    goto case_80;
  }
#line 294
  if ((opcode & 255) == 81) {
#line 294
    goto case_81;
  }
#line 297
  if ((opcode & 255) == 82) {
#line 297
    goto case_82;
  }
#line 300
  if ((opcode & 255) == 85) {
#line 300
    goto case_85;
  }
#line 303
  if ((opcode & 255) == 89) {
#line 303
    goto case_89;
  }
#line 306
  if ((opcode & 255) == 90) {
#line 306
    goto case_90;
  }
#line 309
  if ((opcode & 255) == 91) {
#line 309
    goto case_91;
  }
#line 312
  if ((opcode & 255) == 92) {
#line 312
    goto case_92;
  }
#line 315
  if ((opcode & 255) == 93) {
#line 315
    goto case_93;
  }
#line 318
  if ((opcode & 255) == 94) {
#line 318
    goto case_94;
  }
#line 321
  if ((opcode & 255) == 95) {
#line 321
    goto case_95;
  }
#line 324
  if ((opcode & 255) == 96) {
#line 324
    goto case_96;
  }
#line 327
  if ((opcode & 255) == 99) {
#line 327
    goto case_99;
  }
#line 330
  if ((opcode & 255) == 125) {
#line 330
    goto case_125;
  }
#line 333
  if ((opcode & 255) == 126) {
#line 333
    goto case_126;
  }
#line 336
  if ((opcode & 255) == 127) {
#line 336
    goto case_127;
  }
#line 339
  if ((opcode & 255) == 128) {
#line 339
    goto case_128;
  }
#line 342
  if ((opcode & 255) == 129) {
#line 342
    goto case_129;
  }
#line 345
  if ((opcode & 255) == 130) {
#line 345
    goto case_130;
  }
#line 348
  if ((opcode & 255) == 131) {
#line 348
    goto case_131;
  }
#line 351
  if ((opcode & 255) == 132) {
#line 351
    goto case_132;
  }
#line 354
  if ((opcode & 255) == 133) {
#line 354
    goto case_133;
  }
#line 357
  if ((opcode & 255) == 134) {
#line 357
    goto case_134;
  }
#line 360
  if ((opcode & 255) == 135) {
#line 360
    goto case_135;
  }
#line 363
  if ((opcode & 255) == 136) {
#line 363
    goto case_136;
  }
#line 366
  if ((opcode & 255) == 137) {
#line 366
    goto case_137;
  }
#line 369
  if ((opcode & 255) == 140) {
#line 369
    goto case_140;
  }
#line 372
  if ((opcode & 255) == 141) {
#line 372
    goto case_141;
  }
#line 375
  if ((opcode & 255) == 144) {
#line 375
    goto case_144;
  }
#line 378
  if ((opcode & 255) == 145) {
#line 378
    goto case_145;
  }
#line 381
  if ((opcode & 255) == 146) {
#line 381
    goto case_146;
  }
#line 384
  if ((opcode & 255) == 148) {
#line 384
    goto case_148;
  }
#line 387
  if ((opcode & 255) == 149) {
#line 387
    goto case_149;
  }
#line 390
  if ((opcode & 255) == 150) {
#line 390
    goto case_150;
  }
#line 393
  if ((opcode & 255) == 152) {
#line 393
    goto case_152;
  }
#line 396
  if ((opcode & 255) == 153) {
#line 396
    goto case_153;
  }
#line 399
  if ((opcode & 255) == 154) {
#line 399
    goto case_154;
  }
#line 402
  if ((opcode & 255) == 155) {
#line 402
    goto case_155;
  }
#line 405
  if ((opcode & 255) == 156) {
#line 405
    goto case_156;
  }
#line 408
  if ((opcode & 255) == 157) {
#line 408
    goto case_157;
  }
#line 411
  if ((opcode & 255) == 158) {
#line 411
    goto case_158;
  }
#line 414
  if ((opcode & 255) == 160) {
#line 414
    goto case_160;
  }
#line 417
  if ((opcode & 255) == 161) {
#line 417
    goto case_161;
  }
#line 420
  if ((opcode & 255) == 169) {
#line 420
    goto case_169;
  }
#line 423
  if ((opcode & 255) == 171) {
#line 423
    goto case_171;
  }
#line 426
  if ((opcode & 255) == 174) {
#line 426
    goto case_174;
  }
#line 429
  if ((opcode & 255) == 175) {
#line 429
    goto case_175;
  }
#line 432
  if ((opcode & 255) == 176) {
#line 432
    goto case_176;
  }
#line 435
  if ((opcode & 255) == 177) {
#line 435
    goto case_177;
  }
#line 438
  if ((opcode & 255) == 178) {
#line 438
    goto case_178;
  }
#line 441
  if ((opcode & 255) == 180) {
#line 441
    goto case_180;
  }
#line 444
  if ((opcode & 255) == 181) {
#line 444
    goto case_181;
  }
#line 447
  if ((opcode & 255) == 182) {
#line 447
    goto case_182;
  }
#line 450
  if ((opcode & 255) == 184) {
#line 450
    goto case_184;
  }
#line 453
  if ((opcode & 255) == 185) {
#line 453
    goto case_185;
  }
#line 456
  if ((opcode & 255) == 188) {
#line 456
    goto case_188;
  }
#line 459
  if ((opcode & 255) == 189) {
#line 459
    goto case_189;
  }
#line 462
  if ((opcode & 255) == 190) {
#line 462
    goto case_190;
  }
#line 465
  if ((opcode & 255) == 193) {
#line 465
    goto case_193;
  }
#line 468
  if ((opcode & 255) == 194) {
#line 468
    goto case_194;
  }
#line 471
  if ((opcode & 255) == 195) {
#line 471
    goto case_195;
  }
#line 474
  if ((opcode & 255) == 197) {
#line 474
    goto case_197;
  }
#line 477
  if ((opcode & 255) == 198) {
#line 477
    goto case_198;
  }
#line 480
  if ((opcode & 255) == 205) {
#line 480
    goto case_205;
  }
#line 483
  if ((opcode & 255) == 208) {
#line 483
    goto case_208;
  }
#line 486
  if ((opcode & 255) == 209) {
#line 486
    goto case_209;
  }
#line 489
  if ((opcode & 255) == 210) {
#line 489
    goto case_210;
  }
#line 492
  if ((opcode & 255) == 211) {
#line 492
    goto case_211;
  }
#line 495
  if ((opcode & 255) == 213) {
#line 495
    goto case_213;
  }
#line 498
  if ((opcode & 255) == 214) {
#line 498
    goto case_214;
  }
#line 501
  if ((opcode & 255) == 215) {
#line 501
    goto case_215;
  }
#line 504
  if ((opcode & 255) == 218) {
#line 504
    goto case_218;
  }
#line 517
  if ((opcode & 255) == 221) {
#line 517
    goto case_221;
  }
#line 520
  if ((opcode & 255) == 222) {
#line 520
    goto case_222;
  }
#line 523
  if ((opcode & 255) == 223) {
#line 523
    goto case_223;
  }
#line 526
  if ((opcode & 255) == 224) {
#line 526
    goto case_224;
  }
#line 529
  if ((opcode & 255) == 225) {
#line 529
    goto case_225;
  }
#line 532
  if ((opcode & 255) == 226) {
#line 532
    goto case_226;
  }
#line 535
  if ((opcode & 255) == 227) {
#line 535
    goto case_227;
  }
#line 538
  if ((opcode & 255) == 234) {
#line 538
    goto case_234;
  }
#line 541
  if ((opcode & 255) == 235) {
#line 541
    goto case_235;
  }
#line 544
  if ((opcode & 255) == 236) {
#line 544
    goto case_236;
  }
#line 547
  if ((opcode & 255) == 237) {
#line 547
    goto case_237;
  }
#line 550
  if ((opcode & 255) == 240) {
#line 550
    goto case_240;
  }
#line 553
  if ((opcode & 255) == 241) {
#line 553
    goto case_241;
  }
#line 556
  if ((opcode & 255) == 242) {
#line 556
    goto case_242;
  }
#line 559
  if ((opcode & 255) == 246) {
#line 559
    goto case_246;
  }
#line 562
  if ((opcode & 255) == 247) {
#line 562
    goto case_247;
  }
#line 565
  if ((opcode & 255) == 248) {
#line 565
    goto case_248;
  }
#line 568
  if ((opcode & 255) == 249) {
#line 568
    goto case_249;
  }
#line 571
  if ((opcode & 255) == 251) {
#line 571
    goto case_251;
  }
#line 574
  if ((opcode & 255) == 252) {
#line 574
    goto case_252;
  }
#line 577
  if ((opcode & 255) == 253) {
#line 577
    goto case_253;
  }
#line 580
  if ((opcode & 255) == 255) {
#line 580
    goto case_255;
  }
#line 585
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 190
  puts("\nEOF: End of File");
  }
#line 191
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 193
  puts("CALCCOUNT: Iteration count");
  }
#line 194
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 196
  puts("CalcMode: Calculation mode");
  }
#line 197
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 199
  puts("Precision");
  }
#line 200
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 202
  puts("Reference Mode");
  }
#line 203
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 205
  puts("Delta: Iteration Increment");
  }
#line 206
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 208
  puts("Iteration Mode");
  }
#line 209
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 211
  puts("Protection Flag");
  }
#line 212
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 214
  puts("Protection Password");
  }
#line 215
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 217
  puts("Print Header on each page");
  }
#line 218
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 220
  puts("Print Footer on each page");
  }
#line 221
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 223
  puts("External Count: Number of external references");
  }
#line 224
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 226
  puts("External reference");
  }
#line 227
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 229
  puts("NAME");
  }
#line 230
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 232
  puts("Windows are Protected");
  }
#line 233
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 235
  puts("Vertical Page Breaks");
  }
#line 236
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 238
  puts("Horizontal Page Breaks");
  }
#line 239
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 241
  puts("Cell Note");
  }
#line 242
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 244
  puts("Selection");
  }
#line 245
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 247
  puts("1904 date system");
  }
#line 248
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 250
  puts("Left Margin Measurement");
  }
#line 251
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 253
  puts("Right Margin Measurement");
  }
#line 254
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 256
  puts("Top Margin Measurement");
  }
#line 257
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 259
  puts("Bottom Margin Measurement");
  }
#line 260
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 262
  puts("Print Row/Column Labels");
  }
#line 263
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 265
  puts("Print Gridlines Flag");
  }
#line 266
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 268
  puts("File is Password protected");
  }
#line 269
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 271
  puts("FONT");
  }
#line 272
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 274
  puts("Continues long records");
  }
#line 275
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 277
  puts("Window1");
  }
#line 278
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 280
  puts("BACKUP: Save Backup Version of the File");
  }
#line 281
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 283
  puts("Number of Panes and their position");
  }
#line 284
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 286
  puts("CODEPAGE: Default code page");
  }
#line 287
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 289
  puts("PLS: Environment specific print record");
  }
#line 290
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 292
  puts("DCON: Data consolidation information");
  }
#line 293
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 295
  puts("DCONREF: Data consolidation references");
  }
#line 296
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 298
  puts("DCONNAME: Data Consolidation Named References");
  }
#line 299
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 301
  puts("DEFCOLWIDTH: Default Column Width");
  }
#line 302
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 304
  puts("XCT: CRN Record Count");
  }
#line 305
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 307
  puts("CRN: Nonresident operands");
  }
#line 308
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 310
  puts("FILESHARING:File-sharing information");
  }
#line 311
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 313
  puts("Write Access");
  }
#line 314
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 316
  puts("OBJ: Describes a Graphic object");
  }
#line 317
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 319
  puts("UNCALCED: Recalculation Status");
  }
#line 320
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 322
  puts("SAVERECALC: Recalculate before save");
  }
#line 323
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 325
  puts("TEMPLATE: Workbook is a template");
  }
#line 326
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 328
  puts("OBJPROTECT: Objects are protected");
  }
#line 329
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 331
  puts("COLINFO: Column formatting information");
  }
#line 332
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 334
  puts("RK Number");
  }
#line 335
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 337
  puts("IMDATA: Image data");
  }
#line 338
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 340
  puts("GUTS: Size of row and column gutters");
  }
#line 341
  goto switch_break;
  case_129: /* CIL Label */ 
  {
#line 343
  puts("WSBOOL: Additional workspace information");
  }
#line 344
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 346
  puts("GRIDSET: State change of gridlines option");
  }
#line 347
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 349
  puts("HCENTER: Center between horizontal margins");
  }
#line 350
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 352
  puts("VCENTER: Center between vertical margins");
  }
#line 353
  goto switch_break;
  case_133: /* CIL Label */ 
  {
#line 355
  puts("BoundSheet");
  }
#line 356
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 358
  puts("WRITEPROT: Workbook is Write-protected");
  }
#line 359
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 361
  puts("ADDIN: Workbook is add-in macro");
  }
#line 362
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 364
  puts("EDG: Edition globals");
  }
#line 365
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 367
  puts("PUB: Publisher");
  }
#line 368
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 370
  puts("COUNTRY: Default country and WIN.INI Country");
  }
#line 371
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 373
  puts("HIDEOBJ: Object display options");
  }
#line 374
  goto switch_break;
  case_144: /* CIL Label */ 
  {
#line 376
  puts("SORT: Sorting options");
  }
#line 377
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 379
  puts("SUB: Subscriber");
  }
#line 380
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 382
  puts("Palette Info");
  }
#line 383
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 385
  puts("LHRECORD: .WK? File Conversion Information");
  }
#line 386
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 388
  puts("LHNGRAPH: Named Graph Information");
  }
#line 389
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 391
  puts("SOUND: Sound note");
  }
#line 392
  goto switch_break;
  case_152: /* CIL Label */ 
  {
#line 394
  puts("LPR: Sheet was printed using LINE.PRINT()");
  }
#line 395
  goto switch_break;
  case_153: /* CIL Label */ 
  {
#line 397
  puts("STANDARDWIDTH: Standard column width");
  }
#line 398
  goto switch_break;
  case_154: /* CIL Label */ 
  {
#line 400
  puts("FNGROUPNAME: Function Group name");
  }
#line 401
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 403
  puts("FILTERMODE: Sheet contains filtered list");
  }
#line 404
  goto switch_break;
  case_156: /* CIL Label */ 
  {
#line 406
  puts("FNGROUPCOUNT: Built-in function group count");
  }
#line 407
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 409
  puts("AUTOFILTERINFO: Drop Down Arrow Count");
  }
#line 410
  goto switch_break;
  case_158: /* CIL Label */ 
  {
#line 412
  puts("AUTOFILTER: AutoFilter data");
  }
#line 413
  goto switch_break;
  case_160: /* CIL Label */ 
  {
#line 415
  puts("SCL: Window Zoom magnification");
  }
#line 416
  goto switch_break;
  case_161: /* CIL Label */ 
  {
#line 418
  puts("Page Setup");
  }
#line 419
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 421
  puts("COORDLIST: Polygon Object Vertex coordinates");
  }
#line 422
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 424
  puts("GCW: Global Column-Wdith flags");
  }
#line 425
  goto switch_break;
  case_174: /* CIL Label */ 
  {
#line 427
  puts("SCENMAN: Scenario Output data");
  }
#line 428
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 430
  puts("PROT4REV: Shared Workbook protection flag");
  }
#line 431
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 433
  puts("SXVIEW: View Definition");
  }
#line 434
  goto switch_break;
  case_177: /* CIL Label */ 
  {
#line 436
  puts("SXVD: View Fields");
  }
#line 437
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 439
  puts("SXVI: View Item");
  }
#line 440
  goto switch_break;
  case_180: /* CIL Label */ 
  {
#line 442
  puts("SXIVD: Row/Column Field Ids");
  }
#line 443
  goto switch_break;
  case_181: /* CIL Label */ 
  {
#line 445
  puts("SXLI: Line item array");
  }
#line 446
  goto switch_break;
  case_182: /* CIL Label */ 
  {
#line 448
  puts("SXPI: Page item");
  }
#line 449
  goto switch_break;
  case_184: /* CIL Label */ 
  {
#line 451
  puts("DOCROUTE: Routing slip information");
  }
#line 452
  goto switch_break;
  case_185: /* CIL Label */ 
  {
#line 454
  puts("RECIPNAME: Recipient name");
  }
#line 455
  goto switch_break;
  case_188: /* CIL Label */ 
  {
#line 457
  puts("SHRFMLA: Shared formula");
  }
#line 458
  goto switch_break;
  case_189: /* CIL Label */ 
  {
#line 460
  puts("MULRK: Multiple RK cells");
  }
#line 461
  goto switch_break;
  case_190: /* CIL Label */ 
  {
#line 463
  puts("Multiple Blanks");
  }
#line 464
  goto switch_break;
  case_193: /* CIL Label */ 
  {
#line 466
  puts("MMS: ADDMENU/DELMENU Record Group count");
  }
#line 467
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 469
  puts("ADDMENU: Menu Addition");
  }
#line 470
  goto switch_break;
  case_195: /* CIL Label */ 
  {
#line 472
  puts("DELMENU: Menu Deletion");
  }
#line 473
  goto switch_break;
  case_197: /* CIL Label */ 
  {
#line 475
  puts("SXDI: Data Item");
  }
#line 476
  goto switch_break;
  case_198: /* CIL Label */ 
  {
#line 478
  puts("SXDB: PivtoTable Cache Data");
  }
#line 479
  goto switch_break;
  case_205: /* CIL Label */ 
  {
#line 481
  puts("SXSTRING: String");
  }
#line 482
  goto switch_break;
  case_208: /* CIL Label */ 
  {
#line 484
  puts("SXTBL: Multiple Consolidation Source Info");
  }
#line 485
  goto switch_break;
  case_209: /* CIL Label */ 
  {
#line 487
  puts("SXTBRGIITM: Page Item Name Count");
  }
#line 488
  goto switch_break;
  case_210: /* CIL Label */ 
  {
#line 490
  puts("SXTBPG: Page Item Indexes");
  }
#line 491
  goto switch_break;
  case_211: /* CIL Label */ 
  {
#line 493
  puts("OBPROJ: Visual Basic Project");
  }
#line 494
  goto switch_break;
  case_213: /* CIL Label */ 
  {
#line 496
  puts("SXIDSTM: Stream ID");
  }
#line 497
  goto switch_break;
  case_214: /* CIL Label */ 
  {
#line 499
  puts("RString");
  }
#line 500
  goto switch_break;
  case_215: /* CIL Label */ 
  {
#line 502
  puts("DBCELL: Stream offsets");
  }
#line 503
  goto switch_break;
  case_218: /* CIL Label */ 
  {
#line 505
  puts("BOOKBOOL: Workbook option flag");
  }
#line 506
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 518
  puts("SCENPROTECT: Scenario protection");
  }
#line 519
  goto switch_break;
  case_222: /* CIL Label */ 
  {
#line 521
  puts("OLESIZE: Size of an OLE object");
  }
#line 522
  goto switch_break;
  case_223: /* CIL Label */ 
  {
#line 524
  puts("UDDESC: Description string for chart autoformat");
  }
#line 525
  goto switch_break;
  case_224: /* CIL Label */ 
  {
#line 527
  puts("Extended Format");
  }
#line 528
  goto switch_break;
  case_225: /* CIL Label */ 
  {
#line 530
  puts("INTERFACEHDR: Beginning of User Interface Records");
  }
#line 531
  goto switch_break;
  case_226: /* CIL Label */ 
  {
#line 533
  puts("INTERFACEEND: End of User interface records");
  }
#line 534
  goto switch_break;
  case_227: /* CIL Label */ 
  {
#line 536
  puts("SXVS: View source");
  }
#line 537
  goto switch_break;
  case_234: /* CIL Label */ 
  {
#line 539
  puts("TABIDCONF: Sheet tab ID of Conflict history");
  }
#line 540
  goto switch_break;
  case_235: /* CIL Label */ 
  {
#line 542
  puts("MSODRAWINGGROUP: MS Office Drawing Group");
  }
#line 543
  goto switch_break;
  case_236: /* CIL Label */ 
  {
#line 545
  puts("MSODRAWING: MS Office Drawing");
  }
#line 546
  goto switch_break;
  case_237: /* CIL Label */ 
  {
#line 548
  puts("MS Office Drawing Selection");
  }
#line 549
  goto switch_break;
  case_240: /* CIL Label */ 
  {
#line 551
  puts("SXRULE: PivotTable Rule data");
  }
#line 552
  goto switch_break;
  case_241: /* CIL Label */ 
  {
#line 554
  puts("SXEX: PivotTable Extended information");
  }
#line 555
  goto switch_break;
  case_242: /* CIL Label */ 
  {
#line 557
  puts("SXFILT: PivotTable Rule Filter");
  }
#line 558
  goto switch_break;
  case_246: /* CIL Label */ 
  {
#line 560
  puts("SXNAME: PivotTable Name");
  }
#line 561
  goto switch_break;
  case_247: /* CIL Label */ 
  {
#line 563
  puts("SXSELECT: PivotTable Selection Information");
  }
#line 564
  goto switch_break;
  case_248: /* CIL Label */ 
  {
#line 566
  puts("PivotTable Name Pair");
  }
#line 567
  goto switch_break;
  case_249: /* CIL Label */ 
  {
#line 569
  puts("PivotTable Parsed Expression");
  }
#line 570
  goto switch_break;
  case_251: /* CIL Label */ 
  {
#line 572
  puts("PivotTable Format Record");
  }
#line 573
  goto switch_break;
  case_252: /* CIL Label */ 
  {
#line 575
  puts("Shared String Table");
  }
#line 576
  goto switch_break;
  case_253: /* CIL Label */ 
  {
#line 578
  puts("Cell Value, String Constant/SST");
  }
#line 579
  goto switch_break;
  case_255: /* CIL Label */ 
  {
#line 581
  puts("Extended Shared String Table");
  }
#line 582
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 586
  puts("Unknown Opcode");
  }
#line 587
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 589
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 130 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.h"
unsigned short fil_sreadU16(unsigned char *in ) ;
#line 131
unsigned int fil_sreadU32(unsigned char *in ) ;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/internal.h"
int __OLEdecode(char *OLEfilename , pps_entry **stream_list , unsigned int *root ,
                unsigned char **_BDepot , unsigned char **_SDepot , FILE **_sbfile ,
                char **_sbfilename , FILE **_input , unsigned short max_level ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree(pps_entry *node , unsigned short level ) ;
#line 74
static void ends(void) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *input  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Block  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Blockx  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *BDepot  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *SDepot  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Root  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static pps_entry *pps_list  ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int num_of_pps  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *sbfile  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *sbd_list  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *root_list  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
int __OLEdecode(char *OLEfilename , pps_entry **stream_list , unsigned int *root ,
                unsigned char **_BDepot , unsigned char **_SDepot , FILE **_sbfile ,
                char **_sbfilename , FILE **_input , unsigned short max_level ) 
{ 
  int c ;
  unsigned int num_bbd_blocks ;
  unsigned int num_xbbd_blocks ;
  unsigned int bl ;
  unsigned int i ;
  unsigned int j ;
  unsigned int len ;
  unsigned char *s ;
  unsigned char *p ;
  unsigned char *t ;
  long FilePos ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  unsigned int *newspace ;
  void *tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  unsigned int *newspace___0 ;
  void *tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  unsigned short size_of_name ;
  unsigned short tmp___30 ;
  int tmp___31 ;
  unsigned short tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  int tmp___35 ;
  unsigned char *Depot ;
  FILE *OLEfile ;
  FILE *infile ;
  unsigned short BlockSize ;
  unsigned short Offset ;
  size_t bytes_to_read ;
  unsigned int pps_size ;
  unsigned int pps_start ;
  int ret ;
  void *tmp___36 ;
  int ret___0 ;
  int tmp___37 ;
  int tmp___38 ;
  unsigned int tmp___39 ;

  {
  {
#line 119
  sbfile = (FILE *)((void *)0);
#line 119
  input = sbfile;
#line 120
  Root = (unsigned char *)((void *)0);
#line 120
  SDepot = Root;
#line 120
  BDepot = SDepot;
#line 120
  Blockx = BDepot;
#line 120
  Block = Blockx;
#line 121
  pps_list = (pps_entry *)((void *)0);
#line 122
  num_of_pps = 0U;
#line 125
  sbd_list = (unsigned int *)((void *)0);
#line 125
  root_list = sbd_list;
#line 127
  *stream_list = (pps_entry *)((void *)0);
#line 131
  input = fopen((char const   */* __restrict  */)OLEfilename, (char const   */* __restrict  */)"rb");
  }
#line 132
  if (! ((unsigned long )input != (unsigned long )((void *)0))) {
    {
#line 132
    ends();
    }
#line 132
    return (4);
  }
  {
#line 133
  *_input = input;
#line 137
  c = _IO_getc(input);
  }
#line 137
  if (! (c != -1)) {
    {
#line 137
    ends();
    }
#line 137
    return (5);
  }
  {
#line 138
  tmp = ungetc(c, input);
  }
#line 138
  if (! (tmp != -1)) {
    {
#line 138
    ends();
    }
#line 138
    return (5);
  }
#line 140
  if (! (c == 208)) {
    {
#line 140
    ends();
    }
#line 140
    return (9);
  }
  {
#line 144
  tmp___0 = malloc((size_t )512);
#line 144
  Block = (unsigned char *)tmp___0;
  }
#line 145
  if (! ((unsigned long )Block != (unsigned long )((void *)0))) {
    {
#line 145
    ends();
    }
#line 145
    return (10);
  }
  {
#line 146
  fread((void */* __restrict  */)Block, (size_t )512, (size_t )1, (FILE */* __restrict  */)input);
#line 147
  tmp___1 = ferror(input);
  }
#line 147
  if (tmp___1) {
    {
#line 147
    ends();
    }
#line 147
    return (5);
  }
  {
#line 150
  rewind(input);
#line 152
  tmp___2 = fil_sreadU32(Block);
  }
#line 152
  if (! ((unsigned long )tmp___2 != 3503231456UL)) {
    {
#line 152
    ends();
    }
#line 152
    return (9);
  }
  {
#line 153
  tmp___3 = fil_sreadU32(Block + 4);
  }
#line 153
  if (! ((unsigned long )tmp___3 != 2712738529UL)) {
    {
#line 153
    ends();
    }
#line 153
    return (9);
  }
  {
#line 158
  num_bbd_blocks = fil_sreadU32(Block + 44);
#line 159
  num_xbbd_blocks = fil_sreadU32(Block + 72);
#line 162
  tmp___4 = malloc((size_t )(512U * (num_bbd_blocks + num_xbbd_blocks)));
#line 162
  BDepot = (unsigned char *)tmp___4;
  }
#line 163
  if (! ((unsigned long )BDepot != (unsigned long )((void *)0))) {
    {
#line 163
    ends();
    }
#line 163
    return (10);
  }
#line 164
  *_BDepot = BDepot;
#line 165
  s = BDepot;
#line 166
  if (! (num_bbd_blocks <= (127U * num_xbbd_blocks + 128U) - 19U)) {
    {
#line 166
    __assert_fail("num_bbd_blocks <= (0x0200 / 4 - 1) * num_xbbd_blocks + (0x0200 / 4) - 19",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                  167U, "__OLEdecode");
    }
  }
#line 169
  i = 0U;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (num_bbd_blocks < 109U) {
#line 169
      tmp___8 = num_bbd_blocks;
    } else {
#line 169
      tmp___8 = 109U;
    }
#line 169
    if (! (i < tmp___8)) {
#line 169
      goto while_break;
    }
    {
#line 172
    tmp___5 = fil_sreadU32((Block + 76) + i * 4U);
#line 172
    FilePos = (long )(512U * (1U + tmp___5));
    }
#line 173
    if (! (FilePos >= 0L)) {
      {
#line 173
      __assert_fail("FilePos >= 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                    173U, "__OLEdecode");
      }
    }
    {
#line 174
    tmp___6 = fseek(input, FilePos, 0);
    }
#line 174
    if (tmp___6) {
      {
#line 174
      ends();
      }
#line 174
      return (5);
    }
    {
#line 175
    fread((void */* __restrict  */)s, (size_t )512, (size_t )1, (FILE */* __restrict  */)input);
#line 176
    tmp___7 = ferror(input);
    }
#line 176
    if (tmp___7) {
      {
#line 176
      ends();
      }
#line 176
      return (5);
    }
#line 177
    s += 512;
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  tmp___9 = malloc((size_t )512);
#line 180
  Blockx = (unsigned char *)tmp___9;
  }
#line 181
  if (! ((unsigned long )Blockx != (unsigned long )((void *)0))) {
    {
#line 181
    ends();
    }
#line 181
    return (10);
  }
  {
#line 182
  bl = fil_sreadU32(Block + 68);
#line 183
  i = 0U;
  }
  {
#line 183
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 183
    if (! (i < num_xbbd_blocks)) {
#line 183
      goto while_break___0;
    }
#line 185
    FilePos = (long )(512U * (1U + bl));
#line 186
    if (! (FilePos >= 0L)) {
      {
#line 186
      __assert_fail("FilePos >= 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                    186U, "__OLEdecode");
      }
    }
    {
#line 187
    tmp___10 = fseek(input, FilePos, 0);
    }
#line 187
    if (tmp___10) {
      {
#line 187
      ends();
      }
#line 187
      return (5);
    }
    {
#line 188
    fread((void */* __restrict  */)Blockx, (size_t )512, (size_t )1, (FILE */* __restrict  */)input);
#line 189
    tmp___11 = ferror(input);
    }
#line 189
    if (tmp___11) {
      {
#line 189
      ends();
      }
#line 189
      return (5);
    }
#line 191
    j = 0U;
    {
#line 191
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 191
      if (! (j < 127U)) {
#line 191
        goto while_break___1;
      }
      {
#line 194
      tmp___12 = fil_sreadU32(Blockx + j * 4U);
      }
#line 194
      if ((unsigned long )tmp___12 == 4294967294UL) {
#line 197
        goto while_break___1;
      } else {
        {
#line 194
        tmp___13 = fil_sreadU32(Blockx + j * 4U);
        }
#line 194
        if ((unsigned long )tmp___13 == 4294967293UL) {
#line 197
          goto while_break___1;
        } else {
          {
#line 194
          tmp___14 = fil_sreadU32(Blockx + j * 4U);
          }
#line 194
          if ((unsigned long )tmp___14 == 4294967295UL) {
#line 197
            goto while_break___1;
          }
        }
      }
      {
#line 199
      tmp___15 = fil_sreadU32(Blockx + j * 4U);
#line 199
      FilePos = (long )(512U * (1U + tmp___15));
      }
#line 200
      if (! (FilePos >= 0L)) {
        {
#line 200
        __assert_fail("FilePos >= 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      200U, "__OLEdecode");
        }
      }
      {
#line 201
      tmp___16 = fseek(input, FilePos, 0);
      }
#line 201
      if (tmp___16) {
        {
#line 201
        ends();
        }
#line 201
        return (5);
      }
      {
#line 202
      fread((void */* __restrict  */)s, (size_t )512, (size_t )1, (FILE */* __restrict  */)input);
#line 203
      tmp___17 = ferror(input);
      }
#line 203
      if (tmp___17) {
        {
#line 203
        ends();
        }
#line 203
        return (5);
      }
#line 204
      s += 512;
#line 191
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 207
    bl = fil_sreadU32((Blockx + 512) - 4);
#line 183
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 214
  tmp___18 = malloc((size_t )80);
#line 214
  sbd_list = (unsigned int *)tmp___18;
  }
#line 215
  if (! ((unsigned long )sbd_list != (unsigned long )((void *)0))) {
    {
#line 215
    ends();
    }
#line 215
    return (10);
  }
  {
#line 216
  *(sbd_list + 0) = fil_sreadU32(Block + 60);
#line 218
  len = 1U;
  }
  {
#line 218
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 218
    if (! ((unsigned long )*(sbd_list + (len - 1U)) != 4294967294UL)) {
#line 218
      goto while_break___2;
    }
#line 220
    if (! (len != 0U)) {
      {
#line 220
      ends();
      }
#line 220
      return (5);
    }
#line 222
    if (! (len % 20U)) {
      {
#line 225
      tmp___19 = realloc((void *)sbd_list, (size_t )(((1U + len / 20U) * 20U) * 4U));
#line 225
      newspace = (unsigned int *)tmp___19;
      }
#line 227
      if (! ((unsigned long )newspace != (unsigned long )((void *)0))) {
        {
#line 227
        ends();
        }
#line 227
        return (10);
      }
#line 228
      sbd_list = newspace;
    }
    {
#line 230
    *(sbd_list + len) = fil_sreadU32(BDepot + *(sbd_list + (len - 1U)) * 4U);
    }
#line 234
    if ((unsigned long )*(sbd_list + len) != 4294967294UL) {
#line 235
      if (! (*(sbd_list + len) <= num_bbd_blocks * 512U - 4U)) {
        {
#line 235
        ends();
        }
#line 235
        return (5);
      }
    }
#line 236
    if ((unsigned long )*(sbd_list + len) != 4294967293UL) {
#line 236
      if (! ((unsigned long )*(sbd_list + len) != 4294967295UL)) {
        {
#line 236
        ends();
        }
#line 236
        return (5);
      }
    } else {
      {
#line 236
      ends();
      }
#line 236
      return (5);
    }
#line 218
    len ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 240
  len --;
#line 243
  if (len == 0U) {
#line 245
    SDepot = (unsigned char *)((void *)0);
  } else {
    {
#line 251
    tmp___20 = malloc((size_t )(512U * len));
#line 251
    SDepot = (unsigned char *)tmp___20;
    }
#line 252
    if (! ((unsigned long )SDepot != (unsigned long )((void *)0))) {
      {
#line 252
      ends();
      }
#line 252
      return (10);
    }
#line 253
    s = SDepot;
#line 254
    i = 0U;
    {
#line 254
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 254
      if (! (i < len)) {
#line 254
        goto while_break___3;
      }
#line 256
      FilePos = (long )(512U * (1U + *(sbd_list + i)));
#line 257
      if (! (FilePos >= 0L)) {
        {
#line 257
        __assert_fail("FilePos >= 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      257U, "__OLEdecode");
        }
      }
      {
#line 258
      tmp___21 = fseek(input, FilePos, 0);
      }
#line 258
      if (tmp___21) {
        {
#line 258
        ends();
        }
#line 258
        return (5);
      }
      {
#line 259
      fread((void */* __restrict  */)s, (size_t )512, (size_t )1, (FILE */* __restrict  */)input);
#line 260
      tmp___22 = ferror(input);
      }
#line 260
      if (tmp___22) {
        {
#line 260
        ends();
        }
#line 260
        return (5);
      }
#line 261
      s += 512;
#line 254
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 265
  *_SDepot = SDepot;
#line 269
  tmp___23 = malloc((size_t )80);
#line 269
  root_list = (unsigned int *)tmp___23;
  }
#line 270
  if (! ((unsigned long )root_list != (unsigned long )((void *)0))) {
    {
#line 270
    ends();
    }
#line 270
    return (10);
  }
  {
#line 271
  *(root_list + 0) = fil_sreadU32(Block + 48);
#line 272
  len = 1U;
  }
  {
#line 272
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 272
    if (! ((unsigned long )*(root_list + (len - 1U)) != 4294967294UL)) {
#line 272
      goto while_break___4;
    }
#line 274
    if (! (len != 0U)) {
      {
#line 274
      ends();
      }
#line 274
      return (5);
    }
#line 276
    if (! (len % 20U)) {
      {
#line 279
      tmp___24 = realloc((void *)root_list, (size_t )(((1U + len / 20U) * 20U) * 4U));
#line 279
      newspace___0 = (unsigned int *)tmp___24;
      }
#line 281
      if (! ((unsigned long )newspace___0 != (unsigned long )((void *)0))) {
        {
#line 281
        ends();
        }
#line 281
        return (10);
      }
#line 282
      root_list = newspace___0;
    }
    {
#line 284
    *(root_list + len) = fil_sreadU32(BDepot + *(root_list + (len - 1U)) * 4U);
    }
#line 285
    if ((unsigned long )*(root_list + len) != 4294967293UL) {
#line 285
      if (! ((unsigned long )*(root_list + len) != 4294967295UL)) {
        {
#line 285
        ends();
        }
#line 285
        return (5);
      }
    } else {
      {
#line 285
      ends();
      }
#line 285
      return (5);
    }
#line 272
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 288
  len --;
#line 292
  tmp___25 = malloc((size_t )(512U * len));
#line 292
  Root = (unsigned char *)tmp___25;
  }
#line 293
  if (! ((unsigned long )Root != (unsigned long )((void *)0))) {
    {
#line 293
    ends();
    }
#line 293
    return (10);
  }
#line 294
  s = Root;
#line 295
  i = 0U;
  {
#line 295
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 295
    if (! (i < len)) {
#line 295
      goto while_break___5;
    }
#line 297
    FilePos = (long )(512U * (*(root_list + i) + 1U));
#line 298
    if (! (FilePos >= 0L)) {
      {
#line 298
      __assert_fail("FilePos >= 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                    298U, "__OLEdecode");
      }
    }
    {
#line 299
    tmp___26 = fseek(input, FilePos, 0);
    }
#line 299
    if (tmp___26) {
      {
#line 299
      ends();
      }
#line 299
      return (5);
    }
    {
#line 300
    fread((void */* __restrict  */)s, (size_t )512, (size_t )1, (FILE */* __restrict  */)input);
#line 301
    tmp___27 = ferror(input);
    }
#line 301
    if (tmp___27) {
      {
#line 301
      ends();
      }
#line 301
      return (5);
    }
#line 302
    s += 512;
#line 295
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 309
  num_of_pps = len * 4U;
#line 310
  tmp___28 = malloc((unsigned long )num_of_pps * sizeof(pps_entry ));
#line 310
  pps_list = (pps_entry *)tmp___28;
#line 310
  *stream_list = pps_list;
  }
#line 311
  if (! ((unsigned long )pps_list != (unsigned long )((void *)0))) {
    {
#line 311
    ends();
    }
#line 311
    return (10);
  }
#line 314
  i = 0U;
  {
#line 314
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 314
    if (! (i < num_of_pps)) {
#line 314
      goto while_break___6;
    }
    {
#line 318
    s = Root + i * 128U;
#line 321
    (pps_list + i)->ppsnumber = i;
#line 324
    tmp___32 = fil_sreadU16(s + 64);
    }
#line 324
    if (64 < (int )tmp___32) {
#line 324
      tmp___31 = 64;
    } else {
      {
#line 324
      tmp___30 = fil_sreadU16(s + 64);
#line 324
      tmp___31 = (int )tmp___30;
      }
    }
#line 324
    size_of_name = (unsigned short )tmp___31;
#line 325
    (pps_list + i)->name[0] = (char)0;
#line 326
    if ((int )size_of_name == 0) {
#line 327
      goto __Cont;
    }
#line 328
    p = (unsigned char *)((pps_list + i)->name);
#line 328
    t = s;
    {
#line 328
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 328
      if (! ((unsigned long )t < (unsigned long )(s + (int )size_of_name))) {
#line 328
        goto while_break___7;
      }
#line 330
      tmp___33 = p;
#line 330
      p ++;
#line 330
      tmp___34 = t;
#line 330
      t ++;
#line 330
      *tmp___33 = *tmp___34;
#line 328
      t ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 336
    (pps_list + i)->type = *(s + 66);
#line 337
    if ((int )(pps_list + i)->type == 5) {
#line 339
      if (! (i == 0U)) {
        {
#line 339
        __assert_fail("i == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      339U, "__OLEdecode");
        }
      }
#line 340
      *root = i;
    }
    {
#line 344
    (pps_list + i)->previous = fil_sreadU32(s + 68);
#line 345
    (pps_list + i)->next = fil_sreadU32(s + 72);
#line 346
    (pps_list + i)->dir = fil_sreadU32(s + 76);
#line 347
    (pps_list + i)->start = fil_sreadU32(s + 116);
#line 348
    (pps_list + i)->size = fil_sreadU32(s + 120);
#line 349
    (pps_list + i)->seconds1 = fil_sreadU32(s + 100);
#line 350
    (pps_list + i)->seconds2 = fil_sreadU32(s + 108);
#line 351
    (pps_list + i)->days1 = fil_sreadU32(s + 104);
#line 352
    (pps_list + i)->days2 = fil_sreadU32(s + 112);
    }
    __Cont: /* CIL Label */ 
#line 314
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 385
  tmp___35 = reorder_pps_tree(pps_list + *root, (unsigned short)0);
  }
#line 385
  if (! tmp___35) {
    {
#line 385
    ends();
    }
#line 385
    return (9);
  }
#line 429
  if (! (num_of_pps >= 1U)) {
    {
#line 429
    __assert_fail("num_of_pps >= 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                  429U, "__OLEdecode");
    }
  }
#line 435
  i = 0U;
  {
#line 435
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 435
    if (! (i < 1U)) {
#line 435
      goto while_break___8;
    }
#line 437
    (pps_list + i)->filename[0] = (char)0;
#line 442
    if ((int )(pps_list + i)->type == 1) {
#line 444
      goto __Cont___0;
    } else
#line 442
    if (! (pps_list + i)->name[0]) {
#line 442
      if ((int )(pps_list + i)->type != 5) {
#line 444
        goto __Cont___0;
      }
    }
#line 446
    if ((int )max_level != 0) {
#line 446
      if ((int )(pps_list + i)->level > (int )max_level) {
#line 447
        goto __Cont___0;
      }
    }
#line 449
    pps_size = (pps_list + i)->size;
#line 450
    pps_start = (pps_list + i)->start;
#line 456
    if ((int )(pps_list + i)->type == 5) {
#line 459
      if ((unsigned long )SDepot == (unsigned long )((void *)0)) {
#line 461
        *_sbfilename = (char *)((void *)0);
#line 462
        *_sbfile = (FILE *)((void *)0);
#line 463
        goto while_break___8;
      }
#line 465
      if (! (i == *root)) {
        {
#line 465
        __assert_fail("i == *root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      465U, "__OLEdecode");
        }
      }
#line 466
      if (! (i == 0U)) {
        {
#line 466
        __assert_fail("i == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      466U, "__OLEdecode");
        }
      }
      {
#line 488
      tmp___36 = malloc((size_t )18);
#line 488
      *_sbfilename = (char *)((unsigned char *)tmp___36);
      }
#line 489
      if (! ((unsigned long )*_sbfilename != (unsigned long )((void *)0))) {
        {
#line 489
        ends();
        }
#line 489
        return (10);
      }
      {
#line 491
      strcpy((char */* __restrict  */)*_sbfilename, (char const   */* __restrict  */)"/tmp/xlHtmlXXXXXX");
#line 492
      ret = mkstemp(*_sbfilename);
      }
#line 493
      if (ret == -1) {
        {
#line 494
        free((void *)*_sbfilename);
        }
#line 495
        if (! (ret == -1)) {
          {
#line 495
          ends();
          }
#line 495
          return (7);
        }
      }
      {
#line 498
      OLEfile = fdopen(ret, "w+b");
#line 498
      sbfile = OLEfile;
#line 500
      unlink((char const   *)*_sbfilename);
#line 503
      *_sbfile = sbfile;
      }
#line 504
      if (! ((unsigned long )OLEfile != (unsigned long )((void *)0))) {
        {
#line 504
        ends();
        }
#line 504
        return (7);
      }
    } else {
      {
#line 519
      strcpy((char */* __restrict  */)((pps_list + i)->filename), (char const   */* __restrict  */)"/tmp/xlHtmlXXXXXX");
#line 520
      ret___0 = mkstemp((pps_list + i)->filename);
      }
#line 521
      if (! (ret___0 == -1)) {
        {
#line 521
        ends();
        }
#line 521
        return (7);
      }
      {
#line 522
      OLEfile = fdopen(ret___0, "wb");
      }
#line 524
      if (! ((unsigned long )OLEfile != (unsigned long )((void *)0))) {
        {
#line 524
        ends();
        }
#line 524
        return (7);
      }
    }
#line 528
    if (pps_size >= 4096U) {
#line 528
      goto _L;
    } else
#line 528
    if ((unsigned long )OLEfile == (unsigned long )sbfile) {
      _L: /* CIL Label */ 
#line 532
      Offset = (unsigned short)1;
#line 533
      BlockSize = (unsigned short)512;
#line 534
      if (! ((unsigned long )input != (unsigned long )((void *)0))) {
        {
#line 534
        __assert_fail("input != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      534U, "__OLEdecode");
        }
      }
#line 535
      if (! ((unsigned long )BDepot != (unsigned long )((void *)0))) {
        {
#line 535
        __assert_fail("BDepot != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      535U, "__OLEdecode");
        }
      }
#line 536
      infile = input;
#line 537
      Depot = BDepot;
    } else {
#line 542
      Offset = (unsigned short)0;
#line 543
      BlockSize = (unsigned short)64;
#line 544
      if (! ((unsigned long )sbfile != (unsigned long )((void *)0))) {
        {
#line 544
        __assert_fail("sbfile != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      544U, "__OLEdecode");
        }
      }
#line 545
      if (! ((unsigned long )SDepot != (unsigned long )((void *)0))) {
        {
#line 545
        __assert_fail("SDepot != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      545U, "__OLEdecode");
        }
      }
#line 546
      infile = sbfile;
#line 547
      Depot = SDepot;
    }
    {
#line 551
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 551
      if (! ((unsigned long )pps_start != 4294967294UL)) {
#line 551
        goto while_break___9;
      }
#line 558
      FilePos = (long )((pps_start + (unsigned int )Offset) * (unsigned int )BlockSize);
#line 559
      if (! (FilePos >= 0L)) {
        {
#line 559
        __assert_fail("FilePos >= 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c",
                      559U, "__OLEdecode");
        }
      }
#line 560
      if ((unsigned int )BlockSize < pps_size) {
#line 560
        bytes_to_read = (size_t )((unsigned int )BlockSize);
      } else {
#line 560
        bytes_to_read = (size_t )pps_size;
      }
      {
#line 561
      fseek(infile, FilePos, 0);
#line 562
      fread((void */* __restrict  */)Block, bytes_to_read, (size_t )1, (FILE */* __restrict  */)infile);
#line 563
      tmp___37 = ferror(infile);
      }
#line 563
      if (tmp___37) {
        {
#line 563
        ends();
        }
#line 563
        return (5);
      }
      {
#line 564
      fwrite((void const   */* __restrict  */)Block, bytes_to_read, (size_t )1, (FILE */* __restrict  */)OLEfile);
#line 565
      tmp___38 = ferror(infile);
      }
#line 565
      if (tmp___38) {
        {
#line 565
        ends();
        }
#line 565
        return (5);
      }
      {
#line 566
      pps_start = fil_sreadU32(Depot + pps_start * 4U);
      }
#line 567
      if ((unsigned int )BlockSize < pps_size) {
#line 567
        tmp___39 = (unsigned int )BlockSize;
      } else {
#line 567
        tmp___39 = pps_size;
      }
#line 567
      pps_size -= tmp___39;
#line 568
      if (pps_size == 0U) {
#line 569
        pps_start = 4294967294U;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 571
    if ((unsigned long )OLEfile == (unsigned long )sbfile) {
      {
#line 573
      rewind(OLEfile);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 435
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 589
  ends();
  }
#line 590
  return (0);
}
}
#line 597 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *last_next_link_visited  ;
#line 598 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree(pps_entry *node , unsigned short level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 603
  node->level = level;
#line 606
  if ((unsigned long )node->dir != 4294967295UL) {
#line 608
    if (node->dir > num_of_pps) {
#line 609
      return (0);
    } else
#line 608
    if (! (pps_list + node->dir)->name[0]) {
#line 609
      return (0);
    } else {
      {
#line 610
      tmp = reorder_pps_tree(pps_list + node->dir, (unsigned short )((int )level + 1));
      }
#line 610
      if (! tmp) {
#line 611
        return (0);
      }
    }
  }
#line 615
  if ((unsigned long )node->next != 4294967295UL) {
#line 617
    if (node->next > num_of_pps) {
#line 618
      return (0);
    } else
#line 617
    if (! (pps_list + node->next)->name[0]) {
#line 618
      return (0);
    } else {
      {
#line 619
      tmp___0 = reorder_pps_tree(pps_list + node->next, level);
      }
#line 619
      if (! tmp___0) {
#line 620
        return (0);
      }
    }
  } else {
#line 623
    last_next_link_visited = & node->next;
  }
#line 626
  if ((unsigned long )node->previous != 4294967295UL) {
#line 628
    if (node->previous > num_of_pps) {
#line 629
      return (0);
    } else
#line 628
    if (! (pps_list + node->previous)->name[0]) {
#line 629
      return (0);
    } else {
      {
#line 632
      *last_next_link_visited = node->previous;
#line 633
      node->previous = 4294967295U;
#line 634
      tmp___1 = reorder_pps_tree(pps_list + *last_next_link_visited, level);
      }
#line 634
      if (! tmp___1) {
#line 635
        return (0);
      }
    }
  }
#line 638
  return (1);
}
}
#line 759 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static void ends(void) 
{ 


  {
#line 767
  if ((unsigned long )Block != (unsigned long )((void *)0)) {
    {
#line 767
    free((void *)Block);
    }
  }
#line 768
  if ((unsigned long )Blockx != (unsigned long )((void *)0)) {
    {
#line 768
    free((void *)Blockx);
    }
  }
#line 775
  if ((unsigned long )Root != (unsigned long )((void *)0)) {
    {
#line 775
    free((void *)Root);
    }
  }
#line 776
  if ((unsigned long )sbd_list != (unsigned long )((void *)0)) {
    {
#line 776
    free((void *)sbd_list);
    }
  }
#line 777
  if ((unsigned long )root_list != (unsigned long )((void *)0)) {
    {
#line 777
    free((void *)root_list);
    }
  }
#line 787
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 134 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.h"
void fil_swriteU16(unsigned char *dest , unsigned short *src ) ;
#line 135
void fil_swriteU32(unsigned char *dest , unsigned int *src ) ;
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE Input  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *sbfile___0  ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *SDepot___0  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *BDepot___0  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *bbd_list  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *Root___0  ;
#line 79 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int header_blocks  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int big_streams_blocks  ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_blocks  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_blocks  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_blocks  ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_blocks  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_start_block  ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_start_block  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_start_block  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_start_block  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static FILE *output_file  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned char output_block[512]  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned short pos_block  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int next_block  ;
#line 105
static int process_Root(pps_entry *pps_list___4 , unsigned int root ) ;
#line 106
static unsigned int max_pps_referenced(pps_entry *pps_list___4 , unsigned int node ) ;
#line 107
static unsigned int max3(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) ;
#line 108
static int process_streams(pps_entry *pps_list___4 , pps_entry *node ) ;
#line 109
static int add_stream_to_sbfile_and_SDepot(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 110
static int add_stream_to_Input_and_BDepot(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 111
static int add_entry_to_Root(pps_entry *node , unsigned int start_block ) ;
#line 112
static unsigned int add_MY_FILE_entry(MY_FILE *list , unsigned int size ) ;
#line 113
static int pps2root(unsigned char *pps , pps_entry *node , unsigned int start_block ) ;
#line 114
static void reset_links_in_Input(void) ;
#line 115
static void reset_links_in_BDepot(void) ;
#line 116
static void reset_links_in_SDepot(void) ;
#line 118
static int generate_ole2_file(char const   *filename___4 , int trunc ) ;
#line 119
static int generate_header(void) ;
#line 120
static int generate_recursive(MY_FILE *list ) ;
#line 121
static int generate_SDepot(void) ;
#line 122
static int generate_Root(void) ;
#line 123
static int generate_BDepot(void) ;
#line 124
static int generate_real_file(MY_FILE *MY_FILE_file ) ;
#line 125
static int write_block_list(unsigned int start_count , MY_FILE *list , int write_end_chain ) ;
#line 126
static int write_root_list(MY_FILE *list ) ;
#line 127
static void calculate_blocks(void) ;
#line 129
static unsigned int sum_block_list(MY_FILE *list ) ;
#line 132
static unsigned int sum_blocks_MY_FILE_list(MY_FILE *list ) ;
#line 134
static void ends___0(void) ;
#line 211 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
int __OLEcode(char const   *OLEfilename , int trunc , pps_entry *stream_list , unsigned int root ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int retval ;
  int retval___0 ;
  int retval___1 ;

  {
#line 217
  if (! ((unsigned long )OLEfilename != (unsigned long )((void *)0))) {
    {
#line 217
    __assert_fail("OLEfilename != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  217U, "__OLEcode");
    }
  }
#line 218
  if (! ((unsigned long )stream_list != (unsigned long )((void *)0))) {
    {
#line 218
    __assert_fail("stream_list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  218U, "__OLEcode");
    }
  }
  {
#line 221
  output_file = (FILE *)((void *)0);
#line 222
  memset((void *)(output_block), 255, (size_t )512);
#line 224
  pos_block = (unsigned short)0;
#line 225
  next_block = 4294967295U;
#line 228
  bbd_list = (MY_FILE *)((void *)0);
#line 228
  SDepot___0 = bbd_list;
#line 228
  BDepot___0 = SDepot___0;
#line 229
  Root___0 = (MY_FILE *)((void *)0);
#line 230
  sbfile___0 = (MY_FILE *)((void *)0);
#line 237
  Input.type = (enum __anonenum_type_26 )1;
#line 237
  Input.size = (unsigned int )(5UL * sizeof(MY_FILE ));
#line 237
  Input.blocks = (unsigned int *)((void *)0);
#line 237
  tmp = malloc((size_t )Input.size);
#line 237
  Input.file.MY_FILE_list = (struct str_MY_FILE *)tmp;
  }
#line 240
  if (! ((unsigned long )Input.file.MY_FILE_list != (unsigned long )((void *)0))) {
    {
#line 240
    ends___0();
    }
#line 240
    return (10);
  }
  {
#line 241
  reset_links_in_Input();
#line 244
  bbd_list->type = (enum __anonenum_type_26 )2;
#line 244
  bbd_list->size = (unsigned int )sizeof(unsigned int );
#line 244
  bbd_list->blocks = (unsigned int *)((void *)0);
#line 244
  tmp___0 = malloc((size_t )bbd_list->size);
#line 244
  bbd_list->file.block_list = (unsigned int *)tmp___0;
  }
#line 248
  if (! ((unsigned long )bbd_list->file.block_list != (unsigned long )((void *)0))) {
    {
#line 248
    ends___0();
    }
#line 248
    return (10);
  }
  {
#line 249
  *(bbd_list->file.block_list + 0) = 1U;
#line 253
  BDepot___0->type = (enum __anonenum_type_26 )2;
#line 253
  BDepot___0->size = (unsigned int )(3UL * sizeof(unsigned int ));
#line 253
  BDepot___0->blocks = bbd_list->file.block_list;
#line 253
  tmp___1 = malloc((size_t )BDepot___0->size);
#line 253
  BDepot___0->file.block_list = (unsigned int *)tmp___1;
  }
#line 255
  if (! ((unsigned long )BDepot___0->file.block_list != (unsigned long )((void *)0))) {
    {
#line 255
    ends___0();
    }
#line 255
    return (10);
  }
  {
#line 256
  tmp___3 = 0U;
#line 256
  *(BDepot___0->file.block_list + 2) = tmp___3;
#line 256
  tmp___2 = tmp___3;
#line 256
  *(BDepot___0->file.block_list + 1) = tmp___2;
#line 256
  *(BDepot___0->file.block_list + 0) = tmp___2;
#line 261
  sbfile___0->type = (enum __anonenum_type_26 )1;
#line 261
  sbfile___0->size = 0U;
#line 261
  sbfile___0->blocks = BDepot___0->file.block_list;
#line 261
  sbfile___0->file.MY_FILE_list = (struct str_MY_FILE *)((void *)0);
#line 264
  SDepot___0->type = (enum __anonenum_type_26 )2;
#line 264
  SDepot___0->size = 0U;
#line 264
  SDepot___0->blocks = BDepot___0->file.block_list + 1;
#line 264
  SDepot___0->file.block_list = (unsigned int *)((void *)0);
#line 267
  Root___0->type = (enum __anonenum_type_26 )3;
#line 267
  Root___0->size = 0U;
#line 267
  Root___0->blocks = BDepot___0->file.block_list + 2;
#line 267
  Root___0->file.root_list = (unsigned char *)((void *)0);
#line 271
  retval = process_Root(stream_list, root);
  }
#line 271
  if (retval) {
#line 271
    return (retval);
  }
  {
#line 272
  retval___0 = process_streams(stream_list, stream_list + root);
  }
#line 272
  if (retval___0) {
#line 272
    return (retval___0);
  }
  {
#line 277
  retval___1 = generate_ole2_file(OLEfilename, trunc);
  }
#line 277
  if (retval___1) {
#line 277
    return (retval___1);
  }
#line 280
  return (0);
}
}
#line 285 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_Root(pps_entry *pps_list___4 , unsigned int root ) 
{ 
  unsigned int pps_list_entries ;
  unsigned int i ;
  unsigned int tmp ;
  int retval ;

  {
  {
#line 293
  tmp = max_pps_referenced(pps_list___4, root);
#line 293
  pps_list_entries = 1U + tmp;
#line 296
  i = 0U;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < pps_list_entries)) {
#line 296
      goto while_break;
    }
    {
#line 297
    retval = add_entry_to_Root(pps_list___4 + i, 0U);
    }
#line 297
    if (retval) {
#line 297
      return (retval);
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max3(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) 
{ 
  unsigned int m ;

  {
#line 319
  m = 0U;
#line 323
  if (m > a) {
#line 323
    m = m;
  } else {
#line 323
    m = a;
  }
#line 324
  if (m > b) {
#line 324
    m = m;
  } else {
#line 324
    m = b;
  }
#line 325
  if (m > c) {
#line 325
    m = m;
  } else {
#line 325
    m = c;
  }
#line 326
  if (m > d) {
#line 326
    m = m;
  } else {
#line 326
    m = d;
  }
#line 327
  return (m);
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max_pps_referenced(pps_entry *pps_list___4 , unsigned int node ) 
{ 
  unsigned int max_pps ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 337
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
#line 337
    tmp = (pps_list___4 + node)->dir;
  } else {
#line 337
    tmp = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
#line 337
    tmp___0 = (pps_list___4 + node)->next;
  } else {
#line 337
    tmp___0 = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
#line 337
    tmp___1 = (pps_list___4 + node)->previous;
  } else {
#line 337
    tmp___1 = 0U;
  }
  {
#line 337
  max_pps = max3(node, tmp___1, tmp___0, tmp);
  }
#line 342
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
    {
#line 343
    tmp___4 = max_pps_referenced(pps_list___4, (pps_list___4 + node)->previous);
    }
#line 343
    if (max_pps > tmp___4) {
#line 343
      max_pps = max_pps;
    } else {
      {
#line 343
      tmp___3 = max_pps_referenced(pps_list___4, (pps_list___4 + node)->previous);
#line 343
      max_pps = tmp___3;
      }
    }
  }
#line 345
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
    {
#line 346
    tmp___7 = max_pps_referenced(pps_list___4, (pps_list___4 + node)->next);
    }
#line 346
    if (max_pps > tmp___7) {
#line 346
      max_pps = max_pps;
    } else {
      {
#line 346
      tmp___6 = max_pps_referenced(pps_list___4, (pps_list___4 + node)->next);
#line 346
      max_pps = tmp___6;
      }
    }
  }
#line 348
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
    {
#line 349
    tmp___10 = max_pps_referenced(pps_list___4, (pps_list___4 + node)->dir);
    }
#line 349
    if (max_pps > tmp___10) {
#line 349
      max_pps = max_pps;
    } else {
      {
#line 349
      tmp___9 = max_pps_referenced(pps_list___4, (pps_list___4 + node)->dir);
#line 349
      max_pps = tmp___9;
      }
    }
  }
#line 352
  return (max_pps);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_streams(pps_entry *pps_list___4 , pps_entry *node ) 
{ 
  unsigned int U32end_chain ;
  int retval ;
  int retval___0 ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;
  int retval___4 ;
  int retval___5 ;

  {
#line 359
  U32end_chain = 4294967294U;
#line 363
  if (! node->name[0]) {
#line 363
    return (12);
  }
  {
#line 366
  if ((int )node->type == 1) {
#line 366
    goto case_1;
  }
#line 374
  if ((int )node->type == 5) {
#line 374
    goto case_5;
  }
#line 385
  if ((int )node->type == 2) {
#line 385
    goto case_2;
  }
#line 399
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 368
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 369
    retval = process_streams(pps_list___4, pps_list___4 + node->dir);
    }
#line 369
    if (retval) {
#line 369
      return (retval);
    }
  }
#line 370
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 371
    retval___0 = process_streams(pps_list___4, pps_list___4 + node->next);
    }
#line 371
    if (retval___0) {
#line 371
      return (retval___0);
    }
  }
#line 372
  goto switch_break;
  case_5: /* CIL Label */ 
#line 375
  if (! ((int )*(Root___0->file.root_list + 66) == 5)) {
    {
#line 375
    __assert_fail("*(Root->file.root_list + 0x42) == 5", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  375U, "process_streams");
    }
  }
  {
#line 378
  fil_swriteU32(Root___0->file.root_list + 116, & U32end_chain);
  }
#line 379
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 380
    retval___1 = process_streams(pps_list___4, pps_list___4 + node->dir);
    }
#line 380
    if (retval___1) {
#line 380
      return (retval___1);
    }
  }
#line 381
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 382
    retval___2 = process_streams(pps_list___4, pps_list___4 + node->next);
    }
#line 382
    if (retval___2) {
#line 382
      return (retval___2);
    }
  }
#line 383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 386
  if (! ((unsigned long )node->dir == 4294967295UL)) {
#line 386
    return (12);
  }
#line 387
  if (node->size < 4096U) {
    {
#line 389
    retval___3 = add_stream_to_sbfile_and_SDepot(node->size, node->filename, node->ppsnumber);
    }
#line 389
    if (retval___3) {
#line 389
      return (retval___3);
    }
  } else {
    {
#line 393
    retval___4 = add_stream_to_Input_and_BDepot(node->size, node->filename, node->ppsnumber);
    }
#line 393
    if (retval___4) {
#line 393
      return (retval___4);
    }
  }
#line 395
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 396
    retval___5 = process_streams(pps_list___4, pps_list___4 + node->next);
    }
#line 396
    if (retval___5) {
#line 396
      return (retval___5);
    }
  }
#line 397
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 400
  return (12);
  switch_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_entry_to_Root(pps_entry *node , unsigned int start_block ) 
{ 
  unsigned int entry_number ;
  unsigned char *new_entry_Root ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 416
  entry_number = add_MY_FILE_entry(Root___0, 0U);
  }
#line 417
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 417
    return (10);
  }
  {
#line 418
  new_entry_Root = Root___0->file.root_list + entry_number * 128U;
#line 421
  pps2root((unsigned char *)new_entry_Root, node, start_block);
  }
#line 424
  if (! Root___0->size) {
#line 424
    *(Root___0->blocks) = 1U;
  } else {
#line 424
    *(Root___0->blocks) = 1U + (Root___0->size - 1U) / 512U;
  }
  {
#line 428
  tmp___1 = sum_block_list(BDepot___0);
  }
#line 428
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 428
    tmp___0 = sum_block_list(BDepot___0);
#line 428
    *(BDepot___0->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 428
    *(BDepot___0->blocks) = 1U;
  }
#line 430
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_sbfile_and_SDepot(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  unsigned int *new_entry_SDepot ;
  MY_FILE *new_entry_sbfile ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 447
  entry_number = add_MY_FILE_entry(SDepot___0, size);
  }
#line 448
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 448
    return (10);
  }
  {
#line 449
  new_entry_SDepot = SDepot___0->file.block_list + entry_number;
#line 451
  entry_number = add_MY_FILE_entry(sbfile___0, size);
  }
#line 452
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 452
    return (10);
  }
#line 453
  new_entry_sbfile = sbfile___0->file.MY_FILE_list + entry_number;
#line 458
  if (! size) {
#line 458
    *new_entry_SDepot = 1U;
  } else {
#line 458
    *new_entry_SDepot = 1U + (size - 1U) / 64U;
  }
  {
#line 461
  tmp___1 = sum_block_list(SDepot___0);
  }
#line 461
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 461
    tmp___0 = sum_block_list(SDepot___0);
#line 461
    *(SDepot___0->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 461
    *(SDepot___0->blocks) = 1U;
  }
  {
#line 468
  new_entry_sbfile->type = (enum __anonenum_type_26 )0;
#line 468
  new_entry_sbfile->size = size;
#line 468
  new_entry_sbfile->blocks = new_entry_SDepot;
#line 468
  new_entry_sbfile->file.real.name = name;
#line 468
  new_entry_sbfile->file.real.ppsnumber = ppsnumber;
#line 472
  tmp___4 = sum_blocks_MY_FILE_list(sbfile___0);
  }
#line 472
  if (tmp___4 * 64U) {
    {
#line 472
    tmp___3 = sum_blocks_MY_FILE_list(sbfile___0);
#line 472
    *(sbfile___0->blocks) = 1U + (tmp___3 * 64U - 1U) / 512U;
    }
  } else {
#line 472
    *(sbfile___0->blocks) = 1U;
  }
  {
#line 477
  tmp___7 = sum_block_list(BDepot___0);
  }
#line 477
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 477
    tmp___6 = sum_block_list(BDepot___0);
#line 477
    *(BDepot___0->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___6 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 477
    *(BDepot___0->blocks) = 1U;
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_Input_and_BDepot(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  MY_FILE *new_entry_Input ;
  unsigned int *new_entry_BDepot ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 496
  entry_number = add_MY_FILE_entry(BDepot___0, size);
  }
#line 497
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 497
    return (10);
  }
  {
#line 498
  new_entry_BDepot = BDepot___0->file.block_list + entry_number;
#line 500
  entry_number = add_MY_FILE_entry(& Input, size);
  }
#line 501
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 501
    return (10);
  }
#line 502
  new_entry_Input = Input.file.MY_FILE_list + entry_number;
#line 507
  if (! size) {
#line 507
    *new_entry_BDepot = 1U;
  } else {
#line 507
    *new_entry_BDepot = 1U + (size - 1U) / 512U;
  }
  {
#line 510
  tmp___1 = sum_block_list(BDepot___0);
  }
#line 510
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 510
    tmp___0 = sum_block_list(BDepot___0);
#line 510
    *(BDepot___0->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 510
    *(BDepot___0->blocks) = 1U;
  }
  {
#line 517
  new_entry_Input->type = (enum __anonenum_type_26 )0;
#line 517
  new_entry_Input->size = size;
#line 517
  new_entry_Input->blocks = new_entry_BDepot;
#line 517
  new_entry_Input->file.real.name = name;
#line 517
  new_entry_Input->file.real.ppsnumber = ppsnumber;
#line 524
  tmp___4 = sum_block_list(BDepot___0);
  }
#line 524
  if ((unsigned long )tmp___4 * sizeof(unsigned int )) {
    {
#line 524
    tmp___3 = sum_block_list(BDepot___0);
#line 524
    *(BDepot___0->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___3 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 524
    *(BDepot___0->blocks) = 1U;
  }
#line 526
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int add_MY_FILE_entry(MY_FILE *list , unsigned int size ) 
{ 
  MY_FILE *new_MY_FILE_list ;
  unsigned int new_entry ;
  void *tmp ;
  unsigned int *new_block_list ;
  unsigned int new_entry___0 ;
  void *tmp___0 ;
  unsigned int new_entry___1 ;
  unsigned char *new_root_list ;
  void *tmp___1 ;

  {
#line 574
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 574
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  574U, "add_MY_FILE_entry");
    }
  }
  {
#line 581
  if ((unsigned int )list->type == 1U) {
#line 581
    goto case_1;
  }
#line 599
  if ((unsigned int )list->type == 2U) {
#line 599
    goto case_2;
  }
#line 616
  if ((unsigned int )list->type == 3U) {
#line 616
    goto case_3;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 585
  if (! ((unsigned long )list == (unsigned long )sbfile___0)) {
#line 585
    if (! ((unsigned long )list == (unsigned long )(& Input))) {
      {
#line 585
      __assert_fail("list == sbfile || list == &Input", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    585U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 587
  list->size = (unsigned int )((unsigned long )list->size + sizeof(MY_FILE ));
#line 588
  tmp = realloc((void *)list->file.MY_FILE_list, (size_t )list->size);
#line 588
  new_MY_FILE_list = (MY_FILE *)tmp;
#line 589
  list->file.MY_FILE_list = new_MY_FILE_list;
  }
#line 590
  if (! ((unsigned long )new_MY_FILE_list != (unsigned long )((void *)0))) {
#line 590
    return (4294967295U);
  }
  {
#line 591
  new_entry = (unsigned int )((unsigned long )list->size / sizeof(MY_FILE ) - 1UL);
#line 592
  reset_links_in_Input();
#line 592
  reset_links_in_BDepot();
#line 592
  reset_links_in_SDepot();
  }
#line 594
  return (new_entry);
  case_2: /* CIL Label */ 
#line 603
  if (! ((unsigned long )list == (unsigned long )SDepot___0)) {
#line 603
    if (! ((unsigned long )list == (unsigned long )BDepot___0)) {
      {
#line 603
      __assert_fail("list == SDepot || list == BDepot", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    603U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 605
  list->size = (unsigned int )((unsigned long )list->size + sizeof(unsigned int ));
#line 606
  tmp___0 = realloc((void *)list->file.block_list, (size_t )list->size);
#line 606
  new_block_list = (unsigned int *)tmp___0;
#line 607
  list->file.block_list = new_block_list;
  }
#line 608
  if (! ((unsigned long )new_block_list != (unsigned long )((void *)0))) {
#line 608
    return (4294967295U);
  }
  {
#line 609
  new_entry___0 = (unsigned int )((unsigned long )list->size / sizeof(unsigned int ) - 1UL);
#line 610
  reset_links_in_Input();
#line 610
  reset_links_in_BDepot();
#line 610
  reset_links_in_SDepot();
  }
#line 612
  return (new_entry___0);
  case_3: /* CIL Label */ 
#line 620
  if (! ((unsigned long )list == (unsigned long )Root___0)) {
    {
#line 620
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  620U, "add_MY_FILE_entry");
    }
  }
  {
#line 622
  list->size += 128U;
#line 623
  tmp___1 = realloc((void *)list->file.root_list, (size_t )list->size);
#line 623
  new_root_list = (unsigned char *)tmp___1;
#line 624
  list->file.root_list = new_root_list;
  }
#line 625
  if (! ((unsigned long )new_root_list != (unsigned long )((void *)0))) {
#line 625
    return (4294967295U);
  }
  {
#line 626
  new_entry___1 = list->size / 128U - 1U;
#line 627
  reset_links_in_Input();
#line 627
  reset_links_in_BDepot();
#line 627
  reset_links_in_SDepot();
  }
#line 629
  return (new_entry___1);
  switch_default: /* CIL Label */ ;
#line 640
  if (! ((unsigned long )"list->type UNKNOWN in add_MY_FILE_entry" == (unsigned long )((void *)0))) {
    {
#line 640
    __assert_fail("\"list->type UNKNOWN in add_MY_FILE_entry\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  640U, "add_MY_FILE_entry");
    }
  }
#line 641
  return (0U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int pps2root(unsigned char *pps , pps_entry *node , unsigned int start_block ) 
{ 
  unsigned short i ;
  unsigned short size_of_name ;
  unsigned char U8magiczero ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 653
  U8magiczero = (unsigned char)0;
#line 654
  U32magiczero = 0U;
#line 655
  U32magic1 = 133376U;
#line 656
  U32magic2 = 1174405120U;
#line 663
  if (! (node->ppsnumber == (unsigned int )(pps - (unsigned char *)Root___0->file.root_list) / 128U)) {
    {
#line 663
    __assert_fail("node->ppsnumber == (unsigned int)(pps - Root->file.root_list)/0x80",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  663U, "pps2root");
    }
  }
  {
#line 665
  memset((void *)pps, 255, (size_t )128);
#line 668
  tmp = strlen((char const   *)(node->name));
#line 668
  size_of_name = (unsigned short )(2UL * (tmp + 1UL));
#line 670
  i = (unsigned short)0;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! ((int )i < (int )size_of_name)) {
#line 670
      goto while_break;
    }
#line 671
    if ((int )i % 2) {
#line 671
      tmp___0 = 0;
    } else {
#line 671
      tmp___0 = (int )*(node->name + (int )i / 2);
    }
#line 671
    *(pps + (int )i) = (unsigned char )tmp___0;
#line 670
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  fil_swriteU16((unsigned char *)(pps + 64), & size_of_name);
#line 675
  *(pps + 66) = node->type;
#line 676
  fil_swriteU32((unsigned char *)(pps + 68), & node->previous);
#line 677
  fil_swriteU32((unsigned char *)(pps + 72), & node->next);
#line 678
  fil_swriteU32((unsigned char *)(pps + 76), & node->dir);
#line 679
  fil_swriteU32((unsigned char *)(pps + 100), & node->seconds1);
#line 680
  fil_swriteU32((unsigned char *)(pps + 104), & node->days1);
#line 681
  fil_swriteU32((unsigned char *)(pps + 108), & node->seconds2);
#line 682
  fil_swriteU32((unsigned char *)(pps + 112), & node->days1);
#line 683
  fil_swriteU32((unsigned char *)(pps + 116), & start_block);
#line 684
  fil_swriteU32((unsigned char *)(pps + 120), & node->size);
#line 687
  *(pps + 67) = U8magiczero;
#line 688
  fil_swriteU32((unsigned char *)(pps + 80), & U32magic1);
#line 689
  fil_swriteU32((unsigned char *)(pps + 84), & U32magiczero);
#line 690
  fil_swriteU32((unsigned char *)(pps + 88), & U32magiczero);
#line 691
  fil_swriteU32((unsigned char *)(pps + 92), & U32magic2);
#line 692
  fil_swriteU32((unsigned char *)(pps + 96), & U32magiczero);
#line 693
  fil_swriteU32((unsigned char *)(pps + 124), & U32magiczero);
  }
#line 697
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_block_list(MY_FILE *list ) 
{ 
  unsigned int sum ;
  unsigned int *block ;

  {
#line 702
  sum = 0U;
#line 707
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 707
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  707U, "sum_block_list");
    }
  }
#line 708
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 708
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  708U, "sum_block_list");
    }
  }
#line 709
  block = list->file.block_list;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned int )((unsigned char *)block - (unsigned char *)list->file.block_list) < list->size)) {
#line 709
      goto while_break;
    }
#line 712
    sum += *block;
#line 709
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return (sum);
}
}
#line 738 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_blocks_MY_FILE_list(MY_FILE *list ) 
{ 
  unsigned int sum ;
  MY_FILE *file ;

  {
#line 740
  sum = 0U;
#line 745
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 745
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  745U, "sum_blocks_MY_FILE_list");
    }
  }
#line 746
  if (! ((unsigned int )list->type == 1U)) {
    {
#line 746
    __assert_fail("list->type == MY_FILE_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  746U, "sum_blocks_MY_FILE_list");
    }
  }
#line 747
  file = list->file.MY_FILE_list;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )((unsigned char *)file - (unsigned char *)list->file.MY_FILE_list) < list->size)) {
#line 747
      goto while_break;
    }
#line 750
    if ((unsigned long )file->blocks != (unsigned long )((void *)0)) {
#line 751
      sum += *(file->blocks);
    }
#line 747
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (sum);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_Input(void) 
{ 


  {
#line 759
  sbfile___0 = Input.file.MY_FILE_list + 4;
#line 760
  SDepot___0 = Input.file.MY_FILE_list + 3;
#line 761
  BDepot___0 = Input.file.MY_FILE_list + 1;
#line 762
  bbd_list = Input.file.MY_FILE_list;
#line 763
  Root___0 = Input.file.MY_FILE_list + 2;
#line 764
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_BDepot(void) 
{ 
  unsigned int i ;

  {
#line 772
  sbfile___0->blocks = BDepot___0->file.block_list;
#line 773
  SDepot___0->blocks = BDepot___0->file.block_list + 1;
#line 774
  Root___0->blocks = BDepot___0->file.block_list + 2;
#line 777
  i = 0U;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )i < (unsigned long )Input.size / sizeof(MY_FILE ) - 5UL)) {
#line 777
      goto while_break;
    }
#line 778
    (Input.file.MY_FILE_list + (i + 5U))->blocks = (BDepot___0->file.block_list + i) + 3;
#line 777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_SDepot(void) 
{ 
  unsigned int i ;

  {
#line 788
  i = 0U;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! ((unsigned long )i < (unsigned long )sbfile___0->size / sizeof(MY_FILE ))) {
#line 788
      goto while_break;
    }
#line 789
    (sbfile___0->file.MY_FILE_list + i)->blocks = SDepot___0->file.block_list + i;
#line 788
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_ole2_file(char const   *filename___4 , int trunc ) 
{ 
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;

  {
#line 796
  if (! trunc) {
    {
#line 798
    output_file = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"r");
    }
#line 799
    if (! ((unsigned long )output_file == (unsigned long )((void *)0))) {
      {
#line 799
      ends___0();
      }
#line 799
      return (2);
    }
  }
  {
#line 801
  output_file = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"wb");
  }
#line 802
  if (! ((unsigned long )output_file != (unsigned long )((void *)0))) {
    {
#line 802
    ends___0();
    }
#line 802
    return (3);
  }
  {
#line 804
  retval = generate_header();
  }
#line 804
  if (retval) {
#line 804
    return (retval);
  }
  {
#line 805
  retval___0 = generate_recursive(& Input);
  }
#line 805
  if (retval___0) {
#line 805
    return (retval___0);
  }
#line 809
  if ((int )pos_block != 0) {
#line 809
    if ((int )pos_block % 512) {
      {
#line 809
      memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 512 + 1) * 512 - (int )pos_block));
      }
    }
    {
#line 809
    tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )1, (size_t )512,
                 (FILE */* __restrict  */)output_file);
    }
#line 809
    if (! (tmp == 512UL)) {
#line 809
      return (1);
    }
#line 809
    next_block ++;
#line 809
    pos_block = (unsigned short)0;
  }
  {
#line 810
  retval___1 = generate_SDepot();
  }
#line 810
  if (retval___1) {
#line 810
    return (retval___1);
  }
  {
#line 811
  retval___2 = generate_Root();
  }
#line 811
  if (retval___2) {
#line 811
    return (retval___2);
  }
  {
#line 812
  retval___3 = generate_BDepot();
  }
#line 812
  if (retval___3) {
#line 812
    return (retval___3);
  }
  {
#line 814
  fclose(output_file);
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_header(void) 
{ 
  unsigned int identifier1 ;
  unsigned int identifier2 ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  unsigned int U32magic3 ;
  unsigned int U32magic4 ;
  unsigned int U32magic5 ;
  unsigned int U32magic6 ;

  {
  {
#line 821
  identifier1 = 3759263696U;
#line 822
  identifier2 = 3776623009U;
#line 823
  U32magiczero = 0U;
#line 824
  U32magic1 = 196667U;
#line 825
  U32magic2 = 655358U;
#line 826
  U32magic3 = 6U;
#line 827
  U32magic4 = 4096U;
#line 828
  U32magic5 = 1U;
#line 829
  U32magic6 = 4294967294U;
#line 833
  calculate_blocks();
#line 835
  fil_swriteU32(output_block + 48, & Root_start_block);
#line 836
  fil_swriteU32(output_block + 60, & SDepot_start_block);
#line 837
  fil_swriteU32(output_block + 44, & BDepot_blocks);
#line 839
  fil_swriteU32(output_block + 0, & identifier1);
#line 840
  fil_swriteU32(output_block + 4, & identifier2);
#line 841
  fil_swriteU32(output_block + 8, & U32magiczero);
#line 842
  fil_swriteU32(output_block + 12, & U32magiczero);
#line 843
  fil_swriteU32(output_block + 16, & U32magiczero);
#line 844
  fil_swriteU32(output_block + 20, & U32magiczero);
#line 845
  fil_swriteU32(output_block + 24, & U32magic1);
#line 846
  fil_swriteU32(output_block + 28, & U32magic2);
#line 847
  fil_swriteU32(output_block + 32, & U32magic3);
#line 848
  fil_swriteU32(output_block + 36, & U32magiczero);
#line 849
  fil_swriteU32(output_block + 40, & U32magiczero);
#line 850
  fil_swriteU32(output_block + 52, & U32magiczero);
#line 851
  fil_swriteU32(output_block + 56, & U32magic4);
#line 852
  fil_swriteU32(output_block + 64, & U32magic5);
#line 853
  fil_swriteU32(output_block + 68, & U32magic6);
#line 854
  fil_swriteU32(output_block + 72, & U32magiczero);
#line 856
  pos_block = (unsigned short)76;
  }
#line 858
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_recursive(MY_FILE *list ) 
{ 
  MY_FILE *p_MY_FILE_list ;
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;

  {
  {
#line 873
  if ((unsigned int )list->type == 1U) {
#line 873
    goto case_1;
  }
#line 881
  if ((unsigned int )list->type == 2U) {
#line 881
    goto case_2;
  }
#line 898
  if ((unsigned int )list->type == 3U) {
#line 898
    goto case_3;
  }
#line 903
  if ((unsigned int )list->type == 0U) {
#line 903
    goto case_0;
  }
#line 908
  goto switch_default;
  case_1: /* CIL Label */ 
#line 874
  p_MY_FILE_list = list->file.MY_FILE_list;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! ((unsigned int )((unsigned char *)p_MY_FILE_list - list->file.root_list) < list->size)) {
#line 874
      goto while_break;
    }
    {
#line 877
    retval = generate_recursive(p_MY_FILE_list);
    }
#line 877
    if (retval) {
#line 877
      return (retval);
    }
#line 874
    p_MY_FILE_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  goto switch_break;
  case_2: /* CIL Label */ 
#line 882
  if ((unsigned long )list == (unsigned long )bbd_list) {
    {
#line 884
    retval___0 = write_block_list(BDepot_start_block, bbd_list, 0);
    }
#line 884
    if (retval___0) {
#line 884
      return (retval___0);
    }
#line 885
    if ((int )pos_block != 0) {
#line 885
      if ((int )pos_block % 512) {
        {
#line 885
        memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 512 + 1) * 512 - (int )pos_block));
        }
      }
      {
#line 885
      tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )1, (size_t )512,
                   (FILE */* __restrict  */)output_file);
      }
#line 885
      if (! (tmp == 512UL)) {
#line 885
        return (1);
      }
#line 885
      next_block ++;
#line 885
      pos_block = (unsigned short)0;
    }
#line 886
    goto switch_break;
  } else
#line 888
  if ((unsigned long )list == (unsigned long )BDepot___0) {
#line 890
    goto switch_break;
  } else
#line 891
  if ((unsigned long )list == (unsigned long )SDepot___0) {
#line 893
    goto switch_break;
  } else
#line 895
  if (! ((unsigned long )"list->type==block_list but list UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 895
    __assert_fail("\"list->type==block_list but list UNKNOWN in generate_recursive\"==((void *)0)",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  895U, "generate_recursive");
    }
  }
  case_3: /* CIL Label */ 
#line 900
  if (! ((unsigned long )list == (unsigned long )Root___0)) {
    {
#line 900
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  900U, "generate_recursive");
    }
  }
#line 901
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 905
  retval___1 = generate_real_file(list);
  }
#line 905
  if (retval___1) {
#line 905
    return (retval___1);
  }
#line 906
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 909
  if (! ((unsigned long )"list->type UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 909
    __assert_fail("\"list->type UNKNOWN in generate_recursive\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  909U, "generate_recursive");
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 912
  return (0);
}
}
#line 916 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_SDepot(void) 
{ 
  int retval ;
  size_t tmp ;

  {
  {
#line 920
  retval = write_block_list(1U, SDepot___0, 1);
  }
#line 920
  if (retval) {
#line 920
    return (retval);
  }
#line 921
  if ((int )pos_block != 0) {
#line 921
    if ((int )pos_block % 512) {
      {
#line 921
      memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 512 + 1) * 512 - (int )pos_block));
      }
    }
    {
#line 921
    tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )1, (size_t )512,
                 (FILE */* __restrict  */)output_file);
    }
#line 921
    if (! (tmp == 512UL)) {
#line 921
      return (1);
    }
#line 921
    next_block ++;
#line 921
    pos_block = (unsigned short)0;
  }
#line 923
  return (0);
}
}
#line 927 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_Root(void) 
{ 
  int retval ;
  int zzzi ;
  unsigned short U16zero ;
  size_t tmp ;

  {
  {
#line 931
  retval = write_root_list(Root___0);
  }
#line 931
  if (retval) {
#line 931
    return (retval);
  }
#line 932
  if ((int )pos_block != 0) {
    {
#line 932
    U16zero = (unsigned short)0;
#line 932
    memset((void *)(output_block + (int )pos_block), 255, (size_t )(512 - (int )pos_block));
#line 932
    zzzi = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 932
      if (! (zzzi < 4)) {
#line 932
        goto while_break;
      }
#line 932
      if (zzzi * 128 >= (int )pos_block) {
        {
#line 932
        fil_swriteU16((output_block + zzzi * 128) + 64, & U16zero);
        }
      }
#line 932
      zzzi ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 933
  if ((int )pos_block != 0) {
    {
#line 933
    tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )1, (size_t )512,
                 (FILE */* __restrict  */)output_file);
    }
#line 933
    if (! (tmp == 512UL)) {
#line 933
      return (1);
    }
#line 933
    next_block ++;
#line 933
    pos_block = (unsigned short)0;
  }
#line 935
  return (0);
}
}
#line 938 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_BDepot(void) 
{ 
  MY_FILE SDepot_and_Root_block_list ;
  MY_FILE file_block_list ;
  unsigned int next_block_link ;
  int retval ;
  int retval___0 ;
  unsigned int tmp ;
  int retval___1 ;
  size_t tmp___0 ;

  {
#line 946
  next_block_link = (unsigned int )((4294967295UL + (unsigned long )header_blocks) + 1UL);
#line 950
  if (! (next_block_link == sbfile_start_block + 1U)) {
    {
#line 950
    __assert_fail("next_block_link == sbfile_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  950U, "generate_BDepot");
    }
  }
  {
#line 952
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 952
  file_block_list.size = (unsigned int )sizeof(unsigned int );
#line 952
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 952
  file_block_list.file.block_list = BDepot___0->file.block_list;
#line 955
  retval = write_block_list(next_block_link, & file_block_list, 1);
  }
#line 955
  if (retval) {
#line 955
    return (retval);
  }
#line 958
  next_block_link += sbfile_blocks;
#line 961
  if (! (next_block_link == (sbfile_start_block + sbfile_blocks) + 1U)) {
    {
#line 961
    __assert_fail("next_block_link == sbfile_start_block + sbfile_blocks + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  961U, "generate_BDepot");
    }
  }
  {
#line 963
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 963
  file_block_list.size = (unsigned int )((unsigned long )BDepot___0->size - 3UL * sizeof(unsigned int ));
#line 963
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 963
  file_block_list.file.block_list = BDepot___0->file.block_list + 3;
#line 965
  retval___0 = write_block_list(next_block_link, & file_block_list, 1);
  }
#line 965
  if (retval___0) {
#line 965
    return (retval___0);
  }
  {
#line 968
  tmp = sum_block_list(& file_block_list);
#line 968
  next_block_link += tmp;
  }
#line 971
  if (sbfile___0->size > 0U) {
#line 973
    if (! (next_block_link == SDepot_start_block + 1U)) {
      {
#line 973
      __assert_fail("next_block_link == SDepot_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    973U, "generate_BDepot");
      }
    }
  }
  {
#line 975
  SDepot_and_Root_block_list.type = (enum __anonenum_type_26 )2;
#line 975
  SDepot_and_Root_block_list.size = (unsigned int )(2UL * sizeof(unsigned int ));
#line 975
  SDepot_and_Root_block_list.blocks = (unsigned int *)((void *)0);
#line 975
  SDepot_and_Root_block_list.file.block_list = BDepot___0->file.block_list + 1;
#line 977
  retval___1 = write_block_list(next_block_link, & SDepot_and_Root_block_list, 1);
  }
#line 977
  if (retval___1) {
#line 977
    return (retval___1);
  }
#line 980
  if ((int )pos_block != 0) {
#line 980
    if ((int )pos_block % 512) {
      {
#line 980
      memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 512 + 1) * 512 - (int )pos_block));
      }
    }
    {
#line 980
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file);
    }
#line 980
    if (! (tmp___0 == 512UL)) {
#line 980
      return (1);
    }
#line 980
    next_block ++;
#line 980
    pos_block = (unsigned short)0;
  }
#line 982
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int last_small_stream_next_block  =    0U;
#line 993 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_start_block_set  =    0;
#line 994 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_may_need_write_until_boundary  =    0;
#line 985 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_real_file(MY_FILE *MY_FILE_file ) 
{ 
  FILE *file ;
  int n_read ;
  unsigned char *pps ;
  unsigned int total_bytes ;
  unsigned int sbfile_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 1004
  if (! ((int )pos_block <= 512)) {
    {
#line 1004
    __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1004U, "generate_real_file");
    }
  }
#line 1005
  if (! ((int )pos_block % 64 == 0)) {
    {
#line 1005
    __assert_fail("pos_block % 0x40 == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1005U, "generate_real_file");
    }
  }
#line 1008
  if (! *(MY_FILE_file->file.real.name + 0)) {
    {
#line 1008
    __assert_fail("MY_FILE_file->file.real.name[0]", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1008U, "generate_real_file");
    }
  }
  {
#line 1009
  file = fopen((char const   */* __restrict  */)MY_FILE_file->file.real.name, (char const   */* __restrict  */)"rb");
  }
#line 1010
  if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 1010
    return (11);
  }
#line 1013
  if (MY_FILE_file->size >= 4096U) {
#line 1018
    if (sbfile_may_need_write_until_boundary) {
#line 1022
      if ((int )pos_block != 0) {
#line 1022
        if ((int )pos_block % 512) {
          {
#line 1022
          memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 512 + 1) * 512 - (int )pos_block));
          }
        }
        {
#line 1022
        tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file);
        }
#line 1022
        if (! (tmp == 512UL)) {
#line 1022
          return (1);
        }
#line 1022
        next_block ++;
#line 1022
        pos_block = (unsigned short)0;
      }
#line 1023
      sbfile_may_need_write_until_boundary = 0;
    }
    {
#line 1029
    pps = Root___0->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1030
    fil_swriteU32(pps + 116, & next_block);
    }
  } else {
    {
#line 1039
    pps = Root___0->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1040
    fil_swriteU32(pps + 116, & last_small_stream_next_block);
#line 1041
    last_small_stream_next_block += *(MY_FILE_file->blocks);
    }
#line 1044
    if (! sbfile_start_block_set) {
#line 1050
      if (! (sbfile_start_block == next_block)) {
        {
#line 1050
        __assert_fail("sbfile_start_block == next_block", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1050U, "generate_real_file");
        }
      }
      {
#line 1051
      fil_swriteU32(Root___0->file.root_list + 116, & next_block);
#line 1053
      tmp___0 = sum_blocks_MY_FILE_list(sbfile___0);
#line 1053
      sbfile_size = tmp___0 * 64U;
#line 1056
      tmp___1 = fil_sreadU32(Root___0->file.root_list + 120);
      }
#line 1056
      if (! (sbfile_size == tmp___1)) {
        {
#line 1056
        __assert_fail("sbfile_size == fil_sreadU32 (Root->file.root_list + 0x78)",
                      "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1056U, "generate_real_file");
        }
      }
#line 1058
      sbfile_start_block_set = 1;
#line 1059
      sbfile_may_need_write_until_boundary = 1;
    }
  }
#line 1064
  total_bytes = 0U;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1066
    tmp___6 = feof(file);
    }
#line 1066
    if (tmp___6) {
#line 1066
      goto while_break;
    }
    {
#line 1068
    tmp___2 = fread((void */* __restrict  */)(output_block + (int )pos_block), (size_t )1,
                    (size_t )(512 - (int )pos_block), (FILE */* __restrict  */)file);
#line 1068
    n_read = (int )tmp___2;
#line 1069
    tmp___3 = ferror(file);
    }
#line 1069
    if (tmp___3) {
#line 1069
      return (11);
    }
#line 1070
    if (n_read < 512 - (int )pos_block) {
      {
#line 1072
      tmp___4 = feof(file);
      }
#line 1072
      if (! tmp___4) {
        {
#line 1072
        __assert_fail("feof (file)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1072U, "generate_real_file");
        }
      }
    }
#line 1073
    pos_block = (unsigned short )((int )pos_block + (int )((unsigned short )n_read));
#line 1074
    total_bytes += (unsigned int )n_read;
#line 1075
    if ((int )pos_block == 512) {
      {
#line 1075
      tmp___5 = fwrite((void const   */* __restrict  */)(output_block), (size_t )512,
                       (size_t )1, (FILE */* __restrict  */)output_file);
      }
#line 1075
      if (! (tmp___5 == 1UL)) {
#line 1075
        return (1);
      }
#line 1075
      next_block ++;
#line 1075
      pos_block = (unsigned short)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (! (total_bytes == MY_FILE_file->size)) {
#line 1077
    return (12);
  }
#line 1079
  if (MY_FILE_file->size >= 4096U) {
#line 1081
    if ((int )pos_block != 0) {
#line 1081
      if ((int )pos_block % 512) {
        {
#line 1081
        memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 512 + 1) * 512 - (int )pos_block));
        }
      }
      {
#line 1081
      tmp___7 = fwrite((void const   */* __restrict  */)(output_block), (size_t )1,
                       (size_t )512, (FILE */* __restrict  */)output_file);
      }
#line 1081
      if (! (tmp___7 == 512UL)) {
#line 1081
        return (1);
      }
#line 1081
      next_block ++;
#line 1081
      pos_block = (unsigned short)0;
    }
  } else
#line 1084
  if ((int )pos_block % 64) {
    {
#line 1084
    memset((void *)(output_block + (int )pos_block), 255, (size_t )(((int )pos_block / 64 + 1) * 64 - (int )pos_block));
    }
#line 1084
    if (! (((int )pos_block + ((int )pos_block / 64 + 1) * 64) - (int )pos_block == ((int )pos_block / 64 + 1) * 64)) {
      {
#line 1084
      __assert_fail("pos_block+(pos_block/0x40 + 1)*0x40 - pos_block == (pos_block/0x40 + 1)*0x40",
                    "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1084U, "generate_real_file");
      }
    }
#line 1084
    pos_block = (unsigned short )((int )pos_block + (int )((unsigned short )(((int )pos_block / 64 + 1) * 64 - (int )pos_block)));
  }
  {
#line 1087
  fclose(file);
  }
#line 1089
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_block_list(unsigned int start_count , MY_FILE *list , int write_end_chain ) 
{ 
  unsigned int *p ;
  unsigned int n ;
  unsigned int end_chain ;
  unsigned int value_to_write ;
  unsigned int delta ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1098
  end_chain = 4294967294U;
#line 1104
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 1104
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1104U, "write_block_list");
    }
  }
#line 1105
  if (! ((int )pos_block <= 508)) {
    {
#line 1105
    __assert_fail("pos_block <= 0x01fc", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1105U, "write_block_list");
    }
  }
#line 1107
  delta = start_count;
#line 1108
  if (list->size == 0U) {
#line 1108
    return (0);
  }
#line 1109
  p = list->file.block_list;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! ((unsigned int )((unsigned char *)p - (unsigned char *)list->file.block_list) < list->size)) {
#line 1109
      goto while_break;
    }
#line 1112
    n = 0U;
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1112
      if (! (n < *p)) {
#line 1112
        goto while_break___0;
      }
#line 1115
      if ((int )pos_block == 512) {
        {
#line 1115
        tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file);
        }
#line 1115
        if (! (tmp == 1UL)) {
#line 1115
          return (1);
        }
#line 1115
        next_block ++;
#line 1115
        pos_block = (unsigned short)0;
      }
#line 1118
      if (write_end_chain) {
#line 1118
        if (! (n + 1U < *p)) {
#line 1119
          value_to_write = end_chain;
        } else {
#line 1121
          value_to_write = n + delta;
        }
      } else {
#line 1121
        value_to_write = n + delta;
      }
      {
#line 1122
      fil_swriteU32(output_block + (int )pos_block, & value_to_write);
#line 1123
      pos_block = (unsigned short )((int )pos_block + (int )((unsigned short )sizeof(unsigned int )));
      }
#line 1124
      if (! ((int )pos_block <= 512)) {
        {
#line 1124
        __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1124U, "write_block_list");
        }
      }
#line 1112
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1126
    delta += n;
#line 1109
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1128
  if ((int )pos_block == 512) {
    {
#line 1128
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file);
    }
#line 1128
    if (! (tmp___0 == 1UL)) {
#line 1128
      return (1);
    }
#line 1128
    next_block ++;
#line 1128
    pos_block = (unsigned short)0;
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_root_list(MY_FILE *list ) 
{ 
  unsigned char *p ;
  size_t tmp ;

  {
#line 1139
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1139
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1139U, "write_root_list");
    }
  }
#line 1140
  if (! ((int )pos_block == 0)) {
    {
#line 1140
    __assert_fail("pos_block == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1140U, "write_root_list");
    }
  }
#line 1141
  if (! ((unsigned int )list->type == 3U)) {
    {
#line 1141
    __assert_fail("list->type == root_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1141U, "write_root_list");
    }
  }
#line 1142
  if (! (list->size > 0U)) {
    {
#line 1142
    __assert_fail("list->size > 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1142U, "write_root_list");
    }
  }
#line 1144
  p = list->file.root_list;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (! ((unsigned int )(p - list->file.root_list) < list->size)) {
#line 1144
      goto while_break;
    }
    {
#line 1147
    memcpy((void */* __restrict  */)(output_block + (p - list->file.root_list) % 512L),
           (void const   */* __restrict  */)p, (size_t )128);
#line 1169
    pos_block = (unsigned short )((int )pos_block + 128);
    }
#line 1170
    if (! ((int )pos_block <= 512)) {
      {
#line 1170
      __assert_fail("pos_block <= (unsigned short)0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1170U, "write_root_list");
      }
    }
#line 1171
    if ((int )pos_block == 512) {
      {
#line 1171
      tmp = fwrite((void const   */* __restrict  */)(output_block), (size_t )512,
                   (size_t )1, (FILE */* __restrict  */)output_file);
      }
#line 1171
      if (! (tmp == 1UL)) {
#line 1171
        return (1);
      }
#line 1171
      next_block ++;
#line 1171
      pos_block = (unsigned short)0;
    }
#line 1144
    p += 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void ends___0(void) 
{ 


  {
#line 1193
  if ((unsigned long )output_file != (unsigned long )((void *)0)) {
    {
#line 1194
    fclose(output_file);
    }
  }
#line 1195
  return;
}
}
#line 1198 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void calculate_blocks(void) 
{ 
  MY_FILE big_streams_list ;
  unsigned int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1205
  big_streams_list.type = (enum __anonenum_type_26 )1;
#line 1205
  big_streams_list.size = (unsigned int )((unsigned long )Input.size - 5UL * sizeof(MY_FILE ));
#line 1205
  big_streams_list.blocks = (unsigned int *)((void *)0);
#line 1205
  big_streams_list.file.MY_FILE_list = Input.file.MY_FILE_list + 5;
#line 1211
  if (! (*(BDepot___0->blocks) == *(bbd_list->file.block_list))) {
    {
#line 1211
    __assert_fail("*(BDepot->blocks) == *(bbd_list->file.block_list)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1211U, "calculate_blocks");
    }
  }
#line 1212
  if (! Root___0->size) {
#line 1212
    tmp = 1U;
  } else {
#line 1212
    tmp = 1U + (Root___0->size - 1U) / 512U;
  }
#line 1212
  if (! (*(Root___0->blocks) == tmp)) {
    {
#line 1212
    __assert_fail("*(Root->blocks) == (!(Root->size) ? 1 : (1+((Root->size)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1212U, "calculate_blocks");
    }
  }
  {
#line 1215
  tmp___3 = sum_blocks_MY_FILE_list(sbfile___0);
  }
#line 1215
  if (tmp___3 * 64U) {
    {
#line 1215
    tmp___1 = sum_blocks_MY_FILE_list(sbfile___0);
#line 1215
    tmp___2 = 1U + (tmp___1 * 64U - 1U) / 512U;
    }
  } else {
#line 1215
    tmp___2 = 0U;
  }
#line 1215
  if (! (*(sbfile___0->blocks) == tmp___2)) {
    {
#line 1215
    __assert_fail("*(sbfile->blocks) == (!(sum_blocks_MY_FILE_list (sbfile) * 0x40) ? 0 : (1+((sum_blocks_MY_FILE_list (sbfile) * 0x40)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1216U, "calculate_blocks");
    }
  }
  {
#line 1217
  tmp___7 = sum_block_list(SDepot___0);
  }
#line 1217
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 1217
    tmp___5 = sum_block_list(SDepot___0);
#line 1217
    tmp___6 = 1UL + ((unsigned long )tmp___5 * sizeof(unsigned int ) - 1UL) / 512UL;
    }
  } else {
#line 1217
    tmp___6 = 0UL;
  }
#line 1217
  if (! ((unsigned long )*(SDepot___0->blocks) == tmp___6)) {
    {
#line 1217
    __assert_fail("*(SDepot->blocks) == (!((sum_block_list (SDepot) * sizeof (unsigned int))) ? 0 : (1+(((sum_block_list (SDepot) * sizeof (unsigned int)))-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1218U, "calculate_blocks");
    }
  }
  {
#line 1219
  BDepot_blocks = *(BDepot___0->blocks);
#line 1220
  SDepot_blocks = *(SDepot___0->blocks);
#line 1221
  Root_blocks = *(Root___0->blocks);
#line 1222
  sbfile_blocks = *(sbfile___0->blocks);
#line 1223
  big_streams_blocks = sum_blocks_MY_FILE_list(& big_streams_list);
  }
#line 1224
  if (! ((unsigned long )(19U + BDepot_blocks) * sizeof(unsigned int ))) {
#line 1224
    header_blocks = 1U;
  } else {
#line 1224
    header_blocks = (unsigned int )(1UL + ((unsigned long )(19U + BDepot_blocks) * sizeof(unsigned int ) - 1UL) / 512UL);
  }
#line 1228
  sbfile_start_block = (unsigned int )(4294967295UL + (unsigned long )header_blocks);
#line 1230
  Root_start_block = (unsigned int )((((4294967295UL + (unsigned long )header_blocks) + (unsigned long )sbfile_blocks) + (unsigned long )big_streams_blocks) + (unsigned long )SDepot_blocks);
#line 1233
  if (SDepot_blocks > 0U) {
#line 1235
    SDepot_start_block = (unsigned int )(((4294967295UL + (unsigned long )header_blocks) + (unsigned long )sbfile_blocks) + (unsigned long )big_streams_blocks);
  } else {
#line 1239
    SDepot_start_block = 4294967294U;
  }
#line 1240
  BDepot_start_block = (unsigned int )(((((4294967295UL + (unsigned long )header_blocks) + (unsigned long )sbfile_blocks) + (unsigned long )big_streams_blocks) + (unsigned long )SDepot_blocks) + (unsigned long )Root_blocks);
#line 1247
  return;
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 128 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/internal.h"
int __cole_extract_file(FILE **file , char **filename___4 , unsigned int size , unsigned int pps_start ,
                        unsigned char *BDepot___9 , unsigned char *SDepot___9 , FILE *sbfile___9 ,
                        FILE *inputfile ) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/internal.c"
int __cole_extract_file(FILE **file , char **filename___4 , unsigned int size , unsigned int pps_start ,
                        unsigned char *BDepot___9 , unsigned char *SDepot___9 , FILE *sbfile___9 ,
                        FILE *inputfile ) 
{ 
  unsigned short BlockSize ;
  unsigned short Offset ;
  unsigned char *Depot ;
  FILE *infile ;
  long FilePos ;
  size_t bytes_to_copy ;
  unsigned char Block___4[512] ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 68
  tmp = malloc((size_t )18);
#line 68
  *filename___4 = (char *)tmp;
  }
#line 69
  if ((unsigned long )*filename___4 == (unsigned long )((void *)0)) {
#line 70
    return (1);
  }
  {
#line 72
  strcpy((char */* __restrict  */)*filename___4, (char const   */* __restrict  */)"/tmp/xlHtmlXXXXXX");
#line 73
  ret = mkstemp(*filename___4);
  }
#line 74
  if (ret == -1) {
    {
#line 75
    free((void *)*filename___4);
    }
#line 76
    return (2);
  }
  {
#line 79
  *file = fdopen(ret, "w+b");
  }
#line 80
  if ((unsigned long )*file == (unsigned long )((void *)0)) {
    {
#line 81
    free((void *)*filename___4);
#line 82
    close(ret);
    }
#line 83
    return (3);
  }
  {
#line 86
  unlink((char const   *)*filename___4);
  }
#line 88
  if (size >= 4096U) {
#line 90
    Offset = (unsigned short)1;
#line 91
    BlockSize = (unsigned short)512;
#line 92
    infile = inputfile;
#line 93
    Depot = BDepot___9;
  } else {
#line 96
    Offset = (unsigned short)0;
#line 97
    BlockSize = (unsigned short)64;
#line 98
    infile = sbfile___9;
#line 99
    Depot = SDepot___9;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )pps_start != 4294967294UL)) {
#line 101
      goto while_break;
    }
#line 103
    FilePos = (long )((pps_start + (unsigned int )Offset) * (unsigned int )BlockSize);
#line 104
    if (FilePos < 0L) {
      {
#line 105
      fclose(*file);
#line 106
      remove((char const   *)*filename___4);
#line 107
      free((void *)*filename___4);
      }
#line 108
      return (4);
    }
#line 110
    if ((unsigned int )BlockSize < size) {
#line 110
      bytes_to_copy = (size_t )((unsigned int )BlockSize);
    } else {
#line 110
      bytes_to_copy = (size_t )size;
    }
    {
#line 111
    tmp___0 = fseek(infile, FilePos, 0);
    }
#line 111
    if (tmp___0) {
      {
#line 112
      fclose(*file);
#line 113
      remove((char const   *)*filename___4);
#line 114
      free((void *)*filename___4);
      }
#line 115
      return (4);
    }
    {
#line 117
    fread((void */* __restrict  */)(Block___4), bytes_to_copy, (size_t )1, (FILE */* __restrict  */)infile);
#line 118
    tmp___1 = ferror(infile);
    }
#line 118
    if (tmp___1) {
      {
#line 119
      fclose(*file);
#line 120
      remove((char const   *)*filename___4);
#line 121
      free((void *)*filename___4);
      }
#line 122
      return (5);
    }
    {
#line 124
    fwrite((void const   */* __restrict  */)(Block___4), bytes_to_copy, (size_t )1,
           (FILE */* __restrict  */)*file);
#line 125
    tmp___2 = ferror(*file);
    }
#line 125
    if (tmp___2) {
      {
#line 126
      fclose(*file);
#line 127
      remove((char const   *)*filename___4);
#line 128
      free((void *)*filename___4);
      }
#line 129
      return (6);
    }
    {
#line 131
    pps_start = fil_sreadU32(Depot + pps_start * 4U);
    }
#line 132
    if ((unsigned int )BlockSize < size) {
#line 132
      tmp___3 = (unsigned int )BlockSize;
    } else {
#line 132
      tmp___3 = size;
    }
#line 132
    size -= tmp___3;
#line 133
    if (size == 0U) {
#line 134
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.h"
double fil_sreadF64(unsigned char *in ) ;
#line 137
void __cole_dump(void *_m , void *_start , int length , char *msg ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.c"
unsigned short fil_sreadU16(unsigned char *in ) 
{ 


  {
#line 37
  return ((unsigned short )(((int )*(in + 1) << 8) | (int )*(in + 0)));
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.c"
unsigned int fil_sreadU32(unsigned char *in ) 
{ 
  unsigned int i0 ;
  unsigned int i1 ;
  unsigned int i2 ;
  unsigned int i3 ;

  {
#line 44
  i0 = (unsigned int )*(in + 0);
#line 44
  i1 = (unsigned int )*(in + 1);
#line 44
  i2 = (unsigned int )*(in + 2);
#line 44
  i3 = (unsigned int )*(in + 3);
#line 46
  return ((((i3 << 24) | (i2 << 16)) | (i1 << 8)) | i0);
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.c"
double fil_sreadF64(unsigned char *in ) 
{ 
  double ret ;

  {
  {
#line 64
  memcpy((void */* __restrict  */)(& ret), (void const   */* __restrict  */)in, (size_t )8);
  }
#line 66
  return (ret);
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.c"
void fil_swriteU16(unsigned char *dest , unsigned short *src ) 
{ 


  {
#line 77
  *dest = *((unsigned char *)src);
#line 78
  *(dest + 1) = *((unsigned char *)src + 1);
#line 80
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.c"
void fil_swriteU32(unsigned char *dest , unsigned int *src ) 
{ 


  {
  {
#line 90
  fil_swriteU16(dest, (unsigned short *)src);
#line 91
  fil_swriteU16(dest + 2, (unsigned short *)((unsigned char *)src + 2));
  }
#line 93
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/support.c"
void __cole_dump(void *_m , void *_start , int length , char *msg ) 
{ 
  unsigned char *pm ;
  char buff[18] ;
  long achar ;
  unsigned char *m ;
  unsigned char *start ;
  int tmp ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int i ;

  {
#line 113
  if ((unsigned long )_m == (unsigned long )((void *)0)) {
    {
#line 114
    printf((char const   */* __restrict  */)"VERBOSE: can\'t dump because m is NULL\n");
    }
#line 115
    return;
  }
#line 117
  if ((unsigned long )_start == (unsigned long )((void *)0)) {
    {
#line 118
    printf((char const   */* __restrict  */)"VERBOSE: can\'t dump because start is NULL\n");
    }
#line 119
    return;
  }
#line 122
  m = (unsigned char *)_m;
#line 123
  start = (unsigned char *)_start;
#line 124
  buff[8] = (char )'-';
#line 125
  buff[17] = (char)0;
#line 126
  if ((unsigned long )msg != (unsigned long )((void *)0)) {
    {
#line 127
    printf((char const   */* __restrict  */)"VERBOSE: %s (from 0x%08tx length 0x%08x (%d)):\n",
           msg, m - start, length, length);
    }
  }
#line 129
  pm = m;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (pm - m < (long )length)) {
#line 129
      goto while_break;
    }
#line 130
    achar = (pm - m) % 16L;
#line 132
    if (achar == 0L) {
      {
#line 133
      printf((char const   */* __restrict  */)"%08tx  ", (pm - m) + (m - start));
      }
    }
#line 135
    if (achar < 8L) {
#line 135
      tmp = 0;
    } else {
#line 135
      tmp = 1;
    }
    {
#line 135
    tmp___2 = __ctype_b_loc();
    }
#line 135
    if ((int const   )*(*tmp___2 + (int )*pm) & 16384) {
#line 135
      tmp___1 = (int )*pm;
    } else {
#line 135
      tmp___1 = '.';
    }
#line 135
    buff[achar + (long )tmp] = (char )tmp___1;
#line 137
    if (! (((pm - m) + 1L) % 16L)) {
      {
#line 139
      printf((char const   */* __restrict  */)"%02x  %s\n", (int )*pm, buff);
      }
    } else
#line 140
    if (! (((pm - m) + 1L) % 8L)) {
      {
#line 141
      printf((char const   */* __restrict  */)"%02x-", (int )*pm);
      }
    } else {
      {
#line 143
      printf((char const   */* __restrict  */)"%02x ", (int )*pm);
      }
    }
#line 129
    pm ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  achar = (pm - m) % 16L;
#line 146
  if (achar) {
#line 148
    i = 0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! ((long )i < (16L - achar) * 3L - 1L)) {
#line 148
        goto while_break___0;
      }
      {
#line 149
      printf((char const   */* __restrict  */)" ");
#line 148
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 150
    if (achar != 8L) {
#line 151
      buff[achar] = (char)0;
    }
    {
#line 152
    printf((char const   */* __restrict  */)"  %s\n", buff);
    }
  }
#line 154
  return;
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 154 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.h"
int cole_print_tree(COLEFS *colefilesystem , COLERRNO *colerrno ) ;
#line 161
int cole_recurse_tree(COLEFS *colefilesystem , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                      COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                      COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                      COLERRNO *colerrno ) ;
#line 174
COLEFILE *cole_fopen(COLEFS *colefilesystem , char *filename___4 , COLERRNO *colerrno ) ;
#line 181
size_t cole_fsize(COLEFILE *colefile ) ;
#line 186
int cole_feof(COLEFILE *colefile ) ;
#line 187
size_t cole_ftell(COLEFILE *colefile ) ;
#line 188
int cole_fseek(COLEFILE *colefile , size_t delta , COLE_SEEK_FLAG direction , COLERRNO *colerrno ) ;
#line 192
int cole_frewind(COLEFILE *colefile , COLERRNO *colerrno ) ;
#line 198
COLEDIR *cole_opendir_rootdir(COLEFS *colefilesystem , COLERRNO *colerrno ) ;
#line 200
COLEDIR *cole_opendir_direntry(COLEDIRENT *coledirentry , COLERRNO *colerrno ) ;
#line 202
int cole_closedir(COLEDIR *coledir , COLERRNO *colerrno ) ;
#line 204
COLEDIRENT *cole_visiteddirentry(COLEDIR *coledir ) ;
#line 205
COLEDIRENT *cole_nextdirentry(COLEDIR *coledir ) ;
#line 206
char *cole_dir_getname(COLEDIR *coledir ) ;
#line 207
size_t cole_dir_getsize(COLEDIR *coledir ) ;
#line 208
long cole_dir_getdays1(COLEDIR *coledir ) ;
#line 209
long cole_dir_getsec1(COLEDIR *coledir ) ;
#line 210
long cole_dir_getdays2(COLEDIR *coledir ) ;
#line 211
long cole_dir_getsec2(COLEDIR *coledir ) ;
#line 212
char *cole_direntry_getname(COLEDIRENT *coledirentry ) ;
#line 213
size_t cole_direntry_getsize(COLEDIRENT *coledirentry ) ;
#line 214
long cole_direntry_getdays1(COLEDIRENT *coledirentry ) ;
#line 215
long cole_direntry_getsec1(COLEDIRENT *coledirentry ) ;
#line 216
long cole_direntry_getdays2(COLEDIRENT *coledirentry ) ;
#line 217
long cole_direntry_getsec2(COLEDIRENT *coledirentry ) ;
#line 218
int cole_direntry_isdir(COLEDIRENT *coledirentry ) ;
#line 219
int cole_direntry_isfile(COLEDIRENT *coledirentry ) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
void cole_perror(char const   *s , COLERRNO colerrno ) 
{ 


  {
#line 47
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            s);
    }
  }
  {
#line 55
  if ((unsigned int )colerrno == 9U) {
#line 55
    goto case_9;
  }
#line 55
  if ((unsigned int )colerrno == 8U) {
#line 55
    goto case_9;
  }
#line 55
  if ((unsigned int )colerrno == 7U) {
#line 55
    goto case_9;
  }
#line 55
  if ((unsigned int )colerrno == 6U) {
#line 55
    goto case_9;
  }
#line 55
  if ((unsigned int )colerrno == 5U) {
#line 55
    goto case_9;
  }
#line 55
  if ((unsigned int )colerrno == 3U) {
#line 55
    goto case_9;
  }
#line 55
  if ((unsigned int )colerrno == 1U) {
#line 55
    goto case_9;
  }
#line 58
  if ((unsigned int )colerrno == 2U) {
#line 58
    goto case_2;
  }
#line 62
  if ((unsigned int )colerrno == 10U) {
#line 62
    goto case_10;
  }
#line 65
  if ((unsigned int )colerrno == 11U) {
#line 65
    goto case_11;
  }
#line 68
  if ((unsigned int )colerrno == 12U) {
#line 68
    goto case_12;
  }
#line 71
  if ((unsigned int )colerrno == 13U) {
#line 71
    goto case_13;
  }
#line 74
  if ((unsigned int )colerrno == 14U) {
#line 74
    goto case_14;
  }
#line 77
  if ((unsigned int )colerrno == 15U) {
#line 77
    goto case_15;
  }
#line 80
  if ((unsigned int )colerrno == 16U) {
#line 80
    goto case_16;
  }
#line 84
  if ((unsigned int )colerrno == 17U) {
#line 84
    goto case_17;
  }
#line 87
  if ((unsigned int )colerrno == 18U) {
#line 87
    goto case_18;
  }
#line 90
  if ((unsigned int )colerrno == 19U) {
#line 90
    goto case_19;
  }
#line 93
  if ((unsigned int )colerrno == 20U) {
#line 93
    goto case_20;
  }
#line 96
  if ((unsigned int )colerrno == 4U) {
#line 96
    goto case_4;
  }
#line 99
  if ((unsigned int )colerrno == 21U) {
#line 99
    goto case_21;
  }
#line 102
  goto switch_default;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 56
  perror("cole");
  }
#line 57
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - Cannot open the file\n");
#line 60
  exit(1);
  }
#line 61
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The file is not a OLE2 file\n");
  }
#line 64
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The file has a short OLE2 header or it is not really an OLE2 file.\n");
  }
#line 67
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The OLE2 entry is not a substorage object\n");
  }
#line 70
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The substorage object is not valid\n");
  }
#line 73
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - OLE2 object not found\n");
  }
#line 76
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - End of stream object has been reached\n");
  }
#line 79
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The OLE2 object searched for is not a substorage object\n");
  }
#line 83
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - Illegal OLE object name\n");
  }
#line 86
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The OLE2 object is not a stream\n");
  }
#line 89
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 91
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The seek offset is an illegal value\n");
  }
#line 92
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - The Seek Flag is not valid\n");
  }
#line 95
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - Short read length returned...the file is probably corrupted\n");
  }
#line 98
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - An unknown error ocurred in the cole libary (might be a bug)\n");
  }
#line 101
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cole - An unknown error %d ocurred in the cole libabry (might be a bug)\n",
          (unsigned int )colerrno);
  }
#line 105
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEFS *cole_mount(char *filename___4 , COLERRNO *colerrno ) 
{ 
  COLEFS *ret ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 126
  tmp = malloc(sizeof(COLEFS ));
#line 126
  ret = (COLEFS *)tmp;
  }
#line 127
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 128
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 128
      *colerrno = (COLERRNO )1;
    }
#line 129
    return ((COLEFS *)((void *)0));
  }
  {
#line 132
  tmp___0 = __OLEdecode(filename___4, & ret->tree, & ret->root, & ret->BDepot, & ret->SDepot,
                        & ret->sbfile, & ret->sbfilename, & ret->file, (unsigned short)0);
  }
  {
#line 135
  if (tmp___0 == 0) {
#line 135
    goto case_0;
  }
#line 138
  if (tmp___0 == 10) {
#line 138
    goto case_10;
  }
#line 143
  if (tmp___0 == 4) {
#line 143
    goto case_4;
  }
#line 143
  if (tmp___0 == 7) {
#line 143
    goto case_4;
  }
#line 148
  if (tmp___0 == 9) {
#line 148
    goto case_9;
  }
#line 148
  if (tmp___0 == 8) {
#line 148
    goto case_9;
  }
#line 152
  if (tmp___0 == 5) {
#line 152
    goto case_5;
  }
#line 156
  goto switch_default;
  case_0: /* CIL Label */ 
#line 137
  goto switch_break;
  case_10: /* CIL Label */ 
#line 139
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 139
    *colerrno = (COLERRNO )1;
  }
  {
#line 140
  free((void *)ret);
  }
#line 141
  return ((COLEFS *)((void *)0));
  case_4: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 144
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 144
    *colerrno = (COLERRNO )2;
  }
  {
#line 145
  free((void *)ret);
  }
#line 146
  return ((COLEFS *)((void *)0));
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 149
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 149
    *colerrno = (COLERRNO )10;
  }
  {
#line 150
  free((void *)ret);
  }
#line 151
  return ((COLEFS *)((void *)0));
  case_5: /* CIL Label */ 
#line 153
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 153
    *colerrno = (COLERRNO )11;
  }
  {
#line 154
  free((void *)ret);
  }
#line 155
  return ((COLEFS *)((void *)0));
  switch_default: /* CIL Label */ 
#line 157
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 157
    *colerrno = (COLERRNO )21;
  }
  {
#line 158
  free((void *)ret);
  }
#line 159
  return ((COLEFS *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 162
  return (ret);
}
}
#line 175 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_umount(COLEFS *colefilesystem , COLERRNO *colerrno ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 180
  ret = 0;
#line 181
  free((void *)colefilesystem->BDepot);
#line 182
  free((void *)colefilesystem->tree);
#line 183
  tmp = fclose(colefilesystem->file);
  }
#line 183
  if (tmp) {
#line 183
    if (! ret) {
#line 184
      if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 184
        *colerrno = (COLERRNO )3;
      }
#line 185
      ret = 1;
    }
  }
#line 187
  if ((unsigned long )colefilesystem->SDepot != (unsigned long )((void *)0)) {
    {
#line 188
    free((void *)colefilesystem->SDepot);
#line 192
    tmp___0 = fclose(colefilesystem->sbfile);
    }
#line 192
    if (tmp___0) {
#line 192
      if (! ret) {
#line 193
        if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 193
          *colerrno = (COLERRNO )3;
        }
#line 194
        ret = 1;
      }
    }
    {
#line 202
    free((void *)colefilesystem->sbfilename);
    }
  }
  {
#line 204
  free((void *)colefilesystem);
  }
#line 206
  return (ret);
}
}
#line 221
static int __cole_print_tree_indir(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 222
static int __cole_print_tree_outdir(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 223
static int __cole_print_tree_inroot(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 224
static int __cole_print_tree_indirentry(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) ;
#line 226 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_print_tree(COLEFS *colefilesystem , COLERRNO *colerrno ) 
{ 
  long level ;
  int tmp ;

  {
  {
#line 230
  level = 1L;
#line 231
  tmp = cole_recurse_tree(colefilesystem, (void *)(& level), & __cole_print_tree_inroot,
                          & __cole_print_tree_indirentry, & __cole_print_tree_indir,
                          & __cole_print_tree_outdir, (COLE_RECURSE_VISIT_DIR_FUNC *)((void *)0),
                          colerrno);
  }
#line 231
  if (tmp) {
#line 236
    return (1);
  }
#line 239
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 250
  (*((long *)info)) ++;
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_outdir(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 262
  (*((long *)info)) --;
#line 263
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_inroot(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 276
  printf((char const   */* __restrict  */)"DIR ");
#line 277
  tmp = cole_dir_getsize(cd);
#line 277
  printf((char const   */* __restrict  */)" %7zu", tmp);
#line 278
  tmp___0 = cole_dir_getsec2(cd);
#line 278
  tmp___1 = cole_dir_getdays2(cd);
#line 278
  tmp___2 = cole_dir_getsec1(cd);
#line 278
  tmp___3 = cole_dir_getdays1(cd);
#line 278
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___3, tmp___2,
         tmp___1, tmp___0);
#line 283
  entry_name = cole_dir_getname(cd);
#line 284
  tmp___4 = __ctype_b_loc();
  }
#line 284
  if ((int const   )*(*tmp___4 + (int )*(entry_name + 0)) & 16384) {
    {
#line 287
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 285
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indirentry(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  long level ;
  long i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 304
  level = *((long *)info);
#line 305
  i = 0L;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < level)) {
#line 305
      goto while_break;
    }
#line 306
    if (i == level - 1L) {
      {
#line 307
      printf((char const   */* __restrict  */)"\\--");
      }
    } else {
      {
#line 309
      printf((char const   */* __restrict  */)"|  ");
      }
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  tmp___0 = cole_direntry_isdir(cde);
  }
#line 312
  if (tmp___0) {
    {
#line 313
    printf((char const   */* __restrict  */)"DIR ");
    }
  } else {
    {
#line 314
    tmp = cole_direntry_isfile(cde);
    }
#line 314
    if (tmp) {
      {
#line 315
      printf((char const   */* __restrict  */)"FILE");
      }
    } else {
      {
#line 317
      printf((char const   */* __restrict  */)"????");
      }
    }
  }
  {
#line 318
  tmp___1 = cole_direntry_getsize(cde);
#line 318
  printf((char const   */* __restrict  */)" %7zu", tmp___1);
#line 319
  tmp___2 = cole_direntry_getsec2(cde);
#line 319
  tmp___3 = cole_direntry_getdays2(cde);
#line 319
  tmp___4 = cole_direntry_getsec1(cde);
#line 319
  tmp___5 = cole_direntry_getdays1(cde);
#line 319
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___5, tmp___4,
         tmp___3, tmp___2);
#line 324
  entry_name = cole_direntry_getname(cde);
#line 325
  tmp___6 = __ctype_b_loc();
  }
#line 325
  if ((int const   )*(*tmp___6 + (int )*(entry_name + 0)) & 16384) {
    {
#line 328
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 326
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 330
  return (0);
}
}
#line 343 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEDIR *cole_opendir_rootdir(COLEFS *colefilesystem , COLERRNO *colerrno ) 
{ 
  COLEDIR *ret ;
  void *tmp ;

  {
  {
#line 348
  tmp = malloc(sizeof(COLEDIR ));
#line 348
  ret = (COLEDIR *)tmp;
  }
#line 349
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 350
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 350
      *colerrno = (COLERRNO )1;
    }
#line 351
    return ((COLEDIR *)((void *)0));
  }
#line 353
  ret->fs = colefilesystem;
#line 354
  ret->entry = (ret->fs)->root;
#line 355
  ret->visited_entry.dir = ret;
#line 356
  ret->visited_entry.entry = ((ret->fs)->tree + ret->entry)->dir;
#line 358
  return (ret);
}
}
#line 371 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEDIR *cole_opendir_direntry(COLEDIRENT *coledirentry , COLERRNO *colerrno ) 
{ 
  COLEDIR *ret ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 376
  tmp = cole_direntry_isdir(coledirentry);
  }
#line 376
  if (! tmp) {
#line 377
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 377
      *colerrno = (COLERRNO )12;
    }
#line 378
    return ((COLEDIR *)((void *)0));
  }
  {
#line 381
  tmp___0 = malloc(sizeof(COLEDIR ));
#line 381
  ret = (COLEDIR *)tmp___0;
  }
#line 382
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 383
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 383
      *colerrno = (COLERRNO )1;
    }
#line 384
    return ((COLEDIR *)((void *)0));
  }
#line 386
  ret->fs = (coledirentry->dir)->fs;
#line 387
  ret->entry = coledirentry->entry;
#line 388
  ret->visited_entry.dir = ret;
#line 389
  ret->visited_entry.entry = ((ret->fs)->tree + ret->entry)->dir;
#line 391
  return (ret);
}
}
#line 405 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_closedir(COLEDIR *coledir , COLERRNO *colerrno ) 
{ 


  {
  {
#line 408
  free((void *)coledir);
  }
#line 410
  return (0);
}
}
#line 414 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEDIRENT *cole_visiteddirentry(COLEDIR *coledir ) 
{ 


  {
#line 417
  if ((unsigned long )coledir->visited_entry.entry == 4294967295UL) {
#line 418
    return ((COLEDIRENT *)((void *)0));
  }
#line 420
  return (& coledir->visited_entry);
}
}
#line 424 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEDIRENT *cole_nextdirentry(COLEDIR *coledir ) 
{ 


  {
#line 427
  if ((unsigned long )coledir->visited_entry.entry == 4294967295UL) {
#line 428
    return ((COLEDIRENT *)((void *)0));
  }
#line 430
  coledir->visited_entry.entry = ((coledir->fs)->tree + coledir->visited_entry.entry)->next;
#line 433
  if ((unsigned long )coledir->visited_entry.entry == 4294967295UL) {
#line 434
    return ((COLEDIRENT *)((void *)0));
  }
#line 436
  return (& coledir->visited_entry);
}
}
#line 448 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_direntry_isdir(COLEDIRENT *coledirentry ) 
{ 


  {
#line 451
  return ((int )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->type == 1);
}
}
#line 464 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_direntry_isfile(COLEDIRENT *coledirentry ) 
{ 


  {
#line 467
  return ((int )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->type == 2);
}
}
#line 472 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
char *cole_direntry_getname(COLEDIRENT *coledirentry ) 
{ 


  {
#line 475
  return ((((coledirentry->dir)->fs)->tree + coledirentry->entry)->name);
}
}
#line 479 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
size_t cole_direntry_getsize(COLEDIRENT *coledirentry ) 
{ 


  {
#line 483
  return ((size_t )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->size);
}
}
#line 487 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_direntry_getsec1(COLEDIRENT *coledirentry ) 
{ 


  {
#line 491
  return ((long )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->seconds1);
}
}
#line 495 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_direntry_getsec2(COLEDIRENT *coledirentry ) 
{ 


  {
#line 499
  return ((long )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->seconds2);
}
}
#line 503 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_direntry_getdays1(COLEDIRENT *coledirentry ) 
{ 


  {
#line 507
  return ((long )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->days1);
}
}
#line 511 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_direntry_getdays2(COLEDIRENT *coledirentry ) 
{ 


  {
#line 515
  return ((long )(((coledirentry->dir)->fs)->tree + coledirentry->entry)->days2);
}
}
#line 519 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
char *cole_dir_getname(COLEDIR *coledir ) 
{ 


  {
#line 522
  return (((coledir->fs)->tree + coledir->entry)->name);
}
}
#line 526 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
size_t cole_dir_getsize(COLEDIR *coledir ) 
{ 


  {
#line 530
  return ((size_t )((coledir->fs)->tree + coledir->entry)->size);
}
}
#line 534 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_dir_getsec1(COLEDIR *coledir ) 
{ 


  {
#line 538
  return ((long )((coledir->fs)->tree + coledir->entry)->seconds1);
}
}
#line 542 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_dir_getsec2(COLEDIR *coledir ) 
{ 


  {
#line 546
  return ((long )((coledir->fs)->tree + coledir->entry)->seconds2);
}
}
#line 550 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_dir_getdays1(COLEDIR *coledir ) 
{ 


  {
#line 554
  return ((long )((coledir->fs)->tree + coledir->entry)->days1);
}
}
#line 558 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
long cole_dir_getdays2(COLEDIR *coledir ) 
{ 


  {
#line 562
  return ((long )((coledir->fs)->tree + coledir->entry)->days2);
}
}
#line 585
static void _cole_fopen_action(COLEDIRENT *cde , void *_info ) ;
#line 586 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEFILE *cole_fopen(COLEFS *colefilesystem , char *filename___4 , COLERRNO *colerrno ) 
{ 
  struct _cole_fopen_info info ;
  int tmp ;

  {
  {
#line 591
  tmp = cole_locate_filename(colefilesystem, filename___4, (void *)(& info), & _cole_fopen_action,
                             colerrno);
  }
#line 591
  if (tmp) {
#line 595
    return ((COLEFILE *)((void *)0));
  }
#line 598
  if (info.succ) {
#line 599
    return (info.file);
  }
#line 601
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 601
    *colerrno = info.colerrno;
  }
#line 602
  return ((COLEFILE *)((void *)0));
}
}
#line 605 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static void _cole_fopen_action(COLEDIRENT *cde , void *_info ) 
{ 
  struct _cole_fopen_info *info ;
  int tmp ;

  {
  {
#line 610
  info = (struct _cole_fopen_info *)_info;
#line 612
  tmp = cole_direntry_isfile(cde);
  }
#line 612
  if (! tmp) {
#line 613
    info->colerrno = (COLERRNO )18;
#line 614
    info->succ = 0;
#line 615
    return;
  }
  {
#line 618
  info->file = cole_fopen_direntry(cde, & info->colerrno);
  }
#line 619
  if ((unsigned long )info->file == (unsigned long )((void *)0)) {
#line 621
    info->succ = 0;
#line 622
    return;
  }
#line 625
  info->succ = 1;
#line 626
  return;
}
}
#line 640 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
COLEFILE *cole_fopen_direntry(COLEDIRENT *coledirentry , COLERRNO *colerrno ) 
{ 
  COLEFILE *ret ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 645
  tmp = cole_direntry_isfile(coledirentry);
  }
#line 645
  if (! tmp) {
#line 646
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 646
      *colerrno = (COLERRNO )13;
    }
#line 647
    return ((COLEFILE *)((void *)0));
  }
  {
#line 650
  tmp___0 = malloc(sizeof(COLEFILE ));
#line 650
  ret = (COLEFILE *)tmp___0;
  }
#line 651
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 652
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 652
      *colerrno = (COLERRNO )1;
    }
#line 653
    return ((COLEFILE *)((void *)0));
  }
  {
#line 655
  ret->fs = (coledirentry->dir)->fs;
#line 656
  ret->entry = coledirentry->entry;
#line 657
  tmp___1 = __cole_extract_file(& ret->file, & ret->filename, ((ret->fs)->tree + ret->entry)->size,
                                ((ret->fs)->tree + ret->entry)->start, (ret->fs)->BDepot,
                                (ret->fs)->SDepot, (ret->fs)->sbfile, (ret->fs)->file);
  }
  {
#line 662
  if (tmp___1 == 0) {
#line 662
    goto case_0;
  }
#line 665
  if (tmp___1 == 1) {
#line 665
    goto case_1;
  }
#line 669
  if (tmp___1 == 2) {
#line 669
    goto case_2;
  }
#line 673
  if (tmp___1 == 3) {
#line 673
    goto case_3;
  }
#line 677
  if (tmp___1 == 4) {
#line 677
    goto case_4;
  }
#line 681
  if (tmp___1 == 5) {
#line 681
    goto case_5;
  }
#line 685
  if (tmp___1 == 6) {
#line 685
    goto case_6;
  }
#line 689
  goto switch_default;
  case_0: /* CIL Label */ 
#line 664
  goto switch_break;
  case_1: /* CIL Label */ 
#line 666
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 666
    *colerrno = (COLERRNO )1;
  }
  {
#line 667
  free((void *)ret);
  }
#line 668
  return ((COLEFILE *)((void *)0));
  case_2: /* CIL Label */ 
#line 670
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 670
    *colerrno = (COLERRNO )7;
  }
  {
#line 671
  free((void *)ret);
  }
#line 672
  return ((COLEFILE *)((void *)0));
  case_3: /* CIL Label */ 
#line 674
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 674
    *colerrno = (COLERRNO )2;
  }
  {
#line 675
  free((void *)ret);
  }
#line 676
  return ((COLEFILE *)((void *)0));
  case_4: /* CIL Label */ 
#line 678
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 678
    *colerrno = (COLERRNO )11;
  }
  {
#line 679
  free((void *)ret);
  }
#line 680
  return ((COLEFILE *)((void *)0));
  case_5: /* CIL Label */ 
#line 682
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 682
    *colerrno = (COLERRNO )4;
  }
  {
#line 683
  free((void *)ret);
  }
#line 684
  return ((COLEFILE *)((void *)0));
  case_6: /* CIL Label */ 
#line 686
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 686
    *colerrno = (COLERRNO )5;
  }
  {
#line 687
  free((void *)ret);
  }
#line 688
  return ((COLEFILE *)((void *)0));
  switch_default: /* CIL Label */ 
#line 690
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 690
    *colerrno = (COLERRNO )21;
  }
  {
#line 691
  free((void *)ret);
  }
#line 692
  return ((COLEFILE *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 696
  rewind(ret->file);
#line 697
  ret->pos = 0U;
#line 698
  ret->filesize = ((ret->fs)->tree + ret->entry)->size;
  }
#line 700
  return (ret);
}
}
#line 713 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_fclose(COLEFILE *colefile , COLERRNO *colerrno ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 718
  ret = 0;
#line 719
  tmp = fclose(colefile->file);
  }
#line 719
  if (tmp) {
#line 719
    if (! ret) {
#line 720
      if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 720
        *colerrno = (COLERRNO )3;
      }
#line 721
      ret = 1;
    }
  }
  {
#line 723
  tmp___0 = remove((char const   *)colefile->filename);
  }
#line 723
  if (tmp___0) {
#line 723
    if (! ret) {
#line 724
      if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 724
        *colerrno = (COLERRNO )6;
      }
#line 725
      ret = 1;
    }
  }
  {
#line 727
  free((void *)colefile->filename);
#line 728
  free((void *)colefile);
  }
#line 730
  return (ret);
}
}
#line 747 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
size_t cole_fread(COLEFILE *colefile , void *ptr , size_t size , COLERRNO *colerrno ) 
{ 
  size_t bytes_read ;
  size_t bytes_to_read ;
  long tbytes ;
  int tmp ;
  int tmp___0 ;

  {
#line 754
  if ((size_t )colefile->pos + size > (size_t )colefile->filesize) {
#line 755
    tbytes = (long )(colefile->filesize - colefile->pos);
  } else {
#line 757
    tbytes = (long )size;
  }
#line 758
  if (tbytes <= 0L) {
#line 759
    return ((size_t )0);
  }
  {
#line 760
  bytes_to_read = (size_t )tbytes;
#line 761
  bytes_read = fread((void */* __restrict  */)ptr, (size_t )1, bytes_to_read, (FILE */* __restrict  */)colefile->file);
#line 763
  colefile->pos = (unsigned int )((size_t )colefile->pos + bytes_read);
  }
#line 766
  if (bytes_read != size) {
    {
#line 770
    tmp___0 = feof(colefile->file);
    }
#line 770
    if (tmp___0) {
#line 771
      if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 771
        *colerrno = (COLERRNO )15;
      }
#line 772
      return ((size_t )0);
    } else {
      {
#line 773
      tmp = ferror(colefile->file);
      }
#line 773
      if (tmp) {
#line 774
        if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 774
          *colerrno = (COLERRNO )4;
        }
#line 775
        return ((size_t )0);
      }
    }
  }
#line 781
  return (bytes_read);
}
}
#line 794 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
size_t cole_ftell(COLEFILE *colefile ) 
{ 


  {
#line 797
  return ((size_t )colefile->pos);
}
}
#line 819 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_fseek(COLEFILE *colefile , size_t delta , COLE_SEEK_FLAG direction , COLERRNO *colerrno ) 
{ 


  {
#line 823
  if ((int )delta < 0) {
#line 824
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 824
      *colerrno = (COLERRNO )19;
    }
#line 825
    return (1);
  }
  {
#line 829
  if ((unsigned int )direction == 0U) {
#line 829
    goto case_0;
  }
#line 837
  if ((unsigned int )direction == 3U) {
#line 837
    goto case_3;
  }
#line 845
  if ((unsigned int )direction == 2U) {
#line 845
    goto case_2;
  }
#line 853
  if ((unsigned int )direction == 1U) {
#line 853
    goto case_1;
  }
#line 861
  goto switch_default;
  case_0: /* CIL Label */ 
#line 830
  if (delta <= (size_t )colefile->filesize) {
#line 831
    colefile->pos = (unsigned int )delta;
#line 832
    return (0);
  } else {
#line 834
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 834
      *colerrno = (COLERRNO )19;
    }
#line 835
    return (1);
  }
  case_3: /* CIL Label */ 
#line 838
  if (delta <= (size_t )colefile->filesize) {
#line 839
    colefile->pos = (unsigned int )((size_t )colefile->filesize - delta);
#line 840
    return (0);
  } else {
#line 842
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 842
      *colerrno = (COLERRNO )19;
    }
#line 843
    return (1);
  }
  case_2: /* CIL Label */ 
#line 846
  if (delta <= (size_t )colefile->pos) {
#line 847
    colefile->pos = (unsigned int )((size_t )colefile->pos - delta);
#line 848
    return (0);
  } else {
#line 850
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 850
      *colerrno = (COLERRNO )19;
    }
#line 851
    return (1);
  }
  case_1: /* CIL Label */ 
#line 854
  if (delta <= (size_t )(colefile->filesize - colefile->pos)) {
#line 855
    colefile->pos = (unsigned int )((size_t )colefile->pos + delta);
#line 856
    return (0);
  } else {
#line 858
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 858
      *colerrno = (COLERRNO )19;
    }
#line 859
    return (1);
  }
  switch_default: /* CIL Label */ 
#line 862
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 862
    *colerrno = (COLERRNO )20;
  }
#line 863
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 878 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_frewind(COLEFILE *colefile , COLERRNO *colerrno ) 
{ 
  int tmp ;

  {
  {
#line 881
  tmp = cole_fseek(colefile, (size_t )0, (COLE_SEEK_FLAG )0, colerrno);
  }
#line 881
  if (tmp) {
#line 882
    return (1);
  }
#line 884
  return (0);
}
}
#line 894 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
size_t cole_fsize(COLEFILE *colefile ) 
{ 


  {
#line 897
  return ((size_t )colefile->filesize);
}
}
#line 909 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_feof(COLEFILE *colefile ) 
{ 


  {
#line 914
  return (colefile->pos == colefile->filesize);
}
}
#line 948
static int __cole_recurse_tree(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                               COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                               COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                               COLERRNO *colerrno ) ;
#line 956 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_recurse_tree(COLEFS *colefilesystem , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                      COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                      COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                      COLERRNO *colerrno ) 
{ 
  COLEDIR *cd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 967
  cd = cole_opendir_rootdir(colefilesystem, colerrno);
  }
#line 968
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 969
    return (1);
  }
  {
#line 971
  tmp = __cole_recurse_tree(cd, 1L, info, inroot, indirentry, indir, outdir, visitdir,
                            colerrno);
  }
#line 971
  if (tmp) {
    {
#line 973
    cole_closedir(cd, (COLERRNO *)((void *)0));
    }
#line 975
    return (1);
  }
  {
#line 978
  tmp___0 = cole_closedir(cd, colerrno);
  }
#line 978
  if (tmp___0) {
#line 980
    return (1);
  }
#line 983
  return (0);
}
}
#line 986 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_recurse_tree(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                               COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                               COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                               COLERRNO *colerrno ) 
{ 
  COLEDIRENT *cde ;
  COLEDIR *cd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1007
  if (level == 1L) {
#line 1009
    if ((unsigned long )inroot != (unsigned long )((void *)0)) {
      {
#line 1010
      tmp = (*inroot)(_cd, info, colerrno);
      }
#line 1010
      if (tmp) {
#line 1012
        return (1);
      }
    }
  }
  {
#line 1018
  cde = cole_visiteddirentry(_cd);
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned long )cde != (unsigned long )((void *)0))) {
#line 1018
      goto while_break;
    }
#line 1020
    if ((unsigned long )indirentry != (unsigned long )((void *)0)) {
      {
#line 1021
      tmp___0 = (*indirentry)(cde, info, colerrno);
      }
#line 1021
      if (tmp___0) {
#line 1023
        return (1);
      }
    }
    {
#line 1028
    tmp___6 = cole_direntry_isdir(cde);
    }
#line 1028
    if (tmp___6) {
      {
#line 1029
      cd = cole_opendir_direntry(cde, colerrno);
      }
#line 1030
      if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 1032
        return (1);
      }
#line 1035
      if ((unsigned long )indir != (unsigned long )((void *)0)) {
        {
#line 1036
        tmp___1 = (*indir)(cd, info, colerrno);
        }
#line 1036
        if (tmp___1) {
          {
#line 1038
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1039
          return (1);
        }
      }
#line 1043
      if ((unsigned long )visitdir == (unsigned long )((void *)0)) {
#line 1043
        goto _L;
      } else {
        {
#line 1043
        tmp___3 = (*visitdir)(cd, info);
        }
#line 1043
        if (tmp___3) {
          _L: /* CIL Label */ 
          {
#line 1045
          tmp___2 = __cole_recurse_tree(cd, level + 1L, info, inroot, indirentry,
                                        indir, outdir, visitdir, colerrno);
          }
#line 1045
          if (tmp___2) {
            {
#line 1050
            cole_closedir(cd, (COLERRNO *)((void *)0));
            }
#line 1051
            return (1);
          }
        }
      }
#line 1055
      if ((unsigned long )outdir != (unsigned long )((void *)0)) {
        {
#line 1056
        tmp___4 = (*outdir)(cd, info, colerrno);
        }
#line 1056
        if (tmp___4) {
          {
#line 1058
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1059
          return (1);
        }
      }
      {
#line 1063
      tmp___5 = cole_closedir(cd, colerrno);
      }
#line 1063
      if (tmp___5) {
#line 1065
        return (1);
      }
    }
    {
#line 1018
    cde = cole_nextdirentry(_cd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return (0);
}
}
#line 1098
static int __cole_locate_filename_indirentry(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) ;
#line 1099
static int __cole_locate_filename_visitdir(COLEDIR *cd , void *info ) ;
#line 1100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
int cole_locate_filename(COLEFS *colefilesystem , char *filename___4 , void *info ,
                         COLE_LOCATE_ACTION_FUNC *action , COLERRNO *colerrno ) 
{ 
  struct __cole_locate_filenameinfo _info ;
  COLERRNO _colerrno ;
  int tmp ;

  {
#line 1110
  if ((int )*(filename___4 + 0) != 47) {
#line 1111
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1111
      *colerrno = (COLERRNO )17;
    }
#line 1112
    return (1);
  }
  {
#line 1115
  _info.action = action;
#line 1116
  _info.info = info;
#line 1117
  _info.filename = filename___4;
#line 1118
  _info.current = filename___4 + 1;
#line 1120
  tmp = cole_recurse_tree(colefilesystem, (void *)(& _info), (COLE_RECURSE_DIR_FUNC *)((void *)0),
                          & __cole_locate_filename_indirentry, (COLE_RECURSE_DIR_FUNC *)((void *)0),
                          (COLE_RECURSE_DIR_FUNC *)((void *)0), & __cole_locate_filename_visitdir,
                          & _colerrno);
  }
#line 1120
  if (tmp) {
#line 1124
    if ((unsigned int )_colerrno == 23U) {
#line 1126
      return (0);
    }
#line 1128
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1128
      *colerrno = _colerrno;
    }
#line 1129
    return (1);
  }
#line 1132
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1132
    *colerrno = (COLERRNO )14;
  }
#line 1133
  return (1);
}
}
#line 1136 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_visitdir(COLEDIR *cd , void *info ) 
{ 


  {
#line 1139
  return (((struct __cole_locate_filenameinfo *)info)->visitdir);
}
}
#line 1142 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_indirentry(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  struct __cole_locate_filenameinfo *info ;
  char *pcurrent ;
  char *pentry_name ;
  int tmp ;

  {
  {
#line 1151
  info = (struct __cole_locate_filenameinfo *)_info;
#line 1152
  entry_name = cole_direntry_getname(cde);
#line 1153
  pcurrent = info->current;
#line 1153
  pentry_name = entry_name;
  }
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (*pcurrent) {
#line 1153
      if (*pentry_name) {
#line 1153
        if (! ((int )*pcurrent != 47)) {
#line 1153
          goto while_break;
        }
      } else {
#line 1153
        goto while_break;
      }
    } else {
#line 1153
      goto while_break;
    }
#line 1156
    if ((int )*pcurrent != (int )*pentry_name) {
#line 1157
      info->visitdir = 0;
#line 1158
      return (0);
    }
#line 1153
    pcurrent ++;
#line 1153
    pentry_name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1162
  if ((int )*pentry_name == 0) {
#line 1162
    goto case_0;
  }
#line 1197
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 1164
  if ((int )*pcurrent == 47) {
#line 1164
    goto case_47;
  }
#line 1185
  if ((int )*pcurrent == 0) {
#line 1185
    goto case_0___0;
  }
#line 1193
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 1165
  tmp = cole_direntry_isdir(cde);
  }
#line 1165
  if (! tmp) {
#line 1166
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1167
      *colerrno = (COLERRNO )16;
    }
#line 1168
    return (1);
  }
#line 1170
  pcurrent ++;
#line 1171
  info->current = pcurrent;
#line 1174
  if (! *(info->current)) {
#line 1176
    if ((unsigned long )info->action != (unsigned long )((void *)0)) {
      {
#line 1177
      (*(info->action))(cde, info->info);
      }
    }
#line 1180
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1180
      *colerrno = (COLERRNO )23;
    }
#line 1181
    return (1);
  }
#line 1183
  info->visitdir = 1;
#line 1184
  return (0);
  case_0___0: /* CIL Label */ 
#line 1187
  if ((unsigned long )info->action != (unsigned long )((void *)0)) {
    {
#line 1188
    (*(info->action))(cde, info->info);
    }
  }
#line 1191
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1191
    *colerrno = (COLERRNO )23;
  }
#line 1192
  return (1);
  switch_default: /* CIL Label */ 
#line 1194
  info->visitdir = 0;
#line 1195
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 1199
  if ((int )*pcurrent == 0) {
#line 1199
    goto case_0___1;
  }
#line 1202
  if ((int )*pcurrent == 47) {
#line 1202
    goto case_47___0;
  }
#line 1205
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 1200
  info->visitdir = 0;
#line 1201
  return (0);
  case_47___0: /* CIL Label */ 
#line 1203
  info->visitdir = 0;
#line 1204
  return (0);
  switch_default___1: /* CIL Label */ 
#line 1206
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1206
    *colerrno = (COLERRNO )21;
  }
#line 1207
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/version.c"
int cole_major_version  =    2;
#line 3 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/version.c"
int cole_minor_version  =    0;
#line 4 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/version.c"
int cole_micro_version  =    2;
#line 5 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/version.c"
char *cole_version  =    (char *)"2.0.2";
#line 6 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/version.c"
char *cole_host_info  =    (char *)"x86_64-unknown-linux-gnu (x86_64-unknown-linux-gnu): x86_64, unknown, linux-gnu";
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE Input___0  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *sbfile___1  ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *SDepot___1  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *BDepot___1  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *bbd_list___0  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *Root___1  ;
#line 79 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int header_blocks___0  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int big_streams_blocks___0  ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_blocks___0  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_blocks___0  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_blocks___0  ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_blocks___0  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_start_block___0  ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_start_block___0  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_start_block___0  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_start_block___0  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static FILE *output_file___0  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned char output_block___0[512]  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned short pos_block___0  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int next_block___0  ;
#line 105
static int process_Root___0(pps_entry *pps_list___4 , unsigned int root ) ;
#line 106
static unsigned int max_pps_referenced___0(pps_entry *pps_list___4 , unsigned int node ) ;
#line 107
static unsigned int max3___0(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) ;
#line 108
static int process_streams___0(pps_entry *pps_list___4 , pps_entry *node ) ;
#line 109
static int add_stream_to_sbfile_and_SDepot___0(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 110
static int add_stream_to_Input_and_BDepot___0(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 111
static int add_entry_to_Root___0(pps_entry *node , unsigned int start_block ) ;
#line 112
static unsigned int add_MY_FILE_entry___0(MY_FILE *list , unsigned int size ) ;
#line 113
static int pps2root___0(unsigned char *pps , pps_entry *node , unsigned int start_block ) ;
#line 114
static void reset_links_in_Input___0(void) ;
#line 115
static void reset_links_in_BDepot___0(void) ;
#line 116
static void reset_links_in_SDepot___0(void) ;
#line 118
static int generate_ole2_file___0(char const   *filename___4 , int trunc ) ;
#line 119
static int generate_header___0(void) ;
#line 120
static int generate_recursive___0(MY_FILE *list ) ;
#line 121
static int generate_SDepot___0(void) ;
#line 122
static int generate_Root___0(void) ;
#line 123
static int generate_BDepot___0(void) ;
#line 124
static int generate_real_file___0(MY_FILE *MY_FILE_file ) ;
#line 125
static int write_block_list___0(unsigned int start_count , MY_FILE *list , int write_end_chain ) ;
#line 126
static int write_root_list___0(MY_FILE *list ) ;
#line 127
static void calculate_blocks___0(void) ;
#line 129
static unsigned int sum_block_list___0(MY_FILE *list ) ;
#line 132
static unsigned int sum_blocks_MY_FILE_list___0(MY_FILE *list ) ;
#line 134
static void ends___1(void) ;
#line 285 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_Root___0(pps_entry *pps_list___4 , unsigned int root ) 
{ 
  unsigned int pps_list_entries ;
  unsigned int i ;
  unsigned int tmp ;
  int retval ;

  {
  {
#line 293
  tmp = max_pps_referenced___0(pps_list___4, root);
#line 293
  pps_list_entries = 1U + tmp;
#line 296
  i = 0U;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < pps_list_entries)) {
#line 296
      goto while_break;
    }
    {
#line 297
    retval = add_entry_to_Root___0(pps_list___4 + i, 0U);
    }
#line 297
    if (retval) {
#line 297
      return (retval);
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max3___0(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) 
{ 
  unsigned int m ;

  {
#line 319
  m = 0U;
#line 323
  if (m > a) {
#line 323
    m = m;
  } else {
#line 323
    m = a;
  }
#line 324
  if (m > b) {
#line 324
    m = m;
  } else {
#line 324
    m = b;
  }
#line 325
  if (m > c) {
#line 325
    m = m;
  } else {
#line 325
    m = c;
  }
#line 326
  if (m > d) {
#line 326
    m = m;
  } else {
#line 326
    m = d;
  }
#line 327
  return (m);
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max_pps_referenced___0(pps_entry *pps_list___4 , unsigned int node ) 
{ 
  unsigned int max_pps ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 337
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
#line 337
    tmp = (pps_list___4 + node)->dir;
  } else {
#line 337
    tmp = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
#line 337
    tmp___0 = (pps_list___4 + node)->next;
  } else {
#line 337
    tmp___0 = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
#line 337
    tmp___1 = (pps_list___4 + node)->previous;
  } else {
#line 337
    tmp___1 = 0U;
  }
  {
#line 337
  max_pps = max3___0(node, tmp___1, tmp___0, tmp);
  }
#line 342
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
    {
#line 343
    tmp___4 = max_pps_referenced___0(pps_list___4, (pps_list___4 + node)->previous);
    }
#line 343
    if (max_pps > tmp___4) {
#line 343
      max_pps = max_pps;
    } else {
      {
#line 343
      tmp___3 = max_pps_referenced___0(pps_list___4, (pps_list___4 + node)->previous);
#line 343
      max_pps = tmp___3;
      }
    }
  }
#line 345
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
    {
#line 346
    tmp___7 = max_pps_referenced___0(pps_list___4, (pps_list___4 + node)->next);
    }
#line 346
    if (max_pps > tmp___7) {
#line 346
      max_pps = max_pps;
    } else {
      {
#line 346
      tmp___6 = max_pps_referenced___0(pps_list___4, (pps_list___4 + node)->next);
#line 346
      max_pps = tmp___6;
      }
    }
  }
#line 348
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
    {
#line 349
    tmp___10 = max_pps_referenced___0(pps_list___4, (pps_list___4 + node)->dir);
    }
#line 349
    if (max_pps > tmp___10) {
#line 349
      max_pps = max_pps;
    } else {
      {
#line 349
      tmp___9 = max_pps_referenced___0(pps_list___4, (pps_list___4 + node)->dir);
#line 349
      max_pps = tmp___9;
      }
    }
  }
#line 352
  return (max_pps);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_streams___0(pps_entry *pps_list___4 , pps_entry *node ) 
{ 
  unsigned int U32end_chain ;
  int retval ;
  int retval___0 ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;
  int retval___4 ;
  int retval___5 ;

  {
#line 359
  U32end_chain = 4294967294U;
#line 363
  if (! node->name[0]) {
#line 363
    return (12);
  }
  {
#line 366
  if ((int )node->type == 1) {
#line 366
    goto case_1;
  }
#line 374
  if ((int )node->type == 5) {
#line 374
    goto case_5;
  }
#line 385
  if ((int )node->type == 2) {
#line 385
    goto case_2;
  }
#line 399
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 368
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 369
    retval = process_streams___0(pps_list___4, pps_list___4 + node->dir);
    }
#line 369
    if (retval) {
#line 369
      return (retval);
    }
  }
#line 370
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 371
    retval___0 = process_streams___0(pps_list___4, pps_list___4 + node->next);
    }
#line 371
    if (retval___0) {
#line 371
      return (retval___0);
    }
  }
#line 372
  goto switch_break;
  case_5: /* CIL Label */ 
#line 375
  if (! ((int )*(Root___1->file.root_list + 66) == 5)) {
    {
#line 375
    __assert_fail("*(Root->file.root_list + 0x42) == 5", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  375U, "process_streams");
    }
  }
  {
#line 378
  fil_swriteU32(Root___1->file.root_list + 116, & U32end_chain);
  }
#line 379
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 380
    retval___1 = process_streams___0(pps_list___4, pps_list___4 + node->dir);
    }
#line 380
    if (retval___1) {
#line 380
      return (retval___1);
    }
  }
#line 381
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 382
    retval___2 = process_streams___0(pps_list___4, pps_list___4 + node->next);
    }
#line 382
    if (retval___2) {
#line 382
      return (retval___2);
    }
  }
#line 383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 386
  if (! ((unsigned long )node->dir == 4294967295UL)) {
#line 386
    return (12);
  }
#line 387
  if (node->size < 4096U) {
    {
#line 389
    retval___3 = add_stream_to_sbfile_and_SDepot___0(node->size, node->filename, node->ppsnumber);
    }
#line 389
    if (retval___3) {
#line 389
      return (retval___3);
    }
  } else {
    {
#line 393
    retval___4 = add_stream_to_Input_and_BDepot___0(node->size, node->filename, node->ppsnumber);
    }
#line 393
    if (retval___4) {
#line 393
      return (retval___4);
    }
  }
#line 395
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 396
    retval___5 = process_streams___0(pps_list___4, pps_list___4 + node->next);
    }
#line 396
    if (retval___5) {
#line 396
      return (retval___5);
    }
  }
#line 397
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 400
  return (12);
  switch_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_entry_to_Root___0(pps_entry *node , unsigned int start_block ) 
{ 
  unsigned int entry_number ;
  unsigned char *new_entry_Root ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 416
  entry_number = add_MY_FILE_entry___0(Root___1, 0U);
  }
#line 417
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 417
    return (10);
  }
  {
#line 418
  new_entry_Root = Root___1->file.root_list + entry_number * 128U;
#line 421
  pps2root___0((unsigned char *)new_entry_Root, node, start_block);
  }
#line 424
  if (! Root___1->size) {
#line 424
    *(Root___1->blocks) = 1U;
  } else {
#line 424
    *(Root___1->blocks) = 1U + (Root___1->size - 1U) / 512U;
  }
  {
#line 428
  tmp___1 = sum_block_list___0(BDepot___1);
  }
#line 428
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 428
    tmp___0 = sum_block_list___0(BDepot___1);
#line 428
    *(BDepot___1->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 428
    *(BDepot___1->blocks) = 1U;
  }
#line 430
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_sbfile_and_SDepot___0(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  unsigned int *new_entry_SDepot ;
  MY_FILE *new_entry_sbfile ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 447
  entry_number = add_MY_FILE_entry___0(SDepot___1, size);
  }
#line 448
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 448
    return (10);
  }
  {
#line 449
  new_entry_SDepot = SDepot___1->file.block_list + entry_number;
#line 451
  entry_number = add_MY_FILE_entry___0(sbfile___1, size);
  }
#line 452
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 452
    return (10);
  }
#line 453
  new_entry_sbfile = sbfile___1->file.MY_FILE_list + entry_number;
#line 458
  if (! size) {
#line 458
    *new_entry_SDepot = 1U;
  } else {
#line 458
    *new_entry_SDepot = 1U + (size - 1U) / 64U;
  }
  {
#line 461
  tmp___1 = sum_block_list___0(SDepot___1);
  }
#line 461
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 461
    tmp___0 = sum_block_list___0(SDepot___1);
#line 461
    *(SDepot___1->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 461
    *(SDepot___1->blocks) = 1U;
  }
  {
#line 468
  new_entry_sbfile->type = (enum __anonenum_type_26 )0;
#line 468
  new_entry_sbfile->size = size;
#line 468
  new_entry_sbfile->blocks = new_entry_SDepot;
#line 468
  new_entry_sbfile->file.real.name = name;
#line 468
  new_entry_sbfile->file.real.ppsnumber = ppsnumber;
#line 472
  tmp___4 = sum_blocks_MY_FILE_list___0(sbfile___1);
  }
#line 472
  if (tmp___4 * 64U) {
    {
#line 472
    tmp___3 = sum_blocks_MY_FILE_list___0(sbfile___1);
#line 472
    *(sbfile___1->blocks) = 1U + (tmp___3 * 64U - 1U) / 512U;
    }
  } else {
#line 472
    *(sbfile___1->blocks) = 1U;
  }
  {
#line 477
  tmp___7 = sum_block_list___0(BDepot___1);
  }
#line 477
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 477
    tmp___6 = sum_block_list___0(BDepot___1);
#line 477
    *(BDepot___1->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___6 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 477
    *(BDepot___1->blocks) = 1U;
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_Input_and_BDepot___0(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  MY_FILE *new_entry_Input ;
  unsigned int *new_entry_BDepot ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 496
  entry_number = add_MY_FILE_entry___0(BDepot___1, size);
  }
#line 497
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 497
    return (10);
  }
  {
#line 498
  new_entry_BDepot = BDepot___1->file.block_list + entry_number;
#line 500
  entry_number = add_MY_FILE_entry___0(& Input___0, size);
  }
#line 501
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 501
    return (10);
  }
#line 502
  new_entry_Input = Input___0.file.MY_FILE_list + entry_number;
#line 507
  if (! size) {
#line 507
    *new_entry_BDepot = 1U;
  } else {
#line 507
    *new_entry_BDepot = 1U + (size - 1U) / 512U;
  }
  {
#line 510
  tmp___1 = sum_block_list___0(BDepot___1);
  }
#line 510
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 510
    tmp___0 = sum_block_list___0(BDepot___1);
#line 510
    *(BDepot___1->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 510
    *(BDepot___1->blocks) = 1U;
  }
  {
#line 517
  new_entry_Input->type = (enum __anonenum_type_26 )0;
#line 517
  new_entry_Input->size = size;
#line 517
  new_entry_Input->blocks = new_entry_BDepot;
#line 517
  new_entry_Input->file.real.name = name;
#line 517
  new_entry_Input->file.real.ppsnumber = ppsnumber;
#line 524
  tmp___4 = sum_block_list___0(BDepot___1);
  }
#line 524
  if ((unsigned long )tmp___4 * sizeof(unsigned int )) {
    {
#line 524
    tmp___3 = sum_block_list___0(BDepot___1);
#line 524
    *(BDepot___1->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___3 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 524
    *(BDepot___1->blocks) = 1U;
  }
#line 526
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int add_MY_FILE_entry___0(MY_FILE *list , unsigned int size ) 
{ 
  MY_FILE *new_MY_FILE_list ;
  unsigned int new_entry ;
  void *tmp ;
  unsigned int *new_block_list ;
  unsigned int new_entry___0 ;
  void *tmp___0 ;
  unsigned int new_entry___1 ;
  unsigned char *new_root_list ;
  void *tmp___1 ;

  {
#line 574
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 574
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  574U, "add_MY_FILE_entry");
    }
  }
  {
#line 581
  if ((unsigned int )list->type == 1U) {
#line 581
    goto case_1;
  }
#line 599
  if ((unsigned int )list->type == 2U) {
#line 599
    goto case_2;
  }
#line 616
  if ((unsigned int )list->type == 3U) {
#line 616
    goto case_3;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 585
  if (! ((unsigned long )list == (unsigned long )sbfile___1)) {
#line 585
    if (! ((unsigned long )list == (unsigned long )(& Input___0))) {
      {
#line 585
      __assert_fail("list == sbfile || list == &Input", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    585U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 587
  list->size = (unsigned int )((unsigned long )list->size + sizeof(MY_FILE ));
#line 588
  tmp = realloc((void *)list->file.MY_FILE_list, (size_t )list->size);
#line 588
  new_MY_FILE_list = (MY_FILE *)tmp;
#line 589
  list->file.MY_FILE_list = new_MY_FILE_list;
  }
#line 590
  if (! ((unsigned long )new_MY_FILE_list != (unsigned long )((void *)0))) {
#line 590
    return (4294967295U);
  }
  {
#line 591
  new_entry = (unsigned int )((unsigned long )list->size / sizeof(MY_FILE ) - 1UL);
#line 592
  reset_links_in_Input___0();
#line 592
  reset_links_in_BDepot___0();
#line 592
  reset_links_in_SDepot___0();
  }
#line 594
  return (new_entry);
  case_2: /* CIL Label */ 
#line 603
  if (! ((unsigned long )list == (unsigned long )SDepot___1)) {
#line 603
    if (! ((unsigned long )list == (unsigned long )BDepot___1)) {
      {
#line 603
      __assert_fail("list == SDepot || list == BDepot", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    603U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 605
  list->size = (unsigned int )((unsigned long )list->size + sizeof(unsigned int ));
#line 606
  tmp___0 = realloc((void *)list->file.block_list, (size_t )list->size);
#line 606
  new_block_list = (unsigned int *)tmp___0;
#line 607
  list->file.block_list = new_block_list;
  }
#line 608
  if (! ((unsigned long )new_block_list != (unsigned long )((void *)0))) {
#line 608
    return (4294967295U);
  }
  {
#line 609
  new_entry___0 = (unsigned int )((unsigned long )list->size / sizeof(unsigned int ) - 1UL);
#line 610
  reset_links_in_Input___0();
#line 610
  reset_links_in_BDepot___0();
#line 610
  reset_links_in_SDepot___0();
  }
#line 612
  return (new_entry___0);
  case_3: /* CIL Label */ 
#line 620
  if (! ((unsigned long )list == (unsigned long )Root___1)) {
    {
#line 620
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  620U, "add_MY_FILE_entry");
    }
  }
  {
#line 622
  list->size += 128U;
#line 623
  tmp___1 = realloc((void *)list->file.root_list, (size_t )list->size);
#line 623
  new_root_list = (unsigned char *)tmp___1;
#line 624
  list->file.root_list = new_root_list;
  }
#line 625
  if (! ((unsigned long )new_root_list != (unsigned long )((void *)0))) {
#line 625
    return (4294967295U);
  }
  {
#line 626
  new_entry___1 = list->size / 128U - 1U;
#line 627
  reset_links_in_Input___0();
#line 627
  reset_links_in_BDepot___0();
#line 627
  reset_links_in_SDepot___0();
  }
#line 629
  return (new_entry___1);
  switch_default: /* CIL Label */ ;
#line 640
  if (! ((unsigned long )"list->type UNKNOWN in add_MY_FILE_entry" == (unsigned long )((void *)0))) {
    {
#line 640
    __assert_fail("\"list->type UNKNOWN in add_MY_FILE_entry\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  640U, "add_MY_FILE_entry");
    }
  }
#line 641
  return (0U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int pps2root___0(unsigned char *pps , pps_entry *node , unsigned int start_block ) 
{ 
  unsigned short i ;
  unsigned short size_of_name ;
  unsigned char U8magiczero ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 653
  U8magiczero = (unsigned char)0;
#line 654
  U32magiczero = 0U;
#line 655
  U32magic1 = 133376U;
#line 656
  U32magic2 = 1174405120U;
#line 663
  if (! (node->ppsnumber == (unsigned int )(pps - (unsigned char *)Root___1->file.root_list) / 128U)) {
    {
#line 663
    __assert_fail("node->ppsnumber == (unsigned int)(pps - Root->file.root_list)/0x80",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  663U, "pps2root");
    }
  }
  {
#line 665
  memset((void *)pps, 255, (size_t )128);
#line 668
  tmp = strlen((char const   *)(node->name));
#line 668
  size_of_name = (unsigned short )(2UL * (tmp + 1UL));
#line 670
  i = (unsigned short)0;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! ((int )i < (int )size_of_name)) {
#line 670
      goto while_break;
    }
#line 671
    if ((int )i % 2) {
#line 671
      tmp___0 = 0;
    } else {
#line 671
      tmp___0 = (int )*(node->name + (int )i / 2);
    }
#line 671
    *(pps + (int )i) = (unsigned char )tmp___0;
#line 670
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  fil_swriteU16((unsigned char *)(pps + 64), & size_of_name);
#line 675
  *(pps + 66) = node->type;
#line 676
  fil_swriteU32((unsigned char *)(pps + 68), & node->previous);
#line 677
  fil_swriteU32((unsigned char *)(pps + 72), & node->next);
#line 678
  fil_swriteU32((unsigned char *)(pps + 76), & node->dir);
#line 679
  fil_swriteU32((unsigned char *)(pps + 100), & node->seconds1);
#line 680
  fil_swriteU32((unsigned char *)(pps + 104), & node->days1);
#line 681
  fil_swriteU32((unsigned char *)(pps + 108), & node->seconds2);
#line 682
  fil_swriteU32((unsigned char *)(pps + 112), & node->days1);
#line 683
  fil_swriteU32((unsigned char *)(pps + 116), & start_block);
#line 684
  fil_swriteU32((unsigned char *)(pps + 120), & node->size);
#line 687
  *(pps + 67) = U8magiczero;
#line 688
  fil_swriteU32((unsigned char *)(pps + 80), & U32magic1);
#line 689
  fil_swriteU32((unsigned char *)(pps + 84), & U32magiczero);
#line 690
  fil_swriteU32((unsigned char *)(pps + 88), & U32magiczero);
#line 691
  fil_swriteU32((unsigned char *)(pps + 92), & U32magic2);
#line 692
  fil_swriteU32((unsigned char *)(pps + 96), & U32magiczero);
#line 693
  fil_swriteU32((unsigned char *)(pps + 124), & U32magiczero);
  }
#line 697
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_block_list___0(MY_FILE *list ) 
{ 
  unsigned int sum ;
  unsigned int *block ;

  {
#line 702
  sum = 0U;
#line 707
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 707
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  707U, "sum_block_list");
    }
  }
#line 708
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 708
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  708U, "sum_block_list");
    }
  }
#line 709
  block = list->file.block_list;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned int )((unsigned char *)block - (unsigned char *)list->file.block_list) < list->size)) {
#line 709
      goto while_break;
    }
#line 712
    sum += *block;
#line 709
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return (sum);
}
}
#line 738 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_blocks_MY_FILE_list___0(MY_FILE *list ) 
{ 
  unsigned int sum ;
  MY_FILE *file ;

  {
#line 740
  sum = 0U;
#line 745
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 745
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  745U, "sum_blocks_MY_FILE_list");
    }
  }
#line 746
  if (! ((unsigned int )list->type == 1U)) {
    {
#line 746
    __assert_fail("list->type == MY_FILE_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  746U, "sum_blocks_MY_FILE_list");
    }
  }
#line 747
  file = list->file.MY_FILE_list;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )((unsigned char *)file - (unsigned char *)list->file.MY_FILE_list) < list->size)) {
#line 747
      goto while_break;
    }
#line 750
    if ((unsigned long )file->blocks != (unsigned long )((void *)0)) {
#line 751
      sum += *(file->blocks);
    }
#line 747
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (sum);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_Input___0(void) 
{ 


  {
#line 759
  sbfile___1 = Input___0.file.MY_FILE_list + 4;
#line 760
  SDepot___1 = Input___0.file.MY_FILE_list + 3;
#line 761
  BDepot___1 = Input___0.file.MY_FILE_list + 1;
#line 762
  bbd_list___0 = Input___0.file.MY_FILE_list;
#line 763
  Root___1 = Input___0.file.MY_FILE_list + 2;
#line 764
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_BDepot___0(void) 
{ 
  unsigned int i ;

  {
#line 772
  sbfile___1->blocks = BDepot___1->file.block_list;
#line 773
  SDepot___1->blocks = BDepot___1->file.block_list + 1;
#line 774
  Root___1->blocks = BDepot___1->file.block_list + 2;
#line 777
  i = 0U;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )i < (unsigned long )Input___0.size / sizeof(MY_FILE ) - 5UL)) {
#line 777
      goto while_break;
    }
#line 778
    (Input___0.file.MY_FILE_list + (i + 5U))->blocks = (BDepot___1->file.block_list + i) + 3;
#line 777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_SDepot___0(void) 
{ 
  unsigned int i ;

  {
#line 788
  i = 0U;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! ((unsigned long )i < (unsigned long )sbfile___1->size / sizeof(MY_FILE ))) {
#line 788
      goto while_break;
    }
#line 789
    (sbfile___1->file.MY_FILE_list + i)->blocks = SDepot___1->file.block_list + i;
#line 788
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_ole2_file___0(char const   *filename___4 , int trunc ) 
{ 
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;

  {
#line 796
  if (! trunc) {
    {
#line 798
    output_file___0 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"r");
    }
#line 799
    if (! ((unsigned long )output_file___0 == (unsigned long )((void *)0))) {
      {
#line 799
      ends___1();
      }
#line 799
      return (2);
    }
  }
  {
#line 801
  output_file___0 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"wb");
  }
#line 802
  if (! ((unsigned long )output_file___0 != (unsigned long )((void *)0))) {
    {
#line 802
    ends___1();
    }
#line 802
    return (3);
  }
  {
#line 804
  retval = generate_header___0();
  }
#line 804
  if (retval) {
#line 804
    return (retval);
  }
  {
#line 805
  retval___0 = generate_recursive___0(& Input___0);
  }
#line 805
  if (retval___0) {
#line 805
    return (retval___0);
  }
#line 809
  if ((int )pos_block___0 != 0) {
#line 809
    if ((int )pos_block___0 % 512) {
      {
#line 809
      memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 512 + 1) * 512 - (int )pos_block___0));
      }
    }
    {
#line 809
    tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___0);
    }
#line 809
    if (! (tmp == 512UL)) {
#line 809
      return (1);
    }
#line 809
    next_block___0 ++;
#line 809
    pos_block___0 = (unsigned short)0;
  }
  {
#line 810
  retval___1 = generate_SDepot___0();
  }
#line 810
  if (retval___1) {
#line 810
    return (retval___1);
  }
  {
#line 811
  retval___2 = generate_Root___0();
  }
#line 811
  if (retval___2) {
#line 811
    return (retval___2);
  }
  {
#line 812
  retval___3 = generate_BDepot___0();
  }
#line 812
  if (retval___3) {
#line 812
    return (retval___3);
  }
  {
#line 814
  fclose(output_file___0);
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_header___0(void) 
{ 
  unsigned int identifier1 ;
  unsigned int identifier2 ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  unsigned int U32magic3 ;
  unsigned int U32magic4 ;
  unsigned int U32magic5 ;
  unsigned int U32magic6 ;

  {
  {
#line 821
  identifier1 = 3759263696U;
#line 822
  identifier2 = 3776623009U;
#line 823
  U32magiczero = 0U;
#line 824
  U32magic1 = 196667U;
#line 825
  U32magic2 = 655358U;
#line 826
  U32magic3 = 6U;
#line 827
  U32magic4 = 4096U;
#line 828
  U32magic5 = 1U;
#line 829
  U32magic6 = 4294967294U;
#line 833
  calculate_blocks___0();
#line 835
  fil_swriteU32(output_block___0 + 48, & Root_start_block___0);
#line 836
  fil_swriteU32(output_block___0 + 60, & SDepot_start_block___0);
#line 837
  fil_swriteU32(output_block___0 + 44, & BDepot_blocks___0);
#line 839
  fil_swriteU32(output_block___0 + 0, & identifier1);
#line 840
  fil_swriteU32(output_block___0 + 4, & identifier2);
#line 841
  fil_swriteU32(output_block___0 + 8, & U32magiczero);
#line 842
  fil_swriteU32(output_block___0 + 12, & U32magiczero);
#line 843
  fil_swriteU32(output_block___0 + 16, & U32magiczero);
#line 844
  fil_swriteU32(output_block___0 + 20, & U32magiczero);
#line 845
  fil_swriteU32(output_block___0 + 24, & U32magic1);
#line 846
  fil_swriteU32(output_block___0 + 28, & U32magic2);
#line 847
  fil_swriteU32(output_block___0 + 32, & U32magic3);
#line 848
  fil_swriteU32(output_block___0 + 36, & U32magiczero);
#line 849
  fil_swriteU32(output_block___0 + 40, & U32magiczero);
#line 850
  fil_swriteU32(output_block___0 + 52, & U32magiczero);
#line 851
  fil_swriteU32(output_block___0 + 56, & U32magic4);
#line 852
  fil_swriteU32(output_block___0 + 64, & U32magic5);
#line 853
  fil_swriteU32(output_block___0 + 68, & U32magic6);
#line 854
  fil_swriteU32(output_block___0 + 72, & U32magiczero);
#line 856
  pos_block___0 = (unsigned short)76;
  }
#line 858
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_recursive___0(MY_FILE *list ) 
{ 
  MY_FILE *p_MY_FILE_list ;
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;

  {
  {
#line 873
  if ((unsigned int )list->type == 1U) {
#line 873
    goto case_1;
  }
#line 881
  if ((unsigned int )list->type == 2U) {
#line 881
    goto case_2;
  }
#line 898
  if ((unsigned int )list->type == 3U) {
#line 898
    goto case_3;
  }
#line 903
  if ((unsigned int )list->type == 0U) {
#line 903
    goto case_0;
  }
#line 908
  goto switch_default;
  case_1: /* CIL Label */ 
#line 874
  p_MY_FILE_list = list->file.MY_FILE_list;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! ((unsigned int )((unsigned char *)p_MY_FILE_list - list->file.root_list) < list->size)) {
#line 874
      goto while_break;
    }
    {
#line 877
    retval = generate_recursive___0(p_MY_FILE_list);
    }
#line 877
    if (retval) {
#line 877
      return (retval);
    }
#line 874
    p_MY_FILE_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  goto switch_break;
  case_2: /* CIL Label */ 
#line 882
  if ((unsigned long )list == (unsigned long )bbd_list___0) {
    {
#line 884
    retval___0 = write_block_list___0(BDepot_start_block___0, bbd_list___0, 0);
    }
#line 884
    if (retval___0) {
#line 884
      return (retval___0);
    }
#line 885
    if ((int )pos_block___0 != 0) {
#line 885
      if ((int )pos_block___0 % 512) {
        {
#line 885
        memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 512 + 1) * 512 - (int )pos_block___0));
        }
      }
      {
#line 885
      tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                   (size_t )512, (FILE */* __restrict  */)output_file___0);
      }
#line 885
      if (! (tmp == 512UL)) {
#line 885
        return (1);
      }
#line 885
      next_block___0 ++;
#line 885
      pos_block___0 = (unsigned short)0;
    }
#line 886
    goto switch_break;
  } else
#line 888
  if ((unsigned long )list == (unsigned long )BDepot___1) {
#line 890
    goto switch_break;
  } else
#line 891
  if ((unsigned long )list == (unsigned long )SDepot___1) {
#line 893
    goto switch_break;
  } else
#line 895
  if (! ((unsigned long )"list->type==block_list but list UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 895
    __assert_fail("\"list->type==block_list but list UNKNOWN in generate_recursive\"==((void *)0)",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  895U, "generate_recursive");
    }
  }
  case_3: /* CIL Label */ 
#line 900
  if (! ((unsigned long )list == (unsigned long )Root___1)) {
    {
#line 900
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  900U, "generate_recursive");
    }
  }
#line 901
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 905
  retval___1 = generate_real_file___0(list);
  }
#line 905
  if (retval___1) {
#line 905
    return (retval___1);
  }
#line 906
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 909
  if (! ((unsigned long )"list->type UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 909
    __assert_fail("\"list->type UNKNOWN in generate_recursive\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  909U, "generate_recursive");
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 912
  return (0);
}
}
#line 916 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_SDepot___0(void) 
{ 
  int retval ;
  size_t tmp ;

  {
  {
#line 920
  retval = write_block_list___0(1U, SDepot___1, 1);
  }
#line 920
  if (retval) {
#line 920
    return (retval);
  }
#line 921
  if ((int )pos_block___0 != 0) {
#line 921
    if ((int )pos_block___0 % 512) {
      {
#line 921
      memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 512 + 1) * 512 - (int )pos_block___0));
      }
    }
    {
#line 921
    tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___0);
    }
#line 921
    if (! (tmp == 512UL)) {
#line 921
      return (1);
    }
#line 921
    next_block___0 ++;
#line 921
    pos_block___0 = (unsigned short)0;
  }
#line 923
  return (0);
}
}
#line 927 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_Root___0(void) 
{ 
  int retval ;
  int zzzi ;
  unsigned short U16zero ;
  size_t tmp ;

  {
  {
#line 931
  retval = write_root_list___0(Root___1);
  }
#line 931
  if (retval) {
#line 931
    return (retval);
  }
#line 932
  if ((int )pos_block___0 != 0) {
    {
#line 932
    U16zero = (unsigned short)0;
#line 932
    memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(512 - (int )pos_block___0));
#line 932
    zzzi = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 932
      if (! (zzzi < 4)) {
#line 932
        goto while_break;
      }
#line 932
      if (zzzi * 128 >= (int )pos_block___0) {
        {
#line 932
        fil_swriteU16((output_block___0 + zzzi * 128) + 64, & U16zero);
        }
      }
#line 932
      zzzi ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 933
  if ((int )pos_block___0 != 0) {
    {
#line 933
    tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___0);
    }
#line 933
    if (! (tmp == 512UL)) {
#line 933
      return (1);
    }
#line 933
    next_block___0 ++;
#line 933
    pos_block___0 = (unsigned short)0;
  }
#line 935
  return (0);
}
}
#line 938 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_BDepot___0(void) 
{ 
  MY_FILE SDepot_and_Root_block_list ;
  MY_FILE file_block_list ;
  unsigned int next_block_link ;
  int retval ;
  int retval___0 ;
  unsigned int tmp ;
  int retval___1 ;
  size_t tmp___0 ;

  {
#line 946
  next_block_link = (unsigned int )((4294967295UL + (unsigned long )header_blocks___0) + 1UL);
#line 950
  if (! (next_block_link == sbfile_start_block___0 + 1U)) {
    {
#line 950
    __assert_fail("next_block_link == sbfile_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  950U, "generate_BDepot");
    }
  }
  {
#line 952
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 952
  file_block_list.size = (unsigned int )sizeof(unsigned int );
#line 952
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 952
  file_block_list.file.block_list = BDepot___1->file.block_list;
#line 955
  retval = write_block_list___0(next_block_link, & file_block_list, 1);
  }
#line 955
  if (retval) {
#line 955
    return (retval);
  }
#line 958
  next_block_link += sbfile_blocks___0;
#line 961
  if (! (next_block_link == (sbfile_start_block___0 + sbfile_blocks___0) + 1U)) {
    {
#line 961
    __assert_fail("next_block_link == sbfile_start_block + sbfile_blocks + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  961U, "generate_BDepot");
    }
  }
  {
#line 963
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 963
  file_block_list.size = (unsigned int )((unsigned long )BDepot___1->size - 3UL * sizeof(unsigned int ));
#line 963
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 963
  file_block_list.file.block_list = BDepot___1->file.block_list + 3;
#line 965
  retval___0 = write_block_list___0(next_block_link, & file_block_list, 1);
  }
#line 965
  if (retval___0) {
#line 965
    return (retval___0);
  }
  {
#line 968
  tmp = sum_block_list___0(& file_block_list);
#line 968
  next_block_link += tmp;
  }
#line 971
  if (sbfile___1->size > 0U) {
#line 973
    if (! (next_block_link == SDepot_start_block___0 + 1U)) {
      {
#line 973
      __assert_fail("next_block_link == SDepot_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    973U, "generate_BDepot");
      }
    }
  }
  {
#line 975
  SDepot_and_Root_block_list.type = (enum __anonenum_type_26 )2;
#line 975
  SDepot_and_Root_block_list.size = (unsigned int )(2UL * sizeof(unsigned int ));
#line 975
  SDepot_and_Root_block_list.blocks = (unsigned int *)((void *)0);
#line 975
  SDepot_and_Root_block_list.file.block_list = BDepot___1->file.block_list + 1;
#line 977
  retval___1 = write_block_list___0(next_block_link, & SDepot_and_Root_block_list,
                                    1);
  }
#line 977
  if (retval___1) {
#line 977
    return (retval___1);
  }
#line 980
  if ((int )pos_block___0 != 0) {
#line 980
    if ((int )pos_block___0 % 512) {
      {
#line 980
      memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 512 + 1) * 512 - (int )pos_block___0));
      }
    }
    {
#line 980
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___0);
    }
#line 980
    if (! (tmp___0 == 512UL)) {
#line 980
      return (1);
    }
#line 980
    next_block___0 ++;
#line 980
    pos_block___0 = (unsigned short)0;
  }
#line 982
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int last_small_stream_next_block___0  =    0U;
#line 993 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_start_block_set___0  =    0;
#line 994 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_may_need_write_until_boundary___0  =    0;
#line 985 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_real_file___0(MY_FILE *MY_FILE_file ) 
{ 
  FILE *file ;
  int n_read ;
  unsigned char *pps ;
  unsigned int total_bytes ;
  unsigned int sbfile_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 1004
  if (! ((int )pos_block___0 <= 512)) {
    {
#line 1004
    __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1004U, "generate_real_file");
    }
  }
#line 1005
  if (! ((int )pos_block___0 % 64 == 0)) {
    {
#line 1005
    __assert_fail("pos_block % 0x40 == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1005U, "generate_real_file");
    }
  }
#line 1008
  if (! *(MY_FILE_file->file.real.name + 0)) {
    {
#line 1008
    __assert_fail("MY_FILE_file->file.real.name[0]", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1008U, "generate_real_file");
    }
  }
  {
#line 1009
  file = fopen((char const   */* __restrict  */)MY_FILE_file->file.real.name, (char const   */* __restrict  */)"rb");
  }
#line 1010
  if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 1010
    return (11);
  }
#line 1013
  if (MY_FILE_file->size >= 4096U) {
#line 1018
    if (sbfile_may_need_write_until_boundary___0) {
#line 1022
      if ((int )pos_block___0 != 0) {
#line 1022
        if ((int )pos_block___0 % 512) {
          {
#line 1022
          memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 512 + 1) * 512 - (int )pos_block___0));
          }
        }
        {
#line 1022
        tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___0);
        }
#line 1022
        if (! (tmp == 512UL)) {
#line 1022
          return (1);
        }
#line 1022
        next_block___0 ++;
#line 1022
        pos_block___0 = (unsigned short)0;
      }
#line 1023
      sbfile_may_need_write_until_boundary___0 = 0;
    }
    {
#line 1029
    pps = Root___1->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1030
    fil_swriteU32(pps + 116, & next_block___0);
    }
  } else {
    {
#line 1039
    pps = Root___1->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1040
    fil_swriteU32(pps + 116, & last_small_stream_next_block___0);
#line 1041
    last_small_stream_next_block___0 += *(MY_FILE_file->blocks);
    }
#line 1044
    if (! sbfile_start_block_set___0) {
#line 1050
      if (! (sbfile_start_block___0 == next_block___0)) {
        {
#line 1050
        __assert_fail("sbfile_start_block == next_block", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1050U, "generate_real_file");
        }
      }
      {
#line 1051
      fil_swriteU32(Root___1->file.root_list + 116, & next_block___0);
#line 1053
      tmp___0 = sum_blocks_MY_FILE_list___0(sbfile___1);
#line 1053
      sbfile_size = tmp___0 * 64U;
#line 1056
      tmp___1 = fil_sreadU32(Root___1->file.root_list + 120);
      }
#line 1056
      if (! (sbfile_size == tmp___1)) {
        {
#line 1056
        __assert_fail("sbfile_size == fil_sreadU32 (Root->file.root_list + 0x78)",
                      "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1056U, "generate_real_file");
        }
      }
#line 1058
      sbfile_start_block_set___0 = 1;
#line 1059
      sbfile_may_need_write_until_boundary___0 = 1;
    }
  }
#line 1064
  total_bytes = 0U;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1066
    tmp___6 = feof(file);
    }
#line 1066
    if (tmp___6) {
#line 1066
      goto while_break;
    }
    {
#line 1068
    tmp___2 = fread((void */* __restrict  */)(output_block___0 + (int )pos_block___0),
                    (size_t )1, (size_t )(512 - (int )pos_block___0), (FILE */* __restrict  */)file);
#line 1068
    n_read = (int )tmp___2;
#line 1069
    tmp___3 = ferror(file);
    }
#line 1069
    if (tmp___3) {
#line 1069
      return (11);
    }
#line 1070
    if (n_read < 512 - (int )pos_block___0) {
      {
#line 1072
      tmp___4 = feof(file);
      }
#line 1072
      if (! tmp___4) {
        {
#line 1072
        __assert_fail("feof (file)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1072U, "generate_real_file");
        }
      }
    }
#line 1073
    pos_block___0 = (unsigned short )((int )pos_block___0 + (int )((unsigned short )n_read));
#line 1074
    total_bytes += (unsigned int )n_read;
#line 1075
    if ((int )pos_block___0 == 512) {
      {
#line 1075
      tmp___5 = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )512,
                       (size_t )1, (FILE */* __restrict  */)output_file___0);
      }
#line 1075
      if (! (tmp___5 == 1UL)) {
#line 1075
        return (1);
      }
#line 1075
      next_block___0 ++;
#line 1075
      pos_block___0 = (unsigned short)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (! (total_bytes == MY_FILE_file->size)) {
#line 1077
    return (12);
  }
#line 1079
  if (MY_FILE_file->size >= 4096U) {
#line 1081
    if ((int )pos_block___0 != 0) {
#line 1081
      if ((int )pos_block___0 % 512) {
        {
#line 1081
        memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 512 + 1) * 512 - (int )pos_block___0));
        }
      }
      {
#line 1081
      tmp___7 = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )1,
                       (size_t )512, (FILE */* __restrict  */)output_file___0);
      }
#line 1081
      if (! (tmp___7 == 512UL)) {
#line 1081
        return (1);
      }
#line 1081
      next_block___0 ++;
#line 1081
      pos_block___0 = (unsigned short)0;
    }
  } else
#line 1084
  if ((int )pos_block___0 % 64) {
    {
#line 1084
    memset((void *)(output_block___0 + (int )pos_block___0), 255, (size_t )(((int )pos_block___0 / 64 + 1) * 64 - (int )pos_block___0));
    }
#line 1084
    if (! (((int )pos_block___0 + ((int )pos_block___0 / 64 + 1) * 64) - (int )pos_block___0 == ((int )pos_block___0 / 64 + 1) * 64)) {
      {
#line 1084
      __assert_fail("pos_block+(pos_block/0x40 + 1)*0x40 - pos_block == (pos_block/0x40 + 1)*0x40",
                    "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1084U, "generate_real_file");
      }
    }
#line 1084
    pos_block___0 = (unsigned short )((int )pos_block___0 + (int )((unsigned short )(((int )pos_block___0 / 64 + 1) * 64 - (int )pos_block___0)));
  }
  {
#line 1087
  fclose(file);
  }
#line 1089
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_block_list___0(unsigned int start_count , MY_FILE *list , int write_end_chain ) 
{ 
  unsigned int *p ;
  unsigned int n ;
  unsigned int end_chain ;
  unsigned int value_to_write ;
  unsigned int delta ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1098
  end_chain = 4294967294U;
#line 1104
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 1104
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1104U, "write_block_list");
    }
  }
#line 1105
  if (! ((int )pos_block___0 <= 508)) {
    {
#line 1105
    __assert_fail("pos_block <= 0x01fc", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1105U, "write_block_list");
    }
  }
#line 1107
  delta = start_count;
#line 1108
  if (list->size == 0U) {
#line 1108
    return (0);
  }
#line 1109
  p = list->file.block_list;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! ((unsigned int )((unsigned char *)p - (unsigned char *)list->file.block_list) < list->size)) {
#line 1109
      goto while_break;
    }
#line 1112
    n = 0U;
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1112
      if (! (n < *p)) {
#line 1112
        goto while_break___0;
      }
#line 1115
      if ((int )pos_block___0 == 512) {
        {
#line 1115
        tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___0);
        }
#line 1115
        if (! (tmp == 1UL)) {
#line 1115
          return (1);
        }
#line 1115
        next_block___0 ++;
#line 1115
        pos_block___0 = (unsigned short)0;
      }
#line 1118
      if (write_end_chain) {
#line 1118
        if (! (n + 1U < *p)) {
#line 1119
          value_to_write = end_chain;
        } else {
#line 1121
          value_to_write = n + delta;
        }
      } else {
#line 1121
        value_to_write = n + delta;
      }
      {
#line 1122
      fil_swriteU32(output_block___0 + (int )pos_block___0, & value_to_write);
#line 1123
      pos_block___0 = (unsigned short )((int )pos_block___0 + (int )((unsigned short )sizeof(unsigned int )));
      }
#line 1124
      if (! ((int )pos_block___0 <= 512)) {
        {
#line 1124
        __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1124U, "write_block_list");
        }
      }
#line 1112
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1126
    delta += n;
#line 1109
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1128
  if ((int )pos_block___0 == 512) {
    {
#line 1128
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___0);
    }
#line 1128
    if (! (tmp___0 == 1UL)) {
#line 1128
      return (1);
    }
#line 1128
    next_block___0 ++;
#line 1128
    pos_block___0 = (unsigned short)0;
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_root_list___0(MY_FILE *list ) 
{ 
  unsigned char *p ;
  size_t tmp ;

  {
#line 1139
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1139
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1139U, "write_root_list");
    }
  }
#line 1140
  if (! ((int )pos_block___0 == 0)) {
    {
#line 1140
    __assert_fail("pos_block == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1140U, "write_root_list");
    }
  }
#line 1141
  if (! ((unsigned int )list->type == 3U)) {
    {
#line 1141
    __assert_fail("list->type == root_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1141U, "write_root_list");
    }
  }
#line 1142
  if (! (list->size > 0U)) {
    {
#line 1142
    __assert_fail("list->size > 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1142U, "write_root_list");
    }
  }
#line 1144
  p = list->file.root_list;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (! ((unsigned int )(p - list->file.root_list) < list->size)) {
#line 1144
      goto while_break;
    }
    {
#line 1147
    memcpy((void */* __restrict  */)(output_block___0 + (p - list->file.root_list) % 512L),
           (void const   */* __restrict  */)p, (size_t )128);
#line 1169
    pos_block___0 = (unsigned short )((int )pos_block___0 + 128);
    }
#line 1170
    if (! ((int )pos_block___0 <= 512)) {
      {
#line 1170
      __assert_fail("pos_block <= (unsigned short)0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1170U, "write_root_list");
      }
    }
#line 1171
    if ((int )pos_block___0 == 512) {
      {
#line 1171
      tmp = fwrite((void const   */* __restrict  */)(output_block___0), (size_t )512,
                   (size_t )1, (FILE */* __restrict  */)output_file___0);
      }
#line 1171
      if (! (tmp == 1UL)) {
#line 1171
        return (1);
      }
#line 1171
      next_block___0 ++;
#line 1171
      pos_block___0 = (unsigned short)0;
    }
#line 1144
    p += 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void ends___1(void) 
{ 


  {
#line 1193
  if ((unsigned long )output_file___0 != (unsigned long )((void *)0)) {
    {
#line 1194
    fclose(output_file___0);
    }
  }
#line 1195
  return;
}
}
#line 1198 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void calculate_blocks___0(void) 
{ 
  MY_FILE big_streams_list ;
  unsigned int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1205
  big_streams_list.type = (enum __anonenum_type_26 )1;
#line 1205
  big_streams_list.size = (unsigned int )((unsigned long )Input___0.size - 5UL * sizeof(MY_FILE ));
#line 1205
  big_streams_list.blocks = (unsigned int *)((void *)0);
#line 1205
  big_streams_list.file.MY_FILE_list = Input___0.file.MY_FILE_list + 5;
#line 1211
  if (! (*(BDepot___1->blocks) == *(bbd_list___0->file.block_list))) {
    {
#line 1211
    __assert_fail("*(BDepot->blocks) == *(bbd_list->file.block_list)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1211U, "calculate_blocks");
    }
  }
#line 1212
  if (! Root___1->size) {
#line 1212
    tmp = 1U;
  } else {
#line 1212
    tmp = 1U + (Root___1->size - 1U) / 512U;
  }
#line 1212
  if (! (*(Root___1->blocks) == tmp)) {
    {
#line 1212
    __assert_fail("*(Root->blocks) == (!(Root->size) ? 1 : (1+((Root->size)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1212U, "calculate_blocks");
    }
  }
  {
#line 1215
  tmp___3 = sum_blocks_MY_FILE_list___0(sbfile___1);
  }
#line 1215
  if (tmp___3 * 64U) {
    {
#line 1215
    tmp___1 = sum_blocks_MY_FILE_list___0(sbfile___1);
#line 1215
    tmp___2 = 1U + (tmp___1 * 64U - 1U) / 512U;
    }
  } else {
#line 1215
    tmp___2 = 0U;
  }
#line 1215
  if (! (*(sbfile___1->blocks) == tmp___2)) {
    {
#line 1215
    __assert_fail("*(sbfile->blocks) == (!(sum_blocks_MY_FILE_list (sbfile) * 0x40) ? 0 : (1+((sum_blocks_MY_FILE_list (sbfile) * 0x40)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1216U, "calculate_blocks");
    }
  }
  {
#line 1217
  tmp___7 = sum_block_list___0(SDepot___1);
  }
#line 1217
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 1217
    tmp___5 = sum_block_list___0(SDepot___1);
#line 1217
    tmp___6 = 1UL + ((unsigned long )tmp___5 * sizeof(unsigned int ) - 1UL) / 512UL;
    }
  } else {
#line 1217
    tmp___6 = 0UL;
  }
#line 1217
  if (! ((unsigned long )*(SDepot___1->blocks) == tmp___6)) {
    {
#line 1217
    __assert_fail("*(SDepot->blocks) == (!((sum_block_list (SDepot) * sizeof (unsigned int))) ? 0 : (1+(((sum_block_list (SDepot) * sizeof (unsigned int)))-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1218U, "calculate_blocks");
    }
  }
  {
#line 1219
  BDepot_blocks___0 = *(BDepot___1->blocks);
#line 1220
  SDepot_blocks___0 = *(SDepot___1->blocks);
#line 1221
  Root_blocks___0 = *(Root___1->blocks);
#line 1222
  sbfile_blocks___0 = *(sbfile___1->blocks);
#line 1223
  big_streams_blocks___0 = sum_blocks_MY_FILE_list___0(& big_streams_list);
  }
#line 1224
  if (! ((unsigned long )(19U + BDepot_blocks___0) * sizeof(unsigned int ))) {
#line 1224
    header_blocks___0 = 1U;
  } else {
#line 1224
    header_blocks___0 = (unsigned int )(1UL + ((unsigned long )(19U + BDepot_blocks___0) * sizeof(unsigned int ) - 1UL) / 512UL);
  }
#line 1228
  sbfile_start_block___0 = (unsigned int )(4294967295UL + (unsigned long )header_blocks___0);
#line 1230
  Root_start_block___0 = (unsigned int )((((4294967295UL + (unsigned long )header_blocks___0) + (unsigned long )sbfile_blocks___0) + (unsigned long )big_streams_blocks___0) + (unsigned long )SDepot_blocks___0);
#line 1233
  if (SDepot_blocks___0 > 0U) {
#line 1235
    SDepot_start_block___0 = (unsigned int )(((4294967295UL + (unsigned long )header_blocks___0) + (unsigned long )sbfile_blocks___0) + (unsigned long )big_streams_blocks___0);
  } else {
#line 1239
    SDepot_start_block___0 = 4294967294U;
  }
#line 1240
  BDepot_start_block___0 = (unsigned int )(((((4294967295UL + (unsigned long )header_blocks___0) + (unsigned long )sbfile_blocks___0) + (unsigned long )big_streams_blocks___0) + (unsigned long )SDepot_blocks___0) + (unsigned long )Root_blocks___0);
#line 1247
  return;
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.h"
void display_usage(void) ;
#line 7
void NumToDate(long num , int *year , int *month , int *day ) ;
#line 8
unsigned short getShort(unsigned char *ptr ) ;
#line 9
void getDouble(unsigned char *ptr , double *d ) ;
#line 10
int null_string(unsigned char *str ) ;
#line 11
void print_version(void) ;
#line 12
void do_cr(void) ;
#line 13
void FracToTime(unsigned char *cnum , int *hr , int *minut , int *sec , int *msec ) ;
#line 14
int getLong(unsigned char *ptr ) ;
#line 15
void RKtoDouble(int n , double *d ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void print_version(void) 
{ 


  {
  {
#line 34
  printf((char const   */* __restrict  */)"xlhtml %s \nCopyright (c) 1999-2002, Charles Wyble\nReleased under GPL.\n",
         "0.5.1");
#line 36
  exit(0);
  }
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void display_usage(void) 
{ 


  {
  {
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nxlhtml  converts excel files (.xls) to Html.\nCopyright (c) 1999-2001, Charles Wyble. Released under GPL.\nUsage: xlhtml [-xp:# -xc:#-# -xr:#-# -bc###### -bi???????? -tc######] <FILE>\n\t-a:  aggressive html optimization\n\t-asc ascii output for -dp & -x? options\n\t-csv comma separated value output for -dp & -x? options\n\t-xml XML output\n\t-bc: Set default background color - default white\n\t-bi: Set background image path\n\t-c:  Center justify tables\n\t-dp: Dumps page count and max rows & colums per page\n\t-v:  Prints program version number\n\t-fw: Suppress formula warnings\n\t-m:  No encoding for multibyte\n\t-nc: No Colors - black & white\n\t-nh: No Html Headers\n\t-tc: Set default text color - default black\n\t-te: Trims empty rows & columns at the edges of a worksheet\n\t-xc: Columns (separated by a dash) for extraction (zero based)\n\t-xp: Page extracted (zero based)\n\t-xr: Rows (separated by a dash) to be extracted (zero based)\n");
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nReport bugs to jackshck@thewybles.com\n");
#line 63
  exit(1);
  }
}
}
#line 68
int aggressive ;
#line 66 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void do_cr(void) 
{ 


  {
#line 69
  if (! aggressive) {
    {
#line 70
    putchar('\n');
    }
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
unsigned short getShort(unsigned char *ptr ) 
{ 


  {
#line 75
  if ((unsigned long )ptr == (unsigned long )((unsigned char *)0)) {
#line 76
    return ((unsigned short)0);
  }
#line 78
  return ((unsigned short )(((int )*(ptr + 1) << 8) + (int )*ptr));
}
}
#line 82 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
int getLong(unsigned char *ptr ) 
{ 


  {
#line 84
  if ((unsigned long )ptr == (unsigned long )((unsigned char *)0)) {
#line 85
    return (0);
  }
#line 87
  return (((((int )*(ptr + 3) << 24) + ((int )*(ptr + 2) << 16)) + ((int )*(ptr + 1) << 8)) + (int )*ptr);
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void getDouble(unsigned char *ptr , double *d ) 
{ 
  size_t i ;
  double dd ;
  unsigned char *t ;

  {
#line 96
  t = (unsigned char *)(& dd);
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < sizeof(double ))) {
#line 98
      goto while_break;
    }
#line 99
    *(t + i) = *(ptr + i);
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  *d = dd;
#line 102
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
int null_string(unsigned char *str ) 
{ 
  unsigned char *ptr ;
  unsigned char *tmp ;

  {
#line 121
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 122
    return (1);
  } else
#line 121
  if ((int )*str == 0) {
#line 122
    return (1);
  }
#line 124
  ptr = str;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((int )*ptr != 0)) {
#line 125
      goto while_break;
    }
#line 127
    tmp = ptr;
#line 127
    ptr ++;
#line 127
    if ((int )*tmp != 32) {
#line 128
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (1);
}
}
#line 133 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void FracToTime(unsigned char *cnum , int *hr , int *minut , int *sec , int *msec ) 
{ 
  int Hr ;
  int Min ;
  int Sec ;
  int Msec ;
  double fnum ;
  double tHr ;
  double tMin ;
  double tSec ;
  double tMsec ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 138
  if (msec) {
    {
#line 139
    tmp = atof((char const   *)((char *)(cnum + 0)));
#line 139
    fnum = tmp + 0.05 / 86400.0;
    }
  } else
#line 140
  if (sec) {
    {
#line 141
    tmp___0 = atof((char const   *)((char *)(cnum + 0)));
#line 141
    fnum = tmp___0 + 0.5 / 86400.0;
    }
  } else {
    {
#line 143
    tmp___1 = atof((char const   *)((char *)(cnum + 0)));
#line 143
    fnum = tmp___1 + (double )30 / 86400.0;
    }
  }
#line 144
  tHr = 24.0 * fnum;
#line 145
  Hr = (int )tHr;
#line 146
  tMin = (tHr - (double )Hr) * 60.0;
#line 147
  Min = (int )tMin;
#line 148
  tSec = (tMin - (double )Min) * 60.0;
#line 149
  Sec = (int )tSec;
#line 150
  tMsec = (tSec - (double )Sec) * 10.0;
#line 151
  Msec = (int )tMsec;
#line 153
  Hr %= 24;
#line 154
  if (hr) {
#line 155
    *hr = Hr;
  }
#line 156
  if (minut) {
#line 157
    *minut = Min;
  }
#line 158
  if (sec) {
#line 159
    *sec = Sec;
  }
#line 160
  if (msec) {
#line 161
    *msec = Msec;
  }
#line 162
  return;
}
}
#line 170
int DatesR1904 ;
#line 165 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void NumToDate(long num , int *year , int *month , int *day ) 
{ 
  int ldays[12] ;
  int ndays[12] ;
  int t ;
  int i ;
  int y ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 167
  ldays[0] = 31;
#line 167
  ldays[1] = 29;
#line 167
  ldays[2] = 31;
#line 167
  ldays[3] = 30;
#line 167
  ldays[4] = 31;
#line 167
  ldays[5] = 30;
#line 167
  ldays[6] = 31;
#line 167
  ldays[7] = 31;
#line 167
  ldays[8] = 30;
#line 167
  ldays[9] = 31;
#line 167
  ldays[10] = 30;
#line 167
  ldays[11] = 31;
#line 168
  ndays[0] = 31;
#line 168
  ndays[1] = 28;
#line 168
  ndays[2] = 31;
#line 168
  ndays[3] = 30;
#line 168
  ndays[4] = 31;
#line 168
  ndays[5] = 30;
#line 168
  ndays[6] = 31;
#line 168
  ndays[7] = 31;
#line 168
  ndays[8] = 30;
#line 168
  ndays[9] = 31;
#line 168
  ndays[10] = 30;
#line 168
  ndays[11] = 31;
#line 172
  y = 0;
#line 174
  num %= 36525L;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (y % 4 == 0) {
#line 175
      tmp___2 = 366;
    } else {
#line 175
      tmp___2 = 365;
    }
#line 175
    if (! (num > (long )tmp___2)) {
#line 175
      goto while_break;
    }
#line 176
    tmp___1 = y;
#line 176
    y ++;
#line 176
    if (tmp___1 % 4 == 0) {
#line 176
      tmp___0 = 366;
    } else {
#line 176
      tmp___0 = 365;
    }
#line 176
    num -= (long )tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  *year = y;
#line 179
  t = (int )num;
#line 180
  if (DatesR1904) {
#line 181
    *year += 4;
  }
#line 182
  if (*year % 4 == 0) {
#line 184
    i = 0;
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if (! (i < 12)) {
#line 184
        goto while_break___0;
      }
#line 186
      if (t <= ldays[i]) {
#line 187
        goto while_break___0;
      }
#line 188
      t -= ldays[i];
#line 184
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 193
    i = 0;
    {
#line 193
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 193
      if (! (i < 12)) {
#line 193
        goto while_break___1;
      }
#line 195
      if (t <= ndays[i]) {
#line 196
        goto while_break___1;
      }
#line 197
      t -= ndays[i];
#line 193
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 201
  *month = 1 + i;
#line 202
  if (t == 0) {
#line 203
    t = 1;
  }
#line 204
  *day = t;
#line 205
  *year %= 100;
#line 206
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/support.c"
void RKtoDouble(int n , double *d ) 
{ 


  {
#line 217
  ((union __anonunion_27 *)d)->sw[0] = 0;
#line 218
  ((union __anonunion_29 *)d)->sw[1] = n << 2;
#line 219
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 151 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
int first_sheet ;
#line 152
int last_sheet ;
#line 153 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
char filename[256]  ;
#line 154
char *default_text_color ;
#line 155
char *default_background_color ;
#line 156
char *default_image ;
#line 158
int center_tables ;
#line 159
int NoHeaders ;
#line 160
int formula_warnings ;
#line 161
int Csv ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
xf_attr **xf_array  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
work_sheet **ws_array  ;
#line 164 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
font_attr **font_array  ;
#line 165 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
uni_string default_font  ;
#line 166
unsigned int next_font ;
#line 167
unsigned int next_ws_title ;
#line 168
int default_fontsize ;
#line 169
char *default_alignment ;
#line 170
char *title ;
#line 171 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.h"
uni_string author  ;
#line 172
char *lastUpdated ;
#line 173
int file_version ;
#line 174
char colorTab[65][8] ;
#line 175
int NoFormat ;
#line 176
int notAccurate ;
#line 177
int NotImplemented ;
#line 178
int Unsupported ;
#line 179
int MaxPalExceeded ;
#line 180
int MaxXFExceeded ;
#line 181
int MaxFormatsExceeded ;
#line 182
int MaxColExceeded ;
#line 183
int MaxRowExceeded ;
#line 184
int MaxWorksheetsExceeded ;
#line 185
int MaxStringsExceeded ;
#line 186
int MaxFontsExceeded ;
#line 187
int UnicodeStrings ;
#line 188
int CodePage ;
#line 191
void OutputString(uni_string *u ) ;
#line 192
void output_cell(cell *c , int xml ) ;
#line 193
int IsCellNumeric(cell *c ) ;
#line 194
int IsCellSafe(cell *c ) ;
#line 195
int IsCellFormula(cell *c ) ;
#line 196
void output_formatted_data(uni_string *u , unsigned short idx , int numeric , int formula ) ;
#line 197
void SetupExtraction(void) ;
#line 198
void trim_sheet_edges(unsigned int sheet ) ;
#line 199
void update_default_font(unsigned int sheet ) ;
#line 200
void update_default_alignment(unsigned int sheet , int row ) ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned short HARD_MAX_ROWS  =    (unsigned short)32766;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static char SectionName[2][12]  = { {        (char )'/',        (char )'W',        (char )'o',        (char )'r', 
            (char )'k',        (char )'b',        (char )'o',        (char )'o', 
            (char )'k',        (char )'\000'}, 
   {        (char )'/',        (char )'B',        (char )'o',        (char )'o', 
            (char )'k',        (char )'\000'}};
#line 42 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int numCustomColors  =    0;
#line 43 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned char **customColors  =    (unsigned char **)0;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char colorTab[65][8]  = 
#line 44
  { {        (char )'0',        (char )'0',        (char )'0',        (char )'0', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'r',        (char )'e',        (char )'d',        (char )'\000'}, 
   {        (char )'l',        (char )'i',        (char )'m',        (char )'e', 
            (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'u',        (char )'e', 
            (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'0',        (char )'0', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'a',        (char )'q',        (char )'u',        (char )'a', 
            (char )'\000'}, 
   {        (char )'8',        (char )'0',        (char )'0',        (char )'0', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'e',        (char )'e', 
            (char )'n',        (char )'\000'}, 
   {        (char )'n',        (char )'a',        (char )'v',        (char )'y', 
            (char )'\000'}, 
   {        (char )'8',        (char )'0',        (char )'8',        (char )'0', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'8',        (char )'0',        (char )'0',        (char )'0', 
            (char )'8',        (char )'0',        (char )'\000'}, 
   {        (char )'t',        (char )'e',        (char )'a',        (char )'l', 
            (char )'\000'}, 
   {        (char )'C',        (char )'0',        (char )'C',        (char )'0', 
            (char )'C',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'\000'}, 
   {        (char )'9',        (char )'9',        (char )'9',        (char )'9', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'9',        (char )'9',        (char )'3',        (char )'3', 
            (char )'6',        (char )'6',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'C',        (char )'C',        (char )'\000'}, 
   {        (char )'C',        (char )'C',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'6',        (char )'6',        (char )'0',        (char )'0', 
            (char )'6',        (char )'6',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'8',        (char )'0', 
            (char )'8',        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'6',        (char )'6', 
            (char )'C',        (char )'C',        (char )'\000'}, 
   {        (char )'C',        (char )'C',        (char )'C',        (char )'C', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'0',        (char )'0', 
            (char )'8',        (char )'0',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'0',        (char )'0', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'8',        (char )'0',        (char )'0',        (char )'0', 
            (char )'8',        (char )'0',        (char )'\000'}, 
   {        (char )'8',        (char )'0',        (char )'0',        (char )'0', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'8',        (char )'0', 
            (char )'8',        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'0',        (char )'0', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'C',        (char )'C', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'C',        (char )'C',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'C',        (char )'C',        (char )'F',        (char )'F', 
            (char )'C',        (char )'C',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'9',        (char )'9',        (char )'\000'}, 
   {        (char )'9',        (char )'9',        (char )'C',        (char )'C', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'9',        (char )'9', 
            (char )'C',        (char )'C',        (char )'\000'}, 
   {        (char )'C',        (char )'C',        (char )'9',        (char )'9', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'C',        (char )'C', 
            (char )'9',        (char )'9',        (char )'\000'}, 
   {        (char )'3',        (char )'3',        (char )'6',        (char )'6', 
            (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'3',        (char )'3',        (char )'C',        (char )'C', 
            (char )'C',        (char )'C',        (char )'\000'}, 
   {        (char )'9',        (char )'9',        (char )'C',        (char )'C', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'C',        (char )'C', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'9',        (char )'9', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'6',        (char )'6', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'6',        (char )'6',        (char )'6',        (char )'6', 
            (char )'9',        (char )'9',        (char )'\000'}, 
   {        (char )'9',        (char )'6',        (char )'9',        (char )'6', 
            (char )'9',        (char )'6',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'3',        (char )'3', 
            (char )'6',        (char )'6',        (char )'\000'}, 
   {        (char )'3',        (char )'3',        (char )'9',        (char )'9', 
            (char )'6',        (char )'6',        (char )'\000'}, 
   {        (char )'0',        (char )'0',        (char )'3',        (char )'3', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'3',        (char )'3',        (char )'3',        (char )'3', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'9',        (char )'9',        (char )'3',        (char )'3', 
            (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'9',        (char )'9',        (char )'3',        (char )'3', 
            (char )'6',        (char )'6',        (char )'\000'}, 
   {        (char )'3',        (char )'3',        (char )'3',        (char )'3', 
            (char )'9',        (char )'9',        (char )'\000'}, 
   {        (char )'3',        (char )'3',        (char )'3',        (char )'3', 
            (char )'3',        (char )'3',        (char )'\000'}, 
   {        (char )'F',        (char )'F',        (char )'F',        (char )'F', 
            (char )'F',        (char )'F',        (char )'\000'}};
#line 113 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int DatesR1904  =    0;
#line 116 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char const   month_abbr[12][5]  = 
#line 116
  { {        (char const   )'J',        (char const   )'a',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'F',        (char const   )'e',        (char const   )'b',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'A',        (char const   )'p',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'y',        (char const   )'\000'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'n',        (char const   )'e', 
            (char const   )'\000'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'l',        (char const   )'y', 
            (char const   )'\000'}, 
   {        (char const   )'A',        (char const   )'u',        (char const   )'g',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'e',        (char const   )'p',        (char const   )'\000'}, 
   {        (char const   )'O',        (char const   )'c',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'N',        (char const   )'o',        (char const   )'v',        (char const   )'\000'}, 
   {        (char const   )'D',        (char const   )'e',        (char const   )'c',        (char const   )'\000'}};
#line 123
void OutputTableXML(void) ;
#line 126
void OutputPartialTableAscii(void) ;
#line 129
void OutputTableHTML(void) ;
#line 130
void output_start_html_attr(html_attr *h , unsigned int fnt_idx , int do_underlines ) ;
#line 131
void output_end_html_attr(html_attr *h ) ;
#line 132
void output_footer(void) ;
#line 133
void output_header(void) ;
#line 135
void scan_file(COLEDIRENT *cde , void *_info ) ;
#line 136
void main_line_processor(unsigned short opcode , unsigned short version , unsigned int count ,
                         unsigned short last , unsigned char data ) ;
#line 137
void decodeBoolErr(unsigned short value , unsigned short flag , char *str ) ;
#line 138
void PrintFloatComma(char *fformat , int is_currency , double d ) ;
#line 139
void print_as_fraction(double d , int digits ) ;
#line 140
void incr_f_cnt(uni_string *name ) ;
#line 141
int get_default_font(void) ;
#line 142
void OutputCharCorrected(unsigned char c ) ;
#line 143
void update_crun_info(unsigned short *loc , unsigned short *fmt_idx , unsigned short crun_cnt ,
                      unsigned char *fmt_run ) ;
#line 144
void put_utf8(unsigned short c ) ;
#line 145
void print_utf8(unsigned short c ) ;
#line 146
void uni_string_clear(uni_string *str ) ;
#line 147
int uni_string_comp(uni_string *s1 , uni_string *s2 ) ;
#line 148
void html_flag_init(html_attr *h ) ;
#line 149
void output_start_font_attribute(html_attr *h , unsigned short fnt_idx ) ;
#line 152
int ws_init(int i ) ;
#line 153
int add_more_worksheet_ptrs(void) ;
#line 154
int resize_c_array(work_sheet *ws , unsigned int new_rows , unsigned short new_cols ) ;
#line 155
void add_wb_array(unsigned short r , unsigned short c , unsigned short xf , unsigned short type ,
                  unsigned char uni , unsigned char *str , unsigned short len , unsigned short crun_cnt ,
                  unsigned char *fmt_run ) ;
#line 156
void update_cell_xf(unsigned short r , unsigned short c , unsigned short xf ) ;
#line 157
void update_cell_hyperlink(unsigned short r , unsigned short c , unsigned char *hyperlink ,
                           int len , unsigned short uni ) ;
#line 158
void add_str_array(unsigned char uni , unsigned char *str , unsigned short len , unsigned char *fmt_run ,
                   unsigned char crun_cnt ) ;
#line 159
void add_font(unsigned short size , unsigned short attr , unsigned short c_idx , unsigned short bold ,
              unsigned short super , unsigned char underline , unsigned short uni ,
              unsigned char *n , unsigned short len ) ;
#line 160
void add_ws_title(unsigned short uni , unsigned char *n , unsigned short len ) ;
#line 161
void add_xf_array(unsigned short fnt_idx , unsigned short fmt_idx , unsigned short gen ,
                  unsigned short align , unsigned short indent , unsigned short b_style ,
                  unsigned short b_l_color , unsigned int b_t_color , unsigned short cell_color ) ;
#line 167 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int file_version  =    0;
#line 168 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int next_string  =    0U;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int next_font  =    0U;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int next_ws_title  =    0U;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int next_xf  =    0U;
#line 170 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int sheet_count  =    -2;
#line 172 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int default_fontsize  =    3;
#line 173 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char *default_alignment  =    (char *)0;
#line 174 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int first_sheet  =    0;
#line 175 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int last_sheet  =    3;
#line 176 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
short xp  =    (short)0;
#line 176 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
short xr1  =    (short)-1;
#line 176 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
short xr2  =    (short)-1;
#line 176 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
short xc1  =    (short)-1;
#line 176 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
short xc2  =    (short)-1;
#line 177 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int currency_symbol  =    '$';
#line 178 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned short str_formula_row  =    (unsigned short)0;
#line 179 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned short str_formula_col  =    (unsigned short)0;
#line 180 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned short str_formula_format  =    (unsigned short)0;
#line 183 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int max_fonts  =    32U;
#line 184 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int max_xformats  =    64U;
#line 185 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned long max_strings  =    256UL;
#line 186 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
unsigned int max_worksheets  =    4U;
#line 192 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
uni_string **str_array  ;
#line 194 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
fnt_cnt *f_cnt  ;
#line 195 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int fnt_size_cnt[7]  ;
#line 197 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char *title  =    (char *)0;
#line 198 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char *lastUpdated  =    (char *)0;
#line 201 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int use_colors  =    1;
#line 202 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int aggressive  =    0;
#line 203 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int formula_warnings  =    1;
#line 204 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int center_tables  =    0;
#line 205 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int trim_edges  =    0;
#line 206 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char *default_text_color  =    (char *)"000000";
#line 207 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char *default_background_color  =    (char *)"FFFFFF";
#line 208 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
char *default_image  =    (char *)((void *)0);
#line 209 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int Ascii  =    0;
#line 210 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int Csv  =    0;
#line 211 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int OutputXML  =    0;
#line 212 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int DumpPage  =    0;
#line 213 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int Xtract  =    0;
#line 214 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MultiByte  =    0;
#line 215 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int NoHeaders  =    0;
#line 219 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int notAccurate  =    0;
#line 220 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int NoFormat  =    0;
#line 221 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int NotImplemented  =    0;
#line 222 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int Unsupported  =    0;
#line 223 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxPalExceeded  =    0;
#line 224 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxXFExceeded  =    0;
#line 225 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxFormatsExceeded  =    0;
#line 226 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxColExceeded  =    0;
#line 227 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxRowExceeded  =    0;
#line 228 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxWorksheetsExceeded  =    0;
#line 229 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxStringsExceeded  =    0;
#line 230 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int MaxFontsExceeded  =    0;
#line 231 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int UnicodeStrings  =    0;
#line 232 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int CodePage  =    0;
#line 531 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void scan_file(COLEDIRENT *cde , void *_info ) 
{ 
  unsigned int count ;
  unsigned short target ;
  unsigned short opcode ;
  unsigned short version ;
  unsigned char buf[16] ;
  COLEFILE *cf ;
  COLERRNO err ;
  size_t tmp ;
  int i ;
  char const   *tmp___0 ;
  int i___0 ;
  char const   *tmp___1 ;

  {
  {
#line 533
  count = 0U;
#line 534
  target = (unsigned short)0;
#line 534
  opcode = (unsigned short)0;
#line 534
  version = (unsigned short)0;
#line 539
  cf = cole_fopen_direntry(cde, & err);
  }
#line 540
  if ((unsigned long )cf == (unsigned long )((COLEFILE *)0)) {
    {
#line 542
    cole_perror("xlhtml", err);
    }
#line 543
    return;
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 547
    tmp = cole_fread(cf, (void *)(buf), (size_t )1, & err);
    }
#line 547
    if (! tmp) {
#line 547
      goto while_break;
    }
#line 555
    if (count > 3U) {
      {
#line 556
      main_line_processor(opcode, version, count - 4U, target, buf[0]);
      }
    } else
#line 557
    if (count == 0U) {
#line 558
      opcode = (unsigned short )buf[0];
    } else
#line 559
    if (count == 1U) {
#line 560
      version = (unsigned short )buf[0];
    } else
#line 561
    if (count == 2U) {
#line 562
      target = (unsigned short )buf[0];
    } else
#line 563
    if (count == 3U) {
#line 564
      target = (unsigned short )((int )target | (int )((unsigned short )((int )buf[0] << 8)));
    }
#line 565
    if (count >= 3U) {
#line 565
      if (count == (unsigned int )target + 3U) {
#line 566
        count = 0U;
      } else {
#line 568
        count ++;
      }
    } else {
#line 568
      count ++;
    }
#line 570
    if (MaxColExceeded) {
#line 571
      goto while_break;
    } else
#line 570
    if (MaxRowExceeded) {
#line 571
      goto while_break;
    } else
#line 570
    if (MaxWorksheetsExceeded) {
#line 571
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 574
  cole_fclose(cf, & err);
  }
#line 576
  if (Ascii) {
#line 578
    if (DumpPage) {
      {
#line 581
      printf((char const   */* __restrict  */)"There are %d pages total.\n", sheet_count + 1);
#line 582
      i = 0;
      }
      {
#line 582
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 582
        if (! (i <= sheet_count)) {
#line 582
          goto while_break___0;
        }
#line 584
        if ((*(ws_array + i))->ws_title.str) {
#line 584
          tmp___0 = (char const   *)((char *)(*(ws_array + i))->ws_title.str);
        } else {
#line 584
          tmp___0 = "(Unknown Page)";
        }
        {
#line 584
        printf((char const   */* __restrict  */)"Page:%d Name:%s MaxRow:%ld MaxCol:%ld\n",
               i, tmp___0, (long )(*(ws_array + i))->biggest_row, (long )(*(ws_array + i))->biggest_col);
#line 582
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 589
    if (Xtract) {
      {
#line 590
      OutputPartialTableAscii();
      }
    }
  } else
#line 594
  if (DumpPage) {
    {
#line 597
    output_header();
#line 598
    printf((char const   */* __restrict  */)"<p>There are %d pages total.</p>\n",
           sheet_count + 1);
#line 599
    i___0 = 0;
    }
    {
#line 599
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 599
      if (! (i___0 <= sheet_count)) {
#line 599
        goto while_break___1;
      }
#line 601
      if ((*(ws_array + i___0))->ws_title.str) {
#line 601
        tmp___1 = (char const   *)((char *)(*(ws_array + i___0))->ws_title.str);
      } else {
#line 601
        tmp___1 = "(Unknown Page)";
      }
      {
#line 601
      printf((char const   */* __restrict  */)"<p>Page:%d Name:%s MaxRow:%ld MaxCol:%ld</p>\n",
             i___0, tmp___1, (long )(*(ws_array + i___0))->biggest_row, (long )(*(ws_array + i___0))->biggest_col);
#line 599
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 606
    output_footer();
    }
  } else
#line 610
  if (OutputXML) {
    {
#line 611
    OutputTableXML();
    }
  } else {
    {
#line 613
    OutputTableHTML();
    }
  }
#line 616
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void SetupExtraction(void) 
{ 


  {
#line 622
  if (Xtract) {
#line 625
    if ((int )xp >= first_sheet) {
#line 625
      if ((int )xp <= last_sheet) {
#line 625
        if ((int )xp <= sheet_count) {
#line 627
          first_sheet = (int )xp;
#line 628
          last_sheet = (int )xp;
#line 629
          if ((int )xr1 < 0) {
#line 631
            xr1 = (short )(*(ws_array + xp))->first_row;
#line 632
            xr2 = (short )(*(ws_array + xp))->biggest_row;
          } else
#line 634
          if ((unsigned int )xr1 >= (*(ws_array + xp))->first_row) {
#line 634
            if ((int )xr1 <= (*(ws_array + xp))->biggest_row) {
#line 634
              if ((unsigned int )xr2 >= (*(ws_array + xp))->first_row) {
#line 634
                if ((int )xr2 <= (*(ws_array + xp))->biggest_row) {
#line 637
                  (*(ws_array + xp))->first_row = (unsigned int )xr1;
#line 638
                  (*(ws_array + xp))->biggest_row = (int )xr2;
#line 640
                  if ((int )xc1 < 0) {
#line 642
                    xc1 = (short )(*(ws_array + xp))->first_col;
#line 643
                    xc2 = (*(ws_array + xp))->biggest_col;
                  } else
#line 645
                  if ((int )xc1 >= (int )(*(ws_array + xp))->first_col) {
#line 645
                    if ((int )xc1 <= (int )(*(ws_array + xp))->biggest_col) {
#line 645
                      if ((int )xc2 >= (int )(*(ws_array + xp))->first_col) {
#line 645
                        if ((int )xc2 <= (int )(*(ws_array + xp))->biggest_col) {
#line 648
                          (*(ws_array + xp))->first_col = (unsigned short )xc1;
#line 649
                          (*(ws_array + xp))->biggest_col = xc2;
                        } else {
#line 645
                          goto _L___1;
                        }
                      } else {
#line 645
                        goto _L___1;
                      }
                    } else {
#line 645
                      goto _L___1;
                    }
                  } else {
                    _L___1: /* CIL Label */ 
#line 653
                    if (Ascii) {
                      {
#line 654
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - Col not in range during extraction (%d or %d not in [%d..%d])\n",
                              (int )xc1, (int )xc2, (int )(*(ws_array + xp))->first_col,
                              (int )(*(ws_array + xp))->biggest_col);
                      }
                    } else {
                      {
#line 658
                      printf((char const   */* __restrict  */)"Error - Col not in range during extraction.\n");
#line 660
                      output_footer();
                      }
                    }
#line 662
                    return;
                  }
                } else {
#line 634
                  goto _L___4;
                }
              } else {
#line 634
                goto _L___4;
              }
            } else {
#line 634
              goto _L___4;
            }
          } else {
            _L___4: /* CIL Label */ 
#line 667
            if (Ascii) {
              {
#line 668
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - Row not in range during extraction (%d or %d not in [%ld..%ld])\n",
                      (int )xr1, (int )xr2, (long )(*(ws_array + xp))->first_row,
                      (long )(*(ws_array + xp))->biggest_row);
              }
            } else {
              {
#line 672
              printf((char const   */* __restrict  */)"Error - Row not in range during extraction.");
#line 673
              output_footer();
              }
            }
#line 675
            return;
          }
        } else {
#line 625
          goto _L___6;
        }
      } else {
#line 625
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 680
      if (Ascii) {
        {
#line 681
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error - Page not in range during extraction.");
        }
      } else {
        {
#line 684
        printf((char const   */* __restrict  */)"Error - Page not in range during extraction.");
#line 685
        output_footer();
        }
      }
#line 687
      return;
    }
  }
#line 690
  return;
}
}
#line 706 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned short last_opcode  =    (unsigned short)65535;
#line 707 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned char working_buffer[8240]  ;
#line 708 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned int bufidx  =    0U;
#line 709 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned int buflast  =    0U;
#line 711 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned char str_options  =    (unsigned char)0;
#line 712 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static int buf_16bit  =    0;
#line 713 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static int now_16bit  =    0;
#line 714 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static int after_str_header  =    0;
#line 715 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned short num_chars  =    (unsigned short)0;
#line 716 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned short num_fmt_runs  =    (unsigned short)0;
#line 717 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned int fareast_bytes  =    0U;
#line 718 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
static unsigned short nonascii  =    (unsigned short)0;
#line 703 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void main_line_processor(unsigned short opcode , unsigned short version , unsigned int count ,
                         unsigned short last , unsigned char data ) 
{ 
  int cont_opcode ;
  unsigned int tmp ;
  unsigned short tmp___0 ;
  unsigned int tmp___1 ;
  unsigned short r ;
  unsigned short c ;
  unsigned short f ;
  unsigned int tmp___2 ;
  unsigned short r___0 ;
  unsigned short c___0 ;
  unsigned short i ;
  unsigned short f___0 ;
  char temp[32] ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  unsigned int tmp___5 ;
  unsigned short r___1 ;
  unsigned short c___1 ;
  unsigned short f___1 ;
  double d ;
  char temp___0[64] ;
  size_t tmp___6 ;
  unsigned int tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short r___2 ;
  unsigned short c___2 ;
  unsigned short l ;
  unsigned short f___2 ;
  size_t tmp___9 ;
  unsigned int tmp___10 ;
  unsigned short r___3 ;
  unsigned short c___3 ;
  unsigned short f___3 ;
  size_t tmp___11 ;
  unsigned short r___4 ;
  unsigned short c___4 ;
  unsigned short f___4 ;
  unsigned short len ;
  size_t tmp___12 ;
  unsigned int tmp___13 ;
  unsigned short r___5 ;
  unsigned short c___5 ;
  unsigned short f___5 ;
  char temp___1[16] ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int i___0 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char uni ;
  unsigned short len___0 ;
  unsigned int i___1 ;
  unsigned short r___6 ;
  unsigned short c___6 ;
  unsigned short f___6 ;
  int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int i___2 ;
  unsigned short size ;
  unsigned short attr ;
  unsigned short c_idx ;
  unsigned short b ;
  unsigned short su ;
  unsigned char u ;
  unsigned int i___3 ;
  unsigned short len___1 ;
  unsigned short size___0 ;
  unsigned short attr___0 ;
  unsigned short c_idx___0 ;
  unsigned short b___0 ;
  unsigned short su___0 ;
  unsigned char u___0 ;
  unsigned char uni___0 ;
  unsigned int tmp___22 ;
  unsigned short r___7 ;
  unsigned short c___7 ;
  unsigned short f___7 ;
  unsigned char calc_val[64] ;
  double n ;
  size_t tmp___23 ;
  unsigned int tmp___24 ;
  unsigned char *str ;
  unsigned char uni___1 ;
  unsigned short len___2 ;
  unsigned short tmp___25 ;
  int t ;
  size_t tmp___26 ;
  unsigned int tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  unsigned int tmp___30 ;
  unsigned short i___4 ;
  unsigned short r___8 ;
  unsigned short fc ;
  unsigned short lc ;
  unsigned short d___0 ;
  unsigned short xf ;
  unsigned short tmp___31 ;
  int tmp___32 ;
  int diff ;
  int tmp___33 ;
  int diff___0 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned short tmp___36 ;
  unsigned int tmp___37 ;
  unsigned short len___3 ;
  unsigned char uni___2 ;
  unsigned int tmp___38 ;
  unsigned short r___9 ;
  unsigned short c___8 ;
  unsigned short f___8 ;
  unsigned int t___0 ;
  int n___0 ;
  int n2 ;
  double d___1 ;
  char temp___2[64] ;
  size_t tmp___39 ;
  unsigned int tmp___40 ;
  unsigned short fr ;
  unsigned short lr ;
  unsigned short fc___0 ;
  unsigned short lc___0 ;
  unsigned short i___5 ;
  unsigned short j ;
  unsigned int tmp___41 ;
  unsigned short r___10 ;
  unsigned short fc___1 ;
  unsigned short lc___1 ;
  int i___6 ;
  unsigned int t___1 ;
  int n2___0 ;
  int n___1 ;
  unsigned short f___9 ;
  double d___2 ;
  char temp___3[64] ;
  size_t tmp___42 ;
  unsigned int tmp___43 ;
  unsigned short r___11 ;
  unsigned short fc___2 ;
  unsigned short lc___2 ;
  unsigned short j___0 ;
  unsigned short f___10 ;
  unsigned int tmp___44 ;
  char *ptr ;
  char *tmp___45 ;
  size_t tmp___46 ;
  void *tmp___47 ;
  char *tmp___48 ;
  size_t tmp___49 ;
  void *tmp___50 ;
  unsigned int tmp___51 ;
  unsigned short fnt_idx ;
  unsigned short fmt_idx ;
  unsigned short gen ;
  unsigned short align ;
  unsigned short indent ;
  unsigned short b_style ;
  unsigned short b_l_color ;
  unsigned int b_t_color ;
  unsigned short cell_color ;
  unsigned short tmp___52 ;
  int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned short num ;
  unsigned short fr___0 ;
  unsigned short lr___0 ;
  unsigned short fc___3 ;
  unsigned short lc___3 ;
  unsigned short i___7 ;
  unsigned short j___1 ;
  unsigned short k ;
  cell *c___9 ;
  int tmp___55 ;
  unsigned int tmp___56 ;
  unsigned short r___12 ;
  unsigned short c___10 ;
  unsigned short uni_type ;
  unsigned short off ;
  unsigned int len___4 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  unsigned int tmp___60 ;
  int i___8 ;
  unsigned char red ;
  unsigned char green ;
  unsigned char blue ;
  unsigned short cnt ;
  unsigned short tmp___61 ;
  void *tmp___62 ;
  char color_string[8] ;
  char *tmp___63 ;
  unsigned int tmp___64 ;
  unsigned short tmp___65 ;

  {
#line 705
  cont_opcode = 0;
#line 721
  if (count == 0U) {
#line 723
    if ((int )opcode != 60) {
      {
#line 725
      last_opcode = opcode;
#line 726
      bufidx = 0U;
#line 727
      buflast = 0U;
#line 728
      memset((void *)(working_buffer), 0, (size_t )8240);
      }
    }
  }
#line 731
  if ((int )opcode == 60) {
#line 733
    opcode = last_opcode;
#line 734
    cont_opcode = 1;
  }
#line 738
  if (bufidx >= 8240U) {
    {
#line 743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: working buffer overflow!\n");
    }
#line 744
    return;
  }
#line 748
  if ((int )version == 16) {
#line 749
    return;
  }
  {
#line 753
  if ((int )opcode == 47) {
#line 753
    goto case_47;
  }
#line 756
  if ((int )opcode == 9) {
#line 756
    goto case_9;
  }
#line 782
  if ((int )opcode == 1) {
#line 782
    goto case_1;
  }
#line 797
  if ((int )opcode == 2) {
#line 797
    goto case_2;
  }
#line 821
  if ((int )opcode == 3) {
#line 821
    goto case_3;
  }
#line 846
  if ((int )opcode == 214) {
#line 846
    goto case_214;
  }
#line 867
  if ((int )opcode == 4) {
#line 867
    goto case_4;
  }
#line 923
  if ((int )opcode == 5) {
#line 923
    goto case_5;
  }
#line 947
  if ((int )opcode == 252) {
#line 947
    goto case_252;
  }
#line 1118
  if ((int )opcode == 253) {
#line 1118
    goto case_253;
  }
#line 1149
  if ((int )opcode == 49) {
#line 1149
    goto case_49;
  }
#line 1219
  if ((int )opcode == 20) {
#line 1219
    goto case_20;
  }
#line 1221
  if ((int )opcode == 21) {
#line 1221
    goto case_21;
  }
#line 1223
  if ((int )opcode == 6) {
#line 1223
    goto case_6;
  }
#line 1263
  if ((int )opcode == 7) {
#line 1263
    goto case_7;
  }
#line 1307
  if ((int )opcode == 92) {
#line 1307
    goto case_92;
  }
#line 1343
  if ((int )opcode == 8) {
#line 1343
    goto case_8;
  }
#line 1417
  if ((int )opcode == 34) {
#line 1417
    goto case_34;
  }
#line 1422
  if ((int )opcode == 133) {
#line 1422
    goto case_133;
  }
#line 1456
  if ((int )opcode == 126) {
#line 1456
    goto case_126;
  }
#line 1493
  if ((int )opcode == 188) {
#line 1493
    goto case_188;
  }
#line 1510
  if ((int )opcode == 33) {
#line 1510
    goto case_33;
  }
#line 1527
  if ((int )opcode == 189) {
#line 1527
    goto case_189;
  }
#line 1571
  if ((int )opcode == 190) {
#line 1571
    goto case_190;
  }
#line 1586
  if ((int )opcode == 24) {
#line 1586
    goto case_24;
  }
#line 1613
  if ((int )opcode == 224) {
#line 1613
    goto case_224;
  }
#line 1652
  if ((int )opcode == 229) {
#line 1652
    goto case_229;
  }
#line 1720
  if ((int )opcode == 184) {
#line 1720
    goto case_184;
  }
#line 1755
  if ((int )opcode == 146) {
#line 1755
    goto case_146;
  }
#line 1776
  if ((int )opcode == 66) {
#line 1776
    goto case_66;
  }
#line 1785
  goto switch_default___1;
  case_47: /* CIL Label */ 
  {
#line 754
  printf((char const   */* __restrict  */)"File is password protected. Exiting...");
#line 755
  exit(1);
  }
  case_9: /* CIL Label */ 
#line 757
  tmp = bufidx;
#line 757
  bufidx ++;
#line 757
  working_buffer[tmp] = data;
#line 758
  if (bufidx == (unsigned int )last) {
#line 760
    if (file_version == 0) {
#line 766
      if ((int )version == 8) {
        {
#line 767
        tmp___0 = getShort(& working_buffer[0]);
#line 767
        file_version = (int )tmp___0;
        }
      } else {
#line 769
        file_version = (int )version;
      }
#line 770
      if (file_version == 1280) {
#line 772
        use_colors = 0;
#line 773
        HARD_MAX_ROWS = (unsigned short)16383;
      }
    }
#line 777
    sheet_count ++;
#line 778
    if (sheet_count >= (int )max_worksheets) {
      {
#line 779
      add_more_worksheet_ptrs();
      }
    }
  }
#line 781
  goto switch_break;
  case_1: /* CIL Label */ 
#line 783
  tmp___1 = bufidx;
#line 783
  bufidx ++;
#line 783
  working_buffer[tmp___1] = data;
#line 784
  if (bufidx == (unsigned int )last) {
    {
#line 788
    r = getShort(& working_buffer[0]);
#line 789
    c = getShort(& working_buffer[2]);
    }
#line 790
    if ((int )version == 2) {
      {
#line 791
      f = getShort(& working_buffer[4]);
      }
    } else {
#line 793
      f = (unsigned short)0;
    }
    {
#line 794
    add_wb_array(r, c, f, opcode, (unsigned char)0, (unsigned char *)0, (unsigned short)0,
                 (unsigned short)0, (unsigned char *)0);
    }
  }
#line 796
  goto switch_break;
  case_2: /* CIL Label */ 
#line 798
  tmp___2 = bufidx;
#line 798
  bufidx ++;
#line 798
  working_buffer[tmp___2] = data;
#line 799
  if (bufidx == (unsigned int )last) {
    {
#line 804
    r___0 = getShort(& working_buffer[0]);
#line 805
    c___0 = getShort(& working_buffer[2]);
    }
#line 806
    if ((int )version == 2) {
      {
#line 808
      f___0 = getShort(& working_buffer[4]);
#line 809
      i = getShort(& working_buffer[7]);
#line 810
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
              (int )i);
      }
    } else {
#line 814
      f___0 = (unsigned short)0;
#line 815
      Unsupported ++;
#line 816
      if (OutputXML) {
#line 816
        tmp___3 = "<Unsupported/>INT";
      } else {
#line 816
        tmp___3 = "****INT";
      }
      {
#line 816
      strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___3);
      }
    }
    {
#line 818
    tmp___4 = strlen((char const   *)(temp));
#line 818
    add_wb_array(r___0, c___0, f___0, opcode, (unsigned char)0, (unsigned char *)(temp),
                 (unsigned short )tmp___4, (unsigned short)0, (unsigned char *)((void *)0));
    }
  }
#line 820
  goto switch_break;
  case_3: /* CIL Label */ 
#line 822
  tmp___5 = bufidx;
#line 822
  bufidx ++;
#line 822
  working_buffer[tmp___5] = data;
#line 823
  if (bufidx == (unsigned int )last) {
    {
#line 829
    r___1 = getShort(& working_buffer[0]);
#line 830
    c___1 = getShort(& working_buffer[2]);
    }
#line 831
    if ((int )version == 2) {
      {
#line 833
      f___1 = getShort(& working_buffer[4]);
#line 834
      getDouble(& working_buffer[6], & d);
#line 835
      sprintf((char */* __restrict  */)(temp___0), (char const   */* __restrict  */)"%.15g",
              d);
      }
    } else {
      {
#line 839
      f___1 = (unsigned short)0;
#line 840
      Unsupported = 1;
#line 841
      sprintf((char */* __restrict  */)(temp___0), (char const   */* __restrict  */)"****FPv:%d",
              (int )version);
      }
    }
    {
#line 843
    tmp___6 = strlen((char const   *)(temp___0));
#line 843
    add_wb_array(r___1, c___1, f___1, opcode, (unsigned char)0, (unsigned char *)(temp___0),
                 (unsigned short )tmp___6, (unsigned short)0, (unsigned char *)0);
    }
  }
#line 845
  goto switch_break;
  case_214: /* CIL Label */ 
#line 847
  tmp___7 = bufidx;
#line 847
  bufidx ++;
#line 847
  working_buffer[tmp___7] = data;
#line 848
  if (bufidx == 8U) {
#line 848
    if (buflast == 0U) {
      {
#line 849
      tmp___8 = getShort(& working_buffer[6]);
#line 849
      buflast = (unsigned int )(8 + (int )tmp___8);
      }
    }
  }
#line 850
  if (buflast) {
#line 852
    if (bufidx == buflast) {
      {
#line 856
      r___2 = getShort(& working_buffer[0]);
#line 857
      c___2 = getShort(& working_buffer[2]);
#line 858
      f___2 = getShort(& working_buffer[4]);
#line 859
      l = getShort(& working_buffer[6]);
#line 860
      working_buffer[8 + (int )l] = (unsigned char)0;
#line 862
      tmp___9 = strlen((char const   *)((char *)(& working_buffer[8])));
#line 862
      add_wb_array(r___2, c___2, f___2, opcode, (unsigned char)0, & working_buffer[8],
                   (unsigned short )tmp___9, (unsigned short)0, (unsigned char *)0);
      }
    }
  }
#line 866
  goto switch_break;
  case_4: /* CIL Label */ 
#line 868
  tmp___10 = bufidx;
#line 868
  bufidx ++;
#line 868
  working_buffer[tmp___10] = data;
#line 869
  if (file_version == 1280) {
#line 871
    if (bufidx == (unsigned int )last) {
      {
#line 875
      r___3 = getShort(& working_buffer[0]);
#line 876
      c___3 = getShort(& working_buffer[2]);
#line 877
      f___3 = getShort(& working_buffer[4]);
#line 878
      working_buffer[bufidx] = (unsigned char)0;
#line 880
      tmp___11 = strlen((char const   *)((char *)(& working_buffer[8])));
#line 880
      add_wb_array(r___3, c___3, f___3, opcode, (unsigned char)0, & working_buffer[8],
                   (unsigned short )tmp___11, (unsigned short)0, (unsigned char *)0);
      }
    }
  } else
#line 884
  if (file_version == 1536) {
#line 886
    if (bufidx == 8U) {
#line 886
      if (buflast == 0U) {
        {
#line 888
        num_chars = getShort(& working_buffer[6]);
#line 889
        buflast = (unsigned int )((int )num_chars + 9);
        }
      }
    }
#line 891
    if (bufidx == 9U) {
#line 893
      if ((int )working_buffer[8] == 1) {
#line 894
        buflast = (unsigned int )(((int )num_chars << 1) + 9);
      }
    }
#line 896
    if (buflast) {
#line 898
      if (bufidx == buflast) {
        {
#line 903
        r___4 = getShort(& working_buffer[0]);
#line 904
        c___4 = getShort(& working_buffer[2]);
        }
#line 905
        if ((int )version == 2) {
          {
#line 906
          f___4 = getShort(& working_buffer[4]);
          }
        } else {
#line 908
          f___4 = (unsigned short)0;
        }
        {
#line 909
        working_buffer[bufidx] = (unsigned char)0;
#line 911
        tmp___12 = strlen((char const   *)((char *)(& working_buffer[8])));
#line 911
        len = (unsigned short )tmp___12;
        }
#line 912
        if ((int )working_buffer[8] == 1) {
          {
#line 914
          UnicodeStrings = 2;
#line 915
          add_wb_array(r___4, c___4, f___4, opcode, (unsigned char)2, & working_buffer[9],
                       (unsigned short )((int )num_chars << 1), (unsigned short)0,
                       (unsigned char *)0);
          }
        } else {
          {
#line 918
          add_wb_array(r___4, c___4, f___4, opcode, (unsigned char)0, & working_buffer[8],
                       len, (unsigned short)0, (unsigned char *)0);
          }
        }
      }
    }
  }
#line 922
  goto switch_break;
  case_5: /* CIL Label */ 
#line 924
  tmp___13 = bufidx;
#line 924
  bufidx ++;
#line 924
  working_buffer[tmp___13] = data;
#line 925
  if (bufidx == (unsigned int )last) {
    {
#line 930
    r___5 = getShort(& working_buffer[0]);
#line 931
    c___5 = getShort(& working_buffer[2]);
    }
#line 932
    if ((int )version == 2) {
      {
#line 934
      f___5 = getShort(& working_buffer[4]);
#line 935
      decodeBoolErr((unsigned short )working_buffer[6], (unsigned short )working_buffer[7],
                    temp___1);
#line 936
      tmp___14 = strlen((char const   *)(temp___1));
#line 936
      add_wb_array(r___5, c___5, f___5, opcode, (unsigned char)0, (unsigned char *)(temp___1),
                   (unsigned short )tmp___14, (unsigned short)0, (unsigned char *)0);
      }
    } else {
      {
#line 940
      f___5 = (unsigned short)0;
#line 941
      Unsupported = 1;
#line 942
      strcpy((char */* __restrict  */)(temp___1), (char const   */* __restrict  */)"****Bool");
#line 943
      tmp___15 = strlen((char const   *)(temp___1));
#line 943
      add_wb_array(r___5, c___5, f___5, opcode, (unsigned char)0, (unsigned char *)(temp___1),
                   (unsigned short )tmp___15, (unsigned short)0, (unsigned char *)0);
      }
    }
  }
#line 946
  goto switch_break;
  case_252: /* CIL Label */ 
#line 979
  if (count == 0U) {
#line 979
    if (! cont_opcode) {
#line 981
      bufidx = 0U;
#line 982
      after_str_header = 0;
    }
  }
#line 984
  if (count < 8U) {
#line 984
    if (! cont_opcode) {
#line 990
      goto switch_break;
    }
  }
#line 991
  if (count == 0U) {
#line 991
    if (cont_opcode) {
#line 991
      if (after_str_header) {
#line 993
        now_16bit = (int )data & 1;
#line 994
        if (now_16bit) {
#line 994
          if (! buf_16bit) {
#line 1000
            if (2U * buflast >= 8240U) {
#line 1002
              bufidx = 8241U;
#line 1003
              goto switch_break;
            }
#line 1005
            if (bufidx >= (unsigned int )num_chars) {
#line 1009
              now_16bit = 0;
            } else {
#line 1013
              buf_16bit = 1;
#line 1014
              if (bufidx > 0U) {
#line 1015
                i___0 = (int )(bufidx - 1U);
                {
#line 1015
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1015
                  if (! (i___0 >= 0)) {
#line 1015
                    goto while_break;
                  }
#line 1016
                  working_buffer[2 * i___0] = working_buffer[i___0];
#line 1017
                  working_buffer[2 * i___0 + 1] = (unsigned char)0;
#line 1015
                  i___0 --;
                }
                while_break: /* CIL Label */ ;
                }
              }
#line 1019
              bufidx = 2U * bufidx;
#line 1020
              buflast = (unsigned int )(2 * (int )num_chars + 4 * (int )num_fmt_runs) + fareast_bytes;
            }
          }
        }
#line 1023
        goto switch_break;
      }
    }
  }
#line 1026
  tmp___16 = bufidx;
#line 1026
  bufidx ++;
#line 1026
  working_buffer[tmp___16] = data;
#line 1027
  if (buf_16bit) {
#line 1027
    if (! now_16bit) {
#line 1027
      if (after_str_header) {
#line 1027
        if (bufidx < (unsigned int )(2 * (int )num_chars)) {
#line 1029
          tmp___17 = bufidx;
#line 1029
          bufidx ++;
#line 1029
          working_buffer[tmp___17] = (unsigned char)0;
        }
      }
    }
  }
#line 1031
  if (! after_str_header) {
#line 1033
    if (bufidx == 3U) {
      {
#line 1035
      num_chars = getShort(& working_buffer[0]);
#line 1036
      str_options = working_buffer[2];
#line 1037
      buf_16bit = (int )str_options & 1;
#line 1037
      now_16bit = buf_16bit;
      }
    }
#line 1039
    if (bufidx == 3U) {
#line 1039
      if (((int )str_options & 12) == 0) {
#line 1041
        num_fmt_runs = (unsigned short)0;
#line 1042
        fareast_bytes = 0U;
#line 1043
        buflast = (unsigned int )((int )num_chars << buf_16bit);
#line 1044
        after_str_header = 1;
      } else {
#line 1039
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1046
    if (bufidx == 5U) {
#line 1046
      if (((int )str_options & 12) == 8) {
        {
#line 1048
        num_fmt_runs = getShort(& working_buffer[3]);
#line 1049
        fareast_bytes = 0U;
#line 1050
        buflast = (unsigned int )(((int )num_chars << buf_16bit) + (int )num_fmt_runs * 4);
#line 1051
        after_str_header = 1;
        }
      } else {
#line 1046
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1053
    if (bufidx == 7U) {
#line 1053
      if (((int )str_options & 12) == 4) {
        {
#line 1055
        num_fmt_runs = (unsigned short)0;
#line 1056
        tmp___18 = getLong(& working_buffer[3]);
#line 1056
        fareast_bytes = (unsigned int )tmp___18;
#line 1057
        buflast = (unsigned int )((int )num_chars << buf_16bit) + fareast_bytes;
#line 1058
        after_str_header = 1;
        }
      } else {
#line 1053
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1060
    if (bufidx == 9U) {
#line 1060
      if (((int )str_options & 12) == 12) {
        {
#line 1062
        num_fmt_runs = getShort(& working_buffer[3]);
#line 1063
        tmp___19 = getLong(& working_buffer[5]);
#line 1063
        fareast_bytes = (unsigned int )tmp___19;
#line 1064
        buflast = ((unsigned int )((int )num_chars << buf_16bit) + fareast_bytes) + (unsigned int )((int )num_fmt_runs * 4);
#line 1065
        after_str_header = 1;
        }
      } else {
#line 1060
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1067
    if (bufidx >= 9U) {
      {
#line 1069
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error in SST processing occured. Please contact the author.\n");
#line 1070
      bufidx = 8241U;
      }
#line 1071
      goto switch_break;
    }
#line 1073
    if (after_str_header) {
#line 1075
      if (buflast == 0U) {
        {
#line 1077
        add_str_array((unsigned char)0, (unsigned char *)0, (unsigned short)0, (unsigned char *)0,
                      (unsigned char)0);
#line 1078
        after_str_header = 0;
        }
      } else {
        {
#line 1082
        memset((void *)(working_buffer), 0, (size_t )8240);
#line 1083
        nonascii = (unsigned short)0;
        }
      }
#line 1085
      bufidx = 0U;
    }
  } else {
#line 1090
    if ((int )data > 127) {
#line 1091
      nonascii = (unsigned short)1;
    }
#line 1092
    if (bufidx == buflast) {
#line 1095
      len___0 = (unsigned short )((int )num_chars << buf_16bit);
#line 1097
      if (buf_16bit) {
#line 1099
        uni = (unsigned char)2;
#line 1100
        UnicodeStrings = 2;
      } else {
#line 1103
        uni = (unsigned char )nonascii;
      }
#line 1104
      working_buffer[bufidx] = (unsigned char)0;
#line 1106
      if (num_fmt_runs) {
        {
#line 1107
        add_str_array(uni, working_buffer, len___0, working_buffer + (int )len___0,
                      (unsigned char )num_fmt_runs);
        }
      } else {
        {
#line 1109
        add_str_array(uni, working_buffer, len___0, (unsigned char *)0, (unsigned char)0);
        }
      }
#line 1110
      if ((int )uni > UnicodeStrings) {
#line 1111
        UnicodeStrings = (int )uni;
      }
      {
#line 1112
      bufidx = 0U;
#line 1113
      after_str_header = 0;
#line 1114
      memset((void *)(working_buffer), 0, (size_t )8240);
      }
    }
  }
#line 1117
  goto switch_break;
  case_253: /* CIL Label */ 
#line 1119
  working_buffer[count] = data;
#line 1120
  if (count == (unsigned int )((int )last - 1)) {
    {
#line 1126
    r___6 = getShort(& working_buffer[0]);
#line 1127
    c___6 = getShort(& working_buffer[2]);
#line 1128
    f___6 = getShort(& working_buffer[4]);
#line 1129
    tmp___20 = getLong(& working_buffer[6]);
#line 1129
    i___1 = (unsigned int )tmp___20;
    }
#line 1130
    if (i___1 < next_string) {
#line 1133
      if (*(str_array + i___1)) {
#line 1135
        if ((*(str_array + i___1))->str) {
          {
#line 1136
          add_wb_array(r___6, c___6, f___6, opcode, (*(str_array + i___1))->uni, (*(str_array + i___1))->str,
                       (*(str_array + i___1))->len, (unsigned short )(*(str_array + i___1))->crun_cnt,
                       (*(str_array + i___1))->fmt_run);
          }
        }
      } else {
        {
#line 1142
        add_wb_array(r___6, c___6, f___6, opcode, (unsigned char)0, (unsigned char *)"String Table Error",
                     (unsigned short)18, (unsigned short)0, (unsigned char *)0);
        }
      }
    } else {
#line 1146
      MaxStringsExceeded = 1;
    }
  }
#line 1148
  goto switch_break;
  case_49: /* CIL Label */ 
#line 1150
  tmp___21 = bufidx;
#line 1150
  bufidx ++;
#line 1150
  working_buffer[tmp___21] = data;
#line 1151
  if (file_version == 1280) {
#line 1151
    if (bufidx == (unsigned int )last) {
#line 1151
      if ((int )last >= 15) {
        {
#line 1158
        size = getShort(& working_buffer[0]);
#line 1159
        attr = getShort(& working_buffer[2]);
#line 1160
        c_idx = getShort(& working_buffer[4]);
#line 1161
        b = getShort(& working_buffer[6]);
#line 1162
        su = getShort(& working_buffer[8]);
#line 1163
        u = working_buffer[10];
#line 1164
        buflast = (unsigned int )working_buffer[14];
#line 1165
        i___2 = 0U;
        }
        {
#line 1165
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1165
          if (! (i___2 < buflast)) {
#line 1165
            goto while_break___0;
          }
#line 1166
          working_buffer[i___2] = working_buffer[i___2 + 15U];
#line 1165
          i___2 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1168
        working_buffer[buflast] = (unsigned char)0;
#line 1172
        add_font(size, attr, c_idx, b, su, u, (unsigned short)0, working_buffer, (unsigned short )buflast);
        }
      } else {
#line 1151
        goto _L___4;
      }
    } else {
#line 1151
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1174
  if (file_version == 1536) {
#line 1174
    if (bufidx == (unsigned int )last) {
#line 1174
      if ((int )last >= 16) {
        {
#line 1182
        size___0 = getShort(& working_buffer[0]);
#line 1183
        attr___0 = getShort(& working_buffer[2]);
#line 1184
        c_idx___0 = getShort(& working_buffer[4]);
#line 1185
        b___0 = getShort(& working_buffer[6]);
#line 1186
        su___0 = getShort(& working_buffer[8]);
#line 1187
        u___0 = working_buffer[10];
#line 1188
        buflast = (unsigned int )working_buffer[14];
        }
#line 1190
        if ((int )working_buffer[15] & 1) {
#line 1192
          uni___0 = (unsigned char)2;
#line 1193
          len___1 = (unsigned short )(2 * (int )((unsigned short )buflast));
#line 1194
          i___3 = 0U;
          {
#line 1194
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1194
            if (! (i___3 < (unsigned int )len___1)) {
#line 1194
              goto while_break___1;
            }
#line 1195
            working_buffer[i___3] = working_buffer[i___3 + 16U];
#line 1194
            i___3 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 1199
          uni___0 = (unsigned char)0;
#line 1200
          len___1 = (unsigned short )buflast;
#line 1201
          i___3 = 0U;
          {
#line 1201
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1201
            if (! (i___3 < (unsigned int )len___1)) {
#line 1201
              goto while_break___2;
            }
#line 1203
            working_buffer[i___3] = working_buffer[i___3 + 16U];
#line 1204
            if ((unsigned int )working_buffer[i___3] >= 128U) {
#line 1205
              uni___0 = (unsigned char)1;
            }
#line 1201
            i___3 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1209
        working_buffer[len___1] = (unsigned char)0;
#line 1216
        add_font(size___0, attr___0, c_idx___0, b___0, su___0, u___0, (unsigned short )uni___0,
                 & working_buffer[0], len___1);
        }
      }
    }
  }
#line 1218
  goto switch_break;
  case_20: /* CIL Label */ 
#line 1220
  goto switch_break;
  case_21: /* CIL Label */ 
#line 1222
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1224
  tmp___22 = bufidx;
#line 1224
  bufidx ++;
#line 1224
  working_buffer[tmp___22] = data;
#line 1225
  if (bufidx == (unsigned int )last) {
    {
#line 1230
    r___7 = getShort(& working_buffer[0]);
#line 1231
    c___7 = getShort(& working_buffer[2]);
#line 1232
    f___7 = getShort(& working_buffer[4]);
    }
#line 1233
    if ((int )working_buffer[12] == 255) {
#line 1233
      if ((int )working_buffer[13] == 255) {
#line 1235
        if ((int )working_buffer[6] == 1) {
          {
#line 1237
          decodeBoolErr((unsigned short )working_buffer[8], (unsigned short)0, (char *)(calc_val));
#line 1238
          opcode = (unsigned short)261;
          }
        } else
#line 1240
        if ((int )working_buffer[6] == 2) {
          {
#line 1242
          decodeBoolErr((unsigned short )working_buffer[8], (unsigned short)1, (char *)(calc_val));
#line 1243
          opcode = (unsigned short)261;
          }
        } else {
#line 1247
          str_formula_row = r___7;
#line 1248
          str_formula_col = c___7;
#line 1249
          str_formula_format = f___7;
#line 1250
          goto switch_break;
        }
      } else {
        {
#line 1256
        getDouble(& working_buffer[6], & n);
#line 1257
        sprintf((char */* __restrict  */)((char *)(calc_val)), (char const   */* __restrict  */)"%.15g",
                n);
#line 1258
        opcode = (unsigned short)259;
        }
      }
    } else {
      {
#line 1256
      getDouble(& working_buffer[6], & n);
#line 1257
      sprintf((char */* __restrict  */)((char *)(calc_val)), (char const   */* __restrict  */)"%.15g",
              n);
#line 1258
      opcode = (unsigned short)259;
      }
    }
    {
#line 1260
    tmp___23 = strlen((char const   *)((char *)(calc_val)));
#line 1260
    add_wb_array(r___7, c___7, f___7, opcode, (unsigned char)0, calc_val, (unsigned short )tmp___23,
                 (unsigned short)0, (unsigned char *)0);
    }
  }
#line 1262
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1264
  tmp___24 = bufidx;
#line 1264
  bufidx ++;
#line 1264
  working_buffer[tmp___24] = data;
#line 1265
  if (bufidx == (unsigned int )last) {
    {
#line 1268
    uni___1 = (unsigned char)0;
#line 1269
    tmp___25 = getShort(& working_buffer[0]);
#line 1269
    len___2 = tmp___25;
    }
#line 1270
    if ((int )len___2 > (int )last - 3) {
#line 1271
      len___2 = (unsigned short )((int )last - 3);
    }
#line 1272
    if (file_version == 1536) {
#line 1278
      t = (int )len___2 << 1;
#line 1279
      if (t + 3 < 8240) {
#line 1280
        working_buffer[t + 3] = (unsigned char)0;
      } else {
#line 1282
        working_buffer[(int )len___2 + 3] = (unsigned char)0;
      }
#line 1283
      if ((int )len___2 + 3 < (int )last) {
#line 1285
        uni___1 = (unsigned char)2;
#line 1286
        len___2 = (unsigned short )t;
      }
#line 1288
      str = & working_buffer[3];
    } else
#line 1290
    if (file_version == 1280) {
#line 1292
      str = & working_buffer[2];
#line 1293
      working_buffer[(int )len___2 + 2] = (unsigned char)0;
    } else {
#line 1297
      if (OutputXML) {
#line 1298
        str = (unsigned char *)"<NotImplemented/>String Formula";
      } else {
#line 1300
        str = (unsigned char *)"***String Formula";
      }
      {
#line 1301
      tmp___26 = strlen((char const   *)((char *)str));
#line 1301
      len___2 = (unsigned short )tmp___26;
#line 1302
      NotImplemented ++;
      }
    }
    {
#line 1304
    add_wb_array(str_formula_row, str_formula_col, str_formula_format, opcode, uni___1,
                 str, len___2, (unsigned short)0, (unsigned char *)0);
    }
  }
#line 1306
  goto switch_break;
  case_92: /* CIL Label */ 
#line 1308
  tmp___27 = bufidx;
#line 1308
  bufidx ++;
#line 1308
  working_buffer[tmp___27] = data;
#line 1309
  if (bufidx == (unsigned int )last) {
#line 1309
    if ((unsigned long )author.str == (unsigned long )((unsigned char *)0)) {
#line 1311
      if (file_version == 1536) {
        {
#line 1313
        author.len = getShort(& working_buffer[0]);
        }
#line 1314
        if ((int )working_buffer[2] & 1) {
#line 1316
          author.len = (unsigned short )((int )author.len * 2);
#line 1317
          author.uni = (unsigned char)2;
        } else {
#line 1320
          author.uni = (unsigned char)0;
        }
#line 1321
        if ((int )author.len > (int )last - 2) {
#line 1322
          author.len = (unsigned short )((int )last - 2);
        }
        {
#line 1323
        tmp___28 = malloc((size_t )((int )author.len + 1));
#line 1323
        author.str = (unsigned char *)tmp___28;
        }
#line 1324
        if (author.str) {
          {
#line 1326
          memcpy((void */* __restrict  */)author.str, (void const   */* __restrict  */)(& working_buffer[3]),
                 (size_t )author.len);
#line 1327
          *(author.str + author.len) = (unsigned char)0;
          }
        }
      } else
#line 1330
      if (file_version == 1280) {
        {
#line 1332
        author.len = (unsigned short )working_buffer[0];
#line 1333
        tmp___29 = malloc((size_t )((int )author.len + 1));
#line 1333
        author.str = (unsigned char *)tmp___29;
        }
#line 1334
        if (author.str) {
          {
#line 1336
          memcpy((void */* __restrict  */)author.str, (void const   */* __restrict  */)(& working_buffer[1]),
                 (size_t )author.len);
#line 1337
          *(author.str + author.len) = (unsigned char)0;
          }
        }
#line 1339
        author.uni = (unsigned char)0;
      }
    }
  }
#line 1342
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1347
  tmp___30 = bufidx;
#line 1347
  bufidx ++;
#line 1347
  working_buffer[tmp___30] = data;
#line 1348
  if (bufidx == (unsigned int )last) {
    {
#line 1353
    r___8 = getShort(& working_buffer[0]);
#line 1354
    fc = getShort(& working_buffer[2]);
#line 1355
    tmp___31 = getShort(& working_buffer[4]);
#line 1355
    lc = (unsigned short )((int )tmp___31 - 1);
#line 1356
    d___0 = getShort(& working_buffer[12]);
#line 1357
    xf = getShort(& working_buffer[14]);
    }
#line 1359
    if ((unsigned long )*(ws_array + sheet_count) == (unsigned long )((work_sheet *)0)) {
      {
#line 1360
      tmp___32 = ws_init(sheet_count);
      }
#line 1360
      if (tmp___32) {
#line 1361
        return;
      }
    }
#line 1363
    if ((int )r___8 > (*(ws_array + sheet_count))->biggest_row) {
#line 1365
      if ((unsigned int )r___8 < (*(ws_array + sheet_count))->max_rows) {
#line 1366
        (*(ws_array + sheet_count))->biggest_row = (int )r___8;
      } else
#line 1369
      if (MaxRowExceeded == 0) {
        {
#line 1371
        diff = (int )((unsigned int )r___8 / 128U + 1U);
#line 1372
        tmp___33 = resize_c_array(*(ws_array + sheet_count), 128U * (unsigned int )diff,
                                  (unsigned short)0);
        }
#line 1372
        if (tmp___33) {
#line 1374
          (*(ws_array + sheet_count))->biggest_row = (int )((*(ws_array + sheet_count))->max_rows - 1U);
#line 1375
          MaxRowExceeded = 1;
#line 1376
          return;
        } else {
#line 1379
          (*(ws_array + sheet_count))->biggest_row = (int )r___8;
        }
      } else {
#line 1382
        return;
      }
    }
#line 1386
    if ((int )lc > (int )(*(ws_array + sheet_count))->biggest_col) {
#line 1388
      if ((int )lc < (int )(*(ws_array + sheet_count))->max_cols) {
#line 1389
        (*(ws_array + sheet_count))->biggest_col = (short )lc;
      } else
#line 1392
      if (MaxColExceeded == 0) {
        {
#line 1394
        diff___0 = (int )lc / 24 + 1;
#line 1395
        tmp___34 = resize_c_array(*(ws_array + sheet_count), 0U, (unsigned short )(24 * diff___0));
        }
#line 1395
        if (tmp___34) {
#line 1397
          (*(ws_array + sheet_count))->biggest_col = (short )((int )(*(ws_array + sheet_count))->max_cols - 1);
#line 1398
          MaxColExceeded = 1;
#line 1399
          lc = (*(ws_array + sheet_count))->max_cols;
        } else {
#line 1402
          (*(ws_array + sheet_count))->biggest_col = (short )lc;
        }
      } else {
#line 1405
        lc = (*(ws_array + sheet_count))->max_cols;
      }
    }
#line 1408
    if ((int )fc < (int )(*(ws_array + sheet_count))->max_cols) {
#line 1408
      if ((int )d___0 & 128) {
#line 1410
        i___4 = fc;
        {
#line 1410
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1410
          if (! ((int )i___4 < (int )lc)) {
#line 1410
            goto while_break___3;
          }
          {
#line 1412
          update_cell_xf(r___8, i___4, xf);
#line 1410
          i___4 = (unsigned short )((int )i___4 + 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  }
#line 1416
  goto switch_break;
  case_34: /* CIL Label */ 
#line 1418
  tmp___35 = bufidx;
#line 1418
  bufidx ++;
#line 1418
  working_buffer[tmp___35] = data;
#line 1419
  if (bufidx == 2U) {
    {
#line 1420
    tmp___36 = getShort(& working_buffer[0]);
#line 1420
    DatesR1904 = (int )tmp___36;
    }
  }
#line 1421
  goto switch_break;
  case_133: /* CIL Label */ 
#line 1423
  tmp___37 = bufidx;
#line 1423
  bufidx ++;
#line 1423
  working_buffer[tmp___37] = data;
#line 1424
  if (bufidx == (unsigned int )last) {
#line 1426
    if (((int )working_buffer[4] & 15) == 0) {
#line 1429
      uni___2 = (unsigned char)0;
#line 1430
      if (file_version == 1536) {
#line 1432
        len___3 = (unsigned short )working_buffer[6];
#line 1433
        if ((int )working_buffer[7] & 1) {
#line 1435
          uni___2 = (unsigned char)2;
#line 1436
          len___3 = (unsigned short )((int )len___3 << 1);
        }
#line 1438
        if ((int )len___3 != 0) {
          {
#line 1440
          working_buffer[(8 + (int )len___3) + 1] = (unsigned char)0;
#line 1441
          add_ws_title((unsigned short )uni___2, & working_buffer[8], len___3);
          }
        }
      } else {
#line 1446
        len___3 = (unsigned short )working_buffer[6];
#line 1447
        if ((int )len___3 != 0) {
          {
#line 1449
          working_buffer[(7 + (int )len___3) + 1] = (unsigned char)0;
#line 1450
          add_ws_title((unsigned short )uni___2, & working_buffer[7], len___3);
          }
        }
      }
    }
  }
#line 1455
  goto switch_break;
  case_126: /* CIL Label */ 
#line 1457
  tmp___38 = bufidx;
#line 1457
  bufidx ++;
#line 1457
  working_buffer[tmp___38] = data;
#line 1458
  if (bufidx == (unsigned int )last) {
    {
#line 1466
    r___9 = getShort(& working_buffer[0]);
#line 1467
    c___8 = getShort(& working_buffer[2]);
#line 1468
    f___8 = getShort(& working_buffer[4]);
#line 1469
    n___0 = getLong(& working_buffer[6]);
#line 1470
    t___0 = (unsigned int )(n___0 & 3);
#line 1471
    n2 = n___0 >> 2;
    }
    {
#line 1474
    if (t___0 == 0U) {
#line 1474
      goto case_0;
    }
#line 1478
    if (t___0 == 1U) {
#line 1478
      goto case_1___0;
    }
#line 1482
    if (t___0 == 2U) {
#line 1482
      goto case_2___0;
    }
#line 1485
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1475
    RKtoDouble(n2, & d___1);
#line 1476
    sprintf((char */* __restrict  */)(temp___2), (char const   */* __restrict  */)"%.15g",
            d___1);
    }
#line 1477
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 1479
    RKtoDouble(n2, & d___1);
#line 1480
    sprintf((char */* __restrict  */)(temp___2), (char const   */* __restrict  */)"%.15g",
            d___1 / 100.0);
    }
#line 1481
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 1483
    sprintf((char */* __restrict  */)(temp___2), (char const   */* __restrict  */)"%ld",
            (long )n2);
    }
#line 1484
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1486
    d___1 = (double )n2;
#line 1487
    sprintf((char */* __restrict  */)(temp___2), (char const   */* __restrict  */)"%.15g",
            d___1 / 100.0);
    }
#line 1488
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1490
    tmp___39 = strlen((char const   *)(temp___2));
#line 1490
    add_wb_array(r___9, c___8, f___8, opcode, (unsigned char)0, (unsigned char *)(temp___2),
                 (unsigned short )tmp___39, (unsigned short)0, (unsigned char *)0);
    }
  }
#line 1492
  goto switch_break;
  case_188: /* CIL Label */ 
#line 1509
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1511
  tmp___40 = bufidx;
#line 1511
  bufidx ++;
#line 1511
  working_buffer[tmp___40] = data;
#line 1512
  if (bufidx == (unsigned int )last) {
    {
#line 1515
    fr = getShort(& working_buffer[0]);
#line 1516
    lr = getShort(& working_buffer[2]);
#line 1517
    fc___0 = (unsigned short )working_buffer[4];
#line 1518
    lc___0 = (unsigned short )working_buffer[5];
#line 1519
    i___5 = fr;
    }
    {
#line 1519
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1519
      if (! ((int )i___5 <= (int )lr)) {
#line 1519
        goto while_break___4;
      }
#line 1521
      j = fc___0;
      {
#line 1521
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1521
        if (! ((int )j <= (int )lc___0)) {
#line 1521
          goto while_break___5;
        }
        {
#line 1522
        add_wb_array(i___5, j, (unsigned short)0, opcode, (unsigned char)0, (unsigned char *)"***Array",
                     (unsigned short)8, (unsigned short)0, (unsigned char *)0);
#line 1521
        j = (unsigned short )((int )j + 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1519
      i___5 = (unsigned short )((int )i___5 + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1524
    NotImplemented = 1;
  }
#line 1526
  goto switch_break;
  case_189: /* CIL Label */ 
#line 1528
  tmp___41 = bufidx;
#line 1528
  bufidx ++;
#line 1528
  working_buffer[tmp___41] = data;
#line 1529
  if (bufidx == (unsigned int )last) {
    {
#line 1533
    r___10 = getShort(& working_buffer[0]);
#line 1534
    fc___1 = getShort(& working_buffer[2]);
#line 1535
    lc___1 = getShort(& working_buffer[(int )last - 2]);
#line 1536
    i___6 = 0;
    }
    {
#line 1536
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1536
      if (! (i___6 <= (int )lc___1 - (int )fc___1)) {
#line 1536
        goto while_break___6;
      }
      {
#line 1544
      f___9 = getShort(& working_buffer[4 + i___6 * 6]);
#line 1545
      n___1 = getLong(& working_buffer[6 + i___6 * 6]);
#line 1546
      t___1 = (unsigned int )(n___1 & 3);
#line 1547
      n2___0 = n___1 >> 2;
      }
      {
#line 1550
      if (t___1 == 0U) {
#line 1550
        goto case_0___0;
      }
#line 1554
      if (t___1 == 1U) {
#line 1554
        goto case_1___1;
      }
#line 1558
      if (t___1 == 2U) {
#line 1558
        goto case_2___1;
      }
#line 1561
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
      {
#line 1551
      RKtoDouble(n2___0, & d___2);
#line 1552
      sprintf((char */* __restrict  */)(temp___3), (char const   */* __restrict  */)"%.15g",
              d___2);
      }
#line 1553
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
      {
#line 1555
      RKtoDouble(n2___0, & d___2);
#line 1556
      sprintf((char */* __restrict  */)(temp___3), (char const   */* __restrict  */)"%.15g",
              d___2 / 100.0);
      }
#line 1557
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 1559
      sprintf((char */* __restrict  */)(temp___3), (char const   */* __restrict  */)" %ld",
              n2___0);
      }
#line 1560
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 1562
      d___2 = (double )n2___0;
#line 1563
      sprintf((char */* __restrict  */)(temp___3), (char const   */* __restrict  */)"%.15g",
              d___2 / 100.0);
      }
#line 1564
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 1567
      tmp___42 = strlen((char const   *)(temp___3));
#line 1567
      add_wb_array(r___10, (unsigned short )((int )fc___1 + i___6), f___9, opcode,
                   (unsigned char)0, (unsigned char *)(temp___3), (unsigned short )tmp___42,
                   (unsigned short)0, (unsigned char *)0);
#line 1536
      i___6 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1570
  goto switch_break;
  case_190: /* CIL Label */ 
#line 1572
  tmp___43 = bufidx;
#line 1572
  bufidx ++;
#line 1572
  working_buffer[tmp___43] = data;
#line 1573
  if (bufidx == (unsigned int )last) {
    {
#line 1576
    r___11 = getShort(& working_buffer[0]);
#line 1577
    fc___2 = getShort(& working_buffer[2]);
#line 1578
    lc___2 = getShort(& working_buffer[(int )last - 2]);
#line 1579
    j___0 = (unsigned short)0;
    }
    {
#line 1579
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1579
      if (! ((int )j___0 <= (int )lc___2 - (int )fc___2)) {
#line 1579
        goto while_break___7;
      }
      {
#line 1581
      f___10 = getShort(& working_buffer[4 + (int )j___0 * 2]);
#line 1582
      add_wb_array(r___11, (unsigned short )((int )fc___2 + (int )j___0), f___10,
                   opcode, (unsigned char)0, (unsigned char *)0, (unsigned short)0,
                   (unsigned short)0, (unsigned char *)0);
#line 1579
      j___0 = (unsigned short )((int )j___0 + 1);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 1585
  goto switch_break;
  case_24: /* CIL Label */ 
#line 1587
  tmp___44 = bufidx;
#line 1587
  bufidx ++;
#line 1587
  working_buffer[tmp___44] = data;
#line 1588
  if (bufidx == (unsigned int )last) {
    {
#line 1591
    working_buffer[bufidx] = (unsigned char)0;
#line 1592
    tmp___45 = strstr((char const   *)((char *)(& working_buffer[15])), "LastUpdate");
#line 1592
    ptr = tmp___45;
    }
#line 1593
    if (ptr) {
      {
#line 1595
      ptr += 13;
#line 1596
      tmp___46 = strlen((char const   *)ptr);
#line 1596
      tmp___47 = malloc(tmp___46 + 1UL);
#line 1596
      lastUpdated = (char *)tmp___47;
      }
#line 1597
      if (lastUpdated) {
        {
#line 1598
        strcpy((char */* __restrict  */)lastUpdated, (char const   */* __restrict  */)ptr);
        }
      }
    } else {
      {
#line 1602
      tmp___48 = strstr((char const   *)((char *)(& working_buffer[15])), "Title");
#line 1602
      ptr = tmp___48;
      }
#line 1603
      if (ptr) {
        {
#line 1605
        ptr += 8;
#line 1606
        tmp___49 = strlen((char const   *)ptr);
#line 1606
        tmp___50 = malloc(tmp___49 + 1UL);
#line 1606
        title = (char *)tmp___50;
        }
#line 1607
        if (title) {
          {
#line 1608
          strcpy((char */* __restrict  */)title, (char const   */* __restrict  */)ptr);
          }
        }
      }
    }
  }
#line 1612
  goto switch_break;
  case_224: /* CIL Label */ 
#line 1614
  tmp___51 = bufidx;
#line 1614
  bufidx ++;
#line 1614
  working_buffer[tmp___51] = data;
#line 1615
  if (bufidx == (unsigned int )last) {
    {
#line 1627
    fnt_idx = getShort(& working_buffer[0]);
#line 1628
    fmt_idx = getShort(& working_buffer[2]);
#line 1629
    gen = getShort(& working_buffer[4]);
#line 1630
    align = getShort(& working_buffer[6]);
#line 1631
    indent = getShort(& working_buffer[8]);
#line 1632
    b_style = getShort(& working_buffer[10]);
    }
#line 1633
    if (file_version == 1280) {
      {
#line 1635
      b_l_color = (unsigned short)0;
#line 1636
      b_t_color = 0U;
#line 1637
      tmp___52 = getShort(& working_buffer[12]);
#line 1637
      cell_color = (unsigned short )((int )tmp___52 & 8191);
      }
    } else {
      {
#line 1641
      b_l_color = getShort(& working_buffer[12]);
#line 1642
      tmp___53 = getLong(& working_buffer[14]);
#line 1642
      b_t_color = (unsigned int )tmp___53;
#line 1643
      cell_color = getShort(& working_buffer[18]);
      }
    }
    {
#line 1648
    add_xf_array(fnt_idx, fmt_idx, gen, align, indent, b_style, b_l_color, b_t_color,
                 cell_color);
    }
  }
#line 1651
  goto switch_break;
  case_229: /* CIL Label */ 
#line 1653
  tmp___54 = bufidx;
#line 1653
  bufidx ++;
#line 1653
  working_buffer[tmp___54] = data;
#line 1654
  if (bufidx == (unsigned int )last) {
    {
#line 1657
    (*(ws_array + sheet_count))->spanned = (unsigned short)1;
#line 1658
    num = getShort(& working_buffer[0]);
    }
#line 1659
    if ((unsigned long )(*(ws_array + sheet_count))->c_array == (unsigned long )((cell **)0)) {
#line 1660
      return;
    }
#line 1662
    i___7 = (unsigned short)0;
    {
#line 1662
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1662
      if (! ((int )i___7 < (int )num)) {
#line 1662
        goto while_break___8;
      }
      {
#line 1665
      fr___0 = getShort(& working_buffer[2 + (int )i___7 * 8]);
#line 1666
      lr___0 = getShort(& working_buffer[4 + (int )i___7 * 8]);
#line 1667
      fc___3 = getShort(& working_buffer[6 + (int )i___7 * 8]);
#line 1668
      lc___3 = getShort(& working_buffer[8 + (int )i___7 * 8]);
      }
#line 1669
      if (sheet_count < (int )max_worksheets) {
#line 1671
        if ((unsigned long )*(ws_array + sheet_count) == (unsigned long )((work_sheet *)0)) {
          {
#line 1673
          tmp___55 = ws_init(sheet_count);
          }
#line 1673
          if (tmp___55) {
#line 1674
            return;
          }
        }
#line 1676
        if ((*(ws_array + sheet_count))->c_array) {
#line 1678
          if ((int )fr___0 > (int )lr___0) {
#line 1679
            lr___0 = (unsigned short )(*(ws_array + sheet_count))->biggest_row;
          } else
#line 1678
          if ((int )fr___0 > (*(ws_array + sheet_count))->biggest_row) {
#line 1679
            lr___0 = (unsigned short )(*(ws_array + sheet_count))->biggest_row;
          } else
#line 1678
          if ((int )lr___0 > (*(ws_array + sheet_count))->biggest_row) {
#line 1679
            lr___0 = (unsigned short )(*(ws_array + sheet_count))->biggest_row;
          }
#line 1680
          if ((int )fc___3 > (int )lc___3) {
#line 1681
            lc___3 = (unsigned short )(*(ws_array + sheet_count))->biggest_col;
          } else
#line 1680
          if ((int )fc___3 > (int )(*(ws_array + sheet_count))->biggest_col) {
#line 1681
            lc___3 = (unsigned short )(*(ws_array + sheet_count))->biggest_col;
          } else
#line 1680
          if ((int )lc___3 > (int )(*(ws_array + sheet_count))->biggest_col) {
#line 1681
            lc___3 = (unsigned short )(*(ws_array + sheet_count))->biggest_col;
          }
#line 1682
          j___1 = fr___0;
          {
#line 1682
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1682
            if (! ((int )j___1 <= (int )lr___0)) {
#line 1682
              goto while_break___9;
            }
#line 1684
            k = fc___3;
            {
#line 1684
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 1684
              if (! ((int )k <= (int )lc___3)) {
#line 1684
                goto while_break___10;
              }
#line 1686
              c___9 = *((*(ws_array + sheet_count))->c_array + ((int )j___1 * (int )(*(ws_array + sheet_count))->max_cols + (int )k));
#line 1687
              if ((unsigned long )c___9 != (unsigned long )((cell *)0)) {
#line 1689
                c___9->spanned = (unsigned short)1;
#line 1690
                c___9->rowspan = (unsigned short)0;
#line 1691
                if ((int )k == (int )fc___3) {
#line 1692
                  c___9->colspan = (unsigned short )(((int )lc___3 - (int )fc___3) + 1);
                } else {
#line 1694
                  c___9->colspan = (unsigned short)0;
                }
              }
#line 1684
              k = (unsigned short )((int )k + 1);
            }
            while_break___10: /* CIL Label */ ;
            }
#line 1682
            j___1 = (unsigned short )((int )j___1 + 1);
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 1705
        c___9 = *((*(ws_array + sheet_count))->c_array + ((int )fr___0 * (int )(*(ws_array + sheet_count))->max_cols + (int )fc___3));
#line 1706
        if ((unsigned long )c___9 != (unsigned long )((cell *)0)) {
#line 1708
          c___9->spanned = (unsigned short)0;
#line 1709
          c___9->rowspan = (unsigned short )((int )lr___0 - (int )fr___0);
#line 1710
          c___9->colspan = (unsigned short )((int )lc___3 - (int )fc___3);
#line 1711
          if (c___9->rowspan) {
#line 1712
            c___9->rowspan = (unsigned short )((int )c___9->rowspan + 1);
          }
#line 1713
          if (c___9->colspan) {
#line 1714
            c___9->colspan = (unsigned short )((int )c___9->colspan + 1);
          }
        }
      }
#line 1662
      i___7 = (unsigned short )((int )i___7 + 1);
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 1719
  goto switch_break;
  case_184: /* CIL Label */ 
#line 1721
  tmp___56 = bufidx;
#line 1721
  bufidx ++;
#line 1721
  working_buffer[tmp___56] = data;
#line 1722
  if (bufidx == (unsigned int )last) {
    {
#line 1727
    r___12 = getShort(& working_buffer[0]);
#line 1728
    c___10 = getShort(& working_buffer[4]);
    }
#line 1729
    if ((int )working_buffer[32] == 224) {
      {
#line 1731
      tmp___57 = getLong(& working_buffer[48]);
#line 1731
      len___4 = (unsigned int )tmp___57;
#line 1732
      off = (unsigned short)52;
#line 1733
      uni_type = (unsigned short)2;
      }
    } else {
      {
#line 1737
      tmp___58 = getLong(& working_buffer[50]);
#line 1737
      len___4 = (unsigned int )tmp___58;
#line 1738
      off = (unsigned short)54;
#line 1739
      uni_type = (unsigned short)0;
      }
    }
#line 1741
    if (len___4 > bufidx - (unsigned int )off) {
#line 1743
      if ((int )uni_type == 0) {
        {
#line 1745
        off = (unsigned short)36;
#line 1746
        uni_type = (unsigned short)2;
#line 1747
        tmp___59 = getLong(& working_buffer[32]);
#line 1747
        len___4 = (unsigned int )(tmp___59 * 2);
        }
      } else {
#line 1750
        len___4 = bufidx - (unsigned int )off;
      }
    }
    {
#line 1752
    update_cell_hyperlink(r___12, c___10, & working_buffer[off], (int )len___4, uni_type);
    }
  }
#line 1754
  goto switch_break;
  case_146: /* CIL Label */ 
#line 1756
  tmp___60 = bufidx;
#line 1756
  bufidx ++;
#line 1756
  working_buffer[tmp___60] = data;
#line 1757
  if (bufidx == (unsigned int )last) {
    {
#line 1761
    tmp___61 = getShort(& working_buffer[0]);
#line 1761
    cnt = tmp___61;
#line 1762
    numCustomColors = (int )cnt;
#line 1763
    tmp___62 = calloc((size_t )((int )cnt + 1), sizeof(char *));
#line 1763
    customColors = (unsigned char **)tmp___62;
#line 1764
    i___8 = 0;
    }
    {
#line 1764
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1764
      if (! (i___8 < (int )cnt)) {
#line 1764
        goto while_break___11;
      }
      {
#line 1767
      red = working_buffer[4 * i___8 + 2];
#line 1768
      green = working_buffer[4 * i___8 + 3];
#line 1769
      blue = working_buffer[4 * i___8 + 4];
#line 1771
      sprintf((char */* __restrict  */)(color_string), (char const   */* __restrict  */)"%02X%02X%02X",
              (int )red, (int )green, (int )blue);
#line 1772
      tmp___63 = strdup((char const   *)(color_string));
#line 1772
      *(customColors + i___8) = (unsigned char *)tmp___63;
#line 1764
      i___8 ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 1775
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1777
  tmp___64 = bufidx;
#line 1777
  bufidx ++;
#line 1777
  working_buffer[tmp___64] = data;
#line 1778
  if (bufidx == (unsigned int )last) {
    {
#line 1780
    tmp___65 = getShort(& working_buffer[0]);
#line 1780
    CodePage = (int )tmp___65;
    }
#line 1781
    if (CodePage == 1200) {
#line 1782
      CodePage = 0;
    }
  }
#line 1784
  goto switch_break;
  switch_default___1: /* CIL Label */ 
#line 1786
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1788
  return;
}
}
#line 1793 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int ws_init(int i ) 
{ 
  unsigned int j ;
  unsigned short k ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1797
  if (i >= (int )max_worksheets) {
#line 1798
    return (1);
  }
  {
#line 1800
  tmp = malloc(sizeof(work_sheet ));
#line 1800
  *(ws_array + i) = (work_sheet *)tmp;
  }
#line 1801
  if (*(ws_array + i)) {
    {
#line 1803
    (*(ws_array + i))->spanned = (unsigned short)0;
#line 1804
    (*(ws_array + i))->first_row = 0U;
#line 1805
    (*(ws_array + i))->biggest_row = -1;
#line 1806
    (*(ws_array + i))->max_rows = 128U;
#line 1807
    (*(ws_array + i))->first_col = (unsigned short)0;
#line 1808
    (*(ws_array + i))->biggest_col = (short)-1;
#line 1809
    (*(ws_array + i))->max_cols = (unsigned short)24;
#line 1810
    uni_string_clear(& (*(ws_array + i))->ws_title);
#line 1811
    tmp___0 = malloc(3072UL * sizeof(cell *));
#line 1811
    (*(ws_array + i))->c_array = (cell **)tmp___0;
    }
#line 1812
    if ((unsigned long )(*(ws_array + i))->c_array == (unsigned long )((cell **)0)) {
#line 1813
      return (1);
    }
#line 1814
    j = 0U;
    {
#line 1814
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1814
      if (! (j < 128U)) {
#line 1814
        goto while_break;
      }
#line 1815
      k = (unsigned short)0;
      {
#line 1815
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1815
        if (! ((int )k < 24)) {
#line 1815
          goto while_break___0;
        }
#line 1816
        *((*(ws_array + i))->c_array + (j * (unsigned int )(*(ws_array + i))->max_cols + (unsigned int )k)) = (cell *)0;
#line 1815
        k = (unsigned short )((int )k + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1814
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1819
    return (1);
  }
#line 1821
  return (0);
}
}
#line 1827 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int add_more_worksheet_ptrs(void) 
{ 
  work_sheet **tws_array ;
  int pages ;
  void *tmp ;
  unsigned int i ;

  {
#line 1832
  if (MaxWorksheetsExceeded) {
#line 1833
    return (1);
  }
#line 1835
  if (sheet_count > (int )max_worksheets) {
#line 1836
    pages = (int )((((unsigned int )sheet_count - max_worksheets) / 4U + 1U) * 4U);
  } else {
#line 1838
    pages = 4;
  }
  {
#line 1839
  tmp = realloc((void *)ws_array, (unsigned long )(max_worksheets + (unsigned int )pages) * sizeof(work_sheet *));
#line 1839
  tws_array = (work_sheet **)tmp;
  }
#line 1842
  if ((unsigned long )tws_array == (unsigned long )((void *)0)) {
#line 1844
    MaxWorksheetsExceeded = 1;
#line 1845
    return (1);
  } else {
#line 1851
    ws_array = tws_array;
#line 1853
    i = max_worksheets;
    {
#line 1853
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1853
      if (! (i < max_worksheets + (unsigned int )pages)) {
#line 1853
        goto while_break;
      }
#line 1854
      *(ws_array + i) = (work_sheet *)0;
#line 1853
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1856
    max_worksheets += (unsigned int )pages;
#line 1857
    last_sheet = (int )(max_worksheets - 1U);
  }
#line 1859
  return (0);
}
}
#line 1864 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int resize_c_array(work_sheet *ws , unsigned int new_rows , unsigned short new_cols ) 
{ 
  cell **tc_array ;
  void *tmp ;
  unsigned int j ;
  unsigned short k ;

  {
#line 1867
  if ((unsigned long )ws == (unsigned long )((work_sheet *)0)) {
#line 1868
    return (1);
  }
#line 1869
  if ((unsigned long )ws->c_array == (unsigned long )((cell **)0)) {
#line 1870
    return (1);
  }
  {
#line 1872
  tmp = malloc((unsigned long )((ws->max_rows + new_rows) * (unsigned int )((int )ws->max_cols + (int )new_cols)) * sizeof(cell *));
#line 1872
  tc_array = (cell **)tmp;
  }
#line 1874
  if ((unsigned long )tc_array == (unsigned long )((void *)0)) {
#line 1875
    return (1);
  } else {
    {
#line 1881
    memset((void *)tc_array, 0, (unsigned long )((ws->max_rows + new_rows) * (unsigned int )((int )ws->max_cols + (int )new_cols)) * sizeof(cell *));
#line 1882
    j = 0U;
    }
    {
#line 1882
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1882
      if (! (j < ws->max_rows)) {
#line 1882
        goto while_break;
      }
#line 1884
      k = (unsigned short)0;
      {
#line 1884
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1884
        if (! ((int )k < (int )ws->max_cols)) {
#line 1884
          goto while_break___0;
        }
#line 1885
        *(tc_array + (j * (unsigned int )((int )ws->max_cols + (int )new_cols) + (unsigned int )k)) = *(ws->c_array + (j * (unsigned int )ws->max_cols + (unsigned int )k));
#line 1884
        k = (unsigned short )((int )k + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1882
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1887
    ws->max_cols = (unsigned short )((int )ws->max_cols + (int )new_cols);
#line 1888
    ws->max_rows += new_rows;
#line 1889
    free((void *)ws->c_array);
#line 1890
    ws->c_array = tc_array;
    }
  }
#line 1892
  return (0);
}
}
#line 1897 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void add_wb_array(unsigned short r , unsigned short c , unsigned short xf , unsigned short type ,
                  unsigned char uni , unsigned char *str , unsigned short len , unsigned short crun_cnt ,
                  unsigned char *fmt_run ) 
{ 
  work_sheet *ws ;
  int tmp ;
  int tmp___0 ;
  int diff ;
  int tmp___1 ;
  unsigned short diff___0 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int rlen ;
  void *tmp___5 ;
  void *tmp___6 ;
  int rlen___0 ;
  void *tmp___7 ;

  {
#line 1902
  if (sheet_count < 0) {
#line 1903
    return;
  } else
#line 1902
  if ((int )r > (int )HARD_MAX_ROWS) {
#line 1903
    return;
  } else
#line 1902
  if ((int )c > 256) {
#line 1903
    return;
  }
#line 1904
  if (sheet_count >= (int )max_worksheets) {
    {
#line 1906
    tmp = add_more_worksheet_ptrs();
    }
#line 1906
    if (tmp) {
#line 1907
      return;
    }
  }
#line 1909
  if ((unsigned long )*(ws_array + sheet_count) == (unsigned long )((work_sheet *)0)) {
    {
#line 1911
    tmp___0 = ws_init(sheet_count);
    }
#line 1911
    if (tmp___0) {
#line 1912
      return;
    }
  }
#line 1914
  ws = *(ws_array + sheet_count);
#line 1915
  if ((unsigned int )r >= ws->max_rows) {
#line 1917
    if (MaxRowExceeded) {
#line 1918
      return;
    } else {
      {
#line 1921
      diff = (int )(((unsigned int )r - ws->max_rows) / 128U + 1U);
#line 1922
      tmp___1 = resize_c_array(ws, 128U * (unsigned int )diff, (unsigned short)0);
      }
#line 1922
      if (tmp___1) {
#line 1924
        MaxRowExceeded = 1;
#line 1925
        return;
      }
    }
  }
#line 1929
  if ((int )c >= (int )ws->max_cols) {
#line 1931
    if (MaxColExceeded) {
#line 1932
      return;
    } else {
      {
#line 1935
      diff___0 = (unsigned short )(((int )c - (int )ws->max_cols) / 24 + 1);
#line 1936
      tmp___2 = resize_c_array(ws, 0U, (unsigned short )(24 * (int )diff___0));
      }
#line 1936
      if (tmp___2) {
#line 1938
        MaxColExceeded = 1;
#line 1939
        return;
      }
    }
  }
#line 1943
  if ((unsigned long )*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)) == (unsigned long )((cell *)0)) {
#line 1945
    if ((int )r > (*(ws_array + sheet_count))->biggest_row) {
#line 1946
      (*(ws_array + sheet_count))->biggest_row = (int )r;
    }
#line 1947
    if ((int )c > (int )(*(ws_array + sheet_count))->biggest_col) {
#line 1948
      (*(ws_array + sheet_count))->biggest_col = (short )c;
    }
    {
#line 1949
    tmp___3 = malloc(sizeof(cell ));
#line 1949
    *(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)) = (cell *)tmp___3;
    }
#line 1950
    if (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c))) {
#line 1952
      if (str) {
        {
#line 1954
        tmp___4 = malloc((size_t )((int )len + 1));
#line 1954
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str = (unsigned char *)tmp___4;
        }
#line 1955
        if ((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str) {
          {
#line 1957
          memcpy((void */* __restrict  */)(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str,
                 (void const   */* __restrict  */)str, (size_t )len);
#line 1958
          *((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str + len) = (unsigned char)0;
          }
        }
#line 1960
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.uni = uni;
#line 1961
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.len = len;
#line 1962
        if (fmt_run) {
#line 1962
          if (crun_cnt) {
            {
#line 1964
            rlen = (int )crun_cnt * 4;
#line 1966
            tmp___5 = malloc((size_t )rlen);
#line 1966
            (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)tmp___5;
            }
#line 1967
            if ((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run) {
              {
#line 1969
              memcpy((void */* __restrict  */)(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run,
                     (void const   */* __restrict  */)fmt_run, (size_t )rlen);
#line 1970
              (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char )crun_cnt;
              }
            } else {
#line 1973
              (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
            }
          } else {
#line 1977
            (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)0;
#line 1978
            (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
          }
        } else {
#line 1977
          (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)0;
#line 1978
          (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
        }
      } else {
        {
#line 1982
        uni_string_clear(& (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr);
        }
      }
      {
#line 1984
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->xfmt = xf;
#line 1985
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->type = type;
#line 1986
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->spanned = (unsigned short)0;
#line 1987
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->rowspan = (unsigned short)0;
#line 1988
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->colspan = (unsigned short)0;
#line 1989
      uni_string_clear(& (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link);
      }
    }
  } else {
#line 1994
    if ((int )r > (*(ws_array + sheet_count))->biggest_row) {
#line 1995
      (*(ws_array + sheet_count))->biggest_row = (int )r;
    }
#line 1996
    if ((int )c > (int )(*(ws_array + sheet_count))->biggest_col) {
#line 1997
      (*(ws_array + sheet_count))->biggest_col = (short )c;
    }
#line 1998
    if (str) {
#line 2000
      if ((unsigned long )(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str != (unsigned long )((unsigned char *)0)) {
        {
#line 2001
        free((void *)(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str);
        }
      }
      {
#line 2003
      tmp___6 = malloc((size_t )((int )len + 1));
#line 2003
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str = (unsigned char *)tmp___6;
      }
#line 2004
      if ((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str) {
        {
#line 2006
        memcpy((void */* __restrict  */)(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str,
               (void const   */* __restrict  */)str, (size_t )len);
#line 2007
        *((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str + len) = (unsigned char)0;
        }
      }
#line 2009
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.len = len;
#line 2010
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.uni = uni;
#line 2011
      if (fmt_run) {
#line 2011
        if (crun_cnt) {
          {
#line 2013
          rlen___0 = (int )crun_cnt * 4;
#line 2015
          tmp___7 = malloc((size_t )rlen___0);
#line 2015
          (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)tmp___7;
          }
#line 2016
          if ((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run) {
            {
#line 2018
            memcpy((void */* __restrict  */)(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run,
                   (void const   */* __restrict  */)fmt_run, (size_t )rlen___0);
#line 2019
            (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char )crun_cnt;
            }
          } else {
#line 2022
            (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
          }
        } else {
#line 2026
          (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)0;
#line 2027
          (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
        }
      } else {
#line 2026
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)0;
#line 2027
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
      }
    } else
#line 2032
    if ((unsigned long )(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.str == (unsigned long )((unsigned char *)0)) {
#line 2034
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.len = (unsigned short)0;
#line 2035
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.uni = (unsigned char)0;
#line 2036
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.fmt_run = (unsigned char *)0;
#line 2037
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr.crun_cnt = (unsigned char)0;
    }
#line 2040
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->xfmt = xf;
#line 2041
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->type = type;
#line 2042
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->spanned = (unsigned short)0;
#line 2043
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->rowspan = (unsigned short)0;
#line 2044
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->colspan = (unsigned short)0;
  }
#line 2046
  return;
}
}
#line 2048 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void update_cell_xf(unsigned short r , unsigned short c , unsigned short xf ) 
{ 
  work_sheet *ws ;
  int tmp ;
  int tmp___0 ;
  int diff ;
  int tmp___1 ;
  int diff___0 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 2052
  if (sheet_count < 0) {
#line 2053
    return;
  } else
#line 2052
  if ((int )r > (int )HARD_MAX_ROWS) {
#line 2053
    return;
  } else
#line 2052
  if ((int )c > 256) {
#line 2053
    return;
  }
#line 2054
  if (sheet_count >= (int )max_worksheets) {
    {
#line 2056
    tmp = add_more_worksheet_ptrs();
    }
#line 2056
    if (tmp) {
#line 2057
      return;
    }
  }
#line 2059
  if ((unsigned long )*(ws_array + sheet_count) == (unsigned long )((work_sheet *)0)) {
    {
#line 2061
    tmp___0 = ws_init(sheet_count);
    }
#line 2061
    if (tmp___0) {
#line 2062
      return;
    }
  }
#line 2064
  if ((unsigned int )r >= (*(ws_array + sheet_count))->max_rows) {
#line 2066
    if (MaxRowExceeded) {
#line 2067
      return;
    } else {
      {
#line 2070
      diff = (int )(((unsigned int )r - (*(ws_array + sheet_count))->max_rows) / 128U + 1U);
#line 2071
      tmp___1 = resize_c_array(*(ws_array + sheet_count), 128U * (unsigned int )diff,
                               (unsigned short)0);
      }
#line 2071
      if (tmp___1) {
#line 2073
        MaxRowExceeded = 1;
#line 2074
        return;
      }
    }
  }
#line 2078
  if ((int )c >= (int )(*(ws_array + sheet_count))->max_cols) {
#line 2080
    if (MaxColExceeded) {
#line 2081
      return;
    } else {
      {
#line 2084
      diff___0 = ((int )c - (int )(*(ws_array + sheet_count))->max_cols) / 24 + 1;
#line 2085
      tmp___2 = resize_c_array(*(ws_array + sheet_count), 0U, (unsigned short )(24 * diff___0));
      }
#line 2085
      if (tmp___2) {
#line 2087
        MaxColExceeded = 1;
#line 2088
        return;
      }
    }
  }
#line 2093
  ws = *(ws_array + sheet_count);
#line 2094
  if ((unsigned long )*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)) == (unsigned long )((cell *)0)) {
    {
#line 2096
    tmp___3 = malloc(sizeof(cell ));
#line 2096
    *(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)) = (cell *)tmp___3;
    }
#line 2097
    if (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c))) {
      {
#line 2099
      uni_string_clear(& (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->ustr);
#line 2100
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->xfmt = xf;
#line 2101
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->type = (unsigned short)1;
      }
#line 2103
      if ((int )r > (*(ws_array + sheet_count))->biggest_row) {
#line 2104
        (*(ws_array + sheet_count))->biggest_row = (int )r;
      }
#line 2105
      if ((int )c > (int )(*(ws_array + sheet_count))->biggest_col) {
#line 2106
        (*(ws_array + sheet_count))->biggest_col = (short )c;
      }
      {
#line 2107
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->spanned = (unsigned short)0;
#line 2108
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->rowspan = (unsigned short)0;
#line 2109
      (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->colspan = (unsigned short)0;
#line 2110
      uni_string_clear(& (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link);
      }
    }
  }
#line 2118
  return;
}
}
#line 2120 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void update_cell_hyperlink(unsigned short r , unsigned short c , unsigned char *hyperlink ,
                           int len , unsigned short uni ) 
{ 
  work_sheet *ws ;
  int tmp ;
  int tmp___0 ;
  int diff ;
  int tmp___1 ;
  int diff___0 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 2124
  if (sheet_count < 0) {
#line 2125
    return;
  }
#line 2126
  if (sheet_count >= (int )max_worksheets) {
    {
#line 2128
    tmp = add_more_worksheet_ptrs();
    }
#line 2128
    if (tmp) {
#line 2129
      return;
    }
  }
#line 2131
  if ((unsigned long )*(ws_array + sheet_count) == (unsigned long )((work_sheet *)0)) {
    {
#line 2133
    tmp___0 = ws_init(sheet_count);
    }
#line 2133
    if (tmp___0) {
#line 2134
      return;
    }
  }
#line 2136
  if ((unsigned int )r >= (*(ws_array + sheet_count))->max_rows) {
#line 2138
    if (MaxRowExceeded) {
#line 2139
      return;
    } else {
      {
#line 2142
      diff = (int )(((unsigned int )r - (*(ws_array + sheet_count))->max_rows) / 128U + 1U);
#line 2143
      tmp___1 = resize_c_array(*(ws_array + sheet_count), 128U * (unsigned int )diff,
                               (unsigned short)0);
      }
#line 2143
      if (tmp___1) {
#line 2145
        MaxRowExceeded = 1;
#line 2146
        return;
      }
    }
  }
#line 2150
  if ((int )c >= (int )(*(ws_array + sheet_count))->max_cols) {
#line 2152
    if (MaxColExceeded) {
#line 2153
      return;
    } else {
      {
#line 2156
      diff___0 = ((int )c - (int )(*(ws_array + sheet_count))->max_cols) / 24 + 1;
#line 2157
      tmp___2 = resize_c_array(*(ws_array + sheet_count), 0U, (unsigned short )(24 * diff___0));
      }
#line 2157
      if (tmp___2) {
#line 2159
        MaxColExceeded = 1;
#line 2160
        return;
      }
    }
  }
#line 2165
  ws = *(ws_array + sheet_count);
#line 2166
  if ((unsigned long )*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)) == (unsigned long )((cell *)0)) {
#line 2168
    return;
  }
#line 2170
  if ((unsigned long )(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.str == (unsigned long )((unsigned char *)0)) {
    {
#line 2172
    tmp___3 = malloc((size_t )len);
#line 2172
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.str = (unsigned char *)tmp___3;
    }
#line 2173
    if ((*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.str) {
      {
#line 2174
      memcpy((void */* __restrict  */)(*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.str,
             (void const   */* __restrict  */)hyperlink, (size_t )len);
      }
    }
#line 2175
    (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.uni = (unsigned char )uni;
#line 2176
    if (len) {
#line 2178
      if ((int )uni < 2) {
#line 2179
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.len = (unsigned short )(len - 1);
      } else {
#line 2181
        (*(ws->c_array + ((int )r * (int )ws->max_cols + (int )c)))->h_link.len = (unsigned short )(len - 2);
      }
    }
  }
#line 2189
  return;
}
}
#line 2191 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void add_str_array(unsigned char uni , unsigned char *str , unsigned short len , unsigned char *fmt_run ,
                   unsigned char crun_cnt ) 
{ 
  uni_string **tstr_array ;
  size_t new_size ;
  void *tmp ;
  unsigned long i ;
  void *tmp___0 ;
  void *tmp___1 ;
  int rlen ;
  void *tmp___2 ;

  {
#line 2194
  if ((unsigned long )str == (unsigned long )((unsigned char *)0)) {
#line 2196
    next_string ++;
#line 2197
    return;
  } else
#line 2194
  if ((int )len == 0) {
#line 2196
    next_string ++;
#line 2197
    return;
  }
#line 2199
  if ((unsigned long )next_string >= max_strings) {
    {
#line 2202
    new_size = (max_strings + 256UL) * sizeof(uni_string *);
#line 2204
    tmp = realloc((void *)str_array, new_size);
#line 2204
    tstr_array = (uni_string **)tmp;
    }
#line 2206
    if ((unsigned long )tstr_array == (unsigned long )((void *)0)) {
#line 2208
      MaxStringsExceeded = 1;
#line 2211
      return;
    } else {
#line 2217
      str_array = tstr_array;
#line 2220
      i = max_strings;
      {
#line 2220
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2220
        if (! (i < max_strings + 256UL)) {
#line 2220
          goto while_break;
        }
#line 2221
        *(str_array + i) = (uni_string *)0;
#line 2220
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2223
      max_strings += 256UL;
    }
  }
#line 2227
  if ((unsigned long )*(str_array + next_string) == (unsigned long )((uni_string *)0)) {
    {
#line 2229
    tmp___0 = malloc(sizeof(uni_string ));
#line 2229
    *(str_array + next_string) = (uni_string *)tmp___0;
    }
#line 2230
    if (*(str_array + next_string)) {
      {
#line 2232
      tmp___1 = malloc((size_t )((int )len + 1));
#line 2232
      (*(str_array + next_string))->str = (unsigned char *)tmp___1;
      }
#line 2233
      if ((*(str_array + next_string))->str) {
        {
#line 2235
        memcpy((void */* __restrict  */)(*(str_array + next_string))->str, (void const   */* __restrict  */)str,
               (size_t )len);
#line 2236
        *((*(str_array + next_string))->str + len) = (unsigned char)0;
#line 2237
        (*(str_array + next_string))->len = len;
#line 2238
        (*(str_array + next_string))->uni = uni;
        }
#line 2239
        if (fmt_run) {
#line 2239
          if (crun_cnt) {
            {
#line 2241
            rlen = (int )crun_cnt * 4;
#line 2243
            tmp___2 = malloc((size_t )rlen);
#line 2243
            (*(str_array + next_string))->fmt_run = (unsigned char *)tmp___2;
            }
#line 2244
            if ((*(str_array + next_string))->fmt_run) {
              {
#line 2246
              memcpy((void */* __restrict  */)(*(str_array + next_string))->fmt_run,
                     (void const   */* __restrict  */)fmt_run, (size_t )rlen);
#line 2247
              (*(str_array + next_string))->crun_cnt = crun_cnt;
              }
            } else {
#line 2250
              (*(str_array + next_string))->crun_cnt = (unsigned char)0;
            }
          } else {
#line 2254
            (*(str_array + next_string))->fmt_run = (unsigned char *)0;
#line 2255
            (*(str_array + next_string))->crun_cnt = (unsigned char)0;
          }
        } else {
#line 2254
          (*(str_array + next_string))->fmt_run = (unsigned char *)0;
#line 2255
          (*(str_array + next_string))->crun_cnt = (unsigned char)0;
        }
      }
    }
  }
#line 2260
  next_string ++;
#line 2261
  return;
}
}
#line 2263 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void add_font(unsigned short size , unsigned short attr , unsigned short c_idx , unsigned short bold ,
              unsigned short super , unsigned char underline , unsigned short uni ,
              unsigned char *n , unsigned short len ) 
{ 
  font_attr **tfont_array ;
  fnt_cnt *tf_cnt ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int i ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2266
  if ((unsigned long )n == (unsigned long )((unsigned char *)0)) {
#line 2267
    return;
  }
#line 2268
  if (next_font >= max_fonts) {
    {
#line 2272
    tmp = realloc((void *)font_array, (unsigned long )(max_fonts * 32U) * sizeof(font_attr *));
#line 2272
    tfont_array = (font_attr **)tmp;
#line 2273
    tmp___0 = realloc((void *)f_cnt, (unsigned long )(max_fonts * 32U) * sizeof(fnt_cnt ));
#line 2273
    tf_cnt = (fnt_cnt *)tmp___0;
    }
#line 2275
    if ((unsigned long )tf_cnt == (unsigned long )((void *)0)) {
#line 2277
      MaxFontsExceeded = 1;
#line 2278
      return;
    } else
#line 2275
    if ((unsigned long )tfont_array == (unsigned long )((void *)0)) {
#line 2277
      MaxFontsExceeded = 1;
#line 2278
      return;
    } else {
#line 2284
      font_array = tfont_array;
#line 2285
      f_cnt = tf_cnt;
#line 2287
      i = max_fonts;
      {
#line 2287
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2287
        if (! (i < max_fonts + 32U)) {
#line 2287
          goto while_break;
        }
#line 2289
        *(font_array + i) = (font_attr *)0;
#line 2290
        (f_cnt + i)->name = (uni_string *)0;
#line 2287
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2292
      max_fonts += 32U;
    }
  }
#line 2296
  if ((unsigned long )*(font_array + next_font) == (unsigned long )((font_attr *)0)) {
    {
#line 2298
    tmp___1 = malloc(sizeof(font_attr ));
#line 2298
    *(font_array + next_font) = (font_attr *)tmp___1;
    }
#line 2299
    if (*(font_array + next_font)) {
      {
#line 2301
      tmp___2 = malloc((size_t )((int )len + 1));
#line 2301
      (*(font_array + next_font))->name.str = (unsigned char *)tmp___2;
      }
#line 2302
      if ((*(font_array + next_font))->name.str) {
        {
#line 2304
        (*(font_array + next_font))->attr = attr;
#line 2305
        (*(font_array + next_font))->c_idx = c_idx;
#line 2306
        (*(font_array + next_font))->bold = bold;
#line 2307
        (*(font_array + next_font))->super = super;
#line 2308
        (*(font_array + next_font))->underline = underline;
#line 2309
        (*(font_array + next_font))->name.uni = (unsigned char )uni;
#line 2310
        memcpy((void */* __restrict  */)(*(font_array + next_font))->name.str, (void const   */* __restrict  */)n,
               (size_t )len);
#line 2311
        *((*(font_array + next_font))->name.str + len) = (unsigned char)0;
#line 2312
        (*(font_array + next_font))->name.len = len;
#line 2313
        (*(font_array + next_font))->name.fmt_run = (unsigned char *)0;
#line 2314
        (*(font_array + next_font))->name.crun_cnt = (unsigned char)0;
        }
#line 2317
        if ((int )size >= 720) {
#line 2318
          (*(font_array + next_font))->size = (unsigned short)7;
        } else
#line 2319
        if ((int )size >= 480) {
#line 2320
          (*(font_array + next_font))->size = (unsigned short)6;
        } else
#line 2321
        if ((int )size >= 360) {
#line 2322
          (*(font_array + next_font))->size = (unsigned short)5;
        } else
#line 2323
        if ((int )size >= 240) {
#line 2324
          (*(font_array + next_font))->size = (unsigned short)4;
        } else
#line 2325
        if ((int )size >= 200) {
#line 2326
          (*(font_array + next_font))->size = (unsigned short)3;
        } else
#line 2327
        if ((int )size >= 160) {
#line 2328
          (*(font_array + next_font))->size = (unsigned short)2;
        } else {
#line 2330
          (*(font_array + next_font))->size = (unsigned short)1;
        }
      }
    }
  }
#line 2334
  next_font ++;
#line 2335
  if (next_font == 4U) {
#line 2336
    next_font ++;
  }
#line 2337
  return;
}
}
#line 2339 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void add_ws_title(unsigned short uni , unsigned char *n , unsigned short len ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 2341
  if ((unsigned long )n == (unsigned long )((unsigned char *)0)) {
#line 2342
    return;
  }
#line 2344
  if (next_ws_title >= max_worksheets) {
    {
#line 2346
    tmp = add_more_worksheet_ptrs();
    }
#line 2346
    if (tmp) {
#line 2347
      return;
    }
  }
#line 2350
  if ((unsigned long )*(ws_array + next_ws_title) == (unsigned long )((work_sheet *)0)) {
    {
#line 2352
    tmp___0 = ws_init((int )next_ws_title);
    }
#line 2352
    if (tmp___0) {
#line 2353
      return;
    }
  }
#line 2355
  if ((unsigned long )(*(ws_array + next_ws_title))->ws_title.str == (unsigned long )((unsigned char *)0)) {
    {
#line 2357
    tmp___1 = malloc((size_t )((int )len + 1));
#line 2357
    (*(ws_array + next_ws_title))->ws_title.str = (unsigned char *)tmp___1;
    }
#line 2358
    if ((*(ws_array + next_ws_title))->ws_title.str) {
      {
#line 2360
      (*(ws_array + next_ws_title))->ws_title.uni = (unsigned char )uni;
#line 2361
      memcpy((void */* __restrict  */)(*(ws_array + next_ws_title))->ws_title.str,
             (void const   */* __restrict  */)n, (size_t )len);
#line 2362
      *((*(ws_array + next_ws_title))->ws_title.str + len) = (unsigned char)0;
#line 2363
      (*(ws_array + next_ws_title))->ws_title.len = len;
#line 2364
      (*(ws_array + next_ws_title))->ws_title.crun_cnt = (unsigned char)0;
#line 2365
      (*(ws_array + next_ws_title))->ws_title.fmt_run = (unsigned char *)0;
      }
    }
  }
#line 2368
  next_ws_title ++;
#line 2369
  return;
}
}
#line 2371 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void add_xf_array(unsigned short fnt_idx , unsigned short fmt_idx , unsigned short gen ,
                  unsigned short align , unsigned short indent , unsigned short b_style ,
                  unsigned short b_l_color , unsigned int b_t_color , unsigned short cell_color ) 
{ 
  xf_attr **txf_array ;
  void *tmp ;
  unsigned int i ;
  void *tmp___0 ;

  {
#line 2374
  if (next_xf >= max_xformats) {
    {
#line 2378
    tmp = realloc((void *)xf_array, (unsigned long )(max_xformats + 64U) * sizeof(xf_attr *));
#line 2378
    txf_array = (xf_attr **)tmp;
    }
#line 2379
    if ((unsigned long )txf_array == (unsigned long )((void *)0)) {
#line 2381
      MaxXFExceeded = 1;
#line 2382
      return;
    } else {
#line 2388
      xf_array = txf_array;
#line 2390
      i = max_xformats;
      {
#line 2390
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2390
        if (! (i < max_xformats + 64U)) {
#line 2390
          goto while_break;
        }
#line 2391
        *(xf_array + i) = (xf_attr *)0;
#line 2390
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2393
      max_xformats += 64U;
    }
  }
#line 2397
  if ((unsigned long )*(xf_array + next_xf) == (unsigned long )((xf_attr *)0)) {
    {
#line 2399
    tmp___0 = malloc(sizeof(xf_attr ));
#line 2399
    *(xf_array + next_xf) = (xf_attr *)tmp___0;
    }
#line 2400
    if (*(xf_array + next_xf)) {
#line 2402
      (*(xf_array + next_xf))->fnt_idx = fnt_idx;
#line 2403
      (*(xf_array + next_xf))->fmt_idx = fmt_idx;
#line 2404
      (*(xf_array + next_xf))->gen = gen;
#line 2405
      (*(xf_array + next_xf))->align = align;
#line 2406
      (*(xf_array + next_xf))->indent = indent;
#line 2407
      (*(xf_array + next_xf))->b_style = b_style;
#line 2408
      (*(xf_array + next_xf))->b_l_color = b_l_color;
#line 2409
      (*(xf_array + next_xf))->b_t_color = b_t_color;
#line 2410
      (*(xf_array + next_xf))->cell_color = cell_color;
    }
#line 2412
    next_xf ++;
  }
#line 2414
  return;
}
}
#line 2416 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void decodeBoolErr(unsigned short value , unsigned short flag , char *str ) 
{ 


  {
#line 2418
  if ((unsigned long )str == (unsigned long )((char *)0)) {
#line 2419
    return;
  }
#line 2421
  if ((int )flag == 0) {
#line 2423
    if ((int )value == 1) {
      {
#line 2424
      strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"TRUE");
      }
    } else {
      {
#line 2426
      strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"FALSE");
      }
    }
  } else {
    {
#line 2432
    if ((int )value == 0) {
#line 2432
      goto case_0;
    }
#line 2435
    if ((int )value == 7) {
#line 2435
      goto case_7;
    }
#line 2438
    if ((int )value == 15) {
#line 2438
      goto case_15;
    }
#line 2441
    if ((int )value == 23) {
#line 2441
      goto case_23;
    }
#line 2444
    if ((int )value == 29) {
#line 2444
      goto case_29;
    }
#line 2447
    if ((int )value == 36) {
#line 2447
      goto case_36;
    }
#line 2450
    if ((int )value == 42) {
#line 2450
      goto case_42;
    }
#line 2453
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 2433
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#NULL!");
    }
#line 2434
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 2436
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#DIV/0!");
    }
#line 2437
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 2439
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#VALUE!");
    }
#line 2440
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 2442
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#REF!");
    }
#line 2443
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 2445
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#NAME?");
    }
#line 2446
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 2448
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#NUM!");
    }
#line 2449
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 2451
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#N/A");
    }
#line 2452
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2454
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"#ERR");
    }
#line 2455
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2458
  return;
}
}
#line 2460 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int IsCellNumeric(cell *c ) 
{ 
  int ret_val ;

  {
#line 2462
  ret_val = 0;
  {
#line 2473
  if (((int )c->type & 255) == 189) {
#line 2473
    goto case_189;
  }
#line 2473
  if (((int )c->type & 255) == 126) {
#line 2473
    goto case_189;
  }
#line 2473
  if (((int )c->type & 255) == 3) {
#line 2473
    goto case_189;
  }
#line 2473
  if (((int )c->type & 255) == 2) {
#line 2473
    goto case_189;
  }
#line 2476
  goto switch_default;
  case_189: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 2474
  ret_val = 1;
#line 2475
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2477
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2479
  return (ret_val);
}
}
#line 2485 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int IsCellSafe(cell *c ) 
{ 
  int safe ;

  {
#line 2487
  safe = 0;
#line 2489
  if ((unsigned int )c->xfmt < next_xf) {
#line 2491
    if (*(xf_array + c->xfmt)) {
#line 2493
      safe = 1;
#line 2494
      if ((unsigned int )(*(xf_array + c->xfmt))->fnt_idx < next_font) {
#line 2496
        if (*(font_array + (*(xf_array + c->xfmt))->fnt_idx)) {
#line 2497
          safe = 2;
        }
      }
    }
  }
#line 2501
  return (safe);
}
}
#line 2504 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int IsCellFormula(cell *c ) 
{ 


  {
#line 2506
  if ((int )c->type > 256) {
#line 2507
    return (1);
  } else
#line 2506
  if ((int )c->type == 6) {
#line 2507
    return (1);
  } else {
#line 2509
    return (0);
  }
}
}
#line 2512 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void output_cell(cell *c , int xml ) 
{ 
  html_attr h ;
  char const   *tmp ;
  int numeric ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int safe ;
  int nullString ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  int fgcolor ;
  int tmp___22 ;
  int tmp___23 ;
  int lcolor ;
  int rcolor ;
  int tcolor ;
  int bcolor ;
  int tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;

  {
#line 2516
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 2517
    if (xml) {
#line 2517
      tmp = ">";
    } else {
#line 2517
      tmp = "<TD>&nbsp;";
    }
    {
#line 2517
    printf((char const   */* __restrict  */)tmp);
    }
  } else
#line 2518
  if ((int )c->spanned != 0) {
#line 2520
    if (xml) {
      {
#line 2521
      printf((char const   */* __restrict  */)">");
      }
    }
#line 2522
    return;
  } else {
    {
#line 2526
    tmp___0 = IsCellNumeric(c);
#line 2526
    numeric = tmp___0;
#line 2527
    html_flag_init(& h);
    }
#line 2528
    if ((int )c->xfmt == 0) {
#line 2530
      if (xml) {
#line 2530
        tmp___1 = ">";
      } else {
#line 2530
        tmp___1 = "<TD>";
      }
      {
#line 2530
      printf((char const   */* __restrict  */)tmp___1);
      }
#line 2531
      if (c->ustr.str) {
        {
#line 2532
        OutputString(& c->ustr);
        }
      } else {
#line 2534
        if (xml) {
#line 2534
          tmp___2 = "";
        } else {
#line 2534
          tmp___2 = "&nbsp;";
        }
        {
#line 2534
        printf((char const   */* __restrict  */)tmp___2);
        }
      }
    } else {
      {
#line 2539
      nullString = 1;
#line 2541
      safe = IsCellSafe(c);
      }
#line 2543
      if (c->ustr.str) {
#line 2545
        if ((int )c->ustr.uni < 2) {
          {
#line 2546
          nullString = null_string(c->ustr.str);
          }
        } else {
#line 2548
          nullString = 0;
        }
      }
#line 2552
      if (xml) {
#line 2552
        tmp___3 = "";
      } else {
#line 2552
        tmp___3 = "<TD";
      }
      {
#line 2552
      printf((char const   */* __restrict  */)tmp___3);
      }
#line 2553
      if ((int )c->rowspan != 0) {
#line 2553
        goto _L;
      } else
#line 2553
      if ((int )c->colspan != 0) {
        _L: /* CIL Label */ 
#line 2555
        if (c->colspan) {
#line 2556
          if (xml) {
#line 2556
            tmp___4 = " colspan=\"%d\"";
          } else {
#line 2556
            tmp___4 = " COLSPAN=\"%d\"";
          }
          {
#line 2556
          printf((char const   */* __restrict  */)tmp___4, (int )c->colspan);
          }
        }
#line 2557
        if (c->rowspan) {
#line 2558
          if (xml) {
#line 2558
            tmp___5 = " rowspan=\"%d\"";
          } else {
#line 2558
            tmp___5 = " ROWSPAN=\"%d\"";
          }
          {
#line 2558
          printf((char const   */* __restrict  */)tmp___5, (int )c->rowspan);
          }
        }
      }
#line 2560
      if (safe > 0) {
#line 2560
        if (! nullString) {
          {
#line 2565
          if (((int )(*(xf_array + c->xfmt))->align & 7) == 6) {
#line 2565
            goto case_6;
          }
#line 2565
          if (((int )(*(xf_array + c->xfmt))->align & 7) == 2) {
#line 2565
            goto case_6;
          }
#line 2569
          if (((int )(*(xf_array + c->xfmt))->align & 7) == 0) {
#line 2569
            goto case_0;
          }
#line 2586
          if (((int )(*(xf_array + c->xfmt))->align & 7) == 3) {
#line 2586
            goto case_3;
          }
#line 2591
          goto switch_default;
          case_6: /* CIL Label */ 
          case_2: /* CIL Label */ 
          {
#line 2566
          tmp___7 = strcmp((char const   *)default_alignment, "center");
          }
#line 2566
          if (tmp___7 != 0) {
#line 2567
            if (xml) {
#line 2567
              tmp___6 = "";
            } else {
#line 2567
              tmp___6 = " ALIGN=\"center\"";
            }
            {
#line 2567
            printf((char const   */* __restrict  */)tmp___6);
            }
          }
#line 2568
          goto switch_break;
          case_0: /* CIL Label */ 
#line 2570
          if (numeric) {
            {
#line 2572
            tmp___9 = strcmp((char const   *)default_alignment, "right");
            }
#line 2572
            if (tmp___9 != 0) {
#line 2573
              if (xml) {
#line 2573
                tmp___8 = "";
              } else {
#line 2573
                tmp___8 = " ALIGN=\"right\"";
              }
              {
#line 2573
              printf((char const   */* __restrict  */)tmp___8);
              }
            }
          } else
#line 2575
          if (((int )c->type & 255) == 5) {
            {
#line 2577
            tmp___11 = strcmp((char const   *)default_alignment, "center");
            }
#line 2577
            if (tmp___11 != 0) {
#line 2578
              if (xml) {
#line 2578
                tmp___10 = "";
              } else {
#line 2578
                tmp___10 = " ALIGN=\"center\"";
              }
              {
#line 2578
              printf((char const   */* __restrict  */)tmp___10);
              }
            }
          } else {
            {
#line 2582
            tmp___13 = strcmp((char const   *)default_alignment, "left");
            }
#line 2582
            if (tmp___13 != 0) {
#line 2583
              if (xml) {
#line 2583
                tmp___12 = "";
              } else {
#line 2583
                tmp___12 = " ALIGN=\"left\"";
              }
              {
#line 2583
              printf((char const   */* __restrict  */)tmp___12);
              }
            }
          }
#line 2585
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 2587
          tmp___15 = strcmp((char const   *)default_alignment, "right");
          }
#line 2587
          if (tmp___15 != 0) {
#line 2588
            if (xml) {
#line 2588
              tmp___14 = "";
            } else {
#line 2588
              tmp___14 = " ALIGN=\"right\"";
            }
            {
#line 2588
            printf((char const   */* __restrict  */)tmp___14);
            }
          }
#line 2589
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 2592
          tmp___17 = strcmp((char const   *)default_alignment, "left");
          }
#line 2592
          if (tmp___17 != 0) {
#line 2593
            if (xml) {
#line 2593
              tmp___16 = "";
            } else {
#line 2593
              tmp___16 = " ALIGN=\"left\"";
            }
            {
#line 2593
            printf((char const   */* __restrict  */)tmp___16);
            }
          }
#line 2594
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          {
#line 2598
          if (((int )(*(xf_array + c->xfmt))->align & 112) >> 4 == 0) {
#line 2598
            goto case_0___0;
          }
#line 2601
          if (((int )(*(xf_array + c->xfmt))->align & 112) >> 4 == 1) {
#line 2601
            goto case_1;
          }
#line 2604
          if (((int )(*(xf_array + c->xfmt))->align & 112) >> 4 == 2) {
#line 2604
            goto case_2___0;
          }
#line 2611
          goto switch_default___0;
          case_0___0: /* CIL Label */ 
#line 2599
          if (xml) {
#line 2599
            tmp___18 = "";
          } else {
#line 2599
            tmp___18 = " VALIGN=\"top\"";
          }
          {
#line 2599
          printf((char const   */* __restrict  */)tmp___18);
          }
#line 2600
          goto switch_break___0;
          case_1: /* CIL Label */ 
#line 2602
          if (xml) {
#line 2602
            tmp___19 = "";
          } else {
#line 2602
            tmp___19 = " VALIGN=\"middle\"";
          }
          {
#line 2602
          printf((char const   */* __restrict  */)tmp___19);
          }
#line 2603
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
#line 2605
          if (safe > 1) {
#line 2607
            if (((int )(*(font_array + (*(xf_array + c->xfmt))->fnt_idx))->super & 3) == 1) {
#line 2608
              if (xml) {
#line 2608
                tmp___20 = "";
              } else {
#line 2608
                tmp___20 = " VALIGN=\"top\"";
              }
              {
#line 2608
              printf((char const   */* __restrict  */)tmp___20);
              }
            }
          }
#line 2610
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
#line 2612
          if (safe > 1) {
#line 2614
            if (((int )(*(font_array + (*(xf_array + c->xfmt))->fnt_idx))->super & 3) == 1) {
#line 2615
              if (xml) {
#line 2615
                tmp___21 = "";
              } else {
#line 2615
                tmp___21 = " VALIGN=\"top\"";
              }
              {
#line 2615
              printf((char const   */* __restrict  */)tmp___21);
              }
            }
          }
#line 2617
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 2621
      if (safe) {
#line 2621
        if (use_colors) {
#line 2625
          fgcolor = (int )(*(xf_array + c->xfmt))->cell_color & 127;
#line 2630
          if (! xml) {
#line 2632
            if (numCustomColors) {
#line 2634
              if (fgcolor < numCustomColors) {
                {
#line 2636
                tmp___22 = strcmp((char const   *)default_background_color, (char const   *)((char *)*(customColors + (fgcolor - 8))));
                }
#line 2636
                if (tmp___22 != 0) {
                  {
#line 2637
                  printf((char const   */* __restrict  */)" BGCOLOR=\"%s\"", *(customColors + (fgcolor - 8)));
                  }
                }
              }
            } else
#line 2642
            if (fgcolor < 65) {
              {
#line 2644
              tmp___23 = strcmp((char const   *)default_background_color, (char const   *)(colorTab[fgcolor]));
              }
#line 2644
              if (tmp___23 != 0) {
                {
#line 2645
                printf((char const   */* __restrict  */)" BGCOLOR=\"%s\"", colorTab[fgcolor]);
                }
              }
            }
          }
        }
      }
#line 2652
      if (safe) {
#line 2652
        if (use_colors) {
#line 2655
          lcolor = (int )(*(xf_array + c->xfmt))->b_l_color & 127;
#line 2656
          rcolor = ((int )(*(xf_array + c->xfmt))->b_l_color & 16256) >> 7;
#line 2657
          tcolor = (int )((*(xf_array + c->xfmt))->b_t_color & 127U);
#line 2658
          bcolor = (int )(((*(xf_array + c->xfmt))->b_t_color & 16256U) >> 7);
#line 2659
          if ((((lcolor & rcolor) & tcolor) & bcolor) == lcolor) {
#line 2659
            if (lcolor < 65) {
#line 2661
              if (numCustomColors == 0) {
                {
#line 2663
                tmp___24 = strcmp((char const   *)(colorTab[lcolor]), "000000");
                }
#line 2663
                if (tmp___24 != 0) {
                  {
#line 2663
                  tmp___25 = strcmp((char const   *)(colorTab[lcolor]), "FFFFFF");
                  }
#line 2663
                  if (tmp___25 != 0) {
#line 2665
                    if (! xml) {
                      {
#line 2666
                      printf((char const   */* __restrict  */)" BORDERCOLOR=\"%s\"",
                             colorTab[lcolor]);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 2673
      printf((char const   */* __restrict  */)">");
      }
#line 2676
      if (safe > 1) {
#line 2676
        if (! xml) {
#line 2678
          if (! nullString) {
            {
#line 2679
            output_start_font_attribute(& h, (*(xf_array + c->xfmt))->fnt_idx);
            }
          }
        }
      }
#line 2683
      if (safe > 1) {
#line 2683
        if (! nullString) {
#line 2685
          if (((int )(*(font_array + (*(xf_array + c->xfmt))->fnt_idx))->underline & 35) > 0) {
#line 2687
            if (c->h_link.str) {
              {
#line 2689
              printf((char const   */* __restrict  */)"<A href=\"");
              }
#line 2690
              if (c->h_link.uni) {
                {
#line 2692
                tmp___27 = memchr((void const   *)((char *)c->h_link.str), ':', (size_t )c->h_link.len);
                }
#line 2692
                if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
                  {
#line 2694
                  tmp___26 = memchr((void const   *)((char *)c->h_link.str), '@',
                                    (size_t )c->h_link.len);
                  }
#line 2694
                  if (tmp___26) {
                    {
#line 2695
                    printf((char const   */* __restrict  */)"mailto:");
                    }
                  }
                }
              }
              {
#line 2698
              OutputString(& c->h_link);
#line 2699
              printf((char const   */* __restrict  */)"\">");
#line 2700
              h.uflag = 2;
              }
            } else {
              {
#line 2704
              printf((char const   */* __restrict  */)"<U>");
#line 2705
              h.uflag = 1;
              }
            }
          }
          {
#line 2708
          output_start_html_attr(& h, (unsigned int )(*(xf_array + c->xfmt))->fnt_idx,
                                 0);
          }
        }
      }
#line 2710
      if (c->ustr.str) {
#line 2712
        if (safe) {
          {
#line 2713
          tmp___28 = IsCellFormula(c);
#line 2713
          output_formatted_data(& c->ustr, (*(xf_array + c->xfmt))->fmt_idx, numeric,
                                tmp___28);
          }
        } else {
          {
#line 2715
          OutputString(& c->ustr);
          }
        }
      } else {
#line 2718
        if (xml) {
#line 2718
          tmp___29 = "";
        } else {
#line 2718
          tmp___29 = "&nbsp;";
        }
        {
#line 2718
        printf((char const   */* __restrict  */)tmp___29);
        }
      }
    }
    {
#line 2723
    output_end_html_attr(& h);
    }
  }
#line 2726
  if (! aggressive) {
#line 2727
    if (xml) {
#line 2727
      tmp___30 = "";
    } else {
#line 2727
      tmp___30 = "</TD>\n";
    }
    {
#line 2727
    printf((char const   */* __restrict  */)tmp___30);
    }
  }
#line 2728
  return;
}
}
#line 2730 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void output_formatted_data(uni_string *u , unsigned short idx , int numeric , int formula ) 
{ 
  int year ;
  int month ;
  int date ;
  long num ;
  double dnum ;
  int hr ;
  int minu ;
  int sec ;
  int msec ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char const   *tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double acc_val ;
  double tmp___15 ;
  double tmp___16 ;
  char *ptr ;
  char *tmp___17 ;

  {
#line 2732
  if ((unsigned int )idx < max_xformats) {
#line 2732
    if (u->str) {
#line 2734
      if (formula_warnings) {
#line 2734
        if (formula) {
#line 2736
          if (OutputXML) {
            {
#line 2737
            printf((char const   */* __restrict  */)"<NotAccurate/>");
            }
          } else {
            {
#line 2739
            printf((char const   */* __restrict  */)"** ");
            }
          }
#line 2740
          notAccurate ++;
        }
      }
#line 2742
      if (numeric) {
        {
#line 2752
        if ((int )idx == 0) {
#line 2752
          goto case_0;
        }
#line 2756
        if ((int )idx == 1) {
#line 2756
          goto case_1;
        }
#line 2760
        if ((int )idx == 2) {
#line 2760
          goto case_2;
        }
#line 2764
        if ((int )idx == 3) {
#line 2764
          goto case_3;
        }
#line 2767
        if ((int )idx == 4) {
#line 2767
          goto case_4;
        }
#line 2770
        if ((int )idx == 5) {
#line 2770
          goto case_5;
        }
#line 2773
        if ((int )idx == 6) {
#line 2773
          goto case_6;
        }
#line 2776
        if ((int )idx == 7) {
#line 2776
          goto case_7;
        }
#line 2779
        if ((int )idx == 8) {
#line 2779
          goto case_8;
        }
#line 2782
        if ((int )idx == 9) {
#line 2782
          goto case_9;
        }
#line 2790
        if ((int )idx == 10) {
#line 2790
          goto case_10;
        }
#line 2798
        if ((int )idx == 11) {
#line 2798
          goto case_11;
        }
#line 2806
        if ((int )idx == 12) {
#line 2806
          goto case_12;
        }
#line 2814
        if ((int )idx == 13) {
#line 2814
          goto case_13;
        }
#line 2822
        if ((int )idx == 14) {
#line 2822
          goto case_14;
        }
#line 2831
        if ((int )idx == 15) {
#line 2831
          goto case_15;
        }
#line 2840
        if ((int )idx == 16) {
#line 2840
          goto case_16;
        }
#line 2849
        if ((int )idx == 17) {
#line 2849
          goto case_17;
        }
#line 2858
        if ((int )idx == 18) {
#line 2858
          goto case_18;
        }
#line 2873
        if ((int )idx == 19) {
#line 2873
          goto case_19;
        }
#line 2888
        if ((int )idx == 20) {
#line 2888
          goto case_20;
        }
#line 2896
        if ((int )idx == 21) {
#line 2896
          goto case_21;
        }
#line 2912
        if ((int )idx == 22) {
#line 2912
          goto case_22;
        }
#line 2922
        if ((int )idx == 37) {
#line 2922
          goto case_37;
        }
#line 2929
        if ((int )idx == 38) {
#line 2929
          goto case_38;
        }
#line 2936
        if ((int )idx == 39) {
#line 2936
          goto case_39;
        }
#line 2943
        if ((int )idx == 40) {
#line 2943
          goto case_40;
        }
#line 2950
        if ((int )idx == 41) {
#line 2950
          goto case_41;
        }
#line 2957
        if ((int )idx == 42) {
#line 2957
          goto case_42;
        }
#line 2964
        if ((int )idx == 43) {
#line 2964
          goto case_43;
        }
#line 2971
        if ((int )idx == 44) {
#line 2971
          goto case_44;
        }
#line 2984
        if ((int )idx == 45) {
#line 2984
          goto case_45;
        }
#line 2992
        if ((int )idx == 46) {
#line 2992
          goto case_46;
        }
#line 3003
        if ((int )idx == 47) {
#line 3003
          goto case_47;
        }
#line 3011
        if ((int )idx == 49) {
#line 3011
          goto case_49;
        }
#line 3015
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 2753
        dnum = atof((char const   *)((char *)u->str));
#line 2754
        printf((char const   */* __restrict  */)"%.15g", dnum);
        }
#line 2755
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 2757
        dnum = atof((char const   *)((char *)u->str));
#line 2758
        printf((char const   */* __restrict  */)"%.0f", dnum);
        }
#line 2759
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 2761
        dnum = atof((char const   *)((char *)u->str));
#line 2762
        printf((char const   */* __restrict  */)"%.2f", dnum);
        }
#line 2763
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2765
        tmp = atof((char const   *)((char *)u->str));
#line 2765
        PrintFloatComma((char *)"%.0f", 0, tmp);
        }
#line 2766
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 2768
        tmp___0 = atof((char const   *)((char *)u->str));
#line 2768
        PrintFloatComma((char *)"%.2f", 0, tmp___0);
        }
#line 2769
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 2771
        tmp___1 = atof((char const   *)((char *)u->str));
#line 2771
        PrintFloatComma((char *)"%.0f", 1, tmp___1);
        }
#line 2772
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 2774
        tmp___2 = atof((char const   *)((char *)u->str));
#line 2774
        PrintFloatComma((char *)"%.0f", 1, tmp___2);
        }
#line 2775
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 2777
        tmp___3 = atof((char const   *)((char *)u->str));
#line 2777
        PrintFloatComma((char *)"%.2f", 1, tmp___3);
        }
#line 2778
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 2780
        tmp___4 = atof((char const   *)((char *)u->str));
#line 2780
        PrintFloatComma((char *)"%.2f", 1, tmp___4);
        }
#line 2781
        goto switch_break;
        case_9: /* CIL Label */ 
#line 2783
        if (Csv) {
          {
#line 2784
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2785
        tmp___5 = atof((char const   *)((char *)u->str));
#line 2785
        dnum = 100.0 * tmp___5;
#line 2786
        printf((char const   */* __restrict  */)"%.0f%%", dnum);
        }
#line 2787
        if (Csv) {
          {
#line 2788
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2789
        goto switch_break;
        case_10: /* CIL Label */ 
#line 2791
        if (Csv) {
          {
#line 2792
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2793
        tmp___6 = atof((char const   *)((char *)u->str));
#line 2793
        dnum = 100.0 * tmp___6;
#line 2794
        printf((char const   */* __restrict  */)"%.2f%%", dnum);
        }
#line 2795
        if (Csv) {
          {
#line 2796
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2797
        goto switch_break;
        case_11: /* CIL Label */ 
#line 2799
        if (Csv) {
          {
#line 2800
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2801
        dnum = atof((char const   *)((char *)u->str));
#line 2802
        printf((char const   */* __restrict  */)"%.2E", dnum);
        }
#line 2803
        if (Csv) {
          {
#line 2804
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2805
        goto switch_break;
        case_12: /* CIL Label */ 
#line 2807
        if (Csv) {
          {
#line 2808
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2809
        dnum = atof((char const   *)((char *)u->str));
#line 2810
        print_as_fraction(dnum, 1);
        }
#line 2811
        if (Csv) {
          {
#line 2812
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2813
        goto switch_break;
        case_13: /* CIL Label */ 
#line 2815
        if (Csv) {
          {
#line 2816
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2817
        dnum = atof((char const   *)((char *)u->str));
#line 2818
        print_as_fraction(dnum, 2);
        }
#line 2819
        if (Csv) {
          {
#line 2820
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2821
        goto switch_break;
        case_14: /* CIL Label */ 
#line 2823
        if (Csv) {
          {
#line 2824
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2825
        num = atol((char const   *)((char *)u->str));
#line 2826
        NumToDate(num, & year, & month, & date);
#line 2827
        printf((char const   */* __restrict  */)"%d-%d-%02d", month, date, year);
        }
#line 2828
        if (Csv) {
          {
#line 2829
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2830
        goto switch_break;
        case_15: /* CIL Label */ 
#line 2832
        if (Csv) {
          {
#line 2833
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2834
        num = atol((char const   *)((char *)u->str));
#line 2835
        NumToDate(num, & year, & month, & date);
#line 2836
        printf((char const   */* __restrict  */)"%d-%s-%02d", date, month_abbr[month - 1],
               year);
        }
#line 2837
        if (Csv) {
          {
#line 2838
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2839
        goto switch_break;
        case_16: /* CIL Label */ 
#line 2841
        if (Csv) {
          {
#line 2842
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2843
        num = atol((char const   *)((char *)u->str));
#line 2844
        NumToDate(num, & year, & month, & date);
#line 2845
        printf((char const   */* __restrict  */)"%d-%s", date, month_abbr[month - 1]);
        }
#line 2846
        if (Csv) {
          {
#line 2847
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2848
        goto switch_break;
        case_17: /* CIL Label */ 
#line 2850
        if (Csv) {
          {
#line 2851
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2852
        num = atol((char const   *)((char *)u->str));
#line 2853
        NumToDate(num, & year, & month, & date);
#line 2854
        printf((char const   */* __restrict  */)"%s-%02d", month_abbr[month - 1],
               year);
        }
#line 2855
        if (Csv) {
          {
#line 2856
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2857
        goto switch_break;
        case_18: /* CIL Label */ 
#line 2859
        if (Csv) {
          {
#line 2860
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2861
        FracToTime(u->str, & hr, & minu, (int *)0, (int *)0);
        }
#line 2862
        if (hr == 0) {
          {
#line 2863
          printf((char const   */* __restrict  */)"12:%02d AM", minu);
          }
        } else
#line 2864
        if (hr < 12) {
          {
#line 2865
          printf((char const   */* __restrict  */)"%d:%02d AM", hr, minu);
          }
        } else
#line 2866
        if (hr == 12) {
          {
#line 2867
          printf((char const   */* __restrict  */)"12:%02d PM", minu);
          }
        } else {
          {
#line 2869
          printf((char const   */* __restrict  */)"%d:%02d PM", hr - 12, minu);
          }
        }
#line 2870
        if (Csv) {
          {
#line 2871
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2872
        goto switch_break;
        case_19: /* CIL Label */ 
#line 2874
        if (Csv) {
          {
#line 2875
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2876
        FracToTime(u->str, & hr, & minu, & sec, (int *)0);
        }
#line 2877
        if (hr == 0) {
          {
#line 2878
          printf((char const   */* __restrict  */)"12:%02d:%02d AM", minu, sec);
          }
        } else
#line 2879
        if (hr < 12) {
          {
#line 2880
          printf((char const   */* __restrict  */)"%d:%02d:%02d AM", hr, minu, sec);
          }
        } else
#line 2881
        if (hr == 12) {
          {
#line 2882
          printf((char const   */* __restrict  */)"12:%02d:%02d PM", minu, sec);
          }
        } else {
          {
#line 2884
          printf((char const   */* __restrict  */)"%d:%02d:%02d PM", hr - 12, minu,
                 sec);
          }
        }
#line 2885
        if (Csv) {
          {
#line 2886
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2887
        goto switch_break;
        case_20: /* CIL Label */ 
#line 2889
        if (Csv) {
          {
#line 2890
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2891
        FracToTime(u->str, & hr, & minu, (int *)0, (int *)0);
#line 2892
        printf((char const   */* __restrict  */)"%d:%02d", hr, minu);
        }
#line 2893
        if (Csv) {
          {
#line 2894
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2895
        goto switch_break;
        case_21: /* CIL Label */ 
#line 2897
        if (Csv) {
          {
#line 2898
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2899
        FracToTime(u->str, & hr, & minu, & sec, (int *)0);
        }
#line 2900
        if (hr != 0) {
          {
#line 2901
          printf((char const   */* __restrict  */)"%d:%02d:%02d", hr, minu, sec);
          }
        } else
#line 2900
        if (minu != 0) {
          {
#line 2901
          printf((char const   */* __restrict  */)"%d:%02d:%02d", hr, minu, sec);
          }
        } else
#line 2900
        if (sec != 0) {
          {
#line 2901
          printf((char const   */* __restrict  */)"%d:%02d:%02d", hr, minu, sec);
          }
        } else
#line 2904
        if (Ascii) {
          {
#line 2905
          putchar(' ');
          }
        } else {
#line 2907
          if (OutputXML) {
#line 2907
            tmp___7 = "";
          } else {
#line 2907
            tmp___7 = "&nbsp;";
          }
          {
#line 2907
          printf((char const   */* __restrict  */)tmp___7);
          }
        }
#line 2909
        if (Csv) {
          {
#line 2910
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2911
        goto switch_break;
        case_22: /* CIL Label */ 
#line 2913
        if (Csv) {
          {
#line 2914
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2915
        num = atol((char const   *)((char *)u->str));
#line 2916
        NumToDate(num, & year, & month, & date);
#line 2917
        FracToTime(u->str, & hr, & minu, (int *)0, (int *)0);
#line 2918
        printf((char const   */* __restrict  */)"%d-%d-%02d %d:%02d", month, date,
               year, hr, minu);
        }
#line 2919
        if (Csv) {
          {
#line 2920
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2921
        goto switch_break;
        case_37: /* CIL Label */ 
#line 2923
        if (Csv) {
          {
#line 2924
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2925
        tmp___8 = atof((char const   *)((char *)u->str));
#line 2925
        PrintFloatComma((char *)"%.0f", 0, tmp___8);
        }
#line 2926
        if (Csv) {
          {
#line 2927
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2928
        goto switch_break;
        case_38: /* CIL Label */ 
#line 2930
        if (Csv) {
          {
#line 2931
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2932
        tmp___9 = atof((char const   *)((char *)u->str));
#line 2932
        PrintFloatComma((char *)"%.0f", 0, tmp___9);
        }
#line 2933
        if (Csv) {
          {
#line 2934
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2935
        goto switch_break;
        case_39: /* CIL Label */ 
#line 2937
        if (Csv) {
          {
#line 2938
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2939
        tmp___10 = atof((char const   *)((char *)u->str));
#line 2939
        PrintFloatComma((char *)"%.2f", 0, tmp___10);
        }
#line 2940
        if (Csv) {
          {
#line 2941
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2942
        goto switch_break;
        case_40: /* CIL Label */ 
#line 2944
        if (Csv) {
          {
#line 2945
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2946
        tmp___11 = atof((char const   *)((char *)u->str));
#line 2946
        PrintFloatComma((char *)"%.2f", 0, tmp___11);
        }
#line 2947
        if (Csv) {
          {
#line 2948
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2949
        goto switch_break;
        case_41: /* CIL Label */ 
#line 2951
        if (Csv) {
          {
#line 2952
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2953
        tmp___12 = atof((char const   *)((char *)u->str));
#line 2953
        PrintFloatComma((char *)"%.2f", 0, tmp___12);
        }
#line 2954
        if (Csv) {
          {
#line 2955
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2956
        goto switch_break;
        case_42: /* CIL Label */ 
#line 2958
        if (Csv) {
          {
#line 2959
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2960
        tmp___13 = atof((char const   *)((char *)u->str));
#line 2960
        PrintFloatComma((char *)"%.0f", 1, tmp___13);
        }
#line 2961
        if (Csv) {
          {
#line 2962
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2963
        goto switch_break;
        case_43: /* CIL Label */ 
#line 2965
        if (Csv) {
          {
#line 2966
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2967
        tmp___14 = atof((char const   *)((char *)u->str));
#line 2967
        PrintFloatComma((char *)"%.2f", 0, tmp___14);
        }
#line 2968
        if (Csv) {
          {
#line 2969
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2970
        goto switch_break;
        case_44: /* CIL Label */ 
        {
#line 2973
        tmp___15 = atof((char const   *)((char *)u->str));
#line 2973
        acc_val = tmp___15;
        }
#line 2974
        if (Csv) {
          {
#line 2975
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2976
        if (acc_val < 0.0) {
          {
#line 2977
          tmp___16 = fabs(acc_val);
#line 2977
          PrintFloatComma((char *)" (%.2f)", 1, tmp___16);
          }
        } else {
          {
#line 2979
          PrintFloatComma((char *)" %.2f", 1, acc_val);
          }
        }
#line 2980
        if (Csv) {
          {
#line 2981
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2982
        goto switch_break;
        case_45: /* CIL Label */ 
#line 2985
        if (Csv) {
          {
#line 2986
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2987
        FracToTime(u->str, & hr, & minu, & sec, (int *)0);
#line 2988
        printf((char const   */* __restrict  */)"%02d:%02d", minu, sec);
        }
#line 2989
        if (Csv) {
          {
#line 2990
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 2991
        goto switch_break;
        case_46: /* CIL Label */ 
#line 2993
        if (Csv) {
          {
#line 2994
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 2995
        FracToTime(u->str, & hr, & minu, & sec, (int *)0);
        }
#line 2996
        if (hr) {
          {
#line 2997
          printf((char const   */* __restrict  */)"%d:%02d:%02d", hr, minu, sec);
          }
        } else {
          {
#line 2999
          printf((char const   */* __restrict  */)"%02d:%02d", minu, sec);
          }
        }
#line 3000
        if (Csv) {
          {
#line 3001
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 3002
        goto switch_break;
        case_47: /* CIL Label */ 
#line 3004
        if (Csv) {
          {
#line 3005
          printf((char const   */* __restrict  */)"\"");
          }
        }
        {
#line 3006
        FracToTime(u->str, & hr, & minu, & sec, & msec);
#line 3007
        printf((char const   */* __restrict  */)"%02d:%02d.%01d", minu, sec, msec);
        }
#line 3008
        if (Csv) {
          {
#line 3009
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 3010
        goto switch_break;
        case_49: /* CIL Label */ 
        {
#line 3012
        dnum = atof((char const   *)((char *)u->str));
#line 3013
        printf((char const   */* __restrict  */)"%g", dnum);
        }
#line 3014
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 3017
        tmp___17 = strchr((char const   *)((char *)u->str), '.');
#line 3017
        ptr = tmp___17;
        }
#line 3018
        if (OutputXML) {
          {
#line 3019
          printf((char const   */* __restrict  */)"<NoFormat/>");
          }
        }
        {
#line 3020
        dnum = atof((char const   *)((char *)u->str));
        }
#line 3021
        if (ptr) {
#line 3023
          if (Csv) {
            {
#line 3024
            printf((char const   */* __restrict  */)"\"%.15g\"", dnum);
            }
          } else
#line 3025
          if (OutputXML) {
            {
#line 3026
            printf((char const   */* __restrict  */)"%.15g", dnum);
            }
          } else {
            {
#line 3028
            printf((char const   */* __restrict  */)"%.15g *", dnum);
            }
          }
        } else {
          {
#line 3032
          num = atol((char const   *)((char *)u->str));
          }
#line 3033
          if (Csv) {
            {
#line 3034
            printf((char const   */* __restrict  */)"%ld", num);
            }
          } else
#line 3035
          if (OutputXML) {
            {
#line 3036
            printf((char const   */* __restrict  */)"%ld", num);
            }
          } else {
            {
#line 3038
            printf((char const   */* __restrict  */)"%ld *", num);
            }
          }
        }
#line 3042
        NoFormat ++;
#line 3044
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 3048
        OutputString(u);
        }
      }
    } else {
      {
#line 3051
      OutputString(u);
      }
    }
  } else {
    {
#line 3051
    OutputString(u);
    }
  }
#line 3052
  return;
}
}
#line 3056 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void PrintFloatComma(char *fformat , int is_currency , double d ) 
{ 
  int len ;
  int int_len ;
  int dec_len ;
  char *ptr2 ;
  char buf[64] ;
  double tmp ;
  size_t tmp___0 ;
  char *ptr ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char rbuf[64] ;
  char buf2[64] ;
  int neg ;
  int i ;
  int j ;
  int count ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3061
  tmp = fabs(d);
#line 3061
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fformat,
          tmp);
#line 3062
  tmp___0 = strlen((char const   *)(buf));
#line 3062
  len = (int )tmp___0;
#line 3063
  ptr2 = strchr((char const   *)(buf), '.');
  }
#line 3064
  if (ptr2) {
    {
#line 3066
    int_len = (int )(ptr2 - buf);
#line 3067
    dec_len = len - int_len;
#line 3068
    tmp___2 = __ctype_b_loc();
    }
#line 3068
    if (((int const   )*(*tmp___2 + (int )buf[0]) & 2048) == 0) {
#line 3070
      ptr = & buf[0];
      {
#line 3071
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 3071
        tmp___1 = __ctype_b_loc();
        }
#line 3071
        if (! (((int const   )*(*tmp___1 + (int )*ptr) & 2048) == 0)) {
#line 3071
          goto while_break;
        }
#line 3073
        int_len --;
#line 3074
        ptr ++;
#line 3075
        if ((int )*ptr == 0) {
#line 3076
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 3082
    int_len = len;
#line 3083
    dec_len = 0;
  }
#line 3086
  if (int_len > 3) {
#line 3089
    count = 0;
#line 3091
    if (d < 0.0) {
#line 3092
      neg = 1;
    } else {
#line 3094
      neg = 0;
    }
#line 3097
    i = 0;
#line 3097
    j = len - 1;
    {
#line 3097
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3097
      if (! (i < len)) {
#line 3097
        goto while_break___0;
      }
#line 3098
      rbuf[i] = buf[j];
#line 3097
      i ++;
#line 3097
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3099
    rbuf[len] = (char)0;
#line 3100
    if (ptr2) {
      {
#line 3102
      memcpy((void */* __restrict  */)(buf2), (void const   */* __restrict  */)(rbuf),
             (size_t )dec_len);
#line 3103
      i = dec_len;
#line 3104
      j = dec_len;
      }
    } else {
#line 3108
      i = 0;
#line 3109
      j = 0;
    }
    {
#line 3112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3112
      if (! (i < len)) {
#line 3112
        goto while_break___1;
      }
#line 3114
      buf2[j] = rbuf[i];
#line 3115
      count ++;
#line 3116
      if (count % 3 == 0) {
        {
#line 3118
        tmp___3 = __ctype_b_loc();
        }
#line 3118
        if ((int const   )*(*tmp___3 + (int )rbuf[i + 1]) & 2048) {
#line 3119
          j ++;
#line 3119
          buf2[j] = (char )',';
        }
      }
#line 3112
      i ++;
#line 3112
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3122
    if (neg) {
#line 3123
      tmp___4 = j;
#line 3123
      j ++;
#line 3123
      buf2[tmp___4] = (char )'-';
    }
#line 3124
    if (is_currency) {
#line 3125
      tmp___5 = j;
#line 3125
      j ++;
#line 3125
      buf2[tmp___5] = (char )currency_symbol;
    }
    {
#line 3126
    buf2[j] = (char)0;
#line 3128
    tmp___6 = strlen((char const   *)(buf2));
#line 3128
    len = (int )tmp___6;
#line 3129
    i = 0;
#line 3129
    j = len - 1;
    }
    {
#line 3129
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3129
      if (! (i < len)) {
#line 3129
        goto while_break___2;
      }
#line 3130
      buf[i] = buf2[j];
#line 3129
      i ++;
#line 3129
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3131
    buf[len] = (char)0;
#line 3132
    if (Csv) {
      {
#line 3133
      printf((char const   */* __restrict  */)"\"%s\"", buf);
      }
    } else {
      {
#line 3135
      printf((char const   */* __restrict  */)"%s", buf);
      }
    }
  } else {
#line 3139
    if (is_currency) {
      {
#line 3140
      putchar((int )((char )currency_symbol));
      }
    }
    {
#line 3141
    printf((char const   */* __restrict  */)fformat, d);
    }
  }
#line 3143
  return;
}
}
#line 3145 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void print_as_fraction(double d , int digits ) 
{ 
  double i ;
  double j ;
  double w ;
  double r ;
  double closest ;
  double lim ;
  int ci ;
  int cj ;
  int n ;
  double tmp ;

  {
#line 3147
  closest = 1.0;
#line 3147
  lim = 9.0;
#line 3148
  ci = 1;
#line 3148
  cj = 1;
#line 3151
  if (digits == 2) {
#line 3152
    lim = 99.0;
  }
#line 3153
  if (d < (double )0) {
    {
#line 3154
    putchar('-');
    }
  }
  {
#line 3157
  w = fabs(d);
  }
#line 3158
  if (w >= 1.0) {
    {
#line 3160
    n = (int )w;
#line 3161
    printf((char const   */* __restrict  */)"%d ", n);
#line 3162
    r = w - (double )n;
    }
  } else {
#line 3165
    r = w;
  }
#line 3168
  j = lim;
  {
#line 3168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3168
    if (! (j > 0.0)) {
#line 3168
      goto while_break;
    }
#line 3170
    i = lim;
    {
#line 3170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3170
      if (! (i >= 0.0)) {
#line 3170
        goto while_break___0;
      }
      {
#line 3172
      tmp = fabs(i / j - r);
      }
#line 3172
      if (tmp <= closest) {
        {
#line 3174
        closest = fabs(i / j - r);
#line 3175
        ci = (int )i;
#line 3176
        cj = (int )j;
        }
      }
#line 3170
      i -= (double )1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3168
    j -= (double )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 3182
  if (ci != 0) {
    {
#line 3183
    printf((char const   */* __restrict  */)"%d/%d", ci, cj);
    }
  }
#line 3184
  return;
}
}
#line 3186 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void trim_sheet_edges(unsigned int sheet ) 
{ 
  cell *ce ;
  int not_done ;
  int r ;
  unsigned short c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3189
  not_done = 1;
#line 3193
  if (sheet >= max_worksheets) {
#line 3195
    return;
  } else
#line 3193
  if ((unsigned long )*(ws_array + sheet) == (unsigned long )((work_sheet *)0)) {
#line 3195
    return;
  } else
#line 3193
  if (trim_edges == 0) {
#line 3195
    return;
  } else
#line 3193
  if ((*(ws_array + sheet))->spanned) {
#line 3195
    return;
  }
#line 3196
  if ((unsigned long )(*(ws_array + sheet))->c_array == (unsigned long )((cell **)0)) {
#line 3197
    return;
  }
#line 3198
  if ((*(ws_array + sheet))->biggest_row == -1) {
#line 3200
    return;
  } else
#line 3198
  if ((int )(*(ws_array + sheet))->biggest_col == -1) {
#line 3200
    return;
  }
#line 3203
  r = (int )(*(ws_array + sheet))->first_row;
  {
#line 3203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3203
    if (! (r <= (*(ws_array + sheet))->biggest_row)) {
#line 3203
      goto while_break;
    }
#line 3205
    c = (*(ws_array + sheet))->first_col;
    {
#line 3205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3205
      if (! ((int )c <= (int )(*(ws_array + sheet))->biggest_col)) {
#line 3205
        goto while_break___0;
      }
#line 3207
      ce = *((*(ws_array + sheet))->c_array + (r * (int )(*(ws_array + sheet))->max_cols + (int )c));
#line 3208
      if (ce) {
#line 3210
        if (ce->ustr.str) {
          {
#line 3212
          tmp = null_string(ce->ustr.str);
          }
#line 3212
          if (! tmp) {
#line 3214
            not_done = 0;
#line 3215
            goto while_break___0;
          }
        }
      }
#line 3205
      c = (unsigned short )((int )c + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3220
    if (! not_done) {
#line 3221
      goto while_break;
    }
#line 3203
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3223
  if (not_done) {
#line 3224
    (*(ws_array + sheet))->first_row = (unsigned int )(*(ws_array + sheet))->biggest_row;
  } else {
#line 3226
    (*(ws_array + sheet))->first_row = (unsigned int )r;
  }
#line 3229
  not_done = 1;
#line 3230
  r = (*(ws_array + sheet))->biggest_row;
  {
#line 3230
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3230
    if (! (r > (int )(*(ws_array + sheet))->first_row)) {
#line 3230
      goto while_break___1;
    }
#line 3232
    c = (*(ws_array + sheet))->first_col;
    {
#line 3232
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3232
      if (! ((int )c <= (int )(*(ws_array + sheet))->biggest_col)) {
#line 3232
        goto while_break___2;
      }
#line 3234
      ce = *((*(ws_array + sheet))->c_array + (r * (int )(*(ws_array + sheet))->max_cols + (int )c));
#line 3235
      if (ce) {
#line 3237
        if (ce->ustr.str) {
          {
#line 3239
          tmp___0 = null_string(ce->ustr.str);
          }
#line 3239
          if (! tmp___0) {
#line 3241
            not_done = 0;
#line 3242
            goto while_break___2;
          }
        }
      }
#line 3232
      c = (unsigned short )((int )c + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3247
    if (! not_done) {
#line 3248
      goto while_break___1;
    }
#line 3230
    r --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3250
  (*(ws_array + sheet))->biggest_row = r;
#line 3253
  not_done = 1;
#line 3254
  c = (*(ws_array + sheet))->first_col;
  {
#line 3254
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3254
    if (! ((int )c <= (int )(*(ws_array + sheet))->biggest_col)) {
#line 3254
      goto while_break___3;
    }
#line 3256
    r = (int )(*(ws_array + sheet))->first_row;
    {
#line 3256
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3256
      if (! (r <= (*(ws_array + sheet))->biggest_row)) {
#line 3256
        goto while_break___4;
      }
#line 3258
      ce = *((*(ws_array + sheet))->c_array + (r * (int )(*(ws_array + sheet))->max_cols + (int )c));
#line 3259
      if (ce) {
#line 3261
        if (ce->ustr.str) {
          {
#line 3263
          tmp___1 = null_string(ce->ustr.str);
          }
#line 3263
          if (! tmp___1) {
#line 3265
            not_done = 0;
#line 3266
            goto while_break___4;
          }
        }
      }
#line 3256
      r ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3271
    if (! not_done) {
#line 3272
      goto while_break___3;
    }
#line 3254
    c = (unsigned short )((int )c + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3274
  if (not_done) {
#line 3275
    (*(ws_array + sheet))->first_col = (unsigned short )(*(ws_array + sheet))->biggest_col;
  } else {
#line 3277
    (*(ws_array + sheet))->first_col = c;
  }
#line 3280
  not_done = 1;
#line 3281
  c = (unsigned short )(*(ws_array + sheet))->biggest_col;
  {
#line 3281
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3281
    if (! ((int )c > (int )(*(ws_array + sheet))->first_col)) {
#line 3281
      goto while_break___5;
    }
#line 3283
    r = (int )(*(ws_array + sheet))->first_row;
    {
#line 3283
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3283
      if (! (r <= (*(ws_array + sheet))->biggest_row)) {
#line 3283
        goto while_break___6;
      }
#line 3285
      ce = *((*(ws_array + sheet))->c_array + (r * (int )(*(ws_array + sheet))->max_cols + (int )c));
#line 3286
      if (ce) {
#line 3288
        if (ce->ustr.str) {
          {
#line 3290
          tmp___2 = null_string(ce->ustr.str);
          }
#line 3290
          if (! tmp___2) {
#line 3292
            not_done = 0;
#line 3293
            goto while_break___6;
          }
        }
      }
#line 3283
      r ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3298
    if (! not_done) {
#line 3299
      goto while_break___5;
    }
#line 3281
    c = (unsigned short )((int )c - 1);
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3301
  (*(ws_array + sheet))->biggest_col = (short )c;
#line 3302
  return;
}
}
#line 3308 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void update_default_font(unsigned int sheet ) 
{ 
  cell *ce ;
  int r ;
  int c ;
  int f ;
  unsigned int fn ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 3313
  if (sheet >= max_worksheets) {
#line 3314
    return;
  } else
#line 3313
  if ((unsigned long )*(ws_array + sheet) == (unsigned long )((work_sheet *)0)) {
#line 3314
    return;
  }
#line 3315
  if ((unsigned long )(*(ws_array + sheet))->c_array == (unsigned long )((cell **)0)) {
#line 3316
    return;
  }
#line 3319
  r = 0;
  {
#line 3319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3319
    if (! (r < 32)) {
#line 3319
      goto while_break;
    }
#line 3321
    (f_cnt + r)->cnt = (unsigned short)0;
#line 3322
    if ((f_cnt + r)->name) {
#line 3324
      if (((f_cnt + r)->name)->str) {
        {
#line 3325
        free((void *)((f_cnt + r)->name)->str);
        }
      }
      {
#line 3326
      free((void *)(f_cnt + r)->name);
#line 3327
      (f_cnt + r)->name = (uni_string *)0;
      }
    }
#line 3319
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3330
  if (default_font.str) {
    {
#line 3331
    free((void *)default_font.str);
    }
  }
#line 3332
  r = 0;
  {
#line 3332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3332
    if (! (r < 7)) {
#line 3332
      goto while_break___0;
    }
#line 3333
    fnt_size_cnt[r] = 0;
#line 3332
    r ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3336
  r = (int )(*(ws_array + sheet))->first_row;
  {
#line 3336
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3336
    if (! (r <= (*(ws_array + sheet))->biggest_row)) {
#line 3336
      goto while_break___1;
    }
#line 3338
    c = (int )(*(ws_array + sheet))->first_col;
    {
#line 3338
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3338
      if (! (c <= (int )(*(ws_array + sheet))->biggest_col)) {
#line 3338
        goto while_break___2;
      }
#line 3340
      ce = *((*(ws_array + sheet))->c_array + (r * (int )(*(ws_array + sheet))->max_cols + c));
#line 3341
      if (ce) {
#line 3343
        if ((unsigned int )ce->xfmt < next_xf) {
#line 3343
          if (ce->ustr.str) {
            {
#line 3345
            tmp = strcmp((char const   *)((char *)ce->ustr.str), "&nbsp;");
            }
#line 3345
            if (tmp) {
#line 3347
              if ((unsigned int )ce->xfmt < next_xf) {
#line 3349
                if (*(xf_array + ce->xfmt)) {
#line 3351
                  fn = (unsigned int )(*(xf_array + ce->xfmt))->fnt_idx;
#line 3352
                  if (fn < next_font) {
#line 3354
                    if (*(font_array + fn)) {
#line 3356
                      if ((*(font_array + fn))->name.str) {
                        {
#line 3359
                        incr_f_cnt(& (*(font_array + fn))->name);
                        }
#line 3360
                        if ((int )(*(font_array + fn))->size < 8) {
#line 3360
                          if ((*(font_array + fn))->size) {
#line 3361
                            (fnt_size_cnt[(int )(*(font_array + fn))->size - 1]) ++;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 3338
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3336
    r ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3373
  f = get_default_font();
  }
#line 3374
  if (f == -1) {
    {
#line 3376
    tmp___0 = malloc((size_t )6);
#line 3376
    default_font.str = (unsigned char *)tmp___0;
    }
#line 3377
    if (default_font.str) {
      {
#line 3379
      strcpy((char */* __restrict  */)((char *)default_font.str), (char const   */* __restrict  */)"Arial");
#line 3380
      default_font.uni = (unsigned char)0;
#line 3381
      default_font.len = (unsigned short)5;
      }
    }
  } else {
    {
#line 3386
    tmp___1 = malloc((size_t )((int )((f_cnt + f)->name)->len + 1));
#line 3386
    default_font.str = (unsigned char *)tmp___1;
    }
#line 3387
    if (default_font.str) {
      {
#line 3389
      memcpy((void */* __restrict  */)default_font.str, (void const   */* __restrict  */)((f_cnt + f)->name)->str,
             (size_t )((f_cnt + f)->name)->len);
#line 3390
      *(default_font.str + ((f_cnt + f)->name)->len) = (unsigned char)0;
#line 3391
      default_font.uni = ((f_cnt + f)->name)->uni;
#line 3392
      default_font.len = ((f_cnt + f)->name)->len;
      }
    }
  }
#line 3398
  c = 0;
#line 3399
  f = 3;
#line 3400
  r = 0;
  {
#line 3400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3400
    if (! (r < 7)) {
#line 3400
      goto while_break___3;
    }
#line 3402
    if (fnt_size_cnt[r] > c) {
#line 3404
      c = fnt_size_cnt[r];
#line 3405
      f = r;
    }
#line 3400
    r ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3408
  if (fnt_size_cnt[2] == c) {
#line 3409
    default_fontsize = 3;
  } else {
#line 3411
    default_fontsize = f + 1;
  }
#line 3413
  r = 0;
  {
#line 3413
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3413
    if (! (r < 32)) {
#line 3413
      goto while_break___4;
    }
#line 3415
    if ((unsigned long )(f_cnt + r)->name != (unsigned long )((uni_string *)0)) {
#line 3417
      if ((unsigned long )((f_cnt + r)->name)->str != (unsigned long )((unsigned char *)0)) {
        {
#line 3418
        free((void *)((f_cnt + r)->name)->str);
        }
      }
      {
#line 3419
      free((void *)(f_cnt + r)->name);
#line 3420
      (f_cnt + r)->name = (uni_string *)0;
      }
    }
#line 3413
    r ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3423
  return;
}
}
#line 3425 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void incr_f_cnt(uni_string *name ) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 3429
  if ((unsigned long )name == (unsigned long )((uni_string *)0)) {
#line 3430
    return;
  } else
#line 3429
  if ((unsigned long )name->str == (unsigned long )((unsigned char *)0)) {
#line 3430
    return;
  } else
#line 3429
  if ((int )*(name->str + 0) == 0) {
#line 3430
    return;
  }
#line 3432
  i = 0;
  {
#line 3432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3432
    if (! (i < 32)) {
#line 3432
      goto while_break;
    }
#line 3434
    if ((f_cnt + i)->name) {
      {
#line 3436
      tmp = uni_string_comp(name, (f_cnt + i)->name);
      }
#line 3436
      if (tmp == 0) {
#line 3437
        (f_cnt + i)->cnt = (unsigned short )((int )(f_cnt + i)->cnt + 1);
      }
    } else {
      {
#line 3441
      tmp___0 = malloc(sizeof(uni_string ));
#line 3441
      (f_cnt + i)->name = (uni_string *)tmp___0;
      }
#line 3442
      if ((f_cnt + i)->name) {
        {
#line 3444
        tmp___1 = malloc((size_t )((int )name->len + 1));
#line 3444
        ((f_cnt + i)->name)->str = (unsigned char *)tmp___1;
        }
#line 3445
        if (((f_cnt + i)->name)->str) {
          {
#line 3447
          memcpy((void */* __restrict  */)((f_cnt + i)->name)->str, (void const   */* __restrict  */)name->str,
                 (size_t )name->len);
#line 3448
          *(((f_cnt + i)->name)->str + name->len) = (unsigned char)0;
#line 3449
          ((f_cnt + i)->name)->uni = name->uni;
#line 3450
          ((f_cnt + i)->name)->len = name->len;
#line 3451
          (f_cnt + i)->cnt = (unsigned short)1;
          }
#line 3452
          goto while_break;
        }
      }
    }
#line 3432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3457
  return;
}
}
#line 3459 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int get_default_font(void) 
{ 
  int i ;
  int m ;

  {
#line 3461
  m = -1;
#line 3463
  i = 0;
  {
#line 3463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3463
    if (! (i < 32)) {
#line 3463
      goto while_break;
    }
#line 3465
    if ((f_cnt + i)->name) {
#line 3467
      if (((f_cnt + i)->name)->str) {
#line 3469
        if ((int )(f_cnt + i)->cnt > m) {
#line 3470
          m = i;
        }
      }
    }
#line 3463
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3474
  return (m);
}
}
#line 3477 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void update_default_alignment(unsigned int sheet , int row ) 
{ 
  int i ;
  int left ;
  int center ;
  int right ;
  cell *c ;
  int numeric ;
  int tmp ;
  int tmp___0 ;

  {
#line 3479
  left = 0;
#line 3479
  center = 0;
#line 3479
  right = 0;
#line 3482
  if (sheet >= max_worksheets) {
#line 3483
    return;
  } else
#line 3482
  if ((unsigned long )*(ws_array + sheet) == (unsigned long )((work_sheet *)0)) {
#line 3483
    return;
  }
#line 3484
  if ((unsigned long )(*(ws_array + sheet))->c_array == (unsigned long )((cell **)0)) {
#line 3485
    return;
  }
#line 3487
  i = (int )(*(ws_array + sheet))->first_col;
  {
#line 3487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3487
    if (! (i <= (int )(*(ws_array + sheet))->biggest_col)) {
#line 3487
      goto while_break;
    }
#line 3489
    c = *((*(ws_array + sheet))->c_array + (row * (int )(*(ws_array + sheet))->max_cols + i));
#line 3490
    if (c) {
      {
#line 3492
      tmp = IsCellNumeric(c);
#line 3492
      numeric = tmp;
      }
#line 3493
      if ((int )c->xfmt == 0) {
#line 3495
        left ++;
      } else
#line 3499
      if ((unsigned int )c->xfmt < next_xf) {
#line 3499
        if (c->ustr.str) {
          {
#line 3501
          tmp___0 = strcmp((char const   *)((char *)c->ustr.str), "&nbsp;");
          }
#line 3501
          if (tmp___0) {
#line 3503
            if (*(xf_array + c->xfmt)) {
              {
#line 3508
              if (((int )(*(xf_array + c->xfmt))->align & 7) == 6) {
#line 3508
                goto case_6;
              }
#line 3508
              if (((int )(*(xf_array + c->xfmt))->align & 7) == 2) {
#line 3508
                goto case_6;
              }
#line 3511
              if (((int )(*(xf_array + c->xfmt))->align & 7) == 0) {
#line 3511
                goto case_0;
              }
#line 3519
              if (((int )(*(xf_array + c->xfmt))->align & 7) == 3) {
#line 3519
                goto case_3;
              }
#line 3523
              goto switch_default;
              case_6: /* CIL Label */ 
              case_2: /* CIL Label */ 
#line 3509
              center ++;
#line 3510
              goto switch_break;
              case_0: /* CIL Label */ 
#line 3512
              if (numeric) {
#line 3513
                right ++;
              } else
#line 3514
              if (((int )c->type & 255) == 5) {
#line 3515
                center ++;
              } else {
#line 3517
                left ++;
              }
#line 3518
              goto switch_break;
              case_3: /* CIL Label */ 
#line 3520
              right ++;
#line 3521
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 3524
              left ++;
#line 3525
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
#line 3487
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3533
  if (center == 0) {
#line 3533
    if (left == 0) {
#line 3533
      if (right == 0) {
#line 3534
        default_alignment = (char *)"";
      } else {
#line 3533
        goto _L___1;
      }
    } else {
#line 3533
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3535
  if (center >= left) {
#line 3535
    if (center >= right) {
#line 3536
      default_alignment = (char *)"center";
    } else {
#line 3535
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3537
  if (right >= center) {
#line 3537
    if (right >= left) {
#line 3538
      default_alignment = (char *)"right";
    } else {
#line 3540
      default_alignment = (char *)"left";
    }
  } else {
#line 3540
    default_alignment = (char *)"left";
  }
#line 3541
  return;
}
}
#line 3544 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void OutputString(uni_string *u ) 
{ 
  unsigned int i ;
  char const   *tmp ;
  unsigned short loc ;
  unsigned short fnt_idx ;
  unsigned short crun_cnt ;
  int format_changed ;
  html_attr h_flags ;
  int tmp___0 ;
  char const   *tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned short tmp___4 ;

  {
#line 3548
  if ((unsigned long )u == (unsigned long )((uni_string *)0)) {
#line 3549
    return;
  }
#line 3551
  if ((int )u->uni < 2) {
    {
#line 3553
    tmp___0 = null_string(u->str);
    }
#line 3553
    if (tmp___0) {
#line 3555
      if (Ascii == 0) {
#line 3556
        if (OutputXML) {
#line 3556
          tmp = "";
        } else {
#line 3556
          tmp = "&nbsp;";
        }
        {
#line 3556
        printf((char const   */* __restrict  */)tmp);
        }
      } else
#line 3557
      if (! Csv) {
        {
#line 3558
        printf((char const   */* __restrict  */)" ");
        }
      }
    } else {
#line 3562
      if (Ascii) {
#line 3564
        if (Csv) {
#line 3566
          i = 0U;
          {
#line 3566
          while (1) {
            while_continue: /* CIL Label */ ;
#line 3566
            if (! (i < (unsigned int )u->len)) {
#line 3566
              goto while_break;
            }
#line 3568
            if ((int )*(u->str + i) == 34) {
              {
#line 3569
              printf((char const   */* __restrict  */)"\"\"");
              }
            } else {
              {
#line 3571
              putchar((int )*(u->str + i));
              }
            }
#line 3566
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 3576
          i = 0U;
          {
#line 3576
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3576
            if (! (i < (unsigned int )u->len)) {
#line 3576
              goto while_break___0;
            }
            {
#line 3577
            putchar((int )*(u->str + i));
#line 3576
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 3579
        return;
      }
#line 3581
      if (u->crun_cnt) {
        {
#line 3583
        crun_cnt = (unsigned short)0;
#line 3584
        format_changed = 0;
#line 3588
        update_crun_info(& loc, & fnt_idx, crun_cnt, u->fmt_run);
#line 3589
        html_flag_init(& h_flags);
#line 3590
        i = 0U;
        }
        {
#line 3590
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3590
          if (! (i < (unsigned int )u->len)) {
#line 3590
            goto while_break___1;
          }
#line 3592
          if (i == (unsigned int )loc) {
#line 3594
            if (format_changed) {
              {
#line 3596
              output_end_html_attr(& h_flags);
              }
            } else {
#line 3601
              format_changed = 1;
            }
            {
#line 3605
            output_start_font_attribute(& h_flags, fnt_idx);
#line 3606
            output_start_html_attr(& h_flags, (unsigned int )fnt_idx, 1);
            }
#line 3609
            if ((int )crun_cnt < (int )u->crun_cnt) {
              {
#line 3611
              crun_cnt = (unsigned short )((int )crun_cnt + 1);
#line 3612
              update_crun_info(& loc, & fnt_idx, crun_cnt, u->fmt_run);
              }
            }
          }
          {
#line 3615
          OutputCharCorrected(*(u->str + i));
#line 3590
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3617
        if (format_changed) {
          {
#line 3619
          output_end_html_attr(& h_flags);
          }
        }
      } else {
#line 3624
        i = 0U;
        {
#line 3624
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3624
          if (! (i < (unsigned int )u->len)) {
#line 3624
            goto while_break___2;
          }
          {
#line 3625
          OutputCharCorrected(*(u->str + i));
#line 3624
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  } else
#line 3631
  if ((int )u->len == 0) {
#line 3633
    if (Ascii) {
      {
#line 3634
      printf((char const   */* __restrict  */)" ");
      }
    } else {
#line 3636
      if (OutputXML) {
#line 3636
        tmp___1 = "";
      } else {
#line 3636
        tmp___1 = "&nbsp;";
      }
      {
#line 3636
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
  } else
#line 3640
  if ((int )u->len == 2) {
    {
#line 3642
    tmp___3 = memcmp((void const   *)u->str, (void const   *)"& ", (size_t )2);
    }
#line 3642
    if (tmp___3 == 0) {
      {
#line 3643
      printf((char const   */* __restrict  */)"&#8230;");
      }
    } else {
#line 3646
      i = 0U;
      {
#line 3646
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3646
        if (! (i < (unsigned int )u->len)) {
#line 3646
          goto while_break___3;
        }
        {
#line 3647
        tmp___2 = getShort(u->str + i);
#line 3647
        print_utf8(tmp___2);
#line 3646
        i += 2U;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  } else {
#line 3652
    i = 0U;
    {
#line 3652
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3652
      if (! (i < (unsigned int )u->len)) {
#line 3652
        goto while_break___4;
      }
      {
#line 3653
      tmp___4 = getShort(u->str + i);
#line 3653
      print_utf8(tmp___4);
#line 3652
      i += 2U;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 3657
  return;
}
}
#line 3659 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void OutputCharCorrected(unsigned char c ) 
{ 


  {
#line 3661
  if (MultiByte) {
#line 3661
    if ((int )c & 128) {
      {
#line 3663
      putchar((int )c);
      }
#line 3664
      return;
    }
  }
  {
#line 3668
  if ((int )c == 60) {
#line 3668
    goto case_60;
  }
#line 3671
  if ((int )c == 62) {
#line 3671
    goto case_62;
  }
#line 3674
  if ((int )c == 38) {
#line 3674
    goto case_38;
  }
#line 3677
  if ((int )c == 34) {
#line 3677
    goto case_34;
  }
#line 3681
  if ((int )c == 128) {
#line 3681
    goto case_128;
  }
#line 3684
  if ((int )c == 130) {
#line 3684
    goto case_130;
  }
#line 3687
  if ((int )c == 131) {
#line 3687
    goto case_131;
  }
#line 3690
  if ((int )c == 132) {
#line 3690
    goto case_132;
  }
#line 3693
  if ((int )c == 133) {
#line 3693
    goto case_133;
  }
#line 3696
  if ((int )c == 134) {
#line 3696
    goto case_134;
  }
#line 3699
  if ((int )c == 135) {
#line 3699
    goto case_135;
  }
#line 3702
  if ((int )c == 136) {
#line 3702
    goto case_136;
  }
#line 3705
  if ((int )c == 137) {
#line 3705
    goto case_137;
  }
#line 3708
  if ((int )c == 138) {
#line 3708
    goto case_138;
  }
#line 3711
  if ((int )c == 139) {
#line 3711
    goto case_139;
  }
#line 3714
  if ((int )c == 140) {
#line 3714
    goto case_140;
  }
#line 3717
  if ((int )c == 142) {
#line 3717
    goto case_142;
  }
#line 3720
  if ((int )c == 145) {
#line 3720
    goto case_145;
  }
#line 3723
  if ((int )c == 146) {
#line 3723
    goto case_146;
  }
#line 3726
  if ((int )c == 147) {
#line 3726
    goto case_147;
  }
#line 3729
  if ((int )c == 148) {
#line 3729
    goto case_148;
  }
#line 3732
  if ((int )c == 149) {
#line 3732
    goto case_149;
  }
#line 3735
  if ((int )c == 150) {
#line 3735
    goto case_150;
  }
#line 3738
  if ((int )c == 151) {
#line 3738
    goto case_151;
  }
#line 3741
  if ((int )c == 152) {
#line 3741
    goto case_152;
  }
#line 3744
  if ((int )c == 153) {
#line 3744
    goto case_153;
  }
#line 3747
  if ((int )c == 154) {
#line 3747
    goto case_154;
  }
#line 3750
  if ((int )c == 155) {
#line 3750
    goto case_155;
  }
#line 3753
  if ((int )c == 156) {
#line 3753
    goto case_156;
  }
#line 3756
  if ((int )c == 159) {
#line 3756
    goto case_159;
  }
#line 3759
  if ((int )c == 225) {
#line 3759
    goto case_225;
  }
#line 3762
  if ((int )c == 233) {
#line 3762
    goto case_233;
  }
#line 3765
  if ((int )c == 237) {
#line 3765
    goto case_237;
  }
#line 3768
  if ((int )c == 243) {
#line 3768
    goto case_243;
  }
#line 3771
  if ((int )c == 250) {
#line 3771
    goto case_250;
  }
#line 3774
  if ((int )c == 253) {
#line 3774
    goto case_253;
  }
#line 3777
  if ((int )c == 193) {
#line 3777
    goto case_193;
  }
#line 3780
  if ((int )c == 201) {
#line 3780
    goto case_201;
  }
#line 3783
  if ((int )c == 205) {
#line 3783
    goto case_205;
  }
#line 3786
  if ((int )c == 211) {
#line 3786
    goto case_211;
  }
#line 3789
  if ((int )c == 218) {
#line 3789
    goto case_218;
  }
#line 3792
  if ((int )c == 221) {
#line 3792
    goto case_221;
  }
#line 3795
  if ((int )c == 176) {
#line 3795
    goto case_176;
  }
#line 3798
  goto switch_default;
  case_60: /* CIL Label */ 
  {
#line 3669
  printf((char const   */* __restrict  */)"&lt;");
  }
#line 3670
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 3672
  printf((char const   */* __restrict  */)"&gt;");
  }
#line 3673
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 3675
  printf((char const   */* __restrict  */)"&amp;");
  }
#line 3676
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 3678
  printf((char const   */* __restrict  */)"&quot;");
  }
#line 3679
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 3682
  printf((char const   */* __restrict  */)"&#8364;");
  }
#line 3683
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 3685
  printf((char const   */* __restrict  */)"&#8218;");
  }
#line 3686
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 3688
  printf((char const   */* __restrict  */)"&#402;");
  }
#line 3689
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 3691
  printf((char const   */* __restrict  */)"&#8222;");
  }
#line 3692
  goto switch_break;
  case_133: /* CIL Label */ 
  {
#line 3694
  printf((char const   */* __restrict  */)"&#8230;");
  }
#line 3695
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 3697
  printf((char const   */* __restrict  */)"&#8224;");
  }
#line 3698
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 3700
  printf((char const   */* __restrict  */)"&#8225;");
  }
#line 3701
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 3703
  printf((char const   */* __restrict  */)"&#710;");
  }
#line 3704
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 3706
  printf((char const   */* __restrict  */)"&#8240;");
  }
#line 3707
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 3709
  printf((char const   */* __restrict  */)"&#352;");
  }
#line 3710
  goto switch_break;
  case_139: /* CIL Label */ 
  {
#line 3712
  printf((char const   */* __restrict  */)"&#8249;");
  }
#line 3713
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 3715
  printf((char const   */* __restrict  */)"&#338;");
  }
#line 3716
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 3718
  printf((char const   */* __restrict  */)"&#381;");
  }
#line 3719
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 3721
  printf((char const   */* __restrict  */)"&#8216;");
  }
#line 3722
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 3724
  printf((char const   */* __restrict  */)"&#8217;");
  }
#line 3725
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 3727
  printf((char const   */* __restrict  */)"&#8220;");
  }
#line 3728
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 3730
  printf((char const   */* __restrict  */)"&#8221;");
  }
#line 3731
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 3733
  printf((char const   */* __restrict  */)"&#8226;");
  }
#line 3734
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 3736
  printf((char const   */* __restrict  */)"&#8211;");
  }
#line 3737
  goto switch_break;
  case_151: /* CIL Label */ 
  {
#line 3739
  printf((char const   */* __restrict  */)"&#8212;");
  }
#line 3740
  goto switch_break;
  case_152: /* CIL Label */ 
  {
#line 3742
  printf((char const   */* __restrict  */)"&#732;");
  }
#line 3743
  goto switch_break;
  case_153: /* CIL Label */ 
  {
#line 3745
  printf((char const   */* __restrict  */)"&#8482;");
  }
#line 3746
  goto switch_break;
  case_154: /* CIL Label */ 
  {
#line 3748
  printf((char const   */* __restrict  */)"&#353;");
  }
#line 3749
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 3751
  printf((char const   */* __restrict  */)"&#8250;");
  }
#line 3752
  goto switch_break;
  case_156: /* CIL Label */ 
  {
#line 3754
  printf((char const   */* __restrict  */)"&#339;");
  }
#line 3755
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 3757
  printf((char const   */* __restrict  */)"&#376;");
  }
#line 3758
  goto switch_break;
  case_225: /* CIL Label */ 
  {
#line 3760
  printf((char const   */* __restrict  */)"&#225;");
  }
#line 3761
  goto switch_break;
  case_233: /* CIL Label */ 
  {
#line 3763
  printf((char const   */* __restrict  */)"&#233;");
  }
#line 3764
  goto switch_break;
  case_237: /* CIL Label */ 
  {
#line 3766
  printf((char const   */* __restrict  */)"&#237;");
  }
#line 3767
  goto switch_break;
  case_243: /* CIL Label */ 
  {
#line 3769
  printf((char const   */* __restrict  */)"&#243;");
  }
#line 3770
  goto switch_break;
  case_250: /* CIL Label */ 
  {
#line 3772
  printf((char const   */* __restrict  */)"&#250;");
  }
#line 3773
  goto switch_break;
  case_253: /* CIL Label */ 
  {
#line 3775
  printf((char const   */* __restrict  */)"&#253;");
  }
#line 3776
  goto switch_break;
  case_193: /* CIL Label */ 
  {
#line 3778
  printf((char const   */* __restrict  */)"&#193;");
  }
#line 3779
  goto switch_break;
  case_201: /* CIL Label */ 
  {
#line 3781
  printf((char const   */* __restrict  */)"&#201;");
  }
#line 3782
  goto switch_break;
  case_205: /* CIL Label */ 
  {
#line 3784
  printf((char const   */* __restrict  */)"&#205;");
  }
#line 3785
  goto switch_break;
  case_211: /* CIL Label */ 
  {
#line 3787
  printf((char const   */* __restrict  */)"&#211;");
  }
#line 3788
  goto switch_break;
  case_218: /* CIL Label */ 
  {
#line 3790
  printf((char const   */* __restrict  */)"&#218;");
  }
#line 3791
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 3793
  printf((char const   */* __restrict  */)"&#221;");
  }
#line 3794
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 3796
  printf((char const   */* __restrict  */)"deg.");
  }
#line 3797
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 3799
  putchar((int )c);
  }
#line 3800
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3802
  return;
}
}
#line 3804 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void update_crun_info(unsigned short *loc , unsigned short *fmt_idx , unsigned short crun_cnt ,
                      unsigned char *fmt_run ) 
{ 
  unsigned short tloc ;
  unsigned short tfmt_idx ;
  unsigned short offset ;

  {
  {
#line 3807
  offset = (unsigned short )((int )crun_cnt * 4);
#line 3809
  tloc = getShort(fmt_run + offset);
#line 3810
  tfmt_idx = getShort(fmt_run + ((int )offset + 2));
#line 3811
  *loc = tloc;
#line 3812
  *fmt_idx = tfmt_idx;
  }
#line 3813
  return;
}
}
#line 3815 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void put_utf8(unsigned short c ) 
{ 


  {
  {
#line 3817
  putchar(128 | ((int )c & 63));
  }
#line 3818
  return;
}
}
#line 3820 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void print_utf8(unsigned short c ) 
{ 


  {
#line 3822
  if ((int )c < 128) {
    {
#line 3823
    OutputCharCorrected((unsigned char )c);
    }
  } else
#line 3824
  if ((int )c < 2048) {
    {
#line 3826
    putchar(192 | ((int )c >> 6));
#line 3827
    put_utf8(c);
    }
  } else {
    {
#line 3831
    putchar(224 | ((int )c >> 12));
#line 3832
    put_utf8((unsigned short )((int )c >> 6));
#line 3833
    put_utf8(c);
    }
  }
#line 3835
  return;
}
}
#line 3837 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void uni_string_clear(uni_string *str ) 
{ 


  {
#line 3839
  if ((unsigned long )str == (unsigned long )((uni_string *)0)) {
#line 3840
    return;
  }
#line 3842
  str->str = (unsigned char *)0;
#line 3843
  str->uni = (unsigned char)0;
#line 3844
  str->len = (unsigned short)0;
#line 3845
  str->fmt_run = (unsigned char *)0;
#line 3846
  str->crun_cnt = (unsigned char)0;
#line 3847
  return;
}
}
#line 3849 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
int uni_string_comp(uni_string *s1 , uni_string *s2 ) 
{ 
  int tmp ;

  {
#line 3851
  if ((unsigned long )s1 == (unsigned long )((uni_string *)0)) {
#line 3852
    return (-1);
  } else
#line 3851
  if ((unsigned long )s2 == (unsigned long )((uni_string *)0)) {
#line 3852
    return (-1);
  }
#line 3853
  if ((unsigned long )s1->str == (unsigned long )((unsigned char *)0)) {
#line 3854
    return (-1);
  } else
#line 3853
  if ((unsigned long )s2->str == (unsigned long )((unsigned char *)0)) {
#line 3854
    return (-1);
  }
#line 3856
  if ((int )s1->uni == (int )s2->uni) {
#line 3856
    if ((int )s1->len == (int )s2->len) {
      {
#line 3857
      tmp = memcmp((void const   *)s1->str, (void const   *)s2->str, (size_t )s1->len);
      }
#line 3857
      return (tmp);
    } else {
#line 3859
      return (-1);
    }
  } else {
#line 3859
    return (-1);
  }
}
}
#line 3864 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void html_flag_init(html_attr *h ) 
{ 


  {
#line 3866
  h->fflag = 0;
#line 3867
  h->bflag = 0;
#line 3868
  h->iflag = 0;
#line 3869
  h->sflag = 0;
#line 3870
  h->uflag = 0;
#line 3871
  h->sbflag = 0;
#line 3872
  h->spflag = 0;
#line 3873
  return;
}
}
#line 3875 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlhtml.c"
void output_start_font_attribute(html_attr *h , unsigned short fnt_idx ) 
{ 
  int tmp ;
  char color[8] ;
  int tmp___0 ;

  {
  {
#line 3877
  tmp = uni_string_comp(& default_font, & (*(font_array + fnt_idx))->name);
  }
#line 3877
  if (tmp != 0) {
    {
#line 3879
    h->fflag = 1;
#line 3880
    printf((char const   */* __restrict  */)"<FONT FACE=\"");
#line 3881
    OutputString(& (*(font_array + fnt_idx))->name);
#line 3882
    printf((char const   */* __restrict  */)"\"");
    }
  }
#line 3884
  if ((int )(*(font_array + fnt_idx))->c_idx != 32767) {
#line 3887
    if (numCustomColors) {
#line 3889
      if ((int )(*(font_array + fnt_idx))->c_idx < numCustomColors) {
#line 3889
        if (use_colors) {
          {
#line 3890
          strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)((char *)*(customColors + ((int )(*(font_array + fnt_idx))->c_idx - 8))));
          }
        } else {
          {
#line 3892
          strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)"000000");
          }
        }
      } else {
        {
#line 3892
        strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)"000000");
        }
      }
    } else
#line 3896
    if ((int )(*(font_array + fnt_idx))->c_idx < 65) {
#line 3896
      if (use_colors) {
        {
#line 3897
        strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)(colorTab[(*(font_array + fnt_idx))->c_idx]));
        }
      } else {
        {
#line 3899
        strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)"000000");
        }
      }
    } else {
      {
#line 3899
      strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)"000000");
      }
    }
    {
#line 3901
    tmp___0 = strcmp((char const   *)(color), "000000");
    }
#line 3901
    if (tmp___0 != 0) {
#line 3903
      if (h->fflag) {
        {
#line 3904
        printf((char const   */* __restrict  */)" COLOR=\"%s\"", color);
        }
      } else {
        {
#line 3907
        h->fflag = 1;
#line 3908
        printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\"", color);
        }
      }
    }
  }
#line 3912
  if ((int )(*(font_array + fnt_idx))->super & 3) {
#line 3914
    if (h->fflag) {
      {
#line 3915
      printf((char const   */* __restrict  */)" SIZE=\"2\"");
      }
    } else {
      {
#line 3918
      h->fflag = 1;
#line 3919
      printf((char const   */* __restrict  */)"<FONT SIZE=\"2\"");
      }
    }
  } else
#line 3924
  if (h->fflag) {
#line 3926
    if ((int )(*(font_array + fnt_idx))->size != default_fontsize) {
      {
#line 3927
      printf((char const   */* __restrict  */)" SIZE=\"%d\"", (int )(*(font_array + fnt_idx))->size);
      }
    }
  } else
#line 3931
  if ((int )(*(font_array + fnt_idx))->size != default_fontsize) {
    {
#line 3933
    h->fflag = 1;
#line 3934
    printf((char const   */* __restrict  */)"<FONT SIZE=\"%d\"", (int )(*(font_array + fnt_idx))->size);
    }
  }
#line 3938
  if (h->fflag) {
    {
#line 3939
    printf((char const   */* __restrict  */)">");
    }
  }
#line 3940
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___0(pps_entry *node , unsigned short level ) ;
#line 74
static void ends___2(void) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *input___0  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Block___0  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Blockx___0  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *BDepot___2  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *SDepot___2  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Root___2  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static pps_entry *pps_list___0  ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int num_of_pps___0  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *sbfile___2  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *sbd_list___0  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *root_list___1  ;
#line 597 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *last_next_link_visited___0  ;
#line 598 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___0(pps_entry *node , unsigned short level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 603
  node->level = level;
#line 606
  if ((unsigned long )node->dir != 4294967295UL) {
#line 608
    if (node->dir > num_of_pps___0) {
#line 609
      return (0);
    } else
#line 608
    if (! (pps_list___0 + node->dir)->name[0]) {
#line 609
      return (0);
    } else {
      {
#line 610
      tmp = reorder_pps_tree___0(pps_list___0 + node->dir, (unsigned short )((int )level + 1));
      }
#line 610
      if (! tmp) {
#line 611
        return (0);
      }
    }
  }
#line 615
  if ((unsigned long )node->next != 4294967295UL) {
#line 617
    if (node->next > num_of_pps___0) {
#line 618
      return (0);
    } else
#line 617
    if (! (pps_list___0 + node->next)->name[0]) {
#line 618
      return (0);
    } else {
      {
#line 619
      tmp___0 = reorder_pps_tree___0(pps_list___0 + node->next, level);
      }
#line 619
      if (! tmp___0) {
#line 620
        return (0);
      }
    }
  } else {
#line 623
    last_next_link_visited___0 = & node->next;
  }
#line 626
  if ((unsigned long )node->previous != 4294967295UL) {
#line 628
    if (node->previous > num_of_pps___0) {
#line 629
      return (0);
    } else
#line 628
    if (! (pps_list___0 + node->previous)->name[0]) {
#line 629
      return (0);
    } else {
      {
#line 632
      *last_next_link_visited___0 = node->previous;
#line 633
      node->previous = 4294967295U;
#line 634
      tmp___1 = reorder_pps_tree___0(pps_list___0 + *last_next_link_visited___0, level);
      }
#line 634
      if (! tmp___1) {
#line 635
        return (0);
      }
    }
  }
#line 638
  return (1);
}
}
#line 759 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static void ends___2(void) 
{ 


  {
#line 767
  if ((unsigned long )Block___0 != (unsigned long )((void *)0)) {
    {
#line 767
    free((void *)Block___0);
    }
  }
#line 768
  if ((unsigned long )Blockx___0 != (unsigned long )((void *)0)) {
    {
#line 768
    free((void *)Blockx___0);
    }
  }
#line 775
  if ((unsigned long )Root___2 != (unsigned long )((void *)0)) {
    {
#line 775
    free((void *)Root___2);
    }
  }
#line 776
  if ((unsigned long )sbd_list___0 != (unsigned long )((void *)0)) {
    {
#line 776
    free((void *)sbd_list___0);
    }
  }
#line 777
  if ((unsigned long )root_list___1 != (unsigned long )((void *)0)) {
    {
#line 777
    free((void *)root_list___1);
    }
  }
#line 787
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xml.c"
void OutputTableXML(void) 
{ 
  int i ;
  int j ;
  int k ;

  {
  {
#line 32
  printf((char const   */* __restrict  */)"<?xml version=\"1.0\" encoding=\"");
  }
  {
#line 35
  if (UnicodeStrings == 0) {
#line 35
    goto case_0;
  }
#line 38
  if (UnicodeStrings == 1) {
#line 38
    goto case_1;
  }
#line 41
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 36
  printf((char const   */* __restrict  */)"iso-8859-1\" ?>\n");
  }
#line 37
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 39
  printf((char const   */* __restrict  */)"windows-1252\"?>\n");
  }
#line 40
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 42
  printf((char const   */* __restrict  */)"utf-8\"?>\n");
  }
#line 43
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 46
  SetupExtraction();
#line 48
  printf((char const   */* __restrict  */)"<excel_workbook>\n");
#line 49
  printf((char const   */* __restrict  */)"\t<sheets>\n");
#line 52
  i = first_sheet;
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i <= last_sheet)) {
#line 52
      goto while_break;
    }
    {
#line 54
    trim_sheet_edges((unsigned int )i);
#line 55
    update_default_font((unsigned int )i);
    }
#line 56
    if ((unsigned long )*(ws_array + i) == (unsigned long )((work_sheet *)0)) {
#line 57
      goto __Cont;
    }
#line 58
    if ((*(ws_array + i))->biggest_row == -1) {
#line 59
      goto __Cont;
    } else
#line 58
    if ((int )(*(ws_array + i))->biggest_col == -1) {
#line 59
      goto __Cont;
    }
#line 60
    if ((unsigned long )(*(ws_array + i))->c_array == (unsigned long )((cell **)0)) {
#line 61
      goto __Cont;
    }
    {
#line 63
    printf((char const   */* __restrict  */)"\t\t<sheet>\n");
#line 64
    printf((char const   */* __restrict  */)"\t\t\t<page>%d</page>\n", i);
    }
#line 67
    if (next_ws_title > 0U) {
#line 69
      if ((*(ws_array + i))->ws_title.str) {
        {
#line 71
        printf((char const   */* __restrict  */)"\t\t\t<pagetitle>");
#line 72
        OutputString(& (*(ws_array + i))->ws_title);
#line 73
        printf((char const   */* __restrict  */)"</pagetitle>\n");
        }
      } else {
        {
#line 76
        printf((char const   */* __restrict  */)"\t\t\t<pagetitle>(Unknown Page)</pagetitle>\n");
        }
      }
    }
    {
#line 79
    printf((char const   */* __restrict  */)"\t\t\t<firstrow>%ld</firstrow>\n", (unsigned long )(*(ws_array + i))->first_row);
#line 80
    printf((char const   */* __restrict  */)"\t\t\t<lastrow>%d</lastrow>\n", (*(ws_array + i))->biggest_row);
#line 81
    printf((char const   */* __restrict  */)"\t\t\t<firstcol>%ld</firstcol>\n", (long )(*(ws_array + i))->first_col);
#line 82
    printf((char const   */* __restrict  */)"\t\t\t<lastcol>%d</lastcol>\n", (int )(*(ws_array + i))->biggest_col);
#line 83
    printf((char const   */* __restrict  */)"\t\t\t<rows>\n");
#line 85
    j = (int )(*(ws_array + i))->first_row;
    }
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 85
      if (! (j <= (*(ws_array + i))->biggest_row)) {
#line 85
        goto while_break___0;
      }
      {
#line 87
      update_default_alignment((unsigned int )i, j);
#line 88
      printf((char const   */* __restrict  */)"\t\t\t\t<row>\n");
#line 89
      k = (int )(*(ws_array + i))->first_col;
      }
      {
#line 89
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 89
        if (! (k <= (int )(*(ws_array + i))->biggest_col)) {
#line 89
          goto while_break___1;
        }
        {
#line 91
        printf((char const   */* __restrict  */)"\t\t\t\t\t<cell row=\"%d\" col=\"%d\"",
               j, k);
#line 92
        output_cell(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)),
                    1);
#line 93
        printf((char const   */* __restrict  */)"</cell>\n");
        }
#line 94
        if (*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k))) {
#line 96
          if ((int )(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)))->colspan != 0) {
#line 97
            k += (int )(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)))->colspan - 1;
          }
        }
#line 89
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 102
      printf((char const   */* __restrict  */)"\t\t\t\t</row>\n");
#line 85
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 104
    printf((char const   */* __restrict  */)"\t\t\t</rows>\n");
#line 105
    printf((char const   */* __restrict  */)"\t\t</sheet>\n");
    }
    __Cont: /* CIL Label */ 
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  printf((char const   */* __restrict  */)"\t</sheets>\n");
  }
#line 110
  if (author.str) {
    {
#line 112
    printf((char const   */* __restrict  */)"\t<author>");
#line 113
    OutputString(& author);
#line 114
    printf((char const   */* __restrict  */)"</author>\n");
    }
  }
#line 118
  if (lastUpdated) {
    {
#line 119
    printf((char const   */* __restrict  */)"\t<lastwrite>%s</lastwrite>", lastUpdated);
    }
  }
  {
#line 120
  printf((char const   */* __restrict  */)"\t<excelversion>");
  }
  {
#line 123
  if (file_version == 1280) {
#line 123
    goto case_1280;
  }
#line 126
  if (file_version == 1536) {
#line 126
    goto case_1536;
  }
#line 129
  goto switch_default___0;
  case_1280: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"using Excel 5.0 or 95");
  }
#line 125
  goto switch_break___0;
  case_1536: /* CIL Label */ 
  {
#line 127
  printf((char const   */* __restrict  */)"using Excel 97/2000");
  }
#line 128
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 130
  printf((char const   */* __restrict  */)"using Excel ????");
  }
#line 131
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 133
  printf((char const   */* __restrict  */)"</excelversion>\n");
  }
#line 136
  if (NoFormat) {
    {
#line 137
    printf((char const   */* __restrict  */)"\t<noformat>%d</noformat>\n", NoFormat);
    }
  }
#line 138
  if (notAccurate) {
#line 138
    if (formula_warnings) {
      {
#line 139
      printf((char const   */* __restrict  */)"\t<accuracy>%d</accuracy>\n", notAccurate);
      }
    }
  }
#line 140
  if (NotImplemented) {
    {
#line 141
    printf((char const   */* __restrict  */)"\t<notimplemented>%d</notimplemented>\n",
           NotImplemented);
    }
  }
#line 142
  if (Unsupported) {
    {
#line 143
    printf((char const   */* __restrict  */)"\t<unsupported>%d</unsupported>\n", Unsupported);
    }
  }
#line 146
  if (MaxWorksheetsExceeded) {
    {
#line 147
    printf((char const   */* __restrict  */)"\t<MaxWorksheetsExceeded>The Maximum Number of Worksheets were exceeded, you might want to increase it.</MaxWorksheetsExceeded>\n ");
    }
  }
#line 148
  if (MaxRowExceeded) {
    {
#line 149
    printf((char const   */* __restrict  */)"\t<MaxRowExceeded>The Maximum Number of Rows were exceeded, you might want to increase it.</MaxRowExceeded>\n ");
    }
  }
#line 150
  if (MaxColExceeded) {
    {
#line 151
    printf((char const   */* __restrict  */)"\t<MaxColExceeded>The Maximum Number of Columns were exceeded, you might want to increase it.</MaxColExceeded>\n");
    }
  }
#line 152
  if (MaxStringsExceeded) {
    {
#line 153
    printf((char const   */* __restrict  */)"\t<MaxStringsExceeded>The Maximum Number of Strings were exceeded, you might want to increase it.</MaxStringsExceeded>\n");
    }
  }
#line 154
  if (MaxFontsExceeded) {
    {
#line 155
    printf((char const   */* __restrict  */)"\t<MaxFontsExceeded>The Maximum Number of Fonts were exceeded, you might want to increase it.</MaxFontsExceeded>\n");
    }
  }
#line 156
  if (MaxPalExceeded) {
    {
#line 157
    printf((char const   */* __restrict  */)"\t<MaxPalExceeded>The Maximum Number of Color Palettes were exceeded, you might want to increase it.</MaxPalExceeded>\n");
    }
  }
#line 158
  if (MaxXFExceeded) {
    {
#line 159
    printf((char const   */* __restrict  */)"\t<MaxXFExceeded>The Maximum Number of Extended Formats were exceeded, you might want to increase it.</MaxXFExceeded>\n");
    }
  }
#line 160
  if (MaxFormatsExceeded) {
    {
#line 161
    printf((char const   */* __restrict  */)"\t<MaxFormatsExceeded>The Maximum Number of Formats were exceeded, you might want to increase it.</MaxFormatsExceeded>\n");
    }
  }
  {
#line 164
  printf((char const   */* __restrict  */)"\t<tool>Created with xlhtml %s</tool>\n",
         "0.5.1");
#line 165
  printf((char const   */* __restrict  */)"\t<toollink>http://chicago.sf.net/xlhtml/</toollink>\n");
#line 166
  printf((char const   */* __restrict  */)"</excel_workbook>\n");
  }
#line 167
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/ascii.c"
void OutputPartialTableAscii(void) 
{ 
  int i ;
  int j ;
  int k ;
  int safe ;
  int numeric ;
  cell *c ;
  int tmp ;

  {
  {
#line 33
  SetupExtraction();
#line 36
  i = first_sheet;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i <= last_sheet)) {
#line 36
      goto while_break;
    }
#line 38
    if ((unsigned long )*(ws_array + i) == (unsigned long )((work_sheet *)0)) {
#line 39
      goto __Cont;
    }
#line 40
    if ((*(ws_array + i))->biggest_row == -1) {
#line 41
      goto __Cont;
    } else
#line 40
    if ((int )(*(ws_array + i))->biggest_col == -1) {
#line 41
      goto __Cont;
    }
#line 42
    if ((unsigned long )(*(ws_array + i))->c_array == (unsigned long )((cell **)0)) {
#line 43
      goto __Cont;
    }
#line 46
    j = (int )(*(ws_array + i))->first_row;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 46
      if (! (j <= (*(ws_array + i))->biggest_row)) {
#line 46
        goto while_break___0;
      }
#line 48
      k = (int )(*(ws_array + i))->first_col;
      {
#line 48
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 48
        if (! (k <= (int )(*(ws_array + i))->biggest_col)) {
#line 48
          goto while_break___1;
        }
#line 50
        numeric = 0;
#line 51
        c = *((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k));
#line 53
        if (c) {
          {
#line 55
          numeric = IsCellNumeric(c);
          }
#line 56
          if (! numeric) {
#line 56
            if (Csv) {
              {
#line 57
              printf((char const   */* __restrict  */)"\"");
              }
            }
          }
          {
#line 58
          safe = IsCellSafe(c);
          }
#line 60
          if (c->ustr.str) {
#line 62
            if (safe) {
              {
#line 63
              tmp = IsCellFormula(c);
#line 63
              output_formatted_data(& c->ustr, (*(xf_array + c->xfmt))->fmt_idx, numeric,
                                    tmp);
              }
            } else {
              {
#line 65
              OutputString(& c->ustr);
              }
            }
          } else
#line 67
          if (! Csv) {
            {
#line 68
            printf((char const   */* __restrict  */)" ");
            }
          }
        } else
#line 72
        if (! Csv) {
          {
#line 73
          printf((char const   */* __restrict  */)" ");
          }
        } else {
          {
#line 75
          printf((char const   */* __restrict  */)"\"");
          }
        }
#line 77
        if (*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k))) {
#line 79
          if ((int )(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)))->colspan != 0) {
#line 80
            k += (int )(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)))->colspan - 1;
          }
        }
#line 82
        if (! numeric) {
#line 82
          if (Csv) {
            {
#line 83
            printf((char const   */* __restrict  */)"\"");
            }
          }
        }
#line 85
        if (Csv) {
#line 85
          if (k < (int )(*(ws_array + i))->biggest_col) {
            {
#line 87
            putchar(',');
            }
          } else {
#line 85
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 91
        if (! Csv) {
#line 91
          if (k != (int )(*(ws_array + i))->biggest_col) {
            {
#line 92
            putchar('\t');
            }
          }
        }
#line 48
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 95
      if (Csv) {
        {
#line 96
        printf((char const   */* __restrict  */)"\r\n");
        }
      } else {
        {
#line 98
        putchar(10);
        }
      }
#line 46
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 100
    if (! Csv) {
      {
#line 101
      printf((char const   */* __restrict  */)"\n\n");
      }
    }
    __Cont: /* CIL Label */ 
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___0(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 222
static int __cole_print_tree_outdir___0(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 223
static int __cole_print_tree_inroot___0(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 224
static int __cole_print_tree_indirentry___0(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) ;
#line 242 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___0(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 250
  (*((long *)info)) ++;
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_outdir___0(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 262
  (*((long *)info)) --;
#line 263
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_inroot___0(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 276
  printf((char const   */* __restrict  */)"DIR ");
#line 277
  tmp = cole_dir_getsize(cd);
#line 277
  printf((char const   */* __restrict  */)" %7zu", tmp);
#line 278
  tmp___0 = cole_dir_getsec2(cd);
#line 278
  tmp___1 = cole_dir_getdays2(cd);
#line 278
  tmp___2 = cole_dir_getsec1(cd);
#line 278
  tmp___3 = cole_dir_getdays1(cd);
#line 278
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___3, tmp___2,
         tmp___1, tmp___0);
#line 283
  entry_name = cole_dir_getname(cd);
#line 284
  tmp___4 = __ctype_b_loc();
  }
#line 284
  if ((int const   )*(*tmp___4 + (int )*(entry_name + 0)) & 16384) {
    {
#line 287
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 285
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indirentry___0(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  long level ;
  long i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 304
  level = *((long *)info);
#line 305
  i = 0L;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < level)) {
#line 305
      goto while_break;
    }
#line 306
    if (i == level - 1L) {
      {
#line 307
      printf((char const   */* __restrict  */)"\\--");
      }
    } else {
      {
#line 309
      printf((char const   */* __restrict  */)"|  ");
      }
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  tmp___0 = cole_direntry_isdir(cde);
  }
#line 312
  if (tmp___0) {
    {
#line 313
    printf((char const   */* __restrict  */)"DIR ");
    }
  } else {
    {
#line 314
    tmp = cole_direntry_isfile(cde);
    }
#line 314
    if (tmp) {
      {
#line 315
      printf((char const   */* __restrict  */)"FILE");
      }
    } else {
      {
#line 317
      printf((char const   */* __restrict  */)"????");
      }
    }
  }
  {
#line 318
  tmp___1 = cole_direntry_getsize(cde);
#line 318
  printf((char const   */* __restrict  */)" %7zu", tmp___1);
#line 319
  tmp___2 = cole_direntry_getsec2(cde);
#line 319
  tmp___3 = cole_direntry_getdays2(cde);
#line 319
  tmp___4 = cole_direntry_getsec1(cde);
#line 319
  tmp___5 = cole_direntry_getdays1(cde);
#line 319
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___5, tmp___4,
         tmp___3, tmp___2);
#line 324
  entry_name = cole_direntry_getname(cde);
#line 325
  tmp___6 = __ctype_b_loc();
  }
#line 325
  if ((int const   )*(*tmp___6 + (int )*(entry_name + 0)) & 16384) {
    {
#line 328
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 326
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 330
  return (0);
}
}
#line 585
static void _cole_fopen_action___0(COLEDIRENT *cde , void *_info ) ;
#line 605 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static void _cole_fopen_action___0(COLEDIRENT *cde , void *_info ) 
{ 
  struct _cole_fopen_info *info ;
  int tmp ;

  {
  {
#line 610
  info = (struct _cole_fopen_info *)_info;
#line 612
  tmp = cole_direntry_isfile(cde);
  }
#line 612
  if (! tmp) {
#line 613
    info->colerrno = (COLERRNO )18;
#line 614
    info->succ = 0;
#line 615
    return;
  }
  {
#line 618
  info->file = cole_fopen_direntry(cde, & info->colerrno);
  }
#line 619
  if ((unsigned long )info->file == (unsigned long )((void *)0)) {
#line 621
    info->succ = 0;
#line 622
    return;
  }
#line 625
  info->succ = 1;
#line 626
  return;
}
}
#line 948
static int __cole_recurse_tree___0(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) ;
#line 986 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_recurse_tree___0(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) 
{ 
  COLEDIRENT *cde ;
  COLEDIR *cd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1007
  if (level == 1L) {
#line 1009
    if ((unsigned long )inroot != (unsigned long )((void *)0)) {
      {
#line 1010
      tmp = (*inroot)(_cd, info, colerrno);
      }
#line 1010
      if (tmp) {
#line 1012
        return (1);
      }
    }
  }
  {
#line 1018
  cde = cole_visiteddirentry(_cd);
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned long )cde != (unsigned long )((void *)0))) {
#line 1018
      goto while_break;
    }
#line 1020
    if ((unsigned long )indirentry != (unsigned long )((void *)0)) {
      {
#line 1021
      tmp___0 = (*indirentry)(cde, info, colerrno);
      }
#line 1021
      if (tmp___0) {
#line 1023
        return (1);
      }
    }
    {
#line 1028
    tmp___6 = cole_direntry_isdir(cde);
    }
#line 1028
    if (tmp___6) {
      {
#line 1029
      cd = cole_opendir_direntry(cde, colerrno);
      }
#line 1030
      if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 1032
        return (1);
      }
#line 1035
      if ((unsigned long )indir != (unsigned long )((void *)0)) {
        {
#line 1036
        tmp___1 = (*indir)(cd, info, colerrno);
        }
#line 1036
        if (tmp___1) {
          {
#line 1038
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1039
          return (1);
        }
      }
#line 1043
      if ((unsigned long )visitdir == (unsigned long )((void *)0)) {
#line 1043
        goto _L;
      } else {
        {
#line 1043
        tmp___3 = (*visitdir)(cd, info);
        }
#line 1043
        if (tmp___3) {
          _L: /* CIL Label */ 
          {
#line 1045
          tmp___2 = __cole_recurse_tree___0(cd, level + 1L, info, inroot, indirentry,
                                            indir, outdir, visitdir, colerrno);
          }
#line 1045
          if (tmp___2) {
            {
#line 1050
            cole_closedir(cd, (COLERRNO *)((void *)0));
            }
#line 1051
            return (1);
          }
        }
      }
#line 1055
      if ((unsigned long )outdir != (unsigned long )((void *)0)) {
        {
#line 1056
        tmp___4 = (*outdir)(cd, info, colerrno);
        }
#line 1056
        if (tmp___4) {
          {
#line 1058
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1059
          return (1);
        }
      }
      {
#line 1063
      tmp___5 = cole_closedir(cd, colerrno);
      }
#line 1063
      if (tmp___5) {
#line 1065
        return (1);
      }
    }
    {
#line 1018
    cde = cole_nextdirentry(_cd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return (0);
}
}
#line 1098
static int __cole_locate_filename_indirentry___0(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) ;
#line 1099
static int __cole_locate_filename_visitdir___0(COLEDIR *cd , void *info ) ;
#line 1136 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_visitdir___0(COLEDIR *cd , void *info ) 
{ 


  {
#line 1139
  return (((struct __cole_locate_filenameinfo *)info)->visitdir);
}
}
#line 1142 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_indirentry___0(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  struct __cole_locate_filenameinfo *info ;
  char *pcurrent ;
  char *pentry_name ;
  int tmp ;

  {
  {
#line 1151
  info = (struct __cole_locate_filenameinfo *)_info;
#line 1152
  entry_name = cole_direntry_getname(cde);
#line 1153
  pcurrent = info->current;
#line 1153
  pentry_name = entry_name;
  }
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (*pcurrent) {
#line 1153
      if (*pentry_name) {
#line 1153
        if (! ((int )*pcurrent != 47)) {
#line 1153
          goto while_break;
        }
      } else {
#line 1153
        goto while_break;
      }
    } else {
#line 1153
      goto while_break;
    }
#line 1156
    if ((int )*pcurrent != (int )*pentry_name) {
#line 1157
      info->visitdir = 0;
#line 1158
      return (0);
    }
#line 1153
    pcurrent ++;
#line 1153
    pentry_name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1162
  if ((int )*pentry_name == 0) {
#line 1162
    goto case_0;
  }
#line 1197
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 1164
  if ((int )*pcurrent == 47) {
#line 1164
    goto case_47;
  }
#line 1185
  if ((int )*pcurrent == 0) {
#line 1185
    goto case_0___0;
  }
#line 1193
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 1165
  tmp = cole_direntry_isdir(cde);
  }
#line 1165
  if (! tmp) {
#line 1166
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1167
      *colerrno = (COLERRNO )16;
    }
#line 1168
    return (1);
  }
#line 1170
  pcurrent ++;
#line 1171
  info->current = pcurrent;
#line 1174
  if (! *(info->current)) {
#line 1176
    if ((unsigned long )info->action != (unsigned long )((void *)0)) {
      {
#line 1177
      (*(info->action))(cde, info->info);
      }
    }
#line 1180
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1180
      *colerrno = (COLERRNO )23;
    }
#line 1181
    return (1);
  }
#line 1183
  info->visitdir = 1;
#line 1184
  return (0);
  case_0___0: /* CIL Label */ 
#line 1187
  if ((unsigned long )info->action != (unsigned long )((void *)0)) {
    {
#line 1188
    (*(info->action))(cde, info->info);
    }
  }
#line 1191
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1191
    *colerrno = (COLERRNO )23;
  }
#line 1192
  return (1);
  switch_default: /* CIL Label */ 
#line 1194
  info->visitdir = 0;
#line 1195
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 1199
  if ((int )*pcurrent == 0) {
#line 1199
    goto case_0___1;
  }
#line 1202
  if ((int )*pcurrent == 47) {
#line 1202
    goto case_47___0;
  }
#line 1205
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 1200
  info->visitdir = 0;
#line 1201
  return (0);
  case_47___0: /* CIL Label */ 
#line 1203
  info->visitdir = 0;
#line 1204
  return (0);
  switch_default___1: /* CIL Label */ 
#line 1206
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1206
    *colerrno = (COLERRNO )21;
  }
#line 1207
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/html.c"
void OutputTableHTML(void) 
{ 
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 39
  output_header();
  }
#line 40
  if (center_tables) {
    {
#line 42
    printf((char const   */* __restrict  */)"<CENTER>");
#line 43
    do_cr();
    }
  }
  {
#line 46
  SetupExtraction();
#line 49
  i = first_sheet;
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i <= last_sheet)) {
#line 49
      goto while_break;
    }
    {
#line 51
    update_default_font((unsigned int )i);
    }
#line 52
    if ((unsigned long )*(ws_array + i) == (unsigned long )((work_sheet *)0)) {
#line 53
      goto __Cont;
    }
#line 54
    if ((*(ws_array + i))->biggest_row == -1) {
#line 55
      goto __Cont;
    } else
#line 54
    if ((int )(*(ws_array + i))->biggest_col == -1) {
#line 55
      goto __Cont;
    }
#line 56
    if ((unsigned long )(*(ws_array + i))->c_array == (unsigned long )((cell **)0)) {
#line 57
      goto __Cont;
    }
    {
#line 58
    trim_sheet_edges((unsigned int )i);
    }
#line 61
    if (next_ws_title > 0U) {
#line 63
      if ((*(ws_array + i))->ws_title.str) {
        {
#line 65
        printf((char const   */* __restrict  */)"<CENTER><H1>");
#line 66
        OutputString(& (*(ws_array + i))->ws_title);
#line 67
        printf((char const   */* __restrict  */)"</H1></CENTER><br>");
#line 68
        do_cr();
        }
      } else {
        {
#line 72
        printf((char const   */* __restrict  */)"<H1><CENTER>(Unknown Page)</CENTER></H1><br>");
#line 73
        do_cr();
        }
      }
    }
    {
#line 78
    printf((char const   */* __restrict  */)"<FONT FACE=\"");
#line 79
    OutputString(& default_font);
    }
#line 80
    if (default_fontsize != 3) {
      {
#line 81
      printf((char const   */* __restrict  */)"\" SIZE=\"%d", default_fontsize);
      }
    }
    {
#line 82
    printf((char const   */* __restrict  */)"\">");
#line 83
    do_cr();
#line 84
    printf((char const   */* __restrict  */)"<TABLE BORDER=\"1\" CELLSPACING=\"2\">");
#line 85
    do_cr();
#line 86
    j = (int )(*(ws_array + i))->first_row;
    }
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! (j <= (*(ws_array + i))->biggest_row)) {
#line 86
        goto while_break___0;
      }
      {
#line 88
      update_default_alignment((unsigned int )i, j);
#line 89
      printf((char const   */* __restrict  */)"<TR");
#line 90
      tmp___0 = null_string((unsigned char *)default_alignment);
      }
#line 90
      if (tmp___0) {
        {
#line 91
        printf((char const   */* __restrict  */)">");
        }
      } else {
        {
#line 94
        tmp = strcmp((char const   *)default_alignment, "left");
        }
#line 94
        if (tmp != 0) {
          {
#line 95
          printf((char const   */* __restrict  */)" ALIGN=\"%s\"", default_alignment);
          }
        }
#line 96
        if (! aggressive) {
          {
#line 97
          printf((char const   */* __restrict  */)" VALIGN=\"bottom\">\n");
          }
        } else {
          {
#line 99
          printf((char const   */* __restrict  */)">");
          }
        }
      }
#line 101
      k = (int )(*(ws_array + i))->first_col;
      {
#line 101
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 101
        if (! (k <= (int )(*(ws_array + i))->biggest_col)) {
#line 101
          goto while_break___1;
        }
        {
#line 103
        output_cell(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)),
                    0);
        }
#line 104
        if (*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k))) {
#line 106
          if ((int )(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)))->colspan != 0) {
#line 107
            k += (int )(*((*(ws_array + i))->c_array + (j * (int )(*(ws_array + i))->max_cols + k)))->colspan - 1;
          }
        }
#line 101
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 111
      if (! aggressive) {
        {
#line 112
        printf((char const   */* __restrict  */)"</TR>\n");
        }
      }
#line 86
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 114
    printf((char const   */* __restrict  */)"</TABLE></FONT><HR>");
#line 115
    do_cr();
    }
    __Cont: /* CIL Label */ 
#line 49
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (center_tables) {
    {
#line 120
    printf((char const   */* __restrict  */)"</CENTER>");
#line 121
    do_cr();
    }
  }
#line 125
  if (author.str) {
    {
#line 127
    printf((char const   */* __restrict  */)"<FONT SIZE=\"-1\"><I>Spreadsheet\'s Author:&nbsp;");
#line 128
    OutputString(& author);
#line 129
    printf((char const   */* __restrict  */)"</I></FONT><br>");
#line 130
    do_cr();
    }
  }
  {
#line 134
  printf((char const   */* __restrict  */)"<FONT SIZE=\"-1\"><I>Last Updated ");
  }
#line 135
  if (lastUpdated) {
    {
#line 136
    printf((char const   */* __restrict  */)"%s&nbsp; ", lastUpdated);
    }
  }
  {
#line 139
  if (file_version == 1280) {
#line 139
    goto case_1280;
  }
#line 142
  if (file_version == 1536) {
#line 142
    goto case_1536;
  }
#line 145
  goto switch_default;
  case_1280: /* CIL Label */ 
  {
#line 140
  printf((char const   */* __restrict  */)"with Excel 5.0 or 95");
  }
#line 141
  goto switch_break;
  case_1536: /* CIL Label */ 
  {
#line 143
  printf((char const   */* __restrict  */)"with Excel 97");
  }
#line 144
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 146
  printf((char const   */* __restrict  */)"with Excel ????");
  }
#line 147
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  printf((char const   */* __restrict  */)"</I></FONT><br>");
#line 150
  do_cr();
  }
#line 153
  if (NoFormat) {
    {
#line 155
    printf((char const   */* __restrict  */)"<br>* This cell\'s format is not supported.<br>");
#line 156
    do_cr();
    }
  }
#line 158
  if (notAccurate) {
#line 158
    if (formula_warnings) {
      {
#line 160
      printf((char const   */* __restrict  */)"<br>** This cell\'s data may not be accurate.<br>");
#line 161
      do_cr();
      }
    }
  }
#line 163
  if (NotImplemented) {
    {
#line 165
    printf((char const   */* __restrict  */)"<br>*** This cell\'s data type will be supported in the future.<br>");
#line 166
    do_cr();
    }
  }
#line 168
  if (Unsupported) {
    {
#line 170
    printf((char const   */* __restrict  */)"<br>**** This cell\'s type is unsupported.<br>");
#line 171
    do_cr();
    }
  }
#line 175
  if (MaxWorksheetsExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxRowExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxColExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxStringsExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxFontsExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxPalExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxXFExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  } else
#line 175
  if (MaxFormatsExceeded) {
    {
#line 177
    printf((char const   */* __restrict  */)"<FONT COLOR=\"%s\">", colorTab[10]);
    }
  }
#line 178
  if (MaxWorksheetsExceeded) {
    {
#line 180
    printf((char const   */* __restrict  */)"The Maximum Number of Worksheets was exceeded, you might want to increase it.<br>");
#line 181
    do_cr();
    }
  }
#line 183
  if (MaxRowExceeded) {
    {
#line 185
    printf((char const   */* __restrict  */)"The Maximum Number of Rows was exceeded, you might want to increase it.<br>");
#line 186
    do_cr();
    }
  }
#line 188
  if (MaxColExceeded) {
    {
#line 190
    printf((char const   */* __restrict  */)"The Maximum Number of Columns was exceeded, you might want to increase it.<br>");
#line 191
    do_cr();
    }
  }
#line 193
  if (MaxStringsExceeded) {
    {
#line 195
    printf((char const   */* __restrict  */)"The Maximum Number of Strings was exceeded, you might want to increase it.<br>");
#line 196
    do_cr();
    }
  }
#line 198
  if (MaxFontsExceeded) {
    {
#line 200
    printf((char const   */* __restrict  */)"The Maximum Number of Fonts was exceeded, you might want to increase it.<br>");
#line 201
    do_cr();
    }
  }
#line 203
  if (MaxPalExceeded) {
    {
#line 205
    printf((char const   */* __restrict  */)"The Maximum Number of Color Palettes was exceeded, you might want to increase it.<br>");
#line 206
    do_cr();
    }
  }
#line 208
  if (MaxXFExceeded) {
    {
#line 210
    printf((char const   */* __restrict  */)"The Maximum Number of Extended Formats was exceeded, you might want to increase it.<br>");
#line 211
    do_cr();
    }
  }
#line 213
  if (MaxFormatsExceeded) {
    {
#line 215
    printf((char const   */* __restrict  */)"The Maximum Number of Formats was exceeded, you might want to increase it.<br>");
#line 216
    do_cr();
    }
  }
#line 218
  if (MaxWorksheetsExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxRowExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxColExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxStringsExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxFontsExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxPalExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxXFExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  } else
#line 218
  if (MaxFormatsExceeded) {
    {
#line 220
    printf((char const   */* __restrict  */)"</FONT>");
    }
  }
  {
#line 222
  printf((char const   */* __restrict  */)"&nbsp;<br>");
#line 223
  do_cr();
#line 226
  printf((char const   */* __restrict  */)"<hr><FONT SIZE=\"-1\">Created with <a href=\"http://chicago.sf.net/xlhtml\">xlhtml %s</a></FONT><br>",
         "0.5.1");
#line 227
  do_cr();
#line 230
  output_footer();
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/html.c"
void output_header(void) 
{ 


  {
#line 235
  if (NoHeaders) {
#line 236
    return;
  }
#line 237
  if (! aggressive) {
    {
#line 239
    printf((char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML Transitional//EN\"");
#line 240
    do_cr();
#line 241
    printf((char const   */* __restrict  */)"\"http://www.w3.org/TR/REC-html40/loose.dtd\">");
#line 242
    do_cr();
    }
  }
  {
#line 244
  printf((char const   */* __restrict  */)"<HTML>\n");
#line 245
  printf((char const   */* __restrict  */)"<HEAD>\n");
#line 246
  do_cr();
#line 247
  printf((char const   */* __restrict  */)"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
  }
#line 248
  if (UnicodeStrings <= 1) {
#line 248
    if (CodePage) {
#line 248
      if (CodePage != 1252) {
        {
#line 249
        printf((char const   */* __restrict  */)"windows-%d\">", CodePage);
        }
      } else {
#line 248
        goto _L___0;
      }
    } else {
#line 248
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 254
    if (UnicodeStrings == 0) {
#line 254
      goto case_0;
    }
#line 257
    if (UnicodeStrings == 1) {
#line 257
      goto case_1;
    }
#line 260
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 255
    printf((char const   */* __restrict  */)"iso-8859-1\">");
    }
#line 256
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 258
    printf((char const   */* __restrict  */)"windows-1252\">");
    }
#line 259
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 261
    printf((char const   */* __restrict  */)"utf-8\">");
    }
#line 262
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 265
  do_cr();
  }
#line 267
  if (! aggressive) {
    {
#line 269
    printf((char const   */* __restrict  */)"<meta name=\"GENERATOR\" content=\"xlhtml\">");
#line 270
    do_cr();
    }
  }
  {
#line 272
  printf((char const   */* __restrict  */)"<TITLE>");
  }
#line 273
  if (title) {
    {
#line 274
    printf((char const   */* __restrict  */)"%s", title);
    }
  } else {
    {
#line 276
    printf((char const   */* __restrict  */)"%s", filename);
    }
  }
  {
#line 277
  printf((char const   */* __restrict  */)"</TITLE>");
#line 278
  do_cr();
#line 279
  printf((char const   */* __restrict  */)"</HEAD>");
#line 280
  do_cr();
#line 281
  do_cr();
#line 282
  printf((char const   */* __restrict  */)"<BODY TEXT=\"#%s\" BGCOLOR=\"#%s\"", default_text_color,
         default_background_color);
  }
#line 284
  if (default_image) {
    {
#line 285
    printf((char const   */* __restrict  */)"BACKGROUND=\"%s\"", default_image);
    }
  }
  {
#line 286
  printf((char const   */* __restrict  */)"><br>");
#line 287
  do_cr();
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/html.c"
void output_footer(void) 
{ 


  {
#line 292
  if (NoHeaders) {
#line 293
    return;
  }
  {
#line 294
  printf((char const   */* __restrict  */)"</BODY></HTML>");
#line 295
  do_cr();
#line 296
  fflush(stdout);
  }
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/html.c"
void output_start_html_attr(html_attr *h , unsigned int fnt_idx , int do_underlines ) 
{ 


  {
#line 301
  if (fnt_idx < next_font) {
#line 303
    if (((int )(*(font_array + fnt_idx))->underline & 35) > 0) {
#line 303
      if (do_underlines) {
        {
#line 305
        printf((char const   */* __restrict  */)"<U>");
#line 306
        h->uflag = 1;
        }
      }
    }
#line 308
    if ((int )(*(font_array + fnt_idx))->bold >= 700) {
      {
#line 310
      h->bflag = 1;
#line 311
      printf((char const   */* __restrict  */)"<B>");
      }
    }
#line 313
    if ((int )(*(font_array + fnt_idx))->attr & 2) {
      {
#line 315
      h->iflag = 1;
#line 316
      printf((char const   */* __restrict  */)"<I>");
      }
    }
#line 318
    if ((int )(*(font_array + fnt_idx))->attr & 8) {
      {
#line 320
      h->sflag = 1;
#line 321
      printf((char const   */* __restrict  */)"<S>");
      }
    }
#line 323
    if (((int )(*(font_array + fnt_idx))->super & 3) == 1) {
      {
#line 325
      h->spflag = 1;
#line 326
      printf((char const   */* __restrict  */)"<SUP>");
      }
    } else
#line 328
    if (((int )(*(font_array + fnt_idx))->super & 3) == 2) {
      {
#line 330
      h->sbflag = 1;
#line 331
      printf((char const   */* __restrict  */)"<SUB>");
      }
    }
  }
#line 334
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/html.c"
void output_end_html_attr(html_attr *h ) 
{ 


  {
#line 338
  if (h->sbflag) {
    {
#line 340
    printf((char const   */* __restrict  */)"</SUB>");
#line 341
    h->sbflag = 0;
    }
  } else
#line 343
  if (h->spflag) {
    {
#line 345
    printf((char const   */* __restrict  */)"</SUP>");
#line 346
    h->spflag = 0;
    }
  }
#line 348
  if (h->sflag) {
    {
#line 350
    printf((char const   */* __restrict  */)"</S>");
#line 351
    h->sflag = 0;
    }
  }
#line 353
  if (h->iflag) {
    {
#line 355
    printf((char const   */* __restrict  */)"</I>");
#line 356
    h->iflag = 0;
    }
  }
#line 358
  if (h->bflag) {
    {
#line 360
    printf((char const   */* __restrict  */)"</B>");
#line 361
    h->bflag = 0;
    }
  }
#line 363
  if (h->uflag) {
#line 365
    if (h->uflag == 1) {
      {
#line 366
      printf((char const   */* __restrict  */)"</U>");
      }
    } else {
      {
#line 368
      printf((char const   */* __restrict  */)"</A>");
      }
    }
#line 369
    h->uflag = 0;
  }
#line 371
  if (h->fflag) {
    {
#line 373
    printf((char const   */* __restrict  */)"</FONT>");
#line 374
    h->fflag = 0;
    }
  }
#line 376
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___1(pps_entry *node , unsigned short level ) ;
#line 74
static void ends___3(void) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *input___1  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Block___1  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Blockx___1  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *BDepot___3  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *SDepot___3  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Root___3  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static pps_entry *pps_list___1  ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int num_of_pps___1  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *sbfile___3  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *sbd_list___1  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *root_list___2  ;
#line 597 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *last_next_link_visited___1  ;
#line 598 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___1(pps_entry *node , unsigned short level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 603
  node->level = level;
#line 606
  if ((unsigned long )node->dir != 4294967295UL) {
#line 608
    if (node->dir > num_of_pps___1) {
#line 609
      return (0);
    } else
#line 608
    if (! (pps_list___1 + node->dir)->name[0]) {
#line 609
      return (0);
    } else {
      {
#line 610
      tmp = reorder_pps_tree___1(pps_list___1 + node->dir, (unsigned short )((int )level + 1));
      }
#line 610
      if (! tmp) {
#line 611
        return (0);
      }
    }
  }
#line 615
  if ((unsigned long )node->next != 4294967295UL) {
#line 617
    if (node->next > num_of_pps___1) {
#line 618
      return (0);
    } else
#line 617
    if (! (pps_list___1 + node->next)->name[0]) {
#line 618
      return (0);
    } else {
      {
#line 619
      tmp___0 = reorder_pps_tree___1(pps_list___1 + node->next, level);
      }
#line 619
      if (! tmp___0) {
#line 620
        return (0);
      }
    }
  } else {
#line 623
    last_next_link_visited___1 = & node->next;
  }
#line 626
  if ((unsigned long )node->previous != 4294967295UL) {
#line 628
    if (node->previous > num_of_pps___1) {
#line 629
      return (0);
    } else
#line 628
    if (! (pps_list___1 + node->previous)->name[0]) {
#line 629
      return (0);
    } else {
      {
#line 632
      *last_next_link_visited___1 = node->previous;
#line 633
      node->previous = 4294967295U;
#line 634
      tmp___1 = reorder_pps_tree___1(pps_list___1 + *last_next_link_visited___1, level);
      }
#line 634
      if (! tmp___1) {
#line 635
        return (0);
      }
    }
  }
#line 638
  return (1);
}
}
#line 759 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static void ends___3(void) 
{ 


  {
#line 767
  if ((unsigned long )Block___1 != (unsigned long )((void *)0)) {
    {
#line 767
    free((void *)Block___1);
    }
  }
#line 768
  if ((unsigned long )Blockx___1 != (unsigned long )((void *)0)) {
    {
#line 768
    free((void *)Blockx___1);
    }
  }
#line 775
  if ((unsigned long )Root___3 != (unsigned long )((void *)0)) {
    {
#line 775
    free((void *)Root___3);
    }
  }
#line 776
  if ((unsigned long )sbd_list___1 != (unsigned long )((void *)0)) {
    {
#line 776
    free((void *)sbd_list___1);
    }
  }
#line 777
  if ((unsigned long )root_list___2 != (unsigned long )((void *)0)) {
    {
#line 777
    free((void *)root_list___2);
    }
  }
#line 787
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE Input___1  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *sbfile___4  ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *SDepot___4  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *BDepot___4  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *bbd_list___1  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *Root___4  ;
#line 79 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int header_blocks___1  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int big_streams_blocks___1  ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_blocks___1  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_blocks___1  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_blocks___1  ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_blocks___1  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_start_block___1  ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_start_block___1  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_start_block___1  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_start_block___1  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static FILE *output_file___1  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned char output_block___1[512]  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned short pos_block___1  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int next_block___1  ;
#line 105
static int process_Root___1(pps_entry *pps_list___4 , unsigned int root ) ;
#line 106
static unsigned int max_pps_referenced___1(pps_entry *pps_list___4 , unsigned int node ) ;
#line 107
static unsigned int max3___1(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) ;
#line 108
static int process_streams___1(pps_entry *pps_list___4 , pps_entry *node ) ;
#line 109
static int add_stream_to_sbfile_and_SDepot___1(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 110
static int add_stream_to_Input_and_BDepot___1(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 111
static int add_entry_to_Root___1(pps_entry *node , unsigned int start_block ) ;
#line 112
static unsigned int add_MY_FILE_entry___1(MY_FILE *list , unsigned int size ) ;
#line 113
static int pps2root___1(unsigned char *pps , pps_entry *node , unsigned int start_block ) ;
#line 114
static void reset_links_in_Input___1(void) ;
#line 115
static void reset_links_in_BDepot___1(void) ;
#line 116
static void reset_links_in_SDepot___1(void) ;
#line 118
static int generate_ole2_file___1(char const   *filename___4 , int trunc ) ;
#line 119
static int generate_header___1(void) ;
#line 120
static int generate_recursive___1(MY_FILE *list ) ;
#line 121
static int generate_SDepot___1(void) ;
#line 122
static int generate_Root___1(void) ;
#line 123
static int generate_BDepot___1(void) ;
#line 124
static int generate_real_file___1(MY_FILE *MY_FILE_file ) ;
#line 125
static int write_block_list___1(unsigned int start_count , MY_FILE *list , int write_end_chain ) ;
#line 126
static int write_root_list___1(MY_FILE *list ) ;
#line 127
static void calculate_blocks___1(void) ;
#line 129
static unsigned int sum_block_list___1(MY_FILE *list ) ;
#line 132
static unsigned int sum_blocks_MY_FILE_list___1(MY_FILE *list ) ;
#line 134
static void ends___4(void) ;
#line 285 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_Root___1(pps_entry *pps_list___4 , unsigned int root ) 
{ 
  unsigned int pps_list_entries ;
  unsigned int i ;
  unsigned int tmp ;
  int retval ;

  {
  {
#line 293
  tmp = max_pps_referenced___1(pps_list___4, root);
#line 293
  pps_list_entries = 1U + tmp;
#line 296
  i = 0U;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < pps_list_entries)) {
#line 296
      goto while_break;
    }
    {
#line 297
    retval = add_entry_to_Root___1(pps_list___4 + i, 0U);
    }
#line 297
    if (retval) {
#line 297
      return (retval);
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max3___1(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) 
{ 
  unsigned int m ;

  {
#line 319
  m = 0U;
#line 323
  if (m > a) {
#line 323
    m = m;
  } else {
#line 323
    m = a;
  }
#line 324
  if (m > b) {
#line 324
    m = m;
  } else {
#line 324
    m = b;
  }
#line 325
  if (m > c) {
#line 325
    m = m;
  } else {
#line 325
    m = c;
  }
#line 326
  if (m > d) {
#line 326
    m = m;
  } else {
#line 326
    m = d;
  }
#line 327
  return (m);
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max_pps_referenced___1(pps_entry *pps_list___4 , unsigned int node ) 
{ 
  unsigned int max_pps ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 337
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
#line 337
    tmp = (pps_list___4 + node)->dir;
  } else {
#line 337
    tmp = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
#line 337
    tmp___0 = (pps_list___4 + node)->next;
  } else {
#line 337
    tmp___0 = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
#line 337
    tmp___1 = (pps_list___4 + node)->previous;
  } else {
#line 337
    tmp___1 = 0U;
  }
  {
#line 337
  max_pps = max3___1(node, tmp___1, tmp___0, tmp);
  }
#line 342
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
    {
#line 343
    tmp___4 = max_pps_referenced___1(pps_list___4, (pps_list___4 + node)->previous);
    }
#line 343
    if (max_pps > tmp___4) {
#line 343
      max_pps = max_pps;
    } else {
      {
#line 343
      tmp___3 = max_pps_referenced___1(pps_list___4, (pps_list___4 + node)->previous);
#line 343
      max_pps = tmp___3;
      }
    }
  }
#line 345
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
    {
#line 346
    tmp___7 = max_pps_referenced___1(pps_list___4, (pps_list___4 + node)->next);
    }
#line 346
    if (max_pps > tmp___7) {
#line 346
      max_pps = max_pps;
    } else {
      {
#line 346
      tmp___6 = max_pps_referenced___1(pps_list___4, (pps_list___4 + node)->next);
#line 346
      max_pps = tmp___6;
      }
    }
  }
#line 348
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
    {
#line 349
    tmp___10 = max_pps_referenced___1(pps_list___4, (pps_list___4 + node)->dir);
    }
#line 349
    if (max_pps > tmp___10) {
#line 349
      max_pps = max_pps;
    } else {
      {
#line 349
      tmp___9 = max_pps_referenced___1(pps_list___4, (pps_list___4 + node)->dir);
#line 349
      max_pps = tmp___9;
      }
    }
  }
#line 352
  return (max_pps);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_streams___1(pps_entry *pps_list___4 , pps_entry *node ) 
{ 
  unsigned int U32end_chain ;
  int retval ;
  int retval___0 ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;
  int retval___4 ;
  int retval___5 ;

  {
#line 359
  U32end_chain = 4294967294U;
#line 363
  if (! node->name[0]) {
#line 363
    return (12);
  }
  {
#line 366
  if ((int )node->type == 1) {
#line 366
    goto case_1;
  }
#line 374
  if ((int )node->type == 5) {
#line 374
    goto case_5;
  }
#line 385
  if ((int )node->type == 2) {
#line 385
    goto case_2;
  }
#line 399
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 368
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 369
    retval = process_streams___1(pps_list___4, pps_list___4 + node->dir);
    }
#line 369
    if (retval) {
#line 369
      return (retval);
    }
  }
#line 370
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 371
    retval___0 = process_streams___1(pps_list___4, pps_list___4 + node->next);
    }
#line 371
    if (retval___0) {
#line 371
      return (retval___0);
    }
  }
#line 372
  goto switch_break;
  case_5: /* CIL Label */ 
#line 375
  if (! ((int )*(Root___4->file.root_list + 66) == 5)) {
    {
#line 375
    __assert_fail("*(Root->file.root_list + 0x42) == 5", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  375U, "process_streams");
    }
  }
  {
#line 378
  fil_swriteU32(Root___4->file.root_list + 116, & U32end_chain);
  }
#line 379
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 380
    retval___1 = process_streams___1(pps_list___4, pps_list___4 + node->dir);
    }
#line 380
    if (retval___1) {
#line 380
      return (retval___1);
    }
  }
#line 381
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 382
    retval___2 = process_streams___1(pps_list___4, pps_list___4 + node->next);
    }
#line 382
    if (retval___2) {
#line 382
      return (retval___2);
    }
  }
#line 383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 386
  if (! ((unsigned long )node->dir == 4294967295UL)) {
#line 386
    return (12);
  }
#line 387
  if (node->size < 4096U) {
    {
#line 389
    retval___3 = add_stream_to_sbfile_and_SDepot___1(node->size, node->filename, node->ppsnumber);
    }
#line 389
    if (retval___3) {
#line 389
      return (retval___3);
    }
  } else {
    {
#line 393
    retval___4 = add_stream_to_Input_and_BDepot___1(node->size, node->filename, node->ppsnumber);
    }
#line 393
    if (retval___4) {
#line 393
      return (retval___4);
    }
  }
#line 395
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 396
    retval___5 = process_streams___1(pps_list___4, pps_list___4 + node->next);
    }
#line 396
    if (retval___5) {
#line 396
      return (retval___5);
    }
  }
#line 397
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 400
  return (12);
  switch_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_entry_to_Root___1(pps_entry *node , unsigned int start_block ) 
{ 
  unsigned int entry_number ;
  unsigned char *new_entry_Root ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 416
  entry_number = add_MY_FILE_entry___1(Root___4, 0U);
  }
#line 417
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 417
    return (10);
  }
  {
#line 418
  new_entry_Root = Root___4->file.root_list + entry_number * 128U;
#line 421
  pps2root___1((unsigned char *)new_entry_Root, node, start_block);
  }
#line 424
  if (! Root___4->size) {
#line 424
    *(Root___4->blocks) = 1U;
  } else {
#line 424
    *(Root___4->blocks) = 1U + (Root___4->size - 1U) / 512U;
  }
  {
#line 428
  tmp___1 = sum_block_list___1(BDepot___4);
  }
#line 428
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 428
    tmp___0 = sum_block_list___1(BDepot___4);
#line 428
    *(BDepot___4->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 428
    *(BDepot___4->blocks) = 1U;
  }
#line 430
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_sbfile_and_SDepot___1(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  unsigned int *new_entry_SDepot ;
  MY_FILE *new_entry_sbfile ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 447
  entry_number = add_MY_FILE_entry___1(SDepot___4, size);
  }
#line 448
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 448
    return (10);
  }
  {
#line 449
  new_entry_SDepot = SDepot___4->file.block_list + entry_number;
#line 451
  entry_number = add_MY_FILE_entry___1(sbfile___4, size);
  }
#line 452
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 452
    return (10);
  }
#line 453
  new_entry_sbfile = sbfile___4->file.MY_FILE_list + entry_number;
#line 458
  if (! size) {
#line 458
    *new_entry_SDepot = 1U;
  } else {
#line 458
    *new_entry_SDepot = 1U + (size - 1U) / 64U;
  }
  {
#line 461
  tmp___1 = sum_block_list___1(SDepot___4);
  }
#line 461
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 461
    tmp___0 = sum_block_list___1(SDepot___4);
#line 461
    *(SDepot___4->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 461
    *(SDepot___4->blocks) = 1U;
  }
  {
#line 468
  new_entry_sbfile->type = (enum __anonenum_type_26 )0;
#line 468
  new_entry_sbfile->size = size;
#line 468
  new_entry_sbfile->blocks = new_entry_SDepot;
#line 468
  new_entry_sbfile->file.real.name = name;
#line 468
  new_entry_sbfile->file.real.ppsnumber = ppsnumber;
#line 472
  tmp___4 = sum_blocks_MY_FILE_list___1(sbfile___4);
  }
#line 472
  if (tmp___4 * 64U) {
    {
#line 472
    tmp___3 = sum_blocks_MY_FILE_list___1(sbfile___4);
#line 472
    *(sbfile___4->blocks) = 1U + (tmp___3 * 64U - 1U) / 512U;
    }
  } else {
#line 472
    *(sbfile___4->blocks) = 1U;
  }
  {
#line 477
  tmp___7 = sum_block_list___1(BDepot___4);
  }
#line 477
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 477
    tmp___6 = sum_block_list___1(BDepot___4);
#line 477
    *(BDepot___4->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___6 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 477
    *(BDepot___4->blocks) = 1U;
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_Input_and_BDepot___1(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  MY_FILE *new_entry_Input ;
  unsigned int *new_entry_BDepot ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 496
  entry_number = add_MY_FILE_entry___1(BDepot___4, size);
  }
#line 497
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 497
    return (10);
  }
  {
#line 498
  new_entry_BDepot = BDepot___4->file.block_list + entry_number;
#line 500
  entry_number = add_MY_FILE_entry___1(& Input___1, size);
  }
#line 501
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 501
    return (10);
  }
#line 502
  new_entry_Input = Input___1.file.MY_FILE_list + entry_number;
#line 507
  if (! size) {
#line 507
    *new_entry_BDepot = 1U;
  } else {
#line 507
    *new_entry_BDepot = 1U + (size - 1U) / 512U;
  }
  {
#line 510
  tmp___1 = sum_block_list___1(BDepot___4);
  }
#line 510
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 510
    tmp___0 = sum_block_list___1(BDepot___4);
#line 510
    *(BDepot___4->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 510
    *(BDepot___4->blocks) = 1U;
  }
  {
#line 517
  new_entry_Input->type = (enum __anonenum_type_26 )0;
#line 517
  new_entry_Input->size = size;
#line 517
  new_entry_Input->blocks = new_entry_BDepot;
#line 517
  new_entry_Input->file.real.name = name;
#line 517
  new_entry_Input->file.real.ppsnumber = ppsnumber;
#line 524
  tmp___4 = sum_block_list___1(BDepot___4);
  }
#line 524
  if ((unsigned long )tmp___4 * sizeof(unsigned int )) {
    {
#line 524
    tmp___3 = sum_block_list___1(BDepot___4);
#line 524
    *(BDepot___4->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___3 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 524
    *(BDepot___4->blocks) = 1U;
  }
#line 526
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int add_MY_FILE_entry___1(MY_FILE *list , unsigned int size ) 
{ 
  MY_FILE *new_MY_FILE_list ;
  unsigned int new_entry ;
  void *tmp ;
  unsigned int *new_block_list ;
  unsigned int new_entry___0 ;
  void *tmp___0 ;
  unsigned int new_entry___1 ;
  unsigned char *new_root_list ;
  void *tmp___1 ;

  {
#line 574
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 574
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  574U, "add_MY_FILE_entry");
    }
  }
  {
#line 581
  if ((unsigned int )list->type == 1U) {
#line 581
    goto case_1;
  }
#line 599
  if ((unsigned int )list->type == 2U) {
#line 599
    goto case_2;
  }
#line 616
  if ((unsigned int )list->type == 3U) {
#line 616
    goto case_3;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 585
  if (! ((unsigned long )list == (unsigned long )sbfile___4)) {
#line 585
    if (! ((unsigned long )list == (unsigned long )(& Input___1))) {
      {
#line 585
      __assert_fail("list == sbfile || list == &Input", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    585U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 587
  list->size = (unsigned int )((unsigned long )list->size + sizeof(MY_FILE ));
#line 588
  tmp = realloc((void *)list->file.MY_FILE_list, (size_t )list->size);
#line 588
  new_MY_FILE_list = (MY_FILE *)tmp;
#line 589
  list->file.MY_FILE_list = new_MY_FILE_list;
  }
#line 590
  if (! ((unsigned long )new_MY_FILE_list != (unsigned long )((void *)0))) {
#line 590
    return (4294967295U);
  }
  {
#line 591
  new_entry = (unsigned int )((unsigned long )list->size / sizeof(MY_FILE ) - 1UL);
#line 592
  reset_links_in_Input___1();
#line 592
  reset_links_in_BDepot___1();
#line 592
  reset_links_in_SDepot___1();
  }
#line 594
  return (new_entry);
  case_2: /* CIL Label */ 
#line 603
  if (! ((unsigned long )list == (unsigned long )SDepot___4)) {
#line 603
    if (! ((unsigned long )list == (unsigned long )BDepot___4)) {
      {
#line 603
      __assert_fail("list == SDepot || list == BDepot", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    603U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 605
  list->size = (unsigned int )((unsigned long )list->size + sizeof(unsigned int ));
#line 606
  tmp___0 = realloc((void *)list->file.block_list, (size_t )list->size);
#line 606
  new_block_list = (unsigned int *)tmp___0;
#line 607
  list->file.block_list = new_block_list;
  }
#line 608
  if (! ((unsigned long )new_block_list != (unsigned long )((void *)0))) {
#line 608
    return (4294967295U);
  }
  {
#line 609
  new_entry___0 = (unsigned int )((unsigned long )list->size / sizeof(unsigned int ) - 1UL);
#line 610
  reset_links_in_Input___1();
#line 610
  reset_links_in_BDepot___1();
#line 610
  reset_links_in_SDepot___1();
  }
#line 612
  return (new_entry___0);
  case_3: /* CIL Label */ 
#line 620
  if (! ((unsigned long )list == (unsigned long )Root___4)) {
    {
#line 620
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  620U, "add_MY_FILE_entry");
    }
  }
  {
#line 622
  list->size += 128U;
#line 623
  tmp___1 = realloc((void *)list->file.root_list, (size_t )list->size);
#line 623
  new_root_list = (unsigned char *)tmp___1;
#line 624
  list->file.root_list = new_root_list;
  }
#line 625
  if (! ((unsigned long )new_root_list != (unsigned long )((void *)0))) {
#line 625
    return (4294967295U);
  }
  {
#line 626
  new_entry___1 = list->size / 128U - 1U;
#line 627
  reset_links_in_Input___1();
#line 627
  reset_links_in_BDepot___1();
#line 627
  reset_links_in_SDepot___1();
  }
#line 629
  return (new_entry___1);
  switch_default: /* CIL Label */ ;
#line 640
  if (! ((unsigned long )"list->type UNKNOWN in add_MY_FILE_entry" == (unsigned long )((void *)0))) {
    {
#line 640
    __assert_fail("\"list->type UNKNOWN in add_MY_FILE_entry\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  640U, "add_MY_FILE_entry");
    }
  }
#line 641
  return (0U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int pps2root___1(unsigned char *pps , pps_entry *node , unsigned int start_block ) 
{ 
  unsigned short i ;
  unsigned short size_of_name ;
  unsigned char U8magiczero ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 653
  U8magiczero = (unsigned char)0;
#line 654
  U32magiczero = 0U;
#line 655
  U32magic1 = 133376U;
#line 656
  U32magic2 = 1174405120U;
#line 663
  if (! (node->ppsnumber == (unsigned int )(pps - (unsigned char *)Root___4->file.root_list) / 128U)) {
    {
#line 663
    __assert_fail("node->ppsnumber == (unsigned int)(pps - Root->file.root_list)/0x80",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  663U, "pps2root");
    }
  }
  {
#line 665
  memset((void *)pps, 255, (size_t )128);
#line 668
  tmp = strlen((char const   *)(node->name));
#line 668
  size_of_name = (unsigned short )(2UL * (tmp + 1UL));
#line 670
  i = (unsigned short)0;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! ((int )i < (int )size_of_name)) {
#line 670
      goto while_break;
    }
#line 671
    if ((int )i % 2) {
#line 671
      tmp___0 = 0;
    } else {
#line 671
      tmp___0 = (int )*(node->name + (int )i / 2);
    }
#line 671
    *(pps + (int )i) = (unsigned char )tmp___0;
#line 670
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  fil_swriteU16((unsigned char *)(pps + 64), & size_of_name);
#line 675
  *(pps + 66) = node->type;
#line 676
  fil_swriteU32((unsigned char *)(pps + 68), & node->previous);
#line 677
  fil_swriteU32((unsigned char *)(pps + 72), & node->next);
#line 678
  fil_swriteU32((unsigned char *)(pps + 76), & node->dir);
#line 679
  fil_swriteU32((unsigned char *)(pps + 100), & node->seconds1);
#line 680
  fil_swriteU32((unsigned char *)(pps + 104), & node->days1);
#line 681
  fil_swriteU32((unsigned char *)(pps + 108), & node->seconds2);
#line 682
  fil_swriteU32((unsigned char *)(pps + 112), & node->days1);
#line 683
  fil_swriteU32((unsigned char *)(pps + 116), & start_block);
#line 684
  fil_swriteU32((unsigned char *)(pps + 120), & node->size);
#line 687
  *(pps + 67) = U8magiczero;
#line 688
  fil_swriteU32((unsigned char *)(pps + 80), & U32magic1);
#line 689
  fil_swriteU32((unsigned char *)(pps + 84), & U32magiczero);
#line 690
  fil_swriteU32((unsigned char *)(pps + 88), & U32magiczero);
#line 691
  fil_swriteU32((unsigned char *)(pps + 92), & U32magic2);
#line 692
  fil_swriteU32((unsigned char *)(pps + 96), & U32magiczero);
#line 693
  fil_swriteU32((unsigned char *)(pps + 124), & U32magiczero);
  }
#line 697
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_block_list___1(MY_FILE *list ) 
{ 
  unsigned int sum ;
  unsigned int *block ;

  {
#line 702
  sum = 0U;
#line 707
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 707
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  707U, "sum_block_list");
    }
  }
#line 708
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 708
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  708U, "sum_block_list");
    }
  }
#line 709
  block = list->file.block_list;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned int )((unsigned char *)block - (unsigned char *)list->file.block_list) < list->size)) {
#line 709
      goto while_break;
    }
#line 712
    sum += *block;
#line 709
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return (sum);
}
}
#line 738 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_blocks_MY_FILE_list___1(MY_FILE *list ) 
{ 
  unsigned int sum ;
  MY_FILE *file ;

  {
#line 740
  sum = 0U;
#line 745
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 745
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  745U, "sum_blocks_MY_FILE_list");
    }
  }
#line 746
  if (! ((unsigned int )list->type == 1U)) {
    {
#line 746
    __assert_fail("list->type == MY_FILE_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  746U, "sum_blocks_MY_FILE_list");
    }
  }
#line 747
  file = list->file.MY_FILE_list;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )((unsigned char *)file - (unsigned char *)list->file.MY_FILE_list) < list->size)) {
#line 747
      goto while_break;
    }
#line 750
    if ((unsigned long )file->blocks != (unsigned long )((void *)0)) {
#line 751
      sum += *(file->blocks);
    }
#line 747
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (sum);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_Input___1(void) 
{ 


  {
#line 759
  sbfile___4 = Input___1.file.MY_FILE_list + 4;
#line 760
  SDepot___4 = Input___1.file.MY_FILE_list + 3;
#line 761
  BDepot___4 = Input___1.file.MY_FILE_list + 1;
#line 762
  bbd_list___1 = Input___1.file.MY_FILE_list;
#line 763
  Root___4 = Input___1.file.MY_FILE_list + 2;
#line 764
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_BDepot___1(void) 
{ 
  unsigned int i ;

  {
#line 772
  sbfile___4->blocks = BDepot___4->file.block_list;
#line 773
  SDepot___4->blocks = BDepot___4->file.block_list + 1;
#line 774
  Root___4->blocks = BDepot___4->file.block_list + 2;
#line 777
  i = 0U;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )i < (unsigned long )Input___1.size / sizeof(MY_FILE ) - 5UL)) {
#line 777
      goto while_break;
    }
#line 778
    (Input___1.file.MY_FILE_list + (i + 5U))->blocks = (BDepot___4->file.block_list + i) + 3;
#line 777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_SDepot___1(void) 
{ 
  unsigned int i ;

  {
#line 788
  i = 0U;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! ((unsigned long )i < (unsigned long )sbfile___4->size / sizeof(MY_FILE ))) {
#line 788
      goto while_break;
    }
#line 789
    (sbfile___4->file.MY_FILE_list + i)->blocks = SDepot___4->file.block_list + i;
#line 788
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_ole2_file___1(char const   *filename___4 , int trunc ) 
{ 
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;

  {
#line 796
  if (! trunc) {
    {
#line 798
    output_file___1 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"r");
    }
#line 799
    if (! ((unsigned long )output_file___1 == (unsigned long )((void *)0))) {
      {
#line 799
      ends___4();
      }
#line 799
      return (2);
    }
  }
  {
#line 801
  output_file___1 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"wb");
  }
#line 802
  if (! ((unsigned long )output_file___1 != (unsigned long )((void *)0))) {
    {
#line 802
    ends___4();
    }
#line 802
    return (3);
  }
  {
#line 804
  retval = generate_header___1();
  }
#line 804
  if (retval) {
#line 804
    return (retval);
  }
  {
#line 805
  retval___0 = generate_recursive___1(& Input___1);
  }
#line 805
  if (retval___0) {
#line 805
    return (retval___0);
  }
#line 809
  if ((int )pos_block___1 != 0) {
#line 809
    if ((int )pos_block___1 % 512) {
      {
#line 809
      memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 512 + 1) * 512 - (int )pos_block___1));
      }
    }
    {
#line 809
    tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___1);
    }
#line 809
    if (! (tmp == 512UL)) {
#line 809
      return (1);
    }
#line 809
    next_block___1 ++;
#line 809
    pos_block___1 = (unsigned short)0;
  }
  {
#line 810
  retval___1 = generate_SDepot___1();
  }
#line 810
  if (retval___1) {
#line 810
    return (retval___1);
  }
  {
#line 811
  retval___2 = generate_Root___1();
  }
#line 811
  if (retval___2) {
#line 811
    return (retval___2);
  }
  {
#line 812
  retval___3 = generate_BDepot___1();
  }
#line 812
  if (retval___3) {
#line 812
    return (retval___3);
  }
  {
#line 814
  fclose(output_file___1);
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_header___1(void) 
{ 
  unsigned int identifier1 ;
  unsigned int identifier2 ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  unsigned int U32magic3 ;
  unsigned int U32magic4 ;
  unsigned int U32magic5 ;
  unsigned int U32magic6 ;

  {
  {
#line 821
  identifier1 = 3759263696U;
#line 822
  identifier2 = 3776623009U;
#line 823
  U32magiczero = 0U;
#line 824
  U32magic1 = 196667U;
#line 825
  U32magic2 = 655358U;
#line 826
  U32magic3 = 6U;
#line 827
  U32magic4 = 4096U;
#line 828
  U32magic5 = 1U;
#line 829
  U32magic6 = 4294967294U;
#line 833
  calculate_blocks___1();
#line 835
  fil_swriteU32(output_block___1 + 48, & Root_start_block___1);
#line 836
  fil_swriteU32(output_block___1 + 60, & SDepot_start_block___1);
#line 837
  fil_swriteU32(output_block___1 + 44, & BDepot_blocks___1);
#line 839
  fil_swriteU32(output_block___1 + 0, & identifier1);
#line 840
  fil_swriteU32(output_block___1 + 4, & identifier2);
#line 841
  fil_swriteU32(output_block___1 + 8, & U32magiczero);
#line 842
  fil_swriteU32(output_block___1 + 12, & U32magiczero);
#line 843
  fil_swriteU32(output_block___1 + 16, & U32magiczero);
#line 844
  fil_swriteU32(output_block___1 + 20, & U32magiczero);
#line 845
  fil_swriteU32(output_block___1 + 24, & U32magic1);
#line 846
  fil_swriteU32(output_block___1 + 28, & U32magic2);
#line 847
  fil_swriteU32(output_block___1 + 32, & U32magic3);
#line 848
  fil_swriteU32(output_block___1 + 36, & U32magiczero);
#line 849
  fil_swriteU32(output_block___1 + 40, & U32magiczero);
#line 850
  fil_swriteU32(output_block___1 + 52, & U32magiczero);
#line 851
  fil_swriteU32(output_block___1 + 56, & U32magic4);
#line 852
  fil_swriteU32(output_block___1 + 64, & U32magic5);
#line 853
  fil_swriteU32(output_block___1 + 68, & U32magic6);
#line 854
  fil_swriteU32(output_block___1 + 72, & U32magiczero);
#line 856
  pos_block___1 = (unsigned short)76;
  }
#line 858
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_recursive___1(MY_FILE *list ) 
{ 
  MY_FILE *p_MY_FILE_list ;
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;

  {
  {
#line 873
  if ((unsigned int )list->type == 1U) {
#line 873
    goto case_1;
  }
#line 881
  if ((unsigned int )list->type == 2U) {
#line 881
    goto case_2;
  }
#line 898
  if ((unsigned int )list->type == 3U) {
#line 898
    goto case_3;
  }
#line 903
  if ((unsigned int )list->type == 0U) {
#line 903
    goto case_0;
  }
#line 908
  goto switch_default;
  case_1: /* CIL Label */ 
#line 874
  p_MY_FILE_list = list->file.MY_FILE_list;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! ((unsigned int )((unsigned char *)p_MY_FILE_list - list->file.root_list) < list->size)) {
#line 874
      goto while_break;
    }
    {
#line 877
    retval = generate_recursive___1(p_MY_FILE_list);
    }
#line 877
    if (retval) {
#line 877
      return (retval);
    }
#line 874
    p_MY_FILE_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  goto switch_break;
  case_2: /* CIL Label */ 
#line 882
  if ((unsigned long )list == (unsigned long )bbd_list___1) {
    {
#line 884
    retval___0 = write_block_list___1(BDepot_start_block___1, bbd_list___1, 0);
    }
#line 884
    if (retval___0) {
#line 884
      return (retval___0);
    }
#line 885
    if ((int )pos_block___1 != 0) {
#line 885
      if ((int )pos_block___1 % 512) {
        {
#line 885
        memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 512 + 1) * 512 - (int )pos_block___1));
        }
      }
      {
#line 885
      tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                   (size_t )512, (FILE */* __restrict  */)output_file___1);
      }
#line 885
      if (! (tmp == 512UL)) {
#line 885
        return (1);
      }
#line 885
      next_block___1 ++;
#line 885
      pos_block___1 = (unsigned short)0;
    }
#line 886
    goto switch_break;
  } else
#line 888
  if ((unsigned long )list == (unsigned long )BDepot___4) {
#line 890
    goto switch_break;
  } else
#line 891
  if ((unsigned long )list == (unsigned long )SDepot___4) {
#line 893
    goto switch_break;
  } else
#line 895
  if (! ((unsigned long )"list->type==block_list but list UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 895
    __assert_fail("\"list->type==block_list but list UNKNOWN in generate_recursive\"==((void *)0)",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  895U, "generate_recursive");
    }
  }
  case_3: /* CIL Label */ 
#line 900
  if (! ((unsigned long )list == (unsigned long )Root___4)) {
    {
#line 900
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  900U, "generate_recursive");
    }
  }
#line 901
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 905
  retval___1 = generate_real_file___1(list);
  }
#line 905
  if (retval___1) {
#line 905
    return (retval___1);
  }
#line 906
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 909
  if (! ((unsigned long )"list->type UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 909
    __assert_fail("\"list->type UNKNOWN in generate_recursive\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  909U, "generate_recursive");
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 912
  return (0);
}
}
#line 916 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_SDepot___1(void) 
{ 
  int retval ;
  size_t tmp ;

  {
  {
#line 920
  retval = write_block_list___1(1U, SDepot___4, 1);
  }
#line 920
  if (retval) {
#line 920
    return (retval);
  }
#line 921
  if ((int )pos_block___1 != 0) {
#line 921
    if ((int )pos_block___1 % 512) {
      {
#line 921
      memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 512 + 1) * 512 - (int )pos_block___1));
      }
    }
    {
#line 921
    tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___1);
    }
#line 921
    if (! (tmp == 512UL)) {
#line 921
      return (1);
    }
#line 921
    next_block___1 ++;
#line 921
    pos_block___1 = (unsigned short)0;
  }
#line 923
  return (0);
}
}
#line 927 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_Root___1(void) 
{ 
  int retval ;
  int zzzi ;
  unsigned short U16zero ;
  size_t tmp ;

  {
  {
#line 931
  retval = write_root_list___1(Root___4);
  }
#line 931
  if (retval) {
#line 931
    return (retval);
  }
#line 932
  if ((int )pos_block___1 != 0) {
    {
#line 932
    U16zero = (unsigned short)0;
#line 932
    memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(512 - (int )pos_block___1));
#line 932
    zzzi = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 932
      if (! (zzzi < 4)) {
#line 932
        goto while_break;
      }
#line 932
      if (zzzi * 128 >= (int )pos_block___1) {
        {
#line 932
        fil_swriteU16((output_block___1 + zzzi * 128) + 64, & U16zero);
        }
      }
#line 932
      zzzi ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 933
  if ((int )pos_block___1 != 0) {
    {
#line 933
    tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___1);
    }
#line 933
    if (! (tmp == 512UL)) {
#line 933
      return (1);
    }
#line 933
    next_block___1 ++;
#line 933
    pos_block___1 = (unsigned short)0;
  }
#line 935
  return (0);
}
}
#line 938 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_BDepot___1(void) 
{ 
  MY_FILE SDepot_and_Root_block_list ;
  MY_FILE file_block_list ;
  unsigned int next_block_link ;
  int retval ;
  int retval___0 ;
  unsigned int tmp ;
  int retval___1 ;
  size_t tmp___0 ;

  {
#line 946
  next_block_link = (unsigned int )((4294967295UL + (unsigned long )header_blocks___1) + 1UL);
#line 950
  if (! (next_block_link == sbfile_start_block___1 + 1U)) {
    {
#line 950
    __assert_fail("next_block_link == sbfile_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  950U, "generate_BDepot");
    }
  }
  {
#line 952
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 952
  file_block_list.size = (unsigned int )sizeof(unsigned int );
#line 952
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 952
  file_block_list.file.block_list = BDepot___4->file.block_list;
#line 955
  retval = write_block_list___1(next_block_link, & file_block_list, 1);
  }
#line 955
  if (retval) {
#line 955
    return (retval);
  }
#line 958
  next_block_link += sbfile_blocks___1;
#line 961
  if (! (next_block_link == (sbfile_start_block___1 + sbfile_blocks___1) + 1U)) {
    {
#line 961
    __assert_fail("next_block_link == sbfile_start_block + sbfile_blocks + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  961U, "generate_BDepot");
    }
  }
  {
#line 963
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 963
  file_block_list.size = (unsigned int )((unsigned long )BDepot___4->size - 3UL * sizeof(unsigned int ));
#line 963
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 963
  file_block_list.file.block_list = BDepot___4->file.block_list + 3;
#line 965
  retval___0 = write_block_list___1(next_block_link, & file_block_list, 1);
  }
#line 965
  if (retval___0) {
#line 965
    return (retval___0);
  }
  {
#line 968
  tmp = sum_block_list___1(& file_block_list);
#line 968
  next_block_link += tmp;
  }
#line 971
  if (sbfile___4->size > 0U) {
#line 973
    if (! (next_block_link == SDepot_start_block___1 + 1U)) {
      {
#line 973
      __assert_fail("next_block_link == SDepot_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    973U, "generate_BDepot");
      }
    }
  }
  {
#line 975
  SDepot_and_Root_block_list.type = (enum __anonenum_type_26 )2;
#line 975
  SDepot_and_Root_block_list.size = (unsigned int )(2UL * sizeof(unsigned int ));
#line 975
  SDepot_and_Root_block_list.blocks = (unsigned int *)((void *)0);
#line 975
  SDepot_and_Root_block_list.file.block_list = BDepot___4->file.block_list + 1;
#line 977
  retval___1 = write_block_list___1(next_block_link, & SDepot_and_Root_block_list,
                                    1);
  }
#line 977
  if (retval___1) {
#line 977
    return (retval___1);
  }
#line 980
  if ((int )pos_block___1 != 0) {
#line 980
    if ((int )pos_block___1 % 512) {
      {
#line 980
      memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 512 + 1) * 512 - (int )pos_block___1));
      }
    }
    {
#line 980
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___1);
    }
#line 980
    if (! (tmp___0 == 512UL)) {
#line 980
      return (1);
    }
#line 980
    next_block___1 ++;
#line 980
    pos_block___1 = (unsigned short)0;
  }
#line 982
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int last_small_stream_next_block___1  =    0U;
#line 993 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_start_block_set___1  =    0;
#line 994 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_may_need_write_until_boundary___1  =    0;
#line 985 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_real_file___1(MY_FILE *MY_FILE_file ) 
{ 
  FILE *file ;
  int n_read ;
  unsigned char *pps ;
  unsigned int total_bytes ;
  unsigned int sbfile_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 1004
  if (! ((int )pos_block___1 <= 512)) {
    {
#line 1004
    __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1004U, "generate_real_file");
    }
  }
#line 1005
  if (! ((int )pos_block___1 % 64 == 0)) {
    {
#line 1005
    __assert_fail("pos_block % 0x40 == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1005U, "generate_real_file");
    }
  }
#line 1008
  if (! *(MY_FILE_file->file.real.name + 0)) {
    {
#line 1008
    __assert_fail("MY_FILE_file->file.real.name[0]", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1008U, "generate_real_file");
    }
  }
  {
#line 1009
  file = fopen((char const   */* __restrict  */)MY_FILE_file->file.real.name, (char const   */* __restrict  */)"rb");
  }
#line 1010
  if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 1010
    return (11);
  }
#line 1013
  if (MY_FILE_file->size >= 4096U) {
#line 1018
    if (sbfile_may_need_write_until_boundary___1) {
#line 1022
      if ((int )pos_block___1 != 0) {
#line 1022
        if ((int )pos_block___1 % 512) {
          {
#line 1022
          memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 512 + 1) * 512 - (int )pos_block___1));
          }
        }
        {
#line 1022
        tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___1);
        }
#line 1022
        if (! (tmp == 512UL)) {
#line 1022
          return (1);
        }
#line 1022
        next_block___1 ++;
#line 1022
        pos_block___1 = (unsigned short)0;
      }
#line 1023
      sbfile_may_need_write_until_boundary___1 = 0;
    }
    {
#line 1029
    pps = Root___4->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1030
    fil_swriteU32(pps + 116, & next_block___1);
    }
  } else {
    {
#line 1039
    pps = Root___4->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1040
    fil_swriteU32(pps + 116, & last_small_stream_next_block___1);
#line 1041
    last_small_stream_next_block___1 += *(MY_FILE_file->blocks);
    }
#line 1044
    if (! sbfile_start_block_set___1) {
#line 1050
      if (! (sbfile_start_block___1 == next_block___1)) {
        {
#line 1050
        __assert_fail("sbfile_start_block == next_block", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1050U, "generate_real_file");
        }
      }
      {
#line 1051
      fil_swriteU32(Root___4->file.root_list + 116, & next_block___1);
#line 1053
      tmp___0 = sum_blocks_MY_FILE_list___1(sbfile___4);
#line 1053
      sbfile_size = tmp___0 * 64U;
#line 1056
      tmp___1 = fil_sreadU32(Root___4->file.root_list + 120);
      }
#line 1056
      if (! (sbfile_size == tmp___1)) {
        {
#line 1056
        __assert_fail("sbfile_size == fil_sreadU32 (Root->file.root_list + 0x78)",
                      "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1056U, "generate_real_file");
        }
      }
#line 1058
      sbfile_start_block_set___1 = 1;
#line 1059
      sbfile_may_need_write_until_boundary___1 = 1;
    }
  }
#line 1064
  total_bytes = 0U;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1066
    tmp___6 = feof(file);
    }
#line 1066
    if (tmp___6) {
#line 1066
      goto while_break;
    }
    {
#line 1068
    tmp___2 = fread((void */* __restrict  */)(output_block___1 + (int )pos_block___1),
                    (size_t )1, (size_t )(512 - (int )pos_block___1), (FILE */* __restrict  */)file);
#line 1068
    n_read = (int )tmp___2;
#line 1069
    tmp___3 = ferror(file);
    }
#line 1069
    if (tmp___3) {
#line 1069
      return (11);
    }
#line 1070
    if (n_read < 512 - (int )pos_block___1) {
      {
#line 1072
      tmp___4 = feof(file);
      }
#line 1072
      if (! tmp___4) {
        {
#line 1072
        __assert_fail("feof (file)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1072U, "generate_real_file");
        }
      }
    }
#line 1073
    pos_block___1 = (unsigned short )((int )pos_block___1 + (int )((unsigned short )n_read));
#line 1074
    total_bytes += (unsigned int )n_read;
#line 1075
    if ((int )pos_block___1 == 512) {
      {
#line 1075
      tmp___5 = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )512,
                       (size_t )1, (FILE */* __restrict  */)output_file___1);
      }
#line 1075
      if (! (tmp___5 == 1UL)) {
#line 1075
        return (1);
      }
#line 1075
      next_block___1 ++;
#line 1075
      pos_block___1 = (unsigned short)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (! (total_bytes == MY_FILE_file->size)) {
#line 1077
    return (12);
  }
#line 1079
  if (MY_FILE_file->size >= 4096U) {
#line 1081
    if ((int )pos_block___1 != 0) {
#line 1081
      if ((int )pos_block___1 % 512) {
        {
#line 1081
        memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 512 + 1) * 512 - (int )pos_block___1));
        }
      }
      {
#line 1081
      tmp___7 = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )1,
                       (size_t )512, (FILE */* __restrict  */)output_file___1);
      }
#line 1081
      if (! (tmp___7 == 512UL)) {
#line 1081
        return (1);
      }
#line 1081
      next_block___1 ++;
#line 1081
      pos_block___1 = (unsigned short)0;
    }
  } else
#line 1084
  if ((int )pos_block___1 % 64) {
    {
#line 1084
    memset((void *)(output_block___1 + (int )pos_block___1), 255, (size_t )(((int )pos_block___1 / 64 + 1) * 64 - (int )pos_block___1));
    }
#line 1084
    if (! (((int )pos_block___1 + ((int )pos_block___1 / 64 + 1) * 64) - (int )pos_block___1 == ((int )pos_block___1 / 64 + 1) * 64)) {
      {
#line 1084
      __assert_fail("pos_block+(pos_block/0x40 + 1)*0x40 - pos_block == (pos_block/0x40 + 1)*0x40",
                    "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1084U, "generate_real_file");
      }
    }
#line 1084
    pos_block___1 = (unsigned short )((int )pos_block___1 + (int )((unsigned short )(((int )pos_block___1 / 64 + 1) * 64 - (int )pos_block___1)));
  }
  {
#line 1087
  fclose(file);
  }
#line 1089
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_block_list___1(unsigned int start_count , MY_FILE *list , int write_end_chain ) 
{ 
  unsigned int *p ;
  unsigned int n ;
  unsigned int end_chain ;
  unsigned int value_to_write ;
  unsigned int delta ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1098
  end_chain = 4294967294U;
#line 1104
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 1104
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1104U, "write_block_list");
    }
  }
#line 1105
  if (! ((int )pos_block___1 <= 508)) {
    {
#line 1105
    __assert_fail("pos_block <= 0x01fc", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1105U, "write_block_list");
    }
  }
#line 1107
  delta = start_count;
#line 1108
  if (list->size == 0U) {
#line 1108
    return (0);
  }
#line 1109
  p = list->file.block_list;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! ((unsigned int )((unsigned char *)p - (unsigned char *)list->file.block_list) < list->size)) {
#line 1109
      goto while_break;
    }
#line 1112
    n = 0U;
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1112
      if (! (n < *p)) {
#line 1112
        goto while_break___0;
      }
#line 1115
      if ((int )pos_block___1 == 512) {
        {
#line 1115
        tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___1);
        }
#line 1115
        if (! (tmp == 1UL)) {
#line 1115
          return (1);
        }
#line 1115
        next_block___1 ++;
#line 1115
        pos_block___1 = (unsigned short)0;
      }
#line 1118
      if (write_end_chain) {
#line 1118
        if (! (n + 1U < *p)) {
#line 1119
          value_to_write = end_chain;
        } else {
#line 1121
          value_to_write = n + delta;
        }
      } else {
#line 1121
        value_to_write = n + delta;
      }
      {
#line 1122
      fil_swriteU32(output_block___1 + (int )pos_block___1, & value_to_write);
#line 1123
      pos_block___1 = (unsigned short )((int )pos_block___1 + (int )((unsigned short )sizeof(unsigned int )));
      }
#line 1124
      if (! ((int )pos_block___1 <= 512)) {
        {
#line 1124
        __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1124U, "write_block_list");
        }
      }
#line 1112
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1126
    delta += n;
#line 1109
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1128
  if ((int )pos_block___1 == 512) {
    {
#line 1128
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___1);
    }
#line 1128
    if (! (tmp___0 == 1UL)) {
#line 1128
      return (1);
    }
#line 1128
    next_block___1 ++;
#line 1128
    pos_block___1 = (unsigned short)0;
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_root_list___1(MY_FILE *list ) 
{ 
  unsigned char *p ;
  size_t tmp ;

  {
#line 1139
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1139
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1139U, "write_root_list");
    }
  }
#line 1140
  if (! ((int )pos_block___1 == 0)) {
    {
#line 1140
    __assert_fail("pos_block == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1140U, "write_root_list");
    }
  }
#line 1141
  if (! ((unsigned int )list->type == 3U)) {
    {
#line 1141
    __assert_fail("list->type == root_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1141U, "write_root_list");
    }
  }
#line 1142
  if (! (list->size > 0U)) {
    {
#line 1142
    __assert_fail("list->size > 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1142U, "write_root_list");
    }
  }
#line 1144
  p = list->file.root_list;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (! ((unsigned int )(p - list->file.root_list) < list->size)) {
#line 1144
      goto while_break;
    }
    {
#line 1147
    memcpy((void */* __restrict  */)(output_block___1 + (p - list->file.root_list) % 512L),
           (void const   */* __restrict  */)p, (size_t )128);
#line 1169
    pos_block___1 = (unsigned short )((int )pos_block___1 + 128);
    }
#line 1170
    if (! ((int )pos_block___1 <= 512)) {
      {
#line 1170
      __assert_fail("pos_block <= (unsigned short)0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1170U, "write_root_list");
      }
    }
#line 1171
    if ((int )pos_block___1 == 512) {
      {
#line 1171
      tmp = fwrite((void const   */* __restrict  */)(output_block___1), (size_t )512,
                   (size_t )1, (FILE */* __restrict  */)output_file___1);
      }
#line 1171
      if (! (tmp == 1UL)) {
#line 1171
        return (1);
      }
#line 1171
      next_block___1 ++;
#line 1171
      pos_block___1 = (unsigned short)0;
    }
#line 1144
    p += 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void ends___4(void) 
{ 


  {
#line 1193
  if ((unsigned long )output_file___1 != (unsigned long )((void *)0)) {
    {
#line 1194
    fclose(output_file___1);
    }
  }
#line 1195
  return;
}
}
#line 1198 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void calculate_blocks___1(void) 
{ 
  MY_FILE big_streams_list ;
  unsigned int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1205
  big_streams_list.type = (enum __anonenum_type_26 )1;
#line 1205
  big_streams_list.size = (unsigned int )((unsigned long )Input___1.size - 5UL * sizeof(MY_FILE ));
#line 1205
  big_streams_list.blocks = (unsigned int *)((void *)0);
#line 1205
  big_streams_list.file.MY_FILE_list = Input___1.file.MY_FILE_list + 5;
#line 1211
  if (! (*(BDepot___4->blocks) == *(bbd_list___1->file.block_list))) {
    {
#line 1211
    __assert_fail("*(BDepot->blocks) == *(bbd_list->file.block_list)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1211U, "calculate_blocks");
    }
  }
#line 1212
  if (! Root___4->size) {
#line 1212
    tmp = 1U;
  } else {
#line 1212
    tmp = 1U + (Root___4->size - 1U) / 512U;
  }
#line 1212
  if (! (*(Root___4->blocks) == tmp)) {
    {
#line 1212
    __assert_fail("*(Root->blocks) == (!(Root->size) ? 1 : (1+((Root->size)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1212U, "calculate_blocks");
    }
  }
  {
#line 1215
  tmp___3 = sum_blocks_MY_FILE_list___1(sbfile___4);
  }
#line 1215
  if (tmp___3 * 64U) {
    {
#line 1215
    tmp___1 = sum_blocks_MY_FILE_list___1(sbfile___4);
#line 1215
    tmp___2 = 1U + (tmp___1 * 64U - 1U) / 512U;
    }
  } else {
#line 1215
    tmp___2 = 0U;
  }
#line 1215
  if (! (*(sbfile___4->blocks) == tmp___2)) {
    {
#line 1215
    __assert_fail("*(sbfile->blocks) == (!(sum_blocks_MY_FILE_list (sbfile) * 0x40) ? 0 : (1+((sum_blocks_MY_FILE_list (sbfile) * 0x40)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1216U, "calculate_blocks");
    }
  }
  {
#line 1217
  tmp___7 = sum_block_list___1(SDepot___4);
  }
#line 1217
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 1217
    tmp___5 = sum_block_list___1(SDepot___4);
#line 1217
    tmp___6 = 1UL + ((unsigned long )tmp___5 * sizeof(unsigned int ) - 1UL) / 512UL;
    }
  } else {
#line 1217
    tmp___6 = 0UL;
  }
#line 1217
  if (! ((unsigned long )*(SDepot___4->blocks) == tmp___6)) {
    {
#line 1217
    __assert_fail("*(SDepot->blocks) == (!((sum_block_list (SDepot) * sizeof (unsigned int))) ? 0 : (1+(((sum_block_list (SDepot) * sizeof (unsigned int)))-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1218U, "calculate_blocks");
    }
  }
  {
#line 1219
  BDepot_blocks___1 = *(BDepot___4->blocks);
#line 1220
  SDepot_blocks___1 = *(SDepot___4->blocks);
#line 1221
  Root_blocks___1 = *(Root___4->blocks);
#line 1222
  sbfile_blocks___1 = *(sbfile___4->blocks);
#line 1223
  big_streams_blocks___1 = sum_blocks_MY_FILE_list___1(& big_streams_list);
  }
#line 1224
  if (! ((unsigned long )(19U + BDepot_blocks___1) * sizeof(unsigned int ))) {
#line 1224
    header_blocks___1 = 1U;
  } else {
#line 1224
    header_blocks___1 = (unsigned int )(1UL + ((unsigned long )(19U + BDepot_blocks___1) * sizeof(unsigned int ) - 1UL) / 512UL);
  }
#line 1228
  sbfile_start_block___1 = (unsigned int )(4294967295UL + (unsigned long )header_blocks___1);
#line 1230
  Root_start_block___1 = (unsigned int )((((4294967295UL + (unsigned long )header_blocks___1) + (unsigned long )sbfile_blocks___1) + (unsigned long )big_streams_blocks___1) + (unsigned long )SDepot_blocks___1);
#line 1233
  if (SDepot_blocks___1 > 0U) {
#line 1235
    SDepot_start_block___1 = (unsigned int )(((4294967295UL + (unsigned long )header_blocks___1) + (unsigned long )sbfile_blocks___1) + (unsigned long )big_streams_blocks___1);
  } else {
#line 1239
    SDepot_start_block___1 = 4294967294U;
  }
#line 1240
  BDepot_start_block___1 = (unsigned int )(((((4294967295UL + (unsigned long )header_blocks___1) + (unsigned long )sbfile_blocks___1) + (unsigned long )big_streams_blocks___1) + (unsigned long )SDepot_blocks___1) + (unsigned long )Root_blocks___1);
#line 1247
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___1(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 222
static int __cole_print_tree_outdir___1(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 223
static int __cole_print_tree_inroot___1(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 224
static int __cole_print_tree_indirentry___1(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) ;
#line 242 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___1(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 250
  (*((long *)info)) ++;
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_outdir___1(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 262
  (*((long *)info)) --;
#line 263
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_inroot___1(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 276
  printf((char const   */* __restrict  */)"DIR ");
#line 277
  tmp = cole_dir_getsize(cd);
#line 277
  printf((char const   */* __restrict  */)" %7zu", tmp);
#line 278
  tmp___0 = cole_dir_getsec2(cd);
#line 278
  tmp___1 = cole_dir_getdays2(cd);
#line 278
  tmp___2 = cole_dir_getsec1(cd);
#line 278
  tmp___3 = cole_dir_getdays1(cd);
#line 278
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___3, tmp___2,
         tmp___1, tmp___0);
#line 283
  entry_name = cole_dir_getname(cd);
#line 284
  tmp___4 = __ctype_b_loc();
  }
#line 284
  if ((int const   )*(*tmp___4 + (int )*(entry_name + 0)) & 16384) {
    {
#line 287
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 285
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indirentry___1(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  long level ;
  long i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 304
  level = *((long *)info);
#line 305
  i = 0L;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < level)) {
#line 305
      goto while_break;
    }
#line 306
    if (i == level - 1L) {
      {
#line 307
      printf((char const   */* __restrict  */)"\\--");
      }
    } else {
      {
#line 309
      printf((char const   */* __restrict  */)"|  ");
      }
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  tmp___0 = cole_direntry_isdir(cde);
  }
#line 312
  if (tmp___0) {
    {
#line 313
    printf((char const   */* __restrict  */)"DIR ");
    }
  } else {
    {
#line 314
    tmp = cole_direntry_isfile(cde);
    }
#line 314
    if (tmp) {
      {
#line 315
      printf((char const   */* __restrict  */)"FILE");
      }
    } else {
      {
#line 317
      printf((char const   */* __restrict  */)"????");
      }
    }
  }
  {
#line 318
  tmp___1 = cole_direntry_getsize(cde);
#line 318
  printf((char const   */* __restrict  */)" %7zu", tmp___1);
#line 319
  tmp___2 = cole_direntry_getsec2(cde);
#line 319
  tmp___3 = cole_direntry_getdays2(cde);
#line 319
  tmp___4 = cole_direntry_getsec1(cde);
#line 319
  tmp___5 = cole_direntry_getdays1(cde);
#line 319
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___5, tmp___4,
         tmp___3, tmp___2);
#line 324
  entry_name = cole_direntry_getname(cde);
#line 325
  tmp___6 = __ctype_b_loc();
  }
#line 325
  if ((int const   )*(*tmp___6 + (int )*(entry_name + 0)) & 16384) {
    {
#line 328
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 326
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 330
  return (0);
}
}
#line 585
static void _cole_fopen_action___1(COLEDIRENT *cde , void *_info ) ;
#line 605 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static void _cole_fopen_action___1(COLEDIRENT *cde , void *_info ) 
{ 
  struct _cole_fopen_info *info ;
  int tmp ;

  {
  {
#line 610
  info = (struct _cole_fopen_info *)_info;
#line 612
  tmp = cole_direntry_isfile(cde);
  }
#line 612
  if (! tmp) {
#line 613
    info->colerrno = (COLERRNO )18;
#line 614
    info->succ = 0;
#line 615
    return;
  }
  {
#line 618
  info->file = cole_fopen_direntry(cde, & info->colerrno);
  }
#line 619
  if ((unsigned long )info->file == (unsigned long )((void *)0)) {
#line 621
    info->succ = 0;
#line 622
    return;
  }
#line 625
  info->succ = 1;
#line 626
  return;
}
}
#line 948
static int __cole_recurse_tree___1(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) ;
#line 986 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_recurse_tree___1(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) 
{ 
  COLEDIRENT *cde ;
  COLEDIR *cd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1007
  if (level == 1L) {
#line 1009
    if ((unsigned long )inroot != (unsigned long )((void *)0)) {
      {
#line 1010
      tmp = (*inroot)(_cd, info, colerrno);
      }
#line 1010
      if (tmp) {
#line 1012
        return (1);
      }
    }
  }
  {
#line 1018
  cde = cole_visiteddirentry(_cd);
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned long )cde != (unsigned long )((void *)0))) {
#line 1018
      goto while_break;
    }
#line 1020
    if ((unsigned long )indirentry != (unsigned long )((void *)0)) {
      {
#line 1021
      tmp___0 = (*indirentry)(cde, info, colerrno);
      }
#line 1021
      if (tmp___0) {
#line 1023
        return (1);
      }
    }
    {
#line 1028
    tmp___6 = cole_direntry_isdir(cde);
    }
#line 1028
    if (tmp___6) {
      {
#line 1029
      cd = cole_opendir_direntry(cde, colerrno);
      }
#line 1030
      if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 1032
        return (1);
      }
#line 1035
      if ((unsigned long )indir != (unsigned long )((void *)0)) {
        {
#line 1036
        tmp___1 = (*indir)(cd, info, colerrno);
        }
#line 1036
        if (tmp___1) {
          {
#line 1038
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1039
          return (1);
        }
      }
#line 1043
      if ((unsigned long )visitdir == (unsigned long )((void *)0)) {
#line 1043
        goto _L;
      } else {
        {
#line 1043
        tmp___3 = (*visitdir)(cd, info);
        }
#line 1043
        if (tmp___3) {
          _L: /* CIL Label */ 
          {
#line 1045
          tmp___2 = __cole_recurse_tree___1(cd, level + 1L, info, inroot, indirentry,
                                            indir, outdir, visitdir, colerrno);
          }
#line 1045
          if (tmp___2) {
            {
#line 1050
            cole_closedir(cd, (COLERRNO *)((void *)0));
            }
#line 1051
            return (1);
          }
        }
      }
#line 1055
      if ((unsigned long )outdir != (unsigned long )((void *)0)) {
        {
#line 1056
        tmp___4 = (*outdir)(cd, info, colerrno);
        }
#line 1056
        if (tmp___4) {
          {
#line 1058
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1059
          return (1);
        }
      }
      {
#line 1063
      tmp___5 = cole_closedir(cd, colerrno);
      }
#line 1063
      if (tmp___5) {
#line 1065
        return (1);
      }
    }
    {
#line 1018
    cde = cole_nextdirentry(_cd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return (0);
}
}
#line 1098
static int __cole_locate_filename_indirentry___1(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) ;
#line 1099
static int __cole_locate_filename_visitdir___1(COLEDIR *cd , void *info ) ;
#line 1136 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_visitdir___1(COLEDIR *cd , void *info ) 
{ 


  {
#line 1139
  return (((struct __cole_locate_filenameinfo *)info)->visitdir);
}
}
#line 1142 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_indirentry___1(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  struct __cole_locate_filenameinfo *info ;
  char *pcurrent ;
  char *pentry_name ;
  int tmp ;

  {
  {
#line 1151
  info = (struct __cole_locate_filenameinfo *)_info;
#line 1152
  entry_name = cole_direntry_getname(cde);
#line 1153
  pcurrent = info->current;
#line 1153
  pentry_name = entry_name;
  }
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (*pcurrent) {
#line 1153
      if (*pentry_name) {
#line 1153
        if (! ((int )*pcurrent != 47)) {
#line 1153
          goto while_break;
        }
      } else {
#line 1153
        goto while_break;
      }
    } else {
#line 1153
      goto while_break;
    }
#line 1156
    if ((int )*pcurrent != (int )*pentry_name) {
#line 1157
      info->visitdir = 0;
#line 1158
      return (0);
    }
#line 1153
    pcurrent ++;
#line 1153
    pentry_name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1162
  if ((int )*pentry_name == 0) {
#line 1162
    goto case_0;
  }
#line 1197
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 1164
  if ((int )*pcurrent == 47) {
#line 1164
    goto case_47;
  }
#line 1185
  if ((int )*pcurrent == 0) {
#line 1185
    goto case_0___0;
  }
#line 1193
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 1165
  tmp = cole_direntry_isdir(cde);
  }
#line 1165
  if (! tmp) {
#line 1166
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1167
      *colerrno = (COLERRNO )16;
    }
#line 1168
    return (1);
  }
#line 1170
  pcurrent ++;
#line 1171
  info->current = pcurrent;
#line 1174
  if (! *(info->current)) {
#line 1176
    if ((unsigned long )info->action != (unsigned long )((void *)0)) {
      {
#line 1177
      (*(info->action))(cde, info->info);
      }
    }
#line 1180
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1180
      *colerrno = (COLERRNO )23;
    }
#line 1181
    return (1);
  }
#line 1183
  info->visitdir = 1;
#line 1184
  return (0);
  case_0___0: /* CIL Label */ 
#line 1187
  if ((unsigned long )info->action != (unsigned long )((void *)0)) {
    {
#line 1188
    (*(info->action))(cde, info->info);
    }
  }
#line 1191
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1191
    *colerrno = (COLERRNO )23;
  }
#line 1192
  return (1);
  switch_default: /* CIL Label */ 
#line 1194
  info->visitdir = 0;
#line 1195
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 1199
  if ((int )*pcurrent == 0) {
#line 1199
    goto case_0___1;
  }
#line 1202
  if ((int )*pcurrent == 47) {
#line 1202
    goto case_47___0;
  }
#line 1205
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 1200
  info->visitdir = 0;
#line 1201
  return (0);
  case_47___0: /* CIL Label */ 
#line 1203
  info->visitdir = 0;
#line 1204
  return (0);
  switch_default___1: /* CIL Label */ 
#line 1206
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1206
    *colerrno = (COLERRNO )21;
  }
#line 1207
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlcdump.c"
static char FileName___0[2][12]  = { {        (char )'/',        (char )'W',        (char )'o',        (char )'r', 
            (char )'k',        (char )'b',        (char )'o',        (char )'o', 
            (char )'k',        (char )'\000'}, 
   {        (char )'/',        (char )'B',        (char )'o',        (char )'o', 
            (char )'k',        (char )'\000'}};
#line 49
static void output_opcode_string___0(int opcode ) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlcdump.c"
static char filename___1[128]  ;
#line 178 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/xlhtml/xlcdump.c"
static void output_opcode_string___0(int opcode ) 
{ 


  {
  {
#line 184
  if ((opcode & 255) == 1) {
#line 184
    goto case_1;
  }
#line 184
  if ((opcode & 255) == 16) {
#line 184
    goto case_1;
  }
#line 187
  if ((opcode & 255) == 2) {
#line 187
    goto case_2;
  }
#line 190
  if ((opcode & 255) == 3) {
#line 190
    goto case_3;
  }
#line 193
  if ((opcode & 255) == 6) {
#line 193
    goto case_6;
  }
#line 196
  if ((opcode & 255) == 7) {
#line 196
    goto case_7;
  }
#line 199
  if ((opcode & 255) == 9) {
#line 199
    goto case_9;
  }
#line 202
  if ((opcode & 255) == 10) {
#line 202
    goto case_10;
  }
#line 205
  if ((opcode & 255) == 11) {
#line 205
    goto case_11;
  }
#line 208
  if ((opcode & 255) == 12) {
#line 208
    goto case_12;
  }
#line 211
  if ((opcode & 255) == 13) {
#line 211
    goto case_13;
  }
#line 214
  if ((opcode & 255) == 20) {
#line 214
    goto case_20;
  }
#line 217
  if ((opcode & 255) == 21) {
#line 217
    goto case_21;
  }
#line 220
  if ((opcode & 255) == 22) {
#line 220
    goto case_22;
  }
#line 223
  if ((opcode & 255) == 23) {
#line 223
    goto case_23;
  }
#line 226
  if ((opcode & 255) == 24) {
#line 226
    goto case_24;
  }
#line 229
  if ((opcode & 255) == 25) {
#line 229
    goto case_25;
  }
#line 232
  if ((opcode & 255) == 26) {
#line 232
    goto case_26;
  }
#line 235
  if ((opcode & 255) == 27) {
#line 235
    goto case_27;
  }
#line 238
  if ((opcode & 255) == 28) {
#line 238
    goto case_28;
  }
#line 241
  if ((opcode & 255) == 29) {
#line 241
    goto case_29;
  }
#line 244
  if ((opcode & 255) == 30) {
#line 244
    goto case_30;
  }
#line 247
  if ((opcode & 255) == 31) {
#line 247
    goto case_31;
  }
#line 250
  if ((opcode & 255) == 32) {
#line 250
    goto case_32;
  }
#line 253
  if ((opcode & 255) == 33) {
#line 253
    goto case_33;
  }
#line 256
  if ((opcode & 255) == 34) {
#line 256
    goto case_34;
  }
#line 259
  if ((opcode & 255) == 36) {
#line 259
    goto case_36;
  }
#line 262
  if ((opcode & 255) == 37) {
#line 262
    goto case_37;
  }
#line 265
  if ((opcode & 255) == 38) {
#line 265
    goto case_38;
  }
#line 268
  if ((opcode & 255) == 39) {
#line 268
    goto case_39;
  }
#line 271
  if ((opcode & 255) == 50) {
#line 271
    goto case_50;
  }
#line 274
  if ((opcode & 255) == 51) {
#line 274
    goto case_51;
  }
#line 277
  if ((opcode & 255) == 52) {
#line 277
    goto case_52;
  }
#line 280
  if ((opcode & 255) == 53) {
#line 280
    goto case_53;
  }
#line 283
  if ((opcode & 255) == 58) {
#line 283
    goto case_58;
  }
#line 286
  if ((opcode & 255) == 60) {
#line 286
    goto case_60;
  }
#line 289
  if ((opcode & 255) == 61) {
#line 289
    goto case_61;
  }
#line 292
  if ((opcode & 255) == 62) {
#line 292
    goto case_62;
  }
#line 295
  if ((opcode & 255) == 63) {
#line 295
    goto case_63;
  }
#line 298
  if ((opcode & 255) == 64) {
#line 298
    goto case_64;
  }
#line 301
  if ((opcode & 255) == 65) {
#line 301
    goto case_65;
  }
#line 304
  if ((opcode & 255) == 67) {
#line 304
    goto case_67;
  }
#line 307
  if ((opcode & 255) == 68) {
#line 307
    goto case_68;
  }
#line 310
  if ((opcode & 255) == 69) {
#line 310
    goto case_69;
  }
#line 313
  if ((opcode & 255) == 70) {
#line 313
    goto case_70;
  }
#line 316
  if ((opcode & 255) == 72) {
#line 316
    goto case_72;
  }
#line 319
  if ((opcode & 255) == 74) {
#line 319
    goto case_74;
  }
#line 322
  if ((opcode & 255) == 75) {
#line 322
    goto case_75;
  }
#line 325
  if ((opcode & 255) == 78) {
#line 325
    goto case_78;
  }
#line 328
  if ((opcode & 255) == 79) {
#line 328
    goto case_79;
  }
#line 331
  if ((opcode & 255) == 80) {
#line 331
    goto case_80;
  }
#line 334
  if ((opcode & 255) == 81) {
#line 334
    goto case_81;
  }
#line 337
  if ((opcode & 255) == 91) {
#line 337
    goto case_91;
  }
#line 340
  if ((opcode & 255) == 93) {
#line 340
    goto case_93;
  }
#line 343
  if ((opcode & 255) == 96) {
#line 343
    goto case_96;
  }
#line 346
  if ((opcode & 255) == 97) {
#line 346
    goto case_97;
  }
#line 349
  if ((opcode & 255) == 98) {
#line 349
    goto case_98;
  }
#line 352
  if ((opcode & 255) == 99) {
#line 352
    goto case_99;
  }
#line 355
  if ((opcode & 255) == 100) {
#line 355
    goto case_100;
  }
#line 358
  if ((opcode & 255) == 101) {
#line 358
    goto case_101;
  }
#line 361
  if ((opcode & 255) == 102) {
#line 361
    goto case_102;
  }
#line 364
  if ((opcode & 255) == 103) {
#line 364
    goto case_103;
  }
#line 367
  goto switch_default;
  case_1: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 185
  puts("UNITS: Chart Units");
  }
#line 186
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 188
  puts("CHART: Location and overall chart dimensions");
  }
#line 189
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 191
  puts("SERIES: Series Definition");
  }
#line 192
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 194
  puts("DATAFORMAT: Series and Data Point Numbers");
  }
#line 195
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 197
  puts("LINEFORMAT: Style of a line or border");
  }
#line 198
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 200
  puts("MARKERFORMAT: Style of a line marker");
  }
#line 201
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 203
  puts("AREAFORMAT: Colors and patterns for an area");
  }
#line 204
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 206
  puts("PIEFORMAT: Position of the pie slice");
  }
#line 207
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 209
  puts("ATTACHEDLABEL: Series data/value labels");
  }
#line 210
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 212
  puts("SERIESTEXT: Legend/category/value text");
  }
#line 213
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 215
  puts("CHARTFORMAT: Parent record for chart group");
  }
#line 216
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 218
  puts("LEGEND: Legend type and position");
  }
#line 219
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 221
  puts("SERIESLIST: Specifies the series in an overlay chart");
  }
#line 222
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 224
  puts("BAR: Chart group is a bar or column chart group");
  }
#line 225
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 227
  puts("LINE: Chart group is a line chart group");
  }
#line 228
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 230
  puts("PIE: Chart group is a pie chart group");
  }
#line 231
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 233
  puts("AREA: Chart group is an area chart group");
  }
#line 234
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 236
  puts("SCATTER: Chart group is a scatter chart group");
  }
#line 237
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 239
  puts("CHARTLINE: Drop/Hi-Lo/Series Lines on a line chart");
  }
#line 240
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 242
  puts("AXIS: Axis Type");
  }
#line 243
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 245
  puts("TICK: Tick marks and labels format");
  }
#line 246
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 248
  puts("VALUERANGE: Defines value axis scale");
  }
#line 249
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 251
  puts("CATSERRANGE: Defines a category or series axis");
  }
#line 252
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 254
  puts("AXISLINEFORMAT: Defines a line that spans an axis");
  }
#line 255
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 257
  puts("CHARTFORMTLINK: Not Used");
  }
#line 258
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 260
  puts("DEFAULTTEXT: Default data label text properties");
  }
#line 261
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 263
  puts("TEXT: Defines display of text fields");
  }
#line 264
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 266
  puts("FONTX: Font Index");
  }
#line 267
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 269
  puts("OBJECTLINK: Attaches Text to chart or chart item");
  }
#line 270
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 272
  puts("FRAME: Defines border shape around displayed text");
  }
#line 273
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 275
  puts("BEGIN: Defines the beginning of an object");
  }
#line 276
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 278
  puts("END: Defines the end of an object");
  }
#line 279
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 281
  puts("PLOTAREA: Frame belongs to ploat area");
  }
#line 282
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 284
  puts("3d Chart group");
  }
#line 285
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 287
  puts("PICF: Picture Format");
  }
#line 288
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 290
  puts("DROPBAR: Defines drop bars");
  }
#line 291
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 293
  puts("RADAR: Chart group is a radar chart group");
  }
#line 294
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 296
  puts("SURFACE: Chart group is a surface chart group");
  }
#line 297
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 299
  puts("RADARAREA: Chart group is a radar area chart group");
  }
#line 300
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 302
  puts("AXISPARENT: Axis size and location");
  }
#line 303
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 305
  puts("LEGENDXN: Legend Exception");
  }
#line 306
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 308
  puts("SHTPROPS: Sheet Properties");
  }
#line 309
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 311
  puts("SERTOCRT: Series chart-group index");
  }
#line 312
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 314
  puts("AXESUSED: Number of axes sets");
  }
#line 315
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 317
  puts("SBASEREF: PivotTable Reference");
  }
#line 318
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 320
  puts("SERPARENT: Trendline or Errorbar series index");
  }
#line 321
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 323
  puts("SERAUXTREND: Series trendline");
  }
#line 324
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 326
  puts("IFMT: Number-Format Index");
  }
#line 327
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 329
  puts("POS: Position information");
  }
#line 330
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 332
  puts("ALRUNS: Text formatting");
  }
#line 333
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 335
  puts("AI: Linked data");
  }
#line 336
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 338
  puts("Series ErrorBar");
  }
#line 339
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 341
  puts("SERFMT: Series Format");
  }
#line 342
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 344
  puts("FBI: Font Basis");
  }
#line 345
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 347
  puts("BOPPOP: Bar of pie/pie of pie chart options");
  }
#line 348
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 350
  puts("AXCEXT: Axis options");
  }
#line 351
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 353
  puts("DAT: Data Table Options");
  }
#line 354
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 356
  puts("PLOTGROWTH: Font scale factors");
  }
#line 357
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 359
  puts("SIINDEX: Series Index");
  }
#line 360
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 362
  puts("GELFRAME: Fill data");
  }
#line 363
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 365
  puts("Custom bar of pie/ pie of pie chart options");
  }
#line 366
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 368
  puts("Unknown Chart Opcode");
  }
#line 369
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___2(pps_entry *node , unsigned short level ) ;
#line 74
static void ends___5(void) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *input___2  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Block___2  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Blockx___2  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *BDepot___5  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *SDepot___5  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Root___5  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static pps_entry *pps_list___2  ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int num_of_pps___2  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *sbfile___5  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *sbd_list___2  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *root_list___3  ;
#line 597 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *last_next_link_visited___2  ;
#line 598 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___2(pps_entry *node , unsigned short level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 603
  node->level = level;
#line 606
  if ((unsigned long )node->dir != 4294967295UL) {
#line 608
    if (node->dir > num_of_pps___2) {
#line 609
      return (0);
    } else
#line 608
    if (! (pps_list___2 + node->dir)->name[0]) {
#line 609
      return (0);
    } else {
      {
#line 610
      tmp = reorder_pps_tree___2(pps_list___2 + node->dir, (unsigned short )((int )level + 1));
      }
#line 610
      if (! tmp) {
#line 611
        return (0);
      }
    }
  }
#line 615
  if ((unsigned long )node->next != 4294967295UL) {
#line 617
    if (node->next > num_of_pps___2) {
#line 618
      return (0);
    } else
#line 617
    if (! (pps_list___2 + node->next)->name[0]) {
#line 618
      return (0);
    } else {
      {
#line 619
      tmp___0 = reorder_pps_tree___2(pps_list___2 + node->next, level);
      }
#line 619
      if (! tmp___0) {
#line 620
        return (0);
      }
    }
  } else {
#line 623
    last_next_link_visited___2 = & node->next;
  }
#line 626
  if ((unsigned long )node->previous != 4294967295UL) {
#line 628
    if (node->previous > num_of_pps___2) {
#line 629
      return (0);
    } else
#line 628
    if (! (pps_list___2 + node->previous)->name[0]) {
#line 629
      return (0);
    } else {
      {
#line 632
      *last_next_link_visited___2 = node->previous;
#line 633
      node->previous = 4294967295U;
#line 634
      tmp___1 = reorder_pps_tree___2(pps_list___2 + *last_next_link_visited___2, level);
      }
#line 634
      if (! tmp___1) {
#line 635
        return (0);
      }
    }
  }
#line 638
  return (1);
}
}
#line 759 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static void ends___5(void) 
{ 


  {
#line 767
  if ((unsigned long )Block___2 != (unsigned long )((void *)0)) {
    {
#line 767
    free((void *)Block___2);
    }
  }
#line 768
  if ((unsigned long )Blockx___2 != (unsigned long )((void *)0)) {
    {
#line 768
    free((void *)Blockx___2);
    }
  }
#line 775
  if ((unsigned long )Root___5 != (unsigned long )((void *)0)) {
    {
#line 775
    free((void *)Root___5);
    }
  }
#line 776
  if ((unsigned long )sbd_list___2 != (unsigned long )((void *)0)) {
    {
#line 776
    free((void *)sbd_list___2);
    }
  }
#line 777
  if ((unsigned long )root_list___3 != (unsigned long )((void *)0)) {
    {
#line 777
    free((void *)root_list___3);
    }
  }
#line 787
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE Input___2  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *sbfile___6  ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *SDepot___6  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *BDepot___6  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *bbd_list___2  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *Root___6  ;
#line 79 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int header_blocks___2  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int big_streams_blocks___2  ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_blocks___2  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_blocks___2  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_blocks___2  ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_blocks___2  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_start_block___2  ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_start_block___2  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_start_block___2  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_start_block___2  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static FILE *output_file___2  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned char output_block___2[512]  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned short pos_block___2  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int next_block___2  ;
#line 105
static int process_Root___2(pps_entry *pps_list___4 , unsigned int root ) ;
#line 106
static unsigned int max_pps_referenced___2(pps_entry *pps_list___4 , unsigned int node ) ;
#line 107
static unsigned int max3___2(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) ;
#line 108
static int process_streams___2(pps_entry *pps_list___4 , pps_entry *node ) ;
#line 109
static int add_stream_to_sbfile_and_SDepot___2(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 110
static int add_stream_to_Input_and_BDepot___2(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 111
static int add_entry_to_Root___2(pps_entry *node , unsigned int start_block ) ;
#line 112
static unsigned int add_MY_FILE_entry___2(MY_FILE *list , unsigned int size ) ;
#line 113
static int pps2root___2(unsigned char *pps , pps_entry *node , unsigned int start_block ) ;
#line 114
static void reset_links_in_Input___2(void) ;
#line 115
static void reset_links_in_BDepot___2(void) ;
#line 116
static void reset_links_in_SDepot___2(void) ;
#line 118
static int generate_ole2_file___2(char const   *filename___4 , int trunc ) ;
#line 119
static int generate_header___2(void) ;
#line 120
static int generate_recursive___2(MY_FILE *list ) ;
#line 121
static int generate_SDepot___2(void) ;
#line 122
static int generate_Root___2(void) ;
#line 123
static int generate_BDepot___2(void) ;
#line 124
static int generate_real_file___2(MY_FILE *MY_FILE_file ) ;
#line 125
static int write_block_list___2(unsigned int start_count , MY_FILE *list , int write_end_chain ) ;
#line 126
static int write_root_list___2(MY_FILE *list ) ;
#line 127
static void calculate_blocks___2(void) ;
#line 129
static unsigned int sum_block_list___2(MY_FILE *list ) ;
#line 132
static unsigned int sum_blocks_MY_FILE_list___2(MY_FILE *list ) ;
#line 134
static void ends___6(void) ;
#line 285 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_Root___2(pps_entry *pps_list___4 , unsigned int root ) 
{ 
  unsigned int pps_list_entries ;
  unsigned int i ;
  unsigned int tmp ;
  int retval ;

  {
  {
#line 293
  tmp = max_pps_referenced___2(pps_list___4, root);
#line 293
  pps_list_entries = 1U + tmp;
#line 296
  i = 0U;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < pps_list_entries)) {
#line 296
      goto while_break;
    }
    {
#line 297
    retval = add_entry_to_Root___2(pps_list___4 + i, 0U);
    }
#line 297
    if (retval) {
#line 297
      return (retval);
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max3___2(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) 
{ 
  unsigned int m ;

  {
#line 319
  m = 0U;
#line 323
  if (m > a) {
#line 323
    m = m;
  } else {
#line 323
    m = a;
  }
#line 324
  if (m > b) {
#line 324
    m = m;
  } else {
#line 324
    m = b;
  }
#line 325
  if (m > c) {
#line 325
    m = m;
  } else {
#line 325
    m = c;
  }
#line 326
  if (m > d) {
#line 326
    m = m;
  } else {
#line 326
    m = d;
  }
#line 327
  return (m);
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max_pps_referenced___2(pps_entry *pps_list___4 , unsigned int node ) 
{ 
  unsigned int max_pps ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 337
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
#line 337
    tmp = (pps_list___4 + node)->dir;
  } else {
#line 337
    tmp = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
#line 337
    tmp___0 = (pps_list___4 + node)->next;
  } else {
#line 337
    tmp___0 = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
#line 337
    tmp___1 = (pps_list___4 + node)->previous;
  } else {
#line 337
    tmp___1 = 0U;
  }
  {
#line 337
  max_pps = max3___2(node, tmp___1, tmp___0, tmp);
  }
#line 342
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
    {
#line 343
    tmp___4 = max_pps_referenced___2(pps_list___4, (pps_list___4 + node)->previous);
    }
#line 343
    if (max_pps > tmp___4) {
#line 343
      max_pps = max_pps;
    } else {
      {
#line 343
      tmp___3 = max_pps_referenced___2(pps_list___4, (pps_list___4 + node)->previous);
#line 343
      max_pps = tmp___3;
      }
    }
  }
#line 345
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
    {
#line 346
    tmp___7 = max_pps_referenced___2(pps_list___4, (pps_list___4 + node)->next);
    }
#line 346
    if (max_pps > tmp___7) {
#line 346
      max_pps = max_pps;
    } else {
      {
#line 346
      tmp___6 = max_pps_referenced___2(pps_list___4, (pps_list___4 + node)->next);
#line 346
      max_pps = tmp___6;
      }
    }
  }
#line 348
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
    {
#line 349
    tmp___10 = max_pps_referenced___2(pps_list___4, (pps_list___4 + node)->dir);
    }
#line 349
    if (max_pps > tmp___10) {
#line 349
      max_pps = max_pps;
    } else {
      {
#line 349
      tmp___9 = max_pps_referenced___2(pps_list___4, (pps_list___4 + node)->dir);
#line 349
      max_pps = tmp___9;
      }
    }
  }
#line 352
  return (max_pps);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_streams___2(pps_entry *pps_list___4 , pps_entry *node ) 
{ 
  unsigned int U32end_chain ;
  int retval ;
  int retval___0 ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;
  int retval___4 ;
  int retval___5 ;

  {
#line 359
  U32end_chain = 4294967294U;
#line 363
  if (! node->name[0]) {
#line 363
    return (12);
  }
  {
#line 366
  if ((int )node->type == 1) {
#line 366
    goto case_1;
  }
#line 374
  if ((int )node->type == 5) {
#line 374
    goto case_5;
  }
#line 385
  if ((int )node->type == 2) {
#line 385
    goto case_2;
  }
#line 399
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 368
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 369
    retval = process_streams___2(pps_list___4, pps_list___4 + node->dir);
    }
#line 369
    if (retval) {
#line 369
      return (retval);
    }
  }
#line 370
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 371
    retval___0 = process_streams___2(pps_list___4, pps_list___4 + node->next);
    }
#line 371
    if (retval___0) {
#line 371
      return (retval___0);
    }
  }
#line 372
  goto switch_break;
  case_5: /* CIL Label */ 
#line 375
  if (! ((int )*(Root___6->file.root_list + 66) == 5)) {
    {
#line 375
    __assert_fail("*(Root->file.root_list + 0x42) == 5", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  375U, "process_streams");
    }
  }
  {
#line 378
  fil_swriteU32(Root___6->file.root_list + 116, & U32end_chain);
  }
#line 379
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 380
    retval___1 = process_streams___2(pps_list___4, pps_list___4 + node->dir);
    }
#line 380
    if (retval___1) {
#line 380
      return (retval___1);
    }
  }
#line 381
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 382
    retval___2 = process_streams___2(pps_list___4, pps_list___4 + node->next);
    }
#line 382
    if (retval___2) {
#line 382
      return (retval___2);
    }
  }
#line 383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 386
  if (! ((unsigned long )node->dir == 4294967295UL)) {
#line 386
    return (12);
  }
#line 387
  if (node->size < 4096U) {
    {
#line 389
    retval___3 = add_stream_to_sbfile_and_SDepot___2(node->size, node->filename, node->ppsnumber);
    }
#line 389
    if (retval___3) {
#line 389
      return (retval___3);
    }
  } else {
    {
#line 393
    retval___4 = add_stream_to_Input_and_BDepot___2(node->size, node->filename, node->ppsnumber);
    }
#line 393
    if (retval___4) {
#line 393
      return (retval___4);
    }
  }
#line 395
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 396
    retval___5 = process_streams___2(pps_list___4, pps_list___4 + node->next);
    }
#line 396
    if (retval___5) {
#line 396
      return (retval___5);
    }
  }
#line 397
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 400
  return (12);
  switch_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_entry_to_Root___2(pps_entry *node , unsigned int start_block ) 
{ 
  unsigned int entry_number ;
  unsigned char *new_entry_Root ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 416
  entry_number = add_MY_FILE_entry___2(Root___6, 0U);
  }
#line 417
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 417
    return (10);
  }
  {
#line 418
  new_entry_Root = Root___6->file.root_list + entry_number * 128U;
#line 421
  pps2root___2((unsigned char *)new_entry_Root, node, start_block);
  }
#line 424
  if (! Root___6->size) {
#line 424
    *(Root___6->blocks) = 1U;
  } else {
#line 424
    *(Root___6->blocks) = 1U + (Root___6->size - 1U) / 512U;
  }
  {
#line 428
  tmp___1 = sum_block_list___2(BDepot___6);
  }
#line 428
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 428
    tmp___0 = sum_block_list___2(BDepot___6);
#line 428
    *(BDepot___6->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 428
    *(BDepot___6->blocks) = 1U;
  }
#line 430
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_sbfile_and_SDepot___2(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  unsigned int *new_entry_SDepot ;
  MY_FILE *new_entry_sbfile ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 447
  entry_number = add_MY_FILE_entry___2(SDepot___6, size);
  }
#line 448
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 448
    return (10);
  }
  {
#line 449
  new_entry_SDepot = SDepot___6->file.block_list + entry_number;
#line 451
  entry_number = add_MY_FILE_entry___2(sbfile___6, size);
  }
#line 452
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 452
    return (10);
  }
#line 453
  new_entry_sbfile = sbfile___6->file.MY_FILE_list + entry_number;
#line 458
  if (! size) {
#line 458
    *new_entry_SDepot = 1U;
  } else {
#line 458
    *new_entry_SDepot = 1U + (size - 1U) / 64U;
  }
  {
#line 461
  tmp___1 = sum_block_list___2(SDepot___6);
  }
#line 461
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 461
    tmp___0 = sum_block_list___2(SDepot___6);
#line 461
    *(SDepot___6->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 461
    *(SDepot___6->blocks) = 1U;
  }
  {
#line 468
  new_entry_sbfile->type = (enum __anonenum_type_26 )0;
#line 468
  new_entry_sbfile->size = size;
#line 468
  new_entry_sbfile->blocks = new_entry_SDepot;
#line 468
  new_entry_sbfile->file.real.name = name;
#line 468
  new_entry_sbfile->file.real.ppsnumber = ppsnumber;
#line 472
  tmp___4 = sum_blocks_MY_FILE_list___2(sbfile___6);
  }
#line 472
  if (tmp___4 * 64U) {
    {
#line 472
    tmp___3 = sum_blocks_MY_FILE_list___2(sbfile___6);
#line 472
    *(sbfile___6->blocks) = 1U + (tmp___3 * 64U - 1U) / 512U;
    }
  } else {
#line 472
    *(sbfile___6->blocks) = 1U;
  }
  {
#line 477
  tmp___7 = sum_block_list___2(BDepot___6);
  }
#line 477
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 477
    tmp___6 = sum_block_list___2(BDepot___6);
#line 477
    *(BDepot___6->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___6 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 477
    *(BDepot___6->blocks) = 1U;
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_Input_and_BDepot___2(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  MY_FILE *new_entry_Input ;
  unsigned int *new_entry_BDepot ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 496
  entry_number = add_MY_FILE_entry___2(BDepot___6, size);
  }
#line 497
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 497
    return (10);
  }
  {
#line 498
  new_entry_BDepot = BDepot___6->file.block_list + entry_number;
#line 500
  entry_number = add_MY_FILE_entry___2(& Input___2, size);
  }
#line 501
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 501
    return (10);
  }
#line 502
  new_entry_Input = Input___2.file.MY_FILE_list + entry_number;
#line 507
  if (! size) {
#line 507
    *new_entry_BDepot = 1U;
  } else {
#line 507
    *new_entry_BDepot = 1U + (size - 1U) / 512U;
  }
  {
#line 510
  tmp___1 = sum_block_list___2(BDepot___6);
  }
#line 510
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 510
    tmp___0 = sum_block_list___2(BDepot___6);
#line 510
    *(BDepot___6->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 510
    *(BDepot___6->blocks) = 1U;
  }
  {
#line 517
  new_entry_Input->type = (enum __anonenum_type_26 )0;
#line 517
  new_entry_Input->size = size;
#line 517
  new_entry_Input->blocks = new_entry_BDepot;
#line 517
  new_entry_Input->file.real.name = name;
#line 517
  new_entry_Input->file.real.ppsnumber = ppsnumber;
#line 524
  tmp___4 = sum_block_list___2(BDepot___6);
  }
#line 524
  if ((unsigned long )tmp___4 * sizeof(unsigned int )) {
    {
#line 524
    tmp___3 = sum_block_list___2(BDepot___6);
#line 524
    *(BDepot___6->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___3 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 524
    *(BDepot___6->blocks) = 1U;
  }
#line 526
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int add_MY_FILE_entry___2(MY_FILE *list , unsigned int size ) 
{ 
  MY_FILE *new_MY_FILE_list ;
  unsigned int new_entry ;
  void *tmp ;
  unsigned int *new_block_list ;
  unsigned int new_entry___0 ;
  void *tmp___0 ;
  unsigned int new_entry___1 ;
  unsigned char *new_root_list ;
  void *tmp___1 ;

  {
#line 574
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 574
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  574U, "add_MY_FILE_entry");
    }
  }
  {
#line 581
  if ((unsigned int )list->type == 1U) {
#line 581
    goto case_1;
  }
#line 599
  if ((unsigned int )list->type == 2U) {
#line 599
    goto case_2;
  }
#line 616
  if ((unsigned int )list->type == 3U) {
#line 616
    goto case_3;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 585
  if (! ((unsigned long )list == (unsigned long )sbfile___6)) {
#line 585
    if (! ((unsigned long )list == (unsigned long )(& Input___2))) {
      {
#line 585
      __assert_fail("list == sbfile || list == &Input", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    585U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 587
  list->size = (unsigned int )((unsigned long )list->size + sizeof(MY_FILE ));
#line 588
  tmp = realloc((void *)list->file.MY_FILE_list, (size_t )list->size);
#line 588
  new_MY_FILE_list = (MY_FILE *)tmp;
#line 589
  list->file.MY_FILE_list = new_MY_FILE_list;
  }
#line 590
  if (! ((unsigned long )new_MY_FILE_list != (unsigned long )((void *)0))) {
#line 590
    return (4294967295U);
  }
  {
#line 591
  new_entry = (unsigned int )((unsigned long )list->size / sizeof(MY_FILE ) - 1UL);
#line 592
  reset_links_in_Input___2();
#line 592
  reset_links_in_BDepot___2();
#line 592
  reset_links_in_SDepot___2();
  }
#line 594
  return (new_entry);
  case_2: /* CIL Label */ 
#line 603
  if (! ((unsigned long )list == (unsigned long )SDepot___6)) {
#line 603
    if (! ((unsigned long )list == (unsigned long )BDepot___6)) {
      {
#line 603
      __assert_fail("list == SDepot || list == BDepot", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    603U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 605
  list->size = (unsigned int )((unsigned long )list->size + sizeof(unsigned int ));
#line 606
  tmp___0 = realloc((void *)list->file.block_list, (size_t )list->size);
#line 606
  new_block_list = (unsigned int *)tmp___0;
#line 607
  list->file.block_list = new_block_list;
  }
#line 608
  if (! ((unsigned long )new_block_list != (unsigned long )((void *)0))) {
#line 608
    return (4294967295U);
  }
  {
#line 609
  new_entry___0 = (unsigned int )((unsigned long )list->size / sizeof(unsigned int ) - 1UL);
#line 610
  reset_links_in_Input___2();
#line 610
  reset_links_in_BDepot___2();
#line 610
  reset_links_in_SDepot___2();
  }
#line 612
  return (new_entry___0);
  case_3: /* CIL Label */ 
#line 620
  if (! ((unsigned long )list == (unsigned long )Root___6)) {
    {
#line 620
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  620U, "add_MY_FILE_entry");
    }
  }
  {
#line 622
  list->size += 128U;
#line 623
  tmp___1 = realloc((void *)list->file.root_list, (size_t )list->size);
#line 623
  new_root_list = (unsigned char *)tmp___1;
#line 624
  list->file.root_list = new_root_list;
  }
#line 625
  if (! ((unsigned long )new_root_list != (unsigned long )((void *)0))) {
#line 625
    return (4294967295U);
  }
  {
#line 626
  new_entry___1 = list->size / 128U - 1U;
#line 627
  reset_links_in_Input___2();
#line 627
  reset_links_in_BDepot___2();
#line 627
  reset_links_in_SDepot___2();
  }
#line 629
  return (new_entry___1);
  switch_default: /* CIL Label */ ;
#line 640
  if (! ((unsigned long )"list->type UNKNOWN in add_MY_FILE_entry" == (unsigned long )((void *)0))) {
    {
#line 640
    __assert_fail("\"list->type UNKNOWN in add_MY_FILE_entry\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  640U, "add_MY_FILE_entry");
    }
  }
#line 641
  return (0U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int pps2root___2(unsigned char *pps , pps_entry *node , unsigned int start_block ) 
{ 
  unsigned short i ;
  unsigned short size_of_name ;
  unsigned char U8magiczero ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 653
  U8magiczero = (unsigned char)0;
#line 654
  U32magiczero = 0U;
#line 655
  U32magic1 = 133376U;
#line 656
  U32magic2 = 1174405120U;
#line 663
  if (! (node->ppsnumber == (unsigned int )(pps - (unsigned char *)Root___6->file.root_list) / 128U)) {
    {
#line 663
    __assert_fail("node->ppsnumber == (unsigned int)(pps - Root->file.root_list)/0x80",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  663U, "pps2root");
    }
  }
  {
#line 665
  memset((void *)pps, 255, (size_t )128);
#line 668
  tmp = strlen((char const   *)(node->name));
#line 668
  size_of_name = (unsigned short )(2UL * (tmp + 1UL));
#line 670
  i = (unsigned short)0;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! ((int )i < (int )size_of_name)) {
#line 670
      goto while_break;
    }
#line 671
    if ((int )i % 2) {
#line 671
      tmp___0 = 0;
    } else {
#line 671
      tmp___0 = (int )*(node->name + (int )i / 2);
    }
#line 671
    *(pps + (int )i) = (unsigned char )tmp___0;
#line 670
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  fil_swriteU16((unsigned char *)(pps + 64), & size_of_name);
#line 675
  *(pps + 66) = node->type;
#line 676
  fil_swriteU32((unsigned char *)(pps + 68), & node->previous);
#line 677
  fil_swriteU32((unsigned char *)(pps + 72), & node->next);
#line 678
  fil_swriteU32((unsigned char *)(pps + 76), & node->dir);
#line 679
  fil_swriteU32((unsigned char *)(pps + 100), & node->seconds1);
#line 680
  fil_swriteU32((unsigned char *)(pps + 104), & node->days1);
#line 681
  fil_swriteU32((unsigned char *)(pps + 108), & node->seconds2);
#line 682
  fil_swriteU32((unsigned char *)(pps + 112), & node->days1);
#line 683
  fil_swriteU32((unsigned char *)(pps + 116), & start_block);
#line 684
  fil_swriteU32((unsigned char *)(pps + 120), & node->size);
#line 687
  *(pps + 67) = U8magiczero;
#line 688
  fil_swriteU32((unsigned char *)(pps + 80), & U32magic1);
#line 689
  fil_swriteU32((unsigned char *)(pps + 84), & U32magiczero);
#line 690
  fil_swriteU32((unsigned char *)(pps + 88), & U32magiczero);
#line 691
  fil_swriteU32((unsigned char *)(pps + 92), & U32magic2);
#line 692
  fil_swriteU32((unsigned char *)(pps + 96), & U32magiczero);
#line 693
  fil_swriteU32((unsigned char *)(pps + 124), & U32magiczero);
  }
#line 697
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_block_list___2(MY_FILE *list ) 
{ 
  unsigned int sum ;
  unsigned int *block ;

  {
#line 702
  sum = 0U;
#line 707
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 707
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  707U, "sum_block_list");
    }
  }
#line 708
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 708
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  708U, "sum_block_list");
    }
  }
#line 709
  block = list->file.block_list;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned int )((unsigned char *)block - (unsigned char *)list->file.block_list) < list->size)) {
#line 709
      goto while_break;
    }
#line 712
    sum += *block;
#line 709
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return (sum);
}
}
#line 738 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_blocks_MY_FILE_list___2(MY_FILE *list ) 
{ 
  unsigned int sum ;
  MY_FILE *file ;

  {
#line 740
  sum = 0U;
#line 745
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 745
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  745U, "sum_blocks_MY_FILE_list");
    }
  }
#line 746
  if (! ((unsigned int )list->type == 1U)) {
    {
#line 746
    __assert_fail("list->type == MY_FILE_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  746U, "sum_blocks_MY_FILE_list");
    }
  }
#line 747
  file = list->file.MY_FILE_list;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )((unsigned char *)file - (unsigned char *)list->file.MY_FILE_list) < list->size)) {
#line 747
      goto while_break;
    }
#line 750
    if ((unsigned long )file->blocks != (unsigned long )((void *)0)) {
#line 751
      sum += *(file->blocks);
    }
#line 747
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (sum);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_Input___2(void) 
{ 


  {
#line 759
  sbfile___6 = Input___2.file.MY_FILE_list + 4;
#line 760
  SDepot___6 = Input___2.file.MY_FILE_list + 3;
#line 761
  BDepot___6 = Input___2.file.MY_FILE_list + 1;
#line 762
  bbd_list___2 = Input___2.file.MY_FILE_list;
#line 763
  Root___6 = Input___2.file.MY_FILE_list + 2;
#line 764
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_BDepot___2(void) 
{ 
  unsigned int i ;

  {
#line 772
  sbfile___6->blocks = BDepot___6->file.block_list;
#line 773
  SDepot___6->blocks = BDepot___6->file.block_list + 1;
#line 774
  Root___6->blocks = BDepot___6->file.block_list + 2;
#line 777
  i = 0U;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )i < (unsigned long )Input___2.size / sizeof(MY_FILE ) - 5UL)) {
#line 777
      goto while_break;
    }
#line 778
    (Input___2.file.MY_FILE_list + (i + 5U))->blocks = (BDepot___6->file.block_list + i) + 3;
#line 777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_SDepot___2(void) 
{ 
  unsigned int i ;

  {
#line 788
  i = 0U;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! ((unsigned long )i < (unsigned long )sbfile___6->size / sizeof(MY_FILE ))) {
#line 788
      goto while_break;
    }
#line 789
    (sbfile___6->file.MY_FILE_list + i)->blocks = SDepot___6->file.block_list + i;
#line 788
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_ole2_file___2(char const   *filename___4 , int trunc ) 
{ 
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;

  {
#line 796
  if (! trunc) {
    {
#line 798
    output_file___2 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"r");
    }
#line 799
    if (! ((unsigned long )output_file___2 == (unsigned long )((void *)0))) {
      {
#line 799
      ends___6();
      }
#line 799
      return (2);
    }
  }
  {
#line 801
  output_file___2 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"wb");
  }
#line 802
  if (! ((unsigned long )output_file___2 != (unsigned long )((void *)0))) {
    {
#line 802
    ends___6();
    }
#line 802
    return (3);
  }
  {
#line 804
  retval = generate_header___2();
  }
#line 804
  if (retval) {
#line 804
    return (retval);
  }
  {
#line 805
  retval___0 = generate_recursive___2(& Input___2);
  }
#line 805
  if (retval___0) {
#line 805
    return (retval___0);
  }
#line 809
  if ((int )pos_block___2 != 0) {
#line 809
    if ((int )pos_block___2 % 512) {
      {
#line 809
      memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 512 + 1) * 512 - (int )pos_block___2));
      }
    }
    {
#line 809
    tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___2);
    }
#line 809
    if (! (tmp == 512UL)) {
#line 809
      return (1);
    }
#line 809
    next_block___2 ++;
#line 809
    pos_block___2 = (unsigned short)0;
  }
  {
#line 810
  retval___1 = generate_SDepot___2();
  }
#line 810
  if (retval___1) {
#line 810
    return (retval___1);
  }
  {
#line 811
  retval___2 = generate_Root___2();
  }
#line 811
  if (retval___2) {
#line 811
    return (retval___2);
  }
  {
#line 812
  retval___3 = generate_BDepot___2();
  }
#line 812
  if (retval___3) {
#line 812
    return (retval___3);
  }
  {
#line 814
  fclose(output_file___2);
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_header___2(void) 
{ 
  unsigned int identifier1 ;
  unsigned int identifier2 ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  unsigned int U32magic3 ;
  unsigned int U32magic4 ;
  unsigned int U32magic5 ;
  unsigned int U32magic6 ;

  {
  {
#line 821
  identifier1 = 3759263696U;
#line 822
  identifier2 = 3776623009U;
#line 823
  U32magiczero = 0U;
#line 824
  U32magic1 = 196667U;
#line 825
  U32magic2 = 655358U;
#line 826
  U32magic3 = 6U;
#line 827
  U32magic4 = 4096U;
#line 828
  U32magic5 = 1U;
#line 829
  U32magic6 = 4294967294U;
#line 833
  calculate_blocks___2();
#line 835
  fil_swriteU32(output_block___2 + 48, & Root_start_block___2);
#line 836
  fil_swriteU32(output_block___2 + 60, & SDepot_start_block___2);
#line 837
  fil_swriteU32(output_block___2 + 44, & BDepot_blocks___2);
#line 839
  fil_swriteU32(output_block___2 + 0, & identifier1);
#line 840
  fil_swriteU32(output_block___2 + 4, & identifier2);
#line 841
  fil_swriteU32(output_block___2 + 8, & U32magiczero);
#line 842
  fil_swriteU32(output_block___2 + 12, & U32magiczero);
#line 843
  fil_swriteU32(output_block___2 + 16, & U32magiczero);
#line 844
  fil_swriteU32(output_block___2 + 20, & U32magiczero);
#line 845
  fil_swriteU32(output_block___2 + 24, & U32magic1);
#line 846
  fil_swriteU32(output_block___2 + 28, & U32magic2);
#line 847
  fil_swriteU32(output_block___2 + 32, & U32magic3);
#line 848
  fil_swriteU32(output_block___2 + 36, & U32magiczero);
#line 849
  fil_swriteU32(output_block___2 + 40, & U32magiczero);
#line 850
  fil_swriteU32(output_block___2 + 52, & U32magiczero);
#line 851
  fil_swriteU32(output_block___2 + 56, & U32magic4);
#line 852
  fil_swriteU32(output_block___2 + 64, & U32magic5);
#line 853
  fil_swriteU32(output_block___2 + 68, & U32magic6);
#line 854
  fil_swriteU32(output_block___2 + 72, & U32magiczero);
#line 856
  pos_block___2 = (unsigned short)76;
  }
#line 858
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_recursive___2(MY_FILE *list ) 
{ 
  MY_FILE *p_MY_FILE_list ;
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;

  {
  {
#line 873
  if ((unsigned int )list->type == 1U) {
#line 873
    goto case_1;
  }
#line 881
  if ((unsigned int )list->type == 2U) {
#line 881
    goto case_2;
  }
#line 898
  if ((unsigned int )list->type == 3U) {
#line 898
    goto case_3;
  }
#line 903
  if ((unsigned int )list->type == 0U) {
#line 903
    goto case_0;
  }
#line 908
  goto switch_default;
  case_1: /* CIL Label */ 
#line 874
  p_MY_FILE_list = list->file.MY_FILE_list;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! ((unsigned int )((unsigned char *)p_MY_FILE_list - list->file.root_list) < list->size)) {
#line 874
      goto while_break;
    }
    {
#line 877
    retval = generate_recursive___2(p_MY_FILE_list);
    }
#line 877
    if (retval) {
#line 877
      return (retval);
    }
#line 874
    p_MY_FILE_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  goto switch_break;
  case_2: /* CIL Label */ 
#line 882
  if ((unsigned long )list == (unsigned long )bbd_list___2) {
    {
#line 884
    retval___0 = write_block_list___2(BDepot_start_block___2, bbd_list___2, 0);
    }
#line 884
    if (retval___0) {
#line 884
      return (retval___0);
    }
#line 885
    if ((int )pos_block___2 != 0) {
#line 885
      if ((int )pos_block___2 % 512) {
        {
#line 885
        memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 512 + 1) * 512 - (int )pos_block___2));
        }
      }
      {
#line 885
      tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                   (size_t )512, (FILE */* __restrict  */)output_file___2);
      }
#line 885
      if (! (tmp == 512UL)) {
#line 885
        return (1);
      }
#line 885
      next_block___2 ++;
#line 885
      pos_block___2 = (unsigned short)0;
    }
#line 886
    goto switch_break;
  } else
#line 888
  if ((unsigned long )list == (unsigned long )BDepot___6) {
#line 890
    goto switch_break;
  } else
#line 891
  if ((unsigned long )list == (unsigned long )SDepot___6) {
#line 893
    goto switch_break;
  } else
#line 895
  if (! ((unsigned long )"list->type==block_list but list UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 895
    __assert_fail("\"list->type==block_list but list UNKNOWN in generate_recursive\"==((void *)0)",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  895U, "generate_recursive");
    }
  }
  case_3: /* CIL Label */ 
#line 900
  if (! ((unsigned long )list == (unsigned long )Root___6)) {
    {
#line 900
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  900U, "generate_recursive");
    }
  }
#line 901
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 905
  retval___1 = generate_real_file___2(list);
  }
#line 905
  if (retval___1) {
#line 905
    return (retval___1);
  }
#line 906
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 909
  if (! ((unsigned long )"list->type UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 909
    __assert_fail("\"list->type UNKNOWN in generate_recursive\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  909U, "generate_recursive");
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 912
  return (0);
}
}
#line 916 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_SDepot___2(void) 
{ 
  int retval ;
  size_t tmp ;

  {
  {
#line 920
  retval = write_block_list___2(1U, SDepot___6, 1);
  }
#line 920
  if (retval) {
#line 920
    return (retval);
  }
#line 921
  if ((int )pos_block___2 != 0) {
#line 921
    if ((int )pos_block___2 % 512) {
      {
#line 921
      memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 512 + 1) * 512 - (int )pos_block___2));
      }
    }
    {
#line 921
    tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___2);
    }
#line 921
    if (! (tmp == 512UL)) {
#line 921
      return (1);
    }
#line 921
    next_block___2 ++;
#line 921
    pos_block___2 = (unsigned short)0;
  }
#line 923
  return (0);
}
}
#line 927 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_Root___2(void) 
{ 
  int retval ;
  int zzzi ;
  unsigned short U16zero ;
  size_t tmp ;

  {
  {
#line 931
  retval = write_root_list___2(Root___6);
  }
#line 931
  if (retval) {
#line 931
    return (retval);
  }
#line 932
  if ((int )pos_block___2 != 0) {
    {
#line 932
    U16zero = (unsigned short)0;
#line 932
    memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(512 - (int )pos_block___2));
#line 932
    zzzi = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 932
      if (! (zzzi < 4)) {
#line 932
        goto while_break;
      }
#line 932
      if (zzzi * 128 >= (int )pos_block___2) {
        {
#line 932
        fil_swriteU16((output_block___2 + zzzi * 128) + 64, & U16zero);
        }
      }
#line 932
      zzzi ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 933
  if ((int )pos_block___2 != 0) {
    {
#line 933
    tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___2);
    }
#line 933
    if (! (tmp == 512UL)) {
#line 933
      return (1);
    }
#line 933
    next_block___2 ++;
#line 933
    pos_block___2 = (unsigned short)0;
  }
#line 935
  return (0);
}
}
#line 938 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_BDepot___2(void) 
{ 
  MY_FILE SDepot_and_Root_block_list ;
  MY_FILE file_block_list ;
  unsigned int next_block_link ;
  int retval ;
  int retval___0 ;
  unsigned int tmp ;
  int retval___1 ;
  size_t tmp___0 ;

  {
#line 946
  next_block_link = (unsigned int )((4294967295UL + (unsigned long )header_blocks___2) + 1UL);
#line 950
  if (! (next_block_link == sbfile_start_block___2 + 1U)) {
    {
#line 950
    __assert_fail("next_block_link == sbfile_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  950U, "generate_BDepot");
    }
  }
  {
#line 952
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 952
  file_block_list.size = (unsigned int )sizeof(unsigned int );
#line 952
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 952
  file_block_list.file.block_list = BDepot___6->file.block_list;
#line 955
  retval = write_block_list___2(next_block_link, & file_block_list, 1);
  }
#line 955
  if (retval) {
#line 955
    return (retval);
  }
#line 958
  next_block_link += sbfile_blocks___2;
#line 961
  if (! (next_block_link == (sbfile_start_block___2 + sbfile_blocks___2) + 1U)) {
    {
#line 961
    __assert_fail("next_block_link == sbfile_start_block + sbfile_blocks + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  961U, "generate_BDepot");
    }
  }
  {
#line 963
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 963
  file_block_list.size = (unsigned int )((unsigned long )BDepot___6->size - 3UL * sizeof(unsigned int ));
#line 963
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 963
  file_block_list.file.block_list = BDepot___6->file.block_list + 3;
#line 965
  retval___0 = write_block_list___2(next_block_link, & file_block_list, 1);
  }
#line 965
  if (retval___0) {
#line 965
    return (retval___0);
  }
  {
#line 968
  tmp = sum_block_list___2(& file_block_list);
#line 968
  next_block_link += tmp;
  }
#line 971
  if (sbfile___6->size > 0U) {
#line 973
    if (! (next_block_link == SDepot_start_block___2 + 1U)) {
      {
#line 973
      __assert_fail("next_block_link == SDepot_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    973U, "generate_BDepot");
      }
    }
  }
  {
#line 975
  SDepot_and_Root_block_list.type = (enum __anonenum_type_26 )2;
#line 975
  SDepot_and_Root_block_list.size = (unsigned int )(2UL * sizeof(unsigned int ));
#line 975
  SDepot_and_Root_block_list.blocks = (unsigned int *)((void *)0);
#line 975
  SDepot_and_Root_block_list.file.block_list = BDepot___6->file.block_list + 1;
#line 977
  retval___1 = write_block_list___2(next_block_link, & SDepot_and_Root_block_list,
                                    1);
  }
#line 977
  if (retval___1) {
#line 977
    return (retval___1);
  }
#line 980
  if ((int )pos_block___2 != 0) {
#line 980
    if ((int )pos_block___2 % 512) {
      {
#line 980
      memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 512 + 1) * 512 - (int )pos_block___2));
      }
    }
    {
#line 980
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___2);
    }
#line 980
    if (! (tmp___0 == 512UL)) {
#line 980
      return (1);
    }
#line 980
    next_block___2 ++;
#line 980
    pos_block___2 = (unsigned short)0;
  }
#line 982
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int last_small_stream_next_block___2  =    0U;
#line 993 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_start_block_set___2  =    0;
#line 994 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_may_need_write_until_boundary___2  =    0;
#line 985 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_real_file___2(MY_FILE *MY_FILE_file ) 
{ 
  FILE *file ;
  int n_read ;
  unsigned char *pps ;
  unsigned int total_bytes ;
  unsigned int sbfile_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 1004
  if (! ((int )pos_block___2 <= 512)) {
    {
#line 1004
    __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1004U, "generate_real_file");
    }
  }
#line 1005
  if (! ((int )pos_block___2 % 64 == 0)) {
    {
#line 1005
    __assert_fail("pos_block % 0x40 == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1005U, "generate_real_file");
    }
  }
#line 1008
  if (! *(MY_FILE_file->file.real.name + 0)) {
    {
#line 1008
    __assert_fail("MY_FILE_file->file.real.name[0]", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1008U, "generate_real_file");
    }
  }
  {
#line 1009
  file = fopen((char const   */* __restrict  */)MY_FILE_file->file.real.name, (char const   */* __restrict  */)"rb");
  }
#line 1010
  if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 1010
    return (11);
  }
#line 1013
  if (MY_FILE_file->size >= 4096U) {
#line 1018
    if (sbfile_may_need_write_until_boundary___2) {
#line 1022
      if ((int )pos_block___2 != 0) {
#line 1022
        if ((int )pos_block___2 % 512) {
          {
#line 1022
          memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 512 + 1) * 512 - (int )pos_block___2));
          }
        }
        {
#line 1022
        tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___2);
        }
#line 1022
        if (! (tmp == 512UL)) {
#line 1022
          return (1);
        }
#line 1022
        next_block___2 ++;
#line 1022
        pos_block___2 = (unsigned short)0;
      }
#line 1023
      sbfile_may_need_write_until_boundary___2 = 0;
    }
    {
#line 1029
    pps = Root___6->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1030
    fil_swriteU32(pps + 116, & next_block___2);
    }
  } else {
    {
#line 1039
    pps = Root___6->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1040
    fil_swriteU32(pps + 116, & last_small_stream_next_block___2);
#line 1041
    last_small_stream_next_block___2 += *(MY_FILE_file->blocks);
    }
#line 1044
    if (! sbfile_start_block_set___2) {
#line 1050
      if (! (sbfile_start_block___2 == next_block___2)) {
        {
#line 1050
        __assert_fail("sbfile_start_block == next_block", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1050U, "generate_real_file");
        }
      }
      {
#line 1051
      fil_swriteU32(Root___6->file.root_list + 116, & next_block___2);
#line 1053
      tmp___0 = sum_blocks_MY_FILE_list___2(sbfile___6);
#line 1053
      sbfile_size = tmp___0 * 64U;
#line 1056
      tmp___1 = fil_sreadU32(Root___6->file.root_list + 120);
      }
#line 1056
      if (! (sbfile_size == tmp___1)) {
        {
#line 1056
        __assert_fail("sbfile_size == fil_sreadU32 (Root->file.root_list + 0x78)",
                      "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1056U, "generate_real_file");
        }
      }
#line 1058
      sbfile_start_block_set___2 = 1;
#line 1059
      sbfile_may_need_write_until_boundary___2 = 1;
    }
  }
#line 1064
  total_bytes = 0U;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1066
    tmp___6 = feof(file);
    }
#line 1066
    if (tmp___6) {
#line 1066
      goto while_break;
    }
    {
#line 1068
    tmp___2 = fread((void */* __restrict  */)(output_block___2 + (int )pos_block___2),
                    (size_t )1, (size_t )(512 - (int )pos_block___2), (FILE */* __restrict  */)file);
#line 1068
    n_read = (int )tmp___2;
#line 1069
    tmp___3 = ferror(file);
    }
#line 1069
    if (tmp___3) {
#line 1069
      return (11);
    }
#line 1070
    if (n_read < 512 - (int )pos_block___2) {
      {
#line 1072
      tmp___4 = feof(file);
      }
#line 1072
      if (! tmp___4) {
        {
#line 1072
        __assert_fail("feof (file)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1072U, "generate_real_file");
        }
      }
    }
#line 1073
    pos_block___2 = (unsigned short )((int )pos_block___2 + (int )((unsigned short )n_read));
#line 1074
    total_bytes += (unsigned int )n_read;
#line 1075
    if ((int )pos_block___2 == 512) {
      {
#line 1075
      tmp___5 = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )512,
                       (size_t )1, (FILE */* __restrict  */)output_file___2);
      }
#line 1075
      if (! (tmp___5 == 1UL)) {
#line 1075
        return (1);
      }
#line 1075
      next_block___2 ++;
#line 1075
      pos_block___2 = (unsigned short)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (! (total_bytes == MY_FILE_file->size)) {
#line 1077
    return (12);
  }
#line 1079
  if (MY_FILE_file->size >= 4096U) {
#line 1081
    if ((int )pos_block___2 != 0) {
#line 1081
      if ((int )pos_block___2 % 512) {
        {
#line 1081
        memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 512 + 1) * 512 - (int )pos_block___2));
        }
      }
      {
#line 1081
      tmp___7 = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )1,
                       (size_t )512, (FILE */* __restrict  */)output_file___2);
      }
#line 1081
      if (! (tmp___7 == 512UL)) {
#line 1081
        return (1);
      }
#line 1081
      next_block___2 ++;
#line 1081
      pos_block___2 = (unsigned short)0;
    }
  } else
#line 1084
  if ((int )pos_block___2 % 64) {
    {
#line 1084
    memset((void *)(output_block___2 + (int )pos_block___2), 255, (size_t )(((int )pos_block___2 / 64 + 1) * 64 - (int )pos_block___2));
    }
#line 1084
    if (! (((int )pos_block___2 + ((int )pos_block___2 / 64 + 1) * 64) - (int )pos_block___2 == ((int )pos_block___2 / 64 + 1) * 64)) {
      {
#line 1084
      __assert_fail("pos_block+(pos_block/0x40 + 1)*0x40 - pos_block == (pos_block/0x40 + 1)*0x40",
                    "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1084U, "generate_real_file");
      }
    }
#line 1084
    pos_block___2 = (unsigned short )((int )pos_block___2 + (int )((unsigned short )(((int )pos_block___2 / 64 + 1) * 64 - (int )pos_block___2)));
  }
  {
#line 1087
  fclose(file);
  }
#line 1089
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_block_list___2(unsigned int start_count , MY_FILE *list , int write_end_chain ) 
{ 
  unsigned int *p ;
  unsigned int n ;
  unsigned int end_chain ;
  unsigned int value_to_write ;
  unsigned int delta ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1098
  end_chain = 4294967294U;
#line 1104
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 1104
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1104U, "write_block_list");
    }
  }
#line 1105
  if (! ((int )pos_block___2 <= 508)) {
    {
#line 1105
    __assert_fail("pos_block <= 0x01fc", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1105U, "write_block_list");
    }
  }
#line 1107
  delta = start_count;
#line 1108
  if (list->size == 0U) {
#line 1108
    return (0);
  }
#line 1109
  p = list->file.block_list;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! ((unsigned int )((unsigned char *)p - (unsigned char *)list->file.block_list) < list->size)) {
#line 1109
      goto while_break;
    }
#line 1112
    n = 0U;
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1112
      if (! (n < *p)) {
#line 1112
        goto while_break___0;
      }
#line 1115
      if ((int )pos_block___2 == 512) {
        {
#line 1115
        tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___2);
        }
#line 1115
        if (! (tmp == 1UL)) {
#line 1115
          return (1);
        }
#line 1115
        next_block___2 ++;
#line 1115
        pos_block___2 = (unsigned short)0;
      }
#line 1118
      if (write_end_chain) {
#line 1118
        if (! (n + 1U < *p)) {
#line 1119
          value_to_write = end_chain;
        } else {
#line 1121
          value_to_write = n + delta;
        }
      } else {
#line 1121
        value_to_write = n + delta;
      }
      {
#line 1122
      fil_swriteU32(output_block___2 + (int )pos_block___2, & value_to_write);
#line 1123
      pos_block___2 = (unsigned short )((int )pos_block___2 + (int )((unsigned short )sizeof(unsigned int )));
      }
#line 1124
      if (! ((int )pos_block___2 <= 512)) {
        {
#line 1124
        __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1124U, "write_block_list");
        }
      }
#line 1112
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1126
    delta += n;
#line 1109
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1128
  if ((int )pos_block___2 == 512) {
    {
#line 1128
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___2);
    }
#line 1128
    if (! (tmp___0 == 1UL)) {
#line 1128
      return (1);
    }
#line 1128
    next_block___2 ++;
#line 1128
    pos_block___2 = (unsigned short)0;
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_root_list___2(MY_FILE *list ) 
{ 
  unsigned char *p ;
  size_t tmp ;

  {
#line 1139
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1139
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1139U, "write_root_list");
    }
  }
#line 1140
  if (! ((int )pos_block___2 == 0)) {
    {
#line 1140
    __assert_fail("pos_block == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1140U, "write_root_list");
    }
  }
#line 1141
  if (! ((unsigned int )list->type == 3U)) {
    {
#line 1141
    __assert_fail("list->type == root_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1141U, "write_root_list");
    }
  }
#line 1142
  if (! (list->size > 0U)) {
    {
#line 1142
    __assert_fail("list->size > 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1142U, "write_root_list");
    }
  }
#line 1144
  p = list->file.root_list;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (! ((unsigned int )(p - list->file.root_list) < list->size)) {
#line 1144
      goto while_break;
    }
    {
#line 1147
    memcpy((void */* __restrict  */)(output_block___2 + (p - list->file.root_list) % 512L),
           (void const   */* __restrict  */)p, (size_t )128);
#line 1169
    pos_block___2 = (unsigned short )((int )pos_block___2 + 128);
    }
#line 1170
    if (! ((int )pos_block___2 <= 512)) {
      {
#line 1170
      __assert_fail("pos_block <= (unsigned short)0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1170U, "write_root_list");
      }
    }
#line 1171
    if ((int )pos_block___2 == 512) {
      {
#line 1171
      tmp = fwrite((void const   */* __restrict  */)(output_block___2), (size_t )512,
                   (size_t )1, (FILE */* __restrict  */)output_file___2);
      }
#line 1171
      if (! (tmp == 1UL)) {
#line 1171
        return (1);
      }
#line 1171
      next_block___2 ++;
#line 1171
      pos_block___2 = (unsigned short)0;
    }
#line 1144
    p += 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void ends___6(void) 
{ 


  {
#line 1193
  if ((unsigned long )output_file___2 != (unsigned long )((void *)0)) {
    {
#line 1194
    fclose(output_file___2);
    }
  }
#line 1195
  return;
}
}
#line 1198 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void calculate_blocks___2(void) 
{ 
  MY_FILE big_streams_list ;
  unsigned int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1205
  big_streams_list.type = (enum __anonenum_type_26 )1;
#line 1205
  big_streams_list.size = (unsigned int )((unsigned long )Input___2.size - 5UL * sizeof(MY_FILE ));
#line 1205
  big_streams_list.blocks = (unsigned int *)((void *)0);
#line 1205
  big_streams_list.file.MY_FILE_list = Input___2.file.MY_FILE_list + 5;
#line 1211
  if (! (*(BDepot___6->blocks) == *(bbd_list___2->file.block_list))) {
    {
#line 1211
    __assert_fail("*(BDepot->blocks) == *(bbd_list->file.block_list)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1211U, "calculate_blocks");
    }
  }
#line 1212
  if (! Root___6->size) {
#line 1212
    tmp = 1U;
  } else {
#line 1212
    tmp = 1U + (Root___6->size - 1U) / 512U;
  }
#line 1212
  if (! (*(Root___6->blocks) == tmp)) {
    {
#line 1212
    __assert_fail("*(Root->blocks) == (!(Root->size) ? 1 : (1+((Root->size)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1212U, "calculate_blocks");
    }
  }
  {
#line 1215
  tmp___3 = sum_blocks_MY_FILE_list___2(sbfile___6);
  }
#line 1215
  if (tmp___3 * 64U) {
    {
#line 1215
    tmp___1 = sum_blocks_MY_FILE_list___2(sbfile___6);
#line 1215
    tmp___2 = 1U + (tmp___1 * 64U - 1U) / 512U;
    }
  } else {
#line 1215
    tmp___2 = 0U;
  }
#line 1215
  if (! (*(sbfile___6->blocks) == tmp___2)) {
    {
#line 1215
    __assert_fail("*(sbfile->blocks) == (!(sum_blocks_MY_FILE_list (sbfile) * 0x40) ? 0 : (1+((sum_blocks_MY_FILE_list (sbfile) * 0x40)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1216U, "calculate_blocks");
    }
  }
  {
#line 1217
  tmp___7 = sum_block_list___2(SDepot___6);
  }
#line 1217
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 1217
    tmp___5 = sum_block_list___2(SDepot___6);
#line 1217
    tmp___6 = 1UL + ((unsigned long )tmp___5 * sizeof(unsigned int ) - 1UL) / 512UL;
    }
  } else {
#line 1217
    tmp___6 = 0UL;
  }
#line 1217
  if (! ((unsigned long )*(SDepot___6->blocks) == tmp___6)) {
    {
#line 1217
    __assert_fail("*(SDepot->blocks) == (!((sum_block_list (SDepot) * sizeof (unsigned int))) ? 0 : (1+(((sum_block_list (SDepot) * sizeof (unsigned int)))-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1218U, "calculate_blocks");
    }
  }
  {
#line 1219
  BDepot_blocks___2 = *(BDepot___6->blocks);
#line 1220
  SDepot_blocks___2 = *(SDepot___6->blocks);
#line 1221
  Root_blocks___2 = *(Root___6->blocks);
#line 1222
  sbfile_blocks___2 = *(sbfile___6->blocks);
#line 1223
  big_streams_blocks___2 = sum_blocks_MY_FILE_list___2(& big_streams_list);
  }
#line 1224
  if (! ((unsigned long )(19U + BDepot_blocks___2) * sizeof(unsigned int ))) {
#line 1224
    header_blocks___2 = 1U;
  } else {
#line 1224
    header_blocks___2 = (unsigned int )(1UL + ((unsigned long )(19U + BDepot_blocks___2) * sizeof(unsigned int ) - 1UL) / 512UL);
  }
#line 1228
  sbfile_start_block___2 = (unsigned int )(4294967295UL + (unsigned long )header_blocks___2);
#line 1230
  Root_start_block___2 = (unsigned int )((((4294967295UL + (unsigned long )header_blocks___2) + (unsigned long )sbfile_blocks___2) + (unsigned long )big_streams_blocks___2) + (unsigned long )SDepot_blocks___2);
#line 1233
  if (SDepot_blocks___2 > 0U) {
#line 1235
    SDepot_start_block___2 = (unsigned int )(((4294967295UL + (unsigned long )header_blocks___2) + (unsigned long )sbfile_blocks___2) + (unsigned long )big_streams_blocks___2);
  } else {
#line 1239
    SDepot_start_block___2 = 4294967294U;
  }
#line 1240
  BDepot_start_block___2 = (unsigned int )(((((4294967295UL + (unsigned long )header_blocks___2) + (unsigned long )sbfile_blocks___2) + (unsigned long )big_streams_blocks___2) + (unsigned long )SDepot_blocks___2) + (unsigned long )Root_blocks___2);
#line 1247
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___2(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 222
static int __cole_print_tree_outdir___2(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 223
static int __cole_print_tree_inroot___2(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 224
static int __cole_print_tree_indirentry___2(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) ;
#line 242 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___2(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 250
  (*((long *)info)) ++;
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_outdir___2(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 262
  (*((long *)info)) --;
#line 263
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_inroot___2(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 276
  printf((char const   */* __restrict  */)"DIR ");
#line 277
  tmp = cole_dir_getsize(cd);
#line 277
  printf((char const   */* __restrict  */)" %7zu", tmp);
#line 278
  tmp___0 = cole_dir_getsec2(cd);
#line 278
  tmp___1 = cole_dir_getdays2(cd);
#line 278
  tmp___2 = cole_dir_getsec1(cd);
#line 278
  tmp___3 = cole_dir_getdays1(cd);
#line 278
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___3, tmp___2,
         tmp___1, tmp___0);
#line 283
  entry_name = cole_dir_getname(cd);
#line 284
  tmp___4 = __ctype_b_loc();
  }
#line 284
  if ((int const   )*(*tmp___4 + (int )*(entry_name + 0)) & 16384) {
    {
#line 287
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 285
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indirentry___2(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  long level ;
  long i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 304
  level = *((long *)info);
#line 305
  i = 0L;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < level)) {
#line 305
      goto while_break;
    }
#line 306
    if (i == level - 1L) {
      {
#line 307
      printf((char const   */* __restrict  */)"\\--");
      }
    } else {
      {
#line 309
      printf((char const   */* __restrict  */)"|  ");
      }
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  tmp___0 = cole_direntry_isdir(cde);
  }
#line 312
  if (tmp___0) {
    {
#line 313
    printf((char const   */* __restrict  */)"DIR ");
    }
  } else {
    {
#line 314
    tmp = cole_direntry_isfile(cde);
    }
#line 314
    if (tmp) {
      {
#line 315
      printf((char const   */* __restrict  */)"FILE");
      }
    } else {
      {
#line 317
      printf((char const   */* __restrict  */)"????");
      }
    }
  }
  {
#line 318
  tmp___1 = cole_direntry_getsize(cde);
#line 318
  printf((char const   */* __restrict  */)" %7zu", tmp___1);
#line 319
  tmp___2 = cole_direntry_getsec2(cde);
#line 319
  tmp___3 = cole_direntry_getdays2(cde);
#line 319
  tmp___4 = cole_direntry_getsec1(cde);
#line 319
  tmp___5 = cole_direntry_getdays1(cde);
#line 319
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___5, tmp___4,
         tmp___3, tmp___2);
#line 324
  entry_name = cole_direntry_getname(cde);
#line 325
  tmp___6 = __ctype_b_loc();
  }
#line 325
  if ((int const   )*(*tmp___6 + (int )*(entry_name + 0)) & 16384) {
    {
#line 328
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 326
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 330
  return (0);
}
}
#line 585
static void _cole_fopen_action___2(COLEDIRENT *cde , void *_info ) ;
#line 605 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static void _cole_fopen_action___2(COLEDIRENT *cde , void *_info ) 
{ 
  struct _cole_fopen_info *info ;
  int tmp ;

  {
  {
#line 610
  info = (struct _cole_fopen_info *)_info;
#line 612
  tmp = cole_direntry_isfile(cde);
  }
#line 612
  if (! tmp) {
#line 613
    info->colerrno = (COLERRNO )18;
#line 614
    info->succ = 0;
#line 615
    return;
  }
  {
#line 618
  info->file = cole_fopen_direntry(cde, & info->colerrno);
  }
#line 619
  if ((unsigned long )info->file == (unsigned long )((void *)0)) {
#line 621
    info->succ = 0;
#line 622
    return;
  }
#line 625
  info->succ = 1;
#line 626
  return;
}
}
#line 948
static int __cole_recurse_tree___2(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) ;
#line 986 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_recurse_tree___2(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) 
{ 
  COLEDIRENT *cde ;
  COLEDIR *cd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1007
  if (level == 1L) {
#line 1009
    if ((unsigned long )inroot != (unsigned long )((void *)0)) {
      {
#line 1010
      tmp = (*inroot)(_cd, info, colerrno);
      }
#line 1010
      if (tmp) {
#line 1012
        return (1);
      }
    }
  }
  {
#line 1018
  cde = cole_visiteddirentry(_cd);
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned long )cde != (unsigned long )((void *)0))) {
#line 1018
      goto while_break;
    }
#line 1020
    if ((unsigned long )indirentry != (unsigned long )((void *)0)) {
      {
#line 1021
      tmp___0 = (*indirentry)(cde, info, colerrno);
      }
#line 1021
      if (tmp___0) {
#line 1023
        return (1);
      }
    }
    {
#line 1028
    tmp___6 = cole_direntry_isdir(cde);
    }
#line 1028
    if (tmp___6) {
      {
#line 1029
      cd = cole_opendir_direntry(cde, colerrno);
      }
#line 1030
      if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 1032
        return (1);
      }
#line 1035
      if ((unsigned long )indir != (unsigned long )((void *)0)) {
        {
#line 1036
        tmp___1 = (*indir)(cd, info, colerrno);
        }
#line 1036
        if (tmp___1) {
          {
#line 1038
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1039
          return (1);
        }
      }
#line 1043
      if ((unsigned long )visitdir == (unsigned long )((void *)0)) {
#line 1043
        goto _L;
      } else {
        {
#line 1043
        tmp___3 = (*visitdir)(cd, info);
        }
#line 1043
        if (tmp___3) {
          _L: /* CIL Label */ 
          {
#line 1045
          tmp___2 = __cole_recurse_tree___2(cd, level + 1L, info, inroot, indirentry,
                                            indir, outdir, visitdir, colerrno);
          }
#line 1045
          if (tmp___2) {
            {
#line 1050
            cole_closedir(cd, (COLERRNO *)((void *)0));
            }
#line 1051
            return (1);
          }
        }
      }
#line 1055
      if ((unsigned long )outdir != (unsigned long )((void *)0)) {
        {
#line 1056
        tmp___4 = (*outdir)(cd, info, colerrno);
        }
#line 1056
        if (tmp___4) {
          {
#line 1058
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1059
          return (1);
        }
      }
      {
#line 1063
      tmp___5 = cole_closedir(cd, colerrno);
      }
#line 1063
      if (tmp___5) {
#line 1065
        return (1);
      }
    }
    {
#line 1018
    cde = cole_nextdirentry(_cd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return (0);
}
}
#line 1098
static int __cole_locate_filename_indirentry___2(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) ;
#line 1099
static int __cole_locate_filename_visitdir___2(COLEDIR *cd , void *info ) ;
#line 1136 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_visitdir___2(COLEDIR *cd , void *info ) 
{ 


  {
#line 1139
  return (((struct __cole_locate_filenameinfo *)info)->visitdir);
}
}
#line 1142 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_indirentry___2(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  struct __cole_locate_filenameinfo *info ;
  char *pcurrent ;
  char *pentry_name ;
  int tmp ;

  {
  {
#line 1151
  info = (struct __cole_locate_filenameinfo *)_info;
#line 1152
  entry_name = cole_direntry_getname(cde);
#line 1153
  pcurrent = info->current;
#line 1153
  pentry_name = entry_name;
  }
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (*pcurrent) {
#line 1153
      if (*pentry_name) {
#line 1153
        if (! ((int )*pcurrent != 47)) {
#line 1153
          goto while_break;
        }
      } else {
#line 1153
        goto while_break;
      }
    } else {
#line 1153
      goto while_break;
    }
#line 1156
    if ((int )*pcurrent != (int )*pentry_name) {
#line 1157
      info->visitdir = 0;
#line 1158
      return (0);
    }
#line 1153
    pcurrent ++;
#line 1153
    pentry_name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1162
  if ((int )*pentry_name == 0) {
#line 1162
    goto case_0;
  }
#line 1197
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 1164
  if ((int )*pcurrent == 47) {
#line 1164
    goto case_47;
  }
#line 1185
  if ((int )*pcurrent == 0) {
#line 1185
    goto case_0___0;
  }
#line 1193
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 1165
  tmp = cole_direntry_isdir(cde);
  }
#line 1165
  if (! tmp) {
#line 1166
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1167
      *colerrno = (COLERRNO )16;
    }
#line 1168
    return (1);
  }
#line 1170
  pcurrent ++;
#line 1171
  info->current = pcurrent;
#line 1174
  if (! *(info->current)) {
#line 1176
    if ((unsigned long )info->action != (unsigned long )((void *)0)) {
      {
#line 1177
      (*(info->action))(cde, info->info);
      }
    }
#line 1180
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1180
      *colerrno = (COLERRNO )23;
    }
#line 1181
    return (1);
  }
#line 1183
  info->visitdir = 1;
#line 1184
  return (0);
  case_0___0: /* CIL Label */ 
#line 1187
  if ((unsigned long )info->action != (unsigned long )((void *)0)) {
    {
#line 1188
    (*(info->action))(cde, info->info);
    }
  }
#line 1191
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1191
    *colerrno = (COLERRNO )23;
  }
#line 1192
  return (1);
  switch_default: /* CIL Label */ 
#line 1194
  info->visitdir = 0;
#line 1195
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 1199
  if ((int )*pcurrent == 0) {
#line 1199
    goto case_0___1;
  }
#line 1202
  if ((int )*pcurrent == 47) {
#line 1202
    goto case_47___0;
  }
#line 1205
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 1200
  info->visitdir = 0;
#line 1201
  return (0);
  case_47___0: /* CIL Label */ 
#line 1203
  info->visitdir = 0;
#line 1204
  return (0);
  switch_default___1: /* CIL Label */ 
#line 1206
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1206
    *colerrno = (COLERRNO )21;
  }
#line 1207
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/pptdump.c"
static char FileName___1[2][32]  = { {        (char )'/',        (char )'P',        (char )'o',        (char )'w', 
            (char )'e',        (char )'r',        (char )'P',        (char )'o', 
            (char )'i',        (char )'n',        (char )'t',        (char )' ', 
            (char )'D',        (char )'o',        (char )'c',        (char )'u', 
            (char )'m',        (char )'e',        (char )'n',        (char )'t', 
            (char )'\000'}, 
   {        (char )'/',        (char )'P',        (char )'P',        (char )'4', 
            (char )'0',        (char )'\000'}};
#line 55 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/pptdump.c"
static char filename___2[128]  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___3(pps_entry *node , unsigned short level ) ;
#line 74
static void ends___7(void) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *input___3  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Block___3  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Blockx___3  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *BDepot___7  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *SDepot___7  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned char *Root___7  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static pps_entry *pps_list___3  ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int num_of_pps___3  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static FILE *sbfile___7  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *sbd_list___3  ;
#line 101 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *root_list___4  ;
#line 597 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static unsigned int *last_next_link_visited___3  ;
#line 598 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static int reorder_pps_tree___3(pps_entry *node , unsigned short level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 603
  node->level = level;
#line 606
  if ((unsigned long )node->dir != 4294967295UL) {
#line 608
    if (node->dir > num_of_pps___3) {
#line 609
      return (0);
    } else
#line 608
    if (! (pps_list___3 + node->dir)->name[0]) {
#line 609
      return (0);
    } else {
      {
#line 610
      tmp = reorder_pps_tree___3(pps_list___3 + node->dir, (unsigned short )((int )level + 1));
      }
#line 610
      if (! tmp) {
#line 611
        return (0);
      }
    }
  }
#line 615
  if ((unsigned long )node->next != 4294967295UL) {
#line 617
    if (node->next > num_of_pps___3) {
#line 618
      return (0);
    } else
#line 617
    if (! (pps_list___3 + node->next)->name[0]) {
#line 618
      return (0);
    } else {
      {
#line 619
      tmp___0 = reorder_pps_tree___3(pps_list___3 + node->next, level);
      }
#line 619
      if (! tmp___0) {
#line 620
        return (0);
      }
    }
  } else {
#line 623
    last_next_link_visited___3 = & node->next;
  }
#line 626
  if ((unsigned long )node->previous != 4294967295UL) {
#line 628
    if (node->previous > num_of_pps___3) {
#line 629
      return (0);
    } else
#line 628
    if (! (pps_list___3 + node->previous)->name[0]) {
#line 629
      return (0);
    } else {
      {
#line 632
      *last_next_link_visited___3 = node->previous;
#line 633
      node->previous = 4294967295U;
#line 634
      tmp___1 = reorder_pps_tree___3(pps_list___3 + *last_next_link_visited___3, level);
      }
#line 634
      if (! tmp___1) {
#line 635
        return (0);
      }
    }
  }
#line 638
  return (1);
}
}
#line 759 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/oledecod.c"
static void ends___7(void) 
{ 


  {
#line 767
  if ((unsigned long )Block___3 != (unsigned long )((void *)0)) {
    {
#line 767
    free((void *)Block___3);
    }
  }
#line 768
  if ((unsigned long )Blockx___3 != (unsigned long )((void *)0)) {
    {
#line 768
    free((void *)Blockx___3);
    }
  }
#line 775
  if ((unsigned long )Root___7 != (unsigned long )((void *)0)) {
    {
#line 775
    free((void *)Root___7);
    }
  }
#line 776
  if ((unsigned long )sbd_list___3 != (unsigned long )((void *)0)) {
    {
#line 776
    free((void *)sbd_list___3);
    }
  }
#line 777
  if ((unsigned long )root_list___4 != (unsigned long )((void *)0)) {
    {
#line 777
    free((void *)root_list___4);
    }
  }
#line 787
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE Input___3  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *sbfile___8  ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *SDepot___8  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *BDepot___8  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *bbd_list___3  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static MY_FILE *Root___8  ;
#line 79 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int header_blocks___3  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int big_streams_blocks___3  ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_blocks___3  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_blocks___3  ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_blocks___3  ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_blocks___3  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sbfile_start_block___3  ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int SDepot_start_block___3  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int Root_start_block___3  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int BDepot_start_block___3  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static FILE *output_file___3  ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned char output_block___3[512]  ;
#line 94 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned short pos_block___3  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int next_block___3  ;
#line 105
static int process_Root___3(pps_entry *pps_list___4 , unsigned int root ) ;
#line 106
static unsigned int max_pps_referenced___3(pps_entry *pps_list___4 , unsigned int node ) ;
#line 107
static unsigned int max3___3(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) ;
#line 108
static int process_streams___3(pps_entry *pps_list___4 , pps_entry *node ) ;
#line 109
static int add_stream_to_sbfile_and_SDepot___3(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 110
static int add_stream_to_Input_and_BDepot___3(unsigned int size , char *name , unsigned int ppsnumber ) ;
#line 111
static int add_entry_to_Root___3(pps_entry *node , unsigned int start_block ) ;
#line 112
static unsigned int add_MY_FILE_entry___3(MY_FILE *list , unsigned int size ) ;
#line 113
static int pps2root___3(unsigned char *pps , pps_entry *node , unsigned int start_block ) ;
#line 114
static void reset_links_in_Input___3(void) ;
#line 115
static void reset_links_in_BDepot___3(void) ;
#line 116
static void reset_links_in_SDepot___3(void) ;
#line 118
static int generate_ole2_file___3(char const   *filename___4 , int trunc ) ;
#line 119
static int generate_header___3(void) ;
#line 120
static int generate_recursive___3(MY_FILE *list ) ;
#line 121
static int generate_SDepot___3(void) ;
#line 122
static int generate_Root___3(void) ;
#line 123
static int generate_BDepot___3(void) ;
#line 124
static int generate_real_file___3(MY_FILE *MY_FILE_file ) ;
#line 125
static int write_block_list___3(unsigned int start_count , MY_FILE *list , int write_end_chain ) ;
#line 126
static int write_root_list___3(MY_FILE *list ) ;
#line 127
static void calculate_blocks___3(void) ;
#line 129
static unsigned int sum_block_list___3(MY_FILE *list ) ;
#line 132
static unsigned int sum_blocks_MY_FILE_list___3(MY_FILE *list ) ;
#line 134
static void ends___8(void) ;
#line 285 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_Root___3(pps_entry *pps_list___4 , unsigned int root ) 
{ 
  unsigned int pps_list_entries ;
  unsigned int i ;
  unsigned int tmp ;
  int retval ;

  {
  {
#line 293
  tmp = max_pps_referenced___3(pps_list___4, root);
#line 293
  pps_list_entries = 1U + tmp;
#line 296
  i = 0U;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < pps_list_entries)) {
#line 296
      goto while_break;
    }
    {
#line 297
    retval = add_entry_to_Root___3(pps_list___4 + i, 0U);
    }
#line 297
    if (retval) {
#line 297
      return (retval);
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max3___3(unsigned int a , unsigned int b , unsigned int c , unsigned int d ) 
{ 
  unsigned int m ;

  {
#line 319
  m = 0U;
#line 323
  if (m > a) {
#line 323
    m = m;
  } else {
#line 323
    m = a;
  }
#line 324
  if (m > b) {
#line 324
    m = m;
  } else {
#line 324
    m = b;
  }
#line 325
  if (m > c) {
#line 325
    m = m;
  } else {
#line 325
    m = c;
  }
#line 326
  if (m > d) {
#line 326
    m = m;
  } else {
#line 326
    m = d;
  }
#line 327
  return (m);
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int max_pps_referenced___3(pps_entry *pps_list___4 , unsigned int node ) 
{ 
  unsigned int max_pps ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 337
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
#line 337
    tmp = (pps_list___4 + node)->dir;
  } else {
#line 337
    tmp = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
#line 337
    tmp___0 = (pps_list___4 + node)->next;
  } else {
#line 337
    tmp___0 = 0U;
  }
#line 337
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
#line 337
    tmp___1 = (pps_list___4 + node)->previous;
  } else {
#line 337
    tmp___1 = 0U;
  }
  {
#line 337
  max_pps = max3___3(node, tmp___1, tmp___0, tmp);
  }
#line 342
  if ((unsigned long )(pps_list___4 + node)->previous != 4294967295UL) {
    {
#line 343
    tmp___4 = max_pps_referenced___3(pps_list___4, (pps_list___4 + node)->previous);
    }
#line 343
    if (max_pps > tmp___4) {
#line 343
      max_pps = max_pps;
    } else {
      {
#line 343
      tmp___3 = max_pps_referenced___3(pps_list___4, (pps_list___4 + node)->previous);
#line 343
      max_pps = tmp___3;
      }
    }
  }
#line 345
  if ((unsigned long )(pps_list___4 + node)->next != 4294967295UL) {
    {
#line 346
    tmp___7 = max_pps_referenced___3(pps_list___4, (pps_list___4 + node)->next);
    }
#line 346
    if (max_pps > tmp___7) {
#line 346
      max_pps = max_pps;
    } else {
      {
#line 346
      tmp___6 = max_pps_referenced___3(pps_list___4, (pps_list___4 + node)->next);
#line 346
      max_pps = tmp___6;
      }
    }
  }
#line 348
  if ((unsigned long )(pps_list___4 + node)->dir != 4294967295UL) {
    {
#line 349
    tmp___10 = max_pps_referenced___3(pps_list___4, (pps_list___4 + node)->dir);
    }
#line 349
    if (max_pps > tmp___10) {
#line 349
      max_pps = max_pps;
    } else {
      {
#line 349
      tmp___9 = max_pps_referenced___3(pps_list___4, (pps_list___4 + node)->dir);
#line 349
      max_pps = tmp___9;
      }
    }
  }
#line 352
  return (max_pps);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int process_streams___3(pps_entry *pps_list___4 , pps_entry *node ) 
{ 
  unsigned int U32end_chain ;
  int retval ;
  int retval___0 ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;
  int retval___4 ;
  int retval___5 ;

  {
#line 359
  U32end_chain = 4294967294U;
#line 363
  if (! node->name[0]) {
#line 363
    return (12);
  }
  {
#line 366
  if ((int )node->type == 1) {
#line 366
    goto case_1;
  }
#line 374
  if ((int )node->type == 5) {
#line 374
    goto case_5;
  }
#line 385
  if ((int )node->type == 2) {
#line 385
    goto case_2;
  }
#line 399
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 368
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 369
    retval = process_streams___3(pps_list___4, pps_list___4 + node->dir);
    }
#line 369
    if (retval) {
#line 369
      return (retval);
    }
  }
#line 370
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 371
    retval___0 = process_streams___3(pps_list___4, pps_list___4 + node->next);
    }
#line 371
    if (retval___0) {
#line 371
      return (retval___0);
    }
  }
#line 372
  goto switch_break;
  case_5: /* CIL Label */ 
#line 375
  if (! ((int )*(Root___8->file.root_list + 66) == 5)) {
    {
#line 375
    __assert_fail("*(Root->file.root_list + 0x42) == 5", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  375U, "process_streams");
    }
  }
  {
#line 378
  fil_swriteU32(Root___8->file.root_list + 116, & U32end_chain);
  }
#line 379
  if ((unsigned long )node->dir != 4294967295UL) {
    {
#line 380
    retval___1 = process_streams___3(pps_list___4, pps_list___4 + node->dir);
    }
#line 380
    if (retval___1) {
#line 380
      return (retval___1);
    }
  }
#line 381
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 382
    retval___2 = process_streams___3(pps_list___4, pps_list___4 + node->next);
    }
#line 382
    if (retval___2) {
#line 382
      return (retval___2);
    }
  }
#line 383
  goto switch_break;
  case_2: /* CIL Label */ 
#line 386
  if (! ((unsigned long )node->dir == 4294967295UL)) {
#line 386
    return (12);
  }
#line 387
  if (node->size < 4096U) {
    {
#line 389
    retval___3 = add_stream_to_sbfile_and_SDepot___3(node->size, node->filename, node->ppsnumber);
    }
#line 389
    if (retval___3) {
#line 389
      return (retval___3);
    }
  } else {
    {
#line 393
    retval___4 = add_stream_to_Input_and_BDepot___3(node->size, node->filename, node->ppsnumber);
    }
#line 393
    if (retval___4) {
#line 393
      return (retval___4);
    }
  }
#line 395
  if ((unsigned long )node->next != 4294967295UL) {
    {
#line 396
    retval___5 = process_streams___3(pps_list___4, pps_list___4 + node->next);
    }
#line 396
    if (retval___5) {
#line 396
      return (retval___5);
    }
  }
#line 397
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 400
  return (12);
  switch_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_entry_to_Root___3(pps_entry *node , unsigned int start_block ) 
{ 
  unsigned int entry_number ;
  unsigned char *new_entry_Root ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 416
  entry_number = add_MY_FILE_entry___3(Root___8, 0U);
  }
#line 417
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 417
    return (10);
  }
  {
#line 418
  new_entry_Root = Root___8->file.root_list + entry_number * 128U;
#line 421
  pps2root___3((unsigned char *)new_entry_Root, node, start_block);
  }
#line 424
  if (! Root___8->size) {
#line 424
    *(Root___8->blocks) = 1U;
  } else {
#line 424
    *(Root___8->blocks) = 1U + (Root___8->size - 1U) / 512U;
  }
  {
#line 428
  tmp___1 = sum_block_list___3(BDepot___8);
  }
#line 428
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 428
    tmp___0 = sum_block_list___3(BDepot___8);
#line 428
    *(BDepot___8->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 428
    *(BDepot___8->blocks) = 1U;
  }
#line 430
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_sbfile_and_SDepot___3(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  unsigned int *new_entry_SDepot ;
  MY_FILE *new_entry_sbfile ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 447
  entry_number = add_MY_FILE_entry___3(SDepot___8, size);
  }
#line 448
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 448
    return (10);
  }
  {
#line 449
  new_entry_SDepot = SDepot___8->file.block_list + entry_number;
#line 451
  entry_number = add_MY_FILE_entry___3(sbfile___8, size);
  }
#line 452
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 452
    return (10);
  }
#line 453
  new_entry_sbfile = sbfile___8->file.MY_FILE_list + entry_number;
#line 458
  if (! size) {
#line 458
    *new_entry_SDepot = 1U;
  } else {
#line 458
    *new_entry_SDepot = 1U + (size - 1U) / 64U;
  }
  {
#line 461
  tmp___1 = sum_block_list___3(SDepot___8);
  }
#line 461
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 461
    tmp___0 = sum_block_list___3(SDepot___8);
#line 461
    *(SDepot___8->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 461
    *(SDepot___8->blocks) = 1U;
  }
  {
#line 468
  new_entry_sbfile->type = (enum __anonenum_type_26 )0;
#line 468
  new_entry_sbfile->size = size;
#line 468
  new_entry_sbfile->blocks = new_entry_SDepot;
#line 468
  new_entry_sbfile->file.real.name = name;
#line 468
  new_entry_sbfile->file.real.ppsnumber = ppsnumber;
#line 472
  tmp___4 = sum_blocks_MY_FILE_list___3(sbfile___8);
  }
#line 472
  if (tmp___4 * 64U) {
    {
#line 472
    tmp___3 = sum_blocks_MY_FILE_list___3(sbfile___8);
#line 472
    *(sbfile___8->blocks) = 1U + (tmp___3 * 64U - 1U) / 512U;
    }
  } else {
#line 472
    *(sbfile___8->blocks) = 1U;
  }
  {
#line 477
  tmp___7 = sum_block_list___3(BDepot___8);
  }
#line 477
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 477
    tmp___6 = sum_block_list___3(BDepot___8);
#line 477
    *(BDepot___8->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___6 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 477
    *(BDepot___8->blocks) = 1U;
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int add_stream_to_Input_and_BDepot___3(unsigned int size , char *name , unsigned int ppsnumber ) 
{ 
  unsigned int entry_number ;
  MY_FILE *new_entry_Input ;
  unsigned int *new_entry_BDepot ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 496
  entry_number = add_MY_FILE_entry___3(BDepot___8, size);
  }
#line 497
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 497
    return (10);
  }
  {
#line 498
  new_entry_BDepot = BDepot___8->file.block_list + entry_number;
#line 500
  entry_number = add_MY_FILE_entry___3(& Input___3, size);
  }
#line 501
  if (! ((unsigned long )entry_number != 4294967295UL)) {
#line 501
    return (10);
  }
#line 502
  new_entry_Input = Input___3.file.MY_FILE_list + entry_number;
#line 507
  if (! size) {
#line 507
    *new_entry_BDepot = 1U;
  } else {
#line 507
    *new_entry_BDepot = 1U + (size - 1U) / 512U;
  }
  {
#line 510
  tmp___1 = sum_block_list___3(BDepot___8);
  }
#line 510
  if ((unsigned long )tmp___1 * sizeof(unsigned int )) {
    {
#line 510
    tmp___0 = sum_block_list___3(BDepot___8);
#line 510
    *(BDepot___8->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___0 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 510
    *(BDepot___8->blocks) = 1U;
  }
  {
#line 517
  new_entry_Input->type = (enum __anonenum_type_26 )0;
#line 517
  new_entry_Input->size = size;
#line 517
  new_entry_Input->blocks = new_entry_BDepot;
#line 517
  new_entry_Input->file.real.name = name;
#line 517
  new_entry_Input->file.real.ppsnumber = ppsnumber;
#line 524
  tmp___4 = sum_block_list___3(BDepot___8);
  }
#line 524
  if ((unsigned long )tmp___4 * sizeof(unsigned int )) {
    {
#line 524
    tmp___3 = sum_block_list___3(BDepot___8);
#line 524
    *(BDepot___8->blocks) = (unsigned int )(1UL + ((unsigned long )tmp___3 * sizeof(unsigned int ) - 1UL) / 512UL);
    }
  } else {
#line 524
    *(BDepot___8->blocks) = 1U;
  }
#line 526
  return (0);
}
}
#line 531 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int add_MY_FILE_entry___3(MY_FILE *list , unsigned int size ) 
{ 
  MY_FILE *new_MY_FILE_list ;
  unsigned int new_entry ;
  void *tmp ;
  unsigned int *new_block_list ;
  unsigned int new_entry___0 ;
  void *tmp___0 ;
  unsigned int new_entry___1 ;
  unsigned char *new_root_list ;
  void *tmp___1 ;

  {
#line 574
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 574
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  574U, "add_MY_FILE_entry");
    }
  }
  {
#line 581
  if ((unsigned int )list->type == 1U) {
#line 581
    goto case_1;
  }
#line 599
  if ((unsigned int )list->type == 2U) {
#line 599
    goto case_2;
  }
#line 616
  if ((unsigned int )list->type == 3U) {
#line 616
    goto case_3;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 585
  if (! ((unsigned long )list == (unsigned long )sbfile___8)) {
#line 585
    if (! ((unsigned long )list == (unsigned long )(& Input___3))) {
      {
#line 585
      __assert_fail("list == sbfile || list == &Input", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    585U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 587
  list->size = (unsigned int )((unsigned long )list->size + sizeof(MY_FILE ));
#line 588
  tmp = realloc((void *)list->file.MY_FILE_list, (size_t )list->size);
#line 588
  new_MY_FILE_list = (MY_FILE *)tmp;
#line 589
  list->file.MY_FILE_list = new_MY_FILE_list;
  }
#line 590
  if (! ((unsigned long )new_MY_FILE_list != (unsigned long )((void *)0))) {
#line 590
    return (4294967295U);
  }
  {
#line 591
  new_entry = (unsigned int )((unsigned long )list->size / sizeof(MY_FILE ) - 1UL);
#line 592
  reset_links_in_Input___3();
#line 592
  reset_links_in_BDepot___3();
#line 592
  reset_links_in_SDepot___3();
  }
#line 594
  return (new_entry);
  case_2: /* CIL Label */ 
#line 603
  if (! ((unsigned long )list == (unsigned long )SDepot___8)) {
#line 603
    if (! ((unsigned long )list == (unsigned long )BDepot___8)) {
      {
#line 603
      __assert_fail("list == SDepot || list == BDepot", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    603U, "add_MY_FILE_entry");
      }
    }
  }
  {
#line 605
  list->size = (unsigned int )((unsigned long )list->size + sizeof(unsigned int ));
#line 606
  tmp___0 = realloc((void *)list->file.block_list, (size_t )list->size);
#line 606
  new_block_list = (unsigned int *)tmp___0;
#line 607
  list->file.block_list = new_block_list;
  }
#line 608
  if (! ((unsigned long )new_block_list != (unsigned long )((void *)0))) {
#line 608
    return (4294967295U);
  }
  {
#line 609
  new_entry___0 = (unsigned int )((unsigned long )list->size / sizeof(unsigned int ) - 1UL);
#line 610
  reset_links_in_Input___3();
#line 610
  reset_links_in_BDepot___3();
#line 610
  reset_links_in_SDepot___3();
  }
#line 612
  return (new_entry___0);
  case_3: /* CIL Label */ 
#line 620
  if (! ((unsigned long )list == (unsigned long )Root___8)) {
    {
#line 620
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  620U, "add_MY_FILE_entry");
    }
  }
  {
#line 622
  list->size += 128U;
#line 623
  tmp___1 = realloc((void *)list->file.root_list, (size_t )list->size);
#line 623
  new_root_list = (unsigned char *)tmp___1;
#line 624
  list->file.root_list = new_root_list;
  }
#line 625
  if (! ((unsigned long )new_root_list != (unsigned long )((void *)0))) {
#line 625
    return (4294967295U);
  }
  {
#line 626
  new_entry___1 = list->size / 128U - 1U;
#line 627
  reset_links_in_Input___3();
#line 627
  reset_links_in_BDepot___3();
#line 627
  reset_links_in_SDepot___3();
  }
#line 629
  return (new_entry___1);
  switch_default: /* CIL Label */ ;
#line 640
  if (! ((unsigned long )"list->type UNKNOWN in add_MY_FILE_entry" == (unsigned long )((void *)0))) {
    {
#line 640
    __assert_fail("\"list->type UNKNOWN in add_MY_FILE_entry\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  640U, "add_MY_FILE_entry");
    }
  }
#line 641
  return (0U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int pps2root___3(unsigned char *pps , pps_entry *node , unsigned int start_block ) 
{ 
  unsigned short i ;
  unsigned short size_of_name ;
  unsigned char U8magiczero ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 653
  U8magiczero = (unsigned char)0;
#line 654
  U32magiczero = 0U;
#line 655
  U32magic1 = 133376U;
#line 656
  U32magic2 = 1174405120U;
#line 663
  if (! (node->ppsnumber == (unsigned int )(pps - (unsigned char *)Root___8->file.root_list) / 128U)) {
    {
#line 663
    __assert_fail("node->ppsnumber == (unsigned int)(pps - Root->file.root_list)/0x80",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  663U, "pps2root");
    }
  }
  {
#line 665
  memset((void *)pps, 255, (size_t )128);
#line 668
  tmp = strlen((char const   *)(node->name));
#line 668
  size_of_name = (unsigned short )(2UL * (tmp + 1UL));
#line 670
  i = (unsigned short)0;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! ((int )i < (int )size_of_name)) {
#line 670
      goto while_break;
    }
#line 671
    if ((int )i % 2) {
#line 671
      tmp___0 = 0;
    } else {
#line 671
      tmp___0 = (int )*(node->name + (int )i / 2);
    }
#line 671
    *(pps + (int )i) = (unsigned char )tmp___0;
#line 670
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  fil_swriteU16((unsigned char *)(pps + 64), & size_of_name);
#line 675
  *(pps + 66) = node->type;
#line 676
  fil_swriteU32((unsigned char *)(pps + 68), & node->previous);
#line 677
  fil_swriteU32((unsigned char *)(pps + 72), & node->next);
#line 678
  fil_swriteU32((unsigned char *)(pps + 76), & node->dir);
#line 679
  fil_swriteU32((unsigned char *)(pps + 100), & node->seconds1);
#line 680
  fil_swriteU32((unsigned char *)(pps + 104), & node->days1);
#line 681
  fil_swriteU32((unsigned char *)(pps + 108), & node->seconds2);
#line 682
  fil_swriteU32((unsigned char *)(pps + 112), & node->days1);
#line 683
  fil_swriteU32((unsigned char *)(pps + 116), & start_block);
#line 684
  fil_swriteU32((unsigned char *)(pps + 120), & node->size);
#line 687
  *(pps + 67) = U8magiczero;
#line 688
  fil_swriteU32((unsigned char *)(pps + 80), & U32magic1);
#line 689
  fil_swriteU32((unsigned char *)(pps + 84), & U32magiczero);
#line 690
  fil_swriteU32((unsigned char *)(pps + 88), & U32magiczero);
#line 691
  fil_swriteU32((unsigned char *)(pps + 92), & U32magic2);
#line 692
  fil_swriteU32((unsigned char *)(pps + 96), & U32magiczero);
#line 693
  fil_swriteU32((unsigned char *)(pps + 124), & U32magiczero);
  }
#line 697
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_block_list___3(MY_FILE *list ) 
{ 
  unsigned int sum ;
  unsigned int *block ;

  {
#line 702
  sum = 0U;
#line 707
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 707
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  707U, "sum_block_list");
    }
  }
#line 708
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 708
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  708U, "sum_block_list");
    }
  }
#line 709
  block = list->file.block_list;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! ((unsigned int )((unsigned char *)block - (unsigned char *)list->file.block_list) < list->size)) {
#line 709
      goto while_break;
    }
#line 712
    sum += *block;
#line 709
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return (sum);
}
}
#line 738 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int sum_blocks_MY_FILE_list___3(MY_FILE *list ) 
{ 
  unsigned int sum ;
  MY_FILE *file ;

  {
#line 740
  sum = 0U;
#line 745
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 745
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  745U, "sum_blocks_MY_FILE_list");
    }
  }
#line 746
  if (! ((unsigned int )list->type == 1U)) {
    {
#line 746
    __assert_fail("list->type == MY_FILE_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  746U, "sum_blocks_MY_FILE_list");
    }
  }
#line 747
  file = list->file.MY_FILE_list;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )((unsigned char *)file - (unsigned char *)list->file.MY_FILE_list) < list->size)) {
#line 747
      goto while_break;
    }
#line 750
    if ((unsigned long )file->blocks != (unsigned long )((void *)0)) {
#line 751
      sum += *(file->blocks);
    }
#line 747
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (sum);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_Input___3(void) 
{ 


  {
#line 759
  sbfile___8 = Input___3.file.MY_FILE_list + 4;
#line 760
  SDepot___8 = Input___3.file.MY_FILE_list + 3;
#line 761
  BDepot___8 = Input___3.file.MY_FILE_list + 1;
#line 762
  bbd_list___3 = Input___3.file.MY_FILE_list;
#line 763
  Root___8 = Input___3.file.MY_FILE_list + 2;
#line 764
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_BDepot___3(void) 
{ 
  unsigned int i ;

  {
#line 772
  sbfile___8->blocks = BDepot___8->file.block_list;
#line 773
  SDepot___8->blocks = BDepot___8->file.block_list + 1;
#line 774
  Root___8->blocks = BDepot___8->file.block_list + 2;
#line 777
  i = 0U;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )i < (unsigned long )Input___3.size / sizeof(MY_FILE ) - 5UL)) {
#line 777
      goto while_break;
    }
#line 778
    (Input___3.file.MY_FILE_list + (i + 5U))->blocks = (BDepot___8->file.block_list + i) + 3;
#line 777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void reset_links_in_SDepot___3(void) 
{ 
  unsigned int i ;

  {
#line 788
  i = 0U;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! ((unsigned long )i < (unsigned long )sbfile___8->size / sizeof(MY_FILE ))) {
#line 788
      goto while_break;
    }
#line 789
    (sbfile___8->file.MY_FILE_list + i)->blocks = SDepot___8->file.block_list + i;
#line 788
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_ole2_file___3(char const   *filename___4 , int trunc ) 
{ 
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;
  int retval___2 ;
  int retval___3 ;

  {
#line 796
  if (! trunc) {
    {
#line 798
    output_file___3 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"r");
    }
#line 799
    if (! ((unsigned long )output_file___3 == (unsigned long )((void *)0))) {
      {
#line 799
      ends___8();
      }
#line 799
      return (2);
    }
  }
  {
#line 801
  output_file___3 = fopen((char const   */* __restrict  */)filename___4, (char const   */* __restrict  */)"wb");
  }
#line 802
  if (! ((unsigned long )output_file___3 != (unsigned long )((void *)0))) {
    {
#line 802
    ends___8();
    }
#line 802
    return (3);
  }
  {
#line 804
  retval = generate_header___3();
  }
#line 804
  if (retval) {
#line 804
    return (retval);
  }
  {
#line 805
  retval___0 = generate_recursive___3(& Input___3);
  }
#line 805
  if (retval___0) {
#line 805
    return (retval___0);
  }
#line 809
  if ((int )pos_block___3 != 0) {
#line 809
    if ((int )pos_block___3 % 512) {
      {
#line 809
      memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 512 + 1) * 512 - (int )pos_block___3));
      }
    }
    {
#line 809
    tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___3);
    }
#line 809
    if (! (tmp == 512UL)) {
#line 809
      return (1);
    }
#line 809
    next_block___3 ++;
#line 809
    pos_block___3 = (unsigned short)0;
  }
  {
#line 810
  retval___1 = generate_SDepot___3();
  }
#line 810
  if (retval___1) {
#line 810
    return (retval___1);
  }
  {
#line 811
  retval___2 = generate_Root___3();
  }
#line 811
  if (retval___2) {
#line 811
    return (retval___2);
  }
  {
#line 812
  retval___3 = generate_BDepot___3();
  }
#line 812
  if (retval___3) {
#line 812
    return (retval___3);
  }
  {
#line 814
  fclose(output_file___3);
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_header___3(void) 
{ 
  unsigned int identifier1 ;
  unsigned int identifier2 ;
  unsigned int U32magiczero ;
  unsigned int U32magic1 ;
  unsigned int U32magic2 ;
  unsigned int U32magic3 ;
  unsigned int U32magic4 ;
  unsigned int U32magic5 ;
  unsigned int U32magic6 ;

  {
  {
#line 821
  identifier1 = 3759263696U;
#line 822
  identifier2 = 3776623009U;
#line 823
  U32magiczero = 0U;
#line 824
  U32magic1 = 196667U;
#line 825
  U32magic2 = 655358U;
#line 826
  U32magic3 = 6U;
#line 827
  U32magic4 = 4096U;
#line 828
  U32magic5 = 1U;
#line 829
  U32magic6 = 4294967294U;
#line 833
  calculate_blocks___3();
#line 835
  fil_swriteU32(output_block___3 + 48, & Root_start_block___3);
#line 836
  fil_swriteU32(output_block___3 + 60, & SDepot_start_block___3);
#line 837
  fil_swriteU32(output_block___3 + 44, & BDepot_blocks___3);
#line 839
  fil_swriteU32(output_block___3 + 0, & identifier1);
#line 840
  fil_swriteU32(output_block___3 + 4, & identifier2);
#line 841
  fil_swriteU32(output_block___3 + 8, & U32magiczero);
#line 842
  fil_swriteU32(output_block___3 + 12, & U32magiczero);
#line 843
  fil_swriteU32(output_block___3 + 16, & U32magiczero);
#line 844
  fil_swriteU32(output_block___3 + 20, & U32magiczero);
#line 845
  fil_swriteU32(output_block___3 + 24, & U32magic1);
#line 846
  fil_swriteU32(output_block___3 + 28, & U32magic2);
#line 847
  fil_swriteU32(output_block___3 + 32, & U32magic3);
#line 848
  fil_swriteU32(output_block___3 + 36, & U32magiczero);
#line 849
  fil_swriteU32(output_block___3 + 40, & U32magiczero);
#line 850
  fil_swriteU32(output_block___3 + 52, & U32magiczero);
#line 851
  fil_swriteU32(output_block___3 + 56, & U32magic4);
#line 852
  fil_swriteU32(output_block___3 + 64, & U32magic5);
#line 853
  fil_swriteU32(output_block___3 + 68, & U32magic6);
#line 854
  fil_swriteU32(output_block___3 + 72, & U32magiczero);
#line 856
  pos_block___3 = (unsigned short)76;
  }
#line 858
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_recursive___3(MY_FILE *list ) 
{ 
  MY_FILE *p_MY_FILE_list ;
  int retval ;
  int retval___0 ;
  size_t tmp ;
  int retval___1 ;

  {
  {
#line 873
  if ((unsigned int )list->type == 1U) {
#line 873
    goto case_1;
  }
#line 881
  if ((unsigned int )list->type == 2U) {
#line 881
    goto case_2;
  }
#line 898
  if ((unsigned int )list->type == 3U) {
#line 898
    goto case_3;
  }
#line 903
  if ((unsigned int )list->type == 0U) {
#line 903
    goto case_0;
  }
#line 908
  goto switch_default;
  case_1: /* CIL Label */ 
#line 874
  p_MY_FILE_list = list->file.MY_FILE_list;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! ((unsigned int )((unsigned char *)p_MY_FILE_list - list->file.root_list) < list->size)) {
#line 874
      goto while_break;
    }
    {
#line 877
    retval = generate_recursive___3(p_MY_FILE_list);
    }
#line 877
    if (retval) {
#line 877
      return (retval);
    }
#line 874
    p_MY_FILE_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  goto switch_break;
  case_2: /* CIL Label */ 
#line 882
  if ((unsigned long )list == (unsigned long )bbd_list___3) {
    {
#line 884
    retval___0 = write_block_list___3(BDepot_start_block___3, bbd_list___3, 0);
    }
#line 884
    if (retval___0) {
#line 884
      return (retval___0);
    }
#line 885
    if ((int )pos_block___3 != 0) {
#line 885
      if ((int )pos_block___3 % 512) {
        {
#line 885
        memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 512 + 1) * 512 - (int )pos_block___3));
        }
      }
      {
#line 885
      tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                   (size_t )512, (FILE */* __restrict  */)output_file___3);
      }
#line 885
      if (! (tmp == 512UL)) {
#line 885
        return (1);
      }
#line 885
      next_block___3 ++;
#line 885
      pos_block___3 = (unsigned short)0;
    }
#line 886
    goto switch_break;
  } else
#line 888
  if ((unsigned long )list == (unsigned long )BDepot___8) {
#line 890
    goto switch_break;
  } else
#line 891
  if ((unsigned long )list == (unsigned long )SDepot___8) {
#line 893
    goto switch_break;
  } else
#line 895
  if (! ((unsigned long )"list->type==block_list but list UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 895
    __assert_fail("\"list->type==block_list but list UNKNOWN in generate_recursive\"==((void *)0)",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  895U, "generate_recursive");
    }
  }
  case_3: /* CIL Label */ 
#line 900
  if (! ((unsigned long )list == (unsigned long )Root___8)) {
    {
#line 900
    __assert_fail("list == Root", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  900U, "generate_recursive");
    }
  }
#line 901
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 905
  retval___1 = generate_real_file___3(list);
  }
#line 905
  if (retval___1) {
#line 905
    return (retval___1);
  }
#line 906
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 909
  if (! ((unsigned long )"list->type UNKNOWN in generate_recursive" == (unsigned long )((void *)0))) {
    {
#line 909
    __assert_fail("\"list->type UNKNOWN in generate_recursive\" == ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  909U, "generate_recursive");
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 912
  return (0);
}
}
#line 916 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_SDepot___3(void) 
{ 
  int retval ;
  size_t tmp ;

  {
  {
#line 920
  retval = write_block_list___3(1U, SDepot___8, 1);
  }
#line 920
  if (retval) {
#line 920
    return (retval);
  }
#line 921
  if ((int )pos_block___3 != 0) {
#line 921
    if ((int )pos_block___3 % 512) {
      {
#line 921
      memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 512 + 1) * 512 - (int )pos_block___3));
      }
    }
    {
#line 921
    tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___3);
    }
#line 921
    if (! (tmp == 512UL)) {
#line 921
      return (1);
    }
#line 921
    next_block___3 ++;
#line 921
    pos_block___3 = (unsigned short)0;
  }
#line 923
  return (0);
}
}
#line 927 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_Root___3(void) 
{ 
  int retval ;
  int zzzi ;
  unsigned short U16zero ;
  size_t tmp ;

  {
  {
#line 931
  retval = write_root_list___3(Root___8);
  }
#line 931
  if (retval) {
#line 931
    return (retval);
  }
#line 932
  if ((int )pos_block___3 != 0) {
    {
#line 932
    U16zero = (unsigned short)0;
#line 932
    memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(512 - (int )pos_block___3));
#line 932
    zzzi = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 932
      if (! (zzzi < 4)) {
#line 932
        goto while_break;
      }
#line 932
      if (zzzi * 128 >= (int )pos_block___3) {
        {
#line 932
        fil_swriteU16((output_block___3 + zzzi * 128) + 64, & U16zero);
        }
      }
#line 932
      zzzi ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 933
  if ((int )pos_block___3 != 0) {
    {
#line 933
    tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                 (size_t )512, (FILE */* __restrict  */)output_file___3);
    }
#line 933
    if (! (tmp == 512UL)) {
#line 933
      return (1);
    }
#line 933
    next_block___3 ++;
#line 933
    pos_block___3 = (unsigned short)0;
  }
#line 935
  return (0);
}
}
#line 938 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_BDepot___3(void) 
{ 
  MY_FILE SDepot_and_Root_block_list ;
  MY_FILE file_block_list ;
  unsigned int next_block_link ;
  int retval ;
  int retval___0 ;
  unsigned int tmp ;
  int retval___1 ;
  size_t tmp___0 ;

  {
#line 946
  next_block_link = (unsigned int )((4294967295UL + (unsigned long )header_blocks___3) + 1UL);
#line 950
  if (! (next_block_link == sbfile_start_block___3 + 1U)) {
    {
#line 950
    __assert_fail("next_block_link == sbfile_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  950U, "generate_BDepot");
    }
  }
  {
#line 952
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 952
  file_block_list.size = (unsigned int )sizeof(unsigned int );
#line 952
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 952
  file_block_list.file.block_list = BDepot___8->file.block_list;
#line 955
  retval = write_block_list___3(next_block_link, & file_block_list, 1);
  }
#line 955
  if (retval) {
#line 955
    return (retval);
  }
#line 958
  next_block_link += sbfile_blocks___3;
#line 961
  if (! (next_block_link == (sbfile_start_block___3 + sbfile_blocks___3) + 1U)) {
    {
#line 961
    __assert_fail("next_block_link == sbfile_start_block + sbfile_blocks + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  961U, "generate_BDepot");
    }
  }
  {
#line 963
  file_block_list.type = (enum __anonenum_type_26 )2;
#line 963
  file_block_list.size = (unsigned int )((unsigned long )BDepot___8->size - 3UL * sizeof(unsigned int ));
#line 963
  file_block_list.blocks = (unsigned int *)((void *)0);
#line 963
  file_block_list.file.block_list = BDepot___8->file.block_list + 3;
#line 965
  retval___0 = write_block_list___3(next_block_link, & file_block_list, 1);
  }
#line 965
  if (retval___0) {
#line 965
    return (retval___0);
  }
  {
#line 968
  tmp = sum_block_list___3(& file_block_list);
#line 968
  next_block_link += tmp;
  }
#line 971
  if (sbfile___8->size > 0U) {
#line 973
    if (! (next_block_link == SDepot_start_block___3 + 1U)) {
      {
#line 973
      __assert_fail("next_block_link == SDepot_start_block + 1", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    973U, "generate_BDepot");
      }
    }
  }
  {
#line 975
  SDepot_and_Root_block_list.type = (enum __anonenum_type_26 )2;
#line 975
  SDepot_and_Root_block_list.size = (unsigned int )(2UL * sizeof(unsigned int ));
#line 975
  SDepot_and_Root_block_list.blocks = (unsigned int *)((void *)0);
#line 975
  SDepot_and_Root_block_list.file.block_list = BDepot___8->file.block_list + 1;
#line 977
  retval___1 = write_block_list___3(next_block_link, & SDepot_and_Root_block_list,
                                    1);
  }
#line 977
  if (retval___1) {
#line 977
    return (retval___1);
  }
#line 980
  if ((int )pos_block___3 != 0) {
#line 980
    if ((int )pos_block___3 % 512) {
      {
#line 980
      memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 512 + 1) * 512 - (int )pos_block___3));
      }
    }
    {
#line 980
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___3);
    }
#line 980
    if (! (tmp___0 == 512UL)) {
#line 980
      return (1);
    }
#line 980
    next_block___3 ++;
#line 980
    pos_block___3 = (unsigned short)0;
  }
#line 982
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static unsigned int last_small_stream_next_block___3  =    0U;
#line 993 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_start_block_set___3  =    0;
#line 994 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int sbfile_may_need_write_until_boundary___3  =    0;
#line 985 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int generate_real_file___3(MY_FILE *MY_FILE_file ) 
{ 
  FILE *file ;
  int n_read ;
  unsigned char *pps ;
  unsigned int total_bytes ;
  unsigned int sbfile_size ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 1004
  if (! ((int )pos_block___3 <= 512)) {
    {
#line 1004
    __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1004U, "generate_real_file");
    }
  }
#line 1005
  if (! ((int )pos_block___3 % 64 == 0)) {
    {
#line 1005
    __assert_fail("pos_block % 0x40 == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1005U, "generate_real_file");
    }
  }
#line 1008
  if (! *(MY_FILE_file->file.real.name + 0)) {
    {
#line 1008
    __assert_fail("MY_FILE_file->file.real.name[0]", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1008U, "generate_real_file");
    }
  }
  {
#line 1009
  file = fopen((char const   */* __restrict  */)MY_FILE_file->file.real.name, (char const   */* __restrict  */)"rb");
  }
#line 1010
  if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 1010
    return (11);
  }
#line 1013
  if (MY_FILE_file->size >= 4096U) {
#line 1018
    if (sbfile_may_need_write_until_boundary___3) {
#line 1022
      if ((int )pos_block___3 != 0) {
#line 1022
        if ((int )pos_block___3 % 512) {
          {
#line 1022
          memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 512 + 1) * 512 - (int )pos_block___3));
          }
        }
        {
#line 1022
        tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                     (size_t )512, (FILE */* __restrict  */)output_file___3);
        }
#line 1022
        if (! (tmp == 512UL)) {
#line 1022
          return (1);
        }
#line 1022
        next_block___3 ++;
#line 1022
        pos_block___3 = (unsigned short)0;
      }
#line 1023
      sbfile_may_need_write_until_boundary___3 = 0;
    }
    {
#line 1029
    pps = Root___8->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1030
    fil_swriteU32(pps + 116, & next_block___3);
    }
  } else {
    {
#line 1039
    pps = Root___8->file.root_list + MY_FILE_file->file.real.ppsnumber * 128U;
#line 1040
    fil_swriteU32(pps + 116, & last_small_stream_next_block___3);
#line 1041
    last_small_stream_next_block___3 += *(MY_FILE_file->blocks);
    }
#line 1044
    if (! sbfile_start_block_set___3) {
#line 1050
      if (! (sbfile_start_block___3 == next_block___3)) {
        {
#line 1050
        __assert_fail("sbfile_start_block == next_block", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1050U, "generate_real_file");
        }
      }
      {
#line 1051
      fil_swriteU32(Root___8->file.root_list + 116, & next_block___3);
#line 1053
      tmp___0 = sum_blocks_MY_FILE_list___3(sbfile___8);
#line 1053
      sbfile_size = tmp___0 * 64U;
#line 1056
      tmp___1 = fil_sreadU32(Root___8->file.root_list + 120);
      }
#line 1056
      if (! (sbfile_size == tmp___1)) {
        {
#line 1056
        __assert_fail("sbfile_size == fil_sreadU32 (Root->file.root_list + 0x78)",
                      "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1056U, "generate_real_file");
        }
      }
#line 1058
      sbfile_start_block_set___3 = 1;
#line 1059
      sbfile_may_need_write_until_boundary___3 = 1;
    }
  }
#line 1064
  total_bytes = 0U;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1066
    tmp___6 = feof(file);
    }
#line 1066
    if (tmp___6) {
#line 1066
      goto while_break;
    }
    {
#line 1068
    tmp___2 = fread((void */* __restrict  */)(output_block___3 + (int )pos_block___3),
                    (size_t )1, (size_t )(512 - (int )pos_block___3), (FILE */* __restrict  */)file);
#line 1068
    n_read = (int )tmp___2;
#line 1069
    tmp___3 = ferror(file);
    }
#line 1069
    if (tmp___3) {
#line 1069
      return (11);
    }
#line 1070
    if (n_read < 512 - (int )pos_block___3) {
      {
#line 1072
      tmp___4 = feof(file);
      }
#line 1072
      if (! tmp___4) {
        {
#line 1072
        __assert_fail("feof (file)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1072U, "generate_real_file");
        }
      }
    }
#line 1073
    pos_block___3 = (unsigned short )((int )pos_block___3 + (int )((unsigned short )n_read));
#line 1074
    total_bytes += (unsigned int )n_read;
#line 1075
    if ((int )pos_block___3 == 512) {
      {
#line 1075
      tmp___5 = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )512,
                       (size_t )1, (FILE */* __restrict  */)output_file___3);
      }
#line 1075
      if (! (tmp___5 == 1UL)) {
#line 1075
        return (1);
      }
#line 1075
      next_block___3 ++;
#line 1075
      pos_block___3 = (unsigned short)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (! (total_bytes == MY_FILE_file->size)) {
#line 1077
    return (12);
  }
#line 1079
  if (MY_FILE_file->size >= 4096U) {
#line 1081
    if ((int )pos_block___3 != 0) {
#line 1081
      if ((int )pos_block___3 % 512) {
        {
#line 1081
        memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 512 + 1) * 512 - (int )pos_block___3));
        }
      }
      {
#line 1081
      tmp___7 = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )1,
                       (size_t )512, (FILE */* __restrict  */)output_file___3);
      }
#line 1081
      if (! (tmp___7 == 512UL)) {
#line 1081
        return (1);
      }
#line 1081
      next_block___3 ++;
#line 1081
      pos_block___3 = (unsigned short)0;
    }
  } else
#line 1084
  if ((int )pos_block___3 % 64) {
    {
#line 1084
    memset((void *)(output_block___3 + (int )pos_block___3), 255, (size_t )(((int )pos_block___3 / 64 + 1) * 64 - (int )pos_block___3));
    }
#line 1084
    if (! (((int )pos_block___3 + ((int )pos_block___3 / 64 + 1) * 64) - (int )pos_block___3 == ((int )pos_block___3 / 64 + 1) * 64)) {
      {
#line 1084
      __assert_fail("pos_block+(pos_block/0x40 + 1)*0x40 - pos_block == (pos_block/0x40 + 1)*0x40",
                    "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1084U, "generate_real_file");
      }
    }
#line 1084
    pos_block___3 = (unsigned short )((int )pos_block___3 + (int )((unsigned short )(((int )pos_block___3 / 64 + 1) * 64 - (int )pos_block___3)));
  }
  {
#line 1087
  fclose(file);
  }
#line 1089
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_block_list___3(unsigned int start_count , MY_FILE *list , int write_end_chain ) 
{ 
  unsigned int *p ;
  unsigned int n ;
  unsigned int end_chain ;
  unsigned int value_to_write ;
  unsigned int delta ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1098
  end_chain = 4294967294U;
#line 1104
  if (! ((unsigned int )list->type == 2U)) {
    {
#line 1104
    __assert_fail("list->type == block_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1104U, "write_block_list");
    }
  }
#line 1105
  if (! ((int )pos_block___3 <= 508)) {
    {
#line 1105
    __assert_fail("pos_block <= 0x01fc", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1105U, "write_block_list");
    }
  }
#line 1107
  delta = start_count;
#line 1108
  if (list->size == 0U) {
#line 1108
    return (0);
  }
#line 1109
  p = list->file.block_list;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! ((unsigned int )((unsigned char *)p - (unsigned char *)list->file.block_list) < list->size)) {
#line 1109
      goto while_break;
    }
#line 1112
    n = 0U;
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1112
      if (! (n < *p)) {
#line 1112
        goto while_break___0;
      }
#line 1115
      if ((int )pos_block___3 == 512) {
        {
#line 1115
        tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___3);
        }
#line 1115
        if (! (tmp == 1UL)) {
#line 1115
          return (1);
        }
#line 1115
        next_block___3 ++;
#line 1115
        pos_block___3 = (unsigned short)0;
      }
#line 1118
      if (write_end_chain) {
#line 1118
        if (! (n + 1U < *p)) {
#line 1119
          value_to_write = end_chain;
        } else {
#line 1121
          value_to_write = n + delta;
        }
      } else {
#line 1121
        value_to_write = n + delta;
      }
      {
#line 1122
      fil_swriteU32(output_block___3 + (int )pos_block___3, & value_to_write);
#line 1123
      pos_block___3 = (unsigned short )((int )pos_block___3 + (int )((unsigned short )sizeof(unsigned int )));
      }
#line 1124
      if (! ((int )pos_block___3 <= 512)) {
        {
#line 1124
        __assert_fail("pos_block <= 0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                      1124U, "write_block_list");
        }
      }
#line 1112
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1126
    delta += n;
#line 1109
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1128
  if ((int )pos_block___3 == 512) {
    {
#line 1128
    tmp___0 = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )512,
                     (size_t )1, (FILE */* __restrict  */)output_file___3);
    }
#line 1128
    if (! (tmp___0 == 1UL)) {
#line 1128
      return (1);
    }
#line 1128
    next_block___3 ++;
#line 1128
    pos_block___3 = (unsigned short)0;
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static int write_root_list___3(MY_FILE *list ) 
{ 
  unsigned char *p ;
  size_t tmp ;

  {
#line 1139
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 1139
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1139U, "write_root_list");
    }
  }
#line 1140
  if (! ((int )pos_block___3 == 0)) {
    {
#line 1140
    __assert_fail("pos_block == 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1140U, "write_root_list");
    }
  }
#line 1141
  if (! ((unsigned int )list->type == 3U)) {
    {
#line 1141
    __assert_fail("list->type == root_list", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1141U, "write_root_list");
    }
  }
#line 1142
  if (! (list->size > 0U)) {
    {
#line 1142
    __assert_fail("list->size > 0", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1142U, "write_root_list");
    }
  }
#line 1144
  p = list->file.root_list;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (! ((unsigned int )(p - list->file.root_list) < list->size)) {
#line 1144
      goto while_break;
    }
    {
#line 1147
    memcpy((void */* __restrict  */)(output_block___3 + (p - list->file.root_list) % 512L),
           (void const   */* __restrict  */)p, (size_t )128);
#line 1169
    pos_block___3 = (unsigned short )((int )pos_block___3 + 128);
    }
#line 1170
    if (! ((int )pos_block___3 <= 512)) {
      {
#line 1170
      __assert_fail("pos_block <= (unsigned short)0x0200", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                    1170U, "write_root_list");
      }
    }
#line 1171
    if ((int )pos_block___3 == 512) {
      {
#line 1171
      tmp = fwrite((void const   */* __restrict  */)(output_block___3), (size_t )512,
                   (size_t )1, (FILE */* __restrict  */)output_file___3);
      }
#line 1171
      if (! (tmp == 1UL)) {
#line 1171
        return (1);
      }
#line 1171
      next_block___3 ++;
#line 1171
      pos_block___3 = (unsigned short)0;
    }
#line 1144
    p += 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void ends___8(void) 
{ 


  {
#line 1193
  if ((unsigned long )output_file___3 != (unsigned long )((void *)0)) {
    {
#line 1194
    fclose(output_file___3);
    }
  }
#line 1195
  return;
}
}
#line 1198 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c"
static void calculate_blocks___3(void) 
{ 
  MY_FILE big_streams_list ;
  unsigned int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1205
  big_streams_list.type = (enum __anonenum_type_26 )1;
#line 1205
  big_streams_list.size = (unsigned int )((unsigned long )Input___3.size - 5UL * sizeof(MY_FILE ));
#line 1205
  big_streams_list.blocks = (unsigned int *)((void *)0);
#line 1205
  big_streams_list.file.MY_FILE_list = Input___3.file.MY_FILE_list + 5;
#line 1211
  if (! (*(BDepot___8->blocks) == *(bbd_list___3->file.block_list))) {
    {
#line 1211
    __assert_fail("*(BDepot->blocks) == *(bbd_list->file.block_list)", "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1211U, "calculate_blocks");
    }
  }
#line 1212
  if (! Root___8->size) {
#line 1212
    tmp = 1U;
  } else {
#line 1212
    tmp = 1U + (Root___8->size - 1U) / 512U;
  }
#line 1212
  if (! (*(Root___8->blocks) == tmp)) {
    {
#line 1212
    __assert_fail("*(Root->blocks) == (!(Root->size) ? 1 : (1+((Root->size)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1212U, "calculate_blocks");
    }
  }
  {
#line 1215
  tmp___3 = sum_blocks_MY_FILE_list___3(sbfile___8);
  }
#line 1215
  if (tmp___3 * 64U) {
    {
#line 1215
    tmp___1 = sum_blocks_MY_FILE_list___3(sbfile___8);
#line 1215
    tmp___2 = 1U + (tmp___1 * 64U - 1U) / 512U;
    }
  } else {
#line 1215
    tmp___2 = 0U;
  }
#line 1215
  if (! (*(sbfile___8->blocks) == tmp___2)) {
    {
#line 1215
    __assert_fail("*(sbfile->blocks) == (!(sum_blocks_MY_FILE_list (sbfile) * 0x40) ? 0 : (1+((sum_blocks_MY_FILE_list (sbfile) * 0x40)-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1216U, "calculate_blocks");
    }
  }
  {
#line 1217
  tmp___7 = sum_block_list___3(SDepot___8);
  }
#line 1217
  if ((unsigned long )tmp___7 * sizeof(unsigned int )) {
    {
#line 1217
    tmp___5 = sum_block_list___3(SDepot___8);
#line 1217
    tmp___6 = 1UL + ((unsigned long )tmp___5 * sizeof(unsigned int ) - 1UL) / 512UL;
    }
  } else {
#line 1217
    tmp___6 = 0UL;
  }
#line 1217
  if (! ((unsigned long )*(SDepot___8->blocks) == tmp___6)) {
    {
#line 1217
    __assert_fail("*(SDepot->blocks) == (!((sum_block_list (SDepot) * sizeof (unsigned int))) ? 0 : (1+(((sum_block_list (SDepot) * sizeof (unsigned int)))-1)/(0x0200)))",
                  "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/olecod.c",
                  1218U, "calculate_blocks");
    }
  }
  {
#line 1219
  BDepot_blocks___3 = *(BDepot___8->blocks);
#line 1220
  SDepot_blocks___3 = *(SDepot___8->blocks);
#line 1221
  Root_blocks___3 = *(Root___8->blocks);
#line 1222
  sbfile_blocks___3 = *(sbfile___8->blocks);
#line 1223
  big_streams_blocks___3 = sum_blocks_MY_FILE_list___3(& big_streams_list);
  }
#line 1224
  if (! ((unsigned long )(19U + BDepot_blocks___3) * sizeof(unsigned int ))) {
#line 1224
    header_blocks___3 = 1U;
  } else {
#line 1224
    header_blocks___3 = (unsigned int )(1UL + ((unsigned long )(19U + BDepot_blocks___3) * sizeof(unsigned int ) - 1UL) / 512UL);
  }
#line 1228
  sbfile_start_block___3 = (unsigned int )(4294967295UL + (unsigned long )header_blocks___3);
#line 1230
  Root_start_block___3 = (unsigned int )((((4294967295UL + (unsigned long )header_blocks___3) + (unsigned long )sbfile_blocks___3) + (unsigned long )big_streams_blocks___3) + (unsigned long )SDepot_blocks___3);
#line 1233
  if (SDepot_blocks___3 > 0U) {
#line 1235
    SDepot_start_block___3 = (unsigned int )(((4294967295UL + (unsigned long )header_blocks___3) + (unsigned long )sbfile_blocks___3) + (unsigned long )big_streams_blocks___3);
  } else {
#line 1239
    SDepot_start_block___3 = 4294967294U;
  }
#line 1240
  BDepot_start_block___3 = (unsigned int )(((((4294967295UL + (unsigned long )header_blocks___3) + (unsigned long )sbfile_blocks___3) + (unsigned long )big_streams_blocks___3) + (unsigned long )SDepot_blocks___3) + (unsigned long )Root_blocks___3);
#line 1247
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___3(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 222
static int __cole_print_tree_outdir___3(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 223
static int __cole_print_tree_inroot___3(COLEDIR *cd , void *info , COLERRNO *colerrno ) ;
#line 224
static int __cole_print_tree_indirentry___3(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) ;
#line 242 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indir___3(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 250
  (*((long *)info)) ++;
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_outdir___3(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 


  {
#line 262
  (*((long *)info)) --;
#line 263
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_inroot___3(COLEDIR *cd , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 276
  printf((char const   */* __restrict  */)"DIR ");
#line 277
  tmp = cole_dir_getsize(cd);
#line 277
  printf((char const   */* __restrict  */)" %7zu", tmp);
#line 278
  tmp___0 = cole_dir_getsec2(cd);
#line 278
  tmp___1 = cole_dir_getdays2(cd);
#line 278
  tmp___2 = cole_dir_getsec1(cd);
#line 278
  tmp___3 = cole_dir_getdays1(cd);
#line 278
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___3, tmp___2,
         tmp___1, tmp___0);
#line 283
  entry_name = cole_dir_getname(cd);
#line 284
  tmp___4 = __ctype_b_loc();
  }
#line 284
  if ((int const   )*(*tmp___4 + (int )*(entry_name + 0)) & 16384) {
    {
#line 287
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 285
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_print_tree_indirentry___3(COLEDIRENT *cde , void *info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  long level ;
  long i ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 304
  level = *((long *)info);
#line 305
  i = 0L;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < level)) {
#line 305
      goto while_break;
    }
#line 306
    if (i == level - 1L) {
      {
#line 307
      printf((char const   */* __restrict  */)"\\--");
      }
    } else {
      {
#line 309
      printf((char const   */* __restrict  */)"|  ");
      }
    }
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  tmp___0 = cole_direntry_isdir(cde);
  }
#line 312
  if (tmp___0) {
    {
#line 313
    printf((char const   */* __restrict  */)"DIR ");
    }
  } else {
    {
#line 314
    tmp = cole_direntry_isfile(cde);
    }
#line 314
    if (tmp) {
      {
#line 315
      printf((char const   */* __restrict  */)"FILE");
      }
    } else {
      {
#line 317
      printf((char const   */* __restrict  */)"????");
      }
    }
  }
  {
#line 318
  tmp___1 = cole_direntry_getsize(cde);
#line 318
  printf((char const   */* __restrict  */)" %7zu", tmp___1);
#line 319
  tmp___2 = cole_direntry_getsec2(cde);
#line 319
  tmp___3 = cole_direntry_getdays2(cde);
#line 319
  tmp___4 = cole_direntry_getsec1(cde);
#line 319
  tmp___5 = cole_direntry_getdays1(cde);
#line 319
  printf((char const   */* __restrict  */)" %08lx-%08lx %08lx-%08lx", tmp___5, tmp___4,
         tmp___3, tmp___2);
#line 324
  entry_name = cole_direntry_getname(cde);
#line 325
  tmp___6 = __ctype_b_loc();
  }
#line 325
  if ((int const   )*(*tmp___6 + (int )*(entry_name + 0)) & 16384) {
    {
#line 328
    printf((char const   */* __restrict  */)" \'%s\'\n", entry_name);
    }
  } else {
    {
#line 326
    printf((char const   */* __restrict  */)" \'\\x%02x%s\'\n", (int )*(entry_name + 0),
           entry_name + 1);
    }
  }
#line 330
  return (0);
}
}
#line 585
static void _cole_fopen_action___3(COLEDIRENT *cde , void *_info ) ;
#line 605 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static void _cole_fopen_action___3(COLEDIRENT *cde , void *_info ) 
{ 
  struct _cole_fopen_info *info ;
  int tmp ;

  {
  {
#line 610
  info = (struct _cole_fopen_info *)_info;
#line 612
  tmp = cole_direntry_isfile(cde);
  }
#line 612
  if (! tmp) {
#line 613
    info->colerrno = (COLERRNO )18;
#line 614
    info->succ = 0;
#line 615
    return;
  }
  {
#line 618
  info->file = cole_fopen_direntry(cde, & info->colerrno);
  }
#line 619
  if ((unsigned long )info->file == (unsigned long )((void *)0)) {
#line 621
    info->succ = 0;
#line 622
    return;
  }
#line 625
  info->succ = 1;
#line 626
  return;
}
}
#line 948
static int __cole_recurse_tree___3(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) ;
#line 986 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_recurse_tree___3(COLEDIR *_cd , long level , void *info , COLE_RECURSE_DIR_FUNC *inroot ,
                                   COLE_RECURSE_DIRENT_FUNC *indirentry , COLE_RECURSE_DIR_FUNC *indir ,
                                   COLE_RECURSE_DIR_FUNC *outdir , COLE_RECURSE_VISIT_DIR_FUNC *visitdir ,
                                   COLERRNO *colerrno ) 
{ 
  COLEDIRENT *cde ;
  COLEDIR *cd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1007
  if (level == 1L) {
#line 1009
    if ((unsigned long )inroot != (unsigned long )((void *)0)) {
      {
#line 1010
      tmp = (*inroot)(_cd, info, colerrno);
      }
#line 1010
      if (tmp) {
#line 1012
        return (1);
      }
    }
  }
  {
#line 1018
  cde = cole_visiteddirentry(_cd);
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned long )cde != (unsigned long )((void *)0))) {
#line 1018
      goto while_break;
    }
#line 1020
    if ((unsigned long )indirentry != (unsigned long )((void *)0)) {
      {
#line 1021
      tmp___0 = (*indirentry)(cde, info, colerrno);
      }
#line 1021
      if (tmp___0) {
#line 1023
        return (1);
      }
    }
    {
#line 1028
    tmp___6 = cole_direntry_isdir(cde);
    }
#line 1028
    if (tmp___6) {
      {
#line 1029
      cd = cole_opendir_direntry(cde, colerrno);
      }
#line 1030
      if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 1032
        return (1);
      }
#line 1035
      if ((unsigned long )indir != (unsigned long )((void *)0)) {
        {
#line 1036
        tmp___1 = (*indir)(cd, info, colerrno);
        }
#line 1036
        if (tmp___1) {
          {
#line 1038
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1039
          return (1);
        }
      }
#line 1043
      if ((unsigned long )visitdir == (unsigned long )((void *)0)) {
#line 1043
        goto _L;
      } else {
        {
#line 1043
        tmp___3 = (*visitdir)(cd, info);
        }
#line 1043
        if (tmp___3) {
          _L: /* CIL Label */ 
          {
#line 1045
          tmp___2 = __cole_recurse_tree___3(cd, level + 1L, info, inroot, indirentry,
                                            indir, outdir, visitdir, colerrno);
          }
#line 1045
          if (tmp___2) {
            {
#line 1050
            cole_closedir(cd, (COLERRNO *)((void *)0));
            }
#line 1051
            return (1);
          }
        }
      }
#line 1055
      if ((unsigned long )outdir != (unsigned long )((void *)0)) {
        {
#line 1056
        tmp___4 = (*outdir)(cd, info, colerrno);
        }
#line 1056
        if (tmp___4) {
          {
#line 1058
          cole_closedir(cd, (COLERRNO *)((void *)0));
          }
#line 1059
          return (1);
        }
      }
      {
#line 1063
      tmp___5 = cole_closedir(cd, colerrno);
      }
#line 1063
      if (tmp___5) {
#line 1065
        return (1);
      }
    }
    {
#line 1018
    cde = cole_nextdirentry(_cd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return (0);
}
}
#line 1098
static int __cole_locate_filename_indirentry___3(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) ;
#line 1099
static int __cole_locate_filename_visitdir___3(COLEDIR *cd , void *info ) ;
#line 1136 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_visitdir___3(COLEDIR *cd , void *info ) 
{ 


  {
#line 1139
  return (((struct __cole_locate_filenameinfo *)info)->visitdir);
}
}
#line 1142 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/cole/cole.c"
static int __cole_locate_filename_indirentry___3(COLEDIRENT *cde , void *_info , COLERRNO *colerrno ) 
{ 
  char *entry_name ;
  struct __cole_locate_filenameinfo *info ;
  char *pcurrent ;
  char *pentry_name ;
  int tmp ;

  {
  {
#line 1151
  info = (struct __cole_locate_filenameinfo *)_info;
#line 1152
  entry_name = cole_direntry_getname(cde);
#line 1153
  pcurrent = info->current;
#line 1153
  pentry_name = entry_name;
  }
  {
#line 1153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1153
    if (*pcurrent) {
#line 1153
      if (*pentry_name) {
#line 1153
        if (! ((int )*pcurrent != 47)) {
#line 1153
          goto while_break;
        }
      } else {
#line 1153
        goto while_break;
      }
    } else {
#line 1153
      goto while_break;
    }
#line 1156
    if ((int )*pcurrent != (int )*pentry_name) {
#line 1157
      info->visitdir = 0;
#line 1158
      return (0);
    }
#line 1153
    pcurrent ++;
#line 1153
    pentry_name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1162
  if ((int )*pentry_name == 0) {
#line 1162
    goto case_0;
  }
#line 1197
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 1164
  if ((int )*pcurrent == 47) {
#line 1164
    goto case_47;
  }
#line 1185
  if ((int )*pcurrent == 0) {
#line 1185
    goto case_0___0;
  }
#line 1193
  goto switch_default;
  case_47: /* CIL Label */ 
  {
#line 1165
  tmp = cole_direntry_isdir(cde);
  }
#line 1165
  if (! tmp) {
#line 1166
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1167
      *colerrno = (COLERRNO )16;
    }
#line 1168
    return (1);
  }
#line 1170
  pcurrent ++;
#line 1171
  info->current = pcurrent;
#line 1174
  if (! *(info->current)) {
#line 1176
    if ((unsigned long )info->action != (unsigned long )((void *)0)) {
      {
#line 1177
      (*(info->action))(cde, info->info);
      }
    }
#line 1180
    if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1180
      *colerrno = (COLERRNO )23;
    }
#line 1181
    return (1);
  }
#line 1183
  info->visitdir = 1;
#line 1184
  return (0);
  case_0___0: /* CIL Label */ 
#line 1187
  if ((unsigned long )info->action != (unsigned long )((void *)0)) {
    {
#line 1188
    (*(info->action))(cde, info->info);
    }
  }
#line 1191
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1191
    *colerrno = (COLERRNO )23;
  }
#line 1192
  return (1);
  switch_default: /* CIL Label */ 
#line 1194
  info->visitdir = 0;
#line 1195
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 1199
  if ((int )*pcurrent == 0) {
#line 1199
    goto case_0___1;
  }
#line 1202
  if ((int )*pcurrent == 47) {
#line 1202
    goto case_47___0;
  }
#line 1205
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 1200
  info->visitdir = 0;
#line 1201
  return (0);
  case_47___0: /* CIL Label */ 
#line 1203
  info->visitdir = 0;
#line 1204
  return (0);
  switch_default___1: /* CIL Label */ 
#line 1206
  if ((unsigned long )colerrno != (unsigned long )((void *)0)) {
#line 1206
    *colerrno = (COLERRNO )21;
  }
#line 1207
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static char FileName___2[2][32]  = { {        (char )'/',        (char )'P',        (char )'o',        (char )'w', 
            (char )'e',        (char )'r',        (char )'P',        (char )'o', 
            (char )'i',        (char )'n',        (char )'t',        (char )' ', 
            (char )'D',        (char )'o',        (char )'c',        (char )'u', 
            (char )'m',        (char )'e',        (char )'n',        (char )'t', 
            (char )'\000'}, 
   {        (char )'/',        (char )'P',        (char )'P',        (char )'4', 
            (char )'0',        (char )'\000'}};
#line 56
static void container_processor(int type ) ;
#line 57
static void atom_processor(int type , int count , int buf_last , unsigned char data ) ;
#line 58
static void print_unicode(unsigned char *ucs , int len ) ;
#line 59
static void print_utf8___0(unsigned short c ) ;
#line 60
static void put_utf8___0(unsigned short c ) ;
#line 63 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static char filename___3[128]  ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static unsigned char working_buffer___0[8192]  ;
#line 65 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static int buf_idx  =    0;
#line 66 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static int output_this_container  =    0;
#line 67 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static int past_first_slide  =    0;
#line 68 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static int last_container  =    0;
#line 209 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static void container_processor(int type ) 
{ 


  {
#line 211
  if (type == 1006) {
#line 213
    if (past_first_slide) {
      {
#line 214
      printf((char const   */* __restrict  */)"<BR><HR><BR>\n");
      }
    } else {
#line 216
      past_first_slide = 1;
    }
  }
  {
#line 220
  if (type == 13) {
#line 220
    goto case_13;
  }
#line 226
  if (type == 4080) {
#line 226
    goto case_4080;
  }
#line 229
  goto switch_default;
  case_13: /* CIL Label */ 
#line 221
  if (last_container == 17) {
#line 222
    output_this_container = 0;
  } else {
#line 224
    output_this_container = 1;
  }
#line 225
  goto switch_break;
  case_4080: /* CIL Label */ 
#line 227
  output_this_container = 1;
#line 228
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 231
  output_this_container = 0;
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 234
  last_container = type;
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static void atom_processor(int type , int count , int buf_last , unsigned char data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int i ;
  int tmp___1 ;

  {
#line 239
  if (buf_idx >= 8192) {
#line 240
    return;
  } else
#line 239
  if (output_this_container == 0) {
#line 240
    return;
  }
#line 242
  if (count == 0) {
    {
#line 244
    memset((void *)(working_buffer___0), 0, (size_t )8192);
#line 245
    buf_idx = 0;
    }
  }
  {
#line 250
  if (type == 4000) {
#line 250
    goto case_4000;
  }
#line 261
  if (type == 4008) {
#line 261
    goto case_4008;
  }
#line 279
  if (type == 4026) {
#line 279
    goto case_4026;
  }
#line 290
  goto switch_default;
  case_4000: /* CIL Label */ 
#line 251
  tmp = buf_idx;
#line 251
  buf_idx ++;
#line 251
  working_buffer___0[tmp] = data;
#line 252
  if (count == buf_last) {
    {
#line 257
    print_unicode(working_buffer___0, buf_idx);
#line 258
    printf((char const   */* __restrict  */)"<BR>\n");
    }
  }
#line 260
  goto switch_break;
  case_4008: /* CIL Label */ 
#line 262
  tmp___0 = buf_idx;
#line 262
  buf_idx ++;
#line 262
  working_buffer___0[tmp___0] = data;
#line 263
  if (count == buf_last) {
#line 268
    i = 0;
    {
#line 268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 268
      if (! (i < buf_idx)) {
#line 268
        goto while_break;
      }
#line 271
      if ((int )working_buffer___0[i] == 13) {
        {
#line 272
        printf((char const   */* __restrict  */)"<BR>\n");
        }
      } else {
        {
#line 274
        putchar((int )working_buffer___0[i]);
        }
      }
#line 268
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 276
    printf((char const   */* __restrict  */)"<BR>\n");
    }
  }
#line 278
  goto switch_break;
  case_4026: /* CIL Label */ 
#line 280
  tmp___1 = buf_idx;
#line 280
  buf_idx ++;
#line 280
  working_buffer___0[tmp___1] = data;
#line 281
  if (count == buf_last) {
    {
#line 286
    print_unicode(working_buffer___0, buf_idx);
#line 287
    printf((char const   */* __restrict  */)"<BR>\n");
    }
  }
#line 289
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 293
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static void print_unicode(unsigned char *ucs , int len ) 
{ 
  int i ;

  {
#line 298
  i = 0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < len)) {
#line 298
      goto while_break;
    }
    {
#line 299
    print_utf8___0((unsigned short )((int )*(ucs + i) | ((int )*(ucs + (i + 1)) << 8)));
#line 298
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static void OutputCharCorrected___0(unsigned char c ) 
{ 


  {
  {
#line 306
  if ((int )c == 13) {
#line 306
    goto case_13;
  }
#line 309
  if ((int )c == 60) {
#line 309
    goto case_60;
  }
#line 312
  if ((int )c == 62) {
#line 312
    goto case_62;
  }
#line 315
  if ((int )c == 38) {
#line 315
    goto case_38;
  }
#line 318
  if ((int )c == 34) {
#line 318
    goto case_34;
  }
#line 322
  if ((int )c == 128) {
#line 322
    goto case_128;
  }
#line 325
  if ((int )c == 130) {
#line 325
    goto case_130;
  }
#line 328
  if ((int )c == 131) {
#line 328
    goto case_131;
  }
#line 331
  if ((int )c == 132) {
#line 331
    goto case_132;
  }
#line 334
  if ((int )c == 133) {
#line 334
    goto case_133;
  }
#line 337
  if ((int )c == 134) {
#line 337
    goto case_134;
  }
#line 340
  if ((int )c == 135) {
#line 340
    goto case_135;
  }
#line 343
  if ((int )c == 136) {
#line 343
    goto case_136;
  }
#line 346
  if ((int )c == 137) {
#line 346
    goto case_137;
  }
#line 349
  if ((int )c == 138) {
#line 349
    goto case_138;
  }
#line 352
  if ((int )c == 139) {
#line 352
    goto case_139;
  }
#line 355
  if ((int )c == 140) {
#line 355
    goto case_140;
  }
#line 358
  if ((int )c == 142) {
#line 358
    goto case_142;
  }
#line 361
  if ((int )c == 145) {
#line 361
    goto case_145;
  }
#line 364
  if ((int )c == 146) {
#line 364
    goto case_146;
  }
#line 367
  if ((int )c == 147) {
#line 367
    goto case_147;
  }
#line 370
  if ((int )c == 148) {
#line 370
    goto case_148;
  }
#line 373
  if ((int )c == 149) {
#line 373
    goto case_149;
  }
#line 376
  if ((int )c == 150) {
#line 376
    goto case_150;
  }
#line 379
  if ((int )c == 151) {
#line 379
    goto case_151;
  }
#line 382
  if ((int )c == 152) {
#line 382
    goto case_152;
  }
#line 385
  if ((int )c == 153) {
#line 385
    goto case_153;
  }
#line 388
  if ((int )c == 154) {
#line 388
    goto case_154;
  }
#line 391
  if ((int )c == 155) {
#line 391
    goto case_155;
  }
#line 394
  if ((int )c == 156) {
#line 394
    goto case_156;
  }
#line 397
  if ((int )c == 159) {
#line 397
    goto case_159;
  }
#line 400
  goto switch_default;
  case_13: /* CIL Label */ 
  {
#line 307
  printf((char const   */* __restrict  */)"<BR>\n");
  }
#line 308
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 310
  printf((char const   */* __restrict  */)"&lt;");
  }
#line 311
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 313
  printf((char const   */* __restrict  */)"&gt;");
  }
#line 314
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 316
  printf((char const   */* __restrict  */)"&amp;");
  }
#line 317
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 319
  printf((char const   */* __restrict  */)"&quot;");
  }
#line 320
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 323
  printf((char const   */* __restrict  */)"&#8364;");
  }
#line 324
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 326
  printf((char const   */* __restrict  */)"&#8218;");
  }
#line 327
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 329
  printf((char const   */* __restrict  */)"&#402;");
  }
#line 330
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 332
  printf((char const   */* __restrict  */)"&#8222;");
  }
#line 333
  goto switch_break;
  case_133: /* CIL Label */ 
  {
#line 335
  printf((char const   */* __restrict  */)"&#8230;");
  }
#line 336
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 338
  printf((char const   */* __restrict  */)"&#8224;");
  }
#line 339
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 341
  printf((char const   */* __restrict  */)"&#8225;");
  }
#line 342
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 344
  printf((char const   */* __restrict  */)"&#710;");
  }
#line 345
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 347
  printf((char const   */* __restrict  */)"&#8240;");
  }
#line 348
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 350
  printf((char const   */* __restrict  */)"&#352;");
  }
#line 351
  goto switch_break;
  case_139: /* CIL Label */ 
  {
#line 353
  printf((char const   */* __restrict  */)"&#8249;");
  }
#line 354
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 356
  printf((char const   */* __restrict  */)"&#338;");
  }
#line 357
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 359
  printf((char const   */* __restrict  */)"&#381;");
  }
#line 360
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 362
  printf((char const   */* __restrict  */)"&#8216;");
  }
#line 363
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 365
  printf((char const   */* __restrict  */)"&#8217;");
  }
#line 366
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 368
  printf((char const   */* __restrict  */)"&#8220;");
  }
#line 369
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 371
  printf((char const   */* __restrict  */)"&#8221;");
  }
#line 372
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 374
  printf((char const   */* __restrict  */)"&#8226;");
  }
#line 375
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 377
  printf((char const   */* __restrict  */)"&#8211;");
  }
#line 378
  goto switch_break;
  case_151: /* CIL Label */ 
  {
#line 380
  printf((char const   */* __restrict  */)"&#8212;");
  }
#line 381
  goto switch_break;
  case_152: /* CIL Label */ 
  {
#line 383
  printf((char const   */* __restrict  */)"&#732;");
  }
#line 384
  goto switch_break;
  case_153: /* CIL Label */ 
  {
#line 386
  printf((char const   */* __restrict  */)"&#8482;");
  }
#line 387
  goto switch_break;
  case_154: /* CIL Label */ 
  {
#line 389
  printf((char const   */* __restrict  */)"&#353;");
  }
#line 390
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 392
  printf((char const   */* __restrict  */)"&#8250;");
  }
#line 393
  goto switch_break;
  case_156: /* CIL Label */ 
  {
#line 395
  printf((char const   */* __restrict  */)"&#339;");
  }
#line 396
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 398
  printf((char const   */* __restrict  */)"&#376;");
  }
#line 399
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 401
  putchar((int )c);
  }
#line 402
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static void print_utf8___0(unsigned short c ) 
{ 


  {
#line 408
  if ((int )c == 0) {
#line 409
    return;
  }
#line 411
  if ((int )c < 128) {
    {
#line 412
    OutputCharCorrected___0((unsigned char )c);
    }
  } else
#line 413
  if ((int )c < 2048) {
    {
#line 415
    putchar(192 | ((int )c >> 6));
#line 416
    put_utf8___0(c);
    }
  } else {
    {
#line 420
    putchar(224 | ((int )c >> 12));
#line 421
    put_utf8___0((unsigned short )((int )c >> 6));
#line 422
    put_utf8___0(c);
    }
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector2/temp/xlhtml-0.5.1/ppthtml/ppthtml.c"
static void put_utf8___0(unsigned short c ) 
{ 


  {
  {
#line 428
  putchar(128 | ((int )((short )c) & 63));
  }
#line 429
  return;
}
}
