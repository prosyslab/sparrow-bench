/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.h"
struct TREE {
   char *name ;
   unsigned long len ;
   unsigned long time ;
   int isdir ;
   int dirdown ;
   int brmin ;
   int brmax ;
   struct TREE *brother ;
   struct TREE *son ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 19 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.h"
int endswith(char *s , char *e ) ;
#line 20
char *nicenum(unsigned long n ) ;
#line 21
char *nicetime(unsigned long n ) ;
#line 22
void help(void) ;
#line 23
void t_scan(struct TREE *t , char *r ) ;
#line 24
int t_fix(struct TREE *t , unsigned long *tim , int *bmin , int *bmax ) ;
#line 25
void t_print(struct TREE *t , char *pref ) ;
#line 26
void t_free(struct TREE *t ) ;
#line 27
void mp3info(char *fname , struct TREE *p ) ;
#line 17 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
struct TREE *root  ;
#line 18 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
int dirsonly  =    0;
#line 19 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
int dirbrate  =    0;
#line 21 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
static struct option longopts[5]  = {      {"help", 0, (int *)((void *)0), '?'}, 
        {"dirs", 0, (int *)((void *)0), 'd'}, 
        {"bitrate", 0, (int *)((void *)0), 'b'}, 
        {"prefix", 1, (int *)((void *)0), 1}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 29 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
int main(int argc , char **argv ) 
{ 
  char *rootname ;
  char *title ;
  unsigned long tt ;
  int opt ;
  int b1 ;
  int b2 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 35
    opt = getopt_long(argc, (char * const  *)argv, "db?", (struct option  const  *)(longopts),
                      (int *)((void *)0));
    }
#line 35
    if (opt < 0) {
#line 36
      goto while_break;
    }
    {
#line 38
    if (opt == 63) {
#line 38
      goto case_63;
    }
#line 41
    if (opt == 100) {
#line 41
      goto case_100;
    }
#line 44
    if (opt == 98) {
#line 44
      goto case_98;
    }
#line 47
    if (opt == 1) {
#line 47
      goto case_1;
    }
#line 37
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 39
    help();
    }
#line 40
    goto switch_break;
    case_100: /* CIL Label */ 
#line 42
    dirsonly = 1;
#line 43
    goto switch_break;
    case_98: /* CIL Label */ 
#line 45
    dirbrate = 1;
#line 46
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 48
    printf((char const   */* __restrict  */)":%s\n", optarg);
    }
#line 49
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (argc - optind > 0) {
#line 52
    rootname = *(argv + optind);
  } else {
#line 53
    rootname = (char *)".";
  }
#line 54
  if (argc - optind > 1) {
#line 54
    title = *(argv + (optind + 1));
  } else {
#line 55
    title = rootname;
  }
  {
#line 56
  tmp = malloc(sizeof(struct TREE ));
#line 56
  root = (struct TREE *)tmp;
#line 57
  root->name = strdup((char const   *)title);
#line 58
  tmp___2 = 0;
#line 58
  root->brmax = tmp___2;
#line 58
  tmp___1 = tmp___2;
#line 58
  root->brmin = tmp___1;
#line 58
  tmp___0 = tmp___1;
#line 58
  root->dirdown = tmp___0;
#line 58
  root->len = (unsigned long )tmp___0;
#line 59
  root->isdir = 1;
#line 60
  t_scan(root, rootname);
#line 61
  t_fix(root, & tt, & b1, & b2);
#line 62
  t_print(root, (char *)"");
#line 63
  t_free(root);
  }
#line 64
  return (0);
}
}
#line 67 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
void t_scan(struct TREE *t , char *r ) 
{ 
  DIR *dir ;
  struct dirent *ent ;
  struct stat st ;
  char buf___1[4096] ;
  int m ;
  struct TREE *p ;
  int tmp ;
  int tmp___0 ;
  struct TREE *tmp___1 ;
  void *tmp___2 ;
  struct TREE *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 72
  m = 0;
#line 73
  p = (struct TREE *)((void *)0);
#line 75
  dir = opendir((char const   *)r);
  }
#line 76
  if (! dir) {
#line 76
    return;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    ent = readdir(dir);
    }
#line 77
    if (! ent) {
#line 77
      goto while_break;
    }
    {
#line 78
    tmp = strcmp((char const   *)(ent->d_name), ".");
    }
#line 78
    if (tmp) {
      {
#line 78
      tmp___0 = strcmp((char const   *)(ent->d_name), "..");
      }
#line 78
      if (! tmp___0) {
#line 78
        goto while_continue;
      }
    } else {
#line 78
      goto while_continue;
    }
#line 79
    if (m) {
      {
#line 79
      tmp___2 = malloc(sizeof(struct TREE ));
#line 79
      tmp___1 = (struct TREE *)tmp___2;
#line 79
      p->brother = tmp___1;
#line 79
      p = tmp___1;
      }
    } else {
      {
#line 80
      tmp___4 = malloc(sizeof(struct TREE ));
#line 80
      tmp___3 = (struct TREE *)tmp___4;
#line 80
      t->son = tmp___3;
#line 80
      p = tmp___3;
      }
    }
    {
#line 81
    m = 1;
#line 82
    p->name = strdup((char const   *)(ent->d_name));
#line 83
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s/%s",
            r, ent->d_name);
#line 84
    p->son = (struct TREE *)((void *)0);
#line 85
    lstat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)(& st));
#line 86
    p->len = (unsigned long )st.st_size;
#line 87
    tmp___7 = 0;
#line 87
    p->brmax = tmp___7;
#line 87
    tmp___6 = tmp___7;
#line 87
    p->brmin = tmp___6;
#line 87
    tmp___5 = tmp___6;
#line 87
    p->dirdown = tmp___5;
#line 87
    p->time = (unsigned long )tmp___5;
    }
#line 88
    if (st.st_mode & 16384U) {
      {
#line 89
      p->isdir = 1;
#line 90
      t_scan(p, buf___1);
      }
    } else {
#line 92
      p->isdir = 0;
#line 93
      if (st.st_mode & 32768U) {
        {
#line 93
        tmp___8 = endswith(ent->d_name, (char *)".mp3");
        }
#line 93
        if (tmp___8) {
          {
#line 95
          mp3info(buf___1, p);
          }
        } else {
          {
#line 93
          tmp___9 = endswith(ent->d_name, (char *)".MP3");
          }
#line 93
          if (tmp___9) {
            {
#line 95
            mp3info(buf___1, p);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (p) {
#line 98
    p->brother = (struct TREE *)((void *)0);
  }
  {
#line 99
  closedir(dir);
  }
#line 100
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
int t_fix(struct TREE *t , unsigned long *tim , int *bmin , int *bmax ) 
{ 
  unsigned long len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 105
  if (t->son) {
    {
#line 106
    tmp = t_fix(t->son, & t->time, & t->brmin, & t->brmax);
#line 106
    t->len = (unsigned long )tmp;
    }
  }
#line 107
  if (t->brother) {
    {
#line 108
    tmp___0 = t_fix(t->brother, tim, bmin, bmax);
#line 108
    len = t->len + (unsigned long )tmp___0;
    }
#line 109
    if ((t->brother)->isdir) {
#line 109
      tmp___1 = 1;
    } else
#line 109
    if ((t->brother)->dirdown) {
#line 109
      tmp___1 = 1;
    } else {
#line 109
      tmp___1 = 0;
    }
#line 109
    t->dirdown = tmp___1;
#line 110
    *tim += t->time;
#line 111
    if (t->brmin) {
#line 111
      if (t->brmin < *bmin) {
#line 111
        *bmin = t->brmin;
      } else
#line 111
      if (! *bmin) {
#line 111
        *bmin = t->brmin;
      }
    }
#line 112
    if (t->brmax > *bmax) {
#line 112
      *bmax = t->brmax;
    }
#line 113
    return ((int )len);
  } else {
#line 115
    *tim += t->time;
#line 116
    if (t->brmin) {
#line 116
      if (t->brmin < *bmin) {
#line 116
        *bmin = t->brmin;
      } else
#line 116
      if (! *bmin) {
#line 116
        *bmin = t->brmin;
      }
    }
#line 117
    if (t->brmax > *bmax) {
#line 117
      *bmax = t->brmax;
    }
#line 118
    return ((int )t->len);
  }
}
}
#line 122 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
void t_print(struct TREE *t , char *pref ) 
{ 
  char npref[256] ;
  int brd ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 126
  if (t->son) {
#line 126
    if (t->time) {
#line 127
      if (dirbrate) {
#line 128
        if (t->brmin == t->brmax) {
          {
#line 129
          tmp = nicetime(t->time);
#line 129
          sprintf((char */* __restrict  */)(npref), (char const   */* __restrict  */)"  <%s %d>",
                  tmp, t->brmin);
          }
        } else {
          {
#line 131
          tmp___0 = nicetime(t->time);
#line 131
          sprintf((char */* __restrict  */)(npref), (char const   */* __restrict  */)"  <%s %d-%d>",
                  tmp___0, t->brmin, t->brmax);
          }
        }
      } else {
        {
#line 133
        tmp___1 = nicetime(t->time);
#line 133
        sprintf((char */* __restrict  */)(npref), (char const   */* __restrict  */)"  <%s>",
                tmp___1);
        }
      }
      {
#line 135
      tmp___2 = strlen((char const   *)t->name);
#line 135
      tmp___3 = strlen((char const   *)(npref));
#line 135
      tmp___4 = realloc((void *)t->name, (tmp___2 + tmp___3) + 1UL);
#line 135
      t->name = (char *)tmp___4;
#line 136
      strcat((char */* __restrict  */)t->name, (char const   */* __restrict  */)(npref));
      }
    }
  }
#line 138
  if (dirsonly) {
#line 138
    brd = t->dirdown;
  } else {
#line 139
    brd = ! (! t->brother);
  }
#line 140
  if (! dirsonly) {
#line 140
    goto _L;
  } else
#line 140
  if (t->isdir) {
    _L: /* CIL Label */ 
    {
#line 141
    tmp___5 = nicenum(t->len);
    }
#line 141
    if (brd) {
#line 141
      tmp___6 = '|';
    } else {
#line 141
      tmp___6 = '`';
    }
    {
#line 141
    printf((char const   */* __restrict  */)"%s%c-- [%11s] %s\n", pref, tmp___6, tmp___5,
           t->name);
    }
  }
#line 142
  if (t->son) {
#line 143
    if (brd) {
#line 143
      tmp___7 = '|';
    } else {
#line 143
      tmp___7 = ' ';
    }
    {
#line 143
    sprintf((char */* __restrict  */)(npref), (char const   */* __restrict  */)"%s%c  ",
            pref, tmp___7);
#line 144
    t_print(t->son, npref);
    }
  }
#line 146
  if (t->brother) {
    {
#line 146
    t_print(t->brother, pref);
    }
  }
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt.c"
void t_free(struct TREE *t ) 
{ 


  {
#line 150
  if (t->son) {
    {
#line 150
    t_free(t->son);
    }
  }
#line 151
  if (t->brother) {
    {
#line 151
    t_free(t->brother);
    }
  }
  {
#line 152
  free((void *)t->name);
#line 153
  free((void *)t);
  }
#line 154
  return;
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 16 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt_mp3.c"
static int tabsel_123[2][3][16]  = { { {          0,          32,          64,          96, 
                128,          160,          192,          224, 
                256,          288,          320,          352, 
                384,          416,          448}, 
     {          0,          32,          48,          56, 
                64,          80,          96,          112, 
                128,          160,          192,          224, 
                256,          320,          384}, 
     {          0,          32,          40,          48, 
                56,          64,          80,          96, 
                112,          128,          160,          192, 
                224,          256,          320}}, 
   { {          0,          32,          48,          56, 
                64,          80,          96,          112, 
                128,          144,          160,          176, 
                192,          224,          256}, 
     {          0,          8,          16,          24, 
                32,          40,          48,          56, 
                64,          80,          96,          112, 
                128,          144,          160}, 
     {          0,          8,          16,          24, 
                32,          40,          48,          56, 
                64,          80,          96,          112, 
                128,          144,          160}}};
#line 24 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt_mp3.c"
static long freqs[9]  = 
#line 24
  {      44100L,      48000L,      32000L,      22050L, 
        24000L,      16000L,      11025L,      12000L, 
        8000L};
#line 25 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt_mp3.c"
static char modes[4]  = {      (char )'S',      (char )'J',      (char )'D',      (char )'M'};
#line 27 "/home/wheatley/newnew/temp/ncdt-2.1/ncdt_mp3.c"
void mp3info(char *fname , struct TREE *p ) 
{ 
  char buf___1[1024] ;
  char *ptr ;
  int ri ;
  int id ;
  int fd ;
  int vbr ;
  int vbroff ;
  unsigned char head[4] ;
  unsigned char th2[3] ;
  unsigned char vbh[4] ;
  unsigned char mpeg25 ;
  unsigned char lsf ;
  unsigned char layer ;
  unsigned char errp ;
  unsigned char bitrate ;
  unsigned char freq ;
  unsigned char pad ;
  unsigned char ext ;
  unsigned char mode ;
  unsigned char modext ;
  unsigned char copy ;
  unsigned char orig ;
  unsigned char emph ;
  unsigned char freq_ ;
  long fs ;
  long sfd ;
  long secs ;
  long off ;
  long len ;
  unsigned int vflags ;
  unsigned int vframes ;
  unsigned int vbytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  __off_t tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;

  {
  {
#line 34
  vframes = 0U;
#line 34
  vbytes = 0U;
#line 36
  fd = open((char const   *)fname, 0);
#line 37
  id = 0;
#line 37
  off = (long )id;
  }
#line 38
  if (fd >= 0) {
    {
#line 39
    read(fd, (void *)(head), (size_t )4);
#line 40
    tmp = strncmp((char const   *)(head), "RIFF", (size_t )4);
    }
#line 40
    if (tmp) {
#line 40
      tmp___0 = 0;
    } else {
#line 40
      tmp___0 = 1;
    }
#line 40
    ri = tmp___0;
#line 41
    if (ri) {
      {
#line 50
      read(fd, (void *)(buf___1), (size_t )1024);
#line 51
      ptr = buf___1;
      }
      {
#line 51
      while (1) {
        while_continue: /* CIL Label */ ;
#line 51
        if ((unsigned long )ptr < (unsigned long )(buf___1 + 1020)) {
          {
#line 51
          tmp___1 = strncmp((char const   *)ptr, "data", (size_t )4);
          }
#line 51
          if (! tmp___1) {
#line 51
            goto while_break;
          }
        } else {
#line 51
          goto while_break;
        }
#line 51
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 52
      tmp___2 = strncmp((char const   *)ptr, "data", (size_t )4);
      }
#line 52
      if (! tmp___2) {
        {
#line 53
        off = lseek(fd, (ptr - buf___1) + 12L, 0);
#line 54
        read(fd, (void *)(head), (size_t )4);
        }
      }
    }
    {
#line 57
    tmp___3 = strncmp((char const   *)(head), "ID3\003", (size_t )4);
    }
#line 57
    if (! tmp___3) {
      {
#line 58
      id = 2;
#line 59
      lseek(fd, (__off_t )2, 1);
#line 60
      read(fd, (void *)(head), (size_t )4);
#line 62
      off = lseek(fd, (__off_t )(((((int )head[0] << 21) | ((int )head[1] << 14)) | ((int )head[2] << 7)) | (int )head[3]),
                  1);
#line 63
      read(fd, (void *)(head), (size_t )4);
      }
    }
    {
#line 65
    tmp___4 = strncmp((char const   *)(head), "RIFF", (size_t )4);
    }
#line 65
    if (tmp___4) {
#line 65
      tmp___5 = 0;
    } else {
#line 65
      tmp___5 = 1;
    }
#line 65
    ri = tmp___5;
#line 66
    if (ri) {
      {
#line 67
      read(fd, (void *)(buf___1), (size_t )1024);
#line 68
      ptr = buf___1;
      }
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if ((unsigned long )ptr < (unsigned long )(buf___1 + 1020)) {
          {
#line 68
          tmp___6 = strncmp((char const   *)ptr, "data", (size_t )4);
          }
#line 68
          if (! tmp___6) {
#line 68
            goto while_break___0;
          }
        } else {
#line 68
          goto while_break___0;
        }
#line 68
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 69
      tmp___7 = strncmp((char const   *)ptr, "data", (size_t )4);
      }
#line 69
      if (! tmp___7) {
        {
#line 70
        off = lseek(fd, ((ptr + off) - buf___1) + 12L, 0);
#line 71
        read(fd, (void *)(head), (size_t )4);
        }
      }
    }
#line 74
    if ((int )head[0] == 255) {
#line 74
      if (((int )head[1] & 224) == 224) {
#line 75
        mpeg25 = (unsigned char )(((int )head[1] >> 4) & 1);
#line 76
        if (mpeg25) {
#line 76
          lsf = (unsigned char )(((int )head[1] >> 3) & 1);
        } else {
#line 77
          lsf = (unsigned char)0;
        }
#line 78
        layer = (unsigned char )(((int )head[1] >> 1) & 3);
#line 79
        errp = (unsigned char )((int )head[1] & 1);
#line 80
        bitrate = (unsigned char )(((int )head[2] >> 4) & 15);
#line 81
        freq = (unsigned char )(((int )head[2] >> 2) & 3);
#line 82
        pad = (unsigned char )(((int )head[2] >> 1) & 1);
#line 83
        ext = (unsigned char )((int )head[2] & 1);
#line 84
        mode = (unsigned char )(((int )head[3] >> 6) & 3);
#line 85
        modext = (unsigned char )(((int )head[3] >> 4) & 3);
#line 86
        copy = (unsigned char )(((int )head[3] >> 3) & 1);
#line 87
        orig = (unsigned char )(((int )head[3] >> 2) & 1);
#line 88
        emph = (unsigned char )((int )head[3] & 3);
#line 89
        if (((int )head[1] >> 3) & 1) {
#line 89
          if ((int )mode == 3) {
#line 89
            tmp___8 = 17;
          } else {
#line 89
            tmp___8 = 32;
          }
#line 89
          vbroff = tmp___8;
        } else {
#line 89
          if ((int )mode == 3) {
#line 89
            tmp___9 = 9;
          } else {
#line 89
            tmp___9 = 17;
          }
#line 89
          vbroff = tmp___9;
        }
        {
#line 90
        lseek(fd, (__off_t )vbroff, 1);
#line 91
        read(fd, (void *)(vbh), (size_t )4);
#line 92
        tmp___10 = strncmp((char const   *)(vbh), "Xing", (size_t )4);
        }
#line 92
        if (tmp___10) {
#line 109
          vbr = 0;
        } else {
          {
#line 93
          vbr = 1;
#line 94
          read(fd, (void *)(vbh), (size_t )4);
#line 95
          vflags = (unsigned int )(((((int )vbh[0] << 24) | ((int )vbh[1] << 16)) | ((int )vbh[2] << 8)) | (int )vbh[3]);
          }
#line 96
          if (vflags & 1U) {
            {
#line 97
            read(fd, (void *)(vbh), (size_t )4);
#line 98
            vframes = (unsigned int )(((((int )vbh[0] << 24) | ((int )vbh[1] << 16)) | ((int )vbh[2] << 8)) | (int )vbh[3]);
            }
          } else {
#line 100
            vframes = 1U;
          }
#line 102
          if (vflags & 2U) {
            {
#line 103
            read(fd, (void *)(vbh), (size_t )4);
#line 104
            vbytes = (unsigned int )(((((int )vbh[0] << 24) | ((int )vbh[1] << 16)) | ((int )vbh[2] << 8)) | (int )vbh[3]);
            }
          } else {
#line 106
            vbytes = 0U;
          }
        }
        {
#line 111
        tmp___11 = lseek(fd, (__off_t )-128, 2);
#line 111
        len = tmp___11 - off;
#line 112
        read(fd, (void *)(th2), (size_t )3);
#line 113
        tmp___12 = strncmp((char const   *)(th2), "TAG", (size_t )3);
        }
#line 113
        if (tmp___12) {
#line 116
          len += 128L;
        } else
#line 114
        if (! id) {
#line 114
          id = 1;
        }
#line 118
        if (mpeg25) {
#line 118
          freq_ = (unsigned char )((int )freq + 3 * ! lsf);
        } else {
#line 118
          freq_ = (unsigned char )(6 + (int )freq);
        }
#line 119
        if (vbr) {
#line 120
          if (vbytes) {
#line 120
            tmp___13 = (long )vbytes;
          } else {
#line 120
            tmp___13 = len;
          }
#line 120
          p->brmin = (int )(((tmp___13 / (long )vframes) * freqs[freq_]) / 144000L);
#line 121
          sfd = freqs[freq_] * (long )(2 - (int )lsf);
#line 122
          if ((int )layer == 2) {
#line 122
            tmp___14 = 384;
          } else {
#line 122
            tmp___14 = 1152;
          }
#line 122
          secs = ((long )(vframes * (unsigned int )tmp___14) + sfd / 2L) / sfd;
        } else {
#line 124
          p->brmin = tabsel_123[! lsf][3 - (int )layer][bitrate];
#line 125
          if ((int )layer == 2) {
#line 125
            tmp___15 = 12000;
          } else {
#line 125
            tmp___15 = 144000;
          }
#line 125
          if (! lsf) {
#line 125
            if ((int )layer == 1) {
#line 125
              tmp___16 = 1;
            } else {
#line 125
              tmp___16 = 0;
            }
          } else {
#line 125
            tmp___16 = 0;
          }
#line 125
          fs = (((long )p->brmin * (long )tmp___15) / (freqs[freq_] << tmp___16) + (long )pad) << 2 * ((int )layer == 2);
#line 127
          sfd = freqs[freq_] * (long )(2 - (int )lsf);
#line 128
          if ((int )layer == 2) {
#line 128
            tmp___17 = 384;
          } else {
#line 128
            tmp___17 = 1152;
          }
#line 128
          secs = ((len / fs) * (long )tmp___17 + sfd / 2L) / sfd;
        }
        {
#line 130
        tmp___18 = strlen((char const   *)p->name);
#line 130
        tmp___19 = realloc((void *)p->name, tmp___18 + 24UL);
#line 130
        p->name = (char *)tmp___19;
        }
#line 131
        if (id) {
#line 131
          if (id == 2) {
#line 131
            tmp___20 = "+";
          } else {
#line 131
            tmp___20 = "";
          }
#line 131
          tmp___21 = tmp___20;
        } else {
#line 131
          tmp___21 = "-";
        }
#line 131
        if (ri) {
#line 131
          tmp___22 = "R";
        } else {
#line 131
          tmp___22 = "";
        }
#line 131
        if (vbr) {
#line 131
          tmp___23 = "v";
        } else {
#line 131
          tmp___23 = "";
        }
        {
#line 131
        tmp___24 = nicetime((unsigned long )secs);
#line 131
        tmp___25 = strlen((char const   *)p->name);
#line 131
        sprintf((char */* __restrict  */)(p->name + tmp___25), (char const   */* __restrict  */)"  <%s %s%d%c%s%s>",
                tmp___24, tmp___23, p->brmin, (int )modes[mode], tmp___22, tmp___21);
#line 133
        p->time = (unsigned long )secs;
#line 134
        p->brmax = p->brmin;
        }
      }
    }
    {
#line 136
    close(fd);
    }
  }
#line 138
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 13 "/home/wheatley/newnew/temp/ncdt-2.1/util.c"
int endswith(char *s , char *e ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 14
  tmp = strlen((char const   *)s);
#line 14
  tmp___0 = strlen((char const   *)e);
#line 14
  tmp___1 = strcmp((char const   *)((s + tmp) - tmp___0), (char const   *)e);
  }
#line 14
  if (tmp___1) {
#line 14
    tmp___2 = 0;
  } else {
#line 14
    tmp___2 = 1;
  }
#line 14
  return (tmp___2);
}
}
#line 18 "/home/wheatley/newnew/temp/ncdt-2.1/util.c"
static char buf[1024]  ;
#line 17 "/home/wheatley/newnew/temp/ncdt-2.1/util.c"
char *nicenum(unsigned long n ) 
{ 
  char tmp[5] ;

  {
#line 21
  if (n > 999UL) {
    {
#line 22
    nicenum(n / 1000UL);
#line 23
    sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)",%03ld",
            n % 1000UL);
#line 24
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(tmp));
    }
  } else {
    {
#line 26
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%ld",
            n);
    }
  }
#line 28
  return (buf);
}
}
#line 32 "/home/wheatley/newnew/temp/ncdt-2.1/util.c"
static char buf___0[1024]  ;
#line 31 "/home/wheatley/newnew/temp/ncdt-2.1/util.c"
char *nicetime(unsigned long n ) 
{ 


  {
#line 34
  if (n > 3600UL) {
    {
#line 34
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d:%02d:%02d",
            (int )(n / 3600UL), (int )((n / 60UL) % 60UL), (int )(n % 60UL));
    }
  } else {
    {
#line 36
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d:%02d",
            (int )(n / 60UL), (int )(n % 60UL));
    }
  }
#line 37
  return (buf___0);
}
}
#line 56
extern int ( /* missing proto */  exit)() ;
#line 40 "/home/wheatley/newnew/temp/ncdt-2.1/util.c"
void help(void) 
{ 


  {
  {
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NcdT 2.0 -- simple format tree with extended capabilities\n\nUsage:\n  ncdt [options] [directory [name]]\n\nIf directory is omitted, . (current directory) is assumed. Name changes name\nused for root directory of the tree. If omitted the value of directory is\nused.\n\nValid options:\n  --dirs, -d\t  - print only directories, omit files\n  --bitrate, -b\t  - print bitrate info for directories\n  --prefix ...\t  - prefix listing with given text\n  --help, -?\t  - display this information\n\nAdditional capabilities not found in standard tree are:\n - size field for directories displays the summary size of directory\n   subtree instead of the size of the special file\n - sizes are displayed in a more readable format\n - MP3 files are detected; additional info is displayed for them\n\n");
#line 56
  exit(0);
  }
}
}
