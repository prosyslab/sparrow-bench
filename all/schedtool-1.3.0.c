/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 292 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 40 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef unsigned long __cpu_mask;
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct __anonstruct_cpu_set_t_41 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef struct __anonstruct_cpu_set_t_41 cpu_set_t;
#line 103 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
struct engine_s {
   int mode ;
   int policy ;
   int prio ;
   int nice ;
   cpu_set_t aff_mask ;
   int n ;
   char **args ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/error.h"
void decode_error(char *fmt  , ...) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/error.c"
void decode_error(char *fmt  , ...) 
{ 
  va_list args ;
  char *msg ;
  int tmp_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 34
  msg = (char *)((void *)0);
#line 35
  tmp = __errno_location();
#line 35
  tmp_errno = *tmp;
#line 37
  printf((char const   */* __restrict  */)"ERROR: ");
#line 38
  __builtin_va_start(args, fmt);
#line 39
  vprintf((char const   */* __restrict  */)fmt, args);
#line 40
  __builtin_va_end(args);
#line 42
  tmp___4 = __errno_location();
  }
#line 42
  if (*tmp___4) {
    {
#line 44
    tmp___0 = __errno_location();
    }
#line 44
    if (*tmp___0 == 22) {
#line 45
      msg = (char *)"value out of range / policy not implemented";
#line 46
      goto bail;
    }
    {
#line 50
    tmp___1 = __errno_location();
#line 50
    tmp___2 = strerror(*tmp___1);
#line 50
    msg = tmp___2;
#line 53
    tmp___3 = __errno_location();
    }
#line 53
    if (*tmp___3 != tmp_errno) {
#line 54
      msg = (char *)"unknown error code, sorry";
    }
    bail: 
    {
#line 58
    printf((char const   */* __restrict  */)" - %s", msg);
    }
  }
  {
#line 60
  printf((char const   */* __restrict  */)"\n");
  }
#line 61
  return;
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 289 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 557
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  __stringp ,
                                                                                                 char const   * __restrict  __delim ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 93 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpriority)(__priority_which_t __which ,
                                                                                  id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 53 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_getparam)(__pid_t __pid ,
                                                                                     struct sched_param *__param ) ;
#line 56
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid ,
                                                                                         int __policy ,
                                                                                         struct sched_param  const  *__param ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_getscheduler)(__pid_t __pid ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_setaffinity)(__pid_t __pid ,
                                                                                        size_t __cpusetsize ,
                                                                                        cpu_set_t const   *__cpuset ) ;
#line 120
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_getaffinity)(__pid_t __pid ,
                                                                                        size_t __cpusetsize ,
                                                                                        cpu_set_t *__cpuset ) ;
#line 578 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/util.h"
__inline static int mode_set(int x , int try ) 
{ 


  {
#line 22
  return ((x & try) == try);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
char *TAB[7]  = {      (char *)"N: SCHED_NORMAL",      (char *)"F: SCHED_FIFO",      (char *)"R: SCHED_RR",      (char *)"B: SCHED_BATCH", 
        (char *)"I: SCHED_ISO",      (char *)"D: SCHED_IDLEPRIO",      (char *)0};
#line 117
int engine(struct engine_s *e ) ;
#line 118
int set_process(pid_t pid , int policy , int prio ) ;
#line 119
__inline static int val_to_char(int v ) ;
#line 120
static char *cpuset_to_str(cpu_set_t *mask , char *str ) ;
#line 121
__inline static int char_to_val(int c ) ;
#line 122
static int str_to_cpuset(cpu_set_t *mask , char const   *str ) ;
#line 123
int parse_affinity(cpu_set_t *mask , char *arg ) ;
#line 124
int set_affinity(pid_t pid , cpu_set_t *mask ) ;
#line 125
int set_niceness(pid_t pid , int nice___0 ) ;
#line 126
void probe_sched_features(void) ;
#line 127
void get_prio_min_max(int policy , int *min , int *max ) ;
#line 128
void print_prio_min_max(int policy ) ;
#line 129
void print_process(pid_t pid ) ;
#line 130
void usage(void) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
int main(int ac , char **dc ) 
{ 
  int policy ;
  int nice___0 ;
  int prio ;
  int mode ;
  cpu_set_t aff_mask ;
  int c ;
  int prio_min ;
  int prio_max ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct engine_s stuff ;
  int tmp___3 ;

  {
#line 145
  policy = -1;
#line 145
  nice___0 = 10;
#line 145
  prio = 0;
#line 145
  mode = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    __builtin_memset((void *)(& aff_mask), '\000', (int )sizeof(cpu_set_t ));
    }
#line 151
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (ac < 2) {
    {
#line 157
    usage();
    }
#line 158
    return (0);
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 161
    c = getopt(ac, (char * const  *)dc, "+NFRBID012345M:a:p:n:ervh");
    }
#line 161
    if (! (c != -1)) {
#line 161
      goto while_break___0;
    }
    {
#line 165
    if (c == 78) {
#line 165
      goto case_78;
    }
#line 165
    if (c == 48) {
#line 165
      goto case_78;
    }
#line 170
    if (c == 70) {
#line 170
      goto case_70;
    }
#line 170
    if (c == 49) {
#line 170
      goto case_70;
    }
#line 175
    if (c == 82) {
#line 175
      goto case_82;
    }
#line 175
    if (c == 50) {
#line 175
      goto case_82;
    }
#line 180
    if (c == 66) {
#line 180
      goto case_66;
    }
#line 180
    if (c == 51) {
#line 180
      goto case_66;
    }
#line 185
    if (c == 73) {
#line 185
      goto case_73;
    }
#line 185
    if (c == 52) {
#line 185
      goto case_73;
    }
#line 190
    if (c == 68) {
#line 190
      goto case_68;
    }
#line 190
    if (c == 53) {
#line 190
      goto case_68;
    }
#line 194
    if (c == 77) {
#line 194
      goto case_77;
    }
#line 199
    if (c == 97) {
#line 199
      goto case_97;
    }
#line 203
    if (c == 110) {
#line 203
      goto case_110;
    }
#line 207
    if (c == 101) {
#line 207
      goto case_101;
    }
#line 210
    if (c == 112) {
#line 210
      goto case_112;
    }
#line 213
    if (c == 114) {
#line 213
      goto case_114;
    }
#line 216
    if (c == 118) {
#line 216
      goto case_118;
    }
#line 221
    if (c == 104) {
#line 221
      goto case_104;
    }
#line 221
    if (c == 86) {
#line 221
      goto case_104;
    }
#line 224
    goto switch_default;
    case_78: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 166
    policy = 0;
#line 167
    mode |= 2;
#line 168
    goto switch_break;
    case_70: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 171
    policy = 1;
#line 172
    mode |= 2;
#line 173
    goto switch_break;
    case_82: /* CIL Label */ 
    case_50: /* CIL Label */ 
#line 176
    policy = 2;
#line 177
    mode |= 2;
#line 178
    goto switch_break;
    case_66: /* CIL Label */ 
    case_51: /* CIL Label */ 
#line 181
    policy = 3;
#line 182
    mode |= 2;
#line 183
    goto switch_break;
    case_73: /* CIL Label */ 
    case_52: /* CIL Label */ 
#line 186
    policy = 4;
#line 187
    mode |= 2;
#line 188
    goto switch_break;
    case_68: /* CIL Label */ 
    case_53: /* CIL Label */ 
#line 191
    policy = 5;
#line 192
    mode |= 2;
#line 193
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 196
    policy = atoi((char const   *)optarg);
#line 197
    mode |= 2;
    }
#line 198
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 200
    mode |= 4;
#line 201
    parse_affinity(& aff_mask, optarg);
    }
#line 202
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 204
    mode |= 16;
#line 205
    nice___0 = atoi((char const   *)optarg);
    }
#line 206
    goto switch_break;
    case_101: /* CIL Label */ 
#line 208
    mode |= 8;
#line 209
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 211
    prio = atoi((char const   *)optarg);
    }
#line 212
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 214
    probe_sched_features();
    }
#line 215
    goto switch_break;
    case_118: /* CIL Label */ 
#line 218
    mode |= 1;
#line 219
    goto switch_break;
    case_104: /* CIL Label */ 
    case_86: /* CIL Label */ 
    {
#line 222
    usage();
    }
#line 223
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 226
    usage();
    }
#line 227
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 237
  if (policy == 0) {
#line 237
    goto _L___2;
  } else
#line 237
  if (policy == 3) {
    _L___2: /* CIL Label */ 
#line 237
    if (prio) {
      {
#line 238
      decode_error((char *)"%s call may fail as static PRIO must be 0 or omitted",
                   TAB[policy]);
      }
    } else {
#line 237
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 243
  if (policy == 1) {
#line 243
    goto _L___0;
  } else
#line 243
  if (policy == 2) {
#line 243
    goto _L___0;
  } else
#line 243
  if (policy == 4) {
    _L___0: /* CIL Label */ 
    {
#line 249
    get_prio_min_max(policy, & prio_min, & prio_max);
    }
#line 253
    if (prio <= prio_max) {
#line 253
      if (! (prio >= prio_min)) {
#line 253
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 255
      if (prio == 0) {
        {
#line 256
        decode_error((char *)"missing priority; specify static priority via -p");
        }
      } else {
        {
#line 258
        decode_error((char *)"PRIO %d is out of range %d-%d for %s", prio, prio_min,
                     prio_max, TAB[policy]);
        }
      }
#line 266
      return (ac - optind);
    }
  }
#line 272
  if (! mode) {
#line 273
    mode |= 1;
  }
  {
#line 276
  tmp = mode_set(mode, 8);
  }
#line 276
  if (tmp) {
    {
#line 276
    tmp___0 = mode_set(mode, 2);
    }
#line 276
    if (! tmp___0) {
      {
#line 276
      tmp___1 = mode_set(mode, 4);
      }
#line 276
      if (! tmp___1) {
        {
#line 276
        tmp___2 = mode_set(mode, 16);
        }
#line 276
        if (! tmp___2) {
          {
#line 282
          decode_error((char *)"Option -e needs scheduling-parameters, not given - exiting");
          }
#line 283
          return (-1);
        }
      }
    }
  }
#line 286
  if (nice___0 <= 20) {
#line 286
    if (! (nice___0 >= -20)) {
      {
#line 287
      decode_error((char *)"NICE %d is out of range -20 to 20", nice___0);
      }
#line 288
      return (-1);
    }
  } else {
    {
#line 287
    decode_error((char *)"NICE %d is out of range -20 to 20", nice___0);
    }
#line 288
    return (-1);
  }
  {
#line 296
  stuff.mode = mode;
#line 297
  stuff.policy = policy;
#line 298
  stuff.prio = prio;
#line 299
  stuff.aff_mask = aff_mask;
#line 300
  stuff.nice = nice___0;
#line 303
  stuff.n = ac - optind;
#line 306
  stuff.args = dc + optind;
#line 309
  tmp___3 = engine(& stuff);
  }
#line 309
  return (tmp___3);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
int engine(struct engine_s *e ) 
{ 
  int ret ;
  int i ;
  int pid ;
  int tmpret ;
  cpu_set_t affi ;
  size_t __cpu ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char **new_argv ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 316
  ret = 0;
#line 335
  i = 0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i < e->n)) {
#line 335
      goto while_break;
    }
#line 337
    tmpret = 0;
    {
#line 340
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 340
      __builtin_memset((void *)(& affi), '\000', (int )sizeof(cpu_set_t ));
      }
#line 340
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    __cpu = (size_t )0;
#line 341
    if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 341
      affi.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
    }
    {
#line 344
    tmp = mode_set(e->mode, 8);
    }
#line 344
    if (tmp) {
      {
#line 345
      pid = getpid();
      }
#line 346
      goto exec_mode_special;
    }
    {
#line 349
    tmp___0 = __ctype_b_loc();
    }
#line 349
    if (! ((int const   )*(*tmp___0 + (int )*(*(e->args + i))) & 2048)) {
      {
#line 350
      decode_error((char *)"Ignoring arg %s: is not a PID", *(e->args + i));
      }
#line 351
      goto __Cont;
    }
    {
#line 354
    pid = atoi((char const   *)*(e->args + i));
    }
    exec_mode_special: 
    {
#line 357
    tmp___1 = mode_set(e->mode, 2);
    }
#line 357
    if (tmp___1) {
      {
#line 364
      tmpret = set_process(pid, e->policy, e->prio);
#line 365
      ret += tmpret;
      }
#line 368
      if (tmpret) {
#line 369
        goto __Cont;
      }
    }
    {
#line 374
    tmp___2 = mode_set(e->mode, 16);
    }
#line 374
    if (tmp___2) {
      {
#line 375
      tmpret = set_niceness(pid, e->nice);
#line 376
      ret += tmpret;
      }
#line 378
      if (tmpret) {
#line 379
        goto __Cont;
      }
    }
    {
#line 384
    tmp___3 = mode_set(e->mode, 4);
    }
#line 384
    if (tmp___3) {
      {
#line 385
      tmpret = set_affinity(pid, & e->aff_mask);
#line 386
      ret += tmpret;
      }
#line 388
      if (tmpret) {
#line 389
        goto __Cont;
      }
    }
    {
#line 395
    tmp___4 = mode_set(e->mode, 1);
    }
#line 395
    if (tmp___4) {
      {
#line 396
      print_process(pid);
      }
    }
    {
#line 401
    tmp___5 = mode_set(e->mode, 8);
    }
#line 401
    if (tmp___5) {
      {
#line 403
      new_argv = e->args;
#line 405
      ret = execvp((char const   *)*new_argv, (char * const  *)new_argv);
#line 408
      decode_error((char *)"schedtool: Could not exec %s", *new_argv);
      }
#line 409
      return (ret);
    }
    __Cont: /* CIL Label */ 
#line 335
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  tmp___6 = abs(ret);
  }
#line 416
  return (tmp___6);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
int set_process(pid_t pid , int policy , int prio ) 
{ 
  struct sched_param p ;
  int ret ;
  char *msg1 ;
  char *msg2 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 425
  msg1 = (char *)"could not set PID %d to %s";
#line 426
  msg2 = (char *)"could not set PID %d to raw policy #%d";
#line 428
  p.__sched_priority = prio;
#line 431
  ret = sched_setscheduler(pid, policy, (struct sched_param  const  *)(& p));
  }
#line 431
  if (ret) {
#line 434
    if (policy <= 5) {
#line 434
      if (policy >= 0) {
#line 434
        tmp = TAB[policy];
      } else {
#line 434
        tmp = (char *)policy;
      }
    } else {
#line 434
      tmp = (char *)policy;
    }
#line 434
    if (policy <= 5) {
#line 434
      if (policy >= 0) {
#line 434
        tmp___0 = msg1;
      } else {
#line 434
        tmp___0 = msg2;
      }
    } else {
#line 434
      tmp___0 = msg2;
    }
    {
#line 434
    decode_error(tmp___0, pid, tmp);
    }
#line 438
    return (ret);
  }
#line 440
  return (0);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
__inline static int val_to_char(int v ) 
{ 


  {
#line 450
  if (v >= 0) {
#line 450
    if (v < 10) {
#line 451
      return (48 + v);
    } else {
#line 450
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 452
  if (v >= 10) {
#line 452
    if (v < 16) {
#line 453
      return (87 + v);
    } else {
#line 455
      return (-1);
    }
  } else {
#line 455
    return (-1);
  }
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
static char *cpuset_to_str(cpu_set_t *mask , char *str ) 
{ 
  int base ;
  char *ptr ;
  char *ret ;
  char val ;
  size_t __cpu ;
  int tmp ;
  size_t __cpu___0 ;
  int tmp___0 ;
  size_t __cpu___1 ;
  int tmp___1 ;
  size_t __cpu___2 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 470
  ptr = str;
#line 471
  ret = (char *)0;
#line 473
  base = 1020;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (base >= 0)) {
#line 473
      goto while_break;
    }
#line 474
    val = (char)0;
#line 475
    __cpu = (size_t )base;
#line 475
    if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 475
      tmp = (*((__cpu_mask const   *)(mask->__bits) + __cpu / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu % (8UL * sizeof(__cpu_mask )))) != 0UL;
    } else {
#line 475
      tmp = 0;
    }
#line 475
    if (tmp) {
#line 476
      val = (char )((int )val | 1);
    }
#line 477
    __cpu___0 = (size_t )(base + 1);
#line 477
    if (__cpu___0 / 8UL < sizeof(cpu_set_t )) {
#line 477
      tmp___0 = (*((__cpu_mask const   *)(mask->__bits) + __cpu___0 / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu___0 % (8UL * sizeof(__cpu_mask )))) != 0UL;
    } else {
#line 477
      tmp___0 = 0;
    }
#line 477
    if (tmp___0) {
#line 478
      val = (char )((int )val | 2);
    }
#line 479
    __cpu___1 = (size_t )(base + 2);
#line 479
    if (__cpu___1 / 8UL < sizeof(cpu_set_t )) {
#line 479
      tmp___1 = (*((__cpu_mask const   *)(mask->__bits) + __cpu___1 / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu___1 % (8UL * sizeof(__cpu_mask )))) != 0UL;
    } else {
#line 479
      tmp___1 = 0;
    }
#line 479
    if (tmp___1) {
#line 480
      val = (char )((int )val | 4);
    }
#line 481
    __cpu___2 = (size_t )(base + 3);
#line 481
    if (__cpu___2 / 8UL < sizeof(cpu_set_t )) {
#line 481
      tmp___2 = (*((__cpu_mask const   *)(mask->__bits) + __cpu___2 / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu___2 % (8UL * sizeof(__cpu_mask )))) != 0UL;
    } else {
#line 481
      tmp___2 = 0;
    }
#line 481
    if (tmp___2) {
#line 482
      val = (char )((int )val | 8);
    }
#line 483
    if (! ret) {
#line 483
      if (val) {
#line 484
        ret = ptr;
      }
    }
    {
#line 485
    tmp___3 = ptr;
#line 485
    ptr ++;
#line 485
    tmp___4 = val_to_char((int )val);
#line 485
    *tmp___3 = (char )tmp___4;
#line 473
    base -= 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  *ptr = (char)0;
#line 488
  if (ret) {
#line 488
    tmp___5 = ret;
  } else {
#line 488
    tmp___5 = ptr - 1;
  }
#line 488
  return (tmp___5);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
__inline static int char_to_val(int c ) 
{ 
  int cl ;

  {
  {
#line 496
  cl = tolower(c);
  }
#line 497
  if (c >= 48) {
#line 497
    if (c <= 57) {
#line 498
      return (c - 48);
    } else {
#line 497
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 499
  if (cl >= 97) {
#line 499
    if (cl <= 102) {
#line 500
      return (cl + -87);
    } else {
#line 502
      return (-1);
    }
  } else {
#line 502
    return (-1);
  }
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
static int str_to_cpuset(cpu_set_t *mask , char const   *str ) 
{ 
  int len ;
  size_t tmp ;
  char const   *ptr ;
  int base ;
  char val ;
  int tmp___0 ;
  size_t __cpu ;
  size_t __cpu___0 ;
  size_t __cpu___1 ;
  size_t __cpu___2 ;

  {
  {
#line 508
  tmp = strlen(str);
#line 508
  len = (int )tmp;
#line 509
  ptr = (str + len) - 1;
#line 510
  base = 0;
  }
#line 513
  if (len > 1) {
#line 513
    if ((int const   )*(str + 0) == 48) {
#line 513
      if ((int const   )*(str + 1) == 120) {
#line 514
        str += 2;
      }
    }
  }
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 517
    __builtin_memset((void *)mask, '\000', (int )sizeof(cpu_set_t ));
    }
#line 517
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! ((unsigned long )ptr >= (unsigned long )str)) {
#line 518
      goto while_break___0;
    }
    {
#line 519
    tmp___0 = char_to_val((int )*ptr);
#line 519
    val = (char )tmp___0;
    }
#line 520
    if ((int )val == -1) {
#line 521
      return (-1);
    }
#line 522
    if ((int )val & 1) {
#line 523
      __cpu = (size_t )base;
#line 523
      if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 523
        mask->__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
      }
    }
#line 524
    if ((int )val & 2) {
#line 525
      __cpu___0 = (size_t )(base + 1);
#line 525
      if (__cpu___0 / 8UL < sizeof(cpu_set_t )) {
#line 525
        mask->__bits[__cpu___0 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___0 % (8UL * sizeof(__cpu_mask ));
      }
    }
#line 526
    if ((int )val & 4) {
#line 527
      __cpu___1 = (size_t )(base + 2);
#line 527
      if (__cpu___1 / 8UL < sizeof(cpu_set_t )) {
#line 527
        mask->__bits[__cpu___1 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___1 % (8UL * sizeof(__cpu_mask ));
      }
    }
#line 528
    if ((int )val & 8) {
#line 529
      __cpu___2 = (size_t )(base + 3);
#line 529
      if (__cpu___2 / 8UL < sizeof(cpu_set_t )) {
#line 529
        mask->__bits[__cpu___2 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___2 % (8UL * sizeof(__cpu_mask ));
      }
    }
#line 530
    len --;
#line 531
    ptr --;
#line 532
    base += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 535
  return (0);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
int parse_affinity(cpu_set_t *mask , char *arg ) 
{ 
  cpu_set_t tmp_aff ;
  char *tmp_arg ;
  size_t valid_len ;
  int tmp_cpu ;
  size_t __cpu ;
  unsigned short const   **tmp ;

  {
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 547
    __builtin_memset((void *)(& tmp_aff), '\000', (int )sizeof(cpu_set_t ));
    }
#line 547
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  if ((int )*arg == 48) {
#line 549
    if ((int )*(arg + 1) == 120) {
      {
#line 551
      str_to_cpuset(& tmp_aff, (char const   *)arg);
      }
    } else {
#line 549
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 553
    valid_len = strspn((char const   *)arg, "0123456789,.");
    }
#line 553
    if (valid_len) {
      {
#line 557
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 557
        tmp_arg = strsep((char **/* __restrict  */)(& arg), (char const   */* __restrict  */)",.");
        }
#line 557
        if (! tmp_arg) {
#line 557
          goto while_break___0;
        }
        {
#line 560
        tmp = __ctype_b_loc();
        }
#line 560
        if ((int const   )*(*tmp + (int )*tmp_arg) & 2048) {
          {
#line 561
          tmp_cpu = atoi((char const   *)tmp_arg);
#line 562
          __cpu = (size_t )tmp_cpu;
          }
#line 562
          if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 562
            tmp_aff.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 570
      decode_error((char *)"affinity %s is not parseable", arg);
#line 571
      exit(1);
      }
    }
  }
#line 574
  *mask = tmp_aff;
#line 575
  return (0);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
int set_affinity(pid_t pid , cpu_set_t *mask ) 
{ 
  int ret ;
  char aff_hex[512] ;
  char *tmp ;

  {
  {
#line 584
  ret = sched_setaffinity(pid, sizeof(cpu_set_t ), (cpu_set_t const   *)mask);
  }
#line 584
  if (ret == -1) {
    {
#line 585
    tmp = cpuset_to_str(mask, aff_hex);
#line 585
    decode_error((char *)"could not set PID %d to affinity 0x%s", pid, tmp);
    }
#line 589
    return (ret);
  }
#line 591
  return (0);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
int set_niceness(pid_t pid , int nice___0 ) 
{ 
  int ret ;

  {
  {
#line 599
  ret = setpriority((__priority_which_t )0, (id_t )pid, nice___0);
  }
#line 599
  if (ret) {
    {
#line 600
    decode_error((char *)"could not set PID %d to nice %d", pid, nice___0);
    }
#line 604
    return (ret);
  }
#line 606
  return (0);
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
void probe_sched_features(void) 
{ 
  int i ;

  {
#line 617
  i = 0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (i <= 5)) {
#line 617
      goto while_break;
    }
    {
#line 618
    print_prio_min_max(i);
#line 617
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
void get_prio_min_max(int policy , int *min , int *max ) 
{ 


  {
  {
#line 629
  *min = sched_get_priority_min(policy);
#line 630
  *max = sched_get_priority_max(policy);
  }
#line 631
  return;
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
void print_prio_min_max(int policy ) 
{ 
  int min ;
  int max ;

  {
  {
#line 639
  get_prio_min_max(policy, & min, & max);
  }
  {
#line 643
  if ((min | max) == -1) {
#line 643
    goto case_neg_1;
  }
#line 646
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 644
  printf((char const   */* __restrict  */)"%-17s: policy not implemented\n", TAB[policy]);
  }
#line 645
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 647
  printf((char const   */* __restrict  */)"%-17s: prio_min %d, prio_max %d\n", TAB[policy],
         min, max);
  }
#line 648
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 650
  return;
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
void print_process(pid_t pid ) 
{ 
  int policy ;
  int nice___0 ;
  struct sched_param p ;
  cpu_set_t aff_mask ;
  char aff_mask_hex[512] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 666
    __builtin_memset((void *)(& aff_mask), '\000', (int )sizeof(cpu_set_t ));
    }
#line 666
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  tmp = __errno_location();
#line 669
  *tmp = 0;
#line 670
  policy = sched_getscheduler(pid);
  }
#line 670
  if (policy < 0) {
    {
#line 675
    decode_error((char *)"could not get scheduling-information for PID %d", pid);
    }
  } else {
    {
#line 670
    tmp___3 = sched_getparam(pid, & p);
    }
#line 670
    if (tmp___3 < 0) {
      {
#line 675
      decode_error((char *)"could not get scheduling-information for PID %d", pid);
      }
    } else {
      {
#line 670
      nice___0 = getpriority((__priority_which_t )0, (id_t )pid);
      }
#line 670
      if (nice___0) {
        {
#line 670
        tmp___4 = __errno_location();
        }
#line 670
        if (*tmp___4) {
          {
#line 675
          decode_error((char *)"could not get scheduling-information for PID %d",
                       pid);
          }
        } else {
#line 670
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 680
        if (policy <= 5) {
#line 680
          if (policy >= 0) {
            {
#line 689
            printf((char const   */* __restrict  */)"PID %5d: PRIO %3d, POLICY %-17s, NICE %3d",
                   pid, p.__sched_priority, TAB[policy], nice___0);
            }
          } else {
            {
#line 681
            printf((char const   */* __restrict  */)"PID %5d: PRIO %3d, POLICY %-5d <UNKNOWN>, NICE %3d",
                   pid, p.__sched_priority, policy, nice___0);
            }
          }
        } else {
          {
#line 681
          printf((char const   */* __restrict  */)"PID %5d: PRIO %3d, POLICY %-5d <UNKNOWN>, NICE %3d",
                 pid, p.__sched_priority, policy, nice___0);
          }
        }
        {
#line 701
        tmp___2 = sched_getaffinity(pid, sizeof(aff_mask), & aff_mask);
        }
#line 701
        if (tmp___2 == -1) {
          {
#line 706
          tmp___0 = __errno_location();
#line 706
          *tmp___0 = 0;
          }
        } else {
          {
#line 708
          tmp___1 = cpuset_to_str(& aff_mask, aff_mask_hex);
#line 708
          printf((char const   */* __restrict  */)", AFFINITY 0x%s", tmp___1);
          }
        }
        {
#line 710
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 712
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/schedtool-1.3.0/schedtool.c"
void usage(void) 
{ 


  {
  {
#line 717
  printf((char const   */* __restrict  */)"get/set scheduling policies - v1.3.0, GPL\'d, NO WARRANTY\nUSAGE: schedtool PIDS                    - query PIDS\n       schedtool [OPTIONS] PIDS          - set PIDS\n       schedtool [OPTIONS] -e COMMAND    - exec COMMAND\n\nset scheduling policies:\n    -N                    for SCHED_NORMAL\n    -F -p PRIO            for SCHED_FIFO       only as root\n    -R -p PRIO            for SCHED_RR         only as root\n    -B                    for SCHED_BATCH\n    -I -p PRIO            for SCHED_ISO\n    -D                    for SCHED_IDLEPRIO\n\n    -M POLICY             for manual mode; raw number for POLICY\n    -p STATIC_PRIORITY    usually 1-99; only for FIFO or RR\n                          higher numbers means higher priority\n    -n NICE_LEVEL         set niceness to NICE_LEVEL\n    -a AFFINITY_MASK      set CPU-affinity to bitmask or list\n\n    -e COMMAND [ARGS]     start COMMAND with specified policy/priority\n    -r                    display priority min/max for each policy\n    -v                    be verbose\n\n");
  }
#line 744
  return;
}
}
