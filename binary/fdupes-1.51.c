/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __dev_t dev_t;
#line 57 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __ino64_t ino_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.h"
typedef unsigned char md5_byte_t;
#line 55 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.h"
typedef unsigned int md5_word_t;
#line 58 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.h"
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.h"
typedef struct md5_state_s md5_state_t;
#line 85 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
struct _file {
   char *d_name ;
   off_t size ;
   char *crcpartial ;
   char *crcsignature ;
   dev_t device ;
   ino_t inode ;
   time_t mtime ;
   int hasdupes ;
   struct _file *duplicates ;
   struct _file *next ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
typedef struct _file file_t;
#line 98 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
struct _filetree {
   file_t *file ;
   struct _filetree *left ;
   struct _filetree *right ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
typedef struct _filetree filetree_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 286
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream )  __asm__("freopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 267
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 790 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.h"
void md5_init(md5_state_t *pms ) ;
#line 80
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
#line 87
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
char *program_name  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
unsigned long flags  =    0UL;
#line 104 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void errormsg(char *message  , ...) 
{ 
  va_list ap ;

  {
  {
#line 108
  __builtin_va_start(ap, message);
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%40s\r%s: ",
          "", program_name);
#line 111
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           ap);
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void escapefilename(char *escape_list , char **filename_ptr ) 
{ 
  int x ;
  int tx ;
  char *tmp ;
  char *filename ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 121
  filename = *filename_ptr;
#line 123
  tmp___0 = strlen((char const   *)filename);
#line 123
  tmp___1 = malloc(tmp___0 * 2UL + 1UL);
#line 123
  tmp = (char *)tmp___1;
  }
#line 124
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 125
    errormsg((char *)"out of memory!\n");
#line 126
    exit(1);
    }
  }
#line 129
  x = 0;
#line 129
  tx = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___5 = strlen((char const   *)filename);
    }
#line 129
    if (! ((size_t )x < tmp___5)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp___3 = strchr((char const   *)escape_list, (int )*(filename + x));
    }
#line 130
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 130
      tmp___2 = tx;
#line 130
      tx ++;
#line 130
      *(tmp + tmp___2) = (char )'\\';
    }
#line 131
    tmp___4 = tx;
#line 131
    tx ++;
#line 131
    *(tmp + tmp___4) = *(filename + x);
#line 129
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  *(tmp + tx) = (char )'\000';
#line 136
  if (x != tx) {
    {
#line 137
    tmp___6 = strlen((char const   *)tmp);
#line 137
    tmp___7 = realloc((void *)*filename_ptr, tmp___6 + 1UL);
#line 137
    *filename_ptr = (char *)tmp___7;
    }
#line 138
    if ((unsigned long )*filename_ptr == (unsigned long )((void *)0)) {
      {
#line 139
      errormsg((char *)"out of memory!\n");
#line 140
      exit(1);
      }
    }
    {
#line 142
    strcpy((char */* __restrict  */)*filename_ptr, (char const   */* __restrict  */)tmp);
    }
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
off_t filesize(char *filename ) 
{ 
  struct stat s ;
  int tmp ;

  {
  {
#line 149
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& s));
  }
#line 149
  if (tmp != 0) {
#line 149
    return ((off_t )-1);
  }
#line 151
  return (s.st_size);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
dev_t getdevice(char *filename ) 
{ 
  struct stat s ;
  int tmp ;

  {
  {
#line 157
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& s));
  }
#line 157
  if (tmp != 0) {
#line 157
    return ((dev_t )0);
  }
#line 159
  return (s.st_dev);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
ino_t getinode(char *filename ) 
{ 
  struct stat s ;
  int tmp ;

  {
  {
#line 165
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& s));
  }
#line 165
  if (tmp != 0) {
#line 165
    return ((ino_t )0);
  }
#line 167
  return (s.st_ino);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
time_t getmtime(char *filename ) 
{ 
  struct stat s ;
  int tmp ;

  {
  {
#line 173
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& s));
  }
#line 173
  if (tmp != 0) {
#line 173
    return ((time_t )0);
  }
#line 175
  return (s.st_mtim.tv_sec);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
char **cloneargs(int argc , char **argv ) 
{ 
  int x ;
  char **args ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 183
  tmp = malloc(sizeof(char *) * (unsigned long )argc);
#line 183
  args = (char **)tmp;
  }
#line 184
  if ((unsigned long )args == (unsigned long )((void *)0)) {
    {
#line 185
    errormsg((char *)"out of memory!\n");
#line 186
    exit(1);
    }
  }
#line 189
  x = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (x < argc)) {
#line 189
      goto while_break;
    }
    {
#line 190
    tmp___0 = strlen((char const   *)*(argv + x));
#line 190
    tmp___1 = malloc(tmp___0 + 1UL);
#line 190
    *(args + x) = (char *)tmp___1;
    }
#line 191
    if ((unsigned long )*(args + x) == (unsigned long )((void *)0)) {
      {
#line 192
      free((void *)args);
#line 193
      errormsg((char *)"out of memory!\n");
#line 194
      exit(1);
      }
    }
    {
#line 197
    strcpy((char */* __restrict  */)*(args + x), (char const   */* __restrict  */)*(argv + x));
#line 189
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return (args);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int findarg(char *arg , int start , int argc , char **argv ) 
{ 
  int x ;
  int tmp ;

  {
#line 207
  x = start;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (x < argc)) {
#line 207
      goto while_break;
    }
    {
#line 208
    tmp = strcmp((char const   *)*(argv + x), (char const   *)arg);
    }
#line 208
    if (tmp == 0) {
#line 209
      return (x);
    }
#line 207
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (x);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int nonoptafter(char *option , int argc , char **oldargv , char **newargv , int optind___0 ) 
{ 
  int x ;
  int targetind ;
  int testind ;
  int startat ;

  {
  {
#line 221
  startat = 1;
#line 223
  targetind = findarg(option, 1, argc, oldargv);
#line 225
  x = optind___0;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (x < argc)) {
#line 225
      goto while_break;
    }
    {
#line 226
    testind = findarg(*(newargv + x), startat, argc, oldargv);
    }
#line 227
    if (testind > targetind) {
#line 227
      return (x);
    } else {
#line 228
      startat = testind;
    }
#line 225
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (x);
}
}
#line 243
int grokdir(char *dir , file_t **filelistp ) ;
#line 243 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
static int progress  =    0;
#line 244 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
static char indicator[5]  = {      (char )'-',      (char )'\\',      (char )'|',      (char )'/', 
        (char )'\000'};
#line 234 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int grokdir(char *dir , file_t **filelistp ) 
{ 
  DIR *cd ;
  file_t *newfile ;
  struct dirent *dirinfo ;
  int lastchar ;
  int filecount ;
  struct stat info ;
  struct stat linfo ;
  char *fullname ;
  char *name ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  off_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 240
  filecount = 0;
#line 247
  cd = opendir((char const   *)dir);
  }
#line 249
  if (! cd) {
    {
#line 250
    errormsg((char *)"could not chdir to %s\n", dir);
    }
#line 251
    return (0);
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 254
    dirinfo = readdir(cd);
    }
#line 254
    if (! ((unsigned long )dirinfo != (unsigned long )((void *)0))) {
#line 254
      goto while_break;
    }
    {
#line 255
    tmp___10 = strcmp((char const   *)(dirinfo->d_name), ".");
    }
#line 255
    if (tmp___10) {
      {
#line 255
      tmp___11 = strcmp((char const   *)(dirinfo->d_name), "..");
      }
#line 255
      if (tmp___11) {
#line 256
        if (! ((flags & 2UL) == 2UL)) {
          {
#line 257
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rBuilding file list %c ",
                  (int )indicator[progress]);
#line 258
          progress = (progress + 1) % 4;
          }
        }
        {
#line 261
        tmp = malloc(sizeof(file_t ));
#line 261
        newfile = (file_t *)tmp;
        }
#line 263
        if (! newfile) {
          {
#line 264
          errormsg((char *)"out of memory!\n");
#line 265
          closedir(cd);
#line 266
          exit(1);
          }
        } else {
#line 267
          newfile->next = *filelistp;
        }
        {
#line 269
        newfile->device = (dev_t )0;
#line 270
        newfile->inode = (ino_t )0;
#line 271
        newfile->crcsignature = (char *)((void *)0);
#line 272
        newfile->crcpartial = (char *)((void *)0);
#line 273
        newfile->duplicates = (struct _file *)((void *)0);
#line 274
        newfile->hasdupes = 0;
#line 276
        tmp___0 = strlen((char const   *)dir);
#line 276
        tmp___1 = strlen((char const   *)(dirinfo->d_name));
#line 276
        tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 276
        newfile->d_name = (char *)tmp___2;
        }
#line 278
        if (! newfile->d_name) {
          {
#line 279
          errormsg((char *)"out of memory!\n");
#line 280
          free((void *)newfile);
#line 281
          closedir(cd);
#line 282
          exit(1);
          }
        }
        {
#line 285
        strcpy((char */* __restrict  */)newfile->d_name, (char const   */* __restrict  */)dir);
#line 286
        tmp___3 = strlen((char const   *)dir);
#line 286
        lastchar = (int )(tmp___3 - 1UL);
        }
#line 287
        if (lastchar >= 0) {
#line 287
          if ((int )*(dir + lastchar) != 47) {
            {
#line 288
            strcat((char */* __restrict  */)newfile->d_name, (char const   */* __restrict  */)"/");
            }
          }
        }
        {
#line 289
        strcat((char */* __restrict  */)newfile->d_name, (char const   */* __restrict  */)(dirinfo->d_name));
        }
#line 291
        if ((flags & 4096UL) == 4096UL) {
          {
#line 292
          fullname = strdup((char const   *)newfile->d_name);
#line 293
          name = __xpg_basename(fullname);
          }
#line 294
          if ((int )*(name + 0) == 46) {
            {
#line 294
            tmp___4 = strcmp((char const   *)name, ".");
            }
#line 294
            if (tmp___4) {
              {
#line 294
              tmp___5 = strcmp((char const   *)name, "..");
              }
#line 294
              if (tmp___5) {
                {
#line 295
                free((void *)newfile->d_name);
#line 296
                free((void *)newfile);
                }
#line 297
                goto while_continue;
              }
            }
          }
          {
#line 299
          free((void *)fullname);
          }
        }
        {
#line 302
        tmp___6 = filesize(newfile->d_name);
        }
#line 302
        if (tmp___6 == 0L) {
#line 302
          if ((flags & 32UL) == 32UL) {
            {
#line 303
            free((void *)newfile->d_name);
#line 304
            free((void *)newfile);
            }
#line 305
            goto while_continue;
          }
        }
        {
#line 308
        tmp___7 = stat((char const   */* __restrict  */)newfile->d_name, (struct stat */* __restrict  */)(& info));
        }
#line 308
        if (tmp___7 == -1) {
          {
#line 309
          free((void *)newfile->d_name);
#line 310
          free((void *)newfile);
          }
#line 311
          goto while_continue;
        }
        {
#line 314
        tmp___8 = lstat((char const   */* __restrict  */)newfile->d_name, (struct stat */* __restrict  */)(& linfo));
        }
#line 314
        if (tmp___8 == -1) {
          {
#line 315
          free((void *)newfile->d_name);
#line 316
          free((void *)newfile);
          }
#line 317
          goto while_continue;
        }
#line 320
        if ((info.st_mode & 61440U) == 16384U) {
#line 321
          if ((flags & 1UL) == 1UL) {
#line 321
            if ((flags & 8UL) == 8UL) {
              {
#line 322
              tmp___9 = grokdir(newfile->d_name, filelistp);
#line 322
              filecount += tmp___9;
              }
            } else
#line 321
            if (! ((linfo.st_mode & 61440U) == 40960U)) {
              {
#line 322
              tmp___9 = grokdir(newfile->d_name, filelistp);
#line 322
              filecount += tmp___9;
              }
            }
          }
          {
#line 323
          free((void *)newfile->d_name);
#line 324
          free((void *)newfile);
          }
        } else
#line 326
        if ((linfo.st_mode & 61440U) == 32768U) {
#line 327
          *filelistp = newfile;
#line 328
          filecount ++;
        } else
#line 326
        if ((linfo.st_mode & 61440U) == 40960U) {
#line 326
          if ((flags & 8UL) == 8UL) {
#line 327
            *filelistp = newfile;
#line 328
            filecount ++;
          } else {
            {
#line 330
            free((void *)newfile->d_name);
#line 331
            free((void *)newfile);
            }
          }
        } else {
          {
#line 330
          free((void *)newfile->d_name);
#line 331
          free((void *)newfile);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  closedir(cd);
  }
#line 339
  return (filecount);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
static md5_byte_t chunk[8192]  ;
#line 354 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
static char signature[33]  ;
#line 346 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
char *getcrcsignatureuntil(char *filename , off_t max_read ) 
{ 
  int x ;
  off_t fsize ;
  off_t toread ;
  md5_state_t state ;
  md5_byte_t digest[16] ;
  char *sigp ;
  FILE *file ;
  size_t tmp ;

  {
  {
#line 358
  md5_init(& state);
#line 361
  fsize = filesize(filename);
  }
#line 363
  if (max_read != 0L) {
#line 363
    if (fsize > max_read) {
#line 364
      fsize = max_read;
    }
  }
  {
#line 366
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 367
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 368
    errormsg((char *)"error opening file %s\n", filename);
    }
#line 369
    return ((char *)((void *)0));
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (fsize > 0L)) {
#line 372
      goto while_break;
    }
#line 373
    if (fsize % 8192L) {
#line 373
      toread = fsize % 8192L;
    } else {
#line 373
      toread = (off_t )8192;
    }
    {
#line 374
    tmp = fread((void */* __restrict  */)(chunk), (size_t )toread, (size_t )1, (FILE */* __restrict  */)file);
    }
#line 374
    if (tmp != 1UL) {
      {
#line 375
      errormsg((char *)"error reading from file %s\n", filename);
#line 376
      fclose(file);
      }
#line 377
      return ((char *)((void *)0));
    }
    {
#line 379
    md5_append(& state, (md5_byte_t const   *)(chunk), (int )toread);
#line 380
    fsize -= toread;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  md5_finish(& state, (md5_byte_t *)(digest));
#line 385
  sigp = signature;
#line 387
  x = 0;
  }
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    if (! (x < 16)) {
#line 387
      goto while_break___0;
    }
    {
#line 388
    sprintf((char */* __restrict  */)sigp, (char const   */* __restrict  */)"%02x",
            (int )digest[x]);
#line 389
    sigp = strchr((char const   *)sigp, '\000');
#line 387
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 392
  fclose(file);
  }
#line 394
  return (signature);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
char *getcrcsignature(char *filename ) 
{ 
  char *tmp ;

  {
  {
#line 399
  tmp = getcrcsignatureuntil(filename, (off_t )0);
  }
#line 399
  return (tmp);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
char *getcrcpartialsignature(char *filename ) 
{ 
  char *tmp ;

  {
  {
#line 404
  tmp = getcrcsignatureuntil(filename, (off_t )4096);
  }
#line 404
  return (tmp);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void purgetree(filetree_t *checktree ) 
{ 


  {
#line 452
  if ((unsigned long )checktree->left != (unsigned long )((void *)0)) {
    {
#line 452
    purgetree(checktree->left);
    }
  }
#line 454
  if ((unsigned long )checktree->right != (unsigned long )((void *)0)) {
    {
#line 454
    purgetree(checktree->right);
    }
  }
  {
#line 456
  free((void *)checktree);
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void getfilestats(file_t *file ) 
{ 


  {
  {
#line 461
  file->size = filesize(file->d_name);
#line 462
  file->inode = getinode(file->d_name);
#line 463
  file->device = getdevice(file->d_name);
#line 464
  file->mtime = getmtime(file->d_name);
  }
#line 465
  return;
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int registerfile(filetree_t **branch , file_t *file ) 
{ 
  void *tmp ;

  {
  {
#line 469
  getfilestats(file);
#line 471
  tmp = malloc(sizeof(filetree_t ));
#line 471
  *branch = (filetree_t *)tmp;
  }
#line 472
  if ((unsigned long )*branch == (unsigned long )((void *)0)) {
    {
#line 473
    errormsg((char *)"out of memory!\n");
#line 474
    exit(1);
    }
  }
#line 477
  (*branch)->file = file;
#line 478
  (*branch)->left = (struct _filetree *)((void *)0);
#line 479
  (*branch)->right = (struct _filetree *)((void *)0);
#line 481
  return (1);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
file_t **checkmatch(filetree_t **root , filetree_t *checktree , file_t *file ) 
{ 
  int cmpresult ;
  char *crcsignature ;
  off_t fsize ;
  ino_t tmp ;
  dev_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  file_t **tmp___9 ;
  file_t **tmp___10 ;

  {
#line 496
  if (! ((flags & 64UL) == 64UL)) {
    {
#line 496
    tmp = getinode(file->d_name);
    }
#line 496
    if (tmp == (checktree->file)->inode) {
      {
#line 496
      tmp___0 = getdevice(file->d_name);
      }
#line 496
      if (tmp___0 == (checktree->file)->device) {
#line 498
        return ((file_t **)((void *)0));
      }
    }
  }
  {
#line 500
  fsize = filesize(file->d_name);
  }
#line 502
  if (fsize < (checktree->file)->size) {
#line 503
    cmpresult = -1;
  } else
#line 505
  if (fsize > (checktree->file)->size) {
#line 505
    cmpresult = 1;
  } else {
#line 507
    if ((unsigned long )(checktree->file)->crcpartial == (unsigned long )((void *)0)) {
      {
#line 508
      crcsignature = getcrcpartialsignature((checktree->file)->d_name);
      }
#line 509
      if ((unsigned long )crcsignature == (unsigned long )((void *)0)) {
        {
#line 510
        errormsg((char *)"cannot read file %s\n", (checktree->file)->d_name);
        }
#line 511
        return ((file_t **)((void *)0));
      }
      {
#line 514
      tmp___1 = strlen((char const   *)crcsignature);
#line 514
      tmp___2 = malloc(tmp___1 + 1UL);
#line 514
      (checktree->file)->crcpartial = (char *)tmp___2;
      }
#line 515
      if ((unsigned long )(checktree->file)->crcpartial == (unsigned long )((void *)0)) {
        {
#line 516
        errormsg((char *)"out of memory\n");
#line 517
        exit(1);
        }
      }
      {
#line 519
      strcpy((char */* __restrict  */)(checktree->file)->crcpartial, (char const   */* __restrict  */)crcsignature);
      }
    }
#line 522
    if ((unsigned long )file->crcpartial == (unsigned long )((void *)0)) {
      {
#line 523
      crcsignature = getcrcpartialsignature(file->d_name);
      }
#line 524
      if ((unsigned long )crcsignature == (unsigned long )((void *)0)) {
        {
#line 525
        errormsg((char *)"cannot read file %s\n", file->d_name);
        }
#line 526
        return ((file_t **)((void *)0));
      }
      {
#line 529
      tmp___3 = strlen((char const   *)crcsignature);
#line 529
      tmp___4 = malloc(tmp___3 + 1UL);
#line 529
      file->crcpartial = (char *)tmp___4;
      }
#line 530
      if ((unsigned long )file->crcpartial == (unsigned long )((void *)0)) {
        {
#line 531
        errormsg((char *)"out of memory\n");
#line 532
        exit(1);
        }
      }
      {
#line 534
      strcpy((char */* __restrict  */)file->crcpartial, (char const   */* __restrict  */)crcsignature);
      }
    }
    {
#line 537
    cmpresult = strcmp((char const   *)file->crcpartial, (char const   *)(checktree->file)->crcpartial);
    }
#line 540
    if (cmpresult == 0) {
#line 541
      if ((unsigned long )(checktree->file)->crcsignature == (unsigned long )((void *)0)) {
        {
#line 542
        crcsignature = getcrcsignature((checktree->file)->d_name);
        }
#line 543
        if ((unsigned long )crcsignature == (unsigned long )((void *)0)) {
#line 543
          return ((file_t **)((void *)0));
        }
        {
#line 545
        tmp___5 = strlen((char const   *)crcsignature);
#line 545
        tmp___6 = malloc(tmp___5 + 1UL);
#line 545
        (checktree->file)->crcsignature = (char *)tmp___6;
        }
#line 546
        if ((unsigned long )(checktree->file)->crcsignature == (unsigned long )((void *)0)) {
          {
#line 547
          errormsg((char *)"out of memory\n");
#line 548
          exit(1);
          }
        }
        {
#line 550
        strcpy((char */* __restrict  */)(checktree->file)->crcsignature, (char const   */* __restrict  */)crcsignature);
        }
      }
#line 553
      if ((unsigned long )file->crcsignature == (unsigned long )((void *)0)) {
        {
#line 554
        crcsignature = getcrcsignature(file->d_name);
        }
#line 555
        if ((unsigned long )crcsignature == (unsigned long )((void *)0)) {
#line 555
          return ((file_t **)((void *)0));
        }
        {
#line 557
        tmp___7 = strlen((char const   *)crcsignature);
#line 557
        tmp___8 = malloc(tmp___7 + 1UL);
#line 557
        file->crcsignature = (char *)tmp___8;
        }
#line 558
        if ((unsigned long )file->crcsignature == (unsigned long )((void *)0)) {
          {
#line 559
          errormsg((char *)"out of memory\n");
#line 560
          exit(1);
          }
        }
        {
#line 562
        strcpy((char */* __restrict  */)file->crcsignature, (char const   */* __restrict  */)crcsignature);
        }
      }
      {
#line 565
      cmpresult = strcmp((char const   *)file->crcsignature, (char const   *)(checktree->file)->crcsignature);
      }
    }
  }
#line 574
  if (cmpresult < 0) {
#line 575
    if ((unsigned long )checktree->left != (unsigned long )((void *)0)) {
      {
#line 576
      tmp___9 = checkmatch(root, checktree->left, file);
      }
#line 576
      return (tmp___9);
    } else {
      {
#line 578
      registerfile(& checktree->left, file);
      }
#line 579
      return ((file_t **)((void *)0));
    }
  } else
#line 581
  if (cmpresult > 0) {
#line 582
    if ((unsigned long )checktree->right != (unsigned long )((void *)0)) {
      {
#line 583
      tmp___10 = checkmatch(root, checktree->right, file);
      }
#line 583
      return (tmp___10);
    } else {
      {
#line 585
      registerfile(& checktree->right, file);
      }
#line 586
      return ((file_t **)((void *)0));
    }
  } else {
    {
#line 590
    getfilestats(file);
    }
#line 591
    return (& checktree->file);
  }
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int confirmmatch(FILE *file1 , FILE *file2 ) 
{ 
  unsigned char c1[8192] ;
  unsigned char c2[8192] ;
  size_t r1 ;
  size_t r2 ;
  int tmp ;

  {
  {
#line 605
  fseek(file1, 0L, 0);
#line 606
  fseek(file2, 0L, 0);
  }
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 609
    r1 = fread((void */* __restrict  */)(c1), (size_t )1, sizeof(c1), (FILE */* __restrict  */)file1);
#line 610
    r2 = fread((void */* __restrict  */)(c2), (size_t )1, sizeof(c2), (FILE */* __restrict  */)file2);
    }
#line 612
    if (r1 != r2) {
#line 612
      return (0);
    }
    {
#line 613
    tmp = memcmp((void const   *)(c1), (void const   *)(c2), r1);
    }
#line 613
    if (tmp) {
#line 613
      return (0);
    }
#line 608
    if (! r2) {
#line 608
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return (1);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void summarizematches(file_t *files ) 
{ 
  int numsets ;
  double numbytes ;
  int numfiles ;
  file_t *tmpfile___0 ;

  {
#line 621
  numsets = 0;
#line 622
  numbytes = 0.0;
#line 623
  numfiles = 0;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (! ((unsigned long )files != (unsigned long )((void *)0))) {
#line 626
      goto while_break;
    }
#line 628
    if (files->hasdupes) {
#line 630
      numsets ++;
#line 632
      tmpfile___0 = files->duplicates;
      {
#line 633
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 633
        if (! ((unsigned long )tmpfile___0 != (unsigned long )((void *)0))) {
#line 633
          goto while_break___0;
        }
#line 635
        numfiles ++;
#line 636
        numbytes += (double )files->size;
#line 637
        tmpfile___0 = tmpfile___0->duplicates;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 641
    files = files->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (numsets == 0) {
    {
#line 645
    printf((char const   */* __restrict  */)"No duplicates found.\n\n");
    }
  } else
#line 648
  if (numbytes < 1024.0) {
    {
#line 649
    printf((char const   */* __restrict  */)"%d duplicate files (in %d sets), occupying %.0f bytes.\n\n",
           numfiles, numsets, numbytes);
    }
  } else
#line 650
  if (numbytes <= 1000.0 * 1000.0) {
    {
#line 651
    printf((char const   */* __restrict  */)"%d duplicate files (in %d sets), occupying %.1f kylobytes\n\n",
           numfiles, numsets, numbytes / 1000.0);
    }
  } else {
    {
#line 653
    printf((char const   */* __restrict  */)"%d duplicate files (in %d sets), occupying %.1f megabytes\n\n",
           numfiles, numsets, numbytes / (1000.0 * 1000.0));
    }
  }
#line 656
  return;
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void printmatches(file_t *files ) 
{ 
  file_t *tmpfile___0 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! ((unsigned long )files != (unsigned long )((void *)0))) {
#line 662
      goto while_break;
    }
#line 663
    if (files->hasdupes) {
#line 664
      if (! ((flags & 256UL) == 256UL)) {
#line 665
        if ((flags & 128UL) == 128UL) {
#line 665
          if (files->size != 1L) {
#line 665
            tmp = "s ";
          } else {
#line 665
            tmp = " ";
          }
          {
#line 665
          printf((char const   */* __restrict  */)"%lld byte%seach:\n", files->size,
                 tmp);
          }
        }
#line 667
        if ((flags & 4UL) == 4UL) {
          {
#line 667
          escapefilename((char *)"\\ ", & files->d_name);
          }
        }
#line 668
        if ((flags & 4UL) == 4UL) {
#line 668
          tmp___0 = ' ';
        } else {
#line 668
          tmp___0 = '\n';
        }
        {
#line 668
        printf((char const   */* __restrict  */)"%s%c", files->d_name, tmp___0);
        }
      }
#line 670
      tmpfile___0 = files->duplicates;
      {
#line 671
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 671
        if (! ((unsigned long )tmpfile___0 != (unsigned long )((void *)0))) {
#line 671
          goto while_break___0;
        }
#line 672
        if ((flags & 4UL) == 4UL) {
          {
#line 672
          escapefilename((char *)"\\ ", & tmpfile___0->d_name);
          }
        }
#line 673
        if ((flags & 4UL) == 4UL) {
#line 673
          tmp___1 = ' ';
        } else {
#line 673
          tmp___1 = '\n';
        }
        {
#line 673
        printf((char const   */* __restrict  */)"%s%c", tmpfile___0->d_name, tmp___1);
#line 674
        tmpfile___0 = tmpfile___0->duplicates;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 676
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 680
    files = files->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return;
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int relink(char *oldfile , char *newfile ) 
{ 
  dev_t od ;
  dev_t nd ;
  ino_t oi ;
  ino_t ni ;
  int tmp ;

  {
  {
#line 725
  od = getdevice(oldfile);
#line 726
  oi = getinode(oldfile);
#line 728
  tmp = link((char const   *)oldfile, (char const   *)newfile);
  }
#line 728
  if (tmp != 0) {
#line 729
    return (0);
  }
  {
#line 732
  nd = getdevice(newfile);
#line 733
  ni = getinode(newfile);
  }
#line 735
  if (nd != od) {
#line 736
    return (0);
  } else
#line 735
  if (oi != ni) {
#line 736
    return (0);
  }
#line 738
  return (1);
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void deletefiles(file_t *files , int prompt , FILE *tty ) 
{ 
  int counter ;
  int groups ;
  int curgroup ;
  file_t *tmpfile___0 ;
  file_t *curfile ;
  file_t **dupelist ;
  int *preserve ;
  char *preservestr ;
  char *token ;
  char *tstr ;
  int number ;
  int sum ;
  int max ;
  int x ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 744
  groups = 0;
#line 745
  curgroup = 0;
#line 755
  max = 0;
#line 759
  curfile = files;
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! curfile) {
#line 761
      goto while_break;
    }
#line 762
    if (curfile->hasdupes) {
#line 763
      counter = 1;
#line 764
      groups ++;
#line 766
      tmpfile___0 = curfile->duplicates;
      {
#line 767
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 767
        if (! tmpfile___0) {
#line 767
          goto while_break___0;
        }
#line 768
        counter ++;
#line 769
        tmpfile___0 = tmpfile___0->duplicates;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 772
      if (counter > max) {
#line 772
        max = counter;
      }
    }
#line 775
    curfile = curfile->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 778
  max ++;
#line 780
  tmp = malloc(sizeof(file_t *) * (unsigned long )max);
#line 780
  dupelist = (file_t **)tmp;
#line 781
  tmp___0 = malloc(sizeof(int ) * (unsigned long )max);
#line 781
  preserve = (int *)tmp___0;
#line 782
  tmp___1 = malloc((size_t )256);
#line 782
  preservestr = (char *)tmp___1;
  }
#line 784
  if (! dupelist) {
    {
#line 785
    errormsg((char *)"out of memory\n");
#line 786
    exit(1);
    }
  } else
#line 784
  if (! preserve) {
    {
#line 785
    errormsg((char *)"out of memory\n");
#line 786
    exit(1);
    }
  } else
#line 784
  if (! preservestr) {
    {
#line 785
    errormsg((char *)"out of memory\n");
#line 786
    exit(1);
    }
  }
  {
#line 789
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 789
    if (! files) {
#line 789
      goto while_break___1;
    }
#line 790
    if (files->hasdupes) {
#line 791
      curgroup ++;
#line 792
      counter = 1;
#line 793
      *(dupelist + counter) = files;
#line 795
      if (prompt) {
        {
#line 795
        printf((char const   */* __restrict  */)"[%d] %s\n", counter, files->d_name);
        }
      }
#line 797
      tmpfile___0 = files->duplicates;
      {
#line 799
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 799
        if (! tmpfile___0) {
#line 799
          goto while_break___2;
        }
#line 800
        counter ++;
#line 800
        *(dupelist + counter) = tmpfile___0;
#line 801
        if (prompt) {
          {
#line 801
          printf((char const   */* __restrict  */)"[%d] %s\n", counter, tmpfile___0->d_name);
          }
        }
#line 802
        tmpfile___0 = tmpfile___0->duplicates;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 805
      if (prompt) {
        {
#line 805
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 807
      if (! prompt) {
#line 809
        *(preserve + 1) = 1;
#line 810
        x = 2;
        {
#line 810
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 810
          if (! (x <= counter)) {
#line 810
            goto while_break___3;
          }
#line 810
          *(preserve + x) = 0;
#line 810
          x ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 815
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 816
          printf((char const   */* __restrict  */)"Set %d of %d, preserve files [1 - %d, all]",
                 curgroup, groups, counter);
          }
#line 818
          if ((flags & 128UL) == 128UL) {
#line 818
            if (files->size != 1L) {
#line 818
              tmp___2 = "s ";
            } else {
#line 818
              tmp___2 = " ";
            }
            {
#line 818
            printf((char const   */* __restrict  */)" (%lld byte%seach)", files->size,
                   tmp___2);
            }
          }
          {
#line 820
          printf((char const   */* __restrict  */)": ");
#line 821
          fflush(stdout);
#line 823
          tmp___3 = fgets((char */* __restrict  */)preservestr, 256, (FILE */* __restrict  */)tty);
          }
#line 823
          if (! tmp___3) {
#line 824
            *(preservestr + 0) = (char )'\n';
          }
          {
#line 826
          tmp___4 = strlen((char const   *)preservestr);
#line 826
          i = (int )(tmp___4 - 1UL);
          }
          {
#line 828
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 828
            if (! ((int )*(preservestr + i) != 10)) {
#line 828
              goto while_break___5;
            }
            {
#line 829
            tmp___5 = strlen((char const   *)preservestr);
#line 829
            tmp___6 = realloc((void *)preservestr, (tmp___5 + 1UL) + 256UL);
#line 829
            tstr = (char *)tmp___6;
            }
#line 831
            if (! tstr) {
              {
#line 832
              errormsg((char *)"out of memory!\n");
#line 833
              exit(1);
              }
            }
            {
#line 836
            preservestr = tstr;
#line 837
            tmp___7 = fgets((char */* __restrict  */)((preservestr + i) + 1), 256,
                            (FILE */* __restrict  */)tty);
            }
#line 837
            if (! tmp___7) {
#line 839
              *(preservestr + 0) = (char )'\n';
#line 840
              goto while_break___5;
            }
            {
#line 842
            tmp___8 = strlen((char const   *)preservestr);
#line 842
            i = (int )(tmp___8 - 1UL);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 845
          x = 1;
          {
#line 845
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 845
            if (! (x <= counter)) {
#line 845
              goto while_break___6;
            }
#line 845
            *(preserve + x) = 0;
#line 845
            x ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 847
          token = strtok((char */* __restrict  */)preservestr, (char const   */* __restrict  */)" ,\n");
          }
          {
#line 849
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 849
            if (! ((unsigned long )token != (unsigned long )((void *)0))) {
#line 849
              goto while_break___7;
            }
            {
#line 850
            tmp___9 = strcasecmp((char const   *)token, "all");
            }
#line 850
            if (tmp___9 == 0) {
#line 851
              x = 0;
              {
#line 851
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 851
                if (! (x <= counter)) {
#line 851
                  goto while_break___8;
                }
#line 851
                *(preserve + x) = 1;
#line 851
                x ++;
              }
              while_break___8: /* CIL Label */ ;
              }
            }
            {
#line 853
            number = 0;
#line 854
            sscanf((char const   */* __restrict  */)token, (char const   */* __restrict  */)"%d",
                   & number);
            }
#line 855
            if (number > 0) {
#line 855
              if (number <= counter) {
#line 855
                *(preserve + number) = 1;
              }
            }
            {
#line 857
            token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ,\n");
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 860
          sum = 0;
#line 860
          x = 1;
          {
#line 860
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 860
            if (! (x <= counter)) {
#line 860
              goto while_break___9;
            }
#line 860
            sum += *(preserve + x);
#line 860
            x ++;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 815
          if (! (sum < 1)) {
#line 815
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 863
      printf((char const   */* __restrict  */)"\n");
#line 865
      x = 1;
      }
      {
#line 865
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 865
        if (! (x <= counter)) {
#line 865
          goto while_break___10;
        }
#line 866
        if (*(preserve + x)) {
          {
#line 867
          printf((char const   */* __restrict  */)"   [+] %s\n", (*(dupelist + x))->d_name);
          }
        } else {
          {
#line 869
          tmp___10 = remove((char const   *)(*(dupelist + x))->d_name);
          }
#line 869
          if (tmp___10 == 0) {
            {
#line 870
            printf((char const   */* __restrict  */)"   [-] %s\n", (*(dupelist + x))->d_name);
            }
          } else {
            {
#line 872
            printf((char const   */* __restrict  */)"   [!] %s ", (*(dupelist + x))->d_name);
#line 873
            printf((char const   */* __restrict  */)"-- unable to delete file!\n");
            }
          }
        }
#line 865
        x ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 877
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 880
    files = files->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 883
  free((void *)dupelist);
#line 884
  free((void *)preserve);
#line 885
  free((void *)preservestr);
  }
#line 886
  return;
}
}
#line 888 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int sort_pairs_by_arrival(file_t *f1 , file_t *f2 ) 
{ 


  {
#line 890
  if ((unsigned long )f2->duplicates != (unsigned long )((struct _file *)0)) {
#line 891
    return (1);
  }
#line 893
  return (-1);
}
}
#line 896 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int sort_pairs_by_mtime(file_t *f1 , file_t *f2 ) 
{ 


  {
#line 898
  if (f1->mtime < f2->mtime) {
#line 899
    return (-1);
  } else
#line 900
  if (f1->mtime > f2->mtime) {
#line 901
    return (1);
  }
#line 903
  return (0);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void registerpair(file_t **matchlist , file_t *newmatch , int (*comparef)(file_t *f1 ,
                                                                          file_t *f2 ) ) 
{ 
  file_t *traverse ;
  file_t *back ;
  int tmp ;

  {
#line 912
  (*matchlist)->hasdupes = 1;
#line 914
  back = (file_t *)0;
#line 915
  traverse = *matchlist;
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! traverse) {
#line 916
      goto while_break;
    }
    {
#line 918
    tmp = (*comparef)(newmatch, traverse);
    }
#line 918
    if (tmp <= 0) {
#line 920
      newmatch->duplicates = traverse;
#line 922
      if ((unsigned long )back == (unsigned long )((file_t *)0)) {
#line 924
        *matchlist = newmatch;
#line 926
        newmatch->hasdupes = 1;
#line 927
        traverse->hasdupes = 0;
      } else {
#line 930
        back->duplicates = newmatch;
      }
#line 932
      goto while_break;
    } else
#line 936
    if ((unsigned long )traverse->duplicates == (unsigned long )((struct _file *)0)) {
#line 938
      traverse->duplicates = newmatch;
#line 940
      if ((unsigned long )back == (unsigned long )((file_t *)0)) {
#line 941
        traverse->hasdupes = 1;
      }
#line 943
      goto while_break;
    }
#line 947
    back = traverse;
#line 948
    traverse = traverse->duplicates;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  return;
}
}
#line 952 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
void help_text(void) 
{ 


  {
  {
#line 954
  printf((char const   */* __restrict  */)"Usage: fdupes [options] DIRECTORY...\n\n");
#line 956
  printf((char const   */* __restrict  */)" -r --recurse     \tfor every directory given follow subdirectories\n");
#line 957
  printf((char const   */* __restrict  */)"                  \tencountered within\n");
#line 958
  printf((char const   */* __restrict  */)" -R --recurse:    \tfor each directory given after this option follow\n");
#line 959
  printf((char const   */* __restrict  */)"                  \tsubdirectories encountered within (note the \':\' at\n");
#line 960
  printf((char const   */* __restrict  */)"                  \tthe end of the option, manpage for more details)\n");
#line 961
  printf((char const   */* __restrict  */)" -s --symlinks    \tfollow symlinks\n");
#line 962
  printf((char const   */* __restrict  */)" -H --hardlinks   \tnormally, when two or more files point to the same\n");
#line 963
  printf((char const   */* __restrict  */)"                  \tdisk area they are treated as non-duplicates; this\n");
#line 964
  printf((char const   */* __restrict  */)"                  \toption will change this behavior\n");
#line 965
  printf((char const   */* __restrict  */)" -n --noempty     \texclude zero-length files from consideration\n");
#line 966
  printf((char const   */* __restrict  */)" -A --nohidden    \texclude hidden files from consideration\n");
#line 967
  printf((char const   */* __restrict  */)" -f --omitfirst   \tomit the first file in each set of matches\n");
#line 968
  printf((char const   */* __restrict  */)" -1 --sameline    \tlist each set of matches on a single line\n");
#line 969
  printf((char const   */* __restrict  */)" -S --size        \tshow size of duplicate files\n");
#line 970
  printf((char const   */* __restrict  */)" -m --summarize   \tsummarize dupe information\n");
#line 971
  printf((char const   */* __restrict  */)" -q --quiet       \thide progress indicator\n");
#line 972
  printf((char const   */* __restrict  */)" -d --delete      \tprompt user for files to preserve and delete all\n");
#line 973
  printf((char const   */* __restrict  */)"                  \tothers; important: under particular circumstances,\n");
#line 974
  printf((char const   */* __restrict  */)"                  \tdata may be lost when using this option together\n");
#line 975
  printf((char const   */* __restrict  */)"                  \twith -s or --symlinks, or when specifying a\n");
#line 976
  printf((char const   */* __restrict  */)"                  \tparticular directory more than once; refer to the\n");
#line 977
  printf((char const   */* __restrict  */)"                  \tfdupes documentation for additional information\n");
#line 979
  printf((char const   */* __restrict  */)" -N --noprompt    \ttogether with --delete, preserve the first file in\n");
#line 980
  printf((char const   */* __restrict  */)"                  \teach set of duplicates and delete the rest without\n");
#line 981
  printf((char const   */* __restrict  */)"                  \tprompting the user\n");
#line 982
  printf((char const   */* __restrict  */)" -v --version     \tdisplay fdupes version\n");
#line 983
  printf((char const   */* __restrict  */)" -h --help        \tdisplay this help message\n\n");
  }
#line 987
  return;
}
}
#line 1004
int main(int argc , char **argv ) ;
#line 1004 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
static struct option long_options[20]  = 
#line 1004
  {      {"omitfirst", 0, (int *)0, 'f'}, 
        {"recurse", 0, (int *)0, 'r'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"recurse:", 0, (int *)0, 'R'}, 
        {"recursive:", 0, (int *)0, 'R'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"sameline", 0, (int *)0, '1'}, 
        {"size", 0, (int *)0, 'S'}, 
        {"symlinks", 0, (int *)0, 's'}, 
        {"hardlinks", 0, (int *)0, 'H'}, 
        {"relink", 0, (int *)0, 'l'}, 
        {"noempty", 0, (int *)0, 'n'}, 
        {"nohidden", 0, (int *)0, 'A'}, 
        {"delete", 0, (int *)0, 'd'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"noprompt", 0, (int *)0, 'N'}, 
        {"summarize", 0, (int *)0, 'm'}, 
        {"summary", 0, (int *)0, 'm'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 989 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/fdupes.c"
int main(int argc , char **argv ) 
{ 
  int x ;
  int opt ;
  FILE *file1 ;
  FILE *file2 ;
  file_t *files ;
  file_t *curfile ;
  file_t **match ;
  filetree_t *checktree ;
  int filecount ;
  int progress___0 ;
  char **oldargv ;
  int firstrecurse ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 994
  files = (file_t *)((void *)0);
#line 996
  match = (file_t **)((void *)0);
#line 997
  checktree = (filetree_t *)((void *)0);
#line 998
  filecount = 0;
#line 999
  progress___0 = 0;
#line 1032
  program_name = *(argv + 0);
#line 1034
  oldargv = cloneargs(argc, argv);
  }
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1036
    opt = getopt_long(argc, (char * const  *)argv, "frRq1Ss::HlnAdvhNm", (struct option  const  *)(long_options),
                      (int *)((void *)0));
    }
#line 1036
    if (! (opt != -1)) {
#line 1036
      goto while_break;
    }
    {
#line 1042
    if (opt == 102) {
#line 1042
      goto case_102;
    }
#line 1045
    if (opt == 114) {
#line 1045
      goto case_114;
    }
#line 1048
    if (opt == 82) {
#line 1048
      goto case_82;
    }
#line 1051
    if (opt == 113) {
#line 1051
      goto case_113;
    }
#line 1054
    if (opt == 49) {
#line 1054
      goto case_49;
    }
#line 1057
    if (opt == 83) {
#line 1057
      goto case_83;
    }
#line 1060
    if (opt == 115) {
#line 1060
      goto case_115;
    }
#line 1063
    if (opt == 72) {
#line 1063
      goto case_72;
    }
#line 1066
    if (opt == 110) {
#line 1066
      goto case_110;
    }
#line 1069
    if (opt == 65) {
#line 1069
      goto case_65;
    }
#line 1072
    if (opt == 100) {
#line 1072
      goto case_100;
    }
#line 1075
    if (opt == 118) {
#line 1075
      goto case_118;
    }
#line 1078
    if (opt == 104) {
#line 1078
      goto case_104;
    }
#line 1081
    if (opt == 78) {
#line 1081
      goto case_78;
    }
#line 1084
    if (opt == 109) {
#line 1084
      goto case_109;
    }
#line 1088
    goto switch_default;
    case_102: /* CIL Label */ 
#line 1043
    flags |= 256UL;
#line 1044
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1046
    flags |= 1UL;
#line 1047
    goto switch_break;
    case_82: /* CIL Label */ 
#line 1049
    flags |= 512UL;
#line 1050
    goto switch_break;
    case_113: /* CIL Label */ 
#line 1052
    flags |= 2UL;
#line 1053
    goto switch_break;
    case_49: /* CIL Label */ 
#line 1055
    flags |= 4UL;
#line 1056
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1058
    flags |= 128UL;
#line 1059
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1061
    flags |= 8UL;
#line 1062
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1064
    flags |= 64UL;
#line 1065
    goto switch_break;
    case_110: /* CIL Label */ 
#line 1067
    flags |= 32UL;
#line 1068
    goto switch_break;
    case_65: /* CIL Label */ 
#line 1070
    flags |= 4096UL;
#line 1071
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1073
    flags |= 16UL;
#line 1074
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 1076
    printf((char const   */* __restrict  */)"fdupes %s\n", "1.51");
#line 1077
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 1079
    help_text();
#line 1080
    exit(1);
    }
    case_78: /* CIL Label */ 
#line 1082
    flags |= 1024UL;
#line 1083
    goto switch_break;
    case_109: /* CIL Label */ 
#line 1085
    flags |= 2048UL;
#line 1086
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1089
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `fdupes --help\' for more information.\n");
#line 1090
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1094
  if (optind >= argc) {
    {
#line 1095
    errormsg((char *)"no directories specified\n");
#line 1096
    exit(1);
    }
  }
#line 1099
  if ((flags & 1UL) == 1UL) {
#line 1099
    if ((flags & 512UL) == 512UL) {
      {
#line 1100
      errormsg((char *)"options --recurse and --recurse: are not compatible\n");
#line 1101
      exit(1);
      }
    }
  }
#line 1104
  if ((flags & 2048UL) == 2048UL) {
#line 1104
    if ((flags & 16UL) == 16UL) {
      {
#line 1105
      errormsg((char *)"options --summarize and --delete are not compatible\n");
#line 1106
      exit(1);
      }
    }
  }
#line 1109
  if ((flags & 512UL) == 512UL) {
    {
#line 1110
    firstrecurse = nonoptafter((char *)"--recurse:", argc, oldargv, argv, optind);
    }
#line 1112
    if (firstrecurse == argc) {
      {
#line 1113
      firstrecurse = nonoptafter((char *)"-R", argc, oldargv, argv, optind);
      }
    }
#line 1115
    if (firstrecurse == argc) {
      {
#line 1116
      errormsg((char *)"-R option must be isolated from other options\n");
#line 1117
      exit(1);
      }
    }
#line 1121
    x = optind;
    {
#line 1121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1121
      if (! (x < firstrecurse)) {
#line 1121
        goto while_break___0;
      }
      {
#line 1122
      tmp = grokdir(*(argv + x), & files);
#line 1122
      filecount += tmp;
#line 1121
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1125
    flags |= 1UL;
#line 1127
    x = firstrecurse;
    {
#line 1127
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1127
      if (! (x < argc)) {
#line 1127
        goto while_break___1;
      }
      {
#line 1128
      tmp___0 = grokdir(*(argv + x), & files);
#line 1128
      filecount += tmp___0;
#line 1127
      x ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1130
    x = optind;
    {
#line 1130
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1130
      if (! (x < argc)) {
#line 1130
        goto while_break___2;
      }
      {
#line 1131
      tmp___1 = grokdir(*(argv + x), & files);
#line 1131
      filecount += tmp___1;
#line 1130
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1134
  if (! files) {
#line 1135
    if (! ((flags & 2UL) == 2UL)) {
      {
#line 1135
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%40s\r",
              " ");
      }
    }
    {
#line 1136
    exit(0);
    }
  }
#line 1139
  curfile = files;
  {
#line 1141
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1141
    if (! curfile) {
#line 1141
      goto while_break___3;
    }
#line 1142
    if (! checktree) {
      {
#line 1143
      registerfile(& checktree, curfile);
      }
    } else {
      {
#line 1145
      match = checkmatch(& checktree, checktree, curfile);
      }
    }
#line 1147
    if ((unsigned long )match != (unsigned long )((void *)0)) {
      {
#line 1148
      file1 = fopen((char const   */* __restrict  */)curfile->d_name, (char const   */* __restrict  */)"rb");
      }
#line 1149
      if (! file1) {
#line 1150
        curfile = curfile->next;
#line 1151
        goto while_continue___3;
      }
      {
#line 1154
      file2 = fopen((char const   */* __restrict  */)(*match)->d_name, (char const   */* __restrict  */)"rb");
      }
#line 1155
      if (! file2) {
        {
#line 1156
        fclose(file1);
#line 1157
        curfile = curfile->next;
        }
#line 1158
        goto while_continue___3;
      }
      {
#line 1161
      tmp___2 = confirmmatch(file1, file2);
      }
#line 1161
      if (tmp___2) {
        {
#line 1162
        registerpair(match, curfile, & sort_pairs_by_mtime);
        }
      }
      {
#line 1169
      fclose(file1);
#line 1170
      fclose(file2);
      }
    }
#line 1173
    curfile = curfile->next;
#line 1175
    if (! ((flags & 2UL) == 2UL)) {
      {
#line 1176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rProgress [%d/%d] %d%% ",
              progress___0, filecount, (int )((double )((float )progress___0 / (float )filecount) * 100.0));
#line 1178
      progress___0 ++;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1182
  if (! ((flags & 2UL) == 2UL)) {
    {
#line 1182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%40s\r",
            " ");
    }
  }
#line 1184
  if ((flags & 16UL) == 16UL) {
#line 1186
    if ((flags & 1024UL) == 1024UL) {
      {
#line 1188
      deletefiles(files, 0, (FILE *)0);
      }
    } else {
      {
#line 1192
      stdin = freopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r",
                      (FILE */* __restrict  */)stdin);
#line 1193
      deletefiles(files, 1, stdin);
      }
    }
  } else
#line 1199
  if ((flags & 2048UL) == 2048UL) {
    {
#line 1200
    summarizematches(files);
    }
  } else {
    {
#line 1204
    printmatches(files);
    }
  }
  {
#line 1206
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1206
    if (! files) {
#line 1206
      goto while_break___4;
    }
    {
#line 1207
    curfile = files->next;
#line 1208
    free((void *)files->d_name);
#line 1209
    free((void *)files->crcsignature);
#line 1210
    free((void *)files->crcpartial);
#line 1211
    free((void *)files);
#line 1212
    files = curfile;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1215
  x = 0;
  {
#line 1215
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1215
    if (! (x < argc)) {
#line 1215
      goto while_break___5;
    }
    {
#line 1216
    free((void *)*(oldargv + x));
#line 1215
    x ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1218
  free((void *)oldargv);
#line 1220
  purgetree(checktree);
  }
#line 1222
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.c"
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t X[16] ;
  md5_byte_t const   *xp ;
  int i ;

  {
#line 172
  a = pms->abcd[0];
#line 172
  b = pms->abcd[1];
#line 172
  c = pms->abcd[2];
#line 172
  d = pms->abcd[3];
#line 187
  xp = data;
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < 16)) {
#line 190
      goto while_break;
    }
#line 191
    X[i] = (md5_word_t )((((int const   )*(xp + 0) + ((int const   )*(xp + 1) << 8)) + ((int const   )*(xp + 2) << 16)) + ((int const   )*(xp + 3) << 24));
#line 190
    i ++;
#line 190
    xp += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  t = ((a + ((b & c) | (~ b & d))) + X[0]) + 3614090360U;
#line 222
  a = ((t << 7) | (t >> 25)) + b;
#line 223
  t = ((d + ((a & b) | (~ a & c))) + X[1]) + 3905402710U;
#line 223
  d = ((t << 12) | (t >> 20)) + a;
#line 224
  t = ((c + ((d & a) | (~ d & b))) + X[2]) + 606105819U;
#line 224
  c = ((t << 17) | (t >> 15)) + d;
#line 225
  t = ((b + ((c & d) | (~ c & a))) + X[3]) + 3250441966U;
#line 225
  b = ((t << 22) | (t >> 10)) + c;
#line 226
  t = ((a + ((b & c) | (~ b & d))) + X[4]) + 4118548399U;
#line 226
  a = ((t << 7) | (t >> 25)) + b;
#line 227
  t = ((d + ((a & b) | (~ a & c))) + X[5]) + 1200080426U;
#line 227
  d = ((t << 12) | (t >> 20)) + a;
#line 228
  t = ((c + ((d & a) | (~ d & b))) + X[6]) + 2821735955U;
#line 228
  c = ((t << 17) | (t >> 15)) + d;
#line 229
  t = ((b + ((c & d) | (~ c & a))) + X[7]) + 4249261313U;
#line 229
  b = ((t << 22) | (t >> 10)) + c;
#line 230
  t = ((a + ((b & c) | (~ b & d))) + X[8]) + 1770035416U;
#line 230
  a = ((t << 7) | (t >> 25)) + b;
#line 231
  t = ((d + ((a & b) | (~ a & c))) + X[9]) + 2336552879U;
#line 231
  d = ((t << 12) | (t >> 20)) + a;
#line 232
  t = ((c + ((d & a) | (~ d & b))) + X[10]) + 4294925233U;
#line 232
  c = ((t << 17) | (t >> 15)) + d;
#line 233
  t = ((b + ((c & d) | (~ c & a))) + X[11]) + 2304563134U;
#line 233
  b = ((t << 22) | (t >> 10)) + c;
#line 234
  t = ((a + ((b & c) | (~ b & d))) + X[12]) + 1804603682U;
#line 234
  a = ((t << 7) | (t >> 25)) + b;
#line 235
  t = ((d + ((a & b) | (~ a & c))) + X[13]) + 4254626195U;
#line 235
  d = ((t << 12) | (t >> 20)) + a;
#line 236
  t = ((c + ((d & a) | (~ d & b))) + X[14]) + 2792965006U;
#line 236
  c = ((t << 17) | (t >> 15)) + d;
#line 237
  t = ((b + ((c & d) | (~ c & a))) + X[15]) + 1236535329U;
#line 237
  b = ((t << 22) | (t >> 10)) + c;
#line 248
  t = ((a + ((b & d) | (c & ~ d))) + X[1]) + 4129170786U;
#line 248
  a = ((t << 5) | (t >> 27)) + b;
#line 249
  t = ((d + ((a & c) | (b & ~ c))) + X[6]) + 3225465664U;
#line 249
  d = ((t << 9) | (t >> 23)) + a;
#line 250
  t = ((c + ((d & b) | (a & ~ b))) + X[11]) + 643717713U;
#line 250
  c = ((t << 14) | (t >> 18)) + d;
#line 251
  t = ((b + ((c & a) | (d & ~ a))) + X[0]) + 3921069994U;
#line 251
  b = ((t << 20) | (t >> 12)) + c;
#line 252
  t = ((a + ((b & d) | (c & ~ d))) + X[5]) + 3593408605U;
#line 252
  a = ((t << 5) | (t >> 27)) + b;
#line 253
  t = ((d + ((a & c) | (b & ~ c))) + X[10]) + 38016083U;
#line 253
  d = ((t << 9) | (t >> 23)) + a;
#line 254
  t = ((c + ((d & b) | (a & ~ b))) + X[15]) + 3634488961U;
#line 254
  c = ((t << 14) | (t >> 18)) + d;
#line 255
  t = ((b + ((c & a) | (d & ~ a))) + X[4]) + 3889429448U;
#line 255
  b = ((t << 20) | (t >> 12)) + c;
#line 256
  t = ((a + ((b & d) | (c & ~ d))) + X[9]) + 568446438U;
#line 256
  a = ((t << 5) | (t >> 27)) + b;
#line 257
  t = ((d + ((a & c) | (b & ~ c))) + X[14]) + 3275163606U;
#line 257
  d = ((t << 9) | (t >> 23)) + a;
#line 258
  t = ((c + ((d & b) | (a & ~ b))) + X[3]) + 4107603335U;
#line 258
  c = ((t << 14) | (t >> 18)) + d;
#line 259
  t = ((b + ((c & a) | (d & ~ a))) + X[8]) + 1163531501U;
#line 259
  b = ((t << 20) | (t >> 12)) + c;
#line 260
  t = ((a + ((b & d) | (c & ~ d))) + X[13]) + 2850285829U;
#line 260
  a = ((t << 5) | (t >> 27)) + b;
#line 261
  t = ((d + ((a & c) | (b & ~ c))) + X[2]) + 4243563512U;
#line 261
  d = ((t << 9) | (t >> 23)) + a;
#line 262
  t = ((c + ((d & b) | (a & ~ b))) + X[7]) + 1735328473U;
#line 262
  c = ((t << 14) | (t >> 18)) + d;
#line 263
  t = ((b + ((c & a) | (d & ~ a))) + X[12]) + 2368359562U;
#line 263
  b = ((t << 20) | (t >> 12)) + c;
#line 274
  t = ((a + ((b ^ c) ^ d)) + X[5]) + 4294588738U;
#line 274
  a = ((t << 4) | (t >> 28)) + b;
#line 275
  t = ((d + ((a ^ b) ^ c)) + X[8]) + 2272392833U;
#line 275
  d = ((t << 11) | (t >> 21)) + a;
#line 276
  t = ((c + ((d ^ a) ^ b)) + X[11]) + 1839030562U;
#line 276
  c = ((t << 16) | (t >> 16)) + d;
#line 277
  t = ((b + ((c ^ d) ^ a)) + X[14]) + 4259657740U;
#line 277
  b = ((t << 23) | (t >> 9)) + c;
#line 278
  t = ((a + ((b ^ c) ^ d)) + X[1]) + 2763975236U;
#line 278
  a = ((t << 4) | (t >> 28)) + b;
#line 279
  t = ((d + ((a ^ b) ^ c)) + X[4]) + 1272893353U;
#line 279
  d = ((t << 11) | (t >> 21)) + a;
#line 280
  t = ((c + ((d ^ a) ^ b)) + X[7]) + 4139469664U;
#line 280
  c = ((t << 16) | (t >> 16)) + d;
#line 281
  t = ((b + ((c ^ d) ^ a)) + X[10]) + 3200236656U;
#line 281
  b = ((t << 23) | (t >> 9)) + c;
#line 282
  t = ((a + ((b ^ c) ^ d)) + X[13]) + 681279174U;
#line 282
  a = ((t << 4) | (t >> 28)) + b;
#line 283
  t = ((d + ((a ^ b) ^ c)) + X[0]) + 3936430074U;
#line 283
  d = ((t << 11) | (t >> 21)) + a;
#line 284
  t = ((c + ((d ^ a) ^ b)) + X[3]) + 3572445317U;
#line 284
  c = ((t << 16) | (t >> 16)) + d;
#line 285
  t = ((b + ((c ^ d) ^ a)) + X[6]) + 76029189U;
#line 285
  b = ((t << 23) | (t >> 9)) + c;
#line 286
  t = ((a + ((b ^ c) ^ d)) + X[9]) + 3654602809U;
#line 286
  a = ((t << 4) | (t >> 28)) + b;
#line 287
  t = ((d + ((a ^ b) ^ c)) + X[12]) + 3873151461U;
#line 287
  d = ((t << 11) | (t >> 21)) + a;
#line 288
  t = ((c + ((d ^ a) ^ b)) + X[15]) + 530742520U;
#line 288
  c = ((t << 16) | (t >> 16)) + d;
#line 289
  t = ((b + ((c ^ d) ^ a)) + X[2]) + 3299628645U;
#line 289
  b = ((t << 23) | (t >> 9)) + c;
#line 300
  t = ((a + (c ^ (b | ~ d))) + X[0]) + 4096336452U;
#line 300
  a = ((t << 6) | (t >> 26)) + b;
#line 301
  t = ((d + (b ^ (a | ~ c))) + X[7]) + 1126891415U;
#line 301
  d = ((t << 10) | (t >> 22)) + a;
#line 302
  t = ((c + (a ^ (d | ~ b))) + X[14]) + 2878612391U;
#line 302
  c = ((t << 15) | (t >> 17)) + d;
#line 303
  t = ((b + (d ^ (c | ~ a))) + X[5]) + 4237533241U;
#line 303
  b = ((t << 21) | (t >> 11)) + c;
#line 304
  t = ((a + (c ^ (b | ~ d))) + X[12]) + 1700485571U;
#line 304
  a = ((t << 6) | (t >> 26)) + b;
#line 305
  t = ((d + (b ^ (a | ~ c))) + X[3]) + 2399980690U;
#line 305
  d = ((t << 10) | (t >> 22)) + a;
#line 306
  t = ((c + (a ^ (d | ~ b))) + X[10]) + 4293915773U;
#line 306
  c = ((t << 15) | (t >> 17)) + d;
#line 307
  t = ((b + (d ^ (c | ~ a))) + X[1]) + 2240044497U;
#line 307
  b = ((t << 21) | (t >> 11)) + c;
#line 308
  t = ((a + (c ^ (b | ~ d))) + X[8]) + 1873313359U;
#line 308
  a = ((t << 6) | (t >> 26)) + b;
#line 309
  t = ((d + (b ^ (a | ~ c))) + X[15]) + 4264355552U;
#line 309
  d = ((t << 10) | (t >> 22)) + a;
#line 310
  t = ((c + (a ^ (d | ~ b))) + X[6]) + 2734768916U;
#line 310
  c = ((t << 15) | (t >> 17)) + d;
#line 311
  t = ((b + (d ^ (c | ~ a))) + X[13]) + 1309151649U;
#line 311
  b = ((t << 21) | (t >> 11)) + c;
#line 312
  t = ((a + (c ^ (b | ~ d))) + X[4]) + 4149444226U;
#line 312
  a = ((t << 6) | (t >> 26)) + b;
#line 313
  t = ((d + (b ^ (a | ~ c))) + X[11]) + 3174756917U;
#line 313
  d = ((t << 10) | (t >> 22)) + a;
#line 314
  t = ((c + (a ^ (d | ~ b))) + X[2]) + 718787259U;
#line 314
  c = ((t << 15) | (t >> 17)) + d;
#line 315
  t = ((b + (d ^ (c | ~ a))) + X[9]) + 3951481745U;
#line 315
  b = ((t << 21) | (t >> 11)) + c;
#line 321
  pms->abcd[0] += a;
#line 322
  pms->abcd[1] += b;
#line 323
  pms->abcd[2] += c;
#line 324
  pms->abcd[3] += d;
#line 325
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.c"
void md5_init(md5_state_t *pms ) 
{ 
  md5_word_t tmp ;

  {
#line 330
  tmp = (md5_word_t )0;
#line 330
  pms->count[1] = tmp;
#line 330
  pms->count[0] = tmp;
#line 331
  pms->abcd[0] = (md5_word_t )1732584193;
#line 332
  pms->abcd[1] = 4023233417U;
#line 333
  pms->abcd[2] = 2562383102U;
#line 334
  pms->abcd[3] = (md5_word_t )271733878;
#line 335
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.c"
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) 
{ 
  md5_byte_t const   *p ;
  int left ;
  int offset ;
  md5_word_t nbits ;
  int copy ;
  int tmp ;

  {
#line 340
  p = data;
#line 341
  left = nbytes;
#line 342
  offset = (int )((pms->count[0] >> 3) & 63U);
#line 343
  nbits = (md5_word_t )(nbytes << 3);
#line 345
  if (nbytes <= 0) {
#line 346
    return;
  }
#line 349
  pms->count[1] += (md5_word_t )(nbytes >> 29);
#line 350
  pms->count[0] += nbits;
#line 351
  if (pms->count[0] < nbits) {
#line 352
    (pms->count[1]) ++;
  }
#line 355
  if (offset) {
#line 356
    if (offset + nbytes > 64) {
#line 356
      tmp = 64 - offset;
    } else {
#line 356
      tmp = nbytes;
    }
    {
#line 356
    copy = tmp;
#line 358
    memcpy((void */* __restrict  */)(pms->buf + offset), (void const   */* __restrict  */)p,
           (size_t )copy);
    }
#line 359
    if (offset + copy < 64) {
#line 360
      return;
    }
    {
#line 361
    p += copy;
#line 362
    left -= copy;
#line 363
    md5_process(pms, (md5_byte_t const   *)(pms->buf));
    }
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (left >= 64)) {
#line 367
      goto while_break;
    }
    {
#line 368
    md5_process(pms, p);
#line 367
    p += 64;
#line 367
    left -= 64;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  if (left) {
    {
#line 372
    memcpy((void */* __restrict  */)(pms->buf), (void const   */* __restrict  */)p,
           (size_t )left);
    }
  }
#line 373
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.c"
static md5_byte_t const   pad[64]  = 
#line 378
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 375 "/home/june/repo/benchmarks/collector/temp/fdupes-1.51/md5/md5.c"
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) 
{ 
  md5_byte_t data[8] ;
  int i ;

  {
#line 388
  i = 0;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (i < 8)) {
#line 388
      goto while_break;
    }
#line 389
    data[i] = (md5_byte_t )(pms->count[i >> 2] >> ((i & 3) << 3));
#line 388
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 391
  md5_append(pms, pad, (int )(((55U - (pms->count[0] >> 3)) & 63U) + 1U));
#line 393
  md5_append(pms, (md5_byte_t const   *)(data), 8);
#line 394
  i = 0;
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (i < 16)) {
#line 394
      goto while_break___0;
    }
#line 395
    *(digest + i) = (md5_byte_t )(pms->abcd[i >> 2] >> ((i & 3) << 3));
#line 394
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 396
  return;
}
}
