/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
typedef short value_array[100][15];
#line 53 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
typedef signed char fscore_array[100][31][2];
#line 540 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct hashval {
   unsigned long key ;
   unsigned long bd ;
};
#line 545 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct hashentry {
   unsigned long hashbd ;
   unsigned short mv ;
   unsigned char depth ;
   unsigned char flags ;
   short score ;
};
#line 561 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct etable {
   unsigned long ehashbd ;
   short escore[2] ;
   short sscore[81] ;
   short score ;
   signed char hung[2] ;
};
#line 577 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef struct etable etable_field[10001];
#line 606 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct leaf {
   unsigned char f ;
   unsigned char t ;
   short score ;
   short reply ;
   short width ;
   short INCscore ;
   unsigned short flags ;
};
#line 615 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct GameRec {
   unsigned short gmove ;
   short score ;
   short depth ;
   long time ;
   short fpiece ;
   short piece ;
   short color ;
   short flags ;
   short Game50 ;
   long nodes ;
   unsigned long hashkey ;
   unsigned long hashbd ;
};
#line 631 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct TimeControlRec {
   short moves[2] ;
   long clock[2] ;
};
#line 638 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct flags {
   short mate ;
   short post ;
   short quit ;
   short regularstart ;
   short reverse ;
   short bothsides ;
   short hash ;
   short force ;
   short easy ;
   short beep ;
   short timeout ;
   short musttimeout ;
   short back ;
   short rcptr ;
   short rv ;
   short stars ;
   short coords ;
   short shade ;
   short material ;
   short illegal ;
   short onemove ;
   short gamein ;
   short tsume ;
};
#line 785 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef unsigned char next_array[81][81];
#line 786 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef signed char distdata_array[81][81];
#line 854 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef struct hashval hashcode_array[2][15][81];
#line 855 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef struct hashval drop_hashcode_array[2][15][81];
#line 43 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
struct signature {
   unsigned long hashbd ;
   unsigned long hashkey ;
};
#line 923 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
enum __anonenum_UpdatePieceList_mode_14 {
    REMOVE_PIECE = 1,
    ADD_PIECE = 2
} ;
#line 923 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef enum __anonenum_UpdatePieceList_mode_14 UpdatePieceList_mode;
#line 931
enum __anonenum_SelectMove_mode_15 {
    FOREGROUND_MODE = 1,
    BACKGROUND_MODE = 2
} ;
#line 931 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef enum __anonenum_SelectMove_mode_15 SelectMove_mode;
#line 1065
enum __anonenum_ElapsedTime_mode_16 {
    COMPUTE_AND_INIT_MODE = 1,
    COMPUTE_MODE = 2
} ;
#line 1065 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef enum __anonenum_ElapsedTime_mode_16 ElapsedTime_mode;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 63 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef void * __restrict  __timezone_ptr_t;
#line 87 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef unsigned short USHORT;
#line 90 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef long LONG;
#line 91 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef unsigned long ULONG;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 36 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.h"
struct gdxadmin {
   ULONG bookcount ;
   ULONG booksize ;
   ULONG maxoffset ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.h"
struct gdxdata {
   ULONG hashbd ;
   USHORT hashkey ;
   USHORT bmove ;
   USHORT flags ;
   USHORT hint ;
   USHORT count ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 826 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef signed char Mpiece_array[2][81];
#line 51 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.h"
struct PatternField {
   short side ;
   short piece ;
   short square ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.h"
struct Pattern_rec {
   signed char visited ;
   signed char distance[2] ;
   short reachedGameCnt[2] ;
   short first_link ;
   short first_field ;
   short next_pattern ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.h"
struct OpeningSequence_rec {
   short opening_type ;
   short first_pattern[4] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
enum __anonenum_display_t_7 {
    DISPLAY_RAW = 0,
    DISPLAY_CURSES = 1,
    DISPLAY_X = 2
} ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef enum __anonenum_display_t_7 display_t;
#line 597 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct fileentry {
   unsigned char bd[96] ;
   unsigned char f ;
   unsigned char t ;
   unsigned char flags ;
   unsigned char depth ;
   unsigned char sh ;
   unsigned char sl ;
};
#line 1120
enum __anonenum_VerifyMove_mode_49 {
    VERIFY_AND_MAKE_MODE = 0,
    VERIFY_AND_TRY_MODE = 1,
    UNMAKE_MODE = 2
} ;
#line 1120 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
typedef enum __anonenum_VerifyMove_mode_49 VerifyMove_mode;
#line 159
short ahead ;
#line 160
char *xwin ;
#line 161
char *Lang ;
#line 55 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
value_array *value ;
#line 56
fscore_array *fscore ;
#line 576 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short use_etable ;
#line 578
etable_field *etab[2] ;
#line 677
short use_history ;
#line 678
unsigned short *history ;
#line 681 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long znodes  ;
#line 683 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char ColorStr[2][10]  ;
#line 691
struct leaf *Tree ;
#line 692
struct leaf *root ;
#line 693 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char savefile[128]  ;
#line 693 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char listfile[128]  ;
#line 694 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TrPnt[40]  ;
#line 697 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char PieceList[2][81]  ;
#line 697 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char PawnCnt[2][9]  ;
#line 698 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char Captured[2][15]  ;
#line 713 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char Mvboard[81]  ;
#line 716 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short svalue[81]  ;
#line 722 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct flags flag  ;
#line 723 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short opponent  ;
#line 723 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short computer  ;
#line 723
short INCscore ;
#line 724 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short WAwindow  ;
#line 724 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short BAwindow  ;
#line 724 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short WBwindow  ;
#line 724 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short BBwindow  ;
#line 725 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short dither  ;
#line 725 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short player  ;
#line 726 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short xwndw  ;
#line 726 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short contempt  ;
#line 727
long ResponseTime ;
#line 727
long ExtraTime ;
#line 727
long MaxResponseTime ;
#line 727
long et ;
#line 727
long et0 ;
#line 727
long time0 ;
#line 727
long ft ;
#line 735 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long reminus  ;
#line 735 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long replus  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long GenCnt  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long NodeCnt  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long ETnodes  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long EvalNodes  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long HashAdd  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long HashCnt  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long HashCol  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long THashCol  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long FHashCnt  ;
#line 736 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long FHashAdd  ;
#line 738
short HashDepth ;
#line 738
short HashMoveLimit ;
#line 739
struct GameRec *GameList ;
#line 740
short GameCnt ;
#line 740 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short Game50  ;
#line 741 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short Sdepth  ;
#line 741 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short MaxSearchDepth  ;
#line 742 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int Book  ;
#line 743 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
struct TimeControlRec TimeControl  ;
#line 744
int TCadd ;
#line 745 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TCflag  ;
#line 745 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TCmoves  ;
#line 745 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TCminutes  ;
#line 745 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TCseconds  ;
#line 745 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short OperatorTime  ;
#line 746 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int timecomp[4]  ;
#line 746 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int timeopp[4]  ;
#line 747 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int compptr  ;
#line 747 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int oppptr  ;
#line 748
short XCmore ;
#line 748
short XCmoves[3] ;
#line 748
short XCminutes[3] ;
#line 748
short XCseconds[3] ;
#line 748
short XC ;
#line 749
short const   otherside[3] ;
#line 752 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short hint  ;
#line 753 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TOflag  ;
#line 754 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short stage  ;
#line 754 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short stage2  ;
#line 760
short hash ;
#line 761 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short balance[2]  ;
#line 762 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char ChkFlag[40]  ;
#line 762 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char CptrFlag[40]  ;
#line 762 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char TesujiFlag[40]  ;
#line 763 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short Pscore[40]  ;
#line 763 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short Tscore[40]  ;
#line 764
short rehash ;
#line 767
unsigned int ttblsize ;
#line 768 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short mtl[2]  ;
#line 768 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short hung[2]  ;
#line 769 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char Pindex[81]  ;
#line 770 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char PieceCnt[2]  ;
#line 771 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short FROMsquare  ;
#line 771 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short TOsquare  ;
#line 772 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char HasPiece[2][15]  ;
#line 773
short const   kingP[3] ;
#line 774 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short killr0[40]  ;
#line 774 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short killr1[40]  ;
#line 775 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short killr2[40]  ;
#line 775 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short killr3[40]  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short PV  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short SwagHt  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short Swag0  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short Swag1  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short Swag2  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short Swag3  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short Swag4  ;
#line 777 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short sidebit  ;
#line 779
signed char const   relative_value[15] ;
#line 780
long const   control[15] ;
#line 801
short use_nextpos ;
#line 802 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
next_array *nextpos[15]  ;
#line 803 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
next_array *nextdir[15]  ;
#line 810
short use_distdata ;
#line 811
distdata_array *distdata ;
#line 815
short use_ptype_distdata ;
#line 816 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
distdata_array *ptype_distdata[15]  ;
#line 821 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long filesz  ;
#line 821 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long hashmask  ;
#line 821 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long hashbase  ;
#line 822 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
FILE *hashfile  ;
#line 823 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned int starttime  ;
#line 852 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned long hashkey  ;
#line 852 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned long hashbd  ;
#line 857
hashcode_array *hashcode ;
#line 858
drop_hashcode_array *drop_hashcode ;
#line 865
short use_ttable ;
#line 866
struct hashentry *ttable[2] ;
#line 898 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short rpthash[2][256]  ;
#line 899 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char *DRAW  ;
#line 901
char *DRAW_REPETITION ;
#line 902
char *DRAW_MAXMOVES ;
#line 903
char *DRAW_JUSTDRAW ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short ahead  =    (short)1;
#line 36 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short hash  =    (short)1;
#line 37 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
char *xwin  =    (char *)0;
#line 38 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
char *Lang  =    (char *)((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short INCscore  =    (short)0;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long ResponseTime  =    0L;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long ExtraTime  =    0L;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long MaxResponseTime  =    0L;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long et  =    0L;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long et0  =    0L;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long time0  =    0L;
#line 82 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long ft  =    0L;
#line 92 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short HashDepth  =    (short)4;
#line 92 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short HashMoveLimit  =    (short)40;
#line 94 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short rehash  =    (short)-1;
#line 96 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short GameCnt  =    (short)0;
#line 100 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
int TCadd  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short XCmoves[3]  = {      (short)0,      (short)0,      (short)0};
#line 103 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short XCminutes[3]  = {      (short)0,      (short)0,      (short)0};
#line 104 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short XCseconds[3]  = {      (short)0,      (short)0,      (short)0};
#line 105 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short XC  =    (short)0;
#line 105 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short XCmore  =    (short)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short const   otherside[3]  = {      (short const   )1,      (short const   )0,      (short const   )2};
#line 116 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short const   kingP[3]  = {      (short const   )4,      (short const   )76,      (short const   )0};
#line 119 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
signed char const   relative_value[15]  = 
#line 119
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )3,      (signed char const   )4, 
        (signed char const   )7,      (signed char const   )9,      (signed char const   )10,      (signed char const   )12, 
        (signed char const   )2,      (signed char const   )5,      (signed char const   )6,      (signed char const   )8, 
        (signed char const   )11,      (signed char const   )13,      (signed char const   )14};
#line 131 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
long const   control[15]  = 
#line 131
  {      (long const   )0,      (long const   )2097152,      (long const   )524288,      (long const   )262144, 
        (long const   )32768,      (long const   )8192,      (long const   )4096,      (long const   )1024, 
        (long const   )1048576,      (long const   )131072,      (long const   )65536,      (long const   )16384, 
        (long const   )2048,      (long const   )512,      (long const   )256};
#line 156 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
struct leaf *Tree  =    (struct leaf *)((void *)0);
#line 158 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
hashcode_array *hashcode  =    (hashcode_array *)((void *)0);
#line 159 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
drop_hashcode_array *drop_hashcode  =    (drop_hashcode_array *)((void *)0);
#line 161 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
struct leaf *root  =    (struct leaf *)((void *)0);
#line 163 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
struct GameRec *GameList  =    (struct GameRec *)((void *)0);
#line 165 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
value_array *value  =    (value_array *)((void *)0);
#line 166 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
fscore_array *fscore  =    (fscore_array *)((void *)0);
#line 169 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short use_distdata  =    (short)1;
#line 170 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
distdata_array *distdata  =    (distdata_array *)((void *)0);
#line 174 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short use_ptype_distdata  =    (short)1;
#line 181 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short use_nextpos  =    (short)1;
#line 185 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short use_history  =    (short)1;
#line 186 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
unsigned short *history  =    (unsigned short *)((void *)0);
#line 190 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short use_etable  =    (short)1;
#line 191 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
etable_field *etab[2]  = {      (etable_field *)((void *)0),      (etable_field *)((void *)0)};
#line 195 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
short use_ttable  =    (short)1;
#line 196 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
unsigned int ttblsize  =    100001U;
#line 197 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
struct hashentry *ttable[2]  = {      (struct hashentry *)((void *)0),      (struct hashentry *)((void *)0)};
#line 201 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
char *DRAW_REPETITION  =    (char *)"Repetition";
#line 202 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
char *DRAW_MAXMOVES  =    (char *)"Max Moves";
#line 203 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/globals.c"
char *DRAW_JUSTDRAW  =    (char *)"Drawn game!";
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 765 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned int ttbllimit  ;
#line 782
signed char const   promoted[15] ;
#line 782
signed char const   unpromoted[15] ;
#line 819
signed char const   ptype[2][15] ;
#line 835
short ptype_distance(short ptyp , short f , short t ) ;
#line 836
short piece_distance(short side , short piece , short f , short t ) ;
#line 911
int Initialize_data(void) ;
#line 1088
void ShowMessage(char *s ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
signed char const   ptype[2][15]  = { {        (signed char const   )0,        (signed char const   )0,        (signed char const   )1,        (signed char const   )2, 
            (signed char const   )3,        (signed char const   )4,        (signed char const   )5,        (signed char const   )6, 
            (signed char const   )4,        (signed char const   )4,        (signed char const   )4,        (signed char const   )4, 
            (signed char const   )7,        (signed char const   )8,        (signed char const   )9}, 
   {        (signed char const   )0,        (signed char const   )10,        (signed char const   )11,        (signed char const   )12, 
            (signed char const   )13,        (signed char const   )14,        (signed char const   )5,        (signed char const   )6, 
            (signed char const   )14,        (signed char const   )14,        (signed char const   )14,        (signed char const   )14, 
            (signed char const   )7,        (signed char const   )8,        (signed char const   )9}};
#line 73 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
signed char const   promoted[15]  = 
#line 73
  {      (signed char const   )0,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )5,      (signed char const   )12,      (signed char const   )13, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )10,      (signed char const   )11, 
        (signed char const   )12,      (signed char const   )13,      (signed char const   )14};
#line 87 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
signed char const   unpromoted[15]  = 
#line 87
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )1,      (signed char const   )2,      (signed char const   )3,      (signed char const   )4, 
        (signed char const   )6,      (signed char const   )7,      (signed char const   )14};
#line 109 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
signed char const   piece_of_ptype[15]  = 
#line 109
  {      (signed char const   )1,      (signed char const   )2,      (signed char const   )3,      (signed char const   )4, 
        (signed char const   )5,      (signed char const   )6,      (signed char const   )7,      (signed char const   )12, 
        (signed char const   )13,      (signed char const   )14,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5};
#line 125 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
signed char const   side_of_ptype[15]  = 
#line 125
  {      (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1};
#line 140 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
int Initialize_data(void) 
{ 
  size_t n ;
  int i___0 ;
  char buffer___1[60] ;
  int doit ;
  signed char x ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;

  {
#line 146
  doit = 1;
#line 149
  x = (signed char)-1;
#line 151
  if ((int )x >= 0) {
    {
#line 153
    ShowMessage((char *)"datatype \'small_short\' is unsigned; check gnushogi.h\n");
    }
#line 155
    return (1);
  }
  {
#line 159
  n = sizeof(struct leaf ) * 4000UL;
#line 160
  tmp = malloc(n);
#line 160
  Tree = (struct leaf *)tmp;
  }
#line 162
  if (! Tree) {
    {
#line 164
    sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for search tree",
            (long )n);
#line 166
    ShowMessage(buffer___1);
    }
#line 167
    return (1);
  }
  {
#line 170
  n = sizeof(hashcode_array );
#line 171
  tmp___0 = malloc(n);
#line 171
  hashcode = (hashcode_array *)tmp___0;
  }
#line 173
  if (! hashcode) {
    {
#line 175
    sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for hashcode",
            (long )n);
#line 176
    ShowMessage(buffer___1);
    }
#line 177
    return (1);
  }
  {
#line 180
  n = sizeof(drop_hashcode_array );
#line 181
  tmp___1 = malloc(n);
#line 181
  drop_hashcode = (drop_hashcode_array *)tmp___1;
  }
#line 183
  if (! drop_hashcode) {
    {
#line 185
    sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for drop_hashcode",
            (long )n);
#line 188
    ShowMessage(buffer___1);
    }
#line 189
    return (1);
  }
  {
#line 192
  n = sizeof(struct GameRec ) * 340UL;
#line 193
  tmp___2 = malloc(n);
#line 193
  GameList = (struct GameRec *)tmp___2;
  }
#line 195
  if (! GameList) {
    {
#line 197
    sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for game record",
            (long )n);
#line 200
    ShowMessage(buffer___1);
    }
#line 201
    return (1);
  }
#line 205
  n = sizeof(next_array );
#line 207
  i___0 = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i___0 < 15)) {
#line 207
      goto while_break;
    }
#line 209
    if (use_nextpos) {
      {
#line 209
      tmp___3 = malloc(n);
#line 209
      nextdir[i___0] = (next_array *)tmp___3;
      }
    } else {
#line 209
      nextdir[i___0] = (next_array *)((void *)0);
    }
#line 211
    if (! nextdir[i___0]) {
#line 213
      if (use_nextpos) {
        {
#line 215
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"cannot allocate %ld space for nextdir %d",
                (long )n, i___0);
#line 217
        ShowMessage(buffer___1);
        }
      }
#line 220
      nextdir[i___0] = (next_array *)((void *)0);
#line 221
      use_nextpos = (short)0;
    }
#line 224
    if (use_nextpos) {
      {
#line 224
      tmp___4 = malloc(n);
#line 224
      nextpos[i___0] = (next_array *)tmp___4;
      }
    } else {
#line 224
      nextpos[i___0] = (next_array *)((void *)0);
    }
#line 226
    if (! nextpos[i___0]) {
#line 228
      if (use_nextpos) {
        {
#line 230
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"cannot allocate %ld space for nextpos %d",
                (long )n, i___0);
#line 232
        ShowMessage(buffer___1);
        }
      }
#line 235
      use_nextpos = (short)0;
    }
#line 207
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (! use_nextpos) {
#line 241
    return (1);
  }
  {
#line 245
  n = sizeof(value_array );
#line 246
  tmp___5 = malloc(n);
#line 246
  value = (value_array *)tmp___5;
  }
#line 248
  if (! value) {
    {
#line 250
    ShowMessage((char *)"cannot allocate value space");
    }
#line 251
    return (1);
  }
  {
#line 254
  n = sizeof(fscore_array );
#line 255
  tmp___6 = malloc(n);
#line 255
  fscore = (fscore_array *)tmp___6;
  }
#line 257
  if (! fscore) {
    {
#line 259
    ShowMessage((char *)"cannot allocate fscore space");
    }
#line 260
    return (1);
  }
  {
#line 264
  n = sizeof(unsigned short ) * (size_t )(1 << 16);
#line 265
  tmp___7 = malloc(n);
#line 265
  history = (unsigned short *)tmp___7;
  }
#line 267
  if (! history) {
    {
#line 269
    sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for history table",
            (long )(sizeof(unsigned short ) * (size_t )(1 << 16)));
#line 271
    ShowMessage(buffer___1);
#line 272
    use_history = (short)0;
    }
  }
#line 277
  n = sizeof(struct etable ) * 10001UL;
#line 279
  i___0 = 0;
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 279
    if (! (i___0 < 2)) {
#line 279
      goto while_break___0;
    }
#line 281
    if (use_etable) {
      {
#line 281
      tmp___8 = malloc(n);
#line 281
      etab[i___0] = (etable_field *)tmp___8;
      }
    } else {
#line 281
      etab[i___0] = (etable_field *)0;
    }
#line 283
    if (! etab[i___0]) {
      {
#line 285
      sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for cache table %ld",
              (long )n, (long )i___0);
#line 287
      ShowMessage(buffer___1);
#line 288
      use_etable = (short)0;
      }
    }
#line 279
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  if ((int )rehash < 0) {
#line 296
    rehash = (short)7;
  }
#line 298
  n = sizeof(struct hashentry ) * (unsigned long )(ttblsize + (unsigned int )rehash);
  {
#line 300
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 300
    if (doit) {
#line 300
      if (! (ttblsize > 8000U)) {
#line 300
        goto while_break___1;
      }
    } else {
#line 300
      goto while_break___1;
    }
    {
#line 302
    tmp___9 = malloc(n);
#line 302
    ttable[0] = (struct hashentry *)tmp___9;
    }
#line 303
    if (ttable[0]) {
      {
#line 303
      tmp___10 = malloc(n);
#line 303
      ttable[1] = (struct hashentry *)tmp___10;
      }
    } else {
#line 303
      ttable[1] = (struct hashentry *)((void *)0);
    }
#line 305
    if (! ttable[0]) {
#line 305
      goto _L;
    } else
#line 305
    if (! ttable[1]) {
      _L: /* CIL Label */ 
#line 307
      if (! ttable[0]) {
        {
#line 308
        free((void *)ttable[0]);
        }
      }
#line 310
      if (! ttable[1]) {
        {
#line 311
        free((void *)ttable[1]);
        }
      }
#line 313
      ttblsize >>= 1;
#line 314
      n = sizeof(struct hashentry ) * (unsigned long )(ttblsize + (unsigned int )rehash);
    } else {
#line 318
      doit = 0;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  if (ttblsize <= 8000U) {
#line 324
    use_ttable = (short)0;
  }
#line 327
  if (use_ttable) {
#line 331
    ttbllimit = (ttblsize << 1) - (ttblsize >> 2);
  } else {
    {
#line 335
    sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Cannot allocate %ld bytes for transposition table",
            (long )(2UL * n));
#line 337
    ShowMessage(buffer___1);
#line 338
    ttable[1] = (struct hashentry *)((void *)0);
#line 338
    ttable[0] = ttable[1];
    }
  }
  {
#line 343
  n = sizeof(distdata_array );
#line 344
  tmp___11 = malloc(n);
#line 344
  distdata = (distdata_array *)tmp___11;
  }
#line 346
  if (! distdata) {
    {
#line 348
    ShowMessage((char *)"cannot allocate distdata space...");
#line 349
    use_distdata = (short)0;
    }
  }
#line 354
  n = sizeof(distdata_array );
#line 356
  i___0 = 0;
  {
#line 356
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 356
    if (! (i___0 < 15)) {
#line 356
      goto while_break___2;
    }
#line 358
    if (use_ptype_distdata) {
      {
#line 358
      tmp___12 = malloc(n);
#line 358
      ptype_distdata[i___0] = (distdata_array *)tmp___12;
      }
    } else {
#line 358
      ptype_distdata[i___0] = (distdata_array *)0;
    }
#line 360
    if (! ptype_distdata[i___0]) {
      {
#line 362
      sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"cannot allocate %ld bytes for ptype_distdata %d...",
              (long )n, i___0);
#line 365
      use_ptype_distdata = (short)0;
      }
    }
#line 356
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 370
  return (0);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
short piece_distance(short side , short piece , short f , short t ) 
{ 
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 386
  if ((int )f > 81) {
#line 386
    tmp___1 = 1;
  } else {
#line 386
    if (use_ptype_distdata) {
#line 386
      tmp___0 = (int )((short )(*(ptype_distdata[ptype[side][piece]]))[f][t]);
    } else {
      {
#line 386
      tmp = ptype_distance((short )ptype[side][piece], f, t);
#line 386
      tmp___0 = (int )tmp;
      }
    }
#line 386
    tmp___1 = tmp___0;
  }
#line 386
  return ((short )tmp___1);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init-common.c"
short ptype_distance(short ptyp , short f , short t ) 
{ 
  short side ;
  short piece ;
  short colf ;
  short colt ;
  short rowf ;
  short rowt ;
  short dcol ;
  short drow ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
#line 411
  if ((int )f == (int )t) {
#line 412
    return ((short)0);
  }
#line 414
  piece = (short )piece_of_ptype[ptyp];
#line 415
  side = (short )side_of_ptype[ptyp];
#line 417
  if ((int )side == 0) {
#line 417
    tmp = (int )t;
  } else {
#line 417
    tmp = 80 - (int )t;
  }
#line 417
  colt = (short )(tmp % 9);
#line 417
  if ((int )side == 0) {
#line 417
    tmp___0 = (int )f;
  } else {
#line 417
    tmp___0 = 80 - (int )f;
  }
#line 417
  colf = (short )(tmp___0 % 9);
#line 417
  dcol = (short )((int )colt - (int )colf);
#line 418
  if ((int )side == 0) {
#line 418
    tmp___1 = (int )t;
  } else {
#line 418
    tmp___1 = 80 - (int )t;
  }
#line 418
  rowt = (short )(tmp___1 / 9);
#line 418
  if ((int )side == 0) {
#line 418
    tmp___2 = (int )f;
  } else {
#line 418
    tmp___2 = 80 - (int )f;
  }
#line 418
  rowf = (short )(tmp___2 / 9);
#line 418
  drow = (short )((int )rowt - (int )rowf);
  {
#line 422
  if ((int )piece == 1) {
#line 422
    goto case_1;
  }
#line 429
  if ((int )piece == 2) {
#line 429
    goto case_2;
  }
#line 435
  if ((int )piece == 3) {
#line 435
    goto case_3;
  }
#line 444
  if ((int )piece == 4) {
#line 444
    goto case_4;
  }
#line 473
  if ((int )piece == 11) {
#line 473
    goto case_11;
  }
#line 473
  if ((int )piece == 9) {
#line 473
    goto case_11;
  }
#line 473
  if ((int )piece == 10) {
#line 473
    goto case_11;
  }
#line 473
  if ((int )piece == 8) {
#line 473
    goto case_11;
  }
#line 473
  if ((int )piece == 5) {
#line 473
    goto case_11;
  }
#line 481
  if ((int )piece == 6) {
#line 481
    goto case_6;
  }
#line 487
  if ((int )piece == 12) {
#line 487
    goto case_12;
  }
#line 502
  if ((int )piece == 7) {
#line 502
    goto case_7;
  }
#line 508
  if ((int )piece == 13) {
#line 508
    goto case_13;
  }
#line 516
  if ((int )piece == 14) {
#line 516
    goto case_14;
  }
#line 519
  goto switch_default;
  case_1: /* CIL Label */ 
#line 423
  if ((int )dcol != 0) {
#line 424
    return ((short)-1);
  } else
#line 423
  if ((int )drow < 1) {
#line 424
    return ((short)-1);
  } else {
#line 426
    return (drow);
  }
  case_2: /* CIL Label */ 
#line 430
  if ((int )dcol != 0) {
#line 431
    return ((short)-1);
  } else
#line 430
  if ((int )drow < 1) {
#line 431
    return ((short)-1);
  } else {
#line 433
    return ((short)1);
  }
  case_3: /* CIL Label */ 
#line 436
  if ((int )drow & 1) {
#line 437
    return ((short)-1);
  } else
#line 436
  if (((int )drow / 2 & 1) != ((int )dcol & 1)) {
#line 437
    return ((short)-1);
  } else
#line 438
  if ((int )drow == 0) {
#line 439
    return ((short)-1);
  } else {
    {
#line 438
    tmp___3 = abs((int )dcol);
    }
#line 438
    if ((int )drow / 2 < tmp___3) {
#line 439
      return ((short)-1);
    } else {
#line 441
      return ((short )((int )drow / 2));
    }
  }
  case_4: /* CIL Label */ 
#line 445
  if ((int )drow > 0) {
#line 447
    if (((int )drow & 1) == ((int )dcol & 1)) {
      {
#line 449
      tmp___9 = abs((int )drow);
#line 449
      tmp___10 = abs((int )dcol);
      }
#line 449
      if (tmp___9 < tmp___10) {
        {
#line 449
        tmp___6 = abs((int )dcol);
#line 449
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 449
        tmp___7 = abs((int )drow);
#line 449
        tmp___8 = tmp___7;
        }
      }
#line 449
      return ((short )tmp___8);
    } else {
      {
#line 453
      tmp___18 = abs((int )dcol);
      }
#line 453
      if (tmp___18 <= (int )drow) {
#line 454
        return (drow);
      } else {
        {
#line 456
        tmp___16 = abs((int )drow);
#line 456
        tmp___17 = abs((int )dcol);
        }
#line 456
        if (tmp___16 < tmp___17) {
          {
#line 456
          tmp___13 = abs((int )dcol);
#line 456
          tmp___15 = tmp___13;
          }
        } else {
          {
#line 456
          tmp___14 = abs((int )drow);
#line 456
          tmp___15 = tmp___14;
          }
        }
#line 456
        return ((short )(tmp___15 + 1));
      }
    }
  } else
#line 461
  if (((int )drow & 1) == ((int )dcol & 1)) {
    {
#line 462
    tmp___24 = abs((int )drow);
#line 462
    tmp___25 = abs((int )dcol);
    }
#line 462
    if (tmp___24 < tmp___25) {
      {
#line 462
      tmp___21 = abs((int )dcol);
#line 462
      tmp___23 = tmp___21;
      }
    } else {
      {
#line 462
      tmp___22 = abs((int )drow);
#line 462
      tmp___23 = tmp___22;
      }
    }
#line 462
    return ((short )tmp___23);
  } else {
    {
#line 464
    tmp___31 = abs((int )drow);
#line 464
    tmp___32 = abs((int )dcol);
    }
#line 464
    if (tmp___31 + 1 < tmp___32) {
      {
#line 464
      tmp___28 = abs((int )dcol);
#line 464
      tmp___30 = tmp___28;
      }
    } else {
      {
#line 464
      tmp___29 = abs((int )drow);
#line 464
      tmp___30 = tmp___29 + 1;
      }
    }
#line 464
    return ((short )(tmp___30 + 1));
  }
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 474
  tmp___39 = abs((int )dcol);
  }
#line 474
  if (tmp___39 == 0) {
    {
#line 475
    tmp___33 = abs((int )drow);
    }
#line 475
    return ((short )tmp___33);
  } else
#line 476
  if ((int )drow >= 0) {
    {
#line 477
    tmp___37 = abs((int )dcol);
    }
#line 477
    if ((int )drow < tmp___37) {
      {
#line 477
      tmp___35 = abs((int )dcol);
#line 477
      tmp___36 = tmp___35;
      }
    } else {
#line 477
      tmp___36 = (int )drow;
    }
#line 477
    return ((short )tmp___36);
  } else {
    {
#line 479
    tmp___38 = abs((int )dcol);
    }
#line 479
    return ((short )(tmp___38 - (int )drow));
  }
  case_6: /* CIL Label */ 
#line 482
  if (((int )dcol & 1) != ((int )drow & 1)) {
#line 483
    return ((short)-1);
  } else {
    {
#line 485
    tmp___43 = abs((int )dcol);
#line 485
    tmp___44 = abs((int )drow);
    }
#line 485
    if (tmp___43 == tmp___44) {
#line 485
      tmp___42 = 1;
    } else {
#line 485
      tmp___42 = 2;
    }
#line 485
    return ((short )tmp___42);
  }
  case_12: /* CIL Label */ 
#line 488
  if (((int )dcol & 1) != ((int )drow & 1)) {
    {
#line 490
    tmp___48 = abs((int )dcol);
    }
#line 490
    if (tmp___48 <= 1) {
      {
#line 490
      tmp___49 = abs((int )drow);
      }
#line 490
      if (tmp___49 <= 1) {
#line 491
        return ((short)1);
      } else {
#line 490
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 492
      tmp___45 = abs((int )dcol);
#line 492
      tmp___46 = abs((int )drow);
#line 492
      tmp___47 = abs(tmp___45 - tmp___46);
      }
#line 492
      if (tmp___47 == 1) {
#line 493
        return ((short)2);
      } else {
#line 495
        return ((short)3);
      }
    }
  } else {
    {
#line 499
    tmp___53 = abs((int )dcol);
#line 499
    tmp___54 = abs((int )drow);
    }
#line 499
    if (tmp___53 == tmp___54) {
#line 499
      tmp___52 = 1;
    } else {
#line 499
      tmp___52 = 2;
    }
#line 499
    return ((short )tmp___52);
  }
  case_7: /* CIL Label */ 
#line 503
  if ((int )dcol == 0) {
#line 504
    return ((short)1);
  } else
#line 503
  if ((int )drow == 0) {
#line 504
    return ((short)1);
  } else {
#line 506
    return ((short)2);
  }
  case_13: /* CIL Label */ 
#line 509
  if ((int )dcol == 0) {
#line 510
    return ((short)1);
  } else
#line 509
  if ((int )drow == 0) {
#line 510
    return ((short)1);
  } else {
    {
#line 511
    tmp___55 = abs((int )dcol);
    }
#line 511
    if (tmp___55 == 1) {
      {
#line 511
      tmp___56 = abs((int )drow);
      }
#line 511
      if (tmp___56 == 1) {
#line 512
        return ((short)1);
      } else {
#line 514
        return ((short)2);
      }
    } else {
#line 514
      return ((short)2);
    }
  }
  case_14: /* CIL Label */ 
  {
#line 517
  tmp___62 = abs((int )drow);
#line 517
  tmp___63 = abs((int )dcol);
  }
#line 517
  if (tmp___62 < tmp___63) {
    {
#line 517
    tmp___59 = abs((int )dcol);
#line 517
    tmp___61 = tmp___59;
    }
  } else {
    {
#line 517
    tmp___60 = abs((int )drow);
#line 517
    tmp___61 = tmp___60;
    }
  }
#line 517
  return ((short )tmp___61);
  switch_default: /* CIL Label */ 
#line 521
  return ((short)-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
long attack[2][81] ;
#line 63
struct signature threats_signature[2] ;
#line 695 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char board[81] ;
#line 695
signed char color[81] ;
#line 1013
int SqAttacked(short square , short side , short *blockable ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/attacks.c"
int SqAttacked(short square , short side , short *blockable ) 
{ 
  unsigned char *ppos ;
  unsigned char *pdir ;
  short u ;
  short ptyp ;
  short tmp ;

  {
#line 54
  if (threats_signature[side].hashbd == hashbd) {
#line 54
    if (threats_signature[side].hashkey == hashkey) {
#line 56
      *blockable = (short)1;
#line 57
      return (attack[side][square] != 0L);
    }
  }
#line 67
  *blockable = (short)0;
#line 71
  ptyp = (short )ptype[0][14];
#line 76
  pdir = (*(nextdir[ptyp]))[square];
#line 77
  u = (short )*(pdir + square);
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if ((int )color[u] == (int )side) {
      {
#line 85
      tmp = piece_distance(side, (short )board[u], u, square);
      }
#line 85
      if ((int )tmp == 1) {
#line 86
        return (1);
      }
    }
#line 117
    u = (short )*(pdir + u);
#line 80
    if (! ((int )u != (int )square)) {
#line 80
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  ptyp = (short )ptype[(int )side ^ 1][3];
#line 130
  pdir = (*(nextdir[ptyp]))[square];
#line 131
  u = (short )*(pdir + square);
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if ((int )color[u] == (int )side) {
#line 136
      if ((int )board[u] == 3) {
#line 137
        return (1);
      }
    }
#line 142
    u = (short )*(pdir + u);
#line 134
    if (! ((int )u != (int )square)) {
#line 134
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 148
  *blockable = (short)1;
#line 152
  ptyp = (short )ptype[0][6];
#line 157
  ppos = (*(nextpos[ptyp]))[square];
#line 158
  pdir = (*(nextdir[ptyp]))[square];
#line 159
  u = (short )*(ppos + square);
  {
#line 162
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    if ((int )color[u] == 2) {
#line 168
      u = (short )*(ppos + u);
    } else {
#line 172
      if ((int )color[u] == (int )side) {
#line 172
        if ((int const   )unpromoted[board[u]] == 6) {
#line 173
          return (1);
        }
      }
#line 178
      u = (short )*(pdir + u);
    }
#line 162
    if (! ((int )u != (int )square)) {
#line 162
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  ptyp = (short )ptype[0][7];
#line 191
  ppos = (*(nextpos[ptyp]))[square];
#line 192
  pdir = (*(nextdir[ptyp]))[square];
#line 193
  u = (short )*(ppos + square);
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 198
    if ((int )color[u] == 2) {
#line 205
      u = (short )*(ppos + u);
    } else {
#line 210
      if ((int )color[u] == (int )side) {
#line 210
        if ((int const   )unpromoted[board[u]] == 7) {
#line 211
          return (1);
        }
      }
#line 216
      u = (short )*(pdir + u);
    }
#line 196
    if (! ((int )u != (int )square)) {
#line 196
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 225
  ptyp = (short )ptype[(int )side ^ 1][2];
#line 230
  ppos = (*(nextpos[ptyp]))[square];
#line 231
  u = (short )*(ppos + square);
  {
#line 234
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 236
    if ((int )color[u] == 2) {
#line 243
      u = (short )*(ppos + u);
    } else {
#line 248
      if ((int )color[u] == (int )side) {
#line 248
        if ((int )board[u] == 2) {
#line 249
          return (1);
        }
      }
#line 251
      u = square;
    }
#line 234
    if (! ((int )u != (int )square)) {
#line 234
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 257
  return (0);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short hard_time_limit ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 727 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
long TCleft ;
#line 729 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int TCcount  ;
#line 750
signed char const   Stboard[81] ;
#line 751
signed char const   Stcolor[81] ;
#line 776 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short PrVar[40]  ;
#line 861
short background ;
#line 921
int OpeningBook(unsigned short *hint___0 , short side ) ;
#line 928
void UpdatePieceList(short side , short sq , UpdatePieceList_mode iop ) ;
#line 936
void SelectMove(short side , SelectMove_mode iop ) ;
#line 939
int search(short side , short ply , short depth , short alpha___0 , short beta___0 ,
           unsigned short *bstline , short *rpt___0 ) ;
#line 955
int ProbeTTable(short side , short depth , short ply , short *alpha___0 , short *beta___0 ,
                short *score___0 ) ;
#line 963
int PutInTTable(short side , short score___0 , short depth , short ply , short alpha___0 ,
                short beta___0 , unsigned short mv ) ;
#line 980
int ProbeFTable(short side , short depth , short ply , short *alpha___0 , short *beta___0 ,
                short *score___0 ) ;
#line 988
void PutInFTable(short side , short score___0 , short depth , short ply , short alpha___0 ,
                 short beta___0 , unsigned short f , unsigned short t ) ;
#line 1007
void MoveList(short side , short ply , short in_check , short blockable ) ;
#line 1009
void CaptureList(short side , short ply , short in_check , short blockable ) ;
#line 1016
void MakeMove(short side , struct leaf *node___0 , short *tempb___2 , short *tempc___2 ,
              short *tempsf___2 , short *tempst___2 , short *INCscore___0 ) ;
#line 1025
void UnmakeMove(short side , struct leaf *node___0 , short *tempb___2 , short *tempc___2 ,
                short *tempsf___2 , short *tempst___2 ) ;
#line 1033
void InitializeStats(void) ;
#line 1036
int evaluate(short side , short ply , short alpha___0 , short beta___0 , short INCscore___0 ,
             short *InChk , short *blockable ) ;
#line 1045
short ScorePosition(short side ) ;
#line 1046
void ExaminePosition(short side ) ;
#line 1073
void SetResponseTime(short side ) ;
#line 1074
void CheckForTimeout(int score___0 , int globalscore___0 , int Jscore___0 , int zwndw___0 ) ;
#line 1076
void ShowSidetoMove(void) ;
#line 1077
void ShowResponseTime(void) ;
#line 1079
void SearchStartStuff(short side ) ;
#line 1080
void ShowDepth(char ch ) ;
#line 1082
void ShowResults(short score___0 , unsigned short *bstline , char ch ) ;
#line 1084
void algbr(short f , short t , short flag___0 ) ;
#line 1085
void OutputMove(void) ;
#line 1086
void ShowCurrentMove(short pnt___2 , short f , short t ) ;
#line 1107
int pick(short p1 , short p2 ) ;
#line 1108
short repetition(void) ;
#line 1110
void ElapsedTime(ElapsedTime_mode iop ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
short background  =    (short)0;
#line 36 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short DepthBeyond  ;
#line 38
short recycle ;
#line 38
short ISZERO ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
short null  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
short PVari  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
short zwndw  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
short repetition(void) 
{ 
  short i___0 ;
  short cnt___1 ;
  struct GameRec *g___0 ;

  {
#line 63
  cnt___1 = (short)0;
#line 68
  if ((int )GameCnt > (int )Game50 + 6) {
#line 70
    i___0 = (short )((int )GameCnt - 1);
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! ((int )i___0 >= (int )Game50)) {
#line 70
        goto while_break;
      }
#line 72
      g___0 = GameList + i___0;
#line 74
      if (g___0->hashkey == hashkey) {
#line 74
        if (g___0->hashbd == hashbd) {
#line 75
          cnt___1 = (short )((int )cnt___1 + 1);
        }
      }
#line 70
      i___0 = (short )((int )i___0 - 2);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 80
  return (cnt___1);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
int plyscore  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
int globalscore  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
int pick(short p1 , short p2 ) 
{ 
  struct leaf *p ;
  struct leaf *q ;
  struct leaf *r ;
  struct leaf *k ;
  short s0 ;
  struct leaf temp ;

  {
#line 100
  p = Tree + p1;
#line 100
  k = p;
#line 101
  q = Tree + p2;
#line 102
  s0 = p->score;
#line 104
  r = p + 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((unsigned long )r <= (unsigned long )q)) {
#line 104
      goto while_break;
    }
#line 106
    if ((int )r->score > (int )s0) {
#line 108
      s0 = r->score;
#line 109
      p = r;
    }
#line 104
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  if ((unsigned long )p != (unsigned long )k) {
#line 115
    temp = *p;
#line 116
    *p = *k;
#line 117
    *k = temp;
#line 118
    return (1);
  }
#line 121
  return (0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
int bookflag  =    0;
#line 125 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
int Jscore  =    0;
#line 128 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
long TCleft  =    0L;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short i  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short tempb  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short tempc  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short tempsf  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short tempst  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short xside  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short rpt  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short alpha  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short beta  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static short score  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
static struct GameRec *g  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
void SelectMove(short side , SelectMove_mode iop ) 
{ 
  short sqking___0 ;
  short in_check ;
  short blockable ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 155
  flag.timeout = (short)0;
#line 156
  flag.back = (short)0;
#line 157
  flag.musttimeout = (short)0;
#line 159
  xside = (short )((int )side ^ 1);
#line 162
  recycle = (short )((int )GameCnt % (int )rehash - (int )rehash);
#line 165
  ExaminePosition(side);
  }
#line 168
  if ((unsigned int )iop == 2U) {
#line 170
    background = (short)1;
#line 172
    ResponseTime = 9999999L;
  } else {
    {
#line 176
    background = (short)0;
#line 177
    player = side;
#line 178
    SetResponseTime(side);
    }
  }
#line 182
  if (! background) {
    {
#line 184
    ShowResponseTime();
    }
  }
  {
#line 186
  ExtraTime = 0L;
#line 188
  score = ScorePosition(side);
  }
#line 191
  if (! background) {
    {
#line 193
    ShowSidetoMove();
    }
  }
#line 196
  if (! background) {
    {
#line 198
    SearchStartStuff(side);
    }
  }
  {
#line 201
  memset((void *)history, 0, sizeof(unsigned short ) * (size_t )(1 << 16));
#line 204
  TOsquare = (short)-1;
#line 204
  FROMsquare = TOsquare;
#line 205
  PV = (unsigned short)0;
  }
#line 207
  if ((unsigned int )iop == 1U) {
#line 208
    hint = (unsigned short)0;
  }
#line 216
  if ((int )GameCnt > 0) {
#line 218
    if ((int )(GameList + GameCnt)->gmove == (int )PrVar[2]) {
#line 218
      SwagHt = PrVar[3];
    } else {
#line 218
      SwagHt = (unsigned short)0;
    }
  } else {
#line 222
    SwagHt = (unsigned short)0;
  }
#line 225
  i = (short)0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! ((int )i < 40)) {
#line 225
      goto while_break;
    }
#line 226
    tmp___2 = (unsigned short)0;
#line 226
    killr3[i] = tmp___2;
#line 226
    tmp___1 = tmp___2;
#line 226
    killr2[i] = tmp___1;
#line 226
    tmp___0 = tmp___1;
#line 226
    killr1[i] = tmp___0;
#line 226
    tmp = tmp___0;
#line 226
    killr0[i] = tmp;
#line 226
    PrVar[i] = tmp;
#line 225
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if (flag.tsume) {
#line 232
    alpha = (short)-12999;
#line 233
    beta = (short)12999;
  } else {
#line 237
    if ((int )computer == 1) {
#line 237
      tmp___3 = (int )BAwindow;
    } else {
#line 237
      tmp___3 = (int )WAwindow;
    }
#line 237
    alpha = (short )((int )score - tmp___3);
#line 238
    if ((int )computer == 1) {
#line 238
      tmp___4 = (int )BBwindow;
    } else {
#line 238
      tmp___4 = (int )WBwindow;
    }
#line 238
    beta = (short )((int )score + tmp___4);
  }
#line 241
  rpt = (short)0;
#line 242
  TrPnt[1] = (short)0;
#line 243
  root = Tree + 0;
#line 245
  sqking___0 = (short )PieceList[side][0];
#line 246
  if ((int )board[sqking___0] == 14) {
    {
#line 246
    tmp___5 = SqAttacked(sqking___0, (short )((int )side ^ 1), & blockable);
#line 246
    in_check = (short )tmp___5;
    }
  } else {
#line 246
    in_check = (short)0;
  }
  {
#line 250
  MoveList(side, (short)1, in_check, blockable);
#line 252
  i = TrPnt[1];
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! ((int )i < (int )TrPnt[2])) {
#line 252
      goto while_break___0;
    }
    {
#line 254
    tmp___6 = pick(i, (short )((int )TrPnt[2] - 1));
    }
#line 254
    if (! tmp___6) {
#line 255
      goto while_break___0;
    }
#line 252
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if (flag.regularstart) {
#line 260
    if (Book) {
      {
#line 262
      bookflag = OpeningBook(& hint, side);
#line 262
      flag.timeout = (short )bookflag;
      }
#line 264
      if (TCflag) {
#line 265
        ResponseTime += ResponseTime;
      }
    }
  }
#line 270
  replus = 0L;
#line 270
  reminus = replus;
#line 271
  HashCol = 0L;
#line 271
  THashCol = HashCol;
#line 271
  FHashCnt = THashCol;
#line 271
  HashAdd = FHashCnt;
#line 271
  FHashAdd = HashAdd;
#line 271
  HashCnt = FHashAdd;
#line 271
  EvalNodes = HashCnt;
#line 271
  ETnodes = EvalNodes;
#line 271
  NodeCnt = ETnodes;
#line 271
  GenCnt = NodeCnt;
#line 274
  plyscore = (int )score;
#line 274
  globalscore = plyscore;
#line 275
  Jscore = 0;
#line 276
  zwndw = (short)20;
#line 281
  if ((int )MaxSearchDepth < 1) {
#line 281
    Sdepth = MaxSearchDepth;
  } else {
#line 281
    Sdepth = (short)1;
  }
  {
#line 285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 285
    if (! (! flag.timeout)) {
#line 285
      goto while_break___1;
    }
#line 288
    Sdepth = (short )((int )Sdepth + 1);
#line 291
    null = (short)0;
#line 292
    PVari = (short)1;
#line 296
    if (flag.tsume) {
#line 297
      DepthBeyond = Sdepth;
    } else {
#line 302
      if ((int )Sdepth == 1) {
#line 302
        tmp___7 = 7;
      } else {
#line 302
        tmp___7 = 11;
      }
#line 302
      DepthBeyond = (short )((int )Sdepth + tmp___7);
    }
#line 306
    if (! background) {
      {
#line 308
      ShowDepth((char )' ');
      }
    }
    {
#line 311
    tmp___8 = search(side, (short)1, Sdepth, alpha, beta, PrVar, & rpt);
#line 311
    score = (short )tmp___8;
#line 314
    i = (short)1;
    }
    {
#line 314
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 314
      if (! ((int )i <= (int )Sdepth)) {
#line 314
        goto while_break___2;
      }
#line 315
      killr0[i] = PrVar[i];
#line 314
      i = (short )((int )i + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 318
    if ((int )score < (int )alpha) {
#line 320
      reminus ++;
#line 322
      if (! background) {
        {
#line 324
        ShowDepth((char )'-');
        }
      }
#line 326
      if (TCflag) {
#line 326
        if (TCcount < 4) {
#line 328
          if (hard_time_limit) {
#line 329
            ExtraTime += (long )(4 - TCcount) * TCleft;
          } else {
#line 331
            ExtraTime += 8L * TCleft;
          }
#line 333
          TCcount = 3;
        }
      }
      {
#line 336
      tmp___9 = search(side, (short)1, Sdepth, (short)-12999, (short)12999, PrVar,
                       & rpt);
#line 336
      score = (short )tmp___9;
      }
    } else
#line 340
    if ((int )score > (int )beta) {
#line 340
      if (! ((int )root->flags & 64)) {
#line 342
        replus ++;
#line 344
        if (! background) {
          {
#line 346
          ShowDepth((char )'+');
          }
        }
        {
#line 348
        tmp___10 = search(side, (short)1, Sdepth, (short)-12999, (short)12999, PrVar,
                          & rpt);
#line 348
        score = (short )tmp___10;
        }
      }
    }
    {
#line 353
    CheckForTimeout((int )score, globalscore, Jscore, (int )zwndw);
#line 358
    i = (short)1;
    }
    {
#line 358
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 358
      if (! ((int )i <= (int )Sdepth + 1)) {
#line 358
        goto while_break___3;
      }
#line 359
      killr0[i] = PrVar[i];
#line 358
      i = (short )((int )i + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 361
    if (! flag.timeout) {
#line 362
      Tscore[0] = score;
    }
#line 372
    if ((int )root->flags & 64) {
#line 373
      flag.timeout = (short)1;
    } else
#line 372
    if ((int )score < -12000) {
#line 373
      flag.timeout = (short)1;
    }
#line 377
    if (! flag.timeout) {
      {
#line 380
      Jscore = (plyscore + (int )score) >> 1;
#line 382
      tmp___11 = abs(Jscore / 12);
#line 382
      zwndw = (short )(20 + tmp___11);
#line 383
      plyscore = (int )score;
      }
#line 386
      if ((int )computer == 1) {
#line 386
        tmp___12 = (int )BBwindow;
      } else {
#line 386
        tmp___12 = (int )WBwindow;
      }
#line 386
      beta = (short )((int )score + tmp___12);
#line 388
      if (Jscore < (int )score) {
#line 388
        tmp___13 = Jscore;
      } else {
#line 388
        tmp___13 = (int )score;
      }
#line 388
      if ((int )computer == 1) {
#line 388
        tmp___14 = (int )BAwindow;
      } else {
#line 388
        tmp___14 = (int )WAwindow;
      }
#line 388
      alpha = (short )((tmp___13 - tmp___14) - (int )zwndw);
    }
#line 397
    if (! background) {
      {
#line 399
      ShowResults(score, PrVar, (char )'.');
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 405
  if ((unsigned int )iop == 2U) {
#line 406
    return;
  }
#line 408
  if ((int )rpt >= 3) {
#line 410
    root->flags = (unsigned short )((int )root->flags | 1024);
#line 411
    DRAW = DRAW_REPETITION;
  } else
#line 420
  if ((int )GameCnt == 300) {
#line 422
    root->flags = (unsigned short )((int )root->flags | 1024);
#line 423
    DRAW = DRAW_MAXMOVES;
  }
#line 428
  if (! bookflag) {
#line 429
    if (PrVar[1]) {
#line 429
      hint = PrVar[2];
    } else {
#line 429
      hint = (unsigned short)0;
    }
  }
#line 432
  if ((int )score > -12999) {
#line 432
    if ((int )rpt <= 3) {
      {
#line 435
      MakeMove(side, Tree + 0, & tempb, & tempc, & tempsf, & tempst, & INCscore);
#line 437
      algbr((short )root->f, (short )root->t, (short )root->flags);
      }
    } else {
#line 432
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 432
  if ((int )root->flags & 1024) {
    {
#line 435
    MakeMove(side, Tree + 0, & tempb, & tempc, & tempsf, & tempst, & INCscore);
#line 437
    algbr((short )root->f, (short )root->t, (short )root->flags);
    }
  } else {
    {
#line 441
    algbr((short)0, (short)0, (short)0);
#line 442
    root->score = score;
    }
  }
#line 446
  g = GameList + GameCnt;
#line 448
  if ((int )g->flags & 512) {
#line 448
    if ((int )g->piece == 14) {
#line 449
      flag.illegal = (short)1;
#line 449
      flag.mate = flag.illegal;
    }
  }
#line 452
  if (TCflag) {
    {
#line 453
    ElapsedTime((ElapsedTime_mode )1);
    }
  }
  {
#line 456
  OutputMove();
  }
#line 459
  if ((int )score == -12999) {
#line 460
    flag.mate = (short)1;
  } else
#line 459
  if ((int )score == 12998) {
#line 460
    flag.mate = (short)1;
  }
#line 463
  g->score = score;
#line 464
  g->nodes = NodeCnt;
#line 465
  g->time = (et + 50L) / 100L;
#line 467
  g->depth = Sdepth;
#line 470
  if (TCflag) {
#line 472
    TimeControl.clock[side] -= et + (long )OperatorTime;
#line 473
    timecomp[compptr] = (int )(et + (long )OperatorTime);
#line 476
    TimeControl.moves[side] = (short )((int )TimeControl.moves[side] - 1);
  }
#line 480
  if ((int )root->flags & 1024) {
#line 482
    flag.mate = (short)1;
  } else
#line 484
  if ((int )GameCnt == 300) {
#line 486
    flag.mate = (short)1;
  } else {
#line 492
    player = xside;
  }
#line 496
  if (flag.mate) {
#line 497
    hint = (unsigned short)0;
  }
#line 499
  Sdepth = (short)0;
#line 500
  return;
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
int search(short side , short ply , short depth , short alpha___0 , short beta___0 ,
           unsigned short *bstline , short *rpt___0 ) 
{ 
  short j ;
  short pnt___2 ;
  short tempb___2 ;
  short tempc___2 ;
  short tempsf___2 ;
  short tempst___2 ;
  short xside___0 ;
  short pbst ;
  short score___0 ;
  short rcnt ;
  short in_check ;
  short blockable ;
  unsigned short mv ;
  unsigned short nxtline[40] ;
  struct leaf *node___0 ;
  struct leaf tmp ;
  short best ;
  short bestwidth ;
  short mustcut ;
  short PVsave ;
  short PVarisave ;
  int tmp___0 ;
  short timeout ;
  int tmp___1 ;
  int tmp___2 ;
  struct GameRec *g___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned short h ;
  unsigned short x ;
  int tmp___9 ;

  {
#line 527
  best = (short)-15000;
#line 528
  bestwidth = (short)0;
#line 536
  NodeCnt ++;
#line 540
  if (! null) {
#line 543
    if (NodeCnt > ETnodes) {
      {
#line 545
      ElapsedTime((ElapsedTime_mode )2);
      }
#line 547
      if (flag.back) {
#line 549
        flag.back = (short)0;
#line 550
        flag.timeout = (short)1;
#line 551
        flag.musttimeout = (short)0;
      } else
#line 553
      if (TCflag) {
#line 553
        goto _L;
      } else
#line 553
      if (MaxResponseTime) {
        _L: /* CIL Label */ 
#line 555
        if (et >= ResponseTime + ExtraTime) {
#line 555
          if ((int )Sdepth > 2) {
#line 559
            if (flag.back) {
#line 561
              flag.back = (short)0;
#line 562
              flag.musttimeout = (short)1;
#line 563
              TCcount ++;
#line 564
              ExtraTime += TCleft;
            } else
#line 559
            if (TCflag) {
#line 559
              if (TCcount < 10) {
#line 561
                flag.back = (short)0;
#line 562
                flag.musttimeout = (short)1;
#line 563
                TCcount ++;
#line 564
                ExtraTime += TCleft;
              } else {
#line 568
                flag.back = (short)0;
#line 569
                flag.timeout = (short)1;
#line 570
                flag.musttimeout = (short)0;
              }
            } else {
#line 568
              flag.back = (short)0;
#line 569
              flag.timeout = (short)1;
#line 570
              flag.musttimeout = (short)0;
            }
          }
        }
      } else
#line 574
      if (flag.back) {
#line 576
        flag.back = (short)0;
#line 577
        flag.timeout = (short)1;
#line 578
        flag.musttimeout = (short)0;
      }
#line 582
      if (! background) {
        {
#line 584
        ShowResponseTime();
        }
      }
    } else
#line 586
    if (! TCflag) {
#line 586
      if (flag.musttimeout) {
#line 586
        if ((int )Sdepth > 2) {
#line 588
          flag.timeout = (short)1;
#line 589
          flag.musttimeout = (short)0;
        }
      }
    }
  }
  {
#line 595
  xside___0 = (short )((int )side ^ 1);
#line 596
  tmp___0 = evaluate(side, ply, alpha___0, beta___0, INCscore, & in_check, & blockable);
#line 596
  score___0 = (short )tmp___0;
  }
#line 604
  if ((int )ply <= (int )Sdepth + 3) {
#line 604
    if ((int )rpthash[side][hashkey & 255UL] > 0) {
      {
#line 606
      *rpt___0 = repetition();
      }
#line 613
      if ((int )*rpt___0 == 1) {
#line 615
        score___0 = (short )((int )score___0 / 3);
#line 616
        score___0 = (short )((int )score___0 * 2);
      } else
#line 618
      if ((int )*rpt___0 == 2) {
#line 619
        score___0 = (short )((int )score___0 / 2);
      }
    } else {
#line 623
      *rpt___0 = (short)0;
    }
  } else {
#line 623
    *rpt___0 = (short)0;
  }
#line 627
  if ((int )score___0 > 12000) {
#line 629
    *(bstline + ply) = (unsigned short)0;
#line 630
    return ((int )score___0);
  }
#line 638
  if ((int )depth > 0) {
#line 641
    if (in_check) {
#line 643
      if ((int )depth < 2) {
#line 644
        depth = (short)2;
      }
    } else
#line 646
    if (flag.rcptr) {
#line 646
      if ((int )score___0 > (int )alpha___0) {
#line 646
        if ((int )score___0 < (int )beta___0) {
#line 646
          if ((int )ply > 2) {
#line 646
            if (CptrFlag[(int )ply - 1]) {
#line 646
              if (CptrFlag[(int )ply - 2]) {
#line 651
                if (hard_time_limit) {
#line 653
                  if (! flag.timeout) {
#line 654
                    depth = (short )((int )depth + 1);
                  }
                } else {
#line 658
                  depth = (short )((int )depth + 1);
                }
              }
            }
          }
        }
      }
    }
  } else {
#line 665
    timeout = (short)0;
#line 667
    if (hard_time_limit) {
#line 668
      timeout = flag.timeout;
    }
#line 670
    if ((int )score___0 >= (int )alpha___0) {
#line 670
      if (in_check) {
#line 675
        depth = (short)1;
      } else
#line 670
      if (! timeout) {
#line 670
        if ((int )hung[side] > 1) {
#line 670
          if ((int )ply == (int )Sdepth + 1) {
#line 675
            depth = (short)1;
          } else {
#line 670
            goto _L___0;
          }
        } else {
#line 670
          goto _L___0;
        }
      } else {
#line 670
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 677
    if ((int )score___0 <= (int )beta___0) {
#line 677
      if ((int )ply < (int )Sdepth + 4) {
#line 677
        if ((int )ply > 4) {
#line 677
          if (ChkFlag[(int )ply - 2]) {
#line 677
            if (ChkFlag[(int )ply - 4]) {
#line 677
              if ((int )ChkFlag[(int )ply - 2] != (int )ChkFlag[(int )ply - 4]) {
#line 683
                depth = (short)1;
              }
            }
          }
        }
      }
    }
  }
#line 691
  if (flag.hash) {
#line 691
    if ((int )ply > 1) {
#line 693
      if (use_ttable) {
        {
#line 693
        tmp___2 = ProbeTTable(side, depth, ply, & alpha___0, & beta___0, & score___0);
        }
#line 693
        if (tmp___2 == 1) {
#line 696
          *(bstline + ply) = PV;
#line 697
          *(bstline + ((int )ply + 1)) = (unsigned short)0;
#line 699
          if ((int )beta___0 == -26000) {
#line 700
            return ((int )score___0);
          }
#line 702
          if ((int )alpha___0 > (int )beta___0) {
#line 703
            return ((int )alpha___0);
          }
        } else {
#line 693
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 708
      if (hashfile) {
#line 708
        if ((int )depth > (int )HashDepth) {
#line 708
          if ((int )GameCnt < (int )HashMoveLimit) {
            {
#line 708
            tmp___1 = ProbeFTable(side, depth, ply, & alpha___0, & beta___0, & score___0);
            }
#line 708
            if (tmp___1 == 1) {
              {
#line 714
              PutInTTable(side, score___0, depth, ply, alpha___0, beta___0, PV);
#line 715
              *(bstline + ply) = PV;
#line 716
              *(bstline + ((int )ply + 1)) = (unsigned short)0;
              }
#line 718
              if ((int )beta___0 == -26000) {
#line 719
                return ((int )score___0);
              }
#line 721
              if ((int )alpha___0 > (int )beta___0) {
#line 723
                return ((int )alpha___0);
              }
            }
          }
        }
      }
    }
  }
#line 730
  if ((int )TrPnt[ply] > 3700) {
#line 731
    mustcut = (short)1;
  } else {
#line 733
    mustcut = (short)0;
  }
#line 740
  if (mustcut) {
#line 741
    return ((int )score___0);
  } else
#line 740
  if ((int )ply > (int )DepthBeyond) {
#line 741
    return ((int )score___0);
  } else
#line 740
  if ((int )depth < 1) {
#line 740
    if ((int )score___0 > (int )beta___0) {
#line 741
      return ((int )score___0);
    }
  }
#line 748
  if ((int )ply > 1) {
#line 750
    if ((int )depth > 0) {
      {
#line 752
      MoveList(side, ply, in_check, blockable);
      }
    } else
#line 750
    if ((int )ply < (int )Sdepth + 1) {
      {
#line 752
      MoveList(side, ply, in_check, blockable);
      }
    } else
#line 750
    if (background) {
#line 750
      if ((int )ply < (int )Sdepth + 2) {
        {
#line 752
        MoveList(side, ply, in_check, blockable);
        }
      } else {
        {
#line 754
        CaptureList(side, ply, in_check, blockable);
        }
      }
    } else {
      {
#line 754
      CaptureList(side, ply, in_check, blockable);
      }
    }
  }
#line 765
  if ((int )TrPnt[ply] == (int )TrPnt[(int )ply + 1]) {
#line 766
    return ((int )score___0);
  }
#line 769
  if ((int )depth > 0) {
#line 769
    best = (short)-15000;
  } else {
#line 769
    best = score___0;
  }
#line 773
  PVarisave = PVari;
#line 776
  if (! null) {
#line 776
    if (! PVari) {
#line 776
      if (((int )ply > 2) & ((int )ply <= (int )Sdepth)) {
#line 776
        if ((int )depth > 3) {
#line 776
          if (! in_check) {
            {
#line 799
            nxtline[(int )ply + 1] = (unsigned short)0;
#line 800
            CptrFlag[ply] = (signed char)0;
#line 801
            TesujiFlag[ply] = (signed char)0;
#line 802
            Tscore[ply] = score___0;
#line 803
            PVsave = (short )PV;
#line 804
            PV = (unsigned short)0;
#line 805
            null = (short)1;
#line 806
            GameCnt = (short )((int )GameCnt + 1);
#line 806
            g___0 = GameList + GameCnt;
#line 807
            g___0->hashkey = hashkey;
#line 808
            g___0->hashbd = hashbd;
#line 809
            TOsquare = (short)-1;
#line 809
            FROMsquare = TOsquare;
#line 810
            g___0->Game50 = Game50;
#line 811
            g___0->gmove = (unsigned short)65535;
#line 812
            g___0->flags = (short)0;
#line 813
            g___0->piece = (short)0;
#line 814
            g___0->color = (short)2;
#line 816
            tmp___3 = search(xside___0, (short )((int )ply + 1), (short )((int )depth - 2),
                             (short )(- ((int )beta___0) - 1), (short )(- ((int )beta___0)),
                             nxtline, & rcnt);
#line 816
            best = (short )(- tmp___3);
#line 818
            null = (short)0;
#line 819
            PV = (unsigned short )PVsave;
#line 820
            GameCnt = (short )((int )GameCnt - 1);
            }
#line 822
            if ((int )best < (int )alpha___0) {
#line 824
              best = (short)-15000;
            } else
#line 826
            if ((int )best > (int )beta___0) {
#line 828
              return ((int )best);
            } else {
#line 832
              best = (short)-15000;
            }
          }
        }
      }
    }
  }
#line 838
  if ((int )best > (int )alpha___0) {
#line 839
    alpha___0 = best;
  }
#line 844
  pbst = TrPnt[ply];
#line 844
  pnt___2 = pbst;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if ((int )pnt___2 < (int )TrPnt[(int )ply + 1]) {
#line 844
      if (! ((int )best <= (int )beta___0)) {
#line 844
        goto while_break;
      }
    } else {
#line 844
      goto while_break;
    }
#line 849
    if ((int )ply > 1) {
      {
#line 850
      pick(pnt___2, (short )((int )TrPnt[(int )ply + 1] - 1));
      }
    }
#line 853
    if (PVarisave) {
#line 853
      if ((int )pnt___2 == (int )TrPnt[ply]) {
#line 853
        tmp___4 = 1;
      } else {
#line 853
        tmp___4 = 0;
      }
    } else {
#line 853
      tmp___4 = 0;
    }
#line 853
    PVari = (short )tmp___4;
#line 856
    node___0 = Tree + pnt___2;
#line 859
    if ((int )node___0->score <= -32760) {
#line 860
      goto __Cont;
    }
#line 862
    nxtline[(int )ply + 1] = (unsigned short)0;
#line 866
    if ((int )ply == 1) {
#line 869
      if (flag.post) {
#line 872
        if (! background) {
          {
#line 874
          ShowCurrentMove(pnt___2, (short )node___0->f, (short )node___0->t);
          }
        }
      }
    }
#line 879
    if (! ((int )node___0->flags & 64)) {
      {
#line 883
      MakeMove(side, node___0, & tempb___2, & tempc___2, & tempsf___2, & tempst___2,
               & INCscore);
#line 885
      CptrFlag[ply] = (signed char )(((int )node___0->flags & 512) != 0);
      }
#line 886
      if ((int )node___0->flags & 128) {
#line 886
        if ((int )node___0->flags & 32) {
#line 886
          tmp___5 = 1;
        } else {
#line 886
          tmp___5 = 0;
        }
      } else {
#line 886
        tmp___5 = 0;
      }
#line 886
      TesujiFlag[ply] = (signed char )tmp___5;
#line 888
      Tscore[ply] = node___0->score;
#line 889
      PV = (unsigned short )node___0->reply;
#line 891
      if ((int )depth > 0) {
#line 891
        tmp___6 = (int )depth - 1;
      } else {
#line 891
        tmp___6 = 0;
      }
      {
#line 891
      tmp___7 = search(xside___0, (short )((int )ply + 1), (short )tmp___6, (short )(- ((int )beta___0)),
                       (short )(- ((int )alpha___0)), nxtline, & rcnt);
#line 891
      node___0->score = (short )(- tmp___7);
      }
#line 901
      if ((int )ply % 2 == 1) {
#line 901
        node___0->width = (short )((int )TrPnt[(int )ply + 2] - (int )TrPnt[(int )ply + 1]);
      } else {
#line 901
        node___0->width = (short)0;
      }
#line 905
      if ((int )node___0->score > 12000) {
#line 906
        node___0->flags = (unsigned short )((int )node___0->flags | 64);
      } else
#line 905
      if ((int )node___0->score < -12000) {
#line 906
        node___0->flags = (unsigned short )((int )node___0->flags | 64);
      } else
#line 907
      if ((int )rcnt == 1) {
#line 908
        node___0->score = (short )((int )node___0->score / 2);
      }
#line 910
      if ((int )rcnt >= 3) {
#line 910
        goto _L___2;
      } else
#line 910
      if ((int )node___0->score == 12999 - (int )ply) {
#line 910
        if (! ChkFlag[ply]) {
          _L___2: /* CIL Label */ 
#line 914
          node___0->flags = (unsigned short )((int )node___0->flags | 1088);
#line 915
          DRAW = DRAW_JUSTDRAW;
#line 916
          if ((int )side == (int )computer) {
#line 916
            node___0->score = contempt;
          } else {
#line 916
            node___0->score = (short )(- ((int )contempt));
          }
        }
      }
      {
#line 919
      node___0->reply = (short )nxtline[(int )ply + 1];
#line 922
      UnmakeMove(side, node___0, & tempb___2, & tempc___2, & tempsf___2, & tempst___2);
      }
    }
#line 927
    if (! flag.timeout) {
#line 927
      if ((int )node___0->score > (int )best) {
#line 927
        goto _L___4;
      } else
#line 927
      if ((int )node___0->score == (int )best) {
#line 927
        if ((int )node___0->width > (int )bestwidth) {
          _L___4: /* CIL Label */ 
#line 935
          bestwidth = node___0->width;
#line 942
          if ((int )depth > 0) {
#line 942
            if ((int )node___0->score > (int )alpha___0) {
#line 942
              if (! ((int )node___0->flags & 64)) {
#line 945
                node___0->score = (short )((int )node___0->score + (int )depth);
              }
            }
          }
#line 948
          best = node___0->score;
#line 949
          pbst = pnt___2;
#line 951
          if ((int )best > (int )alpha___0) {
#line 952
            alpha___0 = best;
          }
#line 955
          j = (short )((int )ply + 1);
          {
#line 955
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 955
            if (! ((int )nxtline[j] > 0)) {
#line 955
              goto while_break___0;
            }
#line 956
            *(bstline + j) = nxtline[j];
#line 955
            j = (short )((int )j + 1);
          }
          while_break___0: /* CIL Label */ ;
          }
#line 958
          *(bstline + j) = (unsigned short)0;
#line 959
          *(bstline + ply) = (unsigned short )(((int )node___0->f << 8) | (int )node___0->t);
#line 962
          if ((int )ply == 1) {
#line 967
            if ((int )best > (int )root->score) {
#line 967
              goto _L___3;
            } else
#line 967
            if ((int )best == (int )root->score) {
#line 967
              if ((int )bestwidth > (int )root->width) {
                _L___3: /* CIL Label */ 
#line 971
                tmp = *(Tree + pnt___2);
#line 973
                j = (short )((int )pnt___2 - 1);
                {
#line 973
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 973
                  if (! ((int )j >= 0)) {
#line 973
                    goto while_break___1;
                  }
#line 974
                  *(Tree + ((int )j + 1)) = *(Tree + j);
#line 973
                  j = (short )((int )j - 1);
                }
                while_break___1: /* CIL Label */ ;
                }
#line 976
                *(Tree + 0) = tmp;
#line 977
                pbst = (short)0;
              }
            }
#line 981
            if (! background) {
#line 984
              if ((int )Sdepth > 2) {
#line 986
                if ((int )best > (int )beta___0) {
                  {
#line 988
                  ShowResults(best, bstline, (char )'+');
                  }
                } else
#line 990
                if ((int )best < (int )alpha___0) {
                  {
#line 992
                  ShowResults(best, bstline, (char )'-');
                  }
                } else {
                  {
#line 996
                  ShowResults(best, bstline, (char )'&');
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1005
    if (flag.timeout) {
#line 1006
      return ((int )Tscore[(int )ply - 1]);
    }
    __Cont: /* CIL Label */ 
#line 844
    pnt___2 = (short )((int )pnt___2 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1011
  node___0 = Tree + pbst;
#line 1012
  mv = (unsigned short )(((int )node___0->f << 8) | (int )node___0->t);
#line 1015
  PVari = PVarisave;
#line 1025
  if (flag.hash) {
#line 1025
    if ((int )ply <= (int )Sdepth) {
#line 1025
      if ((int )*rpt___0 == 0) {
#line 1025
        if ((int )best == (int )alpha___0) {
#line 1028
          if (use_ttable) {
            {
#line 1028
            tmp___8 = PutInTTable(side, best, depth, ply, alpha___0, beta___0, mv);
            }
#line 1028
            if (tmp___8) {
#line 1028
              if (hashfile) {
#line 1028
                if ((int )depth > (int )HashDepth) {
#line 1028
                  if ((int )GameCnt < (int )HashMoveLimit) {
                    {
#line 1038
                    PutInFTable(side, best, depth, ply, alpha___0, beta___0, (unsigned short )node___0->f,
                                (unsigned short )node___0->t);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1044
  if ((int )depth > 0) {
#line 1048
    h = mv;
#line 1050
    if (side) {
#line 1050
      tmp___9 = 1 << 15;
    } else {
#line 1050
      tmp___9 = 0;
    }
#line 1050
    x = (unsigned short )(tmp___9 | (((int )h & 32767) ^ 21845));
#line 1050
    if ((int )*(history + x) < 4096) {
#line 1051
      *(history + x) = (unsigned short )((int )*(history + x) + (1 << (int )depth));
    }
#line 1054
    if ((int )node___0->t != (int )((short )((int )(GameList + GameCnt)->gmove & 255))) {
#line 1056
      if ((int )best <= (int )beta___0) {
#line 1058
        killr3[ply] = mv;
      } else
#line 1060
      if ((int )mv != (int )killr1[ply]) {
#line 1062
        killr2[ply] = killr1[ply];
#line 1063
        killr1[ply] = mv;
      }
    }
#line 1067
    if ((int )best > 12000) {
#line 1067
      killr0[ply] = mv;
    } else {
#line 1067
      killr0[ply] = (unsigned short)0;
    }
  }
#line 1070
  return ((int )best);
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
void UpdatePieceList(short side , short sq , UpdatePieceList_mode iop ) 
{ 
  short i___0 ;

  {
#line 1085
  if ((unsigned int )iop == 1U) {
#line 1087
    PieceCnt[side] = (signed char )((int )PieceCnt[side] - 1);
#line 1089
    i___0 = (short )Pindex[sq];
    {
#line 1089
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1089
      if (! ((int )i___0 <= (int )PieceCnt[side])) {
#line 1089
        goto while_break;
      }
#line 1091
      PieceList[side][i___0] = PieceList[side][(int )i___0 + 1];
#line 1092
      Pindex[PieceList[side][i___0]] = (signed char )i___0;
#line 1089
      i___0 = (short )((int )i___0 + 1);
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1095
  if ((int )board[sq] == 14) {
#line 1098
    i___0 = (short )PieceCnt[side];
    {
#line 1098
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1098
      if (! ((int )i___0 >= 0)) {
#line 1098
        goto while_break___0;
      }
#line 1100
      PieceList[side][(int )i___0 + 1] = PieceList[side][i___0];
#line 1101
      Pindex[PieceList[side][(int )i___0 + 1]] = (signed char )((int )i___0 + 1);
#line 1098
      i___0 = (short )((int )i___0 - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1104
    PieceCnt[side] = (signed char )((int )PieceCnt[side] + 1);
#line 1105
    PieceList[side][0] = (signed char )sq;
#line 1106
    Pindex[sq] = (signed char)0;
  } else {
#line 1110
    PieceCnt[side] = (signed char )((int )PieceCnt[side] + 1);
#line 1111
    PieceList[side][PieceCnt[side]] = (signed char )sq;
#line 1112
    Pindex[sq] = PieceCnt[side];
  }
#line 1114
  return;
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
void drop(short side , short piece , short f , short t , short iop ) 
{ 
  short n ;
  signed char tmp ;
  short n___0 ;

  {
#line 1123
  if ((int )iop == 1) {
#line 1126
    board[t] = (signed char )piece;
#line 1127
    color[t] = (signed char )side;
#line 1130
    svalue[t] = (short)0;
#line 1133
    tmp = Captured[side][piece];
#line 1133
    Captured[side][piece] = (signed char )((int )Captured[side][piece] - 1);
#line 1133
    n = (short )tmp;
#line 1135
    hashbd ^= (*drop_hashcode)[side][piece][n].bd;
#line 1135
    hashkey ^= (*drop_hashcode)[side][piece][n].key;
#line 1136
    if ((int )t >= 0) {
#line 1136
      hashbd ^= (*hashcode)[side][piece][t].bd;
#line 1136
      hashkey ^= (*hashcode)[side][piece][t].key;
    }
    {
#line 1137
    UpdatePieceList(side, t, (UpdatePieceList_mode )2);
    }
#line 1139
    if ((int )piece == 1) {
#line 1141
      PawnCnt[side][(int )t % 9] = (signed char )((int )PawnCnt[side][(int )t % 9] + 1);
    }
#line 1144
    Mvboard[t] = (signed char )((int )Mvboard[t] + 1);
#line 1145
    HasPiece[side][piece] = (signed char )((int )HasPiece[side][piece] + 1);
  } else {
#line 1150
    board[t] = (signed char)0;
#line 1151
    color[t] = (signed char)2;
#line 1152
    Captured[side][piece] = (signed char )((int )Captured[side][piece] + 1);
#line 1152
    n___0 = (short )Captured[side][piece];
#line 1154
    hashbd ^= (*drop_hashcode)[side][piece][n___0].bd;
#line 1154
    hashkey ^= (*drop_hashcode)[side][piece][n___0].key;
#line 1155
    if ((int )t >= 0) {
#line 1155
      hashbd ^= (*hashcode)[side][piece][t].bd;
#line 1155
      hashkey ^= (*hashcode)[side][piece][t].key;
    }
    {
#line 1156
    UpdatePieceList(side, t, (UpdatePieceList_mode )1);
    }
#line 1158
    if ((int )piece == 1) {
#line 1159
      PawnCnt[side][(int )t % 9] = (signed char )((int )PawnCnt[side][(int )t % 9] - 1);
    }
#line 1161
    Mvboard[t] = (signed char )((int )Mvboard[t] - 1);
#line 1162
    HasPiece[side][piece] = (signed char )((int )HasPiece[side][piece] - 1);
  }
#line 1164
  return;
}
}
#line 1234 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
void MakeMove(short side , struct leaf *node___0 , short *tempb___2 , short *tempc___2 ,
              short *tempsf___2 , short *tempst___2 , short *INCscore___0 ) 
{ 
  short f ;
  short t ;
  short xside___0 ;
  struct GameRec *g___0 ;
  short fromb ;
  short fromc ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short n ;
  short upiece ;
  short tob ;

  {
#line 1247
  xside___0 = (short )((int )side ^ 1);
#line 1248
  GameCnt = (short )((int )GameCnt + 1);
#line 1248
  g___0 = GameList + GameCnt;
#line 1249
  g___0->hashkey = hashkey;
#line 1250
  g___0->hashbd = hashbd;
#line 1251
  f = (short )node___0->f;
#line 1251
  FROMsquare = f;
#line 1252
  t = (short )((int )node___0->t & 127);
#line 1252
  TOsquare = t;
#line 1253
  *INCscore___0 = node___0->INCscore;
#line 1254
  g___0->Game50 = Game50;
#line 1255
  g___0->gmove = (unsigned short )(((int )f << 8) | (int )node___0->t);
#line 1256
  g___0->flags = (short )node___0->flags;
#line 1276
  rpthash[side][hashkey & 255UL] = (short )((int )rpthash[side][hashkey & 255UL] + 1);
#line 1276
  ISZERO = (short )((int )ISZERO + 1);
#line 1278
  if ((int )f > 81) {
    {
#line 1280
    g___0->fpiece = (short )((int )node___0->flags & 15);
#line 1281
    tmp = (short)0;
#line 1281
    *tempb___2 = tmp;
#line 1281
    g___0->piece = tmp;
#line 1282
    tmp___0 = (short)2;
#line 1282
    *tempc___2 = tmp___0;
#line 1282
    g___0->color = tmp___0;
#line 1285
    *tempsf___2 = (short)0;
#line 1286
    *tempst___2 = svalue[t];
#line 1289
    drop(side, g___0->fpiece, f, t, (short)1);
    }
  } else {
#line 1294
    *tempsf___2 = svalue[f];
#line 1295
    *tempst___2 = svalue[t];
#line 1298
    g___0->fpiece = (short )board[f];
#line 1299
    tmp___1 = (short )board[t];
#line 1299
    *tempb___2 = tmp___1;
#line 1299
    g___0->piece = tmp___1;
#line 1300
    tmp___2 = (short )color[t];
#line 1300
    *tempc___2 = tmp___2;
#line 1300
    g___0->color = tmp___2;
#line 1301
    fromb = (short )board[f];
#line 1302
    fromc = (short )color[f];
#line 1304
    if ((int )*tempc___2 != 2) {
      {
#line 1307
      UpdatePieceList(*tempc___2, t, (UpdatePieceList_mode )1);
      }
#line 1310
      if ((int )*tempb___2 == 1) {
#line 1311
        PawnCnt[*tempc___2][(int )t % 9] = (signed char )((int )PawnCnt[*tempc___2][(int )t % 9] - 1);
      }
#line 1313
      mtl[xside___0] = (short )((int )mtl[xside___0] - (int )(*value)[stage][*tempb___2]);
#line 1314
      HasPiece[xside___0][*tempb___2] = (signed char )((int )HasPiece[xside___0][*tempb___2] - 1);
#line 1317
      upiece = (short )unpromoted[*tempb___2];
#line 1320
      Captured[side][upiece] = (signed char )((int )Captured[side][upiece] + 1);
#line 1320
      n = (short )Captured[side][upiece];
#line 1322
      hashbd ^= (*drop_hashcode)[side][upiece][n].bd;
#line 1322
      hashkey ^= (*drop_hashcode)[side][upiece][n].key;
#line 1323
      mtl[side] = (short )((int )mtl[side] + (int )(*value)[stage][upiece]);
#line 1327
      if ((int )t >= 0) {
#line 1327
        hashbd ^= (*hashcode)[xside___0][*tempb___2][t].bd;
#line 1327
        hashkey ^= (*hashcode)[xside___0][*tempb___2][t].key;
      }
#line 1330
      *INCscore___0 = (short )((int )*INCscore___0 + (int )*tempst___2);
#line 1334
      Mvboard[t] = (signed char )((int )Mvboard[t] + 1);
    }
#line 1337
    color[t] = (signed char )fromc;
#line 1340
    svalue[t] = svalue[f];
#line 1341
    svalue[f] = (short)0;
#line 1344
    Pindex[t] = Pindex[f];
#line 1345
    PieceList[side][Pindex[t]] = (signed char )t;
#line 1346
    color[f] = (signed char)2;
#line 1347
    board[f] = (signed char)0;
#line 1349
    if ((int )node___0->flags & 16) {
#line 1353
      tob = (short )promoted[fromb];
#line 1353
      board[t] = (signed char )tob;
#line 1356
      if ((int )f >= 0) {
#line 1356
        hashbd ^= (*hashcode)[side][fromb][f].bd;
#line 1356
        hashkey ^= (*hashcode)[side][fromb][f].key;
      }
#line 1359
      if ((int )t >= 0) {
#line 1359
        hashbd ^= (*hashcode)[side][tob][t].bd;
#line 1359
        hashkey ^= (*hashcode)[side][tob][t].key;
      }
#line 1360
      mtl[side] = (short )((long )mtl[side] + ((*(value + stage))[tob] - (*(value + stage))[fromb]));
#line 1362
      if ((int )fromb == 1) {
#line 1363
        PawnCnt[side][(int )f % 9] = (signed char )((int )PawnCnt[side][(int )f % 9] - 1);
      }
#line 1365
      HasPiece[side][fromb] = (signed char )((int )HasPiece[side][fromb] - 1);
#line 1366
      HasPiece[side][tob] = (signed char )((int )HasPiece[side][tob] + 1);
#line 1369
      *INCscore___0 = (short )((int )*INCscore___0 - (int )*tempsf___2);
    } else {
#line 1374
      board[t] = (signed char )fromb;
#line 1376
      if ((int )f >= 0) {
#line 1376
        hashbd ^= (*hashcode)[side][fromb][f].bd;
#line 1376
        hashkey ^= (*hashcode)[side][fromb][f].key;
      }
#line 1376
      if ((int )t >= 0) {
#line 1376
        hashbd ^= (*hashcode)[side][fromb][t].bd;
#line 1376
        hashkey ^= (*hashcode)[side][fromb][t].key;
      }
    }
#line 1379
    Mvboard[f] = (signed char )((int )Mvboard[f] + 1);
  }
#line 1391
  return;
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
void UnmakeMove(short side , struct leaf *node___0 , short *tempb___2 , short *tempc___2 ,
                short *tempsf___2 , short *tempst___2 ) 
{ 
  short f ;
  short t ;
  short xside___0 ;
  short tob ;
  short fromb ;
  short n ;
  short upiece ;
  signed char tmp ;

  {
#line 1410
  xside___0 = (short )((int )side ^ 1);
#line 1411
  f = (short )node___0->f;
#line 1412
  t = (short )((int )node___0->t & 127);
#line 1413
  Game50 = (GameList + GameCnt)->Game50;
#line 1415
  if ((int )node___0->flags & 32) {
    {
#line 1417
    drop(side, (short )((int )node___0->flags & 15), f, t, (short)2);
#line 1420
    svalue[t] = *tempst___2;
    }
  } else {
#line 1427
    color[f] = color[t];
#line 1428
    fromb = (short )board[t];
#line 1428
    tob = fromb;
#line 1428
    board[f] = (signed char )tob;
#line 1431
    svalue[f] = *tempsf___2;
#line 1434
    Pindex[f] = Pindex[t];
#line 1435
    PieceList[side][Pindex[f]] = (signed char )f;
#line 1436
    color[t] = (signed char )*tempc___2;
#line 1437
    board[t] = (signed char )*tempb___2;
#line 1440
    svalue[t] = *tempst___2;
#line 1444
    if ((int )node___0->flags & 16) {
#line 1446
      fromb = (short )unpromoted[tob];
#line 1446
      board[f] = (signed char )fromb;
#line 1447
      mtl[side] = (short )((long )mtl[side] + ((*(value + stage))[fromb] - (*(value + stage))[tob]));
#line 1449
      if ((int )fromb == 1) {
#line 1450
        PawnCnt[side][(int )f % 9] = (signed char )((int )PawnCnt[side][(int )f % 9] + 1);
      }
#line 1452
      HasPiece[side][fromb] = (signed char )((int )HasPiece[side][fromb] + 1);
#line 1453
      HasPiece[side][tob] = (signed char )((int )HasPiece[side][tob] - 1);
#line 1456
      if ((int )f >= 0) {
#line 1456
        hashbd ^= (*hashcode)[side][fromb][f].bd;
#line 1456
        hashkey ^= (*hashcode)[side][fromb][f].key;
      }
#line 1459
      if ((int )t >= 0) {
#line 1459
        hashbd ^= (*hashcode)[side][tob][t].bd;
#line 1459
        hashkey ^= (*hashcode)[side][tob][t].key;
      }
    } else {
#line 1463
      if ((int )fromb == 1) {
#line 1465
        PawnCnt[side][(int )t % 9] = (signed char )((int )PawnCnt[side][(int )t % 9] - 1);
#line 1466
        PawnCnt[side][(int )f % 9] = (signed char )((int )PawnCnt[side][(int )f % 9] + 1);
      }
#line 1470
      if ((int )f >= 0) {
#line 1470
        hashbd ^= (*hashcode)[side][fromb][f].bd;
#line 1470
        hashkey ^= (*hashcode)[side][fromb][f].key;
      }
#line 1470
      if ((int )t >= 0) {
#line 1470
        hashbd ^= (*hashcode)[side][fromb][t].bd;
#line 1470
        hashkey ^= (*hashcode)[side][fromb][t].key;
      }
    }
#line 1474
    if ((int )*tempc___2 != 2) {
      {
#line 1476
      upiece = (short )unpromoted[*tempb___2];
#line 1478
      UpdatePieceList(*tempc___2, t, (UpdatePieceList_mode )2);
      }
#line 1480
      if ((int )*tempb___2 == 1) {
#line 1481
        PawnCnt[*tempc___2][(int )t % 9] = (signed char )((int )PawnCnt[*tempc___2][(int )t % 9] + 1);
      }
#line 1483
      mtl[xside___0] = (short )((int )mtl[xside___0] + (int )(*value)[stage][*tempb___2]);
#line 1484
      HasPiece[xside___0][*tempb___2] = (signed char )((int )HasPiece[xside___0][*tempb___2] + 1);
#line 1485
      mtl[side] = (short )((int )mtl[side] - (int )(*value)[stage][upiece]);
#line 1488
      tmp = Captured[side][upiece];
#line 1488
      Captured[side][upiece] = (signed char )((int )Captured[side][upiece] - 1);
#line 1488
      n = (short )tmp;
#line 1490
      hashbd ^= (*drop_hashcode)[side][upiece][n].bd;
#line 1490
      hashkey ^= (*drop_hashcode)[side][upiece][n].key;
#line 1493
      if ((int )t >= 0) {
#line 1493
        hashbd ^= (*hashcode)[xside___0][*tempb___2][t].bd;
#line 1493
        hashkey ^= (*hashcode)[xside___0][*tempb___2][t].key;
      }
#line 1494
      Mvboard[t] = (signed char )((int )Mvboard[t] - 1);
    }
#line 1497
    Mvboard[f] = (signed char )((int )Mvboard[f] - 1);
  }
#line 1500
  GameCnt = (short )((int )GameCnt - 1);
#line 1501
  rpthash[side][hashkey & 255UL] = (short )((int )rpthash[side][hashkey & 255UL] - 1);
#line 1501
  ISZERO = (short )((int )ISZERO - 1);
#line 1512
  return;
}
}
#line 1526 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/search.c"
void InitializeStats(void) 
{ 
  short i___0 ;
  short sq ;
  signed char tmp ;
  short side ;
  short piece ;
  short n ;

  {
#line 1531
  i___0 = (short)0;
  {
#line 1531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1531
    if (! ((int )i___0 < 9)) {
#line 1531
      goto while_break;
    }
#line 1532
    tmp = (signed char)0;
#line 1532
    PawnCnt[1][i___0] = tmp;
#line 1532
    PawnCnt[0][i___0] = tmp;
#line 1531
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1534
  mtl[1] = (short)0;
#line 1534
  mtl[0] = mtl[1];
#line 1535
  PieceCnt[1] = (signed char)0;
#line 1535
  PieceCnt[0] = PieceCnt[1];
#line 1536
  hashkey = 0UL;
#line 1536
  hashbd = hashkey;
#line 1538
  sq = (short)0;
  {
#line 1538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1538
    if (! ((int )sq < 81)) {
#line 1538
      goto while_break___0;
    }
#line 1540
    if ((int )color[sq] != 2) {
#line 1542
      mtl[color[sq]] = (short )((int )mtl[color[sq]] + (int )(*value)[stage][board[sq]]);
#line 1544
      if ((int )board[sq] == 1) {
#line 1545
        PawnCnt[color[sq]][(int )sq % 9] = (signed char )((int )PawnCnt[color[sq]][(int )sq % 9] + 1);
      }
#line 1547
      if ((int )board[sq] == 14) {
#line 1547
        Pindex[sq] = (signed char)0;
      } else {
#line 1547
        PieceCnt[color[sq]] = (signed char )((int )PieceCnt[color[sq]] + 1);
#line 1547
        Pindex[sq] = PieceCnt[color[sq]];
      }
#line 1548
      PieceList[color[sq]][Pindex[sq]] = (signed char )sq;
#line 1549
      if ((int )sq >= 0) {
#line 1549
        hashbd ^= (*hashcode)[color[sq]][board[sq]][sq].bd;
#line 1549
        hashkey ^= (*hashcode)[color[sq]][board[sq]][sq].key;
      }
    }
#line 1553
    if ((int const   )Stcolor[sq] != 2) {
#line 1554
      if ((int )sq >= 0) {
#line 1554
        hashbd ^= (*hashcode)[Stcolor[sq]][Stboard[sq]][sq].bd;
#line 1554
        hashkey ^= (*hashcode)[Stcolor[sq]][Stboard[sq]][sq].key;
      }
    }
#line 1538
    sq = (short )((int )sq + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1560
  side = (short)0;
  {
#line 1560
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1560
    if (! ((int )side <= 1)) {
#line 1560
      goto while_break___1;
    }
#line 1564
    piece = (short)0;
    {
#line 1564
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1564
      if (! ((int )piece < 15)) {
#line 1564
        goto while_break___2;
      }
#line 1566
      n = (short )Captured[side][piece];
#line 1568
      if ((int )n > 0) {
#line 1570
        Captured[side][piece] = (signed char)0;
#line 1572
        i___0 = (short)1;
        {
#line 1572
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1572
          if (! ((int )i___0 <= (int )n)) {
#line 1572
            goto while_break___3;
          }
#line 1574
          Captured[side][piece] = (signed char )((int )Captured[side][piece] + 1);
#line 1575
          hashbd ^= (*drop_hashcode)[side][piece][i___0].bd;
#line 1575
          hashkey ^= (*drop_hashcode)[side][piece][i___0].key;
#line 1576
          mtl[side] = (short )((int )mtl[side] + (int )(*value)[stage][piece]);
#line 1572
          i___0 = (short )((int )i___0 + 1);
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1564
      piece = (short )((int )piece + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1560
    side = (short )((int )side + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1590
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 975 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned int urand(void) ;
#line 978
void gsrand(unsigned int seed___0 ) ;
#line 1109
void TimeCalc(void) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.h"
void PollForInput(void) ;
#line 78
void UpdateClocks(void) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
static unsigned long next  =    1UL;
#line 48 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
unsigned int urand(void) 
{ 


  {
#line 51
  next *= 1103515245UL;
#line 52
  next += 12345UL;
#line 53
  return ((unsigned int )(next >> 16) & 65535U);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
void gsrand(unsigned int seed___0 ) 
{ 


  {
#line 61
  next = (unsigned long )seed___0;
#line 62
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
void TimeCalc(void) 
{ 
  int increment ;
  int topsum ;
  int tcompsum ;
  int me ;
  int him ;
  int i___0 ;

  {
#line 70
  increment = 0;
#line 71
  topsum = 0;
#line 72
  tcompsum = 0;
#line 77
  if ((int )GameCnt < 8) {
#line 78
    return;
  }
#line 81
  i___0 = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i___0 < 4)) {
#line 81
      goto while_break;
    }
#line 83
    tcompsum += timecomp[i___0];
#line 84
    topsum += timeopp[i___0];
#line 81
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  topsum /= 400;
#line 88
  tcompsum /= 400;
#line 91
  me = (int )(TimeControl.clock[computer] / 100L);
#line 92
  him = (int )(TimeControl.clock[opponent] / 100L);
#line 94
  if (me < him) {
#line 95
    increment += 2;
  }
#line 97
  if (him - me > 60) {
#line 98
    increment ++;
  } else
#line 97
  if (me < him) {
#line 97
    if (me < 120) {
#line 98
      increment ++;
    }
  }
#line 103
  if (tcompsum > topsum) {
#line 105
    increment += 2;
  } else
#line 107
  if ((int )TimeControl.moves[computer] < 15) {
#line 107
    if (! increment) {
#line 110
      increment ++;
    } else {
#line 107
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 112
  if (me > him) {
#line 112
    if (tcompsum < topsum) {
#line 115
      increment = -1;
    }
  }
#line 121
  if (TCadd == 0) {
#line 121
    if (increment > 0) {
#line 122
      increment += 2;
    }
  }
#line 124
  if (me == 0) {
#line 124
    if (increment > 0) {
#line 125
      increment += 2;
    }
  }
#line 127
  TimeControl.moves[computer] = (short )((int )TimeControl.moves[computer] + increment);
#line 128
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
void SetResponseTime(short side ) 
{ 
  int DetermineTCcount ;
  short rtf ;
  int tmp ;
  short tcq ;
  int tmp___0 ;
  int AllowedCounts ;

  {
#line 139
  DetermineTCcount = 1;
#line 141
  if (TCflag) {
#line 143
    TCcount = 0;
#line 145
    if ((int )TimeControl.moves[side] < 1) {
#line 146
      TimeControl.moves[side] = (short)1;
    }
#line 149
    if (flag.onemove) {
#line 151
      ResponseTime = TimeControl.clock[side] - 100L;
#line 152
      TCleft = 0L;
    } else {
#line 157
      if (TimeControl.clock[side] <= 0L) {
#line 159
        ResponseTime = 0L;
#line 160
        TCleft = 10L;
      } else {
#line 164
        if (! flag.tsume) {
#line 164
          if ((int )stage < 33) {
#line 164
            tmp = 8;
          } else {
#line 164
            tmp = 2;
          }
        } else {
#line 164
          tmp = 2;
        }
#line 164
        rtf = (short )tmp;
#line 165
        if (! flag.tsume) {
#line 165
          if ((int )stage < 33) {
#line 165
            tmp___0 = 2;
          } else {
#line 165
            tmp___0 = 4;
          }
        } else {
#line 165
          tmp___0 = 4;
        }
#line 165
        tcq = (short )tmp___0;
#line 167
        TimeControl.clock[side] += (long )TCadd;
#line 168
        ResponseTime = TimeControl.clock[side] / (long )((int )TimeControl.moves[side] * (int )rtf + 1);
#line 170
        TCleft = ResponseTime / (long )tcq;
#line 171
        ResponseTime += (long )(TCadd / 2);
      }
#line 174
      if ((int )TimeControl.moves[side] < 5) {
#line 176
        TCcount = 0;
#line 178
        if (TCcount < 0) {
#line 179
          TCcount = 0;
        }
#line 181
        DetermineTCcount = 0;
      }
    }
#line 185
    if (ResponseTime < 100L) {
#line 187
      ResponseTime = 100L;
#line 188
      TCcount = 0;
#line 190
      if (TCcount < 0) {
#line 191
        TCcount = 0;
      }
#line 193
      DetermineTCcount = 0;
    }
#line 196
    if (! hard_time_limit) {
#line 196
      if (ResponseTime < 200L) {
#line 198
        TCcount = 0;
#line 200
        if (TCcount < 0) {
#line 201
          TCcount = 0;
        }
#line 203
        DetermineTCcount = 0;
      }
    }
  } else {
    {
#line 208
    TCleft = 0L;
#line 209
    ResponseTime = MaxResponseTime;
#line 210
    ElapsedTime((ElapsedTime_mode )1);
    }
  }
#line 213
  if (DetermineTCcount) {
#line 215
    if (TCleft) {
#line 217
      AllowedCounts = (int )((long )((int )(TimeControl.clock[side] - ResponseTime) / 2) / TCleft);
#line 221
      if (AllowedCounts <= 0) {
#line 222
        TCcount = 10;
      } else
#line 223
      if (AllowedCounts > 10) {
#line 224
        TCcount = 0;
      } else {
#line 226
        TCcount = 10 - AllowedCounts;
      }
    } else {
#line 230
      TCcount = 10;
    }
  }
#line 234
  if (ResponseTime < 100L) {
#line 235
    ResponseTime = 100L;
  }
#line 299
  if (! (TCcount <= 10)) {
    {
#line 299
    __assert_fail("TCcount <= 10", "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c",
                  299U, "SetResponseTime");
    }
  }
#line 300
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
void CheckForTimeout(int score___0 , int globalscore___0 , int Jscore___0 , int zwndw___0 ) 
{ 
  int tmp ;
  double tmp___0 ;

  {
#line 307
  if (flag.musttimeout) {
#line 308
    flag.timeout = (short)1;
  } else
#line 307
  if ((int )Sdepth >= (int )MaxSearchDepth) {
#line 308
    flag.timeout = (short)1;
  } else
#line 310
  if (TCflag) {
#line 310
    if ((int )Sdepth > 1) {
#line 310
      if (TCcount < 4) {
#line 312
        if ((int )killr0[1] != (int )PrVar[1]) {
#line 314
          TCcount ++;
#line 315
          ExtraTime += TCleft;
        }
#line 318
        if (TCcount < 4) {
          {
#line 318
          tmp = abs(score___0 - globalscore___0);
          }
#line 318
          if (tmp / (int )Sdepth > 10) {
#line 321
            TCcount ++;
#line 322
            ExtraTime += TCleft;
          }
        }
      }
    }
  }
#line 326
  if (score___0 > Jscore___0 - zwndw___0) {
#line 326
    if (score___0 > (int )(Tree + 1)->score + 250) {
#line 327
      ExtraTime = 0L;
    }
  }
  {
#line 329
  ElapsedTime((ElapsedTime_mode )2);
  }
#line 331
  if ((int )root->flags & 64) {
#line 332
    flag.timeout = (short)1;
  } else
#line 341
  if (! ((int )Sdepth < 2)) {
#line 341
    if (TCflag) {
      {
#line 341
      tmp___0 = pow((double )et, (double )1.12446928l);
      }
#line 341
      if ((long )((int )(1.93913099l * (long double )tmp___0)) > ResponseTime + ExtraTime) {
#line 345
        flag.timeout = (short)1;
      }
    }
  }
#line 348
  if (flag.timeout) {
    {
#line 349
    ShowMessage((char *)"timeout");
    }
  }
#line 350
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/tcontrl.c"
void ElapsedTime(ElapsedTime_mode iop ) 
{ 
  long current_time ;
  struct timeval tv ;

  {
  {
#line 369
  PollForInput();
#line 372
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 373
  current_time = tv.tv_sec * 100L + tv.tv_usec / 10000L;
#line 391
  et = current_time - time0;
#line 393
  ETnodes = NodeCnt + znodes;
  }
#line 395
  if (et < 0L) {
#line 400
    et = 0L;
  }
#line 403
  if ((unsigned int )iop == 1U) {
#line 405
    if (et > ResponseTime + ExtraTime) {
#line 405
      if ((int )Sdepth > 2) {
#line 406
        flag.timeout = (short)1;
      }
    }
#line 408
    time0 = current_time;
  }
#line 412
  if (! background) {
    {
#line 414
    UpdateClocks();
    }
  }
#line 416
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 155 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char *binbookfile ;
#line 158
char *bookfile ;
#line 783
signed char const   is_promoted[15] ;
#line 849
unsigned short bookmaxply ;
#line 850
unsigned int bookcount ;
#line 851
unsigned int booksize ;
#line 920
void GetOpenings(void) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.h"
struct gdxadmin B  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
unsigned int booksize  =    8000U;
#line 49 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
unsigned short bookmaxply  =    (unsigned short)40;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
unsigned int bookcount  =    0U;
#line 53 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
char *bookfile  =    (char *)"/usr/local/lib/gnushogi/gnushogi.tbk";
#line 59 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
char *binbookfile  =    (char *)"/usr/local/lib/gnushogi/gnushogi.bbk";
#line 64 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static char bmvstr[3][7]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static ULONG bhashbd  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static ULONG bhashkey  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
void Balgbr(short f , short t , short flag___0 ) 
{ 
  short promoted___0 ;
  short piece ;
  short piece___0 ;

  {
#line 79
  promoted___0 = (short)0;
#line 81
  if (((int )f & 128) != 0) {
#line 83
    f = (short )((int )f & 127);
#line 84
    promoted___0 = (short)1;
  }
#line 87
  if ((int )f > 81) {
#line 90
    piece = (short )((int )f - 81);
#line 92
    if ((int )f > 96) {
#line 93
      piece = (short )((int )piece - 15);
    }
#line 95
    flag___0 = (short )(32 | (int )piece);
  }
#line 98
  if (((int )t & 128) != 0) {
#line 100
    flag___0 = (short )((int )flag___0 | 16);
#line 101
    t = (short )((int )t & 127);
  }
#line 104
  if ((int )f == (int )t) {
#line 104
    if ((int )f != 0) {
#line 110
      bmvstr[2][0] = (char )'\000';
#line 110
      bmvstr[1][0] = bmvstr[2][0];
#line 110
      bmvstr[0][0] = bmvstr[1][0];
    } else
#line 104
    if ((int )t != 0) {
#line 110
      bmvstr[2][0] = (char )'\000';
#line 110
      bmvstr[1][0] = bmvstr[2][0];
#line 110
      bmvstr[0][0] = bmvstr[1][0];
    } else {
#line 104
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 114
  if (((int )flag___0 & 32) != 0) {
    {
#line 117
    piece___0 = (short )((int )flag___0 & 15);
#line 118
    bmvstr[0][0] = (char )*(" PLNSGBRPLNSBRK " + piece___0);
#line 119
    bmvstr[0][1] = (char )'*';
#line 120
    bmvstr[0][2] = (char )*("987654321" + (int )t % 9);
#line 121
    bmvstr[0][3] = (char )*("ihgfedcba" + (int )t / 9);
#line 122
    bmvstr[2][0] = (char )'\000';
#line 122
    bmvstr[0][4] = bmvstr[2][0];
#line 123
    strcpy((char */* __restrict  */)(bmvstr[1]), (char const   */* __restrict  */)(bmvstr[0]));
#line 124
    bmvstr[1][1] = (char )'\'';
    }
  } else
#line 128
  if ((int )f != 0) {
#line 128
    goto _L;
  } else
#line 128
  if ((int )t != 0) {
    _L: /* CIL Label */ 
#line 133
    bmvstr[0][0] = (char )*("987654321" + (int )f % 9);
#line 134
    bmvstr[0][1] = (char )*("ihgfedcba" + (int )f / 9);
#line 135
    bmvstr[0][2] = (char )*("987654321" + (int )t % 9);
#line 136
    bmvstr[0][3] = (char )*("ihgfedcba" + (int )t / 9);
#line 137
    bmvstr[0][4] = (char )'\000';
#line 139
    if (promoted___0) {
      {
#line 141
      bmvstr[2][0] = (char )'+';
#line 141
      bmvstr[1][0] = bmvstr[2][0];
#line 142
      bmvstr[2][1] = (char )*(" PLNSGBRPLNSBRK " + board[f]);
#line 142
      bmvstr[1][1] = bmvstr[2][1];
#line 143
      strcpy((char */* __restrict  */)(& bmvstr[1][2]), (char const   */* __restrict  */)(& bmvstr[0][0]));
#line 144
      strcpy((char */* __restrict  */)(& bmvstr[2][2]), (char const   */* __restrict  */)(& bmvstr[0][2]));
      }
    } else {
      {
#line 148
      bmvstr[2][0] = (char )*(" PLNSGBRPLNSBRK " + board[f]);
#line 148
      bmvstr[1][0] = bmvstr[2][0];
#line 149
      strcpy((char */* __restrict  */)(& bmvstr[1][1]), (char const   */* __restrict  */)(& bmvstr[0][0]));
#line 150
      strcpy((char */* __restrict  */)(& bmvstr[2][1]), (char const   */* __restrict  */)(& bmvstr[0][2]));
      }
    }
#line 153
    if ((int )flag___0 & 16) {
      {
#line 155
      strcat((char */* __restrict  */)(bmvstr[0]), (char const   */* __restrict  */)"+");
#line 156
      strcat((char */* __restrict  */)(bmvstr[1]), (char const   */* __restrict  */)"+");
#line 157
      strcat((char */* __restrict  */)(bmvstr[2]), (char const   */* __restrict  */)"+");
      }
    }
  } else {
#line 162
    bmvstr[2][0] = (char )'\000';
#line 162
    bmvstr[1][0] = bmvstr[2][0];
#line 162
    bmvstr[0][0] = bmvstr[1][0];
  }
#line 166
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short pnt  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
void bkdisplay(char *s , int cnt___1 , int moveno ) 
{ 
  struct leaf *node___0 ;
  int r ;
  int c ;
  int l ;
  char const   *tmp ;
  short tmp___0 ;
  char pc ;
  short color___0 ;
  short piece ;
  short c___0 ;
  char const   *tmp___1 ;

  {
  {
#line 179
  pnt = TrPnt[2];
#line 180
  printf((char const   */* __restrict  */)"matches = %d\n", cnt___1);
  }
#line 181
  if (moveno & 1) {
#line 181
    tmp = "white";
  } else {
#line 181
    tmp = "black";
  }
  {
#line 181
  printf((char const   */* __restrict  */)"inout move is :%s: move number %d side %s\n",
         s, moveno / 2 + 1, tmp);
#line 185
  printf((char const   */* __restrict  */)"legal moves are \n");
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((int )pnt < (int )TrPnt[3])) {
#line 187
      goto while_break;
    }
#line 189
    tmp___0 = pnt;
#line 189
    pnt = (short )((int )pnt + 1);
#line 189
    node___0 = Tree + tmp___0;
#line 191
    if (is_promoted[board[node___0->f]]) {
      {
#line 192
      Balgbr((short )((int )node___0->f | 128), (short )node___0->t, (short )node___0->flags);
      }
    } else {
      {
#line 194
      Balgbr((short )node___0->f, (short )node___0->t, (short )node___0->flags);
      }
    }
    {
#line 196
    printf((char const   */* __restrict  */)"%s %s %s\n", bmvstr[0], bmvstr[1], bmvstr[2]);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  printf((char const   */* __restrict  */)"\n current board is\n");
#line 202
  r = 8;
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! (r >= 0)) {
#line 202
      goto while_break___0;
    }
#line 204
    c = 0;
    {
#line 204
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 204
      if (! (c <= 8)) {
#line 204
        goto while_break___1;
      }
#line 208
      l = r * 9 + c;
#line 209
      if (is_promoted[board[l]]) {
#line 209
        pc = (char )'+';
      } else {
#line 209
        pc = (char )' ';
      }
#line 211
      if ((int )color[l] == 2) {
        {
#line 212
        printf((char const   */* __restrict  */)" -");
        }
      } else
#line 213
      if ((int )color[l] == 0) {
        {
#line 214
        printf((char const   */* __restrict  */)"%c%c", (int )pc, (int const   )*(" plnsgbrplnsbrk " + board[l]));
        }
      } else {
        {
#line 216
        printf((char const   */* __restrict  */)"%c%c", (int )pc, (int const   )*(" PLNSGBRPLNSBRK " + board[l]));
        }
      }
#line 204
      c ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 219
    printf((char const   */* __restrict  */)"\n");
#line 202
    r --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 222
  printf((char const   */* __restrict  */)"\n");
#line 226
  color___0 = (short)0;
  }
  {
#line 226
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 226
    if (! ((int )color___0 <= 1)) {
#line 226
      goto while_break___2;
    }
#line 230
    if ((int )color___0 == 0) {
#line 230
      tmp___1 = "black ";
    } else {
#line 230
      tmp___1 = "white ";
    }
    {
#line 230
    printf((char const   */* __restrict  */)tmp___1);
#line 232
    piece = (short)1;
    }
    {
#line 232
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 232
      if (! ((int )piece <= 14)) {
#line 232
        goto while_break___3;
      }
#line 234
      c___0 = (short )Captured[color___0][piece];
#line 234
      if (c___0) {
        {
#line 235
        printf((char const   */* __restrict  */)"%i%c ", (int )c___0, (int const   )*(" PLNSGBRPLNSBRK " + piece));
        }
      }
#line 232
      piece = (short )((int )piece + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 238
    printf((char const   */* __restrict  */)"\n");
#line 226
    color___0 = (short )((int )color___0 + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short pnt___0  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short tempb___0  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short tempc___0  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short tempsf___0  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short tempst___0  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static short cnt  ;
#line 259 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static struct leaf xnode  ;
#line 255 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
int BVerifyMove(char *s , unsigned short *mv , int moveno ) 
{ 
  struct leaf *node___0 ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  short blockable ;
  int tmp___3 ;

  {
  {
#line 262
  *mv = (unsigned short)0;
#line 263
  cnt = (short)0;
#line 264
  MoveList(opponent, (short)2, (short)-2, (short)1);
#line 265
  pnt___0 = TrPnt[2];
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((int )pnt___0 < (int )TrPnt[3])) {
#line 267
      goto while_break;
    }
#line 269
    tmp = pnt___0;
#line 269
    pnt___0 = (short )((int )pnt___0 + 1);
#line 269
    node___0 = Tree + tmp;
#line 271
    if (is_promoted[board[node___0->f]]) {
      {
#line 272
      Balgbr((short )((int )node___0->f | 128), (short )node___0->t, (short )node___0->flags);
      }
    } else {
      {
#line 274
      Balgbr((short )node___0->f, (short )node___0->t, (short )node___0->flags);
      }
    }
    {
#line 276
    tmp___0 = strcmp((char const   *)s, (char const   *)(bmvstr[0]));
    }
#line 276
    if (tmp___0 == 0) {
#line 279
      cnt = (short )((int )cnt + 1);
#line 280
      xnode = *node___0;
    } else {
      {
#line 276
      tmp___1 = strcmp((char const   *)s, (char const   *)(bmvstr[1]));
      }
#line 276
      if (tmp___1 == 0) {
#line 279
        cnt = (short )((int )cnt + 1);
#line 280
        xnode = *node___0;
      } else {
        {
#line 276
        tmp___2 = strcmp((char const   *)s, (char const   *)(bmvstr[2]));
        }
#line 276
        if (tmp___2 == 0) {
#line 279
          cnt = (short )((int )cnt + 1);
#line 280
          xnode = *node___0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if ((int )cnt == 1) {
    {
#line 288
    MakeMove(opponent, & xnode, & tempb___0, & tempc___0, & tempsf___0, & tempst___0,
             & INCscore);
#line 291
    tmp___3 = SqAttacked((short )PieceList[opponent][0], computer, & blockable);
    }
#line 291
    if (tmp___3) {
      {
#line 293
      UnmakeMove(opponent, & xnode, & tempb___0, & tempc___0, & tempsf___0, & tempst___0);
#line 296
      puts("Illegal move (in check) %s");
#line 297
      bkdisplay(s, (int )cnt, moveno);
      }
#line 299
      return (0);
    } else {
#line 303
      *mv = (unsigned short )(((int )xnode.f << 8) | (int )xnode.t);
#line 305
      if (is_promoted[board[xnode.t]]) {
        {
#line 306
        Balgbr((short )((int )xnode.f | 128), (short )xnode.t, (short)0);
        }
      } else {
        {
#line 308
        Balgbr((short )xnode.f, (short )xnode.t, (short)0);
        }
      }
#line 310
      return (1);
    }
  }
  {
#line 316
  printf((char const   */* __restrict  */)"Illegal move (no match) %s\n", s);
#line 317
  bkdisplay(s, (int )cnt, moveno);
  }
#line 319
  return (0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
void RESET(void) 
{ 
  short l ;

  {
#line 337
  flag.force = (short)0;
#line 337
  flag.onemove = flag.force;
#line 337
  flag.bothsides = flag.onemove;
#line 337
  flag.reverse = flag.bothsides;
#line 337
  flag.quit = flag.reverse;
#line 337
  flag.post = flag.quit;
#line 337
  flag.mate = flag.post;
#line 337
  flag.illegal = flag.mate;
#line 341
  flag.rcptr = (short)1;
#line 341
  flag.beep = flag.rcptr;
#line 341
  flag.easy = flag.beep;
#line 341
  flag.hash = flag.easy;
#line 341
  flag.coords = flag.hash;
#line 341
  flag.material = flag.coords;
#line 345
  flag.musttimeout = (short)0;
#line 345
  flag.back = flag.musttimeout;
#line 345
  flag.shade = flag.back;
#line 345
  flag.stars = flag.shade;
#line 346
  flag.gamein = (short)0;
#line 347
  GenCnt = 0L;
#line 348
  GameCnt = (short)0;
#line 349
  TesujiFlag[0] = (signed char)0;
#line 349
  CptrFlag[0] = TesujiFlag[0];
#line 350
  opponent = (short)0;
#line 351
  computer = (short)1;
#line 353
  l = (short)0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! ((int )l < 81)) {
#line 353
      goto while_break;
    }
#line 355
    board[l] = (signed char )Stboard[l];
#line 356
    color[l] = (signed char )Stcolor[l];
#line 357
    Mvboard[l] = (signed char)0;
#line 353
    l = (short )((int )l + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  memset((void *)((char *)(Captured)), 0, sizeof(Captured));
#line 361
  InitializeStats();
#line 362
  hashkey = 0UL;
#line 362
  hashbd = hashkey;
  }
#line 363
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static int Vparse(FILE *fd , USHORT *mv , USHORT *flags , USHORT side , int moveno ) 
{ 
  int c ;
  int i___0 ;
  char s[255] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 374
  *flags = (USHORT )0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 378
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 378
      c = _IO_getc(fd);
      }
#line 378
      if (! (c == 32)) {
#line 378
        if (! (c == 33)) {
#line 378
          if (! (c == 47)) {
#line 378
            if (! (c == 10)) {
#line 378
              goto while_break___0;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 381
    if (c == 40) {
      {
#line 384
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 384
        c = _IO_getc(fd);
        }
#line 384
        if (c != 41) {
#line 384
          if (! (c != -1)) {
#line 384
            goto while_break___1;
          }
        } else {
#line 384
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 386
      if (c == 41) {
        {
#line 388
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 388
          c = _IO_getc(fd);
          }
#line 388
          if (! (c == 32)) {
#line 388
            if (! (c == 10)) {
#line 388
              goto while_break___2;
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 392
    if (c == 91) {
      {
#line 395
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 395
        c = _IO_getc(fd);
        }
#line 395
        if (c != 93) {
#line 395
          if (! (c != -1)) {
#line 395
            goto while_break___3;
          }
        } else {
#line 395
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 397
      if (c == 93) {
        {
#line 399
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 399
          c = _IO_getc(fd);
          }
#line 399
          if (! (c == 32)) {
#line 399
            if (! (c == 10)) {
#line 399
              goto while_break___4;
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 403
    if (c == 13) {
#line 404
      goto while_continue;
    }
#line 406
    if (c == 35) {
      {
#line 409
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 411
        c = _IO_getc(fd);
        }
#line 413
        if (c == 13) {
#line 414
          goto __Cont;
        }
#line 417
        if (c == 10) {
#line 418
          return (0);
        }
#line 420
        if (c == -1) {
#line 421
          return (-1);
        }
        __Cont: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 426
    i___0 = 0;
#line 426
    s[i___0] = (char )c;
    {
#line 428
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 428
      if (c >= 48) {
#line 428
        if (! (c <= 57)) {
#line 428
          goto while_break___6;
        }
      } else {
#line 428
        goto while_break___6;
      }
      {
#line 430
      c = _IO_getc(fd);
#line 431
      i___0 ++;
#line 431
      s[i___0] = (char )c;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 434
    if (c == 46) {
      {
#line 436
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 436
        c = _IO_getc(fd);
        }
#line 436
        if (! (c == 32)) {
#line 436
          if (! (c == 46)) {
#line 436
            if (! (c == 10)) {
#line 436
              goto while_break___7;
            }
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 437
      i___0 = 0;
#line 437
      s[i___0] = (char )c;
    }
    {
#line 440
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 440
      c = _IO_getc(fd);
      }
#line 440
      if (c != 63) {
#line 440
        if (c != 33) {
#line 440
          if (c != 32) {
#line 440
            if (c != 40) {
#line 440
              if (c != 10) {
#line 440
                if (c != 9) {
#line 440
                  if (! (c != -1)) {
#line 440
                    goto while_break___8;
                  }
                } else {
#line 440
                  goto while_break___8;
                }
              } else {
#line 440
                goto while_break___8;
              }
            } else {
#line 440
              goto while_break___8;
            }
          } else {
#line 440
            goto while_break___8;
          }
        } else {
#line 440
          goto while_break___8;
        }
      } else {
#line 440
        goto while_break___8;
      }
#line 443
      if (c == 13) {
#line 444
        goto while_continue___8;
      }
#line 446
      if (c != 120) {
#line 446
        if (c != 45) {
#line 446
          if (c != 44) {
#line 446
            if (c != 59) {
#line 446
              if (c != 61) {
#line 449
                i___0 ++;
#line 449
                s[i___0] = (char )c;
              }
            }
          }
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 453
    i___0 ++;
#line 453
    s[i___0] = (char )'\000';
#line 455
    if (c == 40) {
      {
#line 457
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 457
        c = _IO_getc(fd);
        }
#line 457
        if (c != 41) {
#line 457
          if (! (c != -1)) {
#line 457
            goto while_break___9;
          }
        } else {
#line 457
          goto while_break___9;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 459
      if (c == 41) {
        {
#line 460
        c = _IO_getc(fd);
        }
      }
    }
#line 463
    if (c == -1) {
#line 464
      return (-1);
    }
#line 466
    if ((int )s[0] == 35) {
      {
#line 468
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 468
        if (c != 10) {
#line 468
          if (! (c != -1)) {
#line 468
            goto while_break___10;
          }
        } else {
#line 468
          goto while_break___10;
        }
        {
#line 469
        c = _IO_getc(fd);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 471
      if (c == -1) {
#line 472
        return (-1);
      } else {
#line 474
        return (0);
      }
    }
    {
#line 477
    tmp___7 = strcmp((char const   *)(s), "draw");
    }
#line 477
    if (tmp___7 == 0) {
#line 478
      goto while_continue;
    } else {
      {
#line 479
      tmp___6 = strcmp((char const   *)(s), "1-0");
      }
#line 479
      if (tmp___6 == 0) {
#line 480
        goto while_continue;
      } else {
        {
#line 481
        tmp___5 = strcmp((char const   *)(s), "0-1");
        }
#line 481
        if (tmp___5 == 0) {
#line 482
          goto while_continue;
        } else {
          {
#line 483
          tmp___4 = strcmp((char const   *)(s), "Resigns");
          }
#line 483
          if (tmp___4 == 0) {
#line 484
            goto while_continue;
          } else {
            {
#line 485
            tmp___3 = strcmp((char const   *)(s), "Resigns.");
            }
#line 485
            if (tmp___3 == 0) {
#line 486
              goto while_continue;
            } else {
              {
#line 487
              tmp___2 = strcmp((char const   *)(s), "Sennichite");
              }
#line 487
              if (tmp___2 == 0) {
#line 488
                goto while_continue;
              } else {
                {
#line 489
                tmp___1 = strcmp((char const   *)(s), "Sennichite.");
                }
#line 489
                if (tmp___1 == 0) {
#line 490
                  goto while_continue;
                } else {
                  {
#line 491
                  tmp___0 = strcmp((char const   *)(s), "Jishogi");
                  }
#line 491
                  if (tmp___0 == 0) {
#line 492
                    goto while_continue;
                  } else {
                    {
#line 493
                    tmp = strcmp((char const   *)(s), "Jishogi.");
                    }
#line 493
                    if (tmp == 0) {
#line 494
                      goto while_continue;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 496
    bhashkey = hashkey;
#line 497
    bhashbd = hashbd;
#line 499
    i___0 = BVerifyMove(s, mv, moveno);
    }
#line 501
    if (c == 63) {
#line 504
      *flags = (USHORT )((int )*flags | 256);
      {
#line 505
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 505
        c = _IO_getc(fd);
        }
#line 505
        if (! (c == 63)) {
#line 505
          if (! (c == 33)) {
#line 505
            if (! (c == 47)) {
#line 505
              goto while_break___11;
            }
          }
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else
#line 516
    if (c == 33) {
#line 519
      *flags = (USHORT )((int )*flags | 4096);
      {
#line 521
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 521
        c = _IO_getc(fd);
        }
#line 521
        if (! (c == 63)) {
#line 521
          if (! (c == 33)) {
#line 521
            if (! (c == 47)) {
#line 521
              goto while_break___12;
            }
          }
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 523
    if (c == 13) {
      {
#line 525
      c = _IO_getc(fd);
      }
    }
#line 528
    if (c == 40) {
      {
#line 529
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 529
        c = _IO_getc(fd);
        }
#line 529
        if (c != 41) {
#line 529
          if (! (c != -1)) {
#line 529
            goto while_break___13;
          }
        } else {
#line 529
          goto while_break___13;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 531
    if (! i___0) {
      {
#line 534
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 534
        c = _IO_getc(fd);
        }
#line 534
        if (c != 35) {
#line 534
          if (! (c != -1)) {
#line 534
            goto while_break___14;
          }
        } else {
#line 534
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 536
      if (c == -1) {
#line 538
        return (-1);
      } else {
        {
#line 542
        ungetc(c, fd);
        }
#line 543
        return (i___0);
      }
    }
#line 547
    return (i___0);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static struct gdxadmin ADMIN  ;
#line 554 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static struct gdxdata DATA  ;
#line 579 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static int gfd  ;
#line 580 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static ULONG currentoffset  ;
#line 616 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static int ReadAdmin(void) 
{ 
  ssize_t tmp ;

  {
  {
#line 618
  lseek(gfd, (__off_t )0, 0);
#line 619
  tmp = read(gfd, (void *)((char *)(& ADMIN)), sizeof(struct gdxadmin ));
  }
#line 619
  return (sizeof(struct gdxadmin ) == (unsigned long )tmp);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
static int ReadData(struct gdxdata *DATA___0 ) 
{ 
  ssize_t tmp ;

  {
  {
#line 624
  lseek(gfd, (__off_t )currentoffset, 0);
#line 625
  tmp = read(gfd, (void *)((char *)DATA___0), sizeof(struct gdxdata ));
  }
#line 625
  return (sizeof(struct gdxdata ) == (unsigned long )tmp);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
void GetOpenings(void) 
{ 
  short i___0 ;
  int mustwrite ;
  int first ;
  unsigned short xside___0 ;
  unsigned short side ;
  short c ;
  USHORT mv ;
  USHORT flags ;
  unsigned int x ;
  unsigned int games ;
  LONG collisions ;
  char msg[80] ;
  FILE *fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 649
  mustwrite = 0;
#line 654
  games = 0U;
#line 655
  collisions = (LONG )0;
#line 660
  fd = fopen((char const   */* __restrict  */)bookfile, (char const   */* __restrict  */)"r");
  }
#line 660
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 661
    fd = fopen((char const   */* __restrict  */)"gnushogi.tbk", (char const   */* __restrict  */)"r");
    }
  }
#line 663
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 667
    gfd = open((char const   *)binbookfile, 0);
    }
#line 669
    if (gfd >= 0) {
      {
#line 671
      tmp = ReadAdmin();
      }
#line 671
      if (tmp) {
#line 673
        B.bookcount = ADMIN.bookcount;
#line 674
        B.booksize = ADMIN.booksize;
#line 675
        B.maxoffset = ADMIN.maxoffset;
#line 677
        if (B.booksize) {
#line 677
          if (! (B.maxoffset == (B.booksize - 1UL) * sizeof(struct gdxdata ) + sizeof(struct gdxadmin ))) {
            {
#line 679
            printf((char const   */* __restrict  */)"bad format %s\n", binbookfile);
#line 680
            exit(1);
            }
          }
        }
      } else {
        {
#line 685
        printf((char const   */* __restrict  */)"bad format %s\n", binbookfile);
#line 686
        exit(1);
        }
      }
      {
#line 688
      close(gfd);
#line 689
      gfd = open((char const   *)binbookfile, 2);
      }
    } else {
      {
#line 694
      gfd = open((char const   *)binbookfile, 66, 420);
#line 696
      B.bookcount = (ULONG )0;
#line 696
      ADMIN.bookcount = B.bookcount;
#line 697
      B.booksize = (ULONG )booksize;
#line 697
      ADMIN.booksize = B.booksize;
#line 698
      ADMIN.maxoffset = (B.booksize - 1UL) * sizeof(struct gdxdata ) + sizeof(struct gdxadmin );
#line 698
      B.maxoffset = ADMIN.maxoffset;
#line 699
      DATA.hashbd = (ULONG )0;
#line 700
      DATA.hashkey = (USHORT )0;
#line 701
      DATA.bmove = (USHORT )0;
#line 702
      DATA.flags = (USHORT )0;
#line 703
      DATA.hint = (USHORT )0;
#line 704
      DATA.count = (USHORT )0;
#line 705
      write(gfd, (void const   *)((char *)(& ADMIN)), sizeof(struct gdxadmin ));
#line 706
      printf((char const   */* __restrict  */)"creating bookfile %s %ld %ld\n", binbookfile,
             B.maxoffset, B.booksize);
#line 709
      x = 0U;
      }
      {
#line 709
      while (1) {
        while_continue: /* CIL Label */ ;
#line 709
        if (! ((ULONG )x < B.booksize)) {
#line 709
          goto while_break;
        }
        {
#line 711
        write(gfd, (void const   *)((char *)(& DATA)), sizeof(struct gdxdata ));
#line 709
        x ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 715
    if (gfd >= 0) {
#line 718
      side = (unsigned short)0;
#line 719
      xside___0 = (unsigned short)1;
#line 720
      hashkey = 0UL;
#line 720
      hashbd = hashkey;
#line 721
      i___0 = (short)0;
      {
#line 723
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 723
        tmp___1 = Vparse(fd, & mv, & flags, side, (int )i___0);
#line 723
        c = (short )tmp___1;
        }
#line 723
        if (! ((int )c >= 0)) {
#line 723
          goto while_break___0;
        }
#line 725
        if ((int )c == 1) {
#line 732
          i___0 = (short )((int )i___0 + 1);
#line 734
          if ((int )i___0 < (int )bookmaxply + 2) {
#line 736
            if ((int )i___0 > 1) {
#line 736
              if (! ((int )flags & 256)) {
#line 737
                DATA.hint = mv;
              }
            }
#line 739
            if ((int )i___0 < (int )bookmaxply + 1) {
#line 746
              if (mustwrite) {
                {
#line 746
                lseek(gfd, (__off_t )currentoffset, 0);
#line 746
                write(gfd, (void const   *)((char *)(& DATA)), sizeof(struct gdxdata ));
#line 746
                mustwrite = 0;
                }
              }
#line 747
              currentoffset = (bhashkey % B.booksize) * sizeof(struct gdxdata ) + sizeof(struct gdxadmin );
#line 748
              first = 1;
              {
#line 750
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
#line 752
                tmp___0 = ReadData(& DATA);
                }
#line 752
                if (! tmp___0) {
#line 753
                  goto while_break___1;
                }
#line 755
                if ((int )DATA.bmove == 0) {
#line 756
                  goto while_break___1;
                }
#line 758
                if ((int )DATA.hashkey == (int )((USHORT )(bhashkey & 65535UL))) {
#line 758
                  if (DATA.hashbd == bhashbd) {
#line 761
                    if ((int )DATA.bmove == (int )mv) {
#line 770
                      DATA.count = (USHORT )((int )DATA.count + 1);
#line 771
                      DATA.flags = (USHORT )((int )DATA.flags | (int )flags);
#line 772
                      mustwrite = 1;
#line 773
                      goto while_break___1;
                    } else {
#line 777
                      if (first) {
#line 778
                        collisions ++;
                      }
#line 780
                      if ((int )DATA.flags & 16) {
#line 782
                        DATA.flags = (USHORT )((int )DATA.flags & -17);
#line 783
                        mustwrite = 1;
#line 784
                        if (mustwrite) {
                          {
#line 784
                          lseek(gfd, (__off_t )currentoffset, 0);
#line 784
                          write(gfd, (void const   *)((char *)(& DATA)), sizeof(struct gdxdata ));
#line 784
                          mustwrite = 0;
                          }
                        }
                      }
                    }
                  }
                }
#line 789
                currentoffset += sizeof(struct gdxdata );
#line 789
                if (currentoffset > B.maxoffset) {
#line 789
                  currentoffset = sizeof(struct gdxadmin );
                }
#line 790
                first = 0;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 797
              if (! mustwrite) {
#line 799
                (B.bookcount) ++;
#line 801
                if (B.bookcount % 1000UL == 0UL) {
                  {
#line 805
                  printf((char const   */* __restrict  */)"%ld rec %d openings processed\n",
                         B.bookcount, games);
                  }
                }
#line 811
                DATA.hashbd = bhashbd;
#line 812
                DATA.hashkey = (USHORT )(bhashkey & 65535UL);
#line 813
                DATA.bmove = mv;
#line 814
                DATA.flags = (USHORT )((int )flags | 16);
#line 815
                DATA.count = (USHORT )1;
#line 816
                DATA.hint = (USHORT )0;
#line 817
                mustwrite = 1;
              }
            }
          }
#line 822
          computer = opponent;
#line 823
          opponent = (short )((int )computer ^ 1);
#line 825
          xside___0 = side;
#line 826
          side = (unsigned short )((int )side ^ 1);
        } else
#line 828
        if ((int )i___0 > 0) {
#line 831
          games ++;
#line 832
          if (mustwrite) {
            {
#line 832
            lseek(gfd, (__off_t )currentoffset, 0);
#line 832
            write(gfd, (void const   *)((char *)(& DATA)), sizeof(struct gdxdata ));
#line 832
            mustwrite = 0;
            }
          }
          {
#line 833
          RESET();
#line 834
          i___0 = (short)0;
#line 835
          side = (unsigned short)0;
#line 836
          xside___0 = (unsigned short)1;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 841
      if (mustwrite) {
        {
#line 841
        lseek(gfd, (__off_t )currentoffset, 0);
#line 841
        write(gfd, (void const   *)((char *)(& DATA)), sizeof(struct gdxdata ));
#line 841
        mustwrite = 0;
        }
      }
      {
#line 842
      fclose(fd);
#line 844
      ADMIN.bookcount = B.bookcount;
#line 845
      lseek(gfd, (__off_t )0, 0);
#line 845
      write(gfd, (void const   *)((char *)(& ADMIN)), sizeof(struct gdxadmin ));
#line 847
      close(gfd);
      }
    }
  }
#line 851
  if ((unsigned long )binbookfile != (unsigned long )((void *)0)) {
    {
#line 854
    gfd = open((char const   *)binbookfile, 0);
    }
#line 856
    if (gfd >= 0) {
      {
#line 858
      tmp___2 = ReadAdmin();
      }
#line 858
      if (tmp___2) {
#line 858
        if (! ADMIN.booksize) {
#line 861
          B.bookcount = ADMIN.bookcount;
#line 862
          B.booksize = ADMIN.booksize;
#line 863
          B.maxoffset = ADMIN.maxoffset;
        } else
#line 858
        if (ADMIN.maxoffset == (ADMIN.booksize - 1UL) * sizeof(struct gdxdata ) + sizeof(struct gdxadmin )) {
#line 861
          B.bookcount = ADMIN.bookcount;
#line 862
          B.booksize = ADMIN.booksize;
#line 863
          B.maxoffset = ADMIN.maxoffset;
        } else {
          {
#line 867
          printf((char const   */* __restrict  */)"bad format %s\n", binbookfile);
#line 868
          exit(1);
          }
        }
      } else {
        {
#line 867
        printf((char const   */* __restrict  */)"bad format %s\n", binbookfile);
#line 868
        exit(1);
        }
      }
    } else {
#line 874
      B.bookcount = (ULONG )0;
#line 875
      B.booksize = (ULONG )booksize;
    }
    {
#line 879
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Book used %d(%d).",
            B.bookcount, B.booksize);
#line 880
    ShowMessage(msg);
    }
  }
  {
#line 884
  Book = 20;
#line 885
  RESET();
  }
#line 888
  if (! B.bookcount) {
    {
#line 890
    ShowMessage((char *)"Can\'t find book.");
#line 891
    Book = 0;
    }
  }
#line 893
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/book.c"
int OpeningBook(unsigned short *hint___0 , short side ) 
{ 
  unsigned short r ;
  unsigned short m ;
  int possibles ;
  time_t tmp ;
  USHORT i___0 ;
  USHORT x ;
  USHORT rec ;
  USHORT summ ;
  USHORT h ;
  USHORT b ;
  struct gdxdata OBB[128] ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 913
  possibles = (int )TrPnt[2] - (int )TrPnt[1];
#line 915
  tmp = time((long *)0);
#line 915
  gsrand((unsigned int )tmp);
#line 916
  m = (unsigned short)0;
#line 925
  rec = (USHORT )0;
#line 926
  summ = (USHORT )0;
#line 927
  h = (USHORT )0;
#line 927
  b = (USHORT )0;
  }
#line 930
  if (B.bookcount == 0UL) {
#line 932
    Book --;
#line 933
    return (0);
  }
#line 936
  x = (USHORT )0;
#line 937
  currentoffset = (hashkey % B.booksize) * sizeof(struct gdxdata ) + sizeof(struct gdxadmin );
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 944
    tmp___0 = ReadData(& OBB[x]);
    }
#line 944
    if (! tmp___0) {
#line 945
      goto while_break;
    }
#line 947
    if ((int )OBB[x].bmove == 0) {
#line 948
      goto while_break;
    }
#line 954
    if ((int )OBB[x].hashkey == (int )((USHORT )(hashkey & 65535UL))) {
#line 954
      if (OBB[x].hashbd == hashbd) {
#line 957
        x = (USHORT )((int )x + 1);
#line 959
        if ((int )OBB[(int )x - 1].flags & 16) {
#line 960
          goto while_break;
        }
      }
    }
#line 963
    currentoffset += sizeof(struct gdxdata );
#line 963
    if (currentoffset > B.maxoffset) {
#line 963
      currentoffset = sizeof(struct gdxadmin );
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  if ((int )x == 0) {
#line 972
    Book --;
#line 973
    return (0);
  }
#line 976
  i___0 = (USHORT )0;
  {
#line 976
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 976
    if (! ((int )i___0 < (int )x)) {
#line 976
      goto while_break___0;
    }
#line 978
    if ((int )OBB[i___0].flags & 256) {
#line 980
      m = OBB[i___0].bmove;
#line 983
      b = (USHORT )TrPnt[1];
      {
#line 983
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 983
        if (! ((unsigned int )b < (unsigned int )TrPnt[2])) {
#line 983
          goto while_break___1;
        }
#line 985
        if ((((int )(Tree + b)->f << 8) | (int )(Tree + b)->t) == (int )m) {
#line 987
          possibles --;
#line 987
          if (possibles) {
#line 988
            (Tree + b)->score = (short)-32760;
          }
#line 989
          goto while_break___1;
        }
#line 983
        b = (USHORT )((int )b + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1000
      summ = (USHORT )((int )summ + (int )OBB[i___0].count);
    }
#line 976
    i___0 = (USHORT )((int )i___0 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  if ((int )summ == 0) {
#line 1006
    Book --;
#line 1007
    return (0);
  }
  {
#line 1010
  tmp___1 = urand();
#line 1010
  r = (unsigned short )(tmp___1 % (unsigned int )summ);
#line 1012
  i___0 = (USHORT )0;
  }
  {
#line 1012
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1012
    if (! ((int )i___0 < (int )x)) {
#line 1012
      goto while_break___2;
    }
#line 1014
    if (! ((int )OBB[i___0].flags & 256)) {
#line 1016
      if ((int )r < (int )OBB[i___0].count) {
#line 1018
        rec = i___0;
#line 1019
        goto while_break___2;
      } else {
#line 1023
        r = (unsigned short )((int )r - (int )OBB[i___0].count);
      }
    }
#line 1012
    i___0 = (USHORT )((int )i___0 + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1028
  h = OBB[rec].hint;
#line 1029
  m = OBB[rec].bmove;
#line 1032
  b = (USHORT )TrPnt[1];
  {
#line 1032
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1032
    if (! ((unsigned int )b < (unsigned int )TrPnt[2])) {
#line 1032
      goto while_break___3;
    }
#line 1034
    if ((((int )(Tree + b)->f << 8) | (int )(Tree + b)->t) == (int )m) {
#line 1036
      (Tree + b)->flags = (unsigned short )((int )(Tree + b)->flags | 16384);
#line 1037
      (Tree + b)->score = (short)0;
#line 1038
      goto while_break___3;
    }
#line 1032
    b = (USHORT )((int )b + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1044
  pick(TrPnt[1], (short )((int )TrPnt[2] - 1));
  }
#line 1046
  if ((Tree + TrPnt[1])->score) {
#line 1049
    Book --;
#line 1050
    return (0);
  }
#line 1054
  *hint___0 = h;
#line 1055
  return (1);
#line 1058
  Book --;
#line 1059
  return (0);
}
}
#line 107 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 538
extern int getchar(void) ;
#line 580
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 709
extern int nocbreak(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 735
extern int scanw(char const   *  , ...) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 69 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short nolist ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 685 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char mvstr[4][6] ;
#line 686 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned short MV[40]  ;
#line 687 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int MSCORE  ;
#line 688 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int mycnt1  ;
#line 688 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int mycnt2  ;
#line 719
short pscore[2] ;
#line 846
char GameType[2] ;
#line 973
void ZeroRPT(void) ;
#line 1056
void SetTimeControl(void) ;
#line 1087
void ListGame(void) ;
#line 1105
void ShowNodeCnt(long NodeCnt___0 ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.h"
void Curses_ChangeAlphaWindow(void) ;
#line 43
void Curses_ChangeBetaWindow(void) ;
#line 44
void Curses_ChangeHashDepth(void) ;
#line 45
void Curses_ChangeSearchDepth(void) ;
#line 46
void Curses_ChangeXwindow(void) ;
#line 47
void Curses_ClearScreen(void) ;
#line 48
void Curses_Die(int sig ) ;
#line 49
void Curses_DoDebug(void) ;
#line 50
void Curses_DoTable(short *table ) ;
#line 51
void Curses_EditBoard(void) ;
#line 52
void Curses_ExitShogi(void) ;
#line 53
void Curses_GiveHint(void) ;
#line 54
void Curses_Initialize(void) ;
#line 55
void Curses_ShowNodeCnt(long NodeCnt___0 ) ;
#line 56
void Curses_OutputMove(void) ;
#line 57
void Curses_PollForInput(void) ;
#line 58
void Curses_SearchStartStuff(short side ) ;
#line 59
void Curses_SelectLevel(char *sx ) ;
#line 60
void Curses_SetContempt(void) ;
#line 61
void Curses_ShowCurrentMove(short pnt___2 , short f , short t ) ;
#line 62
void Curses_ShowDepth(char ch ) ;
#line 63
void Curses_ShowGameType(void) ;
#line 64
void Curses_ShowLine(unsigned short *bstline ) ;
#line 65
void Curses_ShowMessage(char *s ) ;
#line 66
void Curses_AlwaysShowMessage(char const   *format , va_list ap ) ;
#line 67
void Curses_Printf(char const   *format , va_list ap ) ;
#line 68
void Curses_doRequestInputString(char const   *fmt___0 , char *buffer___1 ) ;
#line 69
int Curses_GetString(char *sx ) ;
#line 70
void Curses_SetupBoard(void) ;
#line 71
void Curses_ShowPatternCount(short side , short n ) ;
#line 72
void Curses_ShowPostnValue(short sq ) ;
#line 73
void Curses_ShowPostnValues(void) ;
#line 74
void Curses_ShowPrompt(void) ;
#line 75
void Curses_ShowResponseTime(void) ;
#line 76
void Curses_ShowResults(short score___0 , unsigned short *bstline , char ch ) ;
#line 77
void Curses_ShowSidetoMove(void) ;
#line 78
void Curses_ShowStage(void) ;
#line 79
void Curses_TerminateSearch(int sig ) ;
#line 80
void Curses_UpdateClocks(void) ;
#line 81
void Curses_UpdateDisplay(short f , short t , short redraw , short isspec ) ;
#line 82
void Curses_help(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void UpdateCatched(void) ;
#line 80
static void DrawPiece(short sq ) ;
#line 81
static void ShowScore(short score___0 ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void ClearEoln(void) 
{ 


  {
  {
#line 90
  wclrtoeol(stdscr);
#line 91
  wrefresh(stdscr);
  }
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ClearScreen(void) 
{ 


  {
  {
#line 98
  wclear(stdscr);
#line 99
  wrefresh(stdscr);
  }
#line 100
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void gotoXY(short x , short y ) 
{ 


  {
  {
#line 106
  wmove(stdscr, (int )y - 1, (int )x - 1);
  }
#line 107
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowCurrentMove(short pnt___2 , short f , short t ) 
{ 


  {
  {
#line 121
  algbr(f, t, (short)0);
#line 122
  gotoXY((short)58, (short)7);
#line 123
  printw("(%2d) %5s ", (int )pnt___2, mvstr[0]);
  }
#line 124
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowDepth(char ch ) 
{ 


  {
  {
#line 130
  gotoXY((short)58, (short)4);
#line 131
  printw("Depth= %d%c ", (int )Sdepth, (int )ch);
#line 132
  ClearEoln();
  }
#line 133
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowGameType(void) 
{ 


  {
#line 139
  if (flag.post) {
    {
#line 141
    gotoXY((short)58, (short)20);
#line 142
    printw("%c vs. %c", (int )GameType[0], (int )GameType[1]);
    }
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void ShowHeader(void) 
{ 


  {
  {
#line 150
  gotoXY((short)58, (short)2);
#line 151
  printw("GNU Shogi %s", "1.4.1");
  }
#line 152
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowLine(unsigned short *bstline ) 
{ 


  {
#line 158
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowMessage(char *s ) 
{ 


  {
  {
#line 164
  gotoXY((short)58, (short)6);
#line 165
  printw("%s", s);
#line 166
  ClearEoln();
  }
#line 167
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static char buffer[60]  ;
#line 170 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_AlwaysShowMessage(char const   *format , va_list ap ) 
{ 


  {
  {
#line 174
  vsnprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)format,
            ap);
#line 175
  Curses_ShowMessage(buffer);
  }
#line 176
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static char buffer___0[60]  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_Printf(char const   *format , va_list ap ) 
{ 


  {
  {
#line 183
  vsnprintf((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)format,
            ap);
#line 184
  printw("%s", buffer___0);
  }
#line 185
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_doRequestInputString(char const   *fmt___0 , char *buffer___1 ) 
{ 


  {
  {
#line 191
  fflush(stdout);
#line 191
  scanw(fmt___0, buffer___1);
  }
#line 192
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
int Curses_GetString(char *sx ) 
{ 
  int tmp ;

  {
  {
#line 198
  fflush(stdout);
#line 199
  tmp = wgetnstr(stdscr, sx, -1);
  }
#line 199
  return (tmp == -1);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowNodeCnt(long NodeCnt___0 ) 
{ 
  long tmp ;

  {
  {
#line 206
  gotoXY((short)58, (short)22);
  }
#line 208
  if (et > 100L) {
#line 208
    tmp = NodeCnt___0 / (et / 100L);
  } else {
#line 208
    tmp = 0L;
  }
  {
#line 208
  printw("n = %ld n/s = %ld", NodeCnt___0, tmp);
#line 210
  ClearEoln();
  }
#line 211
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowPatternCount(short side , short n ) 
{ 


  {
#line 217
  if (flag.post) {
    {
#line 219
    gotoXY((short )(68 + 3 * (int )side), (short)20);
    }
#line 221
    if ((int )n >= 0) {
      {
#line 222
      printw("%3d", (int )n);
      }
    } else {
      {
#line 224
      printw("   ");
      }
    }
  }
#line 226
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void ShowPlayers(void) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 232
  if (flag.reverse) {
#line 232
    tmp = 23;
  } else {
#line 232
    tmp = 2;
  }
  {
#line 232
  gotoXY((short)5, (short )tmp);
  }
#line 233
  if ((int )computer == 1) {
#line 233
    tmp___0 = "Computer";
  } else {
#line 233
    tmp___0 = "Human   ";
  }
  {
#line 233
  printw("%s", tmp___0);
  }
#line 234
  if (flag.reverse) {
#line 234
    tmp___1 = 2;
  } else {
#line 234
    tmp___1 = 23;
  }
  {
#line 234
  gotoXY((short)5, (short )tmp___1);
  }
#line 235
  if ((int )computer == 0) {
#line 235
    tmp___2 = "Computer";
  } else {
#line 235
    tmp___2 = "Human   ";
  }
  {
#line 235
  printw("%s", tmp___2);
  }
#line 236
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowPrompt(void) 
{ 


  {
  {
#line 242
  Curses_ShowSidetoMove();
#line 243
  gotoXY((short)58, (short)17);
#line 244
  printw("Your move is? ");
#line 245
  ClearEoln();
  }
#line 246
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowResponseTime(void) 
{ 
  short TCC ;

  {
#line 252
  if (flag.post) {
    {
#line 254
    TCC = (short )TCcount;
#line 255
    gotoXY((short)58, (short)21);
#line 256
    printw("%ld, %d, %ld, %ld, %ld, %d", ResponseTime, (int )TCC, TCleft, ExtraTime,
           et, (int )flag.timeout);
#line 258
    ClearEoln();
    }
  }
#line 260
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowResults(short score___0 , unsigned short *bstline , char ch ) 
{ 
  unsigned char d ;
  unsigned char ply ;

  {
#line 268
  if (flag.post) {
    {
#line 270
    Curses_ShowDepth(ch);
#line 271
    ShowScore(score___0);
#line 272
    d = (unsigned char)7;
#line 274
    ply = (unsigned char)1;
    }
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (! ((int )*(bstline + ply) > 0)) {
#line 274
        goto while_break;
      }
#line 276
      if ((int )ply % 2 == 1) {
        {
#line 278
        d = (unsigned char )((int )d + 1);
#line 278
        gotoXY((short)58, (short )d);
#line 279
        ClearEoln();
        }
      }
      {
#line 282
      algbr((short )((int )((short )*(bstline + ply)) >> 8), (short )((int )((short )*(bstline + ply)) & 255),
            (short)0);
#line 284
      printw("%5s ", mvstr[0]);
#line 274
      ply = (unsigned char )((int )ply + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 287
    ClearEoln();
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 289
      if (! ((int )d < 13)) {
#line 289
        goto while_break___0;
      }
      {
#line 291
      d = (unsigned char )((int )d + 1);
#line 291
      gotoXY((short)58, (short )d);
#line 292
      ClearEoln();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 295
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void ShowScore(short score___0 ) 
{ 


  {
  {
#line 301
  gotoXY((short)58, (short)5);
#line 302
  printw("Score= %d", (int )score___0);
#line 303
  ClearEoln();
  }
#line 304
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowSidetoMove(void) 
{ 


  {
  {
#line 310
  gotoXY((short)58, (short)14);
#line 311
  printw("%2d:   %s", 1 + (int )GameCnt / 2, ColorStr[player]);
#line 312
  ClearEoln();
  }
#line 313
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowStage(void) 
{ 
  int tmp ;

  {
  {
#line 319
  gotoXY((short)58, (short)19);
  }
#line 320
  if (flag.tsume) {
#line 320
    tmp = 'T';
  } else {
#line 320
    tmp = ' ';
  }
  {
#line 320
  printw("Stage= %2d%c B= %2d W= %2d", (int )stage, tmp, (int )balance[0], (int )balance[1]);
#line 322
  ClearEoln();
  }
#line 323
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_Initialize(void) 
{ 


  {
  {
#line 332
  signal(2, & Curses_Die);
#line 333
  signal(3, & Curses_Die);
#line 334
  initscr();
#line 335
  cbreak();
  }
#line 336
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ExitShogi(void) 
{ 


  {
#line 342
  if (! nolist) {
    {
#line 343
    ListGame();
    }
  }
  {
#line 345
  gotoXY((short)1, (short)24);
#line 347
  wrefresh(stdscr);
#line 348
  nocbreak();
#line 349
  endwin();
#line 351
  exit(0);
  }
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_Die(int sig ) 
{ 
  char s[80] ;
  int tmp ;

  {
  {
#line 360
  signal(2, (void (*)(int  ))1);
#line 361
  signal(3, (void (*)(int  ))1);
#line 363
  Curses_ShowMessage((char *)"Abort? ");
#line 364
  fflush(stdout);
#line 364
  scanw("%s", s);
#line 366
  tmp = strcmp((char const   *)(s), "yes");
  }
#line 366
  if (tmp == 0) {
    {
#line 367
    Curses_ExitShogi();
    }
  }
  {
#line 369
  signal(2, & Curses_Die);
#line 370
  signal(3, & Curses_Die);
  }
#line 371
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_TerminateSearch(int sig ) 
{ 


  {
  {
#line 377
  signal(2, (void (*)(int  ))1);
#line 378
  signal(3, (void (*)(int  ))1);
  }
#line 380
  if (! flag.timeout) {
#line 381
    flag.musttimeout = (short)1;
  }
  {
#line 383
  Curses_ShowMessage((char *)"Terminate Search");
#line 384
  flag.bothsides = (short)0;
#line 385
  signal(2, & Curses_Die);
#line 386
  signal(3, & Curses_Die);
  }
#line 387
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_help(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 393
  Curses_ClearScreen();
#line 394
  printw("GNU Shogi %s command summary\n", "1.4.1");
#line 395
  printw("----------------------------------------------------------------\n");
#line 397
  printw("7g7f      move from 7g to 7f      quit      Exit Shogi\n");
  }
#line 398
  if (flag.beep) {
#line 398
    tmp = "OFF";
  } else {
#line 398
    tmp = "ON";
  }
  {
#line 398
  printw("S6h       move silver to 6h       beep      turn %s\n", tmp);
  }
#line 399
  if (flag.material) {
#line 399
    tmp___0 = "OFF";
  } else {
#line 399
    tmp___0 = "ON";
  }
  {
#line 399
  printw("2d2c+     move to 2c and promote  material  turn %s\n", tmp___0);
  }
#line 400
  if (flag.easy) {
#line 400
    tmp___1 = "OFF";
  } else {
#line 400
    tmp___1 = "ON";
  }
  {
#line 400
  printw("P*5e      drop pawn to 5e         easy      turn %s\n", tmp___1);
  }
#line 401
  if (flag.hash) {
#line 401
    tmp___2 = "OFF";
  } else {
#line 401
    tmp___2 = "ON";
  }
  {
#line 401
  printw("tsume     toggle tsume mode       hash      turn %s\n", tmp___2);
#line 402
  printw("bd        redraw board            reverse   board display\n");
  }
#line 403
  if (Book) {
#line 403
    tmp___3 = "OFF";
  } else {
#line 403
    tmp___3 = "ON";
  }
  {
#line 403
  printw("list      game to shogi.lst       book      turn %s used %d of %d\n", tmp___3,
         bookcount, 8000);
#line 404
  printw("undo      undo last ply           remove    take back a move\n");
#line 405
  printw("edit      edit board              force     toggle manual move mode\n");
#line 406
  printw("switch    sides with computer     both      computer match\n");
#line 407
  printw("black     computer plays black    white     computer plays white\n");
#line 408
  printw("depth     set search depth        clock     set time control\n");
  }
#line 409
  if (flag.post) {
#line 409
    tmp___4 = "OFF";
  } else {
#line 409
    tmp___4 = "ON";
  }
  {
#line 409
  printw("post      principle variation     hint      suggest a move\n", tmp___4);
#line 410
  printw("save      game to file            get       game from file\n");
#line 411
  printw("random    randomize play          new       start new game\n");
#line 412
  gotoXY((short)10, (short)20);
#line 413
  printw("Computer: %s", ColorStr[computer]);
#line 414
  gotoXY((short)10, (short)21);
#line 415
  printw("Opponent: %s", ColorStr[opponent]);
#line 416
  gotoXY((short)10, (short)22);
#line 417
  printw("Level: %ld", MaxResponseTime / 100L);
#line 418
  gotoXY((short)10, (short)23);
  }
#line 419
  if (flag.easy) {
#line 419
    tmp___5 = "ON";
  } else {
#line 419
    tmp___5 = "OFF";
  }
  {
#line 419
  printw("Easy mode: %s", tmp___5);
#line 420
  gotoXY((short)25, (short)23);
  }
#line 421
  if (flag.tsume) {
#line 421
    tmp___6 = "ON";
  } else {
#line 421
    tmp___6 = "OFF";
  }
  {
#line 421
  printw("Tsume: %s", tmp___6);
#line 422
  gotoXY((short)40, (short)20);
#line 423
  printw("Depth: %d", (int )MaxSearchDepth);
#line 424
  gotoXY((short)40, (short)21);
  }
#line 425
  if (dither) {
#line 425
    tmp___7 = "ON";
  } else {
#line 425
    tmp___7 = "OFF";
  }
  {
#line 425
  printw("Random: %s", tmp___7);
#line 426
  gotoXY((short)40, (short)22);
  }
#line 427
  if (flag.hash) {
#line 427
    tmp___8 = "ON";
  } else {
#line 427
    tmp___8 = "OFF";
  }
  {
#line 427
  printw("Transposition table: %s", tmp___8);
#line 428
  gotoXY((short)40, (short)23);
#line 429
  printw("Hit <RET> to return: ");
#line 430
  gotoXY((short)10, (short)24);
  }
#line 431
  if (TCflag) {
#line 431
    tmp___9 = "ON";
  } else {
#line 431
    tmp___9 = "OFF";
  }
  {
#line 431
  printw("Time Control %s %d moves %d sec %d add %d depth\n", tmp___9, (int )TimeControl.moves[0],
         TimeControl.clock[0] / 100L, (int )OperatorTime, (int )MaxSearchDepth);
#line 436
  wrefresh(stdscr);
#line 442
  getchar();
#line 443
  Curses_ClearScreen();
#line 444
  Curses_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
  }
#line 445
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static short const   x0[2]  = {      (short const   )54,      (short const   )2};
#line 449 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static short const   y0[2]  = {      (short const   )20,      (short const   )4};
#line 458 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_EditBoard(void) 
{ 
  short a ;
  short c ;
  short sq ;
  short i___0 ;
  short r ;
  char s[80] ;

  {
  {
#line 462
  r = (short)0;
#line 465
  flag.regularstart = (short)1;
#line 466
  Book = 20;
#line 467
  Curses_ClearScreen();
#line 468
  Curses_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
#line 469
  gotoXY((short)58, (short)3);
#line 470
  printw(".   Exit to main\n");
#line 471
  gotoXY((short)58, (short)4);
#line 472
  printw("#   Clear board\n");
#line 473
  gotoXY((short)58, (short)5);
#line 474
  printw("c   Change sides\n");
#line 475
  gotoXY((short)58, (short)7);
#line 476
  printw("Enter piece & location: ");
#line 477
  a = (short)0;
  }
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    gotoXY((short)58, (short)6);
#line 482
    printw("Editing: %s", ColorStr[a]);
#line 483
    gotoXY((short)82, (short)7);
#line 484
    ClearEoln();
#line 485
    fflush(stdout);
#line 485
    scanw("%s", s);
    }
#line 487
    if ((int )s[0] == 35) {
#line 489
      sq = (short)0;
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 489
        if (! ((int )sq < 81)) {
#line 489
          goto while_break___0;
        }
        {
#line 491
        board[sq] = (signed char)0;
#line 492
        color[sq] = (signed char)2;
#line 493
        DrawPiece(sq);
#line 489
        sq = (short )((int )sq + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 496
      memset((void *)((char *)(Captured)), 0, sizeof(Captured));
#line 497
      UpdateCatched();
      }
    }
#line 500
    if ((int )s[0] == 99) {
#line 501
      a = (short )otherside[a];
    }
#line 503
    if ((int )s[1] == 42) {
#line 505
      i___0 = (short)15;
      {
#line 505
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 505
        if (! ((int )i___0 > 0)) {
#line 505
          goto while_break___1;
        }
#line 507
        if ((int )s[0] == (int )*(" PLNSGBRPLNSBRK " + i___0)) {
#line 508
          goto while_break___1;
        } else
#line 507
        if ((int )s[0] == (int )*(" plnsgbrplnsbrk " + i___0)) {
#line 508
          goto while_break___1;
        }
#line 505
        i___0 = (short )((int )i___0 - 1);
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 511
      Captured[a][unpromoted[i___0]] = (signed char )((int )Captured[a][unpromoted[i___0]] + 1);
#line 512
      UpdateCatched();
#line 513
      c = (short)-1;
      }
    } else {
#line 517
      c = (short )(57 - (int )s[1]);
#line 518
      r = (short )(105 - (int )s[2]);
    }
#line 521
    if ((int )c >= 0) {
#line 521
      if ((int )c < 9) {
#line 521
        if ((int )r >= 0) {
#line 521
          if ((int )r < 9) {
#line 523
            sq = (short )((int )r * 9 + (int )c);
#line 525
            i___0 = (short)15;
            {
#line 525
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 525
              if (! ((int )i___0 > 0)) {
#line 525
                goto while_break___2;
              }
#line 527
              if ((int )s[0] == (int )*(" PLNSGBRPLNSBRK " + i___0)) {
#line 528
                goto while_break___2;
              } else
#line 527
              if ((int )s[0] == (int )*(" plnsgbrplnsbrk " + i___0)) {
#line 528
                goto while_break___2;
              }
#line 525
              i___0 = (short )((int )i___0 - 1);
            }
            while_break___2: /* CIL Label */ ;
            }
#line 531
            if ((int )s[3] == 43) {
#line 532
              i___0 = (short )promoted[i___0];
            } else {
#line 534
              i___0 = (short )unpromoted[i___0];
            }
#line 536
            board[sq] = (signed char )i___0;
#line 537
            if ((int )board[sq] == 0) {
#line 537
              color[sq] = (signed char)2;
            } else {
#line 537
              color[sq] = (signed char )a;
            }
            {
#line 538
            DrawPiece(sq);
            }
          }
        }
      }
    }
#line 479
    if (! ((int )s[0] != 46)) {
#line 479
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  sq = (short)0;
  {
#line 543
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 543
    if (! ((int )sq < 81)) {
#line 543
      goto while_break___3;
    }
#line 544
    if ((int )board[sq] != (int )Stboard[sq]) {
#line 544
      Mvboard[sq] = (signed char)10;
    } else {
#line 544
      Mvboard[sq] = (signed char)0;
    }
#line 543
    sq = (short )((int )sq + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 546
  GameCnt = (short)0;
#line 547
  Game50 = (short)1;
#line 548
  ZeroRPT();
#line 549
  Sdepth = (short)0;
#line 550
  InitializeStats();
#line 551
  Curses_ClearScreen();
#line 552
  Curses_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
  }
#line 553
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void UpdateCatched(void) 
{ 
  short side ;
  short x ;
  short y ;
  short piece ;
  short cside ;
  short k ;
  short n ;

  {
#line 561
  side = (short)0;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! ((int )side <= 1)) {
#line 561
      goto while_break;
    }
#line 565
    if (flag.reverse) {
#line 565
      cside = (short )((int )side ^ 1);
    } else {
#line 565
      cside = side;
    }
#line 566
    x = (short )x0[cside];
#line 567
    y = (short )y0[cside];
#line 568
    k = (short)0;
#line 570
    piece = (short)1;
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 570
      if (! ((int )piece <= 14)) {
#line 570
        goto while_break___0;
      }
#line 574
      n = (short )Captured[side][piece];
#line 574
      if (n) {
        {
#line 576
        gotoXY(x, y);
#line 577
        printw("%i%c", (int )n, (int const   )*(" PLNSGBRPLNSBRK " + piece));
        }
#line 579
        if ((int )cside == 0) {
#line 580
          y = (short )((int )y - 1);
        } else {
#line 582
          y = (short )((int )y + 1);
        }
      } else {
#line 586
        k = (short )((int )k + 1);
      }
#line 570
      piece = (short )((int )piece + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 590
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 590
      if (! k) {
#line 590
        goto while_break___1;
      }
      {
#line 592
      k = (short )((int )k - 1);
#line 593
      gotoXY(x, y);
#line 594
      printw("  ");
      }
#line 596
      if ((int )cside == 0) {
#line 597
        y = (short )((int )y - 1);
      } else {
#line 599
        y = (short )((int )y + 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 561
    side = (short )((int )side + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 603
  wrefresh(stdscr);
  }
#line 604
  return;
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_SearchStartStuff(short side ) 
{ 
  short i___0 ;

  {
  {
#line 612
  signal(2, & Curses_TerminateSearch);
#line 613
  signal(3, & Curses_TerminateSearch);
#line 615
  i___0 = (short)4;
  }
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! ((int )i___0 < 14)) {
#line 615
      goto while_break;
    }
    {
#line 617
    gotoXY((short)58, i___0);
#line 618
    ClearEoln();
#line 615
    i___0 = (short )((int )i___0 + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_OutputMove(void) 
{ 
  short h ;
  short l ;
  short t ;

  {
  {
#line 627
  Curses_UpdateDisplay((short )root->f, (short )root->t, (short)0, (short )root->flags);
#line 628
  gotoXY((short)58, (short)16);
  }
#line 630
  if (flag.illegal) {
    {
#line 632
    printw("Illegal position.");
    }
#line 633
    return;
  }
  {
#line 636
  printw("My move is: %5s", mvstr[0]);
  }
#line 638
  if (flag.beep) {
    {
#line 639
    putchar(7);
    }
  }
  {
#line 641
  ClearEoln();
#line 643
  gotoXY((short)58, (short)18);
  }
#line 645
  if ((int )root->flags & 1024) {
    {
#line 646
    printw("Drawn game!");
    }
  } else
#line 647
  if ((int )root->score == -12999) {
    {
#line 648
    printw("Opponent mates!");
    }
  } else
#line 649
  if ((int )root->score == 12998) {
    {
#line 650
    printw("Computer mates!");
    }
  } else
#line 652
  if ((int )root->score < -12000) {
    {
#line 653
    printw("Opp: mate in %d!", (12999 + (int )root->score) - 1);
    }
  } else
#line 654
  if ((int )root->score > 12000) {
    {
#line 655
    printw("Comp: mate in %d!", (12998 - (int )root->score) - 1);
    }
  }
  {
#line 658
  ClearEoln();
  }
#line 660
  if (flag.post) {
#line 664
    h = (short)4000;
#line 665
    l = (short)0;
#line 666
    t = (short )(4000 >> 1);
    {
#line 668
    while (1) {
      while_continue: /* CIL Label */ ;
#line 668
      if (! ((int )l != (int )t)) {
#line 668
        goto while_break;
      }
#line 670
      if ((Tree + t)->f) {
#line 671
        l = t;
      } else
#line 670
      if ((Tree + t)->t) {
#line 671
        l = t;
      } else {
#line 673
        h = t;
      }
#line 675
      t = (short )(((int )l + (int )h) >> 1);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 678
    ShowNodeCnt(NodeCnt);
#line 679
    gotoXY((short)58, (short)23);
#line 680
    printw("Max Tree = %5d", (int )t);
#line 681
    ClearEoln();
    }
  }
  {
#line 684
  Curses_ShowSidetoMove();
  }
#line 685
  return;
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_UpdateClocks(void) 
{ 
  short m ;
  short s ;
  long dt ;
  int tmp ;
  int tmp___0 ;

  {
#line 694
  if (TCflag) {
#line 696
    dt = TimeControl.clock[player] - et;
#line 696
    m = (short )(dt / 6000L);
#line 697
    s = (short )((dt - 6000L * (long )m) / 100L);
  } else {
#line 701
    dt = et;
#line 701
    m = (short )(dt / 6000L);
#line 702
    s = (short )((int )((short )(et - 6000L * (long )m)) / 100);
  }
#line 705
  if ((int )m < 0) {
#line 706
    m = (short)0;
  }
#line 708
  if ((int )s < 0) {
#line 709
    s = (short)0;
  }
#line 711
  if ((int )player == 0) {
#line 712
    if (flag.reverse) {
#line 712
      tmp = 2;
    } else {
#line 712
      tmp = 23;
    }
    {
#line 712
    gotoXY((short)20, (short )tmp);
    }
  } else {
#line 714
    if (flag.reverse) {
#line 714
      tmp___0 = 23;
    } else {
#line 714
      tmp___0 = 2;
    }
    {
#line 714
    gotoXY((short)20, (short )tmp___0);
    }
  }
  {
#line 717
  printw("%d:%02d  ", (int )m, (int )s);
  }
#line 719
  if (flag.post) {
    {
#line 720
    ShowNodeCnt(NodeCnt);
    }
  }
  {
#line 722
  wrefresh(stdscr);
  }
#line 723
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
static void DrawPiece(short sq ) 
{ 
  char y ;
  char piece ;
  char l ;
  char r ;
  char p ;
  int tmp ;
  int tmp___0 ;

  {
#line 732
  if ((int )color[sq] == 2) {
#line 734
    r = (char )' ';
#line 734
    l = r;
  } else
#line 736
  if ((int )flag.reverse ^ ((int )color[sq] == 0)) {
#line 738
    l = (char )'/';
#line 739
    r = (char )'\\';
  } else {
#line 743
    l = (char )'\\';
#line 743
    r = (char )'/';
  }
#line 746
  piece = (char )board[sq];
#line 748
  if (is_promoted[(int )piece]) {
#line 750
    p = (char )'+';
#line 751
    y = (char )*(" PLNSGBRPLNSBRK " + unpromoted[(int )piece]);
  } else {
#line 755
    p = (char )' ';
#line 756
    y = (char )*(" PLNSGBRPLNSBRK " + (int )piece);
  }
#line 759
  if (flag.reverse) {
#line 759
    tmp = 8 - (int )sq / 9;
  } else {
#line 759
    tmp = (int )sq / 9;
  }
#line 759
  if (flag.reverse) {
#line 759
    tmp___0 = 8 - (int )sq % 9;
  } else {
#line 759
    tmp___0 = (int )sq % 9;
  }
  {
#line 759
  gotoXY((short )(8 + 5 * tmp___0), (short )(4 + 2 * (8 - tmp)));
#line 760
  printw("%c%c%c%c", (int )l, (int )p, (int )y, (int )r);
  }
#line 761
  return;
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowPostnValue(short sq ) 
{ 
  short score___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 772
  if (flag.reverse) {
#line 772
    tmp = 8 - (int )sq / 9;
  } else {
#line 772
    tmp = (int )sq / 9;
  }
#line 772
  if (flag.reverse) {
#line 772
    tmp___0 = 8 - (int )sq % 9;
  } else {
#line 772
    tmp___0 = (int )sq % 9;
  }
  {
#line 772
  gotoXY((short )(4 + 5 * tmp___0), (short )(5 + 2 * (7 - tmp)));
#line 773
  score___0 = ScorePosition((short )color[sq]);
  }
#line 775
  if ((int )color[sq] != 2) {
    {
#line 782
    printw("%3d ", (int )svalue[sq]);
    }
  } else {
    {
#line 787
    printw("   ");
    }
  }
#line 789
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ShowPostnValues(void) 
{ 
  short sq ;
  short score___0 ;

  {
  {
#line 797
  ExaminePosition(opponent);
#line 799
  sq = (short)0;
  }
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! ((int )sq < 81)) {
#line 799
      goto while_break;
    }
    {
#line 800
    Curses_ShowPostnValue(sq);
#line 799
    sq = (short )((int )sq + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 802
  score___0 = ScorePosition(opponent);
#line 803
  gotoXY((short)58, (short)5);
#line 804
  printw("S%d m%d ps%d gt%c m%d ps%d gt%c", (int )score___0, (int )mtl[computer],
         (int )pscore[computer], (int )GameType[computer], (int )mtl[opponent], (int )pscore[opponent],
         (int )GameType[opponent]);
#line 808
  ClearEoln();
  }
#line 809
  return;
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_UpdateDisplay(short f , short t , short redraw , short isspec ) 
{ 
  short i___0 ;
  short sq ;
  short z ;
  int j ;
  short side ;
  short x ;
  short y ;
  short piece ;
  short cside ;
  short k ;
  short n ;

  {
#line 818
  if (redraw) {
    {
#line 820
    ShowHeader();
#line 821
    ShowPlayers();
#line 823
    i___0 = (short)2;
#line 824
    i___0 = (short )((int )i___0 + 1);
#line 824
    gotoXY((short)3, i___0);
#line 826
    printw("    +");
#line 827
    j = 0;
    }
    {
#line 827
    while (1) {
      while_continue: /* CIL Label */ ;
#line 827
      if (! (j < 9)) {
#line 827
        goto while_break;
      }
      {
#line 828
      printw("----+");
#line 827
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 830
      if (! ((int )i___0 <= 19)) {
#line 830
        goto while_break___0;
      }
      {
#line 832
      i___0 = (short )((int )i___0 + 1);
#line 832
      gotoXY((short)1, i___0);
      }
#line 834
      if (flag.reverse) {
#line 835
        z = (short )((int )i___0 / 2 - 1);
      } else {
#line 837
        z = (short )(11 - ((int )i___0 + 1) / 2);
      }
      {
#line 839
      printw("    %c |", (105 - (int )z) + 1);
#line 840
      j = 0;
      }
      {
#line 840
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 840
        if (! (j < 9)) {
#line 840
          goto while_break___1;
        }
        {
#line 841
        printw("    |");
#line 840
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 843
      i___0 = (short )((int )i___0 + 1);
#line 843
      gotoXY((short)3, i___0);
      }
#line 845
      if ((int )i___0 < 20) {
        {
#line 847
        printw("    +");
#line 848
        j = 0;
        }
        {
#line 848
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 848
          if (! (j < 9)) {
#line 848
            goto while_break___2;
          }
          {
#line 849
          printw("----+");
#line 848
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 853
    printw("    +");
#line 854
    j = 0;
    }
    {
#line 854
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 854
      if (! (j < 9)) {
#line 854
        goto while_break___3;
      }
      {
#line 855
      printw("----+");
#line 854
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 857
    gotoXY((short)3, (short)22);
#line 858
    printw("    ");
    }
#line 861
    if (flag.reverse) {
      {
#line 862
      printw("  1    2    3    4    5    6    7    8    9");
      }
    } else {
      {
#line 864
      printw("  9    8    7    6    5    4    3    2    1");
      }
    }
#line 872
    sq = (short)0;
    {
#line 872
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 872
      if (! ((int )sq < 81)) {
#line 872
        goto while_break___4;
      }
      {
#line 873
      DrawPiece(sq);
#line 872
      sq = (short )((int )sq + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 877
    if ((int )f < 81) {
      {
#line 878
      DrawPiece(f);
      }
    }
    {
#line 880
    DrawPiece((short )((int )t & 127));
    }
  }
#line 883
  if ((int )isspec & 512) {
#line 883
    goto _L;
  } else
#line 883
  if ((int )isspec & 32) {
#line 883
    goto _L;
  } else
#line 883
  if (redraw) {
    _L: /* CIL Label */ 
#line 887
    side = (short)0;
    {
#line 887
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 887
      if (! ((int )side <= 1)) {
#line 887
        goto while_break___5;
      }
#line 890
      if (flag.reverse) {
#line 890
        cside = (short )((int )side ^ 1);
      } else {
#line 890
        cside = side;
      }
#line 891
      x = (short )x0[cside];
#line 892
      y = (short )y0[cside];
#line 893
      k = (short)0;
#line 895
      piece = (short)1;
      {
#line 895
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 895
        if (! ((int )piece <= 14)) {
#line 895
          goto while_break___6;
        }
#line 899
        n = (short )Captured[side][piece];
#line 899
        if (n) {
          {
#line 901
          gotoXY(x, y);
#line 902
          printw("%i%c", (int )n, (int const   )*(" PLNSGBRPLNSBRK " + piece));
          }
#line 904
          if ((int )cside == 0) {
#line 904
            y = (short )((int )y - 1);
          } else {
#line 904
            y = (short )((int )y + 1);
          }
        } else {
#line 908
          k = (short )((int )k + 1);
        }
#line 895
        piece = (short )((int )piece + 1);
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 912
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 912
        if (! k) {
#line 912
          goto while_break___7;
        }
        {
#line 914
        k = (short )((int )k - 1);
#line 915
        gotoXY(x, y);
#line 916
        printw("  ");
        }
#line 918
        if ((int )cside == 0) {
#line 919
          y = (short )((int )y - 1);
        } else {
#line 921
          y = (short )((int )y + 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 887
      side = (short )((int )side + 1);
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 926
  wrefresh(stdscr);
  }
#line 927
  return;
}
}
#line 930 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ChangeAlphaWindow(void) 
{ 


  {
  {
#line 933
  Curses_ShowMessage((char *)"WAwindow = ");
#line 934
  fflush(stdout);
#line 934
  scanw("%hd", & WAwindow);
#line 935
  Curses_ShowMessage((char *)"BAwindow = ");
#line 936
  fflush(stdout);
#line 936
  scanw("%hd", & BAwindow);
  }
#line 937
  return;
}
}
#line 940 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ChangeBetaWindow(void) 
{ 


  {
  {
#line 943
  Curses_ShowMessage((char *)"WBwindow = ");
#line 944
  fflush(stdout);
#line 944
  scanw("%hd", & WBwindow);
#line 945
  Curses_ShowMessage((char *)"BBwindow = ");
#line 946
  fflush(stdout);
#line 946
  scanw("%hd", & BBwindow);
  }
#line 947
  return;
}
}
#line 950 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_GiveHint(void) 
{ 
  char s[40] ;

  {
#line 955
  if (hint) {
    {
#line 957
    algbr((short )((int )hint >> 8), (short )((int )hint & 255), (short)0);
#line 958
    strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"try ");
#line 959
    strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)(mvstr[0]));
#line 960
    Curses_ShowMessage(s);
    }
  } else {
    {
#line 964
    Curses_ShowMessage((char *)"I have no idea.\n");
    }
  }
#line 966
  return;
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ChangeSearchDepth(void) 
{ 


  {
  {
#line 972
  Curses_ShowMessage((char *)"depth = ");
#line 973
  fflush(stdout);
#line 973
  scanw("%hd", & MaxSearchDepth);
#line 974
  TCflag = (short )(! ((int )MaxSearchDepth > 0));
  }
#line 975
  return;
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ChangeHashDepth(void) 
{ 


  {
  {
#line 981
  Curses_ShowMessage((char *)"hashdepth = ");
#line 982
  fflush(stdout);
#line 982
  scanw("%hd", & HashDepth);
#line 983
  Curses_ShowMessage((char *)"MoveLimit = ");
#line 984
  fflush(stdout);
#line 984
  scanw("%hd", & HashMoveLimit);
  }
#line 985
  return;
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_SetContempt(void) 
{ 


  {
  {
#line 991
  Curses_ShowMessage((char *)"contempt = ");
#line 992
  fflush(stdout);
#line 992
  scanw("%hd", & contempt);
  }
#line 993
  return;
}
}
#line 996 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_ChangeXwindow(void) 
{ 


  {
  {
#line 999
  Curses_ShowMessage((char *)"xwndw= ");
#line 1000
  fflush(stdout);
#line 1000
  scanw("%hd", & xwndw);
  }
#line 1001
  return;
}
}
#line 1004 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_SelectLevel(char *sx ) 
{ 
  int item ;

  {
  {
#line 1009
  Curses_ClearScreen();
#line 1010
  gotoXY((short)32, (short)2);
#line 1011
  printw("GNU Shogi %s", "1.4.1");
#line 1012
  gotoXY((short)20, (short)4);
#line 1013
  printw(" 1.   40 moves in   5 minutes");
#line 1014
  gotoXY((short)20, (short)5);
#line 1015
  printw(" 2.   40 moves in  15 minutes");
#line 1016
  gotoXY((short)20, (short)6);
#line 1017
  printw(" 3.   40 moves in  30 minutes");
#line 1018
  gotoXY((short)20, (short)7);
#line 1019
  printw(" 4.  all moves in  15 minutes");
#line 1020
  gotoXY((short)20, (short)8);
#line 1021
  printw(" 5.  all moves in  30 minutes");
#line 1022
  gotoXY((short)20, (short)9);
#line 1023
  printw(" 6.  all moves in  15 minutes, 30 seconds fischer clock");
#line 1024
  gotoXY((short)20, (short)10);
#line 1025
  printw(" 7.  all moves in  30 minutes, 30 seconds fischer clock");
#line 1026
  gotoXY((short)20, (short)11);
#line 1027
  printw(" 8.    1 move  in   1 minute");
#line 1028
  gotoXY((short)20, (short)12);
#line 1029
  printw(" 9.    1 move  in  15 minutes");
#line 1030
  gotoXY((short)20, (short)13);
#line 1031
  printw("10.    1 move  in  30 minutes");
#line 1033
  OperatorTime = (short)0;
#line 1034
  TCmoves = (short)40;
#line 1035
  TCminutes = (short)5;
#line 1036
  TCseconds = (short)0;
#line 1038
  gotoXY((short)20, (short)17);
#line 1039
  printw("Enter Level: ");
#line 1040
  wrefresh(stdscr);
#line 1041
  fflush(stdout);
#line 1041
  scanw("%d", & item);
  }
  {
#line 1045
  if (item == 1) {
#line 1045
    goto case_1;
  }
#line 1050
  if (item == 2) {
#line 1050
    goto case_2;
  }
#line 1055
  if (item == 3) {
#line 1055
    goto case_3;
  }
#line 1060
  if (item == 4) {
#line 1060
    goto case_4;
  }
#line 1066
  if (item == 5) {
#line 1066
    goto case_5;
  }
#line 1072
  if (item == 6) {
#line 1072
    goto case_6;
  }
#line 1079
  if (item == 7) {
#line 1079
    goto case_7;
  }
#line 1085
  if (item == 8) {
#line 1085
    goto case_8;
  }
#line 1091
  if (item == 9) {
#line 1091
    goto case_9;
  }
#line 1097
  if (item == 10) {
#line 1097
    goto case_10;
  }
#line 1043
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1046
  TCmoves = (short)40;
#line 1047
  TCminutes = (short)5;
#line 1048
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1051
  TCmoves = (short)40;
#line 1052
  TCminutes = (short)15;
#line 1053
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1056
  TCmoves = (short)40;
#line 1057
  TCminutes = (short)30;
#line 1058
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1061
  TCmoves = (short)80;
#line 1062
  TCminutes = (short)15;
#line 1063
  flag.gamein = (short)1;
#line 1064
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1067
  TCmoves = (short)80;
#line 1068
  TCminutes = (short)30;
#line 1069
  flag.gamein = (short)1;
#line 1070
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1073
  TCmoves = (short)80;
#line 1074
  TCminutes = (short)15;
#line 1075
  TCadd = 3000;
#line 1076
  flag.gamein = (short)1;
#line 1077
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1080
  TCmoves = (short)80;
#line 1081
  TCminutes = (short)30;
#line 1082
  TCadd = 3000;
#line 1083
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1086
  TCmoves = (short)1;
#line 1087
  TCminutes = (short)1;
#line 1088
  flag.onemove = (short)1;
#line 1089
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1092
  TCmoves = (short)1;
#line 1093
  TCminutes = (short)15;
#line 1094
  flag.onemove = (short)1;
#line 1095
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1098
  TCmoves = (short)1;
#line 1099
  TCminutes = (short)30;
#line 1100
  flag.onemove = (short)1;
#line 1101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1104
  TCflag = (short )((int )TCmoves > 0);
#line 1106
  TimeControl.clock[1] = 0L;
#line 1106
  TimeControl.clock[0] = TimeControl.clock[1];
#line 1108
  SetTimeControl();
#line 1109
  Curses_ClearScreen();
#line 1110
  Curses_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
  }
#line 1111
  return;
}
}
#line 1114 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_DoDebug(void) 
{ 
  short c ;
  short p ;
  short sq ;
  short tp ;
  short tc ;
  short tsq ;
  short score___0 ;
  char s[40] ;

  {
  {
#line 1120
  ExaminePosition(opponent);
#line 1121
  Curses_ShowMessage((char *)"Enter piece: ");
#line 1122
  fflush(stdout);
#line 1122
  scanw("%s", s);
#line 1123
  c = (short)2;
  }
#line 1125
  if ((int )s[0] == 98) {
#line 1126
    c = (short)0;
  } else
#line 1125
  if ((int )s[0] == 66) {
#line 1126
    c = (short)0;
  }
#line 1128
  if ((int )s[0] == 119) {
#line 1129
    c = (short)1;
  } else
#line 1128
  if ((int )s[0] == 87) {
#line 1129
    c = (short)1;
  }
#line 1131
  p = (short)14;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (! ((int )p > 0)) {
#line 1131
      goto while_break;
    }
#line 1133
    if ((int )s[1] == (int )*(" PLNSGBRPLNSBRK " + p)) {
#line 1134
      goto while_break;
    } else
#line 1133
    if ((int )s[1] == (int )*(" plnsgbrplnsbrk " + p)) {
#line 1134
      goto while_break;
    }
#line 1131
    p = (short )((int )p - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1137
  sq = (short)0;
  {
#line 1137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1137
    if (! ((int )sq < 81)) {
#line 1137
      goto while_break___0;
    }
    {
#line 1139
    tp = (short )board[sq];
#line 1140
    tc = (short )color[sq];
#line 1141
    board[sq] = (signed char )p;
#line 1142
    color[sq] = (signed char )c;
#line 1143
    tsq = (short )PieceList[c][1];
#line 1144
    PieceList[c][1] = (signed char )sq;
#line 1145
    Curses_ShowPostnValue(sq);
#line 1146
    PieceList[c][1] = (signed char )tsq;
#line 1147
    board[sq] = (signed char )tp;
#line 1148
    color[sq] = (signed char )tc;
#line 1137
    sq = (short )((int )sq + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1151
  score___0 = ScorePosition(opponent);
#line 1152
  gotoXY((short)58, (short)5);
#line 1153
  printw("S%d m%d ps%d gt%c m%d ps%d gt%c", (int )score___0, (int )mtl[computer],
         (int )pscore[computer], (int )GameType[computer], (int )mtl[opponent], (int )pscore[opponent],
         (int )GameType[opponent]);
#line 1157
  ClearEoln();
  }
#line 1158
  return;
}
}
#line 1161 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_DoTable(short *table ) 
{ 
  short sq ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1165
  ExaminePosition(opponent);
#line 1167
  sq = (short)0;
  }
  {
#line 1167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1167
    if (! ((int )sq < 81)) {
#line 1167
      goto while_break;
    }
#line 1169
    if (flag.reverse) {
#line 1169
      tmp = 8 - (int )sq / 9;
    } else {
#line 1169
      tmp = (int )sq / 9;
    }
#line 1169
    if (flag.reverse) {
#line 1169
      tmp___0 = 8 - (int )sq % 9;
    } else {
#line 1169
      tmp___0 = (int )sq % 9;
    }
    {
#line 1169
    gotoXY((short )(4 + 5 * tmp___0), (short )(5 + 2 * (7 - tmp)));
#line 1170
    printw("%3d ", (int )*(table + sq));
#line 1167
    sq = (short )((int )sq + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1172
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_PollForInput(void) 
{ 
  int i___0 ;
  int nchar ;
  int *tmp ;

  {
  {
#line 1181
  i___0 = ioctl(0, 21531UL, & nchar);
  }
#line 1181
  if (i___0) {
    {
#line 1183
    perror("FIONREAD");
#line 1184
    tmp = __errno_location();
#line 1184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You probably have a non-ANSI <ioctl.h>; see README. %d %d %x\n",
            i___0, *tmp, 21531);
#line 1188
    exit(1);
    }
  }
#line 1191
  if (nchar) {
#line 1193
    if (! flag.timeout) {
#line 1194
      flag.back = (short)1;
    }
#line 1196
    flag.bothsides = (short)0;
  }
#line 1198
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/cursesdsp.c"
void Curses_SetupBoard(void) 
{ 


  {
  {
#line 1204
  Curses_ShowMessage((char *)"\'setup\' command is not supported in Cursesmode");
  }
#line 1205
  return;
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 827 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
Mpiece_array *Mpiece[15] ;
#line 828
short ADVNCM[15] ;
#line 77 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.h"
struct Pattern_rec Pattern[128]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.h"
struct OpeningSequence_rec OpeningSequence[14]  ;
#line 80
short piece_to_pattern_distance(short side , short piece , short pside , short pattern ) ;
#line 84
short pattern_distance(short pside , short pattern ) ;
#line 87
short board_to_pattern_distance(short pside , short osequence , short pmplty , short GameCnt___0 ) ;
#line 91
short locate_opening_sequence(short pside , char *s , short GameCnt___0 ) ;
#line 94
void DisplayPattern(FILE *fd , short n ) ;
#line 97
void update_advance_bonus(short pside , short os ) ;
#line 100
void GetOpeningPatterns(short *max_opening_sequence ) ;
#line 103
void ShowOpeningPatterns(short max_opening_sequence ) ;
#line 110
signed char pattern_data[2102] ;
#line 3 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.inc"
signed char pattern_data[2102]  = 
#line 3 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.inc"
  {      (signed char)11,      (signed char)5,      (signed char)-3,      (signed char)1, 
        (signed char)29,      (signed char)1,      (signed char)19,      (signed char)6, 
        (signed char)10,      (signed char)4,      (signed char)12,      (signed char)5, 
        (signed char)3,      (signed char)1,      (signed char)-46,      (signed char)1, 
        (signed char)-60,      (signed char)-4,      (signed char)6,      (signed char)-3, 
        (signed char)1,      (signed char)19,      (signed char)1,      (signed char)29, 
        (signed char)4,      (signed char)10,      (signed char)6,      (signed char)20, 
        (signed char)1,      (signed char)-37,      (signed char)1,      (signed char)-51, 
        (signed char)-4,      (signed char)8,      (signed char)-3,      (signed char)1, 
        (signed char)19,      (signed char)1,      (signed char)29,      (signed char)4, 
        (signed char)20,      (signed char)1,      (signed char)21,      (signed char)1, 
        (signed char)22,      (signed char)5,      (signed char)11,      (signed char)14, 
        (signed char)12,      (signed char)5,      (signed char)13,      (signed char)-4, 
        (signed char)5,      (signed char)-3,      (signed char)6,      (signed char)10, 
        (signed char)1,      (signed char)19,      (signed char)1,      (signed char)29, 
        (signed char)4,      (signed char)20,      (signed char)5,      (signed char)11, 
        (signed char)14,      (signed char)3,      (signed char)-4,      (signed char)5, 
        (signed char)-3,      (signed char)14,      (signed char)4,      (signed char)5, 
        (signed char)3,      (signed char)5,      (signed char)21,      (signed char)4, 
        (signed char)11,      (signed char)6,      (signed char)10,      (signed char)1, 
        (signed char)19,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)30,      (signed char)-4,      (signed char)8,      (signed char)-3, 
        (signed char)14,      (signed char)3,      (signed char)6,      (signed char)2, 
        (signed char)5,      (signed char)11,      (signed char)4,      (signed char)20, 
        (signed char)1,      (signed char)19,      (signed char)1,      (signed char)29, 
        (signed char)-4,      (signed char)7,      (signed char)-3,      (signed char)14, 
        (signed char)3,      (signed char)4,      (signed char)10,      (signed char)5, 
        (signed char)11,      (signed char)5,      (signed char)13,      (signed char)1, 
        (signed char)19,      (signed char)6,      (signed char)20,      (signed char)1, 
        (signed char)29,      (signed char)1,      (signed char)30,      (signed char)1, 
        (signed char)31,      (signed char)-4,      (signed char)8,      (signed char)-3, 
        (signed char)14,      (signed char)3,      (signed char)5,      (signed char)11, 
        (signed char)6,      (signed char)12,      (signed char)5,      (signed char)13, 
        (signed char)1,      (signed char)19,      (signed char)4,      (signed char)20, 
        (signed char)1,      (signed char)29,      (signed char)1,      (signed char)30, 
        (signed char)1,      (signed char)31,      (signed char)-4,      (signed char)9, 
        (signed char)10,      (signed char)-3,      (signed char)14,      (signed char)2, 
        (signed char)5,      (signed char)11,      (signed char)1,      (signed char)19, 
        (signed char)1,      (signed char)29,      (signed char)4,      (signed char)20, 
        (signed char)1,      (signed char)30,      (signed char)1,      (signed char)31, 
        (signed char)5,      (signed char)21,      (signed char)-4,      (signed char)11, 
        (signed char)-3,      (signed char)14,      (signed char)10,      (signed char)5, 
        (signed char)11,      (signed char)1,      (signed char)27,      (signed char)1, 
        (signed char)19,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)30,      (signed char)4,      (signed char)20,      (signed char)5, 
        (signed char)21,      (signed char)1,      (signed char)-45,      (signed char)-4, 
        (signed char)-3,      (signed char)14,      (signed char)2,      (signed char)5, 
        (signed char)10,      (signed char)1,      (signed char)18,      (signed char)1, 
        (signed char)19,      (signed char)4,      (signed char)20,      (signed char)5, 
        (signed char)21,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)30,      (signed char)1,      (signed char)-36,      (signed char)-4, 
        (signed char)-3,      (signed char)2,      (signed char)0,      (signed char)3, 
        (signed char)1,      (signed char)14,      (signed char)10,      (signed char)5, 
        (signed char)11,      (signed char)4,      (signed char)20,      (signed char)1, 
        (signed char)19,      (signed char)1,      (signed char)27,      (signed char)1, 
        (signed char)29,      (signed char)-4,      (signed char)13,      (signed char)-3, 
        (signed char)6,      (signed char)20,      (signed char)4,      (signed char)-65, 
        (signed char)-4,      (signed char)6,      (signed char)-3,      (signed char)6, 
        (signed char)20,      (signed char)4,      (signed char)10,      (signed char)5, 
        (signed char)11,      (signed char)4,      (signed char)-46,      (signed char)-4, 
        (signed char)2,      (signed char)-3,      (signed char)4,      (signed char)20, 
        (signed char)5,      (signed char)11,      (signed char)14,      (signed char)12, 
        (signed char)5,      (signed char)13,      (signed char)-4,      (signed char)8, 
        (signed char)-3,      (signed char)14,      (signed char)2,      (signed char)5, 
        (signed char)11,      (signed char)5,      (signed char)21,      (signed char)-4, 
        (signed char)7,      (signed char)-3,      (signed char)14,      (signed char)3, 
        (signed char)5,      (signed char)11,      (signed char)6,      (signed char)12, 
        (signed char)5,      (signed char)13,      (signed char)4,      (signed char)20, 
        (signed char)-4,      (signed char)11,      (signed char)-3,      (signed char)2, 
        (signed char)0,      (signed char)3,      (signed char)1,      (signed char)14, 
        (signed char)10,      (signed char)5,      (signed char)11,      (signed char)4, 
        (signed char)20,      (signed char)-4,      (signed char)6,      (signed char)-3, 
        (signed char)14,      (signed char)3,      (signed char)4,      (signed char)10, 
        (signed char)5,      (signed char)11,      (signed char)5,      (signed char)13, 
        (signed char)1,      (signed char)19,      (signed char)6,      (signed char)20, 
        (signed char)-4,      (signed char)-2,      (signed char)111,      (signed char)1, 
        (signed char)2,      (signed char)-3,      (signed char)1,      (signed char)22, 
        (signed char)1,      (signed char)23,      (signed char)1,      (signed char)24, 
        (signed char)1,      (signed char)34,      (signed char)1,      (signed char)26, 
        (signed char)7,      (signed char)16,      (signed char)4,      (signed char)6, 
        (signed char)-4,      (signed char)3,      (signed char)-3,      (signed char)1, 
        (signed char)22,      (signed char)1,      (signed char)23,      (signed char)1, 
        (signed char)24,      (signed char)1,      (signed char)34,      (signed char)4, 
        (signed char)14,      (signed char)7,      (signed char)16,      (signed char)3, 
        (signed char)7,      (signed char)-4,      (signed char)4,      (signed char)-3, 
        (signed char)4,      (signed char)15,      (signed char)1,      (signed char)23, 
        (signed char)1,      (signed char)24,      (signed char)1,      (signed char)34, 
        (signed char)7,      (signed char)16,      (signed char)-4,      (signed char)5, 
        (signed char)6,      (signed char)7,      (signed char)-3,      (signed char)4, 
        (signed char)14,      (signed char)1,      (signed char)23,      (signed char)1, 
        (signed char)33,      (signed char)1,      (signed char)34,      (signed char)1, 
        (signed char)26,      (signed char)7,      (signed char)16,      (signed char)3, 
        (signed char)7,      (signed char)-4,      (signed char)12,      (signed char)14, 
        (signed char)15,      (signed char)17,      (signed char)-3,      (signed char)1, 
        (signed char)33,      (signed char)1,      (signed char)43,      (signed char)4, 
        (signed char)34,      (signed char)1,      (signed char)35,      (signed char)7, 
        (signed char)16,      (signed char)3,      (signed char)7,      (signed char)2, 
        (signed char)8,      (signed char)-4,      (signed char)12,      (signed char)-3, 
        (signed char)3,      (signed char)7,      (signed char)7,      (signed char)16, 
        (signed char)4,      (signed char)24,      (signed char)1,      (signed char)33, 
        (signed char)1,      (signed char)43,      (signed char)1,      (signed char)44, 
        (signed char)1,      (signed char)-53,      (signed char)-4,      (signed char)9, 
        (signed char)11,      (signed char)-3,      (signed char)2,      (signed char)8, 
        (signed char)7,      (signed char)16,      (signed char)4,      (signed char)23, 
        (signed char)3,      (signed char)24,      (signed char)1,      (signed char)32, 
        (signed char)1,      (signed char)33,      (signed char)1,      (signed char)34, 
        (signed char)1,      (signed char)44,      (signed char)1,      (signed char)-62, 
        (signed char)-4,      (signed char)8,      (signed char)-3,      (signed char)4, 
        (signed char)14,      (signed char)1,      (signed char)31,      (signed char)1, 
        (signed char)23,      (signed char)3,      (signed char)24,      (signed char)1, 
        (signed char)33,      (signed char)1,      (signed char)34,      (signed char)7, 
        (signed char)16,      (signed char)2,      (signed char)26,      (signed char)-4, 
        (signed char)-3,      (signed char)4,      (signed char)14,      (signed char)1, 
        (signed char)31,      (signed char)1,      (signed char)23,      (signed char)3, 
        (signed char)24,      (signed char)1,      (signed char)33,      (signed char)1, 
        (signed char)34,      (signed char)7,      (signed char)17,      (signed char)2, 
        (signed char)26,      (signed char)-4,      (signed char)10,      (signed char)-3, 
        (signed char)4,      (signed char)23,      (signed char)1,      (signed char)32, 
        (signed char)3,      (signed char)24,      (signed char)3,      (signed char)33, 
        (signed char)7,      (signed char)16,      (signed char)2,      (signed char)26, 
        (signed char)1,      (signed char)44,      (signed char)-4,      (signed char)-3, 
        (signed char)4,      (signed char)23,      (signed char)1,      (signed char)32, 
        (signed char)3,      (signed char)24,      (signed char)3,      (signed char)33, 
        (signed char)7,      (signed char)17,      (signed char)2,      (signed char)26, 
        (signed char)1,      (signed char)44,      (signed char)-4,      (signed char)-3, 
        (signed char)4,      (signed char)31,      (signed char)1,      (signed char)22, 
        (signed char)1,      (signed char)32,      (signed char)1,      (signed char)33, 
        (signed char)3,      (signed char)24,      (signed char)7,      (signed char)16, 
        (signed char)1,      (signed char)43,      (signed char)1,      (signed char)35, 
        (signed char)2,      (signed char)8,      (signed char)-4,      (signed char)13, 
        (signed char)-3,      (signed char)3,      (signed char)7,      (signed char)4, 
        (signed char)24,      (signed char)1,      (signed char)33,      (signed char)1, 
        (signed char)43,      (signed char)2,      (signed char)26,      (signed char)7, 
        (signed char)16,      (signed char)-4,      (signed char)-3,      (signed char)3, 
        (signed char)7,      (signed char)4,      (signed char)24,      (signed char)1, 
        (signed char)33,      (signed char)1,      (signed char)43,      (signed char)2, 
        (signed char)26,      (signed char)7,      (signed char)17,      (signed char)-4, 
        (signed char)16,      (signed char)-3,      (signed char)3,      (signed char)7, 
        (signed char)2,      (signed char)8,      (signed char)7,      (signed char)16, 
        (signed char)1,      (signed char)43,      (signed char)1,      (signed char)33, 
        (signed char)4,      (signed char)42,      (signed char)-4,      (signed char)16, 
        (signed char)-3,      (signed char)3,      (signed char)7,      (signed char)2, 
        (signed char)8,      (signed char)7,      (signed char)16,      (signed char)1, 
        (signed char)43,      (signed char)1,      (signed char)42,      (signed char)4, 
        (signed char)34,      (signed char)-4,      (signed char)-3,      (signed char)4, 
        (signed char)42,      (signed char)1,      (signed char)52,      (signed char)7, 
        (signed char)16,      (signed char)-4,      (signed char)-3,      (signed char)4, 
        (signed char)44,      (signed char)1,      (signed char)52,      (signed char)7, 
        (signed char)16,      (signed char)-4,      (signed char)-2,      (signed char)12, 
        (signed char)1,      (signed char)2,      (signed char)-3,      (signed char)5, 
        (signed char)3,      (signed char)5,      (signed char)13,      (signed char)14, 
        (signed char)4,      (signed char)6,      (signed char)10,      (signed char)1, 
        (signed char)29,      (signed char)4,      (signed char)2,      (signed char)3, 
        (signed char)1,      (signed char)2,      (signed char)0,      (signed char)-4, 
        (signed char)3,      (signed char)-3,      (signed char)1,      (signed char)27, 
        (signed char)2,      (signed char)0,      (signed char)3,      (signed char)1, 
        (signed char)6,      (signed char)10,      (signed char)14,      (signed char)11, 
        (signed char)5,      (signed char)3,      (signed char)5,      (signed char)13, 
        (signed char)1,      (signed char)19,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)21,      (signed char)1,      (signed char)31, 
        (signed char)-4,      (signed char)4,      (signed char)-3,      (signed char)2, 
        (signed char)0,      (signed char)3,      (signed char)1,      (signed char)4, 
        (signed char)2,      (signed char)5,      (signed char)3,      (signed char)5, 
        (signed char)13,      (signed char)14,      (signed char)12,      (signed char)6, 
        (signed char)10,      (signed char)1,      (signed char)19,      (signed char)1, 
        (signed char)21,      (signed char)1,      (signed char)29,      (signed char)-4, 
        (signed char)7,      (signed char)8,      (signed char)-3,      (signed char)2, 
        (signed char)0,      (signed char)3,      (signed char)1,      (signed char)5, 
        (signed char)3,      (signed char)6,      (signed char)10,      (signed char)14, 
        (signed char)11,      (signed char)4,      (signed char)12,      (signed char)5, 
        (signed char)13,      (signed char)1,      (signed char)27,      (signed char)1, 
        (signed char)19,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)21,      (signed char)1,      (signed char)31,      (signed char)-4, 
        (signed char)5,      (signed char)-3,      (signed char)2,      (signed char)0, 
        (signed char)3,      (signed char)1,      (signed char)4,      (signed char)2, 
        (signed char)5,      (signed char)3,      (signed char)5,      (signed char)13, 
        (signed char)14,      (signed char)11,      (signed char)6,      (signed char)10, 
        (signed char)1,      (signed char)19,      (signed char)1,      (signed char)21, 
        (signed char)1,      (signed char)29,      (signed char)1,      (signed char)22, 
        (signed char)-4,      (signed char)6,      (signed char)-3,      (signed char)2, 
        (signed char)9,      (signed char)14,      (signed char)10,      (signed char)3, 
        (signed char)1,      (signed char)4,      (signed char)2,      (signed char)5, 
        (signed char)3,      (signed char)6,      (signed char)20,      (signed char)1, 
        (signed char)18,      (signed char)1,      (signed char)19,      (signed char)1, 
        (signed char)29,      (signed char)-4,      (signed char)-3,      (signed char)14, 
        (signed char)0,      (signed char)2,      (signed char)9,      (signed char)4, 
        (signed char)10,      (signed char)5,      (signed char)11,      (signed char)5, 
        (signed char)2,      (signed char)1,      (signed char)19,      (signed char)6, 
        (signed char)20,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)21,      (signed char)-4,      (signed char)-3,      (signed char)2, 
        (signed char)0,      (signed char)3,      (signed char)1,      (signed char)14, 
        (signed char)10,      (signed char)5,      (signed char)11,      (signed char)1, 
        (signed char)27,      (signed char)1,      (signed char)19,      (signed char)6, 
        (signed char)20,      (signed char)5,      (signed char)21,      (signed char)1, 
        (signed char)29,      (signed char)1,      (signed char)30,      (signed char)-4, 
        (signed char)9,      (signed char)-3,      (signed char)2,      (signed char)0, 
        (signed char)3,      (signed char)1,      (signed char)6,      (signed char)10, 
        (signed char)14,      (signed char)11,      (signed char)5,      (signed char)3, 
        (signed char)5,      (signed char)13,      (signed char)4,      (signed char)20, 
        (signed char)1,      (signed char)38,      (signed char)1,      (signed char)21, 
        (signed char)4,      (signed char)22,      (signed char)1,      (signed char)31, 
        (signed char)1,      (signed char)-56,      (signed char)-4,      (signed char)-3, 
        (signed char)2,      (signed char)0,      (signed char)3,      (signed char)1, 
        (signed char)14,      (signed char)10,      (signed char)5,      (signed char)11, 
        (signed char)6,      (signed char)20,      (signed char)5,      (signed char)21, 
        (signed char)4,      (signed char)22,      (signed char)4,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)1,      (signed char)31, 
        (signed char)1,      (signed char)37,      (signed char)1,      (signed char)38, 
        (signed char)-4,      (signed char)1,      (signed char)-3,      (signed char)2, 
        (signed char)0,      (signed char)3,      (signed char)1,      (signed char)6, 
        (signed char)10,      (signed char)14,      (signed char)11,      (signed char)5, 
        (signed char)3,      (signed char)5,      (signed char)13,      (signed char)-4, 
        (signed char)3,      (signed char)-3,      (signed char)2,      (signed char)0, 
        (signed char)3,      (signed char)1,      (signed char)5,      (signed char)3, 
        (signed char)6,      (signed char)10,      (signed char)14,      (signed char)11, 
        (signed char)4,      (signed char)12,      (signed char)5,      (signed char)13, 
        (signed char)-4,      (signed char)2,      (signed char)-3,      (signed char)2, 
        (signed char)0,      (signed char)3,      (signed char)1,      (signed char)4, 
        (signed char)2,      (signed char)5,      (signed char)3,      (signed char)5, 
        (signed char)13,      (signed char)14,      (signed char)12,      (signed char)6, 
        (signed char)10,      (signed char)-4,      (signed char)-2,      (signed char)112, 
        (signed char)1,      (signed char)2,      (signed char)6,      (signed char)-3, 
        (signed char)7,      (signed char)16,      (signed char)1,      (signed char)43, 
        (signed char)-4,      (signed char)2,      (signed char)3,      (signed char)5, 
        (signed char)6,      (signed char)13,      (signed char)-3,      (signed char)4, 
        (signed char)14,      (signed char)7,      (signed char)16,      (signed char)3, 
        (signed char)7,      (signed char)2,      (signed char)8,      (signed char)1, 
        (signed char)31,      (signed char)1,      (signed char)33,      (signed char)-4, 
        (signed char)13,      (signed char)-3,      (signed char)2,      (signed char)8, 
        (signed char)4,      (signed char)14,      (signed char)7,      (signed char)16, 
        (signed char)3,      (signed char)24,      (signed char)1,      (signed char)32, 
        (signed char)1,      (signed char)33,      (signed char)-4,      (signed char)4, 
        (signed char)-3,      (signed char)2,      (signed char)8,      (signed char)3, 
        (signed char)7,      (signed char)7,      (signed char)16,      (signed char)4, 
        (signed char)12,      (signed char)1,      (signed char)24,      (signed char)1, 
        (signed char)23,      (signed char)4,      (signed char)22,      (signed char)1, 
        (signed char)40,      (signed char)1,      (signed char)-58,      (signed char)1, 
        (signed char)-50,      (signed char)-4,      (signed char)-3,      (signed char)2, 
        (signed char)8,      (signed char)3,      (signed char)7,      (signed char)7, 
        (signed char)16,      (signed char)4,      (signed char)12,      (signed char)1, 
        (signed char)24,      (signed char)1,      (signed char)23,      (signed char)4, 
        (signed char)31,      (signed char)1,      (signed char)40,      (signed char)1, 
        (signed char)-58,      (signed char)-4,      (signed char)-3,      (signed char)2, 
        (signed char)8,      (signed char)6,      (signed char)10,      (signed char)4, 
        (signed char)20,      (signed char)4,      (signed char)22,      (signed char)1, 
        (signed char)38,      (signed char)1,      (signed char)-56,      (signed char)-4, 
        (signed char)7,      (signed char)-3,      (signed char)1,      (signed char)43, 
        (signed char)1,      (signed char)35,      (signed char)7,      (signed char)16, 
        (signed char)4,      (signed char)15,      (signed char)-4,      (signed char)8, 
        (signed char)10,      (signed char)-3,      (signed char)1,      (signed char)43, 
        (signed char)1,      (signed char)33,      (signed char)1,      (signed char)35, 
        (signed char)4,      (signed char)34,      (signed char)7,      (signed char)16, 
        (signed char)-4,      (signed char)9,      (signed char)-3,      (signed char)1, 
        (signed char)42,      (signed char)1,      (signed char)43,      (signed char)1, 
        (signed char)35,      (signed char)4,      (signed char)34,      (signed char)7, 
        (signed char)16,      (signed char)-4,      (signed char)-3,      (signed char)4, 
        (signed char)42,      (signed char)1,      (signed char)43,      (signed char)1, 
        (signed char)35,      (signed char)7,      (signed char)16,      (signed char)-4, 
        (signed char)-3,      (signed char)1,      (signed char)43,      (signed char)4, 
        (signed char)44,      (signed char)1,      (signed char)35,      (signed char)7, 
        (signed char)16,      (signed char)-4,      (signed char)12,      (signed char)-3, 
        (signed char)2,      (signed char)26,      (signed char)7,      (signed char)16, 
        (signed char)-4,      (signed char)-3,      (signed char)2,      (signed char)26, 
        (signed char)7,      (signed char)17,      (signed char)1,      (signed char)53, 
        (signed char)-4,      (signed char)11,      (signed char)-3,      (signed char)4, 
        (signed char)23,      (signed char)3,      (signed char)24,      (signed char)7, 
        (signed char)16,      (signed char)2,      (signed char)8,      (signed char)1, 
        (signed char)32,      (signed char)1,      (signed char)33,      (signed char)-4, 
        (signed char)-2,      (signed char)21,      (signed char)1,      (signed char)-3, 
        (signed char)5,      (signed char)3,      (signed char)5,      (signed char)5, 
        (signed char)4,      (signed char)6,      (signed char)3,      (signed char)7, 
        (signed char)2,      (signed char)8,      (signed char)14,      (signed char)14, 
        (signed char)1,      (signed char)23,      (signed char)1,      (signed char)24, 
        (signed char)1,      (signed char)25,      (signed char)1,      (signed char)26, 
        (signed char)-4,      (signed char)2,      (signed char)4,      (signed char)-3, 
        (signed char)5,      (signed char)3,      (signed char)5,      (signed char)5, 
        (signed char)4,      (signed char)6,      (signed char)3,      (signed char)7, 
        (signed char)2,      (signed char)8,      (signed char)14,      (signed char)16, 
        (signed char)1,      (signed char)23,      (signed char)1,      (signed char)24, 
        (signed char)1,      (signed char)25,      (signed char)1,      (signed char)26, 
        (signed char)-4,      (signed char)3,      (signed char)-3,      (signed char)5, 
        (signed char)5,      (signed char)4,      (signed char)6,      (signed char)3, 
        (signed char)7,      (signed char)14,      (signed char)8,      (signed char)5, 
        (signed char)13,      (signed char)2,      (signed char)17,      (signed char)1, 
        (signed char)23,      (signed char)1,      (signed char)24,      (signed char)1, 
        (signed char)25,      (signed char)1,      (signed char)26,      (signed char)-4, 
        (signed char)12,      (signed char)-3,      (signed char)5,      (signed char)6, 
        (signed char)3,      (signed char)7,      (signed char)14,      (signed char)8, 
        (signed char)5,      (signed char)15,      (signed char)4,      (signed char)16, 
        (signed char)2,      (signed char)17,      (signed char)1,      (signed char)23, 
        (signed char)1,      (signed char)24,      (signed char)1,      (signed char)25, 
        (signed char)1,      (signed char)26,      (signed char)-4,      (signed char)5, 
        (signed char)8,      (signed char)-3,      (signed char)5,      (signed char)5, 
        (signed char)3,      (signed char)7,      (signed char)2,      (signed char)8, 
        (signed char)4,      (signed char)15,      (signed char)14,      (signed char)16, 
        (signed char)1,      (signed char)24,      (signed char)1,      (signed char)25, 
        (signed char)1,      (signed char)35,      (signed char)-4,      (signed char)6, 
        (signed char)9,      (signed char)-3,      (signed char)5,      (signed char)5, 
        (signed char)3,      (signed char)7,      (signed char)2,      (signed char)8, 
        (signed char)5,      (signed char)13,      (signed char)4,      (signed char)15, 
        (signed char)14,      (signed char)16,      (signed char)1,      (signed char)23, 
        (signed char)1,      (signed char)24,      (signed char)1,      (signed char)25, 
        (signed char)1,      (signed char)35,      (signed char)-4,      (signed char)7, 
        (signed char)10,      (signed char)-3,      (signed char)5,      (signed char)5, 
        (signed char)3,      (signed char)7,      (signed char)2,      (signed char)8, 
        (signed char)4,      (signed char)15,      (signed char)14,      (signed char)16, 
        (signed char)5,      (signed char)23,      (signed char)1,      (signed char)25, 
        (signed char)1,      (signed char)32,      (signed char)1,      (signed char)33, 
        (signed char)1,      (signed char)35,      (signed char)-4,      (signed char)11, 
        (signed char)-3,      (signed char)3,      (signed char)7,      (signed char)2, 
        (signed char)8,      (signed char)5,      (signed char)15,      (signed char)14, 
        (signed char)16,      (signed char)5,      (signed char)23,      (signed char)4, 
        (signed char)25,      (signed char)1,      (signed char)32,      (signed char)1, 
        (signed char)33,      (signed char)1,      (signed char)34,      (signed char)1, 
        (signed char)35,      (signed char)-4,      (signed char)5,      (signed char)-3, 
        (signed char)5,      (signed char)5,      (signed char)3,      (signed char)7, 
        (signed char)2,      (signed char)8,      (signed char)4,      (signed char)15, 
        (signed char)14,      (signed char)16,      (signed char)1,      (signed char)24, 
        (signed char)1,      (signed char)25,      (signed char)1,      (signed char)35, 
        (signed char)-4,      (signed char)6,      (signed char)-3,      (signed char)5, 
        (signed char)5,      (signed char)3,      (signed char)7,      (signed char)2, 
        (signed char)8,      (signed char)5,      (signed char)13,      (signed char)4, 
        (signed char)15,      (signed char)14,      (signed char)16,      (signed char)1, 
        (signed char)23,      (signed char)1,      (signed char)24,      (signed char)1, 
        (signed char)25,      (signed char)1,      (signed char)35,      (signed char)-4, 
        (signed char)7,      (signed char)-3,      (signed char)5,      (signed char)5, 
        (signed char)3,      (signed char)7,      (signed char)2,      (signed char)8, 
        (signed char)4,      (signed char)15,      (signed char)14,      (signed char)16, 
        (signed char)5,      (signed char)23,      (signed char)-4,      (signed char)-3, 
        (signed char)3,      (signed char)7,      (signed char)2,      (signed char)8, 
        (signed char)5,      (signed char)15,      (signed char)14,      (signed char)16, 
        (signed char)5,      (signed char)23,      (signed char)4,      (signed char)25, 
        (signed char)-4,      (signed char)-3,      (signed char)5,      (signed char)6, 
        (signed char)3,      (signed char)7,      (signed char)14,      (signed char)8, 
        (signed char)5,      (signed char)15,      (signed char)4,      (signed char)16, 
        (signed char)2,      (signed char)17,      (signed char)-4,      (signed char)-2, 
        (signed char)22,      (signed char)1,      (signed char)-3,      (signed char)2, 
        (signed char)8,      (signed char)4,      (signed char)6,      (signed char)5, 
        (signed char)5,      (signed char)5,      (signed char)3,      (signed char)14, 
        (signed char)15,      (signed char)1,      (signed char)25,      (signed char)1, 
        (signed char)24,      (signed char)1,      (signed char)23,      (signed char)-4, 
        (signed char)2,      (signed char)-3,      (signed char)2,      (signed char)8, 
        (signed char)5,      (signed char)5,      (signed char)4,      (signed char)16, 
        (signed char)14,      (signed char)15,      (signed char)5,      (signed char)13, 
        (signed char)1,      (signed char)25,      (signed char)1,      (signed char)24, 
        (signed char)1,      (signed char)23,      (signed char)-4,      (signed char)-3, 
        (signed char)4,      (signed char)16,      (signed char)14,      (signed char)15, 
        (signed char)5,      (signed char)14,      (signed char)5,      (signed char)13, 
        (signed char)1,      (signed char)25,      (signed char)1,      (signed char)24, 
        (signed char)1,      (signed char)23,      (signed char)-4,      (signed char)0, 
        (signed char)-3,      (signed char)2,      (signed char)8,      (signed char)4, 
        (signed char)6,      (signed char)5,      (signed char)5,      (signed char)5, 
        (signed char)3,      (signed char)14,      (signed char)15,      (signed char)-4, 
        (signed char)1,      (signed char)-3,      (signed char)2,      (signed char)8, 
        (signed char)5,      (signed char)5,      (signed char)4,      (signed char)16, 
        (signed char)14,      (signed char)15,      (signed char)5,      (signed char)13, 
        (signed char)-4,      (signed char)2,      (signed char)-3,      (signed char)4, 
        (signed char)16,      (signed char)14,      (signed char)15,      (signed char)5, 
        (signed char)14,      (signed char)5,      (signed char)13,      (signed char)-4, 
        (signed char)-2,      (signed char)13,      (signed char)-3,      (signed char)1, 
        (signed char)26,      (signed char)1,      (signed char)43,      (signed char)1, 
        (signed char)24,      (signed char)1,      (signed char)23,      (signed char)1, 
        (signed char)22,      (signed char)1,      (signed char)21,      (signed char)1, 
        (signed char)29,      (signed char)1,      (signed char)19,      (signed char)1, 
        (signed char)18,      (signed char)3,      (signed char)1,      (signed char)4, 
        (signed char)2,      (signed char)5,      (signed char)3,      (signed char)14, 
        (signed char)4,      (signed char)5,      (signed char)5,      (signed char)4, 
        (signed char)6,      (signed char)3,      (signed char)7,      (signed char)-4, 
        (signed char)-3,      (signed char)1,      (signed char)19,      (signed char)1, 
        (signed char)29,      (signed char)1,      (signed char)21,      (signed char)5, 
        (signed char)3,      (signed char)5,      (signed char)13,      (signed char)1, 
        (signed char)31,      (signed char)-4,      (signed char)-2,      (signed char)113, 
        (signed char)1,      (signed char)2,      (signed char)-3,      (signed char)1, 
        (signed char)34,      (signed char)7,      (signed char)16,      (signed char)-4, 
        (signed char)3,      (signed char)-3,      (signed char)1,      (signed char)34, 
        (signed char)4,      (signed char)14,      (signed char)-4,      (signed char)6, 
        (signed char)-3,      (signed char)1,      (signed char)34,      (signed char)4, 
        (signed char)15,      (signed char)-4,      (signed char)4,      (signed char)5, 
        (signed char)-3,      (signed char)1,      (signed char)34,      (signed char)4, 
        (signed char)14,      (signed char)1,      (signed char)33,      (signed char)-4, 
        (signed char)-3,      (signed char)1,      (signed char)34,      (signed char)1, 
        (signed char)32,      (signed char)1,      (signed char)33,      (signed char)4, 
        (signed char)23,      (signed char)3,      (signed char)24,      (signed char)-4, 
        (signed char)-3,      (signed char)1,      (signed char)43,      (signed char)1, 
        (signed char)33,      (signed char)4,      (signed char)24,      (signed char)1, 
        (signed char)44,      (signed char)-4,      (signed char)7,      (signed char)-3, 
        (signed char)1,      (signed char)43,      (signed char)4,      (signed char)25, 
        (signed char)1,      (signed char)24,      (signed char)-4,      (signed char)-3, 
        (signed char)1,      (signed char)43,      (signed char)4,      (signed char)34, 
        (signed char)1,      (signed char)35,      (signed char)1,      (signed char)33, 
        (signed char)-4,      (signed char)-2,      (signed char)23,      (signed char)4, 
        (signed char)-3,      (signed char)7,      (signed char)13,      (signed char)14, 
        (signed char)4,      (signed char)5,      (signed char)5,      (signed char)4, 
        (signed char)6,      (signed char)-4,      (signed char)4,      (signed char)-3, 
        (signed char)7,      (signed char)12,      (signed char)14,      (signed char)4, 
        (signed char)5,      (signed char)5,      (signed char)4,      (signed char)6, 
        (signed char)-4,      (signed char)4,      (signed char)-3,      (signed char)7, 
        (signed char)11,      (signed char)14,      (signed char)4,      (signed char)5, 
        (signed char)5,      (signed char)4,      (signed char)6,      (signed char)-4, 
        (signed char)4,      (signed char)-3,      (signed char)7,      (signed char)10, 
        (signed char)14,      (signed char)4,      (signed char)5,      (signed char)5, 
        (signed char)4,      (signed char)6,      (signed char)-4,      (signed char)-3, 
        (signed char)14,      (signed char)15,      (signed char)5,      (signed char)5, 
        (signed char)4,      (signed char)6,      (signed char)-4,      (signed char)-2, 
        (signed char)123,      (signed char)1,      (signed char)2,      (signed char)3, 
        (signed char)4,      (signed char)-3,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)6,      (signed char)20, 
        (signed char)-4,      (signed char)-3,      (signed char)7,      (signed char)10, 
        (signed char)1,      (signed char)29,      (signed char)1,      (signed char)30, 
        (signed char)6,      (signed char)20,      (signed char)4,      (signed char)21, 
        (signed char)-4,      (signed char)-3,      (signed char)7,      (signed char)11, 
        (signed char)1,      (signed char)29,      (signed char)1,      (signed char)30, 
        (signed char)6,      (signed char)20,      (signed char)-4,      (signed char)-3, 
        (signed char)7,      (signed char)12,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)-4,      (signed char)-3, 
        (signed char)7,      (signed char)13,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)-4,      (signed char)-2, 
        (signed char)33,      (signed char)1,      (signed char)-3,      (signed char)1, 
        (signed char)24,      (signed char)1,      (signed char)23,      (signed char)1, 
        (signed char)21,      (signed char)1,      (signed char)29,      (signed char)3, 
        (signed char)1,      (signed char)4,      (signed char)2,      (signed char)5, 
        (signed char)3,      (signed char)14,      (signed char)4,      (signed char)5, 
        (signed char)5,      (signed char)4,      (signed char)6,      (signed char)3, 
        (signed char)7,      (signed char)-4,      (signed char)2,      (signed char)3, 
        (signed char)-3,      (signed char)1,      (signed char)24,      (signed char)1, 
        (signed char)23,      (signed char)1,      (signed char)30,      (signed char)1, 
        (signed char)29,      (signed char)6,      (signed char)10,      (signed char)4, 
        (signed char)2,      (signed char)5,      (signed char)3,      (signed char)14, 
        (signed char)4,      (signed char)5,      (signed char)5,      (signed char)4, 
        (signed char)6,      (signed char)-4,      (signed char)4,      (signed char)-3, 
        (signed char)1,      (signed char)30,      (signed char)1,      (signed char)29, 
        (signed char)4,      (signed char)11,      (signed char)6,      (signed char)10, 
        (signed char)-4,      (signed char)4,      (signed char)-3,      (signed char)1, 
        (signed char)30,      (signed char)1,      (signed char)29,      (signed char)4, 
        (signed char)12,      (signed char)6,      (signed char)10,      (signed char)-4, 
        (signed char)-3,      (signed char)1,      (signed char)30,      (signed char)1, 
        (signed char)29,      (signed char)4,      (signed char)12,      (signed char)6, 
        (signed char)10,      (signed char)1,      (signed char)44,      (signed char)-4, 
        (signed char)-2,      (signed char)-123,      (signed char)-3,      (signed char)1, 
        (signed char)29,      (signed char)-4,      (signed char)-2,      (signed char)124, 
        (signed char)1,      (signed char)5,      (signed char)8,      (signed char)10, 
        (signed char)-3,      (signed char)6,      (signed char)20,      (signed char)1, 
        (signed char)29,      (signed char)1,      (signed char)30,      (signed char)14, 
        (signed char)4,      (signed char)5,      (signed char)5,      (signed char)4, 
        (signed char)6,      (signed char)1,      (signed char)25,      (signed char)-4, 
        (signed char)2,      (signed char)-3,      (signed char)7,      (signed char)10, 
        (signed char)6,      (signed char)20,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)14,      (signed char)4, 
        (signed char)5,      (signed char)5,      (signed char)4,      (signed char)6, 
        (signed char)-4,      (signed char)3,      (signed char)4,      (signed char)-3, 
        (signed char)7,      (signed char)10,      (signed char)3,      (signed char)1, 
        (signed char)5,      (signed char)3,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)-4,      (signed char)-3, 
        (signed char)7,      (signed char)10,      (signed char)3,      (signed char)1, 
        (signed char)5,      (signed char)11,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)-4,      (signed char)-3, 
        (signed char)7,      (signed char)10,      (signed char)3,      (signed char)1, 
        (signed char)5,      (signed char)13,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)-4,      (signed char)6, 
        (signed char)7,      (signed char)-3,      (signed char)7,      (signed char)11, 
        (signed char)6,      (signed char)20,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)14,      (signed char)4, 
        (signed char)5,      (signed char)5,      (signed char)4,      (signed char)6, 
        (signed char)-4,      (signed char)-3,      (signed char)7,      (signed char)11, 
        (signed char)4,      (signed char)21,      (signed char)5,      (signed char)13, 
        (signed char)1,      (signed char)19,      (signed char)6,      (signed char)20, 
        (signed char)1,      (signed char)29,      (signed char)1,      (signed char)30, 
        (signed char)-4,      (signed char)-3,      (signed char)7,      (signed char)11, 
        (signed char)4,      (signed char)21,      (signed char)1,      (signed char)19, 
        (signed char)6,      (signed char)20,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)1,      (signed char)31, 
        (signed char)-4,      (signed char)9,      (signed char)-3,      (signed char)7, 
        (signed char)12,      (signed char)6,      (signed char)20,      (signed char)4, 
        (signed char)21,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)30,      (signed char)14,      (signed char)4,      (signed char)5, 
        (signed char)5,      (signed char)4,      (signed char)6,      (signed char)-4, 
        (signed char)-3,      (signed char)7,      (signed char)12,      (signed char)3, 
        (signed char)1,      (signed char)5,      (signed char)3,      (signed char)1, 
        (signed char)19,      (signed char)6,      (signed char)20,      (signed char)4, 
        (signed char)21,      (signed char)1,      (signed char)29,      (signed char)1, 
        (signed char)30,      (signed char)-4,      (signed char)11,      (signed char)13, 
        (signed char)-3,      (signed char)7,      (signed char)13,      (signed char)1, 
        (signed char)19,      (signed char)6,      (signed char)20,      (signed char)4, 
        (signed char)21,      (signed char)14,      (signed char)4,      (signed char)5, 
        (signed char)5,      (signed char)4,      (signed char)6,      (signed char)-4, 
        (signed char)12,      (signed char)-3,      (signed char)7,      (signed char)13, 
        (signed char)3,      (signed char)1,      (signed char)5,      (signed char)11, 
        (signed char)1,      (signed char)19,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)-4,      (signed char)-3, 
        (signed char)7,      (signed char)4,      (signed char)3,      (signed char)1, 
        (signed char)1,      (signed char)19,      (signed char)6,      (signed char)20, 
        (signed char)4,      (signed char)21,      (signed char)4,      (signed char)23, 
        (signed char)1,      (signed char)29,      (signed char)1,      (signed char)30, 
        (signed char)-4,      (signed char)-3,      (signed char)7,      (signed char)13, 
        (signed char)3,      (signed char)1,      (signed char)1,      (signed char)19, 
        (signed char)6,      (signed char)20,      (signed char)4,      (signed char)21, 
        (signed char)5,      (signed char)23,      (signed char)1,      (signed char)29, 
        (signed char)1,      (signed char)30,      (signed char)-4,      (signed char)-2, 
        (signed char)34,      (signed char)1,      (signed char)-3,      (signed char)1, 
        (signed char)24,      (signed char)1,      (signed char)23,      (signed char)1, 
        (signed char)21,      (signed char)1,      (signed char)29,      (signed char)3, 
        (signed char)1,      (signed char)4,      (signed char)2,      (signed char)5, 
        (signed char)3,      (signed char)14,      (signed char)4,      (signed char)5, 
        (signed char)5,      (signed char)4,      (signed char)6,      (signed char)3, 
        (signed char)7,      (signed char)-4,      (signed char)2,      (signed char)3, 
        (signed char)-3,      (signed char)1,      (signed char)24,      (signed char)1, 
        (signed char)23,      (signed char)1,      (signed char)30,      (signed char)1, 
        (signed char)29,      (signed char)6,      (signed char)10,      (signed char)4, 
        (signed char)2,      (signed char)5,      (signed char)3,      (signed char)14, 
        (signed char)4,      (signed char)5,      (signed char)5,      (signed char)4, 
        (signed char)6,      (signed char)-4,      (signed char)4,      (signed char)-3, 
        (signed char)1,      (signed char)30,      (signed char)1,      (signed char)29, 
        (signed char)4,      (signed char)11,      (signed char)6,      (signed char)10, 
        (signed char)-4,      (signed char)4,      (signed char)-3,      (signed char)1, 
        (signed char)30,      (signed char)1,      (signed char)29,      (signed char)4, 
        (signed char)12,      (signed char)6,      (signed char)10,      (signed char)-4, 
        (signed char)-3,      (signed char)1,      (signed char)30,      (signed char)1, 
        (signed char)29,      (signed char)4,      (signed char)12,      (signed char)6, 
        (signed char)10,      (signed char)1,      (signed char)44,      (signed char)-4, 
        (signed char)-2,      (signed char)-1};
#line 45 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
static void NameOfOpeningValue(short i___0 , char *name ) 
{ 


  {
#line 48
  if ((int )i___0 < 100) {
    {
#line 50
    strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"CASTLE_?_?");
    }
  } else {
    {
#line 54
    strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"ATTACK_?_?");
#line 55
    i___0 = (short )((int )i___0 - 100);
    }
  }
  {
#line 60
  if ((int )i___0 / 10 == 1) {
#line 60
    goto case_1;
  }
#line 64
  if ((int )i___0 / 10 == 2) {
#line 64
    goto case_2;
  }
#line 68
  if ((int )i___0 / 10 == 3) {
#line 68
    goto case_3;
  }
#line 72
  goto switch_default;
  case_1: /* CIL Label */ 
#line 61
  *(name + 7) = (char )'S';
#line 62
  goto switch_break;
  case_2: /* CIL Label */ 
#line 65
  *(name + 7) = (char )'R';
#line 66
  goto switch_break;
  case_3: /* CIL Label */ 
#line 69
  *(name + 7) = (char )'U';
#line 70
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 73
  *(name + 7) = (char )'*';
#line 74
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 79
  if ((int )i___0 % 10 == 1) {
#line 79
    goto case_1___0;
  }
#line 83
  if ((int )i___0 % 10 == 2) {
#line 83
    goto case_2___0;
  }
#line 87
  if ((int )i___0 % 10 == 3) {
#line 87
    goto case_3___0;
  }
#line 91
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 80
  *(name + 9) = (char )'S';
#line 81
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 84
  *(name + 9) = (char )'R';
#line 85
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 88
  *(name + 9) = (char )'U';
#line 89
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 92
  *(name + 9) = (char )'*';
#line 93
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
void GetOpeningPatterns(short *max_opening_sequence ) 
{ 
  short pindex ;
  short os ;
  short p ;
  short i___0 ;
  short tmp ;

  {
#line 101
  pindex = (short)0;
#line 102
  os = (short)0;
#line 103
  p = (short)0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    tmp = pindex;
#line 108
    pindex = (short )((int )pindex + 1);
#line 108
    OpeningSequence[os].opening_type = (short )pattern_data[tmp];
#line 109
    OpeningSequence[os].first_pattern[0] = p;
#line 111
    i___0 = (short)1;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! ((int )i___0 < 4)) {
#line 111
        goto while_break___0;
      }
#line 112
      OpeningSequence[os].first_pattern[i___0] = (short)-2;
#line 111
      i___0 = (short )((int )i___0 + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 114
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 116
      Pattern[p].reachedGameCnt[0] = (short)300;
#line 117
      Pattern[p].reachedGameCnt[1] = (short)300;
#line 118
      Pattern[p].first_link = pindex;
      {
#line 120
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 120
        if (! ((int )pattern_data[pindex] != -3)) {
#line 120
          goto while_break___2;
        }
#line 121
        pindex = (short )((int )pindex + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 122
      pindex = (short )((int )pindex + 1);
#line 124
      Pattern[p].first_field = pindex;
      {
#line 126
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 126
        if (! ((int )pattern_data[pindex] != -4)) {
#line 126
          goto while_break___3;
        }
#line 127
        pindex = (short )((int )pindex + 2);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 128
      pindex = (short )((int )pindex + 1);
#line 130
      if ((int )pattern_data[pindex] != -2) {
#line 131
        Pattern[p].next_pattern = (short )((int )p + 1);
      } else {
#line 133
        Pattern[p].next_pattern = (short)-2;
      }
#line 135
      p = (short )((int )p + 1);
#line 114
      if (! ((int )pattern_data[pindex] != -2)) {
#line 114
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 139
    pindex = (short )((int )pindex + 1);
#line 140
    os = (short )((int )os + 1);
#line 106
    if (! ((int )pattern_data[pindex] != -1)) {
#line 106
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  *max_opening_sequence = os;
#line 145
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
void ShowOpeningPatterns(short max_opening_sequence ) 
{ 
  short os ;
  short p ;
  short n ;
  short i___0 ;
  char name[16] ;

  {
#line 154
  os = (short)0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((int )os < (int )max_opening_sequence)) {
#line 154
      goto while_break;
    }
    {
#line 157
    NameOfOpeningValue(OpeningSequence[os].opening_type, name);
#line 158
    printf((char const   */* __restrict  */)"Opening Type: %s\n", name);
#line 160
    p = OpeningSequence[os].first_pattern[0];
#line 160
    n = (short)0;
    }
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! ((int )p != -2)) {
#line 160
        goto while_break___0;
      }
      {
#line 164
      printf((char const   */* __restrict  */)"Pattern %d (%d) with links ", (int )p,
             (int )n);
#line 166
      i___0 = Pattern[p].first_link;
      }
      {
#line 166
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 166
        if (! ((int )pattern_data[i___0] != -3)) {
#line 166
          goto while_break___1;
        }
        {
#line 170
        printf((char const   */* __restrict  */)"%d ", (int )pattern_data[i___0]);
#line 166
        i___0 = (short )((int )i___0 + 1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 173
      printf((char const   */* __restrict  */)"\n");
#line 174
      DisplayPattern(stdout, Pattern[p].first_field);
#line 160
      p = Pattern[p].next_pattern;
#line 160
      n = (short )((int )n + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 154
    os = (short )((int )os + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
void set_field(short i___0 , struct PatternField *field ) 
{ 


  {
#line 184
  field->piece = (short )pattern_data[i___0];
#line 185
  field->square = (short )pattern_data[(int )i___0 + 1];
#line 187
  if ((int )field->square < 0) {
#line 189
    field->square = (short )(- ((int )field->square));
#line 190
    field->side = (short)1;
  } else {
#line 194
    field->side = (short)0;
  }
#line 196
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
short piece_to_pattern_distance(short side , short piece , short pside , short pattern ) 
{ 
  short nP ;
  short P[4] ;
  short nB ;
  short B___0[4] ;
  short i___0 ;
  short j ;
  short r ;
  short dd ;
  short occupied ;
  short mindd ;
  short c[4] ;
  short d[4] ;
  short c1___0 ;
  struct PatternField field ;
  short t ;
  short pcol ;
  short sq ;
  int tmp ;
  short psq ;
  short pc ;
  struct PatternField field___0 ;
  short psq___0 ;
  short pc___0 ;
  short sq___0 ;

  {
#line 215
  c1___0 = (short )((int )side ^ (int )pside);
#line 225
  if ((int )piece == 1) {
#line 227
    occupied = (short)0;
#line 227
    mindd = occupied;
#line 229
    i___0 = Pattern[pattern].first_field;
    {
#line 229
    while (1) {
      while_continue: /* CIL Label */ ;
#line 229
      if (! ((int )pattern_data[i___0] != -4)) {
#line 229
        goto while_break;
      }
      {
#line 234
      set_field(i___0, & field);
      }
#line 236
      if ((int )field.side == (int )side) {
#line 236
        if ((int )field.piece == 1) {
#line 238
          t = field.square;
#line 239
          pcol = (short )((int )t % 9);
#line 240
          dd = (short)-1;
#line 242
          if ((int )side == (int )c1___0) {
#line 242
            tmp = (int )pcol;
          } else {
#line 242
            tmp = 8 - (int )pcol;
          }
#line 242
          if (PawnCnt[c1___0][tmp]) {
#line 245
            j = (short)0;
            {
#line 245
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 245
              if (! ((int )j <= (int )PieceCnt[c1___0])) {
#line 245
                goto while_break___0;
              }
#line 247
              sq = (short )PieceList[c1___0][j];
#line 249
              if ((int )board[sq] == 1) {
#line 251
                if ((int )pside == 1) {
#line 252
                  sq = (short )(80 - (int )sq);
                }
#line 254
                if ((int )sq % 9 == (int )pcol) {
                  {
#line 256
                  dd = piece_distance(side, (short)1, sq, t);
                  }
#line 262
                  goto while_break___0;
                }
              }
#line 245
              j = (short )((int )j + 1);
            }
            while_break___0: /* CIL Label */ ;
            }
          } else
#line 270
          if (Captured[c1___0][1]) {
#line 272
            dd = (short)1;
          }
#line 280
          if ((int )dd >= 0) {
#line 285
            if ((int )pside == 0) {
#line 287
              psq = t;
#line 288
              pc = field.side;
            } else {
#line 292
              psq = (short )(80 - (int )t);
#line 293
              pc = (short )(~ ((int )field.side));
            }
#line 296
            if ((int )color[psq] == (int )pc) {
#line 296
              if ((int )board[psq] != 1) {
#line 301
                occupied = (short )((int )occupied + 1);
              }
            }
#line 304
            mindd = (short )((int )mindd + (int )dd);
          } else {
#line 308
            return ((short)-1);
          }
        }
      }
#line 229
      i___0 = (short )((int )i___0 + 2);
    }
    while_break: /* CIL Label */ ;
    }
#line 313
    return ((short )((int )mindd + (int )occupied));
  }
#line 320
  nP = (short)0;
#line 320
  occupied = nP;
#line 320
  i___0 = Pattern[pattern].first_field;
  {
#line 320
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 320
    if (! ((int )pattern_data[i___0] != -4)) {
#line 320
      goto while_break___1;
    }
    {
#line 325
    set_field(i___0, & field___0);
    }
#line 327
    if ((int )field___0.side == (int )side) {
#line 327
      if ((int )field___0.piece == (int )piece) {
#line 330
        P[nP] = field___0.square;
#line 334
        nP = (short )((int )nP + 1);
#line 337
        if ((int )pside == 0) {
#line 339
          psq___0 = field___0.square;
#line 340
          pc___0 = field___0.side;
        } else {
#line 344
          psq___0 = (short )(80 - (int )field___0.square);
#line 345
          pc___0 = (short )((int )field___0.side ^ 1);
        }
#line 348
        if ((int )color[psq___0] == (int )pc___0) {
#line 348
          if ((int )board[psq___0] != (int )field___0.piece) {
#line 353
            occupied = (short )((int )occupied + 1);
          }
        }
      }
    }
#line 320
    i___0 = (short )((int )i___0 + 2);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 358
  if ((int )nP == 0) {
#line 359
    return ((short)0);
  }
#line 369
  nB = (short)0;
  {
#line 369
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 369
    if (! ((int )nB < (int )Captured[c1___0][piece])) {
#line 369
      goto while_break___2;
    }
#line 370
    B___0[nB] = (short )(81 + (int )piece);
#line 369
    nB = (short )((int )nB + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 372
  i___0 = (short)0;
  {
#line 372
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 372
    if (! ((int )i___0 <= (int )PieceCnt[c1___0])) {
#line 372
      goto while_break___3;
    }
#line 374
    sq___0 = (short )PieceList[c1___0][i___0];
#line 376
    if ((int )board[sq___0] == (int )piece) {
#line 378
      if ((int )pside == 0) {
#line 378
        B___0[nB] = sq___0;
      } else {
#line 378
        B___0[nB] = (short )(80 - (int )sq___0);
      }
#line 382
      nB = (short )((int )nB + 1);
    }
#line 372
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 390
  if ((int )nP > (int )nB) {
#line 392
    return ((short)-1);
  }
#line 397
  r = (short)0;
#line 398
  c[0] = (short)-1;
#line 399
  mindd = (short)-1;
  {
#line 401
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 401
    if ((int )r >= 0) {
#line 401
      if (! ((int )mindd != 0)) {
#line 401
        goto while_break___4;
      }
    } else {
#line 401
      goto while_break___4;
    }
#line 404
    c[r] = (short )((int )c[r] + 1);
#line 404
    if ((int )c[r] == (int )nB) {
#line 406
      r = (short )((int )r - 1);
    } else {
#line 410
      i___0 = (short)0;
      {
#line 410
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 410
        if (! ((int )i___0 < (int )r)) {
#line 410
          goto while_break___5;
        }
#line 412
        if ((int )c[i___0] == (int )c[r]) {
#line 413
          goto while_break___5;
        }
#line 410
        i___0 = (short )((int )i___0 + 1);
      }
      while_break___5: /* CIL Label */ ;
      }
#line 416
      if ((int )i___0 == (int )r) {
        {
#line 418
        d[r] = piece_distance(side, piece, B___0[c[r]], P[r]);
        }
#line 423
        if (! ((int )d[r] < 0)) {
#line 429
          r = (short )((int )r + 1);
#line 429
          if ((int )r == (int )nP) {
#line 431
            i___0 = (short)0;
#line 431
            dd = i___0;
            {
#line 431
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 431
              if (! ((int )i___0 < (int )nP)) {
#line 431
                goto while_break___6;
              }
#line 432
              dd = (short )((int )dd + (int )d[i___0]);
#line 431
              i___0 = (short )((int )i___0 + 1);
            }
            while_break___6: /* CIL Label */ ;
            }
#line 434
            if ((int )dd < (int )mindd) {
#line 436
              mindd = dd;
            } else
#line 434
            if ((int )mindd < 0) {
#line 436
              mindd = dd;
            }
#line 442
            r = (short )((int )r - 1);
          } else {
#line 446
            c[r] = (short)-1;
          }
        }
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 453
  if ((int )mindd < 0) {
#line 454
    return ((short)-1);
  } else {
#line 456
    return ((short )((int )mindd + (int )occupied));
  }
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
short pattern_distance(short pside , short pattern ) 
{ 
  short side ;
  short piece ;
  short d ;
  short n ;

  {
#line 481
  side = (short)0;
#line 481
  n = side;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if ((int )side <= 1) {
#line 481
      if (! ((int )n >= 0)) {
#line 481
        goto while_break;
      }
    } else {
#line 481
      goto while_break;
    }
#line 483
    piece = (short)1;
    {
#line 483
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 483
      if (! ((int )piece <= 14)) {
#line 483
        goto while_break___0;
      }
      {
#line 485
      d = piece_to_pattern_distance(side, piece, pside, pattern);
      }
#line 487
      if ((int )d < 0) {
#line 489
        n = (short)-1;
#line 490
        goto while_break___0;
      } else {
#line 494
        n = (short )((int )n + (int )d);
      }
#line 483
      piece = (short )((int )piece + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 481
    side = (short )((int )side + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  return (n);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
short board_to_pattern_distance(short pside , short osequence , short pmplty , short GameCnt___0 ) 
{ 
  short i___0 ;
  short d ;
  short dist ;
  short diff ;
  short weighted_diff ;
  short maxdiff ;
  short max_weighted_diff ;
  short pattern ;

  {
#line 523
  maxdiff = (short)0;
#line 523
  max_weighted_diff = (short)0;
#line 526
  i___0 = (short)0;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (! ((int )i___0 < 4)) {
#line 526
      goto while_break;
    }
#line 528
    pattern = OpeningSequence[osequence].first_pattern[i___0];
    {
#line 528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 528
      if (! ((int )pattern != -2)) {
#line 528
        goto while_break___0;
      }
#line 532
      d = (short )Pattern[pattern].distance[pside];
#line 532
      if ((int )d >= 0) {
#line 534
        if ((int )pmplty > (int )d) {
          {
#line 536
          dist = pattern_distance(pside, pattern);
          }
#line 537
          if ((int )dist >= 0) {
#line 548
            diff = (short )((int )d - (int )dist);
#line 548
            weighted_diff = (short )((int )diff * ((int )pmplty - (int )d));
#line 550
            if ((int )weighted_diff > (int )max_weighted_diff) {
#line 555
              maxdiff = weighted_diff;
#line 557
              max_weighted_diff = weighted_diff;
            }
#line 565
            if ((int )dist == 0) {
#line 565
              if ((int )GameCnt___0 >= 0) {
#line 566
                Pattern[pattern].reachedGameCnt[pside] = GameCnt___0;
              }
            }
          }
        }
      }
#line 528
      pattern = Pattern[pattern].next_pattern;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 526
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 573
  return (maxdiff);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
void DisplayPattern(FILE *fd , short n ) 
{ 
  signed char pboard[81] ;
  signed char pcolor[81] ;
  short sq ;
  short i___0 ;
  short r ;
  short c ;
  struct PatternField field ;
  int tmp ;
  int tmp___0 ;

  {
#line 585
  sq = (short)0;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! ((int )sq < 81)) {
#line 585
      goto while_break;
    }
#line 587
    pboard[sq] = (signed char)0;
#line 588
    pcolor[sq] = (signed char)2;
#line 585
    sq = (short )((int )sq + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 591
  i___0 = n;
  {
#line 591
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 591
    if (! ((int )pattern_data[i___0] != -4)) {
#line 591
      goto while_break___0;
    }
    {
#line 594
    set_field(i___0, & field);
#line 595
    pboard[field.square] = (signed char )field.piece;
#line 596
    pcolor[field.square] = (signed char )field.side;
#line 591
    i___0 = (short )((int )i___0 + 2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 599
  r = (short)8;
  {
#line 599
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 599
    if (! ((int )r >= 0)) {
#line 599
      goto while_break___1;
    }
#line 601
    c = (short)0;
    {
#line 601
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if (! ((int )c < 9)) {
#line 601
        goto while_break___2;
      }
#line 603
      sq = (short )((int )r * 9 + (int )c);
#line 604
      i___0 = (short )pboard[sq];
#line 606
      if ((int )i___0 == 0) {
        {
#line 607
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" -");
        }
      } else {
#line 609
        if (pcolor[sq]) {
#line 609
          tmp = (int const   )*(" PLNSGBRPLNSBRK " + i___0);
        } else {
#line 609
          tmp = (int const   )*(" plnsgbrplnsbrk " + i___0);
        }
#line 609
        if (is_promoted[i___0]) {
#line 609
          tmp___0 = '+';
        } else {
#line 609
          tmp___0 = ' ';
        }
        {
#line 609
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c%c",
                tmp___0, tmp);
        }
      }
#line 601
      c = (short )((int )c + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 613
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 599
    r = (short )((int )r - 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 616
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
  }
#line 617
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
static void VisitReachable(int pside , short osequence , int k , int n , int remove___0 ) 
{ 
  short i___0 ;
  short j ;
  short pattern ;

  {
#line 629
  i___0 = (short)0;
#line 629
  pattern = OpeningSequence[osequence].first_pattern[k];
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! ((int )i___0 < n)) {
#line 629
      goto while_break;
    }
#line 632
    pattern = Pattern[pattern].next_pattern;
#line 629
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (Pattern[pattern].visited) {
#line 638
    return;
  } else {
#line 642
    Pattern[pattern].visited = (signed char)1;
  }
#line 646
  j = Pattern[pattern].first_link;
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 646
    if (! ((int )pattern_data[j] != -3)) {
#line 646
      goto while_break___0;
    }
    {
#line 649
    VisitReachable(pside, osequence, k, (int )pattern_data[j], remove___0);
#line 646
    j = (short )((int )j + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 653
  if (remove___0) {
#line 653
    if ((int )Pattern[pattern].distance[pside] >= 0) {
#line 655
      Pattern[pattern].distance[pside] = (signed char)-4;
    }
  }
#line 657
  return;
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
short locate_opening_sequence(short pside , char *s , short GameCnt___0 ) 
{ 
  short i___0 ;
  short j ;
  short k ;
  short os ;
  short d ;
  short l ;
  size_t tmp ;
  short check_visited[4] ;
  char name[16] ;
  char name2[16] ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  signed char tmp___3 ;

  {
  {
#line 674
  tmp = strlen((char const   *)s);
#line 674
  l = (short )tmp;
#line 682
  name[0] = (char )'\000';
#line 684
  i___0 = (short)1;
#line 684
  os = (short)0;
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! ((int )os < 14)) {
#line 684
      goto while_break;
    }
    {
#line 687
    NameOfOpeningValue(OpeningSequence[os].opening_type, name);
    }
#line 689
    if ((int )l > 8) {
#line 689
      if ((int )*(s + 0) == (int )name[0]) {
#line 689
        goto _L___8;
      } else
#line 689
      if ((int )*(s + 0) == 42) {
#line 689
        if ((int )name[0] != 85) {
#line 689
          goto _L___8;
        } else {
#line 689
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 689
      if ((int )name[0] == 42) {
#line 689
        if ((int )*(s + 0) != 85) {
          _L___8: /* CIL Label */ 
#line 689
          if ((int )*(s + 7) == (int )name[7]) {
#line 689
            goto _L___6;
          } else
#line 689
          if ((int )*(s + 7) == 42) {
#line 689
            if ((int )name[7] != 85) {
#line 689
              goto _L___6;
            } else {
#line 689
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 689
          if ((int )name[7] == 42) {
#line 689
            if ((int )*(s + 7) != 85) {
              _L___6: /* CIL Label */ 
#line 689
              if ((int )*(s + 9) == (int )name[9]) {
#line 689
                goto _L___4;
              } else
#line 689
              if ((int )*(s + 9) == 42) {
#line 689
                if ((int )name[9] != 85) {
#line 689
                  goto _L___4;
                } else {
#line 689
                  goto _L___5;
                }
              } else
              _L___5: /* CIL Label */ 
#line 689
              if ((int )name[9] == 42) {
#line 689
                if ((int )*(s + 9) != 85) {
                  _L___4: /* CIL Label */ 
#line 692
                  k = (short )((int )os + 1);
                  {
#line 692
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 692
                    if (! ((int )k < 14)) {
#line 692
                      goto while_break___0;
                    }
                    {
#line 694
                    NameOfOpeningValue(OpeningSequence[k].opening_type, name2);
                    }
#line 696
                    if ((int )l > 8) {
#line 696
                      if ((int )*(s + 0) == (int )name2[0]) {
#line 696
                        goto _L___2;
                      } else
#line 696
                      if ((int )*(s + 0) == 42) {
#line 696
                        if ((int )name2[0] != 85) {
#line 696
                          goto _L___2;
                        } else {
#line 696
                          goto _L___3;
                        }
                      } else
                      _L___3: /* CIL Label */ 
#line 696
                      if ((int )name2[0] == 42) {
#line 696
                        if ((int )*(s + 0) != 85) {
                          _L___2: /* CIL Label */ 
#line 696
                          if ((int )*(s + 7) == (int )name2[7]) {
#line 696
                            goto _L___0;
                          } else
#line 696
                          if ((int )*(s + 7) == 42) {
#line 696
                            if ((int )name2[7] != 85) {
#line 696
                              goto _L___0;
                            } else {
#line 696
                              goto _L___1;
                            }
                          } else
                          _L___1: /* CIL Label */ 
#line 696
                          if ((int )name2[7] == 42) {
#line 696
                            if ((int )*(s + 7) != 85) {
                              _L___0: /* CIL Label */ 
#line 696
                              if ((int )*(s + 9) == (int )name2[9]) {
#line 698
                                tmp___0 = i___0;
#line 698
                                i___0 = (short )((int )i___0 + 1);
#line 698
                                OpeningSequence[os].first_pattern[tmp___0] = OpeningSequence[k].first_pattern[0];
                              } else
#line 696
                              if ((int )*(s + 9) == 42) {
#line 696
                                if ((int )name2[9] != 85) {
#line 698
                                  tmp___0 = i___0;
#line 698
                                  i___0 = (short )((int )i___0 + 1);
#line 698
                                  OpeningSequence[os].first_pattern[tmp___0] = OpeningSequence[k].first_pattern[0];
                                } else {
#line 696
                                  goto _L;
                                }
                              } else
                              _L: /* CIL Label */ 
#line 696
                              if ((int )name2[9] == 42) {
#line 696
                                if ((int )*(s + 9) != 85) {
#line 698
                                  tmp___0 = i___0;
#line 698
                                  i___0 = (short )((int )i___0 + 1);
#line 698
                                  OpeningSequence[os].first_pattern[tmp___0] = OpeningSequence[k].first_pattern[0];
                                }
                              }
                            }
                          }
                        }
                      }
                    }
#line 692
                    k = (short )((int )k + 1);
                  }
                  while_break___0: /* CIL Label */ ;
                  }
#line 703
                  goto while_break;
                }
              }
            }
          }
        }
      }
    }
#line 684
    os = (short )((int )os + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  if ((int )os >= 14) {
#line 709
    return ((short)-1);
  } else {
    {
#line 713
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 713
      if (! ((int )i___0 < 4)) {
#line 713
        goto while_break___1;
      }
#line 713
      tmp___1 = i___0;
#line 713
      i___0 = (short )((int )i___0 + 1);
#line 713
      OpeningSequence[os].first_pattern[tmp___1] = (short)-2;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 723
  i___0 = (short)0;
  {
#line 723
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 723
    if (! ((int )i___0 < 4)) {
#line 723
      goto while_break___2;
    }
#line 725
    check_visited[i___0] = (short)0;
#line 727
    k = OpeningSequence[os].first_pattern[i___0];
    {
#line 727
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 727
      if (! ((int )k != -2)) {
#line 727
        goto while_break___3;
      }
#line 731
      Pattern[k].visited = (signed char)0;
#line 727
      k = Pattern[k].next_pattern;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 723
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 735
  i___0 = (short)0;
  {
#line 735
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 735
    if (! ((int )i___0 < 4)) {
#line 735
      goto while_break___4;
    }
#line 737
    k = OpeningSequence[os].first_pattern[i___0];
    {
#line 737
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 737
      if (! ((int )k != -2)) {
#line 737
        goto while_break___5;
      }
      {
#line 741
      tmp___2 = pattern_distance(pside, k);
#line 741
      Pattern[k].distance[pside] = (signed char )tmp___2;
      }
#line 744
      if ((int )Pattern[k].distance[pside] == 0) {
#line 746
        Pattern[k].distance[pside] = (signed char)-1;
#line 747
        tmp___3 = (signed char)1;
#line 747
        Pattern[k].visited = tmp___3;
#line 747
        check_visited[i___0] = (short )tmp___3;
#line 749
        j = Pattern[k].first_link;
        {
#line 749
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 749
          if (! ((int )pattern_data[j] != -3)) {
#line 749
            goto while_break___6;
          }
          {
#line 752
          VisitReachable((int )pside, os, (int )i___0, (int )pattern_data[j], 0);
#line 749
          j = (short )((int )j + 1);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 755
      if ((int )GameCnt___0 >= 0) {
#line 755
        if ((int )GameCnt___0 >= (int )Pattern[k].reachedGameCnt[pside]) {
#line 758
          Pattern[k].distance[pside] = (signed char)-3;
        }
      }
#line 761
      if ((int )Pattern[k].reachedGameCnt[pside] >= (int )GameCnt___0) {
#line 762
        Pattern[k].reachedGameCnt[pside] = (short)300;
      }
#line 737
      k = Pattern[k].next_pattern;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 735
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 772
  i___0 = (short)0;
  {
#line 772
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 772
    if (! ((int )i___0 < 4)) {
#line 772
      goto while_break___7;
    }
#line 774
    k = OpeningSequence[os].first_pattern[i___0];
    {
#line 774
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 774
      if (! ((int )k != -2)) {
#line 774
        goto while_break___8;
      }
#line 778
      if (check_visited[i___0]) {
#line 778
        if (! Pattern[k].visited) {
#line 779
          Pattern[k].distance[pside] = (signed char)-2;
        } else {
#line 781
          Pattern[k].visited = (signed char)0;
        }
      } else {
#line 781
        Pattern[k].visited = (signed char)0;
      }
#line 774
      k = Pattern[k].next_pattern;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 772
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___7: /* CIL Label */ ;
  }
#line 785
  i___0 = (short)0;
  {
#line 785
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 785
    if (! ((int )i___0 < 4)) {
#line 785
      goto while_break___9;
    }
#line 787
    k = OpeningSequence[os].first_pattern[i___0];
    {
#line 787
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 787
      if (! ((int )k != -2)) {
#line 787
        goto while_break___10;
      }
#line 791
      d = (short )Pattern[k].distance[pside];
#line 791
      if ((int )d >= 0) {
#line 793
        j = Pattern[k].first_link;
        {
#line 793
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 793
          if (! ((int )pattern_data[j] != -3)) {
#line 793
            goto while_break___11;
          }
          {
#line 796
          VisitReachable((int )pside, os, (int )i___0, (int )pattern_data[j], 1);
#line 793
          j = (short )((int )j + 1);
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 787
      k = Pattern[k].next_pattern;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 785
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
#line 806
  i___0 = (short)0;
  {
#line 806
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 806
    if (! ((int )i___0 < 4)) {
#line 806
      goto while_break___12;
    }
#line 808
    k = OpeningSequence[os].first_pattern[i___0];
    {
#line 808
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 808
      if (! ((int )k != -2)) {
#line 808
        goto while_break___13;
      }
#line 812
      d = (short )Pattern[k].distance[pside];
#line 812
      if ((int )d >= 0) {
#line 813
        return (os);
      }
#line 808
      k = Pattern[k].next_pattern;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 806
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___12: /* CIL Label */ ;
  }
#line 817
  return ((short)-1);
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.c"
void update_advance_bonus(short pside , short os ) 
{ 
  struct PatternField field ;
  short i___0 ;
  short j ;
  short k ;
  short d ;
  short square ;
  int tmp ;

  {
#line 829
  j = (short)0;
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    if (! ((int )j < 4)) {
#line 829
      goto while_break;
    }
#line 831
    k = OpeningSequence[os].first_pattern[j];
    {
#line 831
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 831
      if (! ((int )k != -2)) {
#line 831
        goto while_break___0;
      }
#line 835
      d = (short )Pattern[k].distance[pside];
#line 835
      if ((int )d >= 0) {
#line 837
        i___0 = Pattern[k].first_field;
        {
#line 837
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 837
          if (! ((int )pattern_data[i___0] != -4)) {
#line 837
            goto while_break___1;
          }
          {
#line 840
          set_field(i___0, & field);
          }
#line 841
          if ((int )field.side == 0) {
#line 843
            if ((int )pside == 0) {
#line 843
              tmp = (int )field.square;
            } else {
#line 843
              tmp = 80 - (int )field.square;
            }
#line 843
            square = (short )tmp;
#line 847
            (*(Mpiece[field.piece]))[pside][square] = (signed char )((int )(*(Mpiece[field.piece]))[pside][square] + (int )ADVNCM[field.piece]);
          }
#line 837
          i___0 = (short )((int )i___0 + 2);
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 831
      k = Pattern[k].next_pattern;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 829
    j = (short )((int )j + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  return;
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
display_t display_type ;
#line 68
short barebones ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 720 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int EADD ;
#line 721
int EGET ;
#line 917
void NewGame(void) ;
#line 1054
void ExitShogi(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.h"
void Raw_ChangeAlphaWindow(void) ;
#line 43
void Raw_ChangeBetaWindow(void) ;
#line 44
void Raw_ChangeHashDepth(void) ;
#line 45
void Raw_ChangeSearchDepth(void) ;
#line 46
void Raw_ChangeXwindow(void) ;
#line 47
void Raw_ClearScreen(void) ;
#line 48
void Raw_Die(int sig ) ;
#line 49
void Raw_DoDebug(void) ;
#line 50
void Raw_DoTable(short *table ) ;
#line 51
void Raw_EditBoard(void) ;
#line 52
void Raw_ExitShogi(void) ;
#line 53
void Raw_GiveHint(void) ;
#line 54
void Raw_Initialize(void) ;
#line 55
void Raw_ShowNodeCnt(long NodeCnt___0 ) ;
#line 56
void Raw_OutputMove(void) ;
#line 57
void Raw_PollForInput(void) ;
#line 58
void Raw_SearchStartStuff(short side ) ;
#line 59
void Raw_SelectLevel(char *sx ) ;
#line 60
void Raw_SetContempt(void) ;
#line 61
void Raw_ShowCurrentMove(short pnt___2 , short f , short t ) ;
#line 62
void Raw_ShowDepth(char ch ) ;
#line 63
void Raw_ShowGameType(void) ;
#line 64
void Raw_ShowLine(unsigned short *bstline ) ;
#line 65
void Raw_ShowMessage(char *s ) ;
#line 66
void Raw_AlwaysShowMessage(char const   *format , va_list ap ) ;
#line 67
void Raw_Printf(char const   *format , va_list ap ) ;
#line 68
void Raw_doRequestInputString(char const   *fmt___0 , char *buffer___1 ) ;
#line 69
int Raw_GetString(char *sx ) ;
#line 70
void Raw_SetupBoard(void) ;
#line 71
void Raw_ShowPatternCount(short side , short n ) ;
#line 72
void Raw_ShowPostnValue(short sq ) ;
#line 73
void Raw_ShowPostnValues(void) ;
#line 74
void Raw_ShowPrompt(void) ;
#line 75
void Raw_ShowResponseTime(void) ;
#line 76
void Raw_ShowResults(short score___0 , unsigned short *bstline , char ch ) ;
#line 77
void Raw_ShowSidetoMove(void) ;
#line 78
void Raw_ShowStage(void) ;
#line 79
void Raw_TerminateSearch(int sig ) ;
#line 80
void Raw_UpdateClocks(void) ;
#line 81
void Raw_UpdateDisplay(short f , short t , short redraw , short isspec ) ;
#line 82
void Raw_help(void) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ClearScreen(void) 
{ 


  {
#line 63
  if (! barebones) {
#line 63
    if (! ((unsigned int )display_type == 2U)) {
      {
#line 64
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowPrompt(void) 
{ 


  {
#line 71
  if (! barebones) {
#line 71
    if (! ((unsigned int )display_type == 2U)) {
      {
#line 73
      fputs((char const   */* __restrict  */)"\nYour move is? ", (FILE */* __restrict  */)stdout);
      }
    }
  }
#line 75
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowCurrentMove(short pnt___2 , short f , short t ) 
{ 


  {
#line 81
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowDepth(char ch ) 
{ 


  {
#line 87
  if (! barebones) {
#line 87
    if (! ((unsigned int )display_type == 2U)) {
      {
#line 89
      printf((char const   */* __restrict  */)"Depth= %d%c ", (int )Sdepth, (int )ch);
#line 90
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowGameType(void) 
{ 


  {
#line 98
  if (flag.post) {
    {
#line 99
    printf((char const   */* __restrict  */)"%c vs. %c\n", (int )GameType[0], (int )GameType[1]);
    }
  }
#line 100
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowLine(unsigned short *bstline ) 
{ 
  int i___0 ;

  {
#line 108
  i___0 = 1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((int )*(bstline + i___0) > 0)) {
#line 108
      goto while_break;
    }
#line 110
    if (i___0 > 1) {
#line 110
      if (i___0 % 8 == 1) {
        {
#line 111
        printf((char const   */* __restrict  */)"\n                          ");
        }
      }
    }
    {
#line 113
    algbr((short )((int )*(bstline + i___0) >> 8), (short )((int )*(bstline + i___0) & 255),
          (short)0);
#line 114
    printf((char const   */* __restrict  */)"%5s ", mvstr[0]);
#line 108
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  printf((char const   */* __restrict  */)"\n");
  }
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowMessage(char *s ) 
{ 


  {
#line 124
  if (! ((unsigned int )display_type == 2U)) {
    {
#line 125
    printf((char const   */* __restrict  */)"%s\n", s);
    }
  }
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_AlwaysShowMessage(char const   *format , va_list ap ) 
{ 


  {
  {
#line 132
  vprintf((char const   */* __restrict  */)format, ap);
#line 133
  printf((char const   */* __restrict  */)"\n");
  }
#line 134
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_Printf(char const   *format , va_list ap ) 
{ 


  {
  {
#line 140
  vprintf((char const   */* __restrict  */)format, ap);
  }
#line 141
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_doRequestInputString(char const   *fmt___0 , char *buffer___1 ) 
{ 


  {
  {
#line 147
  scanf((char const   */* __restrict  */)fmt___0, buffer___1);
  }
#line 148
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
int Raw_GetString(char *sx ) 
{ 
  int eof ;
  char *tmp ;

  {
#line 154
  eof = 0;
#line 155
  *(sx + 0) = (char )'\000';
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! eof) {
#line 157
      if (! (! *(sx + 0))) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = fgets((char */* __restrict  */)sx, 80, (FILE */* __restrict  */)stdin);
#line 158
    eof = (unsigned long )tmp == (unsigned long )((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (eof);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowNodeCnt(long NodeCnt___0 ) 
{ 
  long tmp ;

  {
#line 166
  if (et) {
#line 166
    tmp = (NodeCnt___0 * 100L) / et;
  } else {
#line 166
    tmp = 0L;
  }
  {
#line 166
  printf((char const   */* __restrict  */)"Nodes = %ld Nodes/sec = %ld\n", NodeCnt___0,
         tmp);
  }
#line 168
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowPatternCount(short side , short n ) 
{ 


  {
#line 174
  if (flag.post) {
    {
#line 175
    printf((char const   */* __restrict  */)"%s matches %d pattern(s)\n", ColorStr[side],
           (int )n);
    }
  }
#line 176
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowResponseTime(void) 
{ 


  {
#line 182
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowResults(short score___0 , unsigned short *bstline , char ch ) 
{ 


  {
#line 188
  if (flag.post) {
#line 188
    if (! ((unsigned int )display_type == 2U)) {
      {
#line 190
      ElapsedTime((ElapsedTime_mode )2);
#line 191
      printf((char const   */* __restrict  */)"%2d%c %6d %4ld %8ld  ", (int )Sdepth,
             (int )ch, (int )score___0, et / 100L, NodeCnt);
#line 193
      Raw_ShowLine(bstline);
      }
    }
  }
#line 195
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowSidetoMove(void) 
{ 


  {
#line 201
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowStage(void) 
{ 


  {
  {
#line 207
  printf((char const   */* __restrict  */)"stage = %d\n", (int )stage);
#line 208
  printf((char const   */* __restrict  */)"balance[black] = %d balance[white] = %d\n",
         (int )balance[0], (int )balance[1]);
  }
#line 210
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_Initialize(void) 
{ 


  {
#line 219
  mycnt2 = 0;
#line 219
  mycnt1 = mycnt2;
#line 221
  if ((unsigned int )display_type == 2U) {
    {
#line 228
    setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0),
            1, (size_t )8192);
#line 237
    printf((char const   */* __restrict  */)"GNU Shogi %s\n", "1.4.1");
    }
  }
#line 240
  if (hard_time_limit) {
#line 242
    if (! TCflag) {
#line 242
      if (MaxResponseTime == 0L) {
#line 243
        MaxResponseTime = 1500L;
      }
    }
  }
#line 245
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ExitShogi(void) 
{ 


  {
  {
#line 252
  signal(15, (void (*)(int  ))1);
  }
#line 254
  if (! nolist) {
    {
#line 255
    ListGame();
    }
  }
  {
#line 257
  exit(0);
  }
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_Die(int sig ) 
{ 
  char s[80] ;
  int tmp ;

  {
  {
#line 266
  Raw_ShowMessage((char *)"Abort? ");
#line 267
  scanf((char const   */* __restrict  */)"%s", s);
#line 269
  tmp = strcmp((char const   *)(s), "yes");
  }
#line 269
  if (tmp == 0) {
    {
#line 270
    Raw_ExitShogi();
    }
  }
#line 271
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_TerminateSearch(int sig ) 
{ 


  {
#line 281
  if (! flag.timeout) {
#line 282
    flag.back = (short)1;
  }
#line 284
  flag.bothsides = (short)0;
#line 285
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_help(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
  {
#line 291
  Raw_ClearScreen();
#line 292
  printf((char const   */* __restrict  */)"GNU Shogi %s command summary\n", "1.4.1");
#line 293
  printf((char const   */* __restrict  */)"----------------------------------------------------------------\n");
#line 295
  fputs((char const   */* __restrict  */)"7g7f      move from 7g to 7f      quit      Exit Shogi\n",
        (FILE */* __restrict  */)stdout);
  }
#line 296
  if (flag.beep) {
#line 296
    tmp = "OFF";
  } else {
#line 296
    tmp = "ON";
  }
  {
#line 296
  printf((char const   */* __restrict  */)"S6h       move silver to 6h       beep      turn %s\n",
         tmp);
  }
#line 297
  if (flag.material) {
#line 297
    tmp___0 = "OFF";
  } else {
#line 297
    tmp___0 = "ON";
  }
  {
#line 297
  printf((char const   */* __restrict  */)"2d2c+     move to 2c and promote  material  turn %s\n",
         tmp___0);
  }
#line 298
  if (flag.easy) {
#line 298
    tmp___1 = "OFF";
  } else {
#line 298
    tmp___1 = "ON";
  }
  {
#line 298
  printf((char const   */* __restrict  */)"P*5e      drop pawn to 5e         easy      turn %s\n",
         tmp___1);
  }
#line 299
  if (flag.hash) {
#line 299
    tmp___2 = "OFF";
  } else {
#line 299
    tmp___2 = "ON";
  }
  {
#line 299
  printf((char const   */* __restrict  */)"tsume     toggle tsume mode       hash      turn %s\n",
         tmp___2);
#line 300
  fputs((char const   */* __restrict  */)"bd        redraw board            reverse   board display\n",
        (FILE */* __restrict  */)stdout);
  }
#line 301
  if (Book) {
#line 301
    tmp___3 = "OFF";
  } else {
#line 301
    tmp___3 = "ON";
  }
  {
#line 301
  printf((char const   */* __restrict  */)"list      game to shogi.lst       book      turn %s used %d of %d\n",
         tmp___3, bookcount, booksize);
#line 302
  fputs((char const   */* __restrict  */)"undo      undo last ply           remove    take back a move\n",
        (FILE */* __restrict  */)stdout);
#line 303
  fputs((char const   */* __restrict  */)"edit      edit board              force     toggle manual move mode\n",
        (FILE */* __restrict  */)stdout);
#line 304
  fputs((char const   */* __restrict  */)"switch    sides with computer     both      computer match\n",
        (FILE */* __restrict  */)stdout);
#line 305
  fputs((char const   */* __restrict  */)"black     computer plays black    white     computer plays white\n",
        (FILE */* __restrict  */)stdout);
#line 306
  fputs((char const   */* __restrict  */)"depth     set search depth        clock     set time control\n",
        (FILE */* __restrict  */)stdout);
#line 307
  fputs((char const   */* __restrict  */)"post      principle variation     hint      suggest a move\n",
        (FILE */* __restrict  */)stdout);
#line 308
  fputs((char const   */* __restrict  */)"save      game to file            get       game from file\n",
        (FILE */* __restrict  */)stdout);
#line 309
  printf((char const   */* __restrict  */)"xsave     pos. to xshogi file     xget      pos. from xshogi file\n");
#line 311
  fputs((char const   */* __restrict  */)"random    randomize play          new       start new game\n",
        (FILE */* __restrict  */)stdout);
#line 312
  printf((char const   */* __restrict  */)"----------------------------------------------------------------\n");
#line 314
  printf((char const   */* __restrict  */)"Computer: %-12s Opponent:            %s\n",
         ColorStr[computer], ColorStr[opponent]);
#line 316
  printf((char const   */* __restrict  */)"Depth:    %-12d Response time:       %d sec\n",
         (int )MaxSearchDepth, MaxResponseTime / 100L);
  }
#line 318
  if (flag.easy) {
#line 318
    tmp___4 = "ON";
  } else {
#line 318
    tmp___4 = "OFF";
  }
#line 318
  if (dither) {
#line 318
    tmp___5 = "ON";
  } else {
#line 318
    tmp___5 = "OFF";
  }
  {
#line 318
  printf((char const   */* __restrict  */)"Random:   %-12s Easy mode:           %s\n",
         tmp___5, tmp___4);
  }
#line 320
  if (flag.hash) {
#line 320
    tmp___6 = "ON";
  } else {
#line 320
    tmp___6 = "OFF";
  }
#line 320
  if (flag.beep) {
#line 320
    tmp___7 = "ON";
  } else {
#line 320
    tmp___7 = "OFF";
  }
  {
#line 320
  printf((char const   */* __restrict  */)"Beep:     %-12s Transposition file:  %s\n",
         tmp___7, tmp___6);
  }
#line 322
  if (flag.force) {
#line 322
    tmp___8 = "ON";
  } else {
#line 322
    tmp___8 = "OFF";
  }
#line 322
  if (flag.tsume) {
#line 322
    tmp___9 = "ON";
  } else {
#line 322
    tmp___9 = "OFF";
  }
  {
#line 322
  printf((char const   */* __restrict  */)"Tsume:    %-12s Force:               %s\n",
         tmp___9, tmp___8);
  }
#line 324
  if (TCflag) {
#line 324
    tmp___10 = "ON";
  } else {
#line 324
    tmp___10 = "OFF";
  }
  {
#line 324
  printf((char const   */* __restrict  */)"Time Control %s %d moves %d sec %d add %d depth\n",
         tmp___10, (int )TimeControl.moves[0], TimeControl.clock[0] / 100L, TCadd / 100,
         (int )MaxSearchDepth);
  }
#line 328
  return;
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_EditBoard(void) 
{ 
  short a ;
  short r ;
  short c ;
  short sq ;
  short i___0 ;
  short found ;
  char s[80] ;

  {
  {
#line 341
  flag.regularstart = (short)1;
#line 342
  Book = 20;
#line 343
  Raw_ClearScreen();
#line 344
  Raw_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
#line 345
  fputs((char const   */* __restrict  */)".   Exit to main\n", (FILE */* __restrict  */)stdout);
#line 346
  fputs((char const   */* __restrict  */)"#   Clear board\n", (FILE */* __restrict  */)stdout);
#line 347
  fputs((char const   */* __restrict  */)"c   Change sides\n", (FILE */* __restrict  */)stdout);
#line 348
  fputs((char const   */* __restrict  */)"enter piece & location: \n", (FILE */* __restrict  */)stdout);
#line 350
  a = (short)0;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 354
    scanf((char const   */* __restrict  */)"%s", s);
#line 355
    found = (short)0;
    }
#line 357
    if ((int )s[0] == 35) {
#line 359
      sq = (short)0;
      {
#line 359
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 359
        if (! ((int )sq < 81)) {
#line 359
          goto while_break___0;
        }
#line 361
        board[sq] = (signed char)0;
#line 362
        color[sq] = (signed char)2;
#line 359
        sq = (short )((int )sq + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 365
      memset((void *)((char *)(Captured)), 0, sizeof(Captured));
      }
    }
#line 368
    if ((int )s[0] == 99) {
#line 369
      a = (short )otherside[a];
    }
#line 371
    if ((int )s[1] == 42) {
#line 373
      i___0 = (short)1;
      {
#line 373
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 373
        if (! ((int )i___0 <= 14)) {
#line 373
          goto while_break___1;
        }
#line 375
        if ((int )s[0] == (int )*(" PLNSGBRPLNSBRK " + i___0)) {
#line 377
          Captured[a][i___0] = (signed char )((int )Captured[a][i___0] + 1);
#line 378
          found = (short)1;
#line 379
          goto while_break___1;
        } else
#line 375
        if ((int )s[0] == (int )*(" plnsgbrplnsbrk " + i___0)) {
#line 377
          Captured[a][i___0] = (signed char )((int )Captured[a][i___0] + 1);
#line 378
          found = (short)1;
#line 379
          goto while_break___1;
        }
#line 373
        i___0 = (short )((int )i___0 + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 383
      c = (short)-1;
#line 384
      r = (short)-1;
    } else {
#line 388
      c = (short )(57 - (int )s[1]);
#line 389
      r = (short )(105 - (int )s[2]);
    }
#line 392
    if ((int )c >= 0) {
#line 392
      if ((int )c < 9) {
#line 392
        if ((int )r >= 0) {
#line 392
          if ((int )r < 9) {
#line 394
            sq = (short )((int )r * 9 + (int )c);
#line 395
            color[sq] = (signed char )a;
#line 396
            board[sq] = (signed char)0;
#line 398
            i___0 = (short)0;
            {
#line 398
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 398
              if (! ((int )i___0 <= 14)) {
#line 398
                goto while_break___2;
              }
#line 400
              if ((int )s[0] == (int )*(" PLNSGBRPLNSBRK " + i___0)) {
#line 400
                goto _L;
              } else
#line 400
              if ((int )s[0] == (int )*(" plnsgbrplnsbrk " + i___0)) {
                _L: /* CIL Label */ 
#line 402
                if ((int )s[3] == 43) {
#line 403
                  board[sq] = (signed char )promoted[i___0];
                } else {
#line 405
                  board[sq] = (signed char )i___0;
                }
#line 407
                found = (short)1;
#line 408
                goto while_break___2;
              }
#line 398
              i___0 = (short )((int )i___0 + 1);
            }
            while_break___2: /* CIL Label */ ;
            }
#line 412
            if ((int )found == 0) {
#line 413
              color[sq] = (signed char)2;
            }
          }
        }
      }
    }
#line 352
    if (! ((int )s[0] != 46)) {
#line 352
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  sq = (short)0;
  {
#line 418
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 418
    if (! ((int )sq < 81)) {
#line 418
      goto while_break___3;
    }
#line 419
    if ((int )board[sq] != (int )Stboard[sq]) {
#line 419
      Mvboard[sq] = (signed char)10;
    } else {
#line 419
      Mvboard[sq] = (signed char)0;
    }
#line 418
    sq = (short )((int )sq + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 421
  GameCnt = (short)0;
#line 422
  Game50 = (short)1;
#line 423
  ZeroRPT();
#line 424
  Sdepth = (short)0;
#line 425
  InitializeStats();
#line 426
  Raw_ClearScreen();
#line 427
  Raw_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
  }
#line 428
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_SetupBoard(void) 
{ 
  short r ;
  short c ;
  short sq ;
  short i___0 ;
  char ch ;
  char s[80] ;

  {
  {
#line 443
  NewGame();
#line 445
  fgets((char */* __restrict  */)(s), 80, (FILE */* __restrict  */)stdin);
#line 447
  r = (short)8;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! ((int )r >= 0)) {
#line 447
      goto while_break;
    }
    {
#line 449
    fgets((char */* __restrict  */)(s), 80, (FILE */* __restrict  */)stdin);
#line 451
    c = (short)0;
    }
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! ((int )c <= 8)) {
#line 451
        goto while_break___0;
      }
#line 453
      ch = s[c];
#line 454
      sq = (short )((int )r * 9 + (int )c);
#line 455
      color[sq] = (signed char)2;
#line 456
      board[sq] = (signed char)0;
#line 458
      i___0 = (short)0;
      {
#line 458
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 458
        if (! ((int )i___0 <= 14)) {
#line 458
          goto while_break___1;
        }
#line 460
        if ((int )ch == (int )*(" PLNSGBRPLNSBRK " + i___0)) {
#line 462
          color[sq] = (signed char)1;
#line 463
          board[sq] = (signed char )i___0;
#line 464
          goto while_break___1;
        } else
#line 466
        if ((int )ch == (int )*(" plnsgbrplnsbrk " + i___0)) {
#line 468
          color[sq] = (signed char)0;
#line 469
          board[sq] = (signed char )i___0;
#line 470
          goto while_break___1;
        }
#line 458
        i___0 = (short )((int )i___0 + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 451
      c = (short )((int )c + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 447
    r = (short )((int )r - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  sq = (short)0;
  {
#line 476
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 476
    if (! ((int )sq < 81)) {
#line 476
      goto while_break___2;
    }
#line 477
    if ((int )board[sq] != (int )Stboard[sq]) {
#line 477
      Mvboard[sq] = (signed char)10;
    } else {
#line 477
      Mvboard[sq] = (signed char)0;
    }
#line 476
    sq = (short )((int )sq + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 479
  InitializeStats();
#line 480
  Raw_ClearScreen();
#line 481
  Raw_UpdateDisplay((short)0, (short)0, (short)1, (short)0);
#line 482
  fputs((char const   */* __restrict  */)"Setup successful\n", (FILE */* __restrict  */)stdout);
  }
#line 483
  return;
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_SearchStartStuff(short side ) 
{ 


  {
#line 489
  if (flag.post) {
    {
#line 491
    printf((char const   */* __restrict  */)"\nMove# %d    Target = %ld    Clock: %ld\n",
           (int )GameCnt / 2 + 1, ResponseTime, TimeControl.clock[side]);
    }
  }
#line 495
  return;
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_OutputMove(void) 
{ 
  short h ;
  short l ;
  short t ;
  long tmp ;

  {
#line 501
  if (flag.illegal) {
    {
#line 503
    printf((char const   */* __restrict  */)"Illegal position.\n");
    }
#line 504
    return;
  }
#line 507
  if ((int )mvstr[0][0] == 0) {
#line 508
    goto nomove;
  }
#line 510
  if ((unsigned int )display_type == 2U) {
    {
#line 513
    mycnt1 ++;
#line 513
    printf((char const   */* __restrict  */)"%d. ... %s %ld\n", mycnt1, mvstr[0],
           (TimeControl.clock[player] - et) * 10L);
    }
  } else {
    {
#line 518
    mycnt1 ++;
#line 518
    printf((char const   */* __restrict  */)"%d. ... %s\n", mycnt1, mvstr[0]);
    }
  }
  nomove: 
#line 522
  if ((int )root->flags & 1024) {
#line 524
    goto summary;
  } else
#line 522
  if ((int )root->score == -12999) {
#line 524
    goto summary;
  } else
#line 522
  if ((int )root->score == 12998) {
#line 524
    goto summary;
  }
#line 526
  if (flag.post) {
#line 530
    h = (short)4000;
#line 531
    l = (short)0;
#line 532
    t = (short )(4000 >> 1);
    {
#line 534
    while (1) {
      while_continue: /* CIL Label */ ;
#line 534
      if (! ((int )l != (int )t)) {
#line 534
        goto while_break;
      }
#line 536
      if ((Tree + t)->f) {
#line 537
        l = t;
      } else
#line 536
      if ((Tree + t)->t) {
#line 537
        l = t;
      } else {
#line 539
        h = t;
      }
#line 541
      t = (short )(((int )l + (int )h) >> 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 544
    if (et > 100L) {
#line 544
      tmp = NodeCnt / (et / 100L);
    } else {
#line 544
      tmp = 0L;
    }
    {
#line 544
    printf((char const   */* __restrict  */)"Gen %ld Node %ld Tree %d Eval %ld Rate %ld EC %d/%d RS hi %ld lo %ld \n",
           GenCnt, NodeCnt, (int )t, EvalNodes, tmp, EADD, EGET, reminus, replus);
#line 548
    printf((char const   */* __restrict  */)"Hin/Hout/Tcol/Coll/Fin/Fout = %ld/%ld/%ld/%ld/%ld/%ld\n",
           HashAdd, HashCnt, THashCol, HashCol, FHashCnt, FHashAdd);
    }
  }
  {
#line 552
  Raw_UpdateDisplay((short )root->f, (short )root->t, (short)0, (short )root->flags);
  }
#line 554
  if (! ((unsigned int )display_type == 2U)) {
    {
#line 556
    printf((char const   */* __restrict  */)"My move is: %5s\n", mvstr[0]);
    }
#line 558
    if (flag.beep) {
      {
#line 559
      printf((char const   */* __restrict  */)"%c", 7);
      }
    }
  }
  summary: 
#line 563
  if ((int )root->flags & 1024) {
    {
#line 565
    fputs((char const   */* __restrict  */)"Drawn game!\n", (FILE */* __restrict  */)stdout);
    }
  } else
#line 567
  if ((int )root->score == -12999) {
    {
#line 569
    printf((char const   */* __restrict  */)"%s mates!\n", ColorStr[opponent]);
    }
  } else
#line 571
  if ((int )root->score == 12998) {
    {
#line 573
    printf((char const   */* __restrict  */)"%s mates!\n", ColorStr[computer]);
    }
  } else
#line 576
  if (! barebones) {
#line 576
    if ((int )root->score < -12000) {
      {
#line 578
      printf((char const   */* __restrict  */)"%s has a forced mate in %d moves!\n",
             ColorStr[opponent], (12999 + (int )root->score) - 1);
      }
    } else {
#line 576
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 581
  if (! barebones) {
#line 581
    if ((int )root->score > 12000) {
      {
#line 583
      printf((char const   */* __restrict  */)"%s has a forced mate in %d moves!\n",
             ColorStr[computer], (12998 - (int )root->score) - 1);
      }
    }
  }
#line 587
  return;
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_UpdateClocks(void) 
{ 


  {
#line 593
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_UpdateDisplay(short f , short t , short redraw , short isspec ) 
{ 
  short r ;
  short c ;
  short l ;
  short m ;
  char pc ;
  short side ;
  short piece ;
  short c___0 ;
  char const   *tmp ;

  {
#line 602
  if (redraw) {
#line 602
    if (! ((unsigned int )display_type == 2U)) {
      {
#line 604
      printf((char const   */* __restrict  */)"\n");
#line 605
      r = (short )(TimeControl.clock[0] / 6000L);
#line 606
      c = (short )((TimeControl.clock[0] % 6000L) / 100L);
#line 607
      l = (short )(TimeControl.clock[1] / 6000L);
#line 608
      m = (short )((TimeControl.clock[1] % 6000L) / 100L);
#line 609
      printf((char const   */* __restrict  */)"Black %d:%02d  White %d:%02d\n", (int )r,
             (int )c, (int )l, (int )m);
#line 610
      printf((char const   */* __restrict  */)"\n");
#line 612
      r = (short)8;
      }
      {
#line 612
      while (1) {
        while_continue: /* CIL Label */ ;
#line 612
        if (! ((int )r >= 0)) {
#line 612
          goto while_break;
        }
#line 614
        c = (short)0;
        {
#line 614
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 614
          if (! ((int )c <= 8)) {
#line 614
            goto while_break___0;
          }
#line 617
          if (flag.reverse) {
#line 617
            l = (short )(((8 - (int )r) * 9 + 8) - (int )c);
          } else {
#line 617
            l = (short )((int )r * 9 + (int )c);
          }
#line 620
          if (is_promoted[board[l]]) {
#line 620
            pc = (char )'+';
          } else {
#line 620
            pc = (char )' ';
          }
#line 622
          if ((int )color[l] == 2) {
            {
#line 623
            printf((char const   */* __restrict  */)" -");
            }
          } else
#line 624
          if ((int )color[l] == 0) {
            {
#line 625
            printf((char const   */* __restrict  */)"%c%c", (int )pc, (int const   )*(" plnsgbrplnsbrk " + board[l]));
            }
          } else {
            {
#line 627
            printf((char const   */* __restrict  */)"%c%c", (int )pc, (int const   )*(" PLNSGBRPLNSBRK " + board[l]));
            }
          }
#line 614
          c = (short )((int )c + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 630
        printf((char const   */* __restrict  */)"\n");
#line 612
        r = (short )((int )r - 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 633
      printf((char const   */* __restrict  */)"\n");
#line 637
      side = (short)0;
      }
      {
#line 637
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 637
        if (! ((int )side <= 1)) {
#line 637
          goto while_break___1;
        }
#line 640
        if ((int )side == 0) {
#line 640
          tmp = "black ";
        } else {
#line 640
          tmp = "white ";
        }
        {
#line 640
        printf((char const   */* __restrict  */)tmp);
#line 642
        piece = (short)1;
        }
        {
#line 642
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 642
          if (! ((int )piece <= 14)) {
#line 642
            goto while_break___2;
          }
#line 644
          c___0 = (short )Captured[side][piece];
#line 644
          if (c___0) {
            {
#line 645
            printf((char const   */* __restrict  */)"%i%c ", (int )c___0, (int const   )*(" PLNSGBRPLNSBRK " + piece));
            }
          }
#line 642
          piece = (short )((int )piece + 1);
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 648
        printf((char const   */* __restrict  */)"\n");
#line 637
        side = (short )((int )side + 1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 652
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ChangeAlphaWindow(void) 
{ 


  {
  {
#line 658
  printf((char const   */* __restrict  */)"WAwindow: ");
#line 659
  scanf((char const   */* __restrict  */)"%hd", & WAwindow);
#line 660
  printf((char const   */* __restrict  */)"BAwindow: ");
#line 661
  scanf((char const   */* __restrict  */)"%hd", & BAwindow);
  }
#line 662
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ChangeBetaWindow(void) 
{ 


  {
  {
#line 668
  printf((char const   */* __restrict  */)"WBwindow: ");
#line 669
  scanf((char const   */* __restrict  */)"%hd", & WBwindow);
#line 670
  printf((char const   */* __restrict  */)"BBwindow: ");
#line 671
  scanf((char const   */* __restrict  */)"%hd", & BBwindow);
  }
#line 672
  return;
}
}
#line 675 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_GiveHint(void) 
{ 


  {
#line 678
  if (hint) {
    {
#line 680
    algbr((short )((int )hint >> 8), (short )((int )hint & 255), (short)0);
#line 681
    printf((char const   */* __restrict  */)"Hint: %s\n", mvstr[0]);
    }
  } else {
    {
#line 684
    fputs((char const   */* __restrict  */)"I have no idea.\n", (FILE */* __restrict  */)stdout);
    }
  }
#line 685
  return;
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_SelectLevel(char *sx ) 
{ 
  char T[82] ;
  char *p ;
  char *q ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 694
  p = strstr((char const   *)sx, "level");
  }
#line 694
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 695
    tmp = strlen("level");
#line 695
    p += tmp;
    }
  } else {
    {
#line 696
    p = strstr((char const   *)sx, "clock");
    }
#line 696
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 697
      tmp___0 = strlen("clock");
#line 697
      p += tmp___0;
      }
    }
  }
  {
#line 699
  strcat((char */* __restrict  */)sx, (char const   */* __restrict  */)"XX");
#line 700
  q = T;
#line 701
  *q = (char )'\000';
  }
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! ((int )*p != 88)) {
#line 703
      goto while_break;
    }
#line 703
    tmp___1 = q;
#line 703
    q ++;
#line 703
    tmp___2 = p;
#line 703
    p ++;
#line 703
    *tmp___1 = *tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  *q = (char )'\000';
#line 708
  if (! T[0]) {
    {
#line 710
    fputs((char const   */* __restrict  */)"Enter #moves #minutes: ", (FILE */* __restrict  */)stdout);
#line 711
    fgets((char */* __restrict  */)(T), 82, (FILE */* __restrict  */)stdin);
#line 712
    strcat((char */* __restrict  */)(T), (char const   */* __restrict  */)"XX");
    }
  }
#line 716
  p = T;
  {
#line 716
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 716
    if (! ((int )*p == 32)) {
#line 716
      goto while_break___0;
    }
#line 716
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 719
  if ((int )*p == 102) {
    {
#line 722
    p ++;
#line 723
    tmp___3 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                     10);
#line 723
    TCminutes = (short )tmp___3;
#line 724
    tmp___4 = strtol((char const   */* __restrict  */)q, (char **/* __restrict  */)((void *)0),
                     10);
#line 724
    TCadd = (int )((short )tmp___4) * 100;
#line 725
    TCseconds = (short)0;
#line 726
    TCmoves = (short)50;
    }
  } else {
    {
#line 731
    TCadd = 0;
#line 732
    tmp___5 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                     10);
#line 732
    TCmoves = (short )tmp___5;
#line 733
    tmp___6 = strtol((char const   */* __restrict  */)q, (char **/* __restrict  */)(& q),
                     10);
#line 733
    TCminutes = (short )tmp___6;
    }
#line 735
    if ((int )*q == 58) {
      {
#line 736
      tmp___7 = strtol((char const   */* __restrict  */)(q + 1), (char **/* __restrict  */)((char **)((void *)0)),
                       10);
#line 736
      TCseconds = (short )tmp___7;
      }
    } else {
#line 738
      TCseconds = (short)0;
    }
#line 745
    if ((int )TCmoves == 0) {
#line 747
      TCflag = (short)0;
#line 748
      MaxResponseTime = ((long )TCminutes * 60L) * 100L + (long )TCseconds * 100L;
#line 749
      TCseconds = (short)0;
#line 749
      TCminutes = TCseconds;
    } else {
#line 753
      TCflag = (short)1;
#line 754
      MaxResponseTime = 0L;
    }
  }
  {
#line 758
  TimeControl.clock[1] = 0L;
#line 758
  TimeControl.clock[0] = TimeControl.clock[1];
#line 759
  SetTimeControl();
  }
#line 761
  if ((unsigned int )display_type == 2U) {
    {
#line 763
    printf((char const   */* __restrict  */)"Clocks: %ld %ld\n", TimeControl.clock[0] * 10L,
           TimeControl.clock[1] * 10L);
    }
  }
#line 767
  return;
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ChangeSearchDepth(void) 
{ 


  {
  {
#line 773
  printf((char const   */* __restrict  */)"depth = ");
#line 774
  scanf((char const   */* __restrict  */)"%hd", & MaxSearchDepth);
#line 775
  TCflag = (short )(! ((int )MaxSearchDepth > 0));
  }
#line 776
  return;
}
}
#line 779 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ChangeHashDepth(void) 
{ 


  {
  {
#line 782
  printf((char const   */* __restrict  */)"hashdepth = ");
#line 783
  scanf((char const   */* __restrict  */)"%hd", & HashDepth);
#line 784
  printf((char const   */* __restrict  */)"MoveLimit = ");
#line 785
  scanf((char const   */* __restrict  */)"%hd", & HashMoveLimit);
  }
#line 786
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_SetContempt(void) 
{ 


  {
  {
#line 792
  printf((char const   */* __restrict  */)"contempt = ");
#line 793
  scanf((char const   */* __restrict  */)"%hd", & contempt);
  }
#line 794
  return;
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ChangeXwindow(void) 
{ 


  {
  {
#line 800
  printf((char const   */* __restrict  */)"xwndw = ");
#line 801
  scanf((char const   */* __restrict  */)"%hd", & xwndw);
  }
#line 802
  return;
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowPostnValue(short sq ) 
{ 
  short score___0 ;
  int tmp ;

  {
  {
#line 813
  score___0 = ScorePosition((short )color[sq]);
  }
#line 815
  if ((int )color[sq] != 2) {
#line 820
    if ((int )color[sq] == 1) {
#line 820
      tmp = 'b';
    } else {
#line 820
      tmp = 'w';
    }
    {
#line 820
    printf((char const   */* __restrict  */)"%3d%c ", (int )svalue[sq], tmp);
    }
  } else {
    {
#line 825
    printf((char const   */* __restrict  */)" *   ");
    }
  }
#line 827
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_DoDebug(void) 
{ 
  short c ;
  short p ;
  short sq ;
  short tp ;
  short tc ;
  short tsq ;
  short score___0 ;
  short j ;
  short k ;
  char s[40] ;
  int tmp ;

  {
  {
#line 836
  ExaminePosition(opponent);
#line 837
  Raw_ShowMessage((char *)"Enter piece: ");
#line 838
  scanf((char const   */* __restrict  */)"%s", s);
#line 839
  c = (short)2;
  }
#line 841
  if ((int )s[0] == 98) {
#line 842
    c = (short)0;
  } else
#line 841
  if ((int )s[0] == 66) {
#line 842
    c = (short)0;
  }
#line 844
  if ((int )s[0] == 119) {
#line 845
    c = (short)1;
  } else
#line 844
  if ((int )s[0] == 87) {
#line 845
    c = (short)1;
  }
#line 847
  p = (short)14;
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! ((int )p > 0)) {
#line 847
      goto while_break;
    }
#line 849
    if ((int )s[1] == (int )*(" PLNSGBRPLNSBRK " + p)) {
#line 850
      goto while_break;
    } else
#line 849
    if ((int )s[1] == (int )*(" plnsgbrplnsbrk " + p)) {
#line 850
      goto while_break;
    }
#line 847
    p = (short )((int )p - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  if ((int )p > 0) {
#line 855
    j = (short)8;
    {
#line 855
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 855
      if (! ((int )j >= 0)) {
#line 855
        goto while_break___0;
      }
#line 857
      k = (short)0;
      {
#line 857
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 857
        if (! ((int )k < 9)) {
#line 857
          goto while_break___1;
        }
        {
#line 859
        sq = (short )((int )j * 9 + (int )k);
#line 860
        tp = (short )board[sq];
#line 861
        tc = (short )color[sq];
#line 862
        board[sq] = (signed char )p;
#line 863
        color[sq] = (signed char )c;
#line 864
        tsq = (short )PieceList[c][1];
#line 865
        PieceList[c][1] = (signed char )sq;
#line 866
        Raw_ShowPostnValue(sq);
#line 867
        PieceList[c][1] = (signed char )tsq;
#line 868
        board[sq] = (signed char )tp;
#line 869
        color[sq] = (signed char )tc;
#line 857
        k = (short )((int )k + 1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 872
      printf((char const   */* __restrict  */)"\n");
#line 855
      j = (short )((int )j - 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 876
  score___0 = ScorePosition(opponent);
#line 878
  j = (short)8;
  }
  {
#line 878
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 878
    if (! ((int )j >= 0)) {
#line 878
      goto while_break___2;
    }
#line 880
    k = (short)0;
    {
#line 880
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 880
      if (! ((int )k < 9)) {
#line 880
        goto while_break___3;
      }
#line 882
      sq = (short )((int )j * 9 + (int )k);
#line 884
      if ((int )color[sq] != 2) {
#line 889
        if ((int )color[sq] == 1) {
#line 889
          tmp = 'b';
        } else {
#line 889
          tmp = 'w';
        }
        {
#line 889
        printf((char const   */* __restrict  */)"%5d%c ", (int )svalue[sq], tmp);
        }
      } else {
        {
#line 894
        printf((char const   */* __restrict  */)"    *  ");
        }
      }
#line 880
      k = (short )((int )k + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 898
    printf((char const   */* __restrict  */)"\n");
#line 878
    j = (short )((int )j - 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 901
  printf((char const   */* __restrict  */)"stage = %d\n", (int )stage);
#line 902
  printf((char const   */* __restrict  */)"S%d m%d ps%d gt%c m%d ps%d gt%c", (int )score___0,
         (int )mtl[computer], (int )pscore[computer], (int )GameType[computer], (int )mtl[opponent],
         (int )pscore[opponent], (int )GameType[opponent]);
  }
#line 905
  return;
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_DoTable(short *table ) 
{ 
  short sq ;
  short j ;
  short k ;

  {
  {
#line 912
  ExaminePosition(opponent);
#line 914
  j = (short)8;
  }
  {
#line 914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 914
    if (! ((int )j >= 0)) {
#line 914
      goto while_break;
    }
#line 916
    k = (short)0;
    {
#line 916
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 916
      if (! ((int )k < 9)) {
#line 916
        goto while_break___0;
      }
      {
#line 918
      sq = (short )((int )j * 9 + (int )k);
#line 919
      printf((char const   */* __restrict  */)"%3d ", (int )*(table + sq));
#line 916
      k = (short )((int )k + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 922
    printf((char const   */* __restrict  */)"\n");
#line 914
    j = (short )((int )j - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  return;
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_ShowPostnValues(void) 
{ 
  short sq ;
  short score___0 ;
  short j ;
  short k ;

  {
  {
#line 931
  ExaminePosition(opponent);
#line 933
  j = (short)8;
  }
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if (! ((int )j >= 0)) {
#line 933
      goto while_break;
    }
#line 935
    k = (short)0;
    {
#line 935
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 935
      if (! ((int )k < 9)) {
#line 935
        goto while_break___0;
      }
      {
#line 937
      sq = (short )((int )j * 9 + (int )k);
#line 938
      Raw_ShowPostnValue(sq);
#line 935
      k = (short )((int )k + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 941
    printf((char const   */* __restrict  */)"\n");
#line 933
    j = (short )((int )j - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 944
  score___0 = ScorePosition(opponent);
#line 945
  printf((char const   */* __restrict  */)"S%d m%d ps%d gt%c m%d ps%d gt%c", (int )score___0,
         (int )mtl[computer], (int )pscore[computer], (int )GameType[computer], (int )mtl[opponent],
         (int )pscore[opponent], (int )GameType[opponent]);
#line 948
  printf((char const   */* __restrict  */)"\nhung black %d hung white %d\n", (int )hung[0],
         (int )hung[1]);
  }
#line 949
  return;
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
static struct pollfd pollfds[1]  = {      {0, (short)1, (short)0}};
#line 952 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/rawdsp.c"
void Raw_PollForInput(void) 
{ 
  int cnt___1 ;
  int tmp ;

  {
  {
#line 962
  tmp = poll(pollfds, sizeof(pollfds) / sizeof(pollfds[0]), 0);
#line 962
  cnt___1 = tmp;
  }
#line 963
  if (cnt___1 < 0) {
    {
#line 964
    perror("polling standard input");
#line 965
    ExitShogi();
    }
  }
#line 968
  if (cnt___1) {
#line 969
    if (! flag.timeout) {
#line 970
      flag.back = (short)1;
    }
#line 971
    flag.bothsides = (short)0;
  }
#line 973
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 847 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
void ShowGameType(void) ;
#line 1052
void Initialize(void) ;
#line 1055
void ClearScreen(void) ;
#line 1057
void SelectLevel(char *sx ) ;
#line 1059
void UpdateDisplay(short f , short t , short redraw , short isspec ) ;
#line 1078
void ShowPatternCount(short side , short n ) ;
#line 1081
void TerminateSearch(int sig ) ;
#line 1083
void SetupBoard(void) ;
#line 1090
void DoDebug(void) ;
#line 1091
void DoTable(short *table ) ;
#line 1092
void ShowPostnValues(void) ;
#line 1093
void ChangeXwindow(void) ;
#line 1094
void SetContempt(void) ;
#line 1095
void ChangeHashDepth(void) ;
#line 1096
void ChangeBetaWindow(void) ;
#line 1097
void GiveHint(void) ;
#line 1098
void ShowPrompt(void) ;
#line 1099
void EditBoard(void) ;
#line 1100
void help(void) ;
#line 1101
void ChangeSearchDepth(void) ;
#line 1106
void ShowLine(unsigned short *bstline ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.h"
void ChangeAlphaWindow(void) ;
#line 64
void AlwaysShowMessage(char const   *format  , ...) ;
#line 65
void Printf(char const   *format  , ...) ;
#line 66
void RequestInputString(char *buffer___1 , unsigned int bufsize ) ;
#line 67
int GetString(char *sx ) ;
#line 70
void ShowPostnValue(short sq ) ;
#line 76
void ShowStage(void) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ChangeAlphaWindow(void) 
{ 


  {
  {
#line 84
  if ((unsigned int )display_type == 2U) {
#line 84
    goto case_2;
  }
#line 84
  if ((unsigned int )display_type == 0U) {
#line 84
    goto case_2;
  }
#line 84
  if ((unsigned int )display_type == 1U) {
#line 84
    goto case_1;
  }
#line 84
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 84
  Raw_ChangeAlphaWindow();
  }
#line 84
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 84
  Curses_ChangeAlphaWindow();
  }
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ChangeBetaWindow(void) 
{ 


  {
  {
#line 85
  if ((unsigned int )display_type == 2U) {
#line 85
    goto case_2;
  }
#line 85
  if ((unsigned int )display_type == 0U) {
#line 85
    goto case_2;
  }
#line 85
  if ((unsigned int )display_type == 1U) {
#line 85
    goto case_1;
  }
#line 85
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 85
  Raw_ChangeBetaWindow();
  }
#line 85
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 85
  Curses_ChangeBetaWindow();
  }
#line 85
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ChangeHashDepth(void) 
{ 


  {
  {
#line 86
  if ((unsigned int )display_type == 2U) {
#line 86
    goto case_2;
  }
#line 86
  if ((unsigned int )display_type == 0U) {
#line 86
    goto case_2;
  }
#line 86
  if ((unsigned int )display_type == 1U) {
#line 86
    goto case_1;
  }
#line 86
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 86
  Raw_ChangeHashDepth();
  }
#line 86
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 86
  Curses_ChangeHashDepth();
  }
#line 86
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ChangeSearchDepth(void) 
{ 


  {
  {
#line 87
  if ((unsigned int )display_type == 2U) {
#line 87
    goto case_2;
  }
#line 87
  if ((unsigned int )display_type == 0U) {
#line 87
    goto case_2;
  }
#line 87
  if ((unsigned int )display_type == 1U) {
#line 87
    goto case_1;
  }
#line 87
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 87
  Raw_ChangeSearchDepth();
  }
#line 87
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 87
  Curses_ChangeSearchDepth();
  }
#line 87
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ChangeXwindow(void) 
{ 


  {
  {
#line 88
  if ((unsigned int )display_type == 2U) {
#line 88
    goto case_2;
  }
#line 88
  if ((unsigned int )display_type == 0U) {
#line 88
    goto case_2;
  }
#line 88
  if ((unsigned int )display_type == 1U) {
#line 88
    goto case_1;
  }
#line 88
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 88
  Raw_ChangeXwindow();
  }
#line 88
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 88
  Curses_ChangeXwindow();
  }
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ClearScreen(void) 
{ 


  {
  {
#line 89
  if ((unsigned int )display_type == 2U) {
#line 89
    goto case_2;
  }
#line 89
  if ((unsigned int )display_type == 0U) {
#line 89
    goto case_2;
  }
#line 89
  if ((unsigned int )display_type == 1U) {
#line 89
    goto case_1;
  }
#line 89
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 89
  Raw_ClearScreen();
  }
#line 89
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 89
  Curses_ClearScreen();
  }
#line 89
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void DoDebug(void) 
{ 


  {
  {
#line 90
  if ((unsigned int )display_type == 2U) {
#line 90
    goto case_2;
  }
#line 90
  if ((unsigned int )display_type == 0U) {
#line 90
    goto case_2;
  }
#line 90
  if ((unsigned int )display_type == 1U) {
#line 90
    goto case_1;
  }
#line 90
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 90
  Raw_DoDebug();
  }
#line 90
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 90
  Curses_DoDebug();
  }
#line 90
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void DoTable(short *table ) 
{ 


  {
  {
#line 91
  if ((unsigned int )display_type == 2U) {
#line 91
    goto case_2;
  }
#line 91
  if ((unsigned int )display_type == 0U) {
#line 91
    goto case_2;
  }
#line 91
  if ((unsigned int )display_type == 1U) {
#line 91
    goto case_1;
  }
#line 91
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 91
  Raw_DoTable(table);
  }
#line 91
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 91
  Curses_DoTable(table);
  }
#line 91
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void EditBoard(void) 
{ 


  {
  {
#line 92
  if ((unsigned int )display_type == 2U) {
#line 92
    goto case_2;
  }
#line 92
  if ((unsigned int )display_type == 0U) {
#line 92
    goto case_2;
  }
#line 92
  if ((unsigned int )display_type == 1U) {
#line 92
    goto case_1;
  }
#line 92
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 92
  Raw_EditBoard();
  }
#line 92
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 92
  Curses_EditBoard();
  }
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ExitShogi(void) 
{ 


  {
  {
#line 93
  if ((unsigned int )display_type == 2U) {
#line 93
    goto case_2;
  }
#line 93
  if ((unsigned int )display_type == 0U) {
#line 93
    goto case_2;
  }
#line 93
  if ((unsigned int )display_type == 1U) {
#line 93
    goto case_1;
  }
#line 93
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 93
  Raw_ExitShogi();
  }
#line 93
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 93
  Curses_ExitShogi();
  }
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void GiveHint(void) 
{ 


  {
  {
#line 94
  if ((unsigned int )display_type == 2U) {
#line 94
    goto case_2;
  }
#line 94
  if ((unsigned int )display_type == 0U) {
#line 94
    goto case_2;
  }
#line 94
  if ((unsigned int )display_type == 1U) {
#line 94
    goto case_1;
  }
#line 94
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 94
  Raw_GiveHint();
  }
#line 94
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 94
  Curses_GiveHint();
  }
#line 94
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void Initialize(void) 
{ 


  {
  {
#line 95
  if ((unsigned int )display_type == 2U) {
#line 95
    goto case_2;
  }
#line 95
  if ((unsigned int )display_type == 0U) {
#line 95
    goto case_2;
  }
#line 95
  if ((unsigned int )display_type == 1U) {
#line 95
    goto case_1;
  }
#line 95
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 95
  Raw_Initialize();
  }
#line 95
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 95
  Curses_Initialize();
  }
#line 95
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowNodeCnt(long NodeCnt___0 ) 
{ 


  {
  {
#line 96
  if ((unsigned int )display_type == 2U) {
#line 96
    goto case_2;
  }
#line 96
  if ((unsigned int )display_type == 0U) {
#line 96
    goto case_2;
  }
#line 96
  if ((unsigned int )display_type == 1U) {
#line 96
    goto case_1;
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 96
  Raw_ShowNodeCnt(NodeCnt___0);
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 96
  Curses_ShowNodeCnt(NodeCnt___0);
  }
#line 96
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void OutputMove(void) 
{ 


  {
  {
#line 97
  if ((unsigned int )display_type == 2U) {
#line 97
    goto case_2;
  }
#line 97
  if ((unsigned int )display_type == 0U) {
#line 97
    goto case_2;
  }
#line 97
  if ((unsigned int )display_type == 1U) {
#line 97
    goto case_1;
  }
#line 97
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 97
  Raw_OutputMove();
  }
#line 97
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 97
  Curses_OutputMove();
  }
#line 97
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void PollForInput(void) 
{ 


  {
  {
#line 98
  if ((unsigned int )display_type == 2U) {
#line 98
    goto case_2;
  }
#line 98
  if ((unsigned int )display_type == 0U) {
#line 98
    goto case_2;
  }
#line 98
  if ((unsigned int )display_type == 1U) {
#line 98
    goto case_1;
  }
#line 98
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 98
  Raw_PollForInput();
  }
#line 98
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 98
  Curses_PollForInput();
  }
#line 98
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void SetContempt(void) 
{ 


  {
  {
#line 99
  if ((unsigned int )display_type == 2U) {
#line 99
    goto case_2;
  }
#line 99
  if ((unsigned int )display_type == 0U) {
#line 99
    goto case_2;
  }
#line 99
  if ((unsigned int )display_type == 1U) {
#line 99
    goto case_1;
  }
#line 99
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 99
  Raw_SetContempt();
  }
#line 99
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 99
  Curses_SetContempt();
  }
#line 99
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void SearchStartStuff(short side ) 
{ 


  {
  {
#line 100
  if ((unsigned int )display_type == 2U) {
#line 100
    goto case_2;
  }
#line 100
  if ((unsigned int )display_type == 0U) {
#line 100
    goto case_2;
  }
#line 100
  if ((unsigned int )display_type == 1U) {
#line 100
    goto case_1;
  }
#line 100
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 100
  Raw_SearchStartStuff(side);
  }
#line 100
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 100
  Curses_SearchStartStuff(side);
  }
#line 100
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void SelectLevel(char *sx ) 
{ 


  {
  {
#line 101
  if ((unsigned int )display_type == 2U) {
#line 101
    goto case_2;
  }
#line 101
  if ((unsigned int )display_type == 0U) {
#line 101
    goto case_2;
  }
#line 101
  if ((unsigned int )display_type == 1U) {
#line 101
    goto case_1;
  }
#line 101
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 101
  Raw_SelectLevel(sx);
  }
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 101
  Curses_SelectLevel(sx);
  }
#line 101
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void SetupBoard(void) 
{ 


  {
  {
#line 102
  if ((unsigned int )display_type == 2U) {
#line 102
    goto case_2;
  }
#line 102
  if ((unsigned int )display_type == 0U) {
#line 102
    goto case_2;
  }
#line 102
  if ((unsigned int )display_type == 1U) {
#line 102
    goto case_1;
  }
#line 102
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 102
  Raw_SetupBoard();
  }
#line 102
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 102
  Curses_SetupBoard();
  }
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowCurrentMove(short pnt___2 , short f , short t ) 
{ 


  {
  {
#line 103
  if ((unsigned int )display_type == 2U) {
#line 103
    goto case_2;
  }
#line 103
  if ((unsigned int )display_type == 0U) {
#line 103
    goto case_2;
  }
#line 103
  if ((unsigned int )display_type == 1U) {
#line 103
    goto case_1;
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 103
  Raw_ShowCurrentMove(pnt___2, f, t);
  }
#line 103
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 103
  Curses_ShowCurrentMove(pnt___2, f, t);
  }
#line 103
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowDepth(char ch ) 
{ 


  {
  {
#line 104
  if ((unsigned int )display_type == 2U) {
#line 104
    goto case_2;
  }
#line 104
  if ((unsigned int )display_type == 0U) {
#line 104
    goto case_2;
  }
#line 104
  if ((unsigned int )display_type == 1U) {
#line 104
    goto case_1;
  }
#line 104
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 104
  Raw_ShowDepth(ch);
  }
#line 104
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 104
  Curses_ShowDepth(ch);
  }
#line 104
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowGameType(void) 
{ 


  {
  {
#line 105
  if ((unsigned int )display_type == 2U) {
#line 105
    goto case_2;
  }
#line 105
  if ((unsigned int )display_type == 0U) {
#line 105
    goto case_2;
  }
#line 105
  if ((unsigned int )display_type == 1U) {
#line 105
    goto case_1;
  }
#line 105
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 105
  Raw_ShowGameType();
  }
#line 105
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 105
  Curses_ShowGameType();
  }
#line 105
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowLine(unsigned short *bstline ) 
{ 


  {
  {
#line 106
  if ((unsigned int )display_type == 2U) {
#line 106
    goto case_2;
  }
#line 106
  if ((unsigned int )display_type == 0U) {
#line 106
    goto case_2;
  }
#line 106
  if ((unsigned int )display_type == 1U) {
#line 106
    goto case_1;
  }
#line 106
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 106
  Raw_ShowLine(bstline);
  }
#line 106
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 106
  Curses_ShowLine(bstline);
  }
#line 106
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowMessage(char *s ) 
{ 


  {
  {
#line 107
  if ((unsigned int )display_type == 2U) {
#line 107
    goto case_2;
  }
#line 107
  if ((unsigned int )display_type == 0U) {
#line 107
    goto case_2;
  }
#line 107
  if ((unsigned int )display_type == 1U) {
#line 107
    goto case_1;
  }
#line 107
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 107
  Raw_ShowMessage(s);
  }
#line 107
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 107
  Curses_ShowMessage(s);
  }
#line 107
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void AlwaysShowMessage(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 108
  __builtin_va_start(ap, format);
  }
  {
#line 108
  if ((unsigned int )display_type == 2U) {
#line 108
    goto case_2;
  }
#line 108
  if ((unsigned int )display_type == 0U) {
#line 108
    goto case_2;
  }
#line 108
  if ((unsigned int )display_type == 1U) {
#line 108
    goto case_1;
  }
#line 108
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 108
  Raw_AlwaysShowMessage(format, ap);
  }
#line 108
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 108
  Curses_AlwaysShowMessage(format, ap);
  }
#line 108
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 108
  __builtin_va_end(ap);
  }
#line 108
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void Printf(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 109
  __builtin_va_start(ap, format);
  }
  {
#line 109
  if ((unsigned int )display_type == 2U) {
#line 109
    goto case_2;
  }
#line 109
  if ((unsigned int )display_type == 0U) {
#line 109
    goto case_2;
  }
#line 109
  if ((unsigned int )display_type == 1U) {
#line 109
    goto case_1;
  }
#line 109
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 109
  Raw_Printf(format, ap);
  }
#line 109
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 109
  Curses_Printf(format, ap);
  }
#line 109
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 109
  __builtin_va_end(ap);
  }
#line 109
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowPatternCount(short side , short n ) 
{ 


  {
  {
#line 110
  if ((unsigned int )display_type == 2U) {
#line 110
    goto case_2;
  }
#line 110
  if ((unsigned int )display_type == 0U) {
#line 110
    goto case_2;
  }
#line 110
  if ((unsigned int )display_type == 1U) {
#line 110
    goto case_1;
  }
#line 110
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 110
  Raw_ShowPatternCount(side, n);
  }
#line 110
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 110
  Curses_ShowPatternCount(side, n);
  }
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowPostnValue(short sq ) 
{ 


  {
  {
#line 111
  if ((unsigned int )display_type == 2U) {
#line 111
    goto case_2;
  }
#line 111
  if ((unsigned int )display_type == 0U) {
#line 111
    goto case_2;
  }
#line 111
  if ((unsigned int )display_type == 1U) {
#line 111
    goto case_1;
  }
#line 111
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 111
  Raw_ShowPostnValue(sq);
  }
#line 111
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 111
  Curses_ShowPostnValue(sq);
  }
#line 111
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowPostnValues(void) 
{ 


  {
  {
#line 112
  if ((unsigned int )display_type == 2U) {
#line 112
    goto case_2;
  }
#line 112
  if ((unsigned int )display_type == 0U) {
#line 112
    goto case_2;
  }
#line 112
  if ((unsigned int )display_type == 1U) {
#line 112
    goto case_1;
  }
#line 112
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 112
  Raw_ShowPostnValues();
  }
#line 112
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 112
  Curses_ShowPostnValues();
  }
#line 112
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowPrompt(void) 
{ 


  {
  {
#line 113
  if ((unsigned int )display_type == 2U) {
#line 113
    goto case_2;
  }
#line 113
  if ((unsigned int )display_type == 0U) {
#line 113
    goto case_2;
  }
#line 113
  if ((unsigned int )display_type == 1U) {
#line 113
    goto case_1;
  }
#line 113
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 113
  Raw_ShowPrompt();
  }
#line 113
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 113
  Curses_ShowPrompt();
  }
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowResponseTime(void) 
{ 


  {
  {
#line 114
  if ((unsigned int )display_type == 2U) {
#line 114
    goto case_2;
  }
#line 114
  if ((unsigned int )display_type == 0U) {
#line 114
    goto case_2;
  }
#line 114
  if ((unsigned int )display_type == 1U) {
#line 114
    goto case_1;
  }
#line 114
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 114
  Raw_ShowResponseTime();
  }
#line 114
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 114
  Curses_ShowResponseTime();
  }
#line 114
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowResults(short score___0 , unsigned short *bstline , char ch ) 
{ 


  {
  {
#line 115
  if ((unsigned int )display_type == 2U) {
#line 115
    goto case_2;
  }
#line 115
  if ((unsigned int )display_type == 0U) {
#line 115
    goto case_2;
  }
#line 115
  if ((unsigned int )display_type == 1U) {
#line 115
    goto case_1;
  }
#line 115
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 115
  Raw_ShowResults(score___0, bstline, ch);
  }
#line 115
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 115
  Curses_ShowResults(score___0, bstline, ch);
  }
#line 115
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowSidetoMove(void) 
{ 


  {
  {
#line 116
  if ((unsigned int )display_type == 2U) {
#line 116
    goto case_2;
  }
#line 116
  if ((unsigned int )display_type == 0U) {
#line 116
    goto case_2;
  }
#line 116
  if ((unsigned int )display_type == 1U) {
#line 116
    goto case_1;
  }
#line 116
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 116
  Raw_ShowSidetoMove();
  }
#line 116
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 116
  Curses_ShowSidetoMove();
  }
#line 116
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void ShowStage(void) 
{ 


  {
  {
#line 117
  if ((unsigned int )display_type == 2U) {
#line 117
    goto case_2;
  }
#line 117
  if ((unsigned int )display_type == 0U) {
#line 117
    goto case_2;
  }
#line 117
  if ((unsigned int )display_type == 1U) {
#line 117
    goto case_1;
  }
#line 117
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 117
  Raw_ShowStage();
  }
#line 117
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 117
  Curses_ShowStage();
  }
#line 117
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void TerminateSearch(int sig ) 
{ 


  {
  {
#line 118
  if ((unsigned int )display_type == 2U) {
#line 118
    goto case_2;
  }
#line 118
  if ((unsigned int )display_type == 0U) {
#line 118
    goto case_2;
  }
#line 118
  if ((unsigned int )display_type == 1U) {
#line 118
    goto case_1;
  }
#line 118
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 118
  Raw_TerminateSearch(sig);
  }
#line 118
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 118
  Curses_TerminateSearch(sig);
  }
#line 118
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void UpdateClocks(void) 
{ 


  {
  {
#line 119
  if ((unsigned int )display_type == 2U) {
#line 119
    goto case_2;
  }
#line 119
  if ((unsigned int )display_type == 0U) {
#line 119
    goto case_2;
  }
#line 119
  if ((unsigned int )display_type == 1U) {
#line 119
    goto case_1;
  }
#line 119
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 119
  Raw_UpdateClocks();
  }
#line 119
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 119
  Curses_UpdateClocks();
  }
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 119
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void UpdateDisplay(short f , short t , short redraw , short isspec ) 
{ 


  {
  {
#line 120
  if ((unsigned int )display_type == 2U) {
#line 120
    goto case_2;
  }
#line 120
  if ((unsigned int )display_type == 0U) {
#line 120
    goto case_2;
  }
#line 120
  if ((unsigned int )display_type == 1U) {
#line 120
    goto case_1;
  }
#line 120
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 120
  Raw_UpdateDisplay(f, t, redraw, isspec);
  }
#line 120
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 120
  Curses_UpdateDisplay(f, t, redraw, isspec);
  }
#line 120
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void help(void) 
{ 


  {
  {
#line 121
  if ((unsigned int )display_type == 2U) {
#line 121
    goto case_2;
  }
#line 121
  if ((unsigned int )display_type == 0U) {
#line 121
    goto case_2;
  }
#line 121
  if ((unsigned int )display_type == 1U) {
#line 121
    goto case_1;
  }
#line 121
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 121
  Raw_help();
  }
#line 121
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 121
  Curses_help();
  }
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void doRequestInputString(char const   *fmt___0 , char *buffer___1 ) 
{ 


  {
  {
#line 123
  if ((unsigned int )display_type == 2U) {
#line 123
    goto case_2;
  }
#line 123
  if ((unsigned int )display_type == 0U) {
#line 123
    goto case_2;
  }
#line 123
  if ((unsigned int )display_type == 1U) {
#line 123
    goto case_1;
  }
#line 123
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 123
  Raw_doRequestInputString(fmt___0, buffer___1);
  }
#line 123
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 123
  Curses_doRequestInputString(fmt___0, buffer___1);
  }
#line 123
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
static char fmt[10]  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
void RequestInputString(char *buffer___1 , unsigned int bufsize ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 127
  tmp = snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"%%%us",
                 bufsize);
#line 127
  ret = tmp;
  }
#line 128
  if ((unsigned long )ret >= sizeof(fmt)) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient format-buffer size in %s for bufsize=%u\n",
            "RequestInputString", bufsize);
#line 132
    exit(1);
    }
  }
  {
#line 134
  doRequestInputString((char const   *)(fmt), buffer___1);
  }
#line 135
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c"
int GetString(char *sx ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 164
  if ((unsigned int )display_type == 2U) {
#line 164
    goto case_2;
  }
#line 164
  if ((unsigned int )display_type == 0U) {
#line 164
    goto case_2;
  }
#line 164
  if ((unsigned int )display_type == 1U) {
#line 164
    goto case_1;
  }
#line 164
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 164
  tmp = Raw_GetString(sx);
  }
#line 164
  return (tmp);
#line 164
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 164
  tmp___0 = Curses_GetString(sx);
  }
#line 164
  return (tmp___0);
#line 164
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 164
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/dspwrappers.c",
                164U, "GetString");
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern.h"
short ValueOfOpeningName(char *name ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pattern-common.c"
short ValueOfOpeningName(char *name ) 
{ 
  short i___0 ;

  {
#line 39
  if ((int )*(name + 0) == 67) {
#line 39
    i___0 = (short)0;
  } else {
#line 39
    i___0 = (short)100;
  }
  {
#line 43
  if ((int )*(name + 7) == 83) {
#line 43
    goto case_83;
  }
#line 47
  if ((int )*(name + 7) == 82) {
#line 47
    goto case_82;
  }
#line 51
  if ((int )*(name + 7) == 85) {
#line 51
    goto case_85;
  }
#line 55
  goto switch_default;
  case_83: /* CIL Label */ 
#line 44
  i___0 = (short )((int )i___0 + 10);
#line 45
  goto switch_break;
  case_82: /* CIL Label */ 
#line 48
  i___0 = (short )((int )i___0 + 20);
#line 49
  goto switch_break;
  case_85: /* CIL Label */ 
#line 52
  i___0 = (short )((int )i___0 + 30);
#line 53
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 56
  i___0 = (short )((int )i___0 + 40);
#line 57
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 62
  if ((int )*(name + 9) == 83) {
#line 62
    goto case_83___0;
  }
#line 66
  if ((int )*(name + 9) == 82) {
#line 66
    goto case_82___0;
  }
#line 70
  if ((int )*(name + 9) == 85) {
#line 70
    goto case_85___0;
  }
#line 74
  goto switch_default___0;
  case_83___0: /* CIL Label */ 
#line 63
  i___0 = (short )((int )i___0 + 1);
#line 64
  goto switch_break___0;
  case_82___0: /* CIL Label */ 
#line 67
  i___0 = (short )((int )i___0 + 2);
#line 68
  goto switch_break___0;
  case_85___0: /* CIL Label */ 
#line 71
  i___0 = (short )((int )i___0 + 3);
#line 72
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 75
  i___0 = (short )((int )i___0 + 4);
#line 76
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 79
  return (i___0);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 1050 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int InitMain(void) ;
#line 1051
void ExitMain(void) ;
#line 1053
void InputCommand(char *command ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/main.c"
void print_arglist(int argc , char **argv ) 
{ 
  int i___0 ;

  {
#line 42
  i___0 = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i___0 < argc)) {
#line 42
      goto while_break;
    }
    {
#line 43
    printf((char const   */* __restrict  */)"argv[%d] = %s\n", i___0, *(argv + i___0));
#line 42
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  printf((char const   */* __restrict  */)"\n");
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long j ;
  struct fileentry n ;
  long tmp___4 ;
  long i___0 ;
  long j___0 ;
  int nr[40] ;
  struct fileentry n___0 ;
  long tmp___5 ;
  char *p ;
  long tmp___6 ;
  long tmp___7 ;
  char *p___0 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;

  {
#line 58
  argc --;
#line 59
  argv ++;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (argc > 0) {
#line 63
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 63
        if (! ((int )*(*(argv + 0) + 0) == 43)) {
#line 63
          goto while_break;
        }
      }
    } else {
#line 63
      goto while_break;
    }
    {
#line 67
    if ((int )*(*(argv + 0) + 1) == 97) {
#line 67
      goto case_97;
    }
#line 73
    if ((int )*(*(argv + 0) + 1) == 98) {
#line 73
      goto case_98;
    }
#line 88
    if ((int )*(*(argv + 0) + 1) == 66) {
#line 88
      goto case_66;
    }
#line 99
    if ((int )*(*(argv + 0) + 1) == 67) {
#line 99
      goto case_67;
    }
#line 106
    if ((int )*(*(argv + 0) + 1) == 104) {
#line 106
      goto case_104;
    }
#line 112
    if ((int )*(*(argv + 0) + 1) == 108) {
#line 112
      goto case_108;
    }
#line 122
    if ((int )*(*(argv + 0) + 1) == 76) {
#line 122
      goto case_76;
    }
#line 131
    if ((int )*(*(argv + 0) + 1) == 115) {
#line 131
      goto case_115;
    }
#line 141
    if ((int )*(*(argv + 0) + 1) == 80) {
#line 141
      goto case_80;
    }
#line 151
    if ((int )*(*(argv + 0) + 1) == 82) {
#line 151
      goto case_82;
    }
#line 158
    if ((int )*(*(argv + 0) + 1) == 83) {
#line 158
      goto case_83;
    }
#line 167
    if ((int )*(*(argv + 0) + 1) == 114) {
#line 167
      goto case_114;
    }
#line 180
    if ((int )*(*(argv + 0) + 1) == 84) {
#line 180
      goto case_84;
    }
#line 193
    if ((int )*(*(argv + 0) + 1) == 99) {
#line 193
      goto case_99;
    }
#line 234
    if ((int )*(*(argv + 0) + 1) == 116) {
#line 234
      goto case_116;
    }
#line 289
    if ((int )*(*(argv + 0) + 1) == 118) {
#line 289
      goto case_118;
    }
#line 294
    if ((int )*(*(argv + 0) + 1) == 88) {
#line 294
      goto case_88;
    }
#line 301
    if ((int )*(*(argv + 0) + 1) == 120) {
#line 301
      goto case_120;
    }
#line 311
    goto switch_default;
    case_97: /* CIL Label */ 
#line 69
    if ((int )*(*(argv + 0) + 0) == 45) {
#line 69
      ahead = (short)0;
    } else {
#line 69
      ahead = (short)1;
    }
#line 70
    goto switch_break;
    case_98: /* CIL Label */ 
#line 74
    argc --;
#line 75
    argv ++;
#line 77
    if (argc > 0) {
#line 79
      bookfile = *(argv + 0);
#line 81
      binbookfile = (char *)((void *)0);
    }
#line 85
    goto switch_break;
    case_66: /* CIL Label */ 
#line 89
    argc --;
#line 90
    argv ++;
#line 92
    if (argc > 0) {
#line 93
      binbookfile = *(argv + 0);
    }
#line 95
    goto switch_break;
    case_67: /* CIL Label */ 
#line 101
    display_type = (display_t )1;
#line 103
    goto switch_break;
    case_104: /* CIL Label */ 
#line 108
    if ((int )*(*(argv + 0) + 0) == 45) {
#line 108
      hash = (short)0;
    } else {
#line 108
      hash = (short)1;
    }
#line 109
    goto switch_break;
    case_108: /* CIL Label */ 
#line 113
    argc --;
#line 114
    argv ++;
#line 116
    if (argc > 0) {
#line 117
      Lang = *(argv + 0);
    }
#line 119
    goto switch_break;
    case_76: /* CIL Label */ 
#line 123
    argc --;
#line 124
    argv ++;
#line 126
    if (argc > 0) {
      {
#line 127
      strcpy((char */* __restrict  */)(listfile), (char const   */* __restrict  */)*(argv + 0));
      }
    }
#line 128
    goto switch_break;
    case_115: /* CIL Label */ 
#line 132
    argc --;
#line 133
    argv ++;
#line 135
    if (argc > 0) {
      {
#line 136
      strcpy((char */* __restrict  */)(savefile), (char const   */* __restrict  */)*(argv + 0));
      }
    }
#line 138
    goto switch_break;
    case_80: /* CIL Label */ 
#line 142
    argc --;
#line 143
    argv ++;
#line 145
    if (argc > 0) {
      {
#line 146
      tmp = atoi((char const   *)*(argv + 0));
#line 146
      bookmaxply = (unsigned short )tmp;
      }
    }
#line 148
    goto switch_break;
    case_82: /* CIL Label */ 
#line 153
    display_type = (display_t )0;
#line 155
    goto switch_break;
    case_83: /* CIL Label */ 
#line 159
    argc --;
#line 160
    argv ++;
#line 162
    if (argc > 0) {
      {
#line 163
      tmp___0 = atoi((char const   *)*(argv + 0));
#line 163
      booksize = (unsigned int )tmp___0;
      }
    }
#line 164
    goto switch_break;
    case_114: /* CIL Label */ 
#line 168
    argc --;
#line 169
    argv ++;
#line 171
    if (argc > 0) {
      {
#line 172
      tmp___1 = atoi((char const   *)*(argv + 0));
#line 172
      rehash = (short )tmp___1;
      }
    }
#line 174
    if ((int )rehash > 7) {
#line 175
      rehash = (short)7;
    }
#line 177
    goto switch_break;
    case_84: /* CIL Label */ 
#line 181
    argc --;
#line 182
    argv ++;
#line 184
    if (argc > 0) {
      {
#line 185
      tmp___2 = atoi((char const   *)*(argv + 0));
#line 185
      ttblsize = (unsigned int )tmp___2;
      }
    }
#line 187
    if (ttblsize <= 8000U) {
#line 188
      ttblsize = 8001U;
    }
#line 190
    goto switch_break;
    case_99: /* CIL Label */ 
#line 194
    argc --;
#line 195
    argv ++;
#line 197
    if (argc > 0) {
      {
#line 198
      tmp___3 = atoi((char const   *)*(argv + 0));
#line 198
      filesz = (long )tmp___3;
      }
    } else {
#line 200
      filesz = 14L;
    }
#line 202
    if (filesz > 0L) {
#line 202
      if (filesz < 24L) {
#line 203
        filesz = (long )(((1 << filesz) - 1) + 7);
      } else {
#line 205
        filesz += 7L;
      }
    } else {
#line 205
      filesz += 7L;
    }
    {
#line 207
    hashfile = fopen((char const   */* __restrict  */)"/usr/local/lib/gnushogi/gnushogi.hsh",
                     (char const   */* __restrict  */)"r+");
    }
#line 207
    if ((unsigned long )hashfile == (unsigned long )((void *)0)) {
      {
#line 208
      hashfile = fopen((char const   */* __restrict  */)"/usr/local/lib/gnushogi/gnushogi.hsh",
                       (char const   */* __restrict  */)"w+");
      }
    }
#line 210
    if ((unsigned long )hashfile != (unsigned long )((void *)0)) {
      {
#line 215
      fputs((char const   */* __restrict  */)"Filling transposition file, wait!\n",
            (FILE */* __restrict  */)stdout);
#line 216
      n.t = (unsigned char)0;
#line 216
      n.f = n.t;
#line 217
      n.flags = (unsigned char)0;
#line 218
      n.depth = (unsigned char)0;
#line 219
      n.sl = (unsigned char)0;
#line 219
      n.sh = n.sl;
#line 221
      j = 0L;
      }
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 221
        if (! (j < filesz + 1L)) {
#line 221
          goto while_break___0;
        }
        {
#line 222
        fwrite((void const   */* __restrict  */)(& n), sizeof(struct fileentry ),
               (size_t )1, (FILE */* __restrict  */)hashfile);
#line 221
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 224
      fclose(hashfile);
      }
    } else {
      {
#line 228
      printf((char const   */* __restrict  */)"Create failed for %s\n", "/usr/local/lib/gnushogi/gnushogi.hsh");
      }
    }
#line 231
    return (0);
    case_116: /* CIL Label */ 
    {
#line 235
    hashfile = fopen((char const   */* __restrict  */)"/usr/local/lib/gnushogi/gnushogi.hsh",
                     (char const   */* __restrict  */)"r+");
    }
#line 237
    if (hashfile) {
      {
#line 239
      fseek(hashfile, 0L, 2);
#line 240
      tmp___4 = ftell(hashfile);
#line 240
      filesz = (long )((unsigned long )tmp___4 / sizeof(struct fileentry ) - 1UL);
      }
    }
#line 243
    if ((unsigned long )hashfile != (unsigned long )((void *)0)) {
      {
#line 249
      fputs((char const   */* __restrict  */)"Counting transposition file entries, wait!\n",
            (FILE */* __restrict  */)stdout);
#line 251
      i___0 = 0L;
      }
      {
#line 251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 251
        if (! (i___0 < 40L)) {
#line 251
          goto while_break___1;
        }
#line 252
        nr[i___0] = 0;
#line 251
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 254
      fseek(hashfile, 0L, 2);
#line 255
      tmp___5 = ftell(hashfile);
#line 255
      i___0 = (long )((unsigned long )tmp___5 / sizeof(struct fileentry ));
#line 256
      fseek(hashfile, 0L, 0);
#line 258
      j___0 = 0L;
      }
      {
#line 258
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 258
        if (! (j___0 < i___0 + 1L)) {
#line 258
          goto while_break___2;
        }
        {
#line 260
        fread((void */* __restrict  */)(& n___0), sizeof(struct fileentry ), (size_t )1,
              (FILE */* __restrict  */)hashfile);
        }
#line 262
        if ((int )n___0.depth > 40) {
          {
#line 264
          printf((char const   */* __restrict  */)"ERROR\n");
#line 265
          exit(1);
          }
        }
#line 268
        if (n___0.depth) {
#line 270
          (nr[n___0.depth]) ++;
#line 271
          (nr[0]) ++;
        }
#line 258
        j___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 275
      printf((char const   */* __restrict  */)"The file contains %d entries out of max %d\n",
             nr[0], i___0);
#line 277
      j___0 = 1L;
      }
      {
#line 277
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 277
        if (! (j___0 < 40L)) {
#line 277
          goto while_break___3;
        }
        {
#line 278
        printf((char const   */* __restrict  */)"%d ", nr[j___0]);
#line 277
        j___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 280
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 283
    return (0);
    case_118: /* CIL Label */ 
    {
#line 290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnushogi version %s\n",
            "1.4.1");
#line 291
    exit(1);
    }
    case_88: /* CIL Label */ 
#line 296
    display_type = (display_t )2;
#line 298
    goto switch_break;
    case_120: /* CIL Label */ 
#line 302
    argc --;
#line 303
    argv ++;
#line 305
    if (argc > 0) {
#line 306
      xwin = *(argv + 0);
    }
#line 308
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 312
    fputs((char const   */* __restrict  */)"Usage: gnushogi [-a] [-t] [-c size] [-s savefile][-l listfile] [-x xwndw]\n",
          (FILE */* __restrict  */)stderr);
#line 313
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 316
    argc --;
#line 317
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (argc == 2) {
    {
#line 324
    tmp___6 = strtol((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)(& p),
                     10);
#line 324
    MaxResponseTime = 100L * tmp___6;
    }
#line 326
    if ((int )*p == 58) {
      {
#line 328
      p ++;
#line 328
      tmp___7 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)((char **)((void *)0)),
                       10);
#line 328
      MaxResponseTime = 60L * MaxResponseTime + 100L * tmp___7;
      }
    }
#line 332
    TCflag = (short)0;
#line 333
    TCmoves = (short)0;
#line 334
    TCminutes = (short)0;
#line 335
    TCseconds = (short)0;
  }
#line 338
  if (argc >= 3) {
#line 342
    if (argc > 9) {
      {
#line 344
      printf((char const   */* __restrict  */)"Time Control Error\n");
#line 345
      exit(1);
      }
    }
    {
#line 348
    tmp___8 = atoi((char const   *)*(argv + 1));
#line 348
    TCmoves = (short )tmp___8;
#line 349
    tmp___9 = strtol((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& p___0),
                     10);
#line 349
    TCminutes = (short )tmp___9;
    }
#line 351
    if ((int )*p___0 == 58) {
      {
#line 352
      tmp___10 = strtol((char const   */* __restrict  */)(p___0 + 1), (char **/* __restrict  */)((char **)((void *)0)),
                        10);
#line 352
      TCseconds = (short )tmp___10;
      }
    } else {
#line 354
      TCseconds = (short)0;
    }
#line 356
    TCflag = (short)1;
#line 357
    argc -= 3;
#line 358
    argv += 3;
    {
#line 360
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 360
      if (! (argc > 1)) {
#line 360
        goto while_break___4;
      }
      {
#line 362
      tmp___11 = atoi((char const   *)*(argv + 0));
#line 362
      XCmoves[XC] = (short )tmp___11;
#line 363
      tmp___12 = strtol((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)(& p___0),
                        10);
#line 363
      XCminutes[XC] = (short )tmp___12;
      }
#line 365
      if ((int )*p___0 == 58) {
        {
#line 366
        tmp___13 = strtol((char const   */* __restrict  */)(p___0 + 1), (char **/* __restrict  */)((char **)((void *)0)),
                          10);
#line 366
        XCseconds[XC] = (short )tmp___13;
        }
      } else {
#line 368
        XCseconds[XC] = (short)0;
      }
#line 370
      if (XCmoves[XC]) {
#line 370
        if (XCminutes[XC]) {
#line 371
          XC = (short )((int )XC + 1);
        } else
#line 370
        if (XCseconds[XC]) {
#line 371
          XC = (short )((int )XC + 1);
        } else {
          {
#line 374
          printf((char const   */* __restrict  */)"Time Control Error\n");
#line 375
          exit(1);
          }
        }
      } else {
        {
#line 374
        printf((char const   */* __restrict  */)"Time Control Error\n");
#line 375
        exit(1);
        }
      }
#line 378
      argc -= 2;
#line 379
      argv += 2;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 382
    if (argc) {
      {
#line 389
      printf((char const   */* __restrict  */)"Invalid command-line arguments:\n");
#line 390
      print_arglist(argc, argv);
#line 391
      exit(1);
      }
    }
  }
  {
#line 395
  tmp___14 = InitMain();
  }
#line 395
  if (tmp___14 != 0) {
    {
#line 396
    exit(1);
    }
  }
  {
#line 398
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 398
    if (! (! flag.quit)) {
#line 398
      goto while_break___5;
    }
#line 400
    oppptr = (oppptr + 1) % 4;
#line 402
    if (flag.bothsides) {
#line 402
      if (! flag.mate) {
        {
#line 403
        SelectMove(opponent, (SelectMove_mode )1);
        }
      } else {
        {
#line 405
        InputCommand((char *)((void *)0));
        }
      }
    } else {
      {
#line 405
      InputCommand((char *)((void *)0));
      }
    }
#line 407
    if ((int )opponent == 1) {
#line 409
      if (flag.gamein) {
        {
#line 411
        TimeCalc();
        }
      } else
#line 409
      if (TCadd) {
        {
#line 411
        TimeCalc();
        }
      } else
#line 413
      if ((int )TimeControl.moves[opponent] == 0) {
#line 415
        if (XC) {
#line 417
          if ((int )XCmore < (int )XC) {
#line 419
            TCmoves = XCmoves[XCmore];
#line 420
            TCminutes = XCminutes[XCmore];
#line 421
            TCseconds = XCseconds[XCmore];
#line 422
            XCmore = (short )((int )XCmore + 1);
          }
        }
        {
#line 426
        SetTimeControl();
        }
      }
    }
#line 430
    compptr = (compptr + 1) % 4;
#line 432
    if (! flag.quit) {
#line 432
      if (! flag.mate) {
#line 432
        if (! flag.force) {
          {
#line 437
          SelectMove(computer, (SelectMove_mode )1);
          }
#line 439
          if ((int )computer == 1) {
#line 441
            if (flag.gamein) {
              {
#line 443
              TimeCalc();
              }
            } else
#line 445
            if ((int )TimeControl.moves[computer] == 0) {
#line 447
              if (XC) {
#line 449
                if ((int )XCmore < (int )XC) {
#line 451
                  TCmoves = XCmoves[XCmore];
#line 452
                  TCminutes = XCminutes[XCmore];
#line 453
                  TCseconds = XCseconds[XCmore];
#line 454
                  XCmore = (short )((int )XCmore + 1);
                }
              }
              {
#line 458
              SetTimeControl();
              }
            }
          }
        }
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 464
  ExitMain();
  }
#line 466
  return (0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
void threats(short side ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
long attack[2][81]  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
signed char sseed[81]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
signed char starget[2][81]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
signed char sloose[81]  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
signed char shole[81]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.h"
signed char shung[81]  ;
#line 70
struct signature squares_signature ;
#line 695 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char board[81]  ;
#line 695 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
signed char color[81]  ;
#line 696
signed char const   sweep[15] ;
#line 719 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short pscore[2]  ;
#line 788
signed char const   inunmap[81] ;
#line 790
signed char const   nunmap[143] ;
#line 828 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short ADVNCM[15]  ;
#line 834
short distance(short a , short b ) ;
#line 916
void Initialize_eval(void) ;
#line 949
void PutInEETable(short side , int score___0 ) ;
#line 950
int CheckEETable(short side ) ;
#line 951
int ProbeEETable(short side , short *score___0 ) ;
#line 1047
short ScorePatternDistance(short c1___0 ) ;
#line 1048
void DetermineStage(short side ) ;
#line 1049
void UpdateWeights(short stage___0 ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
int EADD  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
int EGET  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
int PUTVAR  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
signed char const   Stboard[81]  = 
#line 49
  {      (signed char const   )2,      (signed char const   )3,      (signed char const   )4,      (signed char const   )5, 
        (signed char const   )14,      (signed char const   )5,      (signed char const   )4,      (signed char const   )3, 
        (signed char const   )2,      (signed char const   )0,      (signed char const   )6,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )7,      (signed char const   )0,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )0, 
        (signed char const   )7,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )6,      (signed char const   )0, 
        (signed char const   )2,      (signed char const   )3,      (signed char const   )4,      (signed char const   )5, 
        (signed char const   )14,      (signed char const   )5,      (signed char const   )4,      (signed char const   )3, 
        (signed char const   )2};
#line 63 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
signed char const   Stcolor[81]  = 
#line 63
  {      (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )2,      (signed char const   )0,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )0,      (signed char const   )2,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )1,      (signed char const   )2,      (signed char const   )2,      (signed char const   )2, 
        (signed char const   )2,      (signed char const   )2,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1};
#line 114 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char ispvalue[15][4]  = 
#line 114
  { {        (signed char)0,        (signed char)35,        (signed char)70,        (signed char)99}, 
   {        (signed char)7,        (signed char)7,        (signed char)8,        (signed char)10}, 
   {        (signed char)20,        (signed char)35,        (signed char)45,        (signed char)60}, 
   {        (signed char)20,        (signed char)35,        (signed char)45,        (signed char)60}, 
   {        (signed char)35,        (signed char)40,        (signed char)60,        (signed char)80}, 
   {        (signed char)35,        (signed char)50,        (signed char)65,        (signed char)80}, 
   {        (signed char)90,        (signed char)90,        (signed char)90,        (signed char)90}, 
   {        (signed char)95,        (signed char)95,        (signed char)95,        (signed char)95}, 
   {        (signed char)15,        (signed char)25,        (signed char)40,        (signed char)65}, 
   {        (signed char)25,        (signed char)45,        (signed char)55,        (signed char)65}, 
   {        (signed char)25,        (signed char)45,        (signed char)55,        (signed char)65}, 
   {        (signed char)35,        (signed char)55,        (signed char)75,        (signed char)75}, 
   {        (signed char)99,        (signed char)99,        (signed char)99,        (signed char)99}, 
   {        (signed char)97,        (signed char)97,        (signed char)99,        (signed char)99}, 
   {        (signed char)100,        (signed char)100,        (signed char)100,        (signed char)100}};
#line 173 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char weight[32][6]  = 
#line 173
  { {        (signed char)80,        (signed char)100,        (signed char)100,        (signed char)40, 
            (signed char)10,        (signed char)15}, 
   {        (signed char)80,        (signed char)100,        (signed char)100,        (signed char)50, 
            (signed char)14,        (signed char)10}, 
   {        (signed char)80,        (signed char)100,        (signed char)100,        (signed char)50, 
            (signed char)18,        (signed char)12}, 
   {        (signed char)100,        (signed char)50,        (signed char)0,        (signed char)0, 
            (signed char)2,        (signed char)1}, 
   {        (signed char)100,        (signed char)100,        (signed char)60,        (signed char)10, 
            (signed char)4,        (signed char)2}, 
   {        (signed char)100,        (signed char)50,        (signed char)0,        (signed char)0, 
            (signed char)14,        (signed char)7}, 
   {        (signed char)100,        (signed char)50,        (signed char)0,        (signed char)0, 
            (signed char)6,        (signed char)12}, 
   {        (signed char)10,        (signed char)40,        (signed char)70,        (signed char)100, 
            (signed char)10,        (signed char)15}, 
   {        (signed char)100,        (signed char)80,        (signed char)50,        (signed char)40, 
            (signed char)2,        (signed char)1}, 
   {        (signed char)40,        (signed char)100,        (signed char)40,        (signed char)5, 
            (signed char)4,        (signed char)4}, 
   {        (signed char)80,        (signed char)100,        (signed char)80,        (signed char)30, 
            (signed char)10,        (signed char)15}, 
   {        (signed char)80,        (signed char)100,        (signed char)60,        (signed char)15, 
            (signed char)6,        (signed char)10}, 
   {        (signed char)100,        (signed char)50,        (signed char)0,        (signed char)0, 
            (signed char)15,        (signed char)15}, 
   {        (signed char)0,        (signed char)40,        (signed char)70,        (signed char)100, 
            (signed char)8,        (signed char)12}, 
   {        (signed char)50,        (signed char)100,        (signed char)80,        (signed char)20, 
            (signed char)5,        (signed char)3}, 
   {        (signed char)50,        (signed char)100,        (signed char)80,        (signed char)50, 
            (signed char)100,        (signed char)100}, 
   {        (signed char)50,        (signed char)100,        (signed char)80,        (signed char)50, 
            (signed char)4,        (signed char)8}, 
   {        (signed char)50,        (signed char)40,        (signed char)100,        (signed char)80, 
            (signed char)8,        (signed char)4}, 
   {        (signed char)80,        (signed char)100,        (signed char)60,        (signed char)20, 
            (signed char)5,        (signed char)5}, 
   {        (signed char)20,        (signed char)40,        (signed char)80,        (signed char)100, 
            (signed char)3,        (signed char)6}, 
   {        (signed char)20,        (signed char)40,        (signed char)80,        (signed char)100, 
            (signed char)4,        (signed char)1}, 
   {        (signed char)5,        (signed char)40,        (signed char)100,        (signed char)50, 
            (signed char)0,        (signed char)4}, 
   {        (signed char)0,        (signed char)20,        (signed char)80,        (signed char)100, 
            (signed char)0,        (signed char)4}, 
   {        (signed char)20,        (signed char)50,        (signed char)100,        (signed char)80, 
            (signed char)0,        (signed char)4}, 
   {        (signed char)0,        (signed char)20,        (signed char)80,        (signed char)100, 
            (signed char)0,        (signed char)8}, 
   {        (signed char)40,        (signed char)80,        (signed char)100,        (signed char)80, 
            (signed char)6,        (signed char)0}, 
   {        (signed char)50,        (signed char)100,        (signed char)60,        (signed char)10, 
            (signed char)0,        (signed char)8}, 
   {        (signed char)30,        (signed char)100,        (signed char)60,        (signed char)5, 
            (signed char)0,        (signed char)6}, 
   {        (signed char)0,        (signed char)50,        (signed char)80,        (signed char)100, 
            (signed char)0,        (signed char)8}, 
   {        (signed char)50,        (signed char)100,        (signed char)80,        (signed char)60, 
            (signed char)8,        (signed char)0}, 
   {        (signed char)100,        (signed char)100,        (signed char)80,        (signed char)60, 
            (signed char)4,        (signed char)4}};
#line 212 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   EnemyKingDistanceBonus[10]  = 
#line 212
  {      (short const   )0,      (short const   )6,      (short const   )4,      (short const   )-1, 
        (short const   )-3,      (short const   )-4,      (short const   )-6,      (short const   )-8, 
        (short const   )-10,      (short const   )-12};
#line 216 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   OwnKingDistanceBonus[10]  = 
#line 216
  {      (short const   )0,      (short const   )5,      (short const   )2,      (short const   )1, 
        (short const   )0,      (short const   )-1,      (short const   )-2,      (short const   )-3, 
        (short const   )-4,      (short const   )-5};
#line 221 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int const   PromotionZoneDistanceBonus[9]  = 
#line 221
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )2,      (int const   )6,      (int const   )6,      (int const   )8, 
        (int const   )8};
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   BMBLTY[20]  = 
#line 233
  {      (short const   )0,      (short const   )2,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )14,      (short const   )14, 
        (short const   )16,      (short const   )16,      (short const   )16,      (short const   )16};
#line 237 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   RMBLTY[20]  = 
#line 237
  {      (short const   )0,      (short const   )2,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )14,      (short const   )14, 
        (short const   )16,      (short const   )16,      (short const   )16,      (short const   )16};
#line 242 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   LMBLTY[8]  = 
#line 242
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )4,      (short const   )6,      (short const   )8,      (short const   )10};
#line 246 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   MBLTY[15]  = 
#line 246
  {      (short const   )0,      (short const   )2,      (short const   )1,      (short const   )10, 
        (short const   )5,      (short const   )5,      (short const   )1,      (short const   )1, 
        (short const   )5,      (short const   )5,      (short const   )5,      (short const   )5, 
        (short const   )1,      (short const   )1,      (short const   )4};
#line 257 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short const   KTHRT[36]  = 
#line 257
  {      (short const   )0,      (short const   )-8,      (short const   )-20,      (short const   )-36, 
        (short const   )-52,      (short const   )-68,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80, 
        (short const   )-80,      (short const   )-80,      (short const   )-80,      (short const   )-80};
#line 262 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char fvalue[2][31]  ;
#line 267 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
struct signature threats_signature[2]  = {      {0xffffffffffffffffUL, 0xffffffffffffffffUL}, 
        {0xffffffffffffffffUL, 0xffffffffffffffffUL}};
#line 276 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
struct signature squares_signature  =    {0UL, 0UL};
#line 279 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short target[2]  ;
#line 279 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short seed[2]  ;
#line 279 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short loose[2]  ;
#line 279 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short hole[2]  ;
#line 281 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short captured[2]  ;
#line 282 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short dcaptured[2]  ;
#line 284 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
signed char Kdist[2][81]  ;
#line 286 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short MAXADIST  ;
#line 286 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short MAXCDIST  ;
#line 288 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
char GameType[2]  = {      (char )'U',      (char )'U'};
#line 291 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short attack_opening_sequence[2]  ;
#line 292 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short castle_opening_sequence[2]  ;
#line 294 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mpawn[2][81]  ;
#line 295 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Msilver[2][81]  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mgold[2][81]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mking[2][81]  ;
#line 299 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mlance[2][81]  ;
#line 300 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mknight[2][81]  ;
#line 302 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mbishop[2][81]  ;
#line 303 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char Mrook[2][81]  ;
#line 311 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
Mpiece_array *Mpiece[15]  = 
#line 311
  {      (Mpiece_array *)((void *)0),      & Mpawn,      & Mlance,      & Mknight, 
        & Msilver,      & Mgold,      & Mbishop,      & Mrook, 
        & Mgold,      & Mgold,      & Mgold,      & Mgold, 
        & Mbishop,      & Mrook,      & Mking};
#line 324 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short c1  ;
#line 324 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short c2  ;
#line 325 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char *PC1  ;
#line 325 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char *PC2  ;
#line 326 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static signed char *fv1  ;
#line 327 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static long *atk1  ;
#line 327 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static long *atk2  ;
#line 328 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static long a1  ;
#line 328 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static long a2  ;
#line 335 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short on_csquare(short side , short piece , short square ) 
{ 
  short sq ;
  int tmp ;

  {
#line 340
  if ((int )side == 0) {
#line 340
    sq = square;
  } else {
#line 340
    sq = (short )(80 - (int )square);
  }
#line 340
  if ((int )board[sq] == (int )piece) {
#line 340
    if ((int )color[sq] == (int )side) {
#line 340
      tmp = 1;
    } else {
#line 340
      tmp = 0;
    }
  } else {
#line 340
    tmp = 0;
  }
#line 340
  return ((short )tmp);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short on_column(short side , short piece , short c ) 
{ 
  short sq ;
  short tmp ;

  {
#line 350
  sq = c;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! ((int )sq < 81)) {
#line 350
      goto while_break;
    }
    {
#line 352
    tmp = on_csquare(side, piece, sq);
    }
#line 352
    if (tmp) {
#line 353
      return ((short)1);
    }
#line 350
    sq = (short )((int )sq + 9);
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return ((short)0);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short on_left_side(short side , short piece ) 
{ 
  short c ;
  short tmp ;

  {
#line 368
  c = (short)0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((int )c < 4)) {
#line 368
      goto while_break;
    }
    {
#line 370
    tmp = on_column(side, piece, c);
    }
#line 370
    if (tmp) {
#line 371
      return ((short)1);
    }
#line 368
    c = (short )((int )c + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((short)0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short on_right_side(short side , short piece ) 
{ 
  short c ;
  short tmp ;

  {
#line 383
  c = (short)5;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! ((int )c < 9)) {
#line 383
      goto while_break;
    }
    {
#line 385
    tmp = on_column(side, piece, c);
    }
#line 385
    if (tmp) {
#line 386
      return ((short)1);
    }
#line 383
    c = (short )((int )c + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return ((short)0);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
void threats(short side ) 
{ 
  short u ;
  short sq ;
  long c ;
  long *a ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short i___0 ;
  short kd ;
  short piece ;
  short xside___0 ;
  signed char *PL ;
  short ptyp ;

  {
#line 419
  if (threats_signature[side].hashbd == hashbd) {
#line 419
    if (threats_signature[side].hashkey == hashkey) {
#line 422
      return;
    }
  }
  {
#line 425
  a = attack[side];
#line 426
  xside___0 = (short )((int )side ^ 1);
#line 428
  memset((void *)a, 0, 81UL * sizeof(*(a + 0)));
#line 430
  PL = PieceList[side];
#line 432
  i___0 = (short )PieceCnt[side];
  }
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! ((int )i___0 >= 0)) {
#line 432
      goto while_break;
    }
#line 436
    sq = (short )*(PL + i___0);
#line 437
    piece = (short )board[sq];
#line 438
    ptyp = (short )ptype[side][piece];
#line 439
    c = (long )control[piece];
#line 443
    ppos = (*(nextpos[ptyp]))[sq];
#line 444
    pdir = (*(nextdir[ptyp]))[sq];
#line 445
    u = (short )*(ppos + sq);
    {
#line 448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      *(a + u) = (*(a + u) + 1L) | c;
#line 452
      kd = (short )Kdist[xside___0][u];
#line 452
      if ((int )kd < 2) {
#line 454
        sseed[sq] = (signed char )((int )sseed[sq] + (2 - (int )kd));
#line 455
        seed[side] = (short )((int )seed[side] + 1);
      }
#line 463
      if ((int )color[u] == 2) {
#line 463
        u = (short )*(ppos + u);
      } else {
#line 463
        u = (short )*(pdir + u);
      }
#line 448
      if (! ((int )u != (int )sq)) {
#line 448
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 432
    i___0 = (short )((int )i___0 - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  threats_signature[side].hashbd = hashbd;
#line 470
  threats_signature[side].hashkey = hashkey;
#line 471
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void add_target(short sq , short side , short id ) 
{ 
  short isq ;
  short tsq ;
  short xside___0 ;

  {
#line 486
  isq = (short )inunmap[sq];
#line 487
  if ((int )side == 0) {
#line 487
    tsq = (short )nunmap[(int )isq + (int )id];
  } else {
#line 487
    tsq = (short )nunmap[(int )isq - (int )id];
  }
#line 489
  if ((int )tsq >= 0) {
#line 491
    xside___0 = (short )((int )side ^ 1);
#line 491
    target[xside___0] = (short )((int )target[xside___0] + 1);
#line 493
    if (attack[side][tsq]) {
#line 494
      starget[xside___0][tsq] = (signed char )((int )starget[xside___0][tsq] + 1);
    } else {
#line 496
      starget[xside___0][tsq] = (signed char )((int )starget[xside___0][tsq] + 2);
    }
  }
#line 498
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void CheckTargetPiece(short sq , short side ) 
{ 


  {
  {
#line 512
  if ((int )board[sq] == 1) {
#line 512
    goto case_1;
  }
#line 517
  if ((int )board[sq] == 14) {
#line 517
    goto case_14;
  }
#line 523
  if ((int )board[sq] == 7) {
#line 523
    goto case_7;
  }
#line 530
  if ((int )board[sq] == 6) {
#line 530
    goto case_6;
  }
#line 535
  if ((int )board[sq] == 3) {
#line 535
    goto case_3;
  }
#line 510
  goto switch_break;
  case_1: /* CIL Label */ 
#line 513
  if (! attack[side][sq]) {
    {
#line 514
    add_target(sq, side, (short)11);
    }
  }
#line 515
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 518
  add_target(sq, side, (short)10);
#line 519
  add_target(sq, side, (short)11);
#line 520
  add_target(sq, side, (short)12);
  }
#line 521
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 524
  add_target(sq, side, (short)10);
#line 525
  add_target(sq, side, (short)12);
#line 526
  add_target(sq, side, (short)-10);
#line 527
  add_target(sq, side, (short)-12);
  }
#line 528
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 531
  add_target(sq, side, (short)11);
  }
#line 532
  goto switch_break;
  case_3: /* CIL Label */ 
#line 537
  if ((int )sq != 1) {
#line 537
    if ((int )sq != 7) {
#line 537
      if ((int )sq != 73) {
#line 537
        if ((int )sq != 79) {
          {
#line 538
          add_target(sq, side, (short)11);
          }
        }
      }
    }
  }
#line 539
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 542
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short ScoreKingOpeningFeatures(void) 
{ 
  short s ;
  short sq ;
  short ds ;
  short c ;
  int tmp ;
  short c___0 ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 549
  s = (short)0;
#line 549
  sq = (short )PieceList[c1][0];
#line 551
  if ((int )GameType[c1] == 83) {
#line 555
    if ((int )c1 == 0) {
#line 555
      tmp = (int )sq;
    } else {
#line 555
      tmp = 80 - (int )sq;
    }
#line 555
    c = (short )(4 - tmp % 9);
#line 557
    if ((int )c < 0) {
#line 558
      ds = (short )((- ((int )c) - (int )c) - (int )*(fv1 + 12));
#line 558
      s = (short )((int )s + (int )ds);
    } else
#line 557
    if ((int )c == 0) {
#line 557
      if ((int )sq != (int )kingP[c1]) {
#line 558
        ds = (short )((- ((int )c) - (int )c) - (int )*(fv1 + 12));
#line 558
        s = (short )((int )s + (int )ds);
      }
    }
  } else
#line 560
  if ((int )GameType[c1] == 82) {
#line 564
    if ((int )c1 == 0) {
#line 564
      tmp___0 = (int )sq;
    } else {
#line 564
      tmp___0 = 80 - (int )sq;
    }
#line 564
    c___0 = (short )(4 - tmp___0 % 9);
#line 566
    if ((int )c___0 > 0) {
#line 568
      ds = (short )((- ((int )c___0) - (int )c___0) - (int )*(fv1 + 12));
#line 568
      s = (short )((int )s + (int )ds);
    } else
#line 566
    if ((int )c___0 == 0) {
#line 566
      if ((int )sq != (int )kingP[c1]) {
#line 568
        ds = (short )((- ((int )c___0) - (int )c___0) - (int )*(fv1 + 12));
#line 568
        s = (short )((int )s + (int )ds);
      }
    }
#line 572
    if ((int )sq != (int )kingP[c1]) {
      {
#line 574
      tmp___1 = on_csquare(c1, (short)7, (short)16);
      }
#line 574
      if (tmp___1) {
#line 576
        ds = (short )(-4 * (int )*(fv1 + 12));
#line 576
        s = (short )((int )s + (int )ds);
      }
    } else {
      {
#line 582
      tmp___2 = on_csquare(c1, (short)7, (short)16);
      }
#line 582
      if (! tmp___2) {
#line 584
        ds = (short )(-2 * (int )*(fv1 + 12));
#line 584
        s = (short )((int )s + (int )ds);
      }
    }
#line 590
    if ((int )c1 == 0) {
#line 590
      tmp___5 = (int )sq;
    } else {
#line 590
      tmp___5 = 80 - (int )sq;
    }
#line 590
    if (tmp___5 % 9 < 6) {
#line 592
      if ((int )c1 == 0) {
#line 592
        tmp___3 = 5;
      } else {
#line 592
        tmp___3 = 75;
      }
#line 592
      if (Mvboard[tmp___3]) {
#line 594
        ds = (short )(-2 * (int )*(fv1 + 12));
#line 594
        s = (short )((int )s + (int )ds);
      } else {
#line 592
        if ((int )c1 == 0) {
#line 592
          tmp___4 = 6;
        } else {
#line 592
          tmp___4 = 74;
        }
#line 592
        if (Mvboard[tmp___4]) {
#line 594
          ds = (short )(-2 * (int )*(fv1 + 12));
#line 594
          s = (short )((int )s + (int )ds);
        }
      }
    }
  }
#line 599
  return (s);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void ExamineSquares(void) 
{ 
  short sq ;
  short side ;
  short piece ;
  short n ;
  short tmp ;

  {
#line 610
  if (squares_signature.hashbd == hashbd) {
#line 610
    if (squares_signature.hashkey == hashkey) {
#line 613
      return;
    }
  }
  {
#line 616
  memset((void *)(shole), 0, sizeof(shole));
#line 617
  memset((void *)(sloose), 0, sizeof(sloose));
#line 618
  memset((void *)(starget), 0, sizeof(starget));
#line 620
  target[1] = (short)0;
#line 620
  target[0] = target[1];
#line 620
  loose[1] = target[0];
#line 620
  loose[0] = loose[1];
#line 620
  hole[1] = loose[0];
#line 620
  hole[0] = hole[1];
#line 623
  sq = (short)0;
  }
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! ((int )sq < 81)) {
#line 623
      goto while_break;
    }
#line 625
    side = (short )color[sq];
#line 625
    if ((int )side == 2) {
#line 627
      if ((int )sq > 53) {
#line 629
        if (! attack[1][sq]) {
#line 631
          shole[sq] = (signed char)1;
#line 632
          hole[1] = (short )((int )hole[1] + 1);
        }
      } else
#line 635
      if ((int )sq < 27) {
#line 637
        if (! attack[0][sq]) {
#line 639
          shole[sq] = (signed char)1;
#line 640
          hole[0] = (short )((int )hole[0] + 1);
        }
      }
    } else {
#line 647
      if (! attack[side][sq]) {
#line 649
        sloose[sq] = (signed char)1;
#line 650
        loose[side] = (short )((int )loose[side] + 1);
      }
      {
#line 653
      CheckTargetPiece(sq, side);
      }
    }
#line 623
    sq = (short )((int )sq + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  side = (short)0;
  {
#line 657
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 657
    if (! ((int )side <= 1)) {
#line 657
      goto while_break___0;
    }
#line 659
    tmp = (short)0;
#line 659
    dcaptured[side] = tmp;
#line 659
    captured[side] = tmp;
#line 661
    piece = (short)1;
    {
#line 661
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 661
      if (! ((int )piece <= 7)) {
#line 661
        goto while_break___1;
      }
#line 663
      n = (short )Captured[side][piece];
#line 663
      if ((int )n != 0) {
#line 665
        if ((int )piece != 1) {
#line 666
          captured[side] = (short )((int )captured[side] + (int )n);
        }
#line 668
        dcaptured[side] = (short )((int )dcaptured[side] + 1);
      }
#line 661
      piece = (short )((int )piece + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 657
    side = (short )((int )side + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 674
  squares_signature.hashbd = hashbd;
#line 674
  squares_signature.hashkey = hashkey;
#line 675
  return;
}
}
#line 710 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
int evaluate(short side , short ply , short alpha___0 , short beta___0 , short INCscore___0 ,
             short *InChk , short *blockable ) 
{ 
  short xside___0 ;
  short s ;
  short sq ;
  int tmp ;
  short sq___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 722
  xside___0 = (short )((int )side ^ 1);
#line 723
  s = (short )((- ((int )Pscore[(int )ply - 1]) + (int )mtl[side]) - (int )mtl[xside___0]);
#line 724
  hung[1] = (short)0;
#line 724
  hung[0] = hung[1];
#line 727
  if ((int )ply == 1) {
#line 727
    goto _L;
  } else
#line 727
  if ((int )ply == (int )Sdepth) {
#line 727
    goto _L;
  } else
#line 727
  if ((int )ply > (int )Sdepth) {
#line 727
    if ((int )s >= (int )alpha___0 - 30) {
#line 727
      if ((int )s <= (int )beta___0 + 30) {
#line 727
        goto _L;
      } else {
#line 727
        goto _L___2;
      }
    } else {
#line 727
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 727
  if (use_etable) {
    {
#line 727
    tmp___2 = CheckEETable(side);
    }
#line 727
    if (tmp___2) {
      _L: /* CIL Label */ 
      {
#line 738
      memset((void *)(sseed), 0, sizeof(sseed));
#line 740
      seed[1] = (short)0;
#line 740
      seed[0] = seed[1];
#line 741
      threats(side);
#line 743
      sq = (short )PieceList[xside___0][0];
      }
#line 743
      if (attack[side][sq] != 0L) {
#line 743
        if ((int )board[sq] == 14) {
#line 745
          sq = (short )PieceList[side][0];
#line 745
          if ((int )board[sq] == 14) {
            {
#line 745
            tmp = SqAttacked(sq, xside___0, blockable);
#line 745
            *InChk = (short )tmp;
            }
          } else {
#line 745
            *InChk = (short)0;
          }
#line 749
          return (13001 - (int )ply);
        }
      }
      {
#line 752
      threats(xside___0);
#line 753
      sq = (short )PieceList[side][0];
      }
#line 753
      if ((int )board[sq] == 14) {
#line 753
        *InChk = (short )(attack[xside___0][sq] != 0L);
      } else {
#line 753
        *InChk = (short)0;
      }
#line 756
      *blockable = (short)1;
#line 757
      EvalNodes ++;
#line 759
      if ((int )ply > 4) {
#line 760
        PUTVAR = 1;
      }
      {
#line 762
      ExamineSquares();
#line 763
      s = ScorePosition(side);
#line 764
      PUTVAR = 0;
      }
    } else {
#line 727
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 771
    sq___0 = (short )PieceList[side][0];
#line 771
    if ((int )board[sq___0] == 14) {
      {
#line 771
      tmp___0 = SqAttacked(sq___0, xside___0, blockable);
#line 771
      *InChk = (short )tmp___0;
      }
    } else {
#line 771
      *InChk = (short)0;
    }
#line 775
    sq___0 = (short )PieceList[xside___0][0];
#line 775
    if ((int )board[sq___0] == 14) {
      {
#line 775
      tmp___1 = SqAttacked(sq___0, side, blockable);
      }
#line 775
      if (tmp___1) {
#line 778
        return (13001 - (int )ply);
      }
    }
  }
#line 782
  Pscore[ply] = (short )(((int )s - (int )mtl[side]) + (int )mtl[xside___0]);
#line 783
  if (*InChk) {
#line 783
    ChkFlag[(int )ply - 1] = Pindex[TOsquare];
  } else {
#line 783
    ChkFlag[(int )ply - 1] = (signed char)0;
  }
#line 785
  return ((int )s);
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short value_of_weakest_attacker(long a2___0 ) 
{ 
  short piece ;
  short min_value ;
  short v ;

  {
#line 795
  min_value = (short)12000;
#line 797
  piece = (short)1;
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (! ((int )piece <= 14)) {
#line 797
      goto while_break;
    }
#line 799
    if (control[piece] & (long const   )a2___0) {
#line 801
      v = (*value)[stage][piece];
#line 801
      if ((int )min_value > (int )v) {
#line 802
        min_value = v;
      }
    }
#line 797
    piece = (short )((int )piece + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  return (min_value);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
int BRLscan(short sq , short *mob ) 
{ 
  unsigned char *ppos ;
  unsigned char *pdir ;
  short s ;
  short mobx ;
  short u ;
  short xu ;
  short pin ;
  short ptyp ;
  short csq ;
  short piece ;
  short upiece ;
  short xupiece ;
  short rvalue ;
  short ds ;
  signed char *Kd ;
  int tmp ;

  {
#line 832
  csq = (short )((int )sq % 9);
#line 834
  Kd = Kdist[c2];
#line 836
  s = (short)0;
#line 836
  mobx = s;
#line 837
  piece = (short )board[sq];
#line 839
  rvalue = (*value)[stage][piece];
#line 840
  upiece = (short )unpromoted[piece];
#line 840
  ptyp = (short )ptype[c1][upiece];
#line 841
  rvalue = (*value)[stage][upiece];
#line 846
  ppos = (*(nextpos[ptyp]))[sq];
#line 847
  pdir = (*(nextdir[ptyp]))[sq];
#line 848
  u = (short )*(ppos + sq);
#line 851
  pin = (short)-1;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if ((int )*(Kd + u) < 2) {
#line 857
      ds = (short )((int )*(fv1 + 7) * (2 - (int )*(Kd + u)));
#line 857
      s = (short )((int )s + (int )ds);
    }
#line 860
    ds = (short )starget[c1][u];
#line 860
    if ((int )ds != 0) {
#line 863
      if ((int )pin < 0) {
#line 866
        ds = (short )((int )ds * (int )*(fv1 + 16));
#line 866
        s = (short )((int )s + (int )ds);
      } else
#line 863
      if ((int )color[pin] == (int )c2) {
#line 866
        ds = (short )((int )ds * (int )*(fv1 + 16));
#line 866
        s = (short )((int )s + (int )ds);
      }
    }
#line 870
    ds = (short )shole[u];
#line 870
    if ((int )ds != 0) {
#line 873
      ds = (short )*(fv1 + 4);
#line 873
      s = (short )((int )s + (int )ds);
    } else {
#line 875
      if ((int )c1 == 0) {
#line 875
        tmp = (int )u > 53;
      } else {
#line 875
        tmp = (int )u < 27;
      }
#line 875
      if (tmp) {
#line 878
        ds = (short )((int )*(fv1 + 4) / 2);
#line 878
        s = (short )((int )s + (int )ds);
      }
    }
#line 881
    if ((int )color[u] == 2) {
#line 891
      xu = (short )*(ppos + u);
#line 891
      if ((int )xu == (int )*(pdir + u)) {
#line 892
        pin = (short)-1;
      }
#line 894
      u = xu;
#line 895
      mobx = (short )((int )mobx + 1);
    } else
#line 900
    if ((int )pin < 0) {
#line 903
      if ((int )color[u] == (int )c1) {
#line 907
        if ((int )upiece == 2) {
#line 910
          if ((int )board[u] == 1) {
#line 912
            ds = (short )(2 * (int )*(fv1 + 8));
#line 912
            s = (short )((int )s + (int )ds);
          } else
#line 914
          if (! flag.tsume) {
#line 914
            if ((int )stage < 33) {
#line 916
              ds = (short )(-2 * (int )*(fv1 + 8));
#line 916
              s = (short )((int )s + (int )ds);
            }
          }
        } else
#line 923
        if ((int )upiece == 6) {
#line 923
          if ((int )board[u] == 1) {
#line 923
            if ((int )GameType[c1] == 83) {
#line 926
              ds = (short )(-2 * (int )*(fv1 + 9));
#line 926
              s = (short )((int )s + (int )ds);
            } else {
#line 923
              goto _L___0;
            }
          } else {
#line 923
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 929
        if ((int )upiece == 7) {
#line 929
          if ((int )board[u] == 2) {
#line 929
            if ((int )GameType[c1] == 83) {
#line 929
              if ((int )u % 9 == (int )csq) {
#line 933
                ds = (short )*(fv1 + 11);
#line 933
                s = (short )((int )s + (int )ds);
              }
            }
          }
        }
      } else
#line 942
      if ((int )upiece == 2) {
#line 945
        if ((int )board[u] == 1) {
#line 947
          ds = (short )(-2 * (int )*(fv1 + 8));
#line 947
          s = (short )((int )s + (int )ds);
        } else
#line 949
        if (! flag.tsume) {
#line 949
          if ((int )stage < 33) {
#line 951
            ds = (short )(2 * (int )*(fv1 + 8));
#line 951
            s = (short )((int )s + (int )ds);
          }
        }
      } else
#line 958
      if ((int )board[u] == 1) {
#line 960
        ds = (short )(- ((int )*(fv1 + 9)));
#line 960
        s = (short )((int )s + (int )ds);
      }
#line 972
      xu = (short )*(ppos + u);
#line 972
      if ((int )xu != (int )*(pdir + u)) {
#line 973
        pin = u;
      }
#line 975
      u = xu;
    } else {
#line 981
      if ((int )color[u] == (int )c1) {
#line 984
        if ((int )upiece == 6) {
#line 984
          if ((int )board[u] == 1) {
#line 984
            if ((int )GameType[c1] == 83) {
#line 987
              ds = (short )(- ((int )*(fv1 + 9)));
#line 987
              s = (short )((int )s + (int )ds);
            }
          }
        }
      } else {
#line 993
        if ((int )upiece == 6) {
#line 993
          if ((int )board[u] == 1) {
#line 995
            ds = (short )(- ((int )*(fv1 + 9)) / 2);
#line 995
            s = (short )((int )s + (int )ds);
          }
        }
#line 998
        xupiece = (short )unpromoted[board[u]];
#line 998
        if ((int )(*value)[stage][xupiece] > (int )rvalue) {
#line 998
          goto _L___1;
        } else
#line 998
        if (*(atk2 + u) == 0L) {
          _L___1: /* CIL Label */ 
#line 1002
          if ((int )color[pin] == (int )c2) {
#line 1004
            if ((int )xupiece == 14) {
#line 1004
              if (flag.tsume) {
#line 1006
                ds = (short )(2 * (int )*(fv1 + 10));
#line 1006
                s = (short )((int )s + (int )ds);
              } else
#line 1004
              if ((int )stage > 66) {
#line 1006
                ds = (short )(2 * (int )*(fv1 + 10));
#line 1006
                s = (short )((int )s + (int )ds);
              } else {
#line 1010
                ds = (short )*(fv1 + 10);
#line 1010
                s = (short )((int )s + (int )ds);
              }
            } else {
#line 1010
              ds = (short )*(fv1 + 10);
#line 1010
              s = (short )((int )s + (int )ds);
            }
#line 1013
            if (*(atk2 + pin) == 0L) {
#line 1016
              hung[c2] = (short )((int )hung[c2] + 1);
#line 1017
              shung[u] = (signed char )((int )shung[u] + 1);
            } else
#line 1013
            if (*(atk1 + pin) > (long )(control[board[pin]] + 1L)) {
#line 1016
              hung[c2] = (short )((int )hung[c2] + 1);
#line 1017
              shung[u] = (signed char )((int )shung[u] + 1);
            }
          } else
#line 1023
          if ((int )upiece == 2) {
#line 1025
            ds = (short )((int )*(fv1 + 11) / 2);
#line 1025
            s = (short )((int )s + (int )ds);
          } else {
#line 1030
            ds = (short )*(fv1 + 11);
#line 1030
            s = (short )((int )s + (int )ds);
          }
        }
      }
#line 1036
      pin = (short)-1;
#line 1041
      u = (short )*(pdir + u);
    }
#line 853
    if (! ((int )u != (int )sq)) {
#line 853
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1048
  *mob = mobx;
#line 1050
  return ((int )s);
}
}
#line 1085 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short KingScan(short sq ) 
{ 
  short cnt___1 ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short s ;
  short u ;
  short ptyp ;
  short ok ;
  short ds ;
  short p ;
  short ptyp___0 ;
  int tmp ;
  short ptype_piece ;

  {
#line 1102
  s = (short)0;
#line 1103
  cnt___1 = (short)0;
#line 1108
  p = (short)1;
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1108
    if (! ((int )p < 14)) {
#line 1108
      goto while_break;
    }
#line 1110
    if (HasPiece[c2][p]) {
#line 1110
      goto _L;
    } else
#line 1110
    if (Captured[c2][p]) {
      _L: /* CIL Label */ 
#line 1119
      ptyp___0 = (short )ptype[c1][p];
#line 1124
      ppos = (*(nextpos[ptyp___0]))[sq];
#line 1125
      pdir = (*(nextdir[ptyp___0]))[sq];
#line 1126
      u = (short )*(ppos + sq);
      {
#line 1129
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1135
        if (*(atk2 + u) & (long )control[p]) {
#line 1136
          if ((int )color[u] != (int )c2) {
#line 1136
            if (*(atk1 + u) == 0L) {
#line 1136
              cnt___1 = (short )((int )cnt___1 + 1);
            } else
#line 1136
            if ((*(atk2 + u) & 255L) != 0L) {
#line 1136
              cnt___1 = (short )((int )cnt___1 + 1);
            } else {
#line 1136
              ds = (short )(- ((int )*(fv1 + 7)));
#line 1136
              s = (short )((int )s + (int )ds);
            }
          }
        } else {
#line 1137
          if (Captured[c2][p]) {
#line 1137
            if (color[u]) {
#line 1137
              tmp = 1;
            } else {
#line 1137
              tmp = 0;
            }
          } else {
#line 1137
            tmp = 0;
          }
#line 1137
          if (tmp == 2) {
#line 1138
            if ((int )color[u] != (int )c2) {
#line 1138
              if (*(atk1 + u) == 0L) {
#line 1138
                cnt___1 = (short )((int )cnt___1 + 1);
              } else
#line 1138
              if ((*(atk2 + u) & 255L) != 0L) {
#line 1138
                cnt___1 = (short )((int )cnt___1 + 1);
              } else {
#line 1138
                ds = (short )(- ((int )*(fv1 + 7)));
#line 1138
                s = (short )((int )s + (int )ds);
              }
            }
          }
        }
#line 1145
        if ((int )color[u] == 2) {
#line 1145
          u = (short )*(ppos + u);
        } else {
#line 1145
          u = (short )*(pdir + u);
        }
#line 1129
        if (! ((int )u != (int )sq)) {
#line 1129
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1108
    p = (short )((int )p + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  ds = (short )(((int )*(fv1 + 17) * (int )KTHRT[cnt___1]) / 16);
#line 1153
  s = (short )((int )s + (int )ds);
#line 1157
  cnt___1 = (short)0;
#line 1158
  ok = (short)0;
#line 1159
  ptyp = (short )ptype[c1][14];
#line 1164
  pdir = (*(nextpos[ptyp]))[sq];
#line 1165
  u = (short )*(pdir + sq);
  {
#line 1168
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1170
    if (! ok) {
#line 1170
      if ((int )color[u] == (int )c1) {
#line 1172
        ptype_piece = (short )ptype[0][board[u]];
#line 1174
        if ((int )ptype_piece == 3) {
#line 1175
          ok = (short)1;
        } else
#line 1174
        if ((int )ptype_piece == 4) {
#line 1175
          ok = (short)1;
        }
      }
    }
#line 1178
    if (*(atk2 + u) > *(atk1 + u)) {
#line 1180
      cnt___1 = (short )((int )cnt___1 + 1);
#line 1182
      if (*(atk2 + u) & 1302528L) {
#line 1184
        ds = (short )(- ((int )*(fv1 + 17)) / 2);
#line 1184
        s = (short )((int )s + (int )ds);
      }
    }
#line 1191
    u = (short )*(pdir + u);
#line 1168
    if (! ((int )u != (int )sq)) {
#line 1168
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1196
  if (! ok) {
#line 1196
    goto _L___0;
  } else
#line 1196
  if ((int )cnt___1 > 1) {
    _L___0: /* CIL Label */ 
#line 1198
    if ((int )cnt___1 > 1) {
#line 1199
      ds = (short )(- ((int )*(fv1 + 17)) / 2);
#line 1199
      s = (short )((int )s + (int )ds);
    } else {
#line 1201
      ds = (short )(- ((int )*(fv1 + 17)));
#line 1201
      s = (short )((int )s + (int )ds);
    }
  }
#line 1204
  return (s);
}
}
#line 1208 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short checked_trapped  ;
#line 1216 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
int trapped(short sq ) 
{ 
  short u ;
  short ptyp ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short piece ;
  short rvalue ;

  {
#line 1228
  piece = (short )board[sq];
#line 1229
  rvalue = (*value)[stage][piece];
#line 1230
  ptyp = (short )ptype[c1][piece];
#line 1235
  ppos = (*(nextpos[ptyp]))[sq];
#line 1236
  pdir = (*(nextdir[ptyp]))[sq];
#line 1237
  u = (short )*(ppos + sq);
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    if ((int )color[u] != (int )c1) {
#line 1244
      if (*(atk2 + u) == 0L) {
#line 1245
        return (0);
      } else
#line 1244
      if ((int )(*value)[stage][board[u]] >= (int )rvalue) {
#line 1245
        return (0);
      }
    }
#line 1253
    if ((int )color[u] == 2) {
#line 1253
      u = (short )*(ppos + u);
    } else {
#line 1253
      u = (short )*(pdir + u);
    }
#line 1240
    if (! ((int )u != (int )sq)) {
#line 1240
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  checked_trapped = (short)1;
#line 1260
  return (1);
}
}
#line 1265 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int AttackedPieceValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  int tmp ;

  {
  {
#line 1270
  s = (short)0;
#line 1272
  ds = (short )(- ((int )*(fv1 + 1)) * 2);
#line 1273
  hung[c1] = (short )((int )hung[c1] + 1);
#line 1274
  shung[sq] = (signed char )((int )shung[sq] + 1);
#line 1276
  tmp = trapped(sq);
  }
#line 1276
  if (tmp) {
#line 1278
    hung[c1] = (short )((int )hung[c1] + 2);
#line 1279
    shung[sq] = (signed char )((int )shung[sq] + 2);
  }
#line 1282
  return ((int )s);
}
}
#line 1287 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int OpenFileValue(short sq , short hopn , short hopnx ) 
{ 
  short s ;
  short fyle ;

  {
#line 1290
  s = (short)0;
#line 1292
  fyle = (short )((int )sq % 9);
#line 1292
  if ((int )*(PC1 + fyle) == 0) {
#line 1294
    s = (short )((int )s + (int )hopn);
  }
#line 1297
  if ((int )*(PC2 + fyle) == 0) {
#line 1299
    s = (short )((int )s + (int )hopnx);
  }
#line 1302
  return ((int )s);
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PawnValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ccol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  short m ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1339
  s = (short)0;
#line 1341
  if ((int )c1 == 0) {
#line 1341
    tmp = (int )sq;
  } else {
#line 1341
    tmp = 80 - (int )sq;
  }
#line 1341
  ccol = (short )(tmp % 9);
#line 1343
  ds = (short )*(fv1 + 19);
#line 1343
  if (ds) {
#line 1343
    if ((int )c1 == 0) {
#line 1343
      tmp___0 = (int )sq;
    } else {
#line 1343
      tmp___0 = 80 - (int )sq;
    }
#line 1343
    ds = (short )(((int )ds * (int )PromotionZoneDistanceBonus[tmp___0 / 9]) * 3);
#line 1343
    s = (short )((int )s + (int )ds);
  }
#line 1346
  if ((int )c1 == 0) {
#line 1346
    tmp___1 = (int )sq + 9;
  } else {
#line 1346
    tmp___1 = (int )sq - 9;
  }
#line 1346
  if ((int )color[tmp___1] == 2) {
#line 1348
    ds = (short )MBLTY[1];
#line 1348
    s = (short )((int )s + (int )ds);
  }
#line 1351
  if (a1 & 525824L) {
#line 1353
    ds = (short )*(fv1 + 0);
#line 1353
    s = (short )((int )s + (int )ds);
  }
#line 1356
  if (! flag.tsume) {
#line 1356
    if ((int )stage < 33) {
#line 1364
      if ((int )c1 == 0) {
#line 1364
        tmp___3 = (int )sq;
      } else {
#line 1364
        tmp___3 = 80 - (int )sq;
      }
#line 1364
      if (tmp___3 / 9 == 2) {
#line 1366
        if ((int )c1 == 0) {
#line 1366
          tmp___2 = (int )sq + 27;
        } else {
#line 1366
          tmp___2 = (int )sq - 27;
        }
#line 1366
        if ((int )board[tmp___2] == 1) {
          {
#line 1376
          if ((int )ccol == 8) {
#line 1376
            goto case_8;
          }
#line 1376
          if ((int )ccol == 0) {
#line 1376
            goto case_8;
          }
#line 1380
          if ((int )ccol == 4) {
#line 1380
            goto case_4;
          }
#line 1384
          goto switch_default;
          case_8: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 1377
          if ((int )side == (int )c1) {
#line 1377
            m = (short)3;
          } else {
#line 1377
            m = (short)5;
          }
#line 1378
          goto switch_break;
          case_4: /* CIL Label */ 
#line 1381
          if ((int )side == (int )c1) {
#line 1381
            m = (short)2;
          } else {
#line 1381
            m = (short)3;
          }
#line 1382
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 1385
          if ((int )side == (int )c1) {
#line 1385
            m = (short)1;
          } else {
#line 1385
            m = (short)2;
          }
#line 1386
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 1389
          ds = (short )(- ((int )m) * (int )MBLTY[1]);
#line 1389
          s = (short )((int )s + (int )ds);
        }
      }
#line 1396
      if ((int )GameType[c1] == 83) {
#line 1396
        if ((int )c1 == 0) {
#line 1396
          tmp___5 = 43;
        } else {
#line 1396
          tmp___5 = 37;
        }
#line 1396
        if ((int )sq == tmp___5) {
#line 1398
          if ((int )c1 == 0) {
#line 1398
            tmp___4 = 52;
          } else {
#line 1398
            tmp___4 = 28;
          }
#line 1398
          if ((*(atk2 + tmp___4) & 255L) < 2L) {
#line 1400
            ds = (short )*(fv1 + 0);
#line 1400
            s = (short )((int )s + (int )ds);
          }
        }
      }
#line 1404
      if ((int )GameType[c2] == 83) {
#line 1404
        if ((int )ccol == 1) {
#line 1406
          if ((int )c1 == 0) {
#line 1406
            tmp___6 = 28;
          } else {
#line 1406
            tmp___6 = 52;
          }
#line 1406
          if ((int )sq == tmp___6) {
#line 1408
            ds = (short )(- ((int )*(fv1 + 0)));
#line 1408
            s = (short )((int )s + (int )ds);
          }
#line 1411
          if ((int )c1 == 0) {
#line 1411
            tmp___7 = 19;
          } else {
#line 1411
            tmp___7 = 61;
          }
#line 1411
          if ((*(atk1 + tmp___7) & 255L) < 2L) {
#line 1411
            if ((int )c1 == 0) {
#line 1411
              tmp___8 = 28;
            } else {
#line 1411
              tmp___8 = 52;
            }
#line 1411
            if ((*(atk1 + tmp___8) & 255L) < 2L) {
#line 1414
              ds = (short )(-2 * (int )*(fv1 + 0));
#line 1414
              s = (short )((int )s + (int )ds);
            }
          }
        }
      }
    }
  }
#line 1420
  return ((int )s);
}
}
#line 1429 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int LanceValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;
  int tmp ;
  int tmp___0 ;

  {
#line 1432
  s = (short)0;
#line 1434
  ds = (short )*(fv1 + 20);
#line 1434
  if (ds) {
#line 1434
    ad = (short )Kdist[c1][sq];
#line 1434
    if ((int )ad <= 2) {
#line 1434
      ds = (short )((int )ds * (int )OwnKingDistanceBonus[ad]);
#line 1434
      s = (short )((int )s + (int )ds);
    }
  }
  {
#line 1436
  OpenFileValue(sq, (short )(- ((int )*(fv1 + 18))), (short )*(fv1 + 18));
  }
#line 1438
  if (! checked_trapped) {
#line 1438
    if ((int )c1 == 0) {
#line 1438
      tmp___0 = (int )sq;
    } else {
#line 1438
      tmp___0 = 80 - (int )sq;
    }
#line 1438
    if (tmp___0 / 9 > 2) {
#line 1440
      if (! flag.tsume) {
#line 1440
        if ((int )stage < 33) {
#line 1442
          ds = (short )(-3 * (int )*(fv1 + 0));
#line 1442
          s = (short )((int )s + (int )ds);
        } else {
#line 1440
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1440
        tmp = trapped(sq);
        }
#line 1440
        if (tmp) {
#line 1442
          ds = (short )(-3 * (int )*(fv1 + 0));
#line 1442
          s = (short )((int )s + (int )ds);
        } else {
#line 1446
          ds = (short )(-2 * (int )*(fv1 + 0));
#line 1446
          s = (short )((int )s + (int )ds);
        }
      }
    }
  }
#line 1450
  return ((int )s);
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int KnightValue(short sq , short side ) 
{ 
  short s ;
  short ad ;
  short ds ;
  short checked_trapped___0 ;
  short c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1462
  s = (short)0;
#line 1463
  checked_trapped___0 = (short)0;
#line 1464
  c = (short )((int )sq % 9);
#line 1466
  ds = (short )*(fv1 + 19);
#line 1466
  if (ds) {
#line 1466
    if ((int )c1 == 0) {
#line 1466
      tmp = (int )sq;
    } else {
#line 1466
      tmp = 80 - (int )sq;
    }
#line 1466
    ds = (short )((int )ds * (int )PromotionZoneDistanceBonus[tmp / 9]);
#line 1466
    s = (short )((int )s + (int )ds);
  }
#line 1467
  ds = (short )*(fv1 + 20);
#line 1467
  if (ds) {
#line 1467
    ad = (short )Kdist[c1][sq];
#line 1467
    if ((int )ad <= 2) {
#line 1467
      ds = (short )((int )ds * (int )OwnKingDistanceBonus[ad]);
#line 1467
      s = (short )((int )s + (int )ds);
    }
  }
#line 1469
  if (! checked_trapped___0) {
#line 1469
    if ((int )c1 == 0) {
#line 1469
      tmp___1 = (int )sq;
    } else {
#line 1469
      tmp___1 = 80 - (int )sq;
    }
#line 1469
    if (tmp___1 / 9 > 2) {
      {
#line 1471
      tmp___0 = trapped(sq);
      }
#line 1471
      if (tmp___0) {
#line 1473
        ds = (short )(-4 * (int )*(fv1 + 0));
#line 1473
        s = (short )((int )s + (int )ds);
      } else {
#line 1477
        ds = (short )(-3 * (int )*(fv1 + 0));
#line 1477
        s = (short )((int )s + (int )ds);
      }
    }
  }
#line 1481
  if ((int )c == 0) {
#line 1483
    ds = (short )(- ((int )*(fv1 + 0)));
#line 1483
    s = (short )((int )s + (int )ds);
  } else
#line 1481
  if ((int )c == 8) {
#line 1483
    ds = (short )(- ((int )*(fv1 + 0)));
#line 1483
    s = (short )((int )s + (int )ds);
  }
#line 1486
  return ((int )s);
}
}
#line 1496 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int SilverValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;
  short csq ;
  int tmp ;

  {
#line 1499
  s = (short)0;
#line 1501
  ds = (short )*(fv1 + 20);
#line 1501
  if (ds) {
#line 1501
    ad = (short )Kdist[c1][sq];
#line 1501
    if ((int )ad <= 3) {
#line 1501
      ds = (short )(((int )ds * (int )OwnKingDistanceBonus[ad]) * 2);
#line 1501
      s = (short )((int )s + (int )ds);
    }
  }
#line 1503
  if ((int )Kdist[c1][sq] < 3) {
#line 1503
    if (*(atk1 + sq) & (long )(control[5] | control[4])) {
#line 1506
      ds = (short )*(fv1 + 29);
#line 1506
      s = (short )((int )s + (int )ds);
    }
  }
#line 1509
  if (! flag.tsume) {
#line 1509
    if ((int )stage < 33) {
#line 1515
      if ((int )GameType[c1] == 83) {
#line 1517
        if ((int )c1 == 0) {
#line 1517
          tmp = (int )sq;
        } else {
#line 1517
          tmp = 80 - (int )sq;
        }
#line 1517
        if (tmp == 12) {
#line 1521
          if ((int )c1 == 0) {
#line 1521
            csq = (short)20;
          } else {
#line 1521
            csq = (short)60;
          }
#line 1521
          if ((int )board[csq] == 6) {
#line 1521
            if ((int )color[csq] == (int )c1) {
#line 1524
              ds = (short )(-2 * (int )*(fv1 + 12));
#line 1524
              s = (short )((int )s + (int )ds);
            }
          }
        }
      }
    } else {
#line 1509
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1532
    ds = (short )*(fv1 + 20);
#line 1532
    if (ds) {
#line 1532
      ad = (short )Kdist[c2][sq];
#line 1532
      if ((int )ad <= 3) {
#line 1532
        ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 2);
#line 1532
        s = (short )((int )s + (int )ds);
      }
    }
  }
#line 1535
  return ((int )s);
}
}
#line 1544 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int GoldValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;
  int tmp ;

  {
#line 1547
  s = (short)0;
#line 1549
  ds = (short )*(fv1 + 20);
#line 1549
  if (ds) {
#line 1549
    ad = (short )Kdist[c1][sq];
#line 1549
    if ((int )ad <= 3) {
#line 1549
      ds = (short )(((int )ds * (int )OwnKingDistanceBonus[ad]) * 2);
#line 1549
      s = (short )((int )s + (int )ds);
    }
  }
#line 1551
  if ((int )Kdist[c1][sq] < 3) {
#line 1551
    if (*(atk1 + sq) & (long )(control[5] | control[4])) {
#line 1554
      ds = (short )*(fv1 + 29);
#line 1554
      s = (short )((int )s + (int )ds);
    }
  }
#line 1557
  if (! flag.tsume) {
#line 1557
    if ((int )stage < 33) {
#line 1563
      if ((int )GameType[c1] == 83) {
#line 1563
        if ((int )GameType[c2] != 83) {
#line 1565
          if ((int )c1 == 0) {
#line 1565
            tmp = 3;
          } else {
#line 1565
            tmp = 77;
          }
#line 1565
          if (Mvboard[tmp]) {
#line 1567
            ds = (short )(-2 * (int )*(fv1 + 12));
#line 1567
            s = (short )((int )s + (int )ds);
          }
        }
      }
    } else {
#line 1557
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1574
    ds = (short )*(fv1 + 20);
#line 1574
    if (ds) {
#line 1574
      ad = (short )Kdist[c2][sq];
#line 1574
      if ((int )ad <= 3) {
#line 1574
        ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 2);
#line 1574
        s = (short )((int )s + (int )ds);
      }
    }
  }
#line 1577
  return ((int )s);
}
}
#line 1586 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int BishopValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1589
  s = (short)0;
#line 1591
  if (! flag.tsume) {
#line 1591
    if ((int )stage < 33) {
#line 1597
      if ((int )GameType[c1] == 82) {
        {
#line 1600
        tmp = on_csquare(c1, (short)1, (short)30);
        }
#line 1600
        if (! tmp) {
#line 1602
          ds = (short )(- ((int )*(fv1 + 12)));
#line 1602
          s = (short )((int )s + (int )ds);
        }
      } else
#line 1605
      if ((int )GameType[c2] == 82) {
#line 1608
        if ((int )c1 == 0) {
#line 1608
          tmp___2 = (int )sq;
        } else {
#line 1608
          tmp___2 = 80 - (int )sq;
        }
#line 1608
        if (tmp___2 == 10) {
#line 1608
          if ((int )c1 == 0) {
#line 1608
            tmp___3 = 20;
          } else {
#line 1608
            tmp___3 = 60;
          }
#line 1608
          if ((int )board[tmp___3] == 0) {
#line 1608
            if ((int )c1 == 0) {
#line 1608
              tmp___4 = 30;
            } else {
#line 1608
              tmp___4 = 50;
            }
#line 1608
            if ((int )board[tmp___4] == 0) {
#line 1608
              goto _L;
            } else {
#line 1611
              ds = (short )(- ((int )*(fv1 + 12)));
#line 1611
              s = (short )((int )s + (int )ds);
            }
          } else {
#line 1611
            ds = (short )(- ((int )*(fv1 + 12)));
#line 1611
            s = (short )((int )s + (int )ds);
          }
        } else {
          _L: /* CIL Label */ 
#line 1613
          if ((int )c1 == 0) {
#line 1613
            tmp___0 = (int )sq;
          } else {
#line 1613
            tmp___0 = 80 - (int )sq;
          }
#line 1613
          if (tmp___0 == 20) {
#line 1613
            if ((int )c1 == 0) {
#line 1613
              tmp___1 = 30;
            } else {
#line 1613
              tmp___1 = 50;
            }
#line 1613
            if (! ((int )board[tmp___1] == 0)) {
#line 1615
              ds = (short )(- ((int )*(fv1 + 12)));
#line 1615
              s = (short )((int )s + (int )ds);
            }
          }
        }
      }
    } else {
#line 1591
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1622
    ds = (short )*(fv1 + 20);
#line 1622
    if (ds) {
#line 1622
      ad = (short )Kdist[c2][sq];
#line 1622
      if ((int )ad <= 3) {
#line 1622
        ds = (short )((int )ds * (int )EnemyKingDistanceBonus[ad]);
#line 1622
        s = (short )((int )s + (int )ds);
      }
    }
  }
#line 1625
  return ((int )s);
}
}
#line 1634 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int RookValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;
  short WRONG ;
  short OPOK ;
  short c ;
  int tmp ;
  short c___0 ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;

  {
  {
#line 1637
  s = (short)0;
#line 1639
  OpenFileValue(sq, (short )(2 * (int )*(fv1 + 18)), (short )(4 * (int )*(fv1 + 18)));
  }
#line 1641
  if (! flag.tsume) {
#line 1641
    if ((int )stage < 33) {
#line 1647
      WRONG = (short )*(fv1 + 12);
#line 1647
      OPOK = (short )((int )WRONG / 3);
#line 1649
      if ((int )GameType[c1] == 83) {
#line 1651
        if ((int )c1 == 0) {
#line 1651
          tmp = (int )sq;
        } else {
#line 1651
          tmp = 80 - (int )sq;
        }
#line 1651
        c = (short )(tmp % 9);
#line 1654
        if ((int )c == 7) {
#line 1656
          ds = OPOK;
#line 1656
          s = (short )((int )s + (int )ds);
        }
#line 1664
        c = (short )(4 - (int )c);
#line 1665
        ds = (short)0;
#line 1667
        if ((int )c < 0) {
#line 1669
          ds = (short )(((int )c + (int )c) + (int )OPOK);
#line 1669
          s = (short )((int )s + (int )ds);
        } else
#line 1671
        if ((int )c >= 0) {
#line 1673
          ds = (short )((- ((int )c) - (int )c) - (int )WRONG);
#line 1673
          s = (short )((int )s + (int )ds);
        }
      } else
#line 1676
      if ((int )GameType[c1] == 82) {
#line 1682
        if ((int )c1 == 0) {
#line 1682
          tmp___0 = (int )sq;
        } else {
#line 1682
          tmp___0 = 80 - (int )sq;
        }
#line 1682
        c___0 = (short )(4 - tmp___0 % 9);
#line 1683
        ds = (short)0;
#line 1685
        if ((int )c___0 >= 0) {
          {
#line 1688
          tmp___1 = on_csquare(c1, (short)1, (short)30);
          }
#line 1688
          if (tmp___1) {
#line 1689
            ds = OPOK;
#line 1689
            s = (short )((int )s + (int )ds);
          } else {
#line 1691
            ds = (short )((- ((int )c___0) - (int )c___0) - (int )WRONG);
#line 1691
            s = (short )((int )s + (int )ds);
          }
        } else
#line 1693
        if ((int )c___0 < 0) {
          {
#line 1695
          ds = (short )((- ((int )c___0) - (int )c___0) - (int )WRONG);
#line 1695
          s = (short )((int )s + (int )ds);
#line 1698
          tmp___2 = on_csquare(side, (short)14, (short)4);
          }
#line 1698
          if (! tmp___2) {
#line 1700
            s = (short )((int )s + -4 * (int )WRONG);
#line 1701
            ds = (short )((int )ds + -4 * (int )WRONG);
          }
        }
      }
    } else {
#line 1641
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1709
    ds = (short )*(fv1 + 20);
#line 1709
    if (ds) {
#line 1709
      ad = (short )Kdist[c2][sq];
#line 1709
      if ((int )ad <= 3) {
#line 1709
        ds = (short )((int )ds * (int )EnemyKingDistanceBonus[ad]);
#line 1709
        s = (short )((int )s + (int )ds);
      }
    }
  }
#line 1712
  return ((int )s);
}
}
#line 1721 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PPawnValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;

  {
#line 1724
  s = (short)0;
#line 1726
  ds = (short )*(fv1 + 20);
#line 1726
  if (ds) {
#line 1726
    ad = (short )Kdist[c2][sq];
#line 1726
    if ((int )ad <= 10) {
#line 1726
      ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 3);
#line 1726
      s = (short )((int )s + (int )ds);
    }
  }
#line 1728
  return ((int )s);
}
}
#line 1738 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PLanceValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;

  {
#line 1741
  s = (short)0;
#line 1743
  ds = (short )*(fv1 + 20);
#line 1743
  if (ds) {
#line 1743
    ad = (short )Kdist[c2][sq];
#line 1743
    if ((int )ad <= 10) {
#line 1743
      ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 3);
#line 1743
      s = (short )((int )s + (int )ds);
    }
  }
#line 1745
  return ((int )s);
}
}
#line 1754 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PKnightValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;

  {
#line 1757
  s = (short)0;
#line 1759
  ds = (short )*(fv1 + 20);
#line 1759
  if (ds) {
#line 1759
    ad = (short )Kdist[c2][sq];
#line 1759
    if ((int )ad <= 10) {
#line 1759
      ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 3);
#line 1759
      s = (short )((int )s + (int )ds);
    }
  }
#line 1761
  return ((int )s);
}
}
#line 1771 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PSilverValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;

  {
#line 1774
  s = (short)0;
#line 1776
  ds = (short )*(fv1 + 20);
#line 1776
  if (ds) {
#line 1776
    ad = (short )Kdist[c2][sq];
#line 1776
    if ((int )ad <= 10) {
#line 1776
      ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 3);
#line 1776
      s = (short )((int )s + (int )ds);
    }
  }
#line 1778
  return ((int )s);
}
}
#line 1787 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PBishopValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;

  {
#line 1790
  s = (short)0;
#line 1792
  ds = (short )*(fv1 + 20);
#line 1792
  if (ds) {
#line 1792
    ad = (short )Kdist[c2][sq];
#line 1792
    if ((int )ad <= 4) {
#line 1792
      ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 3);
#line 1792
      s = (short )((int )s + (int )ds);
    }
  }
#line 1794
  return ((int )s);
}
}
#line 1803 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PRookValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short ad ;

  {
#line 1806
  s = (short)0;
#line 1808
  ds = (short )*(fv1 + 20);
#line 1808
  if (ds) {
#line 1808
    ad = (short )Kdist[c2][sq];
#line 1808
    if ((int )ad <= 4) {
#line 1808
      ds = (short )(((int )ds * (int )EnemyKingDistanceBonus[ad]) * 3);
#line 1808
      s = (short )((int )s + (int )ds);
    }
  }
  {
#line 1810
  OpenFileValue(sq, (short )(3 * (int )*(fv1 + 18)), (short )(2 * (int )*(fv1 + 18)));
  }
#line 1812
  return ((int )s);
}
}
#line 1821 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int KingValue(short sq , short side ) 
{ 
  short s ;
  short ds ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1824
  s = (short)0;
#line 1826
  if ((int )*(fv1 + 17) != 0) {
    {
#line 1827
    tmp = KingScan(sq);
#line 1827
    s = (short )((int )s + (int )tmp);
    }
  }
#line 1833
  if (! flag.tsume) {
#line 1833
    if ((int )stage < 33) {
#line 1835
      if ((int )GameType[c1] != 85) {
#line 1835
        if ((int )c1 == 0) {
#line 1835
          tmp___2 = (int )sq;
        } else {
#line 1835
          tmp___2 = 80 - (int )sq;
        }
#line 1835
        if (tmp___2 % 9 == 4) {
#line 1837
          ds = (short )(- ((int )*(fv1 + 12)) / 3);
#line 1837
          s = (short )((int )s + (int )ds);
        } else {
#line 1835
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1839
      if ((int )GameType[c1] == 83) {
        {
#line 1839
        tmp___1 = on_right_side(c1, sq);
        }
#line 1839
        if (tmp___1) {
#line 1841
          ds = (short )(- ((int )*(fv1 + 12)) / 2);
#line 1841
          s = (short )((int )s + (int )ds);
        } else {
#line 1839
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1843
      if ((int )GameType[c1] == 82) {
        {
#line 1843
        tmp___0 = on_left_side(c1, sq);
        }
#line 1843
        if (tmp___0) {
#line 1845
          ds = (short )(- ((int )*(fv1 + 12)) / 2);
#line 1845
          s = (short )((int )s + (int )ds);
        }
      }
    }
  }
#line 1851
  ds = (short )*(fv1 + 18);
#line 1851
  if (ds) {
    {
#line 1853
    tmp___3 = OpenFileValue(sq, (short )(-2 * (int )ds), (short )(-4 * (int )ds));
#line 1853
    s = (short )((int )s + tmp___3);
    }
  }
#line 1856
  return ((int )s);
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static int PieceValue(short sq , short side ) 
{ 
  short s ;
  short piece ;
  short ds ;
  short mob ;
  int tmp ;
  int tmp___0 ;
  short attack_value ;
  short tmp___1 ;
  short piece_value ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1871
  piece = (short )board[sq];
#line 1873
  if ((int )piece == 0) {
#line 1874
    return (0);
  }
#line 1876
  s = (short )(*(Mpiece[piece]))[c1][sq];
#line 1878
  checked_trapped = (short)0;
#line 1880
  if (sweep[piece]) {
    {
#line 1883
    tmp = BRLscan(sq, & mob);
#line 1883
    ds = (short )tmp;
#line 1883
    s = (short )((int )s + (int )ds);
    }
#line 1885
    if ((int )piece == 6) {
#line 1886
      ds = (short )(((int const   )BMBLTY[mob] * (int const   )*(fv1 + 15)) / 100);
#line 1886
      s = (short )((int )s + (int )ds);
    } else
#line 1885
    if ((int )piece == 12) {
#line 1886
      ds = (short )(((int const   )BMBLTY[mob] * (int const   )*(fv1 + 15)) / 100);
#line 1886
      s = (short )((int )s + (int )ds);
    } else
#line 1887
    if ((int )piece == 7) {
#line 1888
      ds = (short )(((int const   )RMBLTY[mob] * (int const   )*(fv1 + 15)) / 100);
#line 1888
      s = (short )((int )s + (int )ds);
    } else
#line 1887
    if ((int )piece == 13) {
#line 1888
      ds = (short )(((int const   )RMBLTY[mob] * (int const   )*(fv1 + 15)) / 100);
#line 1888
      s = (short )((int )s + (int )ds);
    } else {
#line 1891
      ds = (short )(((int const   )LMBLTY[mob] * (int const   )*(fv1 + 15)) / 100);
#line 1891
      s = (short )((int )s + (int )ds);
    }
  }
#line 1899
  a2 = *(atk2 + sq);
#line 1900
  a1 = *(atk1 + sq);
#line 1902
  if (a2 > 0L) {
#line 1905
    if (a1 == 0L) {
      {
#line 1908
      tmp___0 = AttackedPieceValue(sq, side);
#line 1908
      s = (short )((int )s + tmp___0);
      }
    } else {
      {
#line 1913
      tmp___1 = value_of_weakest_attacker(a2);
#line 1913
      attack_value = tmp___1;
#line 1914
      piece_value = (*value)[stage][piece];
      }
#line 1916
      if ((int )attack_value < (int )piece_value) {
        {
#line 1919
        tmp___2 = AttackedPieceValue(sq, side);
#line 1919
        s = (short )((int )s + tmp___2 / 2);
        }
      } else {
        {
#line 1921
        tmp___3 = abs((int )attack_value - (int )piece_value);
        }
#line 1921
        if (tmp___3 < 10) {
#line 1924
          ds = (short )(- ((int )*(fv1 + 0)));
#line 1924
          s = (short )((int )s + (int )ds);
        }
      }
    }
  }
#line 1929
  if ((int )piece != 14) {
#line 1932
    if (a1 > 0L) {
#line 1935
      ds = (short )((a1 & 255L) * (long )*(fv1 + 8));
#line 1935
      s = (short )((int )s + (int )ds);
    }
#line 1938
    if (sseed[sq]) {
#line 1940
      ds = (short )*(fv1 + 13);
#line 1940
      s = (short )((int )s + (int )ds);
    }
#line 1943
    if (sloose[sq]) {
#line 1945
      ds = (short )(- ((int )*(fv1 + 14)));
#line 1945
      s = (short )((int )s + (int )ds);
    }
#line 1948
    if (starget[c1][sq]) {
#line 1950
      if (sweep[piece]) {
#line 1952
        ds = (short )(- ((int )*(fv1 + 0)) / 2);
#line 1952
        s = (short )((int )s - (int )ds);
      } else
#line 1954
      if ((int )piece == 1) {
#line 1956
        ds = (short )*(fv1 + 0);
#line 1956
        s = (short )((int )s + (int )ds);
      }
    }
#line 1960
    if (starget[c2][sq]) {
#line 1962
      if ((int )piece != 1) {
#line 1964
        ds = (short )(- ((int )*(fv1 + 0)) / 3);
#line 1964
        s = (short )((int )s - (int )ds);
      } else {
#line 1968
        ds = (short )*(fv1 + 0);
#line 1968
        s = (short )((int )s + (int )ds);
      }
    }
#line 1972
    if ((int )Kdist[c1][sq] == 1) {
#line 1974
      ds = (short )*(fv1 + 17);
#line 1974
      s = (short )((int )s + (int )ds);
    }
  }
  {
#line 1980
  if ((int )piece == 1) {
#line 1980
    goto case_1;
  }
#line 1985
  if ((int )piece == 2) {
#line 1985
    goto case_2;
  }
#line 1989
  if ((int )piece == 3) {
#line 1989
    goto case_3;
  }
#line 1994
  if ((int )piece == 4) {
#line 1994
    goto case_4;
  }
#line 1998
  if ((int )piece == 5) {
#line 1998
    goto case_5;
  }
#line 2002
  if ((int )piece == 6) {
#line 2002
    goto case_6;
  }
#line 2006
  if ((int )piece == 7) {
#line 2006
    goto case_7;
  }
#line 2010
  if ((int )piece == 14) {
#line 2010
    goto case_14;
  }
#line 2014
  if ((int )piece == 8) {
#line 2014
    goto case_8;
  }
#line 2019
  if ((int )piece == 9) {
#line 2019
    goto case_9;
  }
#line 2023
  if ((int )piece == 10) {
#line 2023
    goto case_10;
  }
#line 2028
  if ((int )piece == 11) {
#line 2028
    goto case_11;
  }
#line 2032
  if ((int )piece == 12) {
#line 2032
    goto case_12;
  }
#line 2036
  if ((int )piece == 13) {
#line 2036
    goto case_13;
  }
#line 1978
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1981
  tmp___4 = PawnValue(sq, side);
#line 1981
  s = (short )((int )s + tmp___4);
  }
#line 1982
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1986
  tmp___5 = LanceValue(sq, side);
#line 1986
  s = (short )((int )s + tmp___5);
  }
#line 1987
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1990
  tmp___6 = KnightValue(sq, side);
#line 1990
  s = (short )((int )s + tmp___6);
  }
#line 1991
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1995
  tmp___7 = SilverValue(sq, side);
#line 1995
  s = (short )((int )s + tmp___7);
  }
#line 1996
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1999
  tmp___8 = GoldValue(sq, side);
#line 1999
  s = (short )((int )s + tmp___8);
  }
#line 2000
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2003
  tmp___9 = BishopValue(sq, side);
#line 2003
  s = (short )((int )s + tmp___9);
  }
#line 2004
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2007
  tmp___10 = RookValue(sq, side);
#line 2007
  s = (short )((int )s + tmp___10);
  }
#line 2008
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 2011
  tmp___11 = KingValue(sq, side);
#line 2011
  s = (short )((int )s + tmp___11);
  }
#line 2012
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2015
  tmp___12 = PPawnValue(sq, side);
#line 2015
  s = (short )((int )s + tmp___12);
  }
#line 2016
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 2020
  tmp___13 = PLanceValue(sq, side);
#line 2020
  s = (short )((int )s + tmp___13);
  }
#line 2021
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 2024
  tmp___14 = PKnightValue(sq, side);
#line 2024
  s = (short )((int )s + tmp___14);
  }
#line 2025
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2029
  tmp___15 = PSilverValue(sq, side);
#line 2029
  s = (short )((int )s + tmp___15);
  }
#line 2030
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 2033
  tmp___16 = PBishopValue(sq, side);
#line 2033
  s = (short )((int )s + tmp___16);
  }
#line 2034
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 2037
  tmp___17 = PRookValue(sq, side);
#line 2037
  s = (short )((int )s + tmp___17);
  }
#line 2038
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2041
  return ((int )s);
}
}
#line 2050 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short ScorePatternDistance(short c1___0 ) 
{ 
  short ds ;
  short s ;
  signed char *fv1___0 ;
  short os ;

  {
#line 2053
  s = (short)0;
#line 2054
  fv1___0 = fvalue[c1___0];
#line 2055
  os = (short)0;
#line 2057
  if ((int )MAXCDIST > 0) {
#line 2057
    if ((int )*(fv1___0 + 5) != 0) {
#line 2057
      os = castle_opening_sequence[c1___0];
#line 2057
      if ((int )os >= 0) {
        {
#line 2060
        ds = board_to_pattern_distance(c1___0, os, MAXCDIST, GameCnt);
        }
#line 2062
        if ((int )ds != 0) {
#line 2064
          ds = (short )((int )ds * (int )*(fv1___0 + 5));
#line 2064
          s = (short )((int )s + (int )ds);
        }
      }
    }
  }
#line 2068
  if ((int )MAXADIST > 0) {
#line 2068
    if ((int )*(fv1___0 + 6) != 0) {
#line 2068
      os = attack_opening_sequence[c1___0];
#line 2068
      if ((int )os >= 0) {
        {
#line 2071
        ds = board_to_pattern_distance(c1___0, os, MAXADIST, GameCnt);
        }
#line 2073
        if ((int )ds != 0) {
#line 2075
          ds = (short )((int )ds * (int )*(fv1___0 + 6));
#line 2075
          s = (short )((int )s + (int )ds);
        }
      }
    }
  }
#line 2079
  return (s);
}
}
#line 2090 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void UpdatePatterns(short side , short GameCnt___0 ) 
{ 
  char s[12] ;
  short xside___0 ;
  short os ;
  short j ;
  short k ;
  short n ;

  {
  {
#line 2094
  xside___0 = (short )((int )side ^ 1);
#line 2096
  n = (short)0;
#line 2098
  strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"CASTLE_?_?");
#line 2099
  s[7] = GameType[side];
#line 2100
  s[9] = GameType[xside___0];
#line 2101
  os = locate_opening_sequence(side, s, GameCnt___0);
#line 2101
  castle_opening_sequence[side] = os;
  }
#line 2104
  if (flag.post) {
#line 2104
    if ((int )os != -1) {
#line 2106
      j = (short)0;
      {
#line 2106
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2106
        if (! ((int )j < 4)) {
#line 2106
          goto while_break;
        }
#line 2108
        k = OpeningSequence[os].first_pattern[j];
        {
#line 2108
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2108
          if (! ((int )k != -2)) {
#line 2108
            goto while_break___0;
          }
#line 2112
          if ((int )Pattern[k].distance[side] >= 0) {
#line 2113
            n = (short )((int )n + 1);
          }
#line 2108
          k = Pattern[k].next_pattern;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2106
        j = (short )((int )j + 1);
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2118
  if ((int )os != -1) {
    {
#line 2119
    update_advance_bonus(side, os);
    }
  }
  {
#line 2121
  strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"ATTACK_?_?");
#line 2122
  s[7] = GameType[side];
#line 2123
  s[9] = GameType[xside___0];
#line 2124
  os = locate_opening_sequence(side, s, GameCnt___0);
#line 2124
  attack_opening_sequence[side] = os;
  }
#line 2127
  if (flag.post) {
#line 2127
    if ((int )os != -1) {
#line 2129
      j = (short)0;
      {
#line 2129
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2129
        if (! ((int )j < 4)) {
#line 2129
          goto while_break___1;
        }
#line 2131
        k = OpeningSequence[os].first_pattern[j];
        {
#line 2131
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2131
          if (! ((int )k != -2)) {
#line 2131
            goto while_break___2;
          }
#line 2135
          if ((int )Pattern[k].distance[side] >= 0) {
#line 2136
            n = (short )((int )n + 1);
          }
#line 2131
          k = Pattern[k].next_pattern;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2129
        j = (short )((int )j + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 2141
  if (flag.post) {
    {
#line 2142
    ShowPatternCount(side, n);
    }
  }
#line 2144
  if ((int )os != -1) {
    {
#line 2145
    update_advance_bonus(side, os);
    }
  }
#line 2146
  return;
}
}
#line 2150 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void ScoreCaptures(void) 
{ 
  short ds ;
  short col ;
  short n ;
  short m ;
  short piece ;
  int tmp ;

  {
#line 2155
  n = (short )Captured[c1][1];
#line 2155
  if (n) {
#line 2157
    m = (short)0;
#line 2157
    ds = m;
#line 2159
    col = (short)0;
    {
#line 2159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2159
      if (! ((int )col < 9)) {
#line 2159
        goto while_break;
      }
#line 2161
      if (! *(PC1 + col)) {
#line 2163
        m = (short )((int )m + 1);
#line 2164
        ds = (short )((int )ds + (int )*(fv1 + 21));
      }
#line 2159
      col = (short )((int )col + 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 2169
    if ((int )n > 2) {
#line 2169
      tmp = 3;
    } else {
#line 2169
      tmp = (int )n;
    }
#line 2169
    ds = (short )((int )ds * tmp);
#line 2169
    pscore[c1] = (short )((int )pscore[c1] + (int )ds);
  }
#line 2172
  m = seed[c1];
#line 2172
  if (m) {
#line 2174
    piece = (short)2;
#line 2174
    n = (short)0;
    {
#line 2174
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2174
      if (! ((int )piece <= 7)) {
#line 2174
        goto while_break___0;
      }
#line 2176
      if (Captured[c1][piece]) {
#line 2177
        n = (short )((int )n + 1);
      }
#line 2174
      piece = (short )((int )piece + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2180
    ds = (short )((int )m * (int )*(fv1 + 22));
#line 2180
    pscore[c1] = (short )((int )pscore[c1] + (int )ds);
  }
#line 2183
  piece = (short)1;
#line 2183
  n = (short)0;
  {
#line 2183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2183
    if (! ((int )piece <= 7)) {
#line 2183
      goto while_break___1;
    }
#line 2185
    if (Captured[c1][piece]) {
      {
#line 2189
      if ((int )piece == 6) {
#line 2189
        goto case_6;
      }
#line 2193
      if ((int )piece == 7) {
#line 2193
        goto case_7;
      }
#line 2198
      if ((int )piece == 2) {
#line 2198
        goto case_2;
      }
#line 2203
      goto switch_default;
      case_6: /* CIL Label */ 
#line 2190
      ds = (short )BMBLTY[19];
#line 2191
      goto switch_break;
      case_7: /* CIL Label */ 
#line 2194
      ds = (short )RMBLTY[19];
#line 2195
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2199
      ds = (short )LMBLTY[7];
#line 2200
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2204
      ds = (short )MBLTY[piece];
      switch_break: /* CIL Label */ ;
      }
#line 2207
      pscore[c1] = (short )((int )pscore[c1] + (int )ds);
#line 2209
      if (! Captured[c2][piece]) {
#line 2210
        n = (short )((int )n + (int )relative_value[piece]);
      }
    }
#line 2183
    piece = (short )((int )piece + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2214
  if (n) {
#line 2216
    ds = (short )((- ((int )n) * (int )*(fv1 + 30)) / 2);
#line 2216
    pscore[c1] = (short )((int )pscore[c1] + (int )ds);
  }
#line 2218
  return;
}
}
#line 2229 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
short ScorePosition(short side ) 
{ 
  short score___0 ;
  short sq ;
  short i___0 ;
  short xside___0 ;
  short s ;
  short ds ;
  short tmp ;
  int tmp___0 ;
  short n ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2237
  xside___0 = (short )((int )side ^ 1);
#line 2239
  UpdateWeights(side);
#line 2241
  pscore[1] = (short)0;
#line 2241
  pscore[0] = pscore[1];
#line 2241
  hung[1] = pscore[0];
#line 2241
  hung[0] = hung[1];
#line 2243
  memset((void *)(shung), 0, sizeof(shung));
  }
#line 2246
  if (use_etable) {
    {
#line 2246
    tmp___2 = ProbeEETable(side, & s);
    }
#line 2246
    if (! tmp___2) {
#line 2246
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2249
    c1 = (short)0;
    {
#line 2249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2249
      if (! ((int )c1 <= 1)) {
#line 2249
        goto while_break;
      }
#line 2251
      c2 = (short )((int )c1 ^ 1);
#line 2254
      atk1 = attack[c1];
#line 2257
      atk2 = attack[c2];
#line 2260
      PC1 = PawnCnt[c1];
#line 2261
      PC2 = PawnCnt[c2];
#line 2264
      fv1 = fvalue[c1];
#line 2266
      i___0 = (short )PieceCnt[c1];
      {
#line 2266
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2266
        if (! ((int )i___0 >= 0)) {
#line 2266
          goto while_break___0;
        }
        {
#line 2268
        sq = (short )PieceList[c1][i___0];
#line 2273
        tmp___0 = PieceValue(sq, side);
#line 2273
        tmp = (short )tmp___0;
#line 2273
        svalue[sq] = tmp;
#line 2273
        pscore[c1] = (short )((int )pscore[c1] + (int )tmp);
#line 2266
        i___0 = (short )((int )i___0 - 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2277
      ScoreCaptures();
#line 2249
      c1 = (short )((int )c1 + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2295
    c1 = (short)0;
#line 2295
    c2 = (short)1;
    {
#line 2295
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2295
      if (! ((int )c1 <= 1)) {
#line 2295
        goto while_break___1;
      }
#line 2299
      fv1 = fvalue[c1];
#line 2302
      sq = (short)36;
#line 2302
      n = (short)0;
      {
#line 2302
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2302
        if (! ((int )sq <= 44)) {
#line 2302
          goto while_break___2;
        }
#line 2304
        if ((int )color[sq] == (int )c1) {
#line 2305
          n = (short )((int )n + 1);
        } else
#line 2304
        if (attack[c1][sq] != 0L) {
#line 2305
          n = (short )((int )n + 1);
        }
#line 2302
        sq = (short )((int )sq + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2308
      if ((int )n != 0) {
#line 2310
        ds = (short )((int )n * (int )*(fv1 + 3));
#line 2310
        pscore[c1] = (short )((int )pscore[c1] + (int )ds);
      }
#line 2314
      if ((int )c1 == 0) {
#line 2314
        sq = (short)0;
      } else {
#line 2314
        sq = (short)54;
      }
#line 2314
      n = (short)0;
      {
#line 2314
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2314
        if ((int )c1 == 0) {
#line 2314
          tmp___1 = 26;
        } else {
#line 2314
          tmp___1 = 80;
        }
#line 2314
        if (! ((int )sq <= tmp___1)) {
#line 2314
          goto while_break___3;
        }
#line 2318
        if ((int )board[sq] == 0) {
#line 2318
          if (attack[c1][sq] == 0L) {
#line 2319
            n = (short )((int )n + 1);
          }
        }
#line 2314
        sq = (short )((int )sq + 1);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2322
      if ((int )n != 0) {
#line 2324
        ds = (short )(- ((int )n) * (int )*(fv1 + 4));
#line 2324
        pscore[c1] = (short )((int )pscore[c1] + (int )ds);
      }
#line 2327
      if ((int )hung[c1] > 1) {
#line 2329
        ds = (short )(- ((int )*(fv1 + 2)));
#line 2329
        pscore[c1] = (short )((int )pscore[c1] + (int )ds);
      }
#line 2335
      if (! flag.tsume) {
#line 2335
        if ((int )stage < 33) {
          {
#line 2337
          ds = ScoreKingOpeningFeatures();
#line 2337
          pscore[c1] = (short )((int )pscore[c1] + (int )ds);
#line 2338
          ds = ScorePatternDistance(c1);
#line 2338
          pscore[c1] = (short )((int )pscore[c1] + (int )ds);
          }
        }
      }
#line 2295
      c1 = (short )((int )c1 + 1);
#line 2295
      c2 = (short )((int )c2 - 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2342
    score___0 = (short )(((((int )mtl[side] - (int )mtl[xside___0]) + (int )pscore[side]) - (int )pscore[xside___0]) + 10);
#line 2346
    if (use_etable) {
#line 2346
      if (PUTVAR) {
        {
#line 2347
        PutInEETable(side, (int )score___0);
        }
      }
    }
#line 2350
    return (score___0);
  }
#line 2354
  return (s);
}
}
#line 2365 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void GuessGameType(short side_to_move ) 
{ 
  short side ;
  short gt ;
  short StaticRook[2] ;
  short RangingRook[2] ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  short tmp___5 ;
  short tmp___6 ;
  short tmp___7 ;
  short tmp___8 ;
  short tmp___9 ;
  short tmp___10 ;
  short tmp___11 ;
  short tmp___12 ;
  short tmp___13 ;
  short tmp___14 ;
  short tmp___15 ;
  unsigned int random ;
  unsigned int tmp___16 ;
  short d ;
  short tmp___17 ;

  {
#line 2369
  StaticRook[0] = (short)0;
#line 2369
  StaticRook[1] = (short)0;
#line 2370
  RangingRook[0] = (short)0;
#line 2370
  RangingRook[1] = (short)0;
#line 2372
  side = (short)0;
  {
#line 2372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2372
    if (! ((int )side <= 1)) {
#line 2372
      goto while_break;
    }
#line 2378
    gt = (short )GameType[side];
#line 2380
    if (! bookflag) {
#line 2380
      if ((int )side == (int )side_to_move) {
#line 2382
        if ((int )gt == 83) {
#line 2383
          StaticRook[side] = (short )((int )StaticRook[side] + 4);
        } else
#line 2384
        if ((int )gt == 82) {
#line 2385
          RangingRook[side] = (short )((int )RangingRook[side] + 4);
        }
      }
    }
    {
#line 2390
    tmp = on_column(side, (short)7, (short)7);
    }
#line 2390
    if (tmp) {
#line 2391
      StaticRook[side] = (short )((int )StaticRook[side] + 3);
    }
    {
#line 2393
    tmp___2 = on_csquare(side, (short)1, (short)34);
    }
#line 2393
    if (tmp___2) {
#line 2394
      StaticRook[side] = (short )((int )StaticRook[side] + 6);
    } else {
      {
#line 2395
      tmp___1 = on_csquare(side, (short)1, (short)43);
      }
#line 2395
      if (tmp___1) {
#line 2396
        StaticRook[side] = (short )((int )StaticRook[side] + 4);
      } else {
        {
#line 2397
        tmp___0 = on_column(side, (short)1, (short)7);
        }
#line 2397
        if (! tmp___0) {
#line 2398
          StaticRook[side] = (short )((int )StaticRook[side] + 5);
        }
      }
    }
#line 2400
    if ((int )side == 0) {
#line 2400
      tmp___3 = 5;
    } else {
#line 2400
      tmp___3 = 75;
    }
#line 2400
    if ((int )board[tmp___3] == 0) {
#line 2401
      StaticRook[side] = (short )((int )StaticRook[side] + 2);
    } else {
#line 2400
      if ((int )side == 0) {
#line 2400
        tmp___4 = 6;
      } else {
#line 2400
        tmp___4 = 74;
      }
#line 2400
      if ((int )board[tmp___4] == 0) {
#line 2401
        StaticRook[side] = (short )((int )StaticRook[side] + 2);
      }
    }
    {
#line 2403
    tmp___5 = on_left_side(side, (short)14);
    }
#line 2403
    if (tmp___5) {
#line 2404
      StaticRook[side] = (short )((int )StaticRook[side] + 2);
    }
    {
#line 2408
    tmp___7 = on_left_side(side, (short)7);
    }
#line 2408
    if (tmp___7) {
#line 2409
      RangingRook[side] = (short )((int )RangingRook[side] + 5);
    } else {
      {
#line 2410
      tmp___6 = on_column(side, (short)7, (short)7);
      }
#line 2410
      if (! tmp___6) {
#line 2411
        RangingRook[side] = (short )((int )RangingRook[side] + 3);
      }
    }
    {
#line 2413
    tmp___8 = on_csquare(side, (short)1, (short)25);
    }
#line 2413
    if (tmp___8) {
#line 2414
      RangingRook[side] = (short )((int )RangingRook[side] + 1);
    }
    {
#line 2416
    tmp___9 = on_csquare(side, (short)1, (short)30);
    }
#line 2416
    if (tmp___9) {
#line 2417
      RangingRook[side] = (short )((int )RangingRook[side] + 1);
    } else {
#line 2419
      RangingRook[side] = (short )((int )RangingRook[side] - 2);
    }
    {
#line 2421
    tmp___10 = on_right_side(side, (short)7);
    }
#line 2421
    if (! tmp___10) {
#line 2422
      RangingRook[side] = (short )((int )RangingRook[side] + 4);
    }
    {
#line 2424
    tmp___11 = on_right_side(side, (short)14);
    }
#line 2424
    if (tmp___11) {
#line 2425
      RangingRook[side] = (short )((int )RangingRook[side] + 4);
    }
    {
#line 2427
    tmp___15 = on_csquare(side, (short)6, (short)20);
    }
#line 2427
    if (tmp___15) {
      {
#line 2429
      tmp___12 = on_csquare(side, (short)4, (short)11);
      }
#line 2429
      if (tmp___12) {
#line 2433
        RangingRook[side] = (short )((int )RangingRook[side] + 3);
      } else {
        {
#line 2429
        tmp___13 = on_csquare(side, (short)4, (short)12);
        }
#line 2429
        if (tmp___13) {
#line 2433
          RangingRook[side] = (short )((int )RangingRook[side] + 3);
        } else {
          {
#line 2429
          tmp___14 = on_csquare(side, (short)4, (short)21);
          }
#line 2429
          if (tmp___14) {
#line 2433
            RangingRook[side] = (short )((int )RangingRook[side] + 3);
          }
        }
      }
    }
#line 2437
    if ((int )StaticRook[side] > 5) {
#line 2437
      goto _L;
    } else
#line 2437
    if ((int )RangingRook[side] > 5) {
      _L: /* CIL Label */ 
#line 2439
      if ((int )StaticRook[side] > (int )RangingRook[side]) {
#line 2439
        GameType[side] = (char )'S';
      } else {
#line 2439
        GameType[side] = (char )'R';
      }
    } else {
#line 2444
      GameType[side] = (char )'U';
    }
#line 2372
    side = (short )((int )side + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2448
  if ((int )GameType[0] == 85) {
#line 2448
    goto _L___0;
  } else
#line 2448
  if ((int )GameType[1] == 85) {
    _L___0: /* CIL Label */ 
#line 2450
    side = (short)0;
    {
#line 2450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2450
      if (! ((int )side <= 1)) {
#line 2450
        goto while_break___0;
      }
#line 2452
      if ((int )side == (int )computer) {
#line 2452
        if ((int )GameType[side] == 85) {
          {
#line 2461
          tmp___17 = on_csquare(side, (short)1, (short)25);
          }
#line 2461
          if (tmp___17) {
            {
#line 2468
            tmp___16 = urand();
#line 2468
            random = tmp___16 % 100U;
#line 2469
            d = (short )((int )StaticRook[side] - (int )RangingRook[side]);
            }
            {
#line 2473
            if ((int )GameType[(int )side ^ 1] == 83) {
#line 2473
              goto case_83;
            }
#line 2480
            if ((int )GameType[(int )side ^ 1] == 82) {
#line 2480
              goto case_82;
            }
#line 2487
            goto switch_default;
            case_83: /* CIL Label */ 
#line 2474
            if (random < (unsigned int )(35 + (int )d)) {
#line 2475
              GameType[side] = (char )'S';
            } else
#line 2476
            if (random < 95U) {
#line 2477
              GameType[side] = (char )'R';
            }
#line 2478
            goto switch_break;
            case_82: /* CIL Label */ 
#line 2481
            if (random < (unsigned int )(75 + (int )d)) {
#line 2482
              GameType[side] = (char )'S';
            } else
#line 2483
            if (random < 95U) {
#line 2484
              GameType[side] = (char )'R';
            }
#line 2485
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 2488
            if (random < (unsigned int )(33 + (int )d)) {
#line 2489
              GameType[side] = (char )'S';
            } else
#line 2490
            if (random < 66U) {
#line 2491
              GameType[side] = (char )'R';
            }
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 2464
            GameType[side] = (char )'S';
          }
        }
      }
#line 2450
      side = (short )((int )side + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2497
  return;
}
}
#line 2503 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static void DetermineGameType(short side_to_move ) 
{ 
  short side ;

  {
  {
#line 2510
  GuessGameType(side_to_move);
#line 2516
  memset((void *)(Mpawn), 0, sizeof(Mpawn));
#line 2518
  memset((void *)(Mlance), 0, sizeof(Mlance));
#line 2519
  memset((void *)(Mknight), 0, sizeof(Mknight));
#line 2521
  memset((void *)(Msilver), 0, sizeof(Msilver));
#line 2522
  memset((void *)(Mgold), 0, sizeof(Mgold));
#line 2523
  memset((void *)(Mbishop), 0, sizeof(Mbishop));
#line 2524
  memset((void *)(Mrook), 0, sizeof(Mrook));
#line 2525
  memset((void *)(Mking), 0, sizeof(Mking));
  }
#line 2527
  if (! flag.tsume) {
#line 2527
    if ((int )stage < 33) {
#line 2529
      side = (short)0;
      {
#line 2529
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2529
        if (! ((int )side <= 1)) {
#line 2529
          goto while_break;
        }
        {
#line 2530
        UpdatePatterns(side, GameCnt);
#line 2529
        side = (short )((int )side + 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 2534
      ShowPatternCount((short)0, (short)-1);
#line 2535
      ShowPatternCount((short)1, (short)-1);
      }
    }
  } else {
    {
#line 2534
    ShowPatternCount((short)0, (short)-1);
#line 2535
    ShowPatternCount((short)1, (short)-1);
    }
  }
#line 2537
  return;
}
}
#line 2547 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
void ExaminePosition(short side ) 
{ 
  short c1___0 ;
  short piece ;
  short sq ;
  short i___0 ;
  short bsq ;
  short wsq ;
  short tmp ;
  short tmp___0 ;

  {
#line 2554
  sq = (short)0;
#line 2554
  bsq = (short )PieceList[0][0];
#line 2554
  wsq = (short )PieceList[1][0];
  {
#line 2554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2554
    if (! ((int )sq < 81)) {
#line 2554
      goto while_break;
    }
    {
#line 2556
    tmp = distance(sq, bsq);
#line 2556
    Kdist[0][sq] = (signed char )tmp;
#line 2557
    tmp___0 = distance(sq, wsq);
#line 2557
    Kdist[1][sq] = (signed char )tmp___0;
#line 2554
    sq = (short )((int )sq + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2560
  threats((short)0);
#line 2561
  threats((short)1);
#line 2563
  ExamineSquares();
#line 2565
  DetermineGameType(side);
#line 2566
  DetermineStage(side);
#line 2568
  UpdateWeights(side);
#line 2570
  memset((void *)(HasPiece), 0, sizeof(HasPiece));
#line 2572
  c1___0 = (short)0;
  }
  {
#line 2572
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2572
    if (! ((int )c1___0 <= 1)) {
#line 2572
      goto while_break___0;
    }
#line 2574
    i___0 = (short )PieceCnt[c1___0];
    {
#line 2574
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2574
      if (! ((int )i___0 >= 0)) {
#line 2574
        goto while_break___1;
      }
#line 2576
      sq = (short )PieceList[c1___0][i___0];
#line 2576
      piece = (short )board[sq];
#line 2576
      HasPiece[c1___0][piece] = (signed char )((int )HasPiece[c1___0][piece] + 1);
#line 2574
      i___0 = (short )((int )i___0 - 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2572
    c1___0 = (short )((int )c1___0 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2579
  return;
}
}
#line 2584 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
void DetermineStage(short side ) 
{ 
  short xside___0 ;
  short ds ;
  short db1 ;
  short c1___0 ;
  short c2___0 ;
  short feature ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2587
  xside___0 = (short )((int )side ^ 1);
#line 2591
  tmp = (short)50;
#line 2591
  balance[xside___0] = tmp;
#line 2591
  balance[side] = tmp;
#line 2593
  if ((int )GameType[side] == 83) {
#line 2593
    if ((int )GameType[xside___0] == 83) {
#line 2596
      if ((int )GameCnt < 40) {
#line 2597
        stage = (short)0;
      } else
#line 2598
      if ((int )GameCnt < 60) {
#line 2599
        stage = (short)15;
      } else
#line 2600
      if ((int )GameCnt < 80) {
#line 2601
        stage = (short)25;
      } else {
#line 2603
        stage = (short)30;
      }
    } else {
#line 2593
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2605
  if ((int )GameType[side] == 82) {
#line 2605
    goto _L;
  } else
#line 2605
  if ((int )GameType[xside___0] == 82) {
    _L: /* CIL Label */ 
#line 2608
    if ((int )GameCnt < 30) {
#line 2609
      stage = (short)0;
    } else
#line 2610
    if ((int )GameCnt < 50) {
#line 2611
      stage = (short)15;
    } else
#line 2612
    if ((int )GameCnt < 70) {
#line 2613
      stage = (short)25;
    } else {
#line 2615
      stage = (short)30;
    }
  } else
#line 2619
  if ((int )GameCnt < 35) {
#line 2620
    stage = (short)0;
  } else
#line 2621
  if ((int )GameCnt < 55) {
#line 2622
    stage = (short)15;
  } else
#line 2623
  if ((int )GameCnt < 75) {
#line 2624
    stage = (short)25;
  } else {
#line 2626
    stage = (short)30;
  }
  {
#line 2632
  ds = (short )((int )mtl[side] - (int )mtl[xside___0]);
#line 2632
  tmp___1 = abs((int )ds);
#line 2632
  db1 = (*value)[stage][2];
  }
#line 2632
  if (tmp___1 > (int )db1) {
    {
#line 2635
    tmp___0 = abs((4 * (int )ds) / (int )db1);
#line 2635
    db1 = (short )tmp___0;
    }
#line 2637
    if ((int )ds < 0) {
#line 2638
      balance[side] = (short )((int )balance[side] + (int )db1);
    } else
#line 2639
    if ((int )ds > 0) {
#line 2640
      balance[xside___0] = (short )((int )balance[xside___0] + (int )db1);
    }
#line 2642
    ds = db1;
#line 2642
    stage = (short )((int )stage + (int )ds);
  }
#line 2646
  c1___0 = (short)0;
#line 2646
  c2___0 = (short)1;
  {
#line 2646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2646
    if (! ((int )c1___0 <= 1)) {
#line 2646
      goto while_break;
    }
#line 2648
    ds = seed[c1___0];
#line 2648
    if ((int )ds > 2) {
#line 2650
      db1 = (short )((int )ds * 2);
#line 2650
      balance[c1___0] = (short )((int )balance[c1___0] + (int )db1);
#line 2651
      balance[c2___0] = (short )((int )balance[c2___0] - (int )db1);
#line 2653
      if ((int )stage < 30) {
#line 2654
        stage = (short)30;
      }
#line 2656
      stage = (short )((int )stage + (int )ds);
    }
#line 2659
    db1 = hung[c1___0];
#line 2659
    if ((int )db1 > 2) {
#line 2661
      db1 = (short )((int )db1 * 2);
#line 2661
      balance[c1___0] = (short )((int )balance[c1___0] - (int )db1);
#line 2662
      balance[c2___0] = (short )((int )balance[c2___0] + (int )db1);
    }
#line 2665
    db1 = loose[c1___0];
#line 2665
    if ((int )db1 > 4) {
#line 2667
      db1 = (short )((int )db1 / 2);
#line 2667
      balance[c1___0] = (short )((int )balance[c1___0] - (int )db1);
#line 2668
      balance[c2___0] = (short )((int )balance[c2___0] + (int )db1);
#line 2669
      ds = (short)1;
#line 2669
      stage = (short )((int )stage + (int )ds);
    }
#line 2672
    ds = hole[c1___0];
#line 2672
    if (ds) {
#line 2674
      db1 = ds;
#line 2674
      balance[c1___0] = (short )((int )balance[c1___0] - (int )db1);
#line 2675
      balance[c2___0] = (short )((int )balance[c2___0] + (int )db1);
#line 2676
      ds = (short )((int )ds / 2);
#line 2676
      stage = (short )((int )stage + (int )ds);
    }
#line 2679
    db1 = target[c1___0];
#line 2679
    if ((int )db1 > 3) {
#line 2681
      db1 = (short )((int )db1 / 3);
#line 2681
      balance[c1___0] = (short )((int )balance[c1___0] + (int )db1);
#line 2682
      balance[c2___0] = (short )((int )balance[c2___0] - (int )db1);
#line 2683
      ds = (short )((int )db1 / 4);
#line 2683
      stage = (short )((int )stage + (int )ds);
    }
#line 2686
    ds = (short )((int )captured[c1___0] / 2);
#line 2686
    stage = (short )((int )stage + (int )ds);
#line 2688
    db1 = captured[c1___0];
#line 2688
    if ((int )db1 > 4) {
#line 2690
      db1 = (short )((int )db1 / 2);
#line 2690
      balance[c1___0] = (short )((int )balance[c1___0] + (int )db1);
#line 2691
      ds = (short)3;
#line 2691
      stage = (short )((int )stage + (int )ds);
    }
#line 2694
    db1 = dcaptured[c1___0];
#line 2694
    if ((int )db1 > 3) {
#line 2696
      balance[c1___0] = (short )((int )balance[c1___0] + (int )db1);
#line 2697
      ds = (short)3;
#line 2697
      stage = (short )((int )stage + (int )ds);
    }
#line 2700
    if ((int )balance[c1___0] > 99) {
#line 2701
      balance[c1___0] = (short)99;
    } else
#line 2702
    if ((int )balance[c1___0] < 0) {
#line 2703
      balance[c1___0] = (short)0;
    }
#line 2646
    c1___0 = (short )((int )c1___0 + 1);
#line 2646
    c2___0 = (short )((int )c2___0 - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2706
  if ((int )stage > 99) {
#line 2707
    stage = (short)99;
  } else
#line 2708
  if ((int )stage < 0) {
#line 2709
    stage = (short)0;
  }
#line 2711
  if (flag.post) {
    {
#line 2712
    ShowStage();
    }
  }
#line 2716
  ADVNCM[1] = (short)1;
#line 2718
  ADVNCM[2] = (short)1;
#line 2719
  ADVNCM[3] = (short)1;
#line 2721
  ADVNCM[4] = (short)1;
#line 2722
  ADVNCM[5] = (short)1;
#line 2723
  ADVNCM[6] = (short)1;
#line 2724
  ADVNCM[7] = (short)1;
#line 2725
  ADVNCM[14] = (short)1;
#line 2727
  if ((int )stage < 33) {
#line 2727
    MAXCDIST = (short )((33 - (int )stage) / 4);
  } else {
#line 2727
    MAXCDIST = (short)0;
  }
#line 2728
  if ((int )stage < 30) {
#line 2728
    MAXADIST = (short )((30 - (int )stage) / 4);
  } else {
#line 2728
    MAXADIST = (short)0;
  }
#line 2730
  c1___0 = (short)0;
  {
#line 2730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2730
    if (! ((int )c1___0 <= 1)) {
#line 2730
      goto while_break___0;
    }
#line 2732
    feature = (short)0;
    {
#line 2732
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2732
      if (! ((int )feature < 31)) {
#line 2732
        goto while_break___1;
      }
#line 2734
      fvalue[c1___0][feature] = (signed char )(((int )(*fscore)[stage][feature][0] * (99 - (int )balance[c1___0]) + 50) / 100 + ((int )(*fscore)[stage][feature][1] * (int )balance[c1___0] + 50) / 100);
#line 2732
      feature = (short )((int )feature + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2730
    c1___0 = (short )((int )c1___0 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2741
  return;
}
}
#line 2745 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
void UpdateWeights(short stage___0 ) 
{ 


  {
#line 2748
  return;
}
}
#line 2763 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short linear_piece_value(short piece , short stage___0 , short i___0 , short j ) 
{ 
  short minvalue ;
  short maxvalue ;
  short minstage ;
  short maxstage ;

  {
#line 2768
  minstage = (short )ispvalue[0][i___0];
#line 2769
  maxstage = (short )ispvalue[0][j];
#line 2770
  minvalue = (short )ispvalue[piece][i___0];
#line 2771
  maxvalue = (short )ispvalue[piece][j];
#line 2774
  return ((short )((((int )stage___0 - (int )minstage) * ((int )maxvalue - (int )minvalue)) / ((int )maxstage - (int )minstage) + (int )minvalue));
}
}
#line 2780 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
static short linear_feature_value(short feature , short stage___0 , short i___0 ,
                                  short j ) 
{ 
  short minvalue ;
  short maxvalue ;
  short minstage ;
  short maxstage ;

  {
#line 2785
  minstage = (short )ispvalue[0][i___0];
#line 2786
  maxstage = (short )ispvalue[0][j];
#line 2787
  minvalue = (short )weight[feature][i___0];
#line 2788
  maxvalue = (short )weight[feature][j];
#line 2791
  return ((short )((((int )stage___0 - (int )minstage) * ((int )maxvalue - (int )minvalue)) / ((int )maxstage - (int )minstage) + (int )minvalue));
}
}
#line 2813 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/eval.c"
void Initialize_eval(void) 
{ 
  short stage___0 ;
  short piece ;
  short feature ;
  short i___0 ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;

  {
#line 2818
  stage___0 = (short)0;
  {
#line 2818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2818
    if (! ((int )stage___0 < 100)) {
#line 2818
      goto while_break;
    }
#line 2820
    i___0 = (short)0;
    {
#line 2820
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2820
      if (! ((int )i___0 < 4)) {
#line 2820
        goto while_break___0;
      }
#line 2822
      if ((int )stage___0 == (int )ispvalue[0][i___0]) {
#line 2824
        piece = (short)0;
        {
#line 2824
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2824
          if (! ((int )piece < 15)) {
#line 2824
            goto while_break___1;
          }
#line 2826
          (*value)[stage___0][piece] = (short )(((-700L * (long )stage___0 + 100000L) * (long )ispvalue[piece][i___0]) / 10000L);
#line 2824
          piece = (short )((int )piece + 1);
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2830
        feature = (short)0;
        {
#line 2830
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2830
          if (! ((int )feature < 31)) {
#line 2830
            goto while_break___2;
          }
#line 2832
          (*fscore)[stage___0][feature][0] = (signed char )(((int )weight[feature][i___0] * (int )weight[feature][4] + 50) / 100);
#line 2836
          (*fscore)[stage___0][feature][1] = (signed char )(((int )weight[feature][i___0] * (int )weight[feature][5] + 50) / 100);
#line 2830
          feature = (short )((int )feature + 1);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2841
        goto while_break___0;
      }
#line 2844
      if ((int )stage___0 < (int )ispvalue[0][(int )i___0 + 1]) {
#line 2846
        piece = (short)0;
        {
#line 2846
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2846
          if (! ((int )piece < 15)) {
#line 2846
            goto while_break___3;
          }
          {
#line 2848
          tmp = linear_piece_value(piece, stage___0, i___0, (short )((int )i___0 + 1));
#line 2848
          (*value)[stage___0][piece] = (short )(((-700L * (long )stage___0 + 100000L) * (long )tmp) / 10000L);
#line 2846
          piece = (short )((int )piece + 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2854
        feature = (short)0;
        {
#line 2854
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2854
          if (! ((int )feature < 31)) {
#line 2854
            goto while_break___4;
          }
          {
#line 2856
          tmp___0 = linear_feature_value(feature, stage___0, i___0, (short )((int )i___0 + 1));
#line 2856
          (*fscore)[stage___0][feature][0] = (signed char )(((int )tmp___0 * (int )weight[feature][4] + 50) / 100);
#line 2860
          tmp___1 = linear_feature_value(feature, stage___0, i___0, (short )((int )i___0 + 1));
#line 2860
          (*fscore)[stage___0][feature][1] = (signed char )(((int )tmp___1 * (int )weight[feature][5] + 50) / 100);
#line 2854
          feature = (short )((int )feature + 1);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2865
        goto while_break___0;
      }
#line 2820
      i___0 = (short )((int )i___0 + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2818
    stage___0 = (short )((int )stage___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 2869
  return;
}
}
#line 1005 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
short generate_move_flags ;
#line 1112
short DropPossible(short piece , short side , short sq ) ;
#line 1115
short IsCheckmate(short side , short in_check , short blockable ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short *TrP  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static struct leaf *node  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static short sqking  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static short sqxking  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static short InCheck  =    (short)0;
#line 41 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static short GenerateAllMoves  =    (short)0;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static short check_determined  =    (short)0;
#line 44 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short deepsearchcut  =    (short)1;
#line 45 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short tas  =    (short)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short taxs  =    (short)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short ssa  =    (short)0;
#line 47 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short generate_move_flags  =    (short)0;
#line 89 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void GenMakeMove(short side , short f , short t , short *tempb___2 , short *tempc___2 ,
                        short promote_piece ) 
{ 
  short piece ;
  short upiece ;
  short n ;
  signed char tmp ;

  {
#line 99
  t = (short )((int )t & 127);
#line 101
  if ((int )f > 81) {
#line 103
    piece = (short )((int )f - 81);
#line 105
    if ((int )piece > 15) {
#line 106
      piece = (short )((int )piece - 15);
    }
#line 108
    board[t] = (signed char )piece;
#line 109
    color[t] = (signed char )side;
#line 110
    tmp = Captured[side][piece];
#line 110
    Captured[side][piece] = (signed char )((int )Captured[side][piece] - 1);
#line 110
    n = (short )tmp;
#line 111
    hashbd ^= (*drop_hashcode)[side][piece][n].bd;
#line 111
    hashkey ^= (*drop_hashcode)[side][piece][n].key;
#line 112
    if ((int )t >= 0) {
#line 112
      hashbd ^= (*hashcode)[side][piece][t].bd;
#line 112
      hashkey ^= (*hashcode)[side][piece][t].key;
    }
    {
#line 113
    UpdatePieceList(side, t, (UpdatePieceList_mode )2);
    }
  } else {
#line 117
    *tempb___2 = (short )board[t];
#line 118
    *tempc___2 = (short )color[t];
#line 120
    if ((int )*tempb___2 != 0) {
#line 122
      upiece = (short )unpromoted[*tempb___2];
#line 122
      Captured[side][upiece] = (signed char )((int )Captured[side][upiece] + 1);
#line 122
      n = (short )Captured[side][upiece];
#line 123
      hashbd ^= (*drop_hashcode)[side][upiece][n].bd;
#line 123
      hashkey ^= (*drop_hashcode)[side][upiece][n].key;
#line 124
      if ((int )t >= 0) {
#line 124
        hashbd ^= (*hashcode)[*tempc___2][*tempb___2][t].bd;
#line 124
        hashkey ^= (*hashcode)[*tempc___2][*tempb___2][t].key;
      }
      {
#line 125
      UpdatePieceList(*tempc___2, t, (UpdatePieceList_mode )1);
      }
    }
#line 128
    piece = (short )board[f];
#line 129
    Pindex[t] = Pindex[f];
#line 130
    PieceList[side][Pindex[t]] = (signed char )t;
#line 131
    color[f] = (signed char)2;
#line 132
    board[f] = (signed char)0;
#line 133
    color[t] = (signed char )side;
#line 135
    if (promote_piece) {
#line 137
      if ((int )f >= 0) {
#line 137
        hashbd ^= (*hashcode)[side][piece][f].bd;
#line 137
        hashkey ^= (*hashcode)[side][piece][f].key;
      }
#line 138
      board[t] = (signed char )promoted[piece];
#line 139
      if ((int )t >= 0) {
#line 139
        hashbd ^= (*hashcode)[side][board[t]][t].bd;
#line 139
        hashkey ^= (*hashcode)[side][board[t]][t].key;
      }
    } else {
#line 143
      board[t] = (signed char )piece;
#line 144
      if ((int )f >= 0) {
#line 144
        hashbd ^= (*hashcode)[side][piece][f].bd;
#line 144
        hashkey ^= (*hashcode)[side][piece][f].key;
      }
#line 144
      if ((int )t >= 0) {
#line 144
        hashbd ^= (*hashcode)[side][piece][t].bd;
#line 144
        hashkey ^= (*hashcode)[side][piece][t].key;
      }
    }
  }
#line 156
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void GenUnmakeMove(short side , short f , short t , short tempb___2 , short tempc___2 ,
                          short promote_piece ) 
{ 
  short piece ;
  short upiece ;
  short n ;
  signed char tmp ;

  {
#line 174
  t = (short )((int )t & 127);
#line 176
  if ((int )f > 81) {
#line 178
    piece = (short )((int )f - 81);
#line 180
    if ((int )piece > 15) {
#line 181
      piece = (short )((int )piece - 15);
    }
#line 183
    board[t] = (signed char)0;
#line 184
    color[t] = (signed char)2;
#line 185
    Captured[side][piece] = (signed char )((int )Captured[side][piece] + 1);
#line 185
    n = (short )Captured[side][piece];
#line 186
    hashbd ^= (*drop_hashcode)[side][piece][n].bd;
#line 186
    hashkey ^= (*drop_hashcode)[side][piece][n].key;
#line 187
    if ((int )t >= 0) {
#line 187
      hashbd ^= (*hashcode)[side][piece][t].bd;
#line 187
      hashkey ^= (*hashcode)[side][piece][t].key;
    }
    {
#line 188
    UpdatePieceList(side, t, (UpdatePieceList_mode )1);
    }
  } else {
#line 192
    piece = (short )board[t];
#line 193
    color[t] = (signed char )tempc___2;
#line 194
    board[t] = (signed char )tempb___2;
#line 195
    Pindex[f] = Pindex[t];
#line 196
    PieceList[side][Pindex[f]] = (signed char )f;
#line 198
    if ((int )tempb___2 != 0) {
#line 201
      upiece = (short )unpromoted[tempb___2];
#line 201
      tmp = Captured[side][upiece];
#line 201
      Captured[side][upiece] = (signed char )((int )Captured[side][upiece] - 1);
#line 201
      n = (short )tmp;
#line 202
      hashbd ^= (*drop_hashcode)[side][upiece][n].bd;
#line 202
      hashkey ^= (*drop_hashcode)[side][upiece][n].key;
#line 203
      if ((int )t >= 0) {
#line 203
        hashbd ^= (*hashcode)[tempc___2][tempb___2][t].bd;
#line 203
        hashkey ^= (*hashcode)[tempc___2][tempb___2][t].key;
      }
      {
#line 204
      UpdatePieceList(tempc___2, t, (UpdatePieceList_mode )2);
      }
    }
#line 207
    color[f] = (signed char )side;
#line 209
    if (promote_piece) {
#line 211
      if ((int )t >= 0) {
#line 211
        hashbd ^= (*hashcode)[side][piece][t].bd;
#line 211
        hashkey ^= (*hashcode)[side][piece][t].key;
      }
#line 212
      board[f] = (signed char )unpromoted[piece];
#line 213
      if ((int )f >= 0) {
#line 213
        hashbd ^= (*hashcode)[side][board[f]][f].bd;
#line 213
        hashkey ^= (*hashcode)[side][board[f]][f].key;
      }
    } else {
#line 217
      board[f] = (signed char )piece;
#line 218
      if ((int )f >= 0) {
#line 218
        hashbd ^= (*hashcode)[side][piece][f].bd;
#line 218
        hashkey ^= (*hashcode)[side][piece][f].key;
      }
#line 218
      if ((int )t >= 0) {
#line 218
        hashbd ^= (*hashcode)[side][piece][t].bd;
#line 218
        hashkey ^= (*hashcode)[side][piece][t].key;
      }
    }
  }
#line 230
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void gives_check_flag(unsigned short *flags , short side , short f , short t ) 
{ 
  short tempb___2 ;
  short tempc___2 ;
  short blockable ;
  short promote_piece ;
  int tmp ;

  {
  {
#line 238
  promote_piece = (short )(((int )*flags & 16) != 0);
#line 239
  GenMakeMove(side, f, t, & tempb___2, & tempc___2, promote_piece);
#line 241
  tmp = SqAttacked(sqxking, side, & blockable);
  }
#line 241
  if (tmp) {
#line 242
    *flags = (unsigned short )((int )*flags | 256);
  }
  {
#line 244
  GenUnmakeMove(side, f, t, tempb___2, tempc___2, promote_piece);
  }
#line 245
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void Link(short side , short piece , short from , short to , unsigned short local_flag ,
                 short s ) 
{ 
  short tempb___2 ;
  short tempc___2 ;
  short sq ;
  short threat ;
  short blockable ;
  short promote_piece ;
  int tmp ;

  {
#line 252
  if ((int )*TrP == 4000) {
    {
#line 254
    ShowMessage((char *)"TREE overflow\n");
    }
  } else {
#line 258
    node->f = (unsigned char )from;
#line 259
    if ((int )local_flag & 16) {
#line 259
      node->t = (unsigned char )((int )to | 128);
    } else {
#line 259
      node->t = (unsigned char )to;
    }
#line 260
    node->reply = (short)0;
#line 261
    node->flags = local_flag;
#line 262
    node->score = s;
#line 263
    node->INCscore = INCscore;
#line 265
    if (GenerateAllMoves) {
#line 268
      *TrP = (short )((int )*TrP + 1);
#line 268
      node ++;
    } else
#line 270
    if (InCheck) {
      {
#line 274
      promote_piece = (short )(((int )node->flags & 16) != 0);
#line 275
      GenMakeMove(side, (short )node->f, (short )node->t, & tempb___2, & tempc___2,
                  promote_piece);
      }
#line 277
      if ((int )from == (int )sqking) {
#line 277
        sq = to;
      } else {
#line 277
        sq = sqking;
      }
      {
#line 278
      tmp = SqAttacked(sq, (short )((int )side ^ 1), & blockable);
#line 278
      threat = (short )tmp;
#line 279
      GenUnmakeMove(side, (short )node->f, (short )node->t, tempb___2, tempc___2,
                    promote_piece);
      }
#line 282
      if (! threat) {
#line 285
        *TrP = (short )((int )*TrP + 1);
#line 285
        node ++;
      }
    } else
#line 288
    if (flag.tsume) {
#line 291
      if (! ((int )node->flags & 256)) {
#line 291
        if (! check_determined) {
          {
#line 294
          gives_check_flag(& node->flags, side, (short )node->f, (short )node->t);
          }
        }
      }
#line 297
      if ((int )node->flags & 256) {
#line 300
        *TrP = (short )((int )*TrP + 1);
#line 300
        node ++;
      }
    } else {
#line 306
      *TrP = (short )((int )*TrP + 1);
#line 306
      node ++;
    }
  }
#line 309
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
int PromotionPossible(short color___0 , short f , short t , short p ) 
{ 


  {
#line 315
  if ((int )color___0 == 0) {
#line 317
    if (! ((int )f > 53)) {
#line 317
      if (! ((int )t > 53)) {
#line 318
        return (0);
      }
    }
  } else
#line 322
  if (! ((int )f < 27)) {
#line 322
    if (! ((int )t < 27)) {
#line 323
      return (0);
    }
  }
  {
#line 336
  if ((int )p == 7) {
#line 336
    goto case_7;
  }
#line 336
  if ((int )p == 6) {
#line 336
    goto case_7;
  }
#line 336
  if ((int )p == 4) {
#line 336
    goto case_7;
  }
#line 336
  if ((int )p == 3) {
#line 336
    goto case_7;
  }
#line 336
  if ((int )p == 2) {
#line 336
    goto case_7;
  }
#line 336
  if ((int )p == 1) {
#line 336
    goto case_7;
  }
#line 327
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 337
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 340
  return (0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
int NonPromotionPossible(short color___0 , short f , short t , short p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 350
  if ((int )p == 1) {
#line 350
    goto case_1;
  }
#line 365
  if ((int )p == 2) {
#line 365
    goto case_2;
  }
#line 379
  if ((int )p == 3) {
#line 379
    goto case_3;
  }
#line 348
  goto switch_break;
  case_1: /* CIL Label */ 
#line 351
  if ((int )color___0 == 0) {
#line 353
    if ((int )t < 72) {
#line 353
      tmp___0 = 1;
    } else {
#line 353
      if (generate_move_flags) {
#line 353
        tmp = -32761;
      } else {
#line 353
        tmp = 0;
      }
#line 353
      tmp___0 = tmp;
    }
#line 353
    return (tmp___0);
  } else {
#line 359
    if ((int )t > 8) {
#line 359
      tmp___2 = 1;
    } else {
#line 359
      if (generate_move_flags) {
#line 359
        tmp___1 = -32761;
      } else {
#line 359
        tmp___1 = 0;
      }
#line 359
      tmp___2 = tmp___1;
    }
#line 359
    return (tmp___2);
  }
  case_2: /* CIL Label */ 
#line 366
  if ((int )color___0 == 0) {
#line 368
    if ((int )t < 72) {
#line 368
      tmp___4 = 1;
    } else {
#line 368
      if (generate_move_flags) {
#line 368
        tmp___3 = -32761;
      } else {
#line 368
        tmp___3 = 0;
      }
#line 368
      tmp___4 = tmp___3;
    }
#line 368
    return (tmp___4);
  } else {
#line 374
    if ((int )t > 8) {
#line 374
      tmp___6 = 1;
    } else {
#line 374
      if (generate_move_flags) {
#line 374
        tmp___5 = -32761;
      } else {
#line 374
        tmp___5 = 0;
      }
#line 374
      tmp___6 = tmp___5;
    }
#line 374
    return (tmp___6);
  }
  case_3: /* CIL Label */ 
#line 380
  if ((int )color___0 == 0) {
#line 382
    if ((int )t < 63) {
#line 382
      tmp___8 = 1;
    } else {
#line 382
      if (generate_move_flags) {
#line 382
        tmp___7 = -32761;
      } else {
#line 382
        tmp___7 = 0;
      }
#line 382
      tmp___8 = tmp___7;
    }
#line 382
    return (tmp___8);
  } else {
#line 388
    if ((int )t > 17) {
#line 388
      tmp___10 = 1;
    } else {
#line 388
      if (generate_move_flags) {
#line 388
        tmp___9 = -32761;
      } else {
#line 388
        tmp___9 = 0;
      }
#line 388
      tmp___10 = tmp___9;
    }
#line 388
    return (tmp___10);
  }
  switch_break: /* CIL Label */ ;
  }
#line 395
  return (1);
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static short field_bonus(short ply , short side , short piece , short f , short t ,
                         unsigned short *local_flag ) 
{ 
  short s ;
  short u ;
  short ptyp ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short c1___0 ;
  short c2___0 ;
  short coloru ;
  short tmp ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  short boardu ;
  short upiece ;
  short rvupiece ;
  short rvuboard ;

  {
#line 415
  c1___0 = side;
#line 416
  c2___0 = (short )((int )side ^ 1);
#line 417
  s = (short)0;
#line 418
  check_determined = (short)1;
#line 420
  ptyp = (short )ptype[side][piece];
#line 425
  ppos = (*(nextpos[ptyp]))[t];
#line 426
  pdir = (*(nextdir[ptyp]))[t];
#line 427
  u = (short )*(ppos + t);
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    coloru = (short )color[u];
#line 434
    if ((int )piece != 14) {
#line 434
      if ((int )GameCnt > 40) {
        {
#line 436
        tmp___0 = distance(u, (short )PieceList[c2___0][0]);
        }
#line 436
        if ((int )tmp___0 <= 1) {
#line 439
          s = (short )((int )s + 2);
#line 440
          *local_flag = (unsigned short )((int )*local_flag | 8192);
        } else {
          {
#line 442
          tmp = distance(u, (short )PieceList[c1___0][0]);
          }
#line 442
          if ((int )tmp <= 1) {
#line 445
            s = (short )((int )s + 1);
#line 446
            *local_flag = (unsigned short )((int )*local_flag | 8192);
          }
        }
      }
    }
#line 450
    if ((int )coloru == (int )side) {
#line 456
      u = (short )*(pdir + u);
    } else {
      {
#line 462
      tmp___2 = PromotionPossible(side, t, u, piece);
      }
#line 462
      if (tmp___2) {
#line 465
        if ((int )piece == 1) {
#line 467
          s = (short )((int )s + 2);
#line 469
          if ((int )side == 0) {
#line 469
            tmp___1 = (int )t > 53;
          } else {
#line 469
            tmp___1 = (int )t < 27;
          }
#line 469
          if (! tmp___1) {
#line 471
            *local_flag = (unsigned short )((int )*local_flag | 128);
#line 472
            s = (short )((int )s + 1);
          }
        } else {
#line 478
          s = (short )((int )s + 1);
        }
      }
#line 482
      if ((int )coloru == 2) {
#line 485
        if ((int )u == (int )FROMsquare) {
#line 488
          s = (short )((int )s + 1);
        }
#line 494
        u = (short )*(ppos + u);
      } else {
#line 503
        s = (short )((int )s + 1);
#line 505
        if ((int )u == (int )TOsquare) {
#line 506
          s = (short )((int )s + 1);
        }
#line 508
        boardu = (short )board[u];
#line 508
        if ((int )boardu == 14) {
#line 510
          s = (short )((int )s + 20);
#line 510
          INCscore = (short )((int )INCscore - 18);
#line 511
          *local_flag = (unsigned short )((int )*local_flag | 256);
        }
#line 516
        upiece = (short )unpromoted[piece];
#line 517
        rvupiece = (short )relative_value[upiece];
#line 518
        rvuboard = (short )relative_value[unpromoted[boardu]];
#line 520
        if ((int )upiece == 1) {
#line 520
          if ((int )Captured[side][1] > 1) {
#line 522
            *local_flag = (unsigned short )((int )*local_flag | 128);
#line 523
            s = (short )((int )s + 1);
          }
        }
#line 526
        if ((int )rvupiece <= (int )rvuboard) {
#line 528
          *local_flag = (unsigned short )((int )*local_flag | 128);
#line 531
          if ((int )f > 81) {
#line 532
            s = (short )((int )s + 2);
          } else {
#line 534
            s = (short )((int )s + 1);
          }
#line 536
          if ((int )upiece == 1) {
#line 537
            s = (short )((int )s + 1);
          }
#line 540
          if ((int )rvupiece == (int )rvuboard) {
#line 540
            if ((int )upiece == 1) {
#line 540
              goto _L;
            } else {
#line 540
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 540
          if ((int )upiece == 6) {
#line 540
            goto _L;
          } else
#line 540
          if ((int )upiece == 3) {
            _L: /* CIL Label */ 
#line 547
            s = (short )((int )s + 1);
#line 549
            if ((int )upiece == 1) {
#line 550
              s = (short )((int )s + 1);
            }
          }
        }
#line 558
        u = (short )*(pdir + u);
      }
    }
#line 430
    if (! ((int )u != (int )t)) {
#line 430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  INCscore = (short )((int )INCscore + (int )s);
#line 567
  return (s);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
void LinkMove(short ply , short f , short t , unsigned short local_flag , short xside___0 ,
              short score_if_impossible ) 
{ 
  short s ;
  short side ;
  short piece ;
  short mv ;
  short flag_tsume ;
  short try_link ;
  short c1___0 ;
  short c2___0 ;
  short ds ;
  short is_drop ;
  unsigned long as ;
  int tmp ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long axs ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  short tmp___8 ;
  short tmp___9 ;
  short tmp___10 ;
  short tmp___11 ;
  int tmp___12 ;
  short tmp___13 ;
  int consider_last ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  short tmp___17 ;
  int tmp___18 ;

  {
#line 590
  s = (short)0;
#line 592
  try_link = (short)1;
#line 593
  is_drop = (short )((int )f > 81);
#line 594
  as = 0UL;
#line 596
  flag_tsume = flag.tsume;
#line 598
  side = (short )((int )xside___0 ^ 1);
#line 598
  c1___0 = side;
#line 599
  c2___0 = xside___0;
#line 605
  check_determined = (short )(((int )local_flag & 256) != 0);
#line 607
  if ((int )local_flag & 16) {
#line 607
    tmp = (int )t | 128;
  } else {
#line 607
    tmp = (int )t;
  }
#line 607
  mv = (short )(((int )f << 8) | tmp);
#line 609
  if ((int )f > 81) {
#line 611
    piece = (short )((int )f - 81);
#line 613
    if ((int )piece > 15) {
#line 614
      piece = (short )((int )piece - 15);
    }
  } else {
#line 618
    piece = (short )board[f];
  }
#line 621
  if ((int )score_if_impossible < 0) {
    {
#line 624
    Link(side, piece, f, t, local_flag, score_if_impossible);
    }
#line 627
    return;
  }
#line 630
  INCscore = (short)0;
#line 633
  if (side) {
#line 633
    tmp___0 = 1 << 15;
  } else {
#line 633
    tmp___0 = 0;
  }
#line 633
  s = (short )((int )s + (int )*(history + (tmp___0 | (((int )mv & 32767) ^ 21845))));
#line 638
  if (! ((int )local_flag & 512)) {
#line 640
    if ((int )*TrP > 3700) {
#line 643
      flag.tsume = (short)1;
    }
  }
#line 649
  if ((int )piece != 14) {
#line 649
    if (! flag.tsume) {
#line 649
      if (! ((int )stage < 33)) {
#line 649
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 651
      tmp___2 = distance(t, (short )PieceList[c2___0][0]);
      }
#line 651
      if ((int )tmp___2 <= 1) {
#line 654
        s = (short )((int )s + 15);
#line 655
        INCscore = (short )((int )INCscore + 2);
#line 656
        local_flag = (unsigned short )((int )local_flag | 8192);
      } else {
        {
#line 658
        tmp___1 = distance(t, (short )PieceList[c1___0][0]);
        }
#line 658
        if ((int )tmp___1 <= 1) {
#line 661
          s = (short )((int )s + 10);
#line 662
          INCscore = (short )((int )INCscore + 1);
#line 663
          local_flag = (unsigned short )((int )local_flag | 8192);
        }
      }
    }
  }
#line 667
  if (tas) {
#line 670
    if (is_drop) {
#line 670
      as = (unsigned long )attack[side][t];
#line 670
      tmp___3 = as;
    } else {
#line 670
      as = (unsigned long )((attack[side][t] & 255L) > 1L);
#line 670
      tmp___3 = as;
    }
#line 670
    if (tmp___3) {
#line 673
      if (flag.tsume) {
#line 673
        ds = (short)100;
      } else
#line 673
      if ((int )stage > 66) {
#line 673
        ds = (short)100;
      } else {
#line 673
        ds = (short)10;
      }
#line 673
      s = (short )((int )s + (int )ds);
    }
  }
#line 676
  if (taxs) {
#line 683
    axs = (unsigned long )attack[xside___0][t];
#line 683
    if (axs) {
#line 683
      if (tas) {
#line 683
        if (as) {
#line 683
          if (axs & (unsigned long )control[14]) {
#line 683
            if ((axs & 255UL) == 1UL) {
              _L___0: /* CIL Label */ 
#line 687
              if (flag.tsume) {
#line 687
                ds = (short)200;
              } else
#line 687
              if ((int )stage > 66) {
#line 687
                ds = (short)200;
              } else {
#line 687
                if (is_drop) {
#line 687
                  if ((int )side == 0) {
#line 687
                    tmp___6 = (int )t > 53;
                  } else {
#line 687
                    tmp___6 = (int )t < 27;
                  }
#line 687
                  if (tmp___6) {
#line 687
                    tmp___5 = 40 + (int )relative_value[piece];
                  } else {
#line 687
                    tmp___5 = 10;
                  }
#line 687
                  tmp___7 = tmp___5;
                } else {
#line 687
                  tmp___7 = 20;
                }
#line 687
                ds = (short )tmp___7;
              }
#line 687
              s = (short )((int )s + (int )ds);
            }
          }
        }
      }
    } else {
#line 683
      goto _L___0;
    }
  }
#line 699
  if ((int )TOsquare >= 0) {
    {
#line 700
    tmp___8 = distance(TOsquare, t);
#line 700
    s = (short )((int )s + (9 - (int )tmp___8));
    }
  }
#line 702
  if ((int )FROMsquare >= 0) {
    {
#line 703
    tmp___9 = distance(FROMsquare, t);
#line 703
    s = (short )((int )s + (9 - (int )tmp___9) / 2);
    }
  }
#line 707
  if (! flag.tsume) {
#line 707
    if (! ((int )stage < 33)) {
#line 707
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 707
  if ((int )piece != 14) {
#line 709
    if ((int )balance[c1___0] < 50) {
      {
#line 710
      tmp___10 = distance((short )PieceList[c2___0][0], t);
#line 710
      s = (short )((int )s + ((9 - (int )tmp___10) * (50 - (int )balance[c1___0])) / 20);
      }
    } else {
      {
#line 712
      tmp___11 = distance((short )PieceList[c1___0][0], t);
#line 712
      s = (short )((int )s + ((9 - (int )tmp___11) * ((int )balance[c1___0] - 50)) / 20);
      }
    }
  }
#line 715
  if ((int )f > 81) {
#line 719
    if (flag.tsume) {
#line 719
      tmp___12 = 25;
    } else
#line 719
    if ((int )stage > 66) {
#line 719
      tmp___12 = 25;
    } else {
#line 719
      tmp___12 = 10;
    }
#line 719
    s = (short )((int )s + tmp___12);
#line 721
    if ((int )t == (int )FROMsquare) {
#line 724
      s = (short )((int )s + 5);
    }
#line 727
    if ((int )piece == 5) {
#line 728
      s = (short )((int )s - 32 / (int )Captured[side][5]);
    } else
#line 729
    if ((int )piece == 4) {
#line 730
      s = (short )((int )s - 16 / (int )Captured[side][4]);
    }
    {
#line 733
    tmp___13 = field_bonus(ply, side, piece, f, t, & local_flag);
#line 733
    s = (short )((int )s + (int )tmp___13);
    }
#line 735
    if ((int )s == 10) {
#line 735
      if ((int )piece != 1) {
#line 736
        local_flag = (unsigned short )((int )local_flag | 4096);
      }
    }
  } else {
#line 742
    consider_last = 0;
#line 744
    if (flag.tsume) {
#line 744
      goto _L___2;
    } else
#line 744
    if ((int )stage > 66) {
      _L___2: /* CIL Label */ 
#line 744
      if (Captured[side][5]) {
#line 745
        s = (short )((int )s + 10);
      }
    }
#line 747
    s = (short )((int )s + 20);
#line 749
    if ((int )t == (int )FROMsquare) {
#line 752
      if (flag.tsume) {
#line 752
        tmp___14 = 10;
      } else
#line 752
      if ((int )stage > 66) {
#line 752
        tmp___14 = 10;
      } else {
#line 752
        tmp___14 = 1;
      }
#line 752
      s = (short )((int )s + tmp___14);
    }
#line 755
    if ((int )color[t] != 2) {
#line 758
      if (flag.tsume) {
#line 760
        s = (short )((int )s + (int )((int const   )relative_value[board[t]] - (int const   )relative_value[piece]));
      } else
#line 758
      if ((int )stage > 66) {
#line 760
        s = (short )((int )s + (int )((int const   )relative_value[board[t]] - (int const   )relative_value[piece]));
      } else {
#line 764
        s = (short )((int )s + ((int )(*value)[stage][board[t]] - (int )relative_value[piece]));
      }
#line 767
      if ((int )t == (int )TOsquare) {
#line 768
        if (flag.tsume) {
#line 768
          tmp___15 = 5;
        } else
#line 768
        if ((int )stage > 66) {
#line 768
          tmp___15 = 5;
        } else {
#line 768
          tmp___15 = 50;
        }
#line 768
        s = (short )((int )s + tmp___15);
      }
    }
#line 771
    if ((int )local_flag & 16) {
#line 774
      s = (short )((int )s + 1);
#line 775
      INCscore = (short )((long )INCscore + ((*(value + stage))[promoted[piece]] - (*(value + stage))[piece]));
    } else {
      {
#line 780
      tmp___16 = PromotionPossible(side, f, t, piece);
      }
#line 780
      if (tmp___16) {
#line 784
        if ((int )piece == 4) {
#line 790
          local_flag = (unsigned short )((int )local_flag | 128);
#line 791
          s = (short )((int )s + 1);
        } else
#line 784
        if ((int )piece == 3) {
#line 790
          local_flag = (unsigned short )((int )local_flag | 128);
#line 791
          s = (short )((int )s + 1);
        } else {
#line 796
          consider_last = 1;
#line 798
          if ((int )piece == 1) {
#line 800
            local_flag = (unsigned short )((int )local_flag | 2048);
#line 801
            INCscore = (short )((int )INCscore - 20);
          } else
#line 798
          if ((int )piece == 6) {
#line 800
            local_flag = (unsigned short )((int )local_flag | 2048);
#line 801
            INCscore = (short )((int )INCscore - 20);
          } else
#line 798
          if ((int )piece == 7) {
#line 800
            local_flag = (unsigned short )((int )local_flag | 2048);
#line 801
            INCscore = (short )((int )INCscore - 20);
          } else {
#line 805
            local_flag = (unsigned short )((int )local_flag | 4096);
#line 806
            INCscore = (short )((int )INCscore - 10);
          }
        }
      }
    }
#line 812
    if (consider_last) {
#line 814
      if ((int )local_flag & 2048) {
#line 815
        s = (short)0;
      } else {
#line 817
        s = (short )((int )s % 20);
      }
    } else {
      {
#line 822
      tmp___17 = field_bonus(ply, side, piece, f, t, & local_flag);
#line 822
      s = (short )((int )s + (int )tmp___17);
      }
    }
  }
#line 829
  if (! ((int )local_flag & 256)) {
#line 829
    if (! check_determined) {
      {
#line 831
      gives_check_flag(& local_flag, side, f, t);
      }
#line 833
      if ((int )local_flag & 256) {
#line 834
        s = (short )((int )s + 20);
      }
    }
  }
#line 841
  if (! flag.tsume) {
#line 841
    if (deepsearchcut) {
#line 843
      if ((int )ply > 0) {
#line 843
        if ((int )local_flag & 2048) {
#line 845
          if (flag.force) {
#line 845
            tmp___18 = 1;
          } else
#line 845
          if ((int )ply == 1) {
#line 845
            if ((int )side != (int )computer) {
#line 845
              tmp___18 = 1;
            } else {
#line 845
              tmp___18 = 0;
            }
          } else {
#line 845
            tmp___18 = 0;
          }
#line 845
          try_link = (short )tmp___18;
        } else {
#line 843
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 847
      if (hard_time_limit) {
#line 847
        if ((int )ply > 2) {
#line 847
          if (flag.timeout) {
#line 849
            flag.tsume = (short)1;
          } else {
#line 847
            goto _L___7;
          }
        } else {
#line 847
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 851
      if ((int )ply > 6) {
#line 851
        if (! ((int )local_flag & 8192)) {
#line 853
          flag.tsume = (short)1;
        } else {
#line 851
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 855
      if ((int )ply > 8) {
#line 855
        if ((int )local_flag & 4096) {
#line 857
          flag.tsume = (short)1;
        } else {
#line 855
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 860
      if ((int )ply > 8) {
#line 860
        if (! ((int )local_flag & 128)) {
#line 862
          flag.tsume = (short)1;
        } else {
#line 860
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 865
      if ((int )ply > 10) {
#line 865
        if ((int )f > 81) {
#line 867
          flag.tsume = (short)1;
        }
      }
    }
  }
#line 872
  if (try_link) {
    {
#line 874
    Link(side, piece, f, t, local_flag, (short )((int )s - 26000));
    }
  } else
#line 872
  if (GenerateAllMoves) {
    {
#line 874
    Link(side, piece, f, t, local_flag, (short )((int )s - 26000));
    }
  }
#line 878
  flag.tsume = flag_tsume;
#line 879
  return;
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short DropPossible(short piece , short side , short sq ) 
{ 
  short r ;
  short possible ;
  short f ;
  short tempb___2 ;
  short tempc___2 ;
  short tmp ;

  {
#line 886
  r = (short )((int )sq / 9);
#line 886
  possible = (short)1;
#line 888
  if ((int )board[sq] != 0) {
#line 890
    possible = (short)0;
  } else
#line 892
  if ((int )piece == 1) {
#line 894
    if ((int )side == 0) {
#line 894
      if ((int )r == 8) {
#line 896
        if (generate_move_flags) {
#line 896
          possible = (short)-32761;
        } else {
#line 896
          possible = (short)0;
        }
      } else {
#line 894
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 898
    if ((int )side == 1) {
#line 898
      if ((int )r == 0) {
#line 900
        if (generate_move_flags) {
#line 900
          possible = (short)-32761;
        } else {
#line 900
          possible = (short)0;
        }
      } else {
#line 898
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 902
    if (PawnCnt[side][(int )sq % 9]) {
#line 904
      if (generate_move_flags) {
#line 904
        possible = (short)-32762;
      } else {
#line 904
        possible = (short)0;
      }
    }
#line 908
    if (possible) {
#line 911
      f = (short)82;
#line 913
      if ((int )side == 1) {
#line 914
        f = (short )((int )f + 15);
      }
      {
#line 916
      GenMakeMove(side, f, sq, & tempb___2, & tempc___2, (short)0);
#line 918
      tmp = IsCheckmate((short )((int )side ^ 1), (short)-1, (short)-1);
      }
#line 918
      if (tmp) {
#line 919
        if (generate_move_flags) {
#line 919
          possible = (short)-32763;
        } else {
#line 919
          possible = (short)0;
        }
      }
      {
#line 921
      GenUnmakeMove(side, f, sq, tempb___2, tempc___2, (short)0);
      }
    }
  } else
#line 925
  if ((int )piece == 2) {
#line 927
    if ((int )side == 0) {
#line 927
      if ((int )r == 8) {
#line 928
        if (generate_move_flags) {
#line 928
          possible = (short)-32761;
        } else {
#line 928
          possible = (short)0;
        }
      } else {
#line 927
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 929
    if ((int )side == 1) {
#line 929
      if ((int )r == 0) {
#line 930
        if (generate_move_flags) {
#line 930
          possible = (short)-32761;
        } else {
#line 930
          possible = (short)0;
        }
      }
    }
  } else
#line 932
  if ((int )piece == 3) {
#line 934
    if ((int )side == 0) {
#line 934
      if ((int )r >= 7) {
#line 935
        if (generate_move_flags) {
#line 935
          possible = (short)-32761;
        } else {
#line 935
          possible = (short)0;
        }
      } else {
#line 934
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 936
    if ((int )side == 1) {
#line 936
      if ((int )r <= 1) {
#line 937
        if (generate_move_flags) {
#line 937
          possible = (short)-32761;
        } else {
#line 937
          possible = (short)0;
        }
      }
    }
  }
#line 941
  return (possible);
}
}
#line 1004 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
void GenMoves(short ply , short sq , short side , short xside___0 ) 
{ 
  short u ;
  short piece ;
  short ptyp ;
  short possible ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  unsigned short local_flag ;
  short c ;
  int tmp ;
  int tmp___0 ;

  {
#line 1016
  piece = (short )board[sq];
#line 1017
  ptyp = (short )ptype[side][piece];
#line 1022
  ppos = (*(nextpos[ptyp]))[sq];
#line 1023
  pdir = (*(nextdir[ptyp]))[sq];
#line 1024
  u = (short )*(ppos + sq);
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    c = (short )color[u];
#line 1032
    if ((int )c == (int )xside___0) {
#line 1033
      local_flag = (unsigned short)512;
    } else {
#line 1035
      local_flag = (unsigned short)0;
    }
#line 1037
    if ((int )c != (int )side) {
#line 1037
      if ((int )board[u] != 14) {
        {
#line 1039
        tmp___0 = PromotionPossible((short )color[sq], sq, u, piece);
        }
#line 1039
        if (tmp___0) {
          {
#line 1041
          LinkMove(ply, sq, u, (unsigned short )((int )local_flag | 16), xside___0,
                   (short)1);
#line 1043
          tmp = NonPromotionPossible((short )color[sq], sq, u, piece);
#line 1043
          possible = (short )tmp;
          }
#line 1043
          if (possible) {
            {
#line 1046
            LinkMove(ply, sq, u, local_flag, xside___0, possible);
            }
          }
        } else {
          {
#line 1051
          LinkMove(ply, sq, u, local_flag, xside___0, (short)1);
          }
        }
      }
    }
#line 1055
    if ((int )c == 2) {
#line 1066
      u = (short )*(ppos + u);
    } else {
#line 1070
      u = (short )*(pdir + u);
    }
#line 1027
    if (! ((int )u != (int )sq)) {
#line 1027
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1075
  return;
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void DropToSquare(short side , short xside___0 , short ply , short u ) 
{ 
  short i___0 ;
  short possible ;
  short f ;

  {
#line 1089
  i___0 = (short)1;
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    if (! ((int )i___0 < 14)) {
#line 1089
      goto while_break;
    }
#line 1091
    if (Captured[side][i___0]) {
      {
#line 1093
      possible = DropPossible(i___0, side, u);
      }
#line 1093
      if (possible) {
#line 1096
        f = (short )(81 + (int )i___0);
#line 1098
        if ((int )side == 1) {
#line 1099
          f = (short )((int )f + 15);
        }
        {
#line 1101
        LinkMove(ply, f, u, (unsigned short )(32 | (int )i___0), xside___0, possible);
        }
      }
    }
#line 1089
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1105
  return;
}
}
#line 1114 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void LinkPreventCheckDrops(short side , short xside___0 , short ply ) 
{ 
  unsigned char *ppos ;
  unsigned char *pdir ;
  short piece ;
  short u ;
  short xu ;
  short square ;
  short ptyp ;
  short n ;
  short drop_square[9] ;
  short tmp ;

  {
#line 1125
  square = (short )PieceList[side][0];
#line 1125
  if ((int )board[square] != 14) {
#line 1126
    return;
  }
#line 1128
  piece = (short)2;
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (! ((int )piece <= 7)) {
#line 1128
      goto while_break;
    }
#line 1130
    if ((int )piece == 2) {
#line 1130
      goto _L;
    } else
#line 1130
    if ((int )piece == 6) {
#line 1130
      goto _L;
    } else
#line 1130
    if ((int )piece == 7) {
      _L: /* CIL Label */ 
#line 1137
      ptyp = (short )ptype[side][piece];
#line 1138
      n = (short)0;
#line 1142
      ppos = (*(nextpos[ptyp]))[square];
#line 1143
      pdir = (*(nextdir[ptyp]))[square];
#line 1144
      u = (short )*(ppos + square);
      {
#line 1147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1149
        if ((int )color[u] == 2) {
#line 1165
          xu = (short )*(ppos + u);
#line 1165
          if ((int )xu == (int )*(pdir + u)) {
#line 1167
            n = (short)0;
          } else {
#line 1171
            tmp = n;
#line 1171
            n = (short )((int )n + 1);
#line 1171
            drop_square[tmp] = u;
          }
#line 1174
          u = xu;
        } else {
#line 1178
          if ((int )color[u] == (int )xside___0) {
#line 1178
            if ((int const   )unpromoted[board[u]] == (int const   )piece) {
              {
#line 1181
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1181
                if (! ((int )n > 0)) {
#line 1181
                  goto while_break___1;
                }
                {
#line 1183
                n = (short )((int )n - 1);
#line 1183
                DropToSquare(side, xside___0, ply, drop_square[n]);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 1188
              n = (short)0;
            }
          } else {
#line 1188
            n = (short)0;
          }
#line 1193
          u = (short )*(pdir + u);
        }
#line 1147
        if (! ((int )u != (int )square)) {
#line 1147
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1128
    piece = (short )((int )piece + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1200
  return;
}
}
#line 1208 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
static void LinkCheckDrops(short side , short xside___0 , short ply ) 
{ 
  unsigned char *ppos ;
  unsigned char *pdir ;
  short u ;
  short ptyp ;
  short square ;
  short piece ;
  short f ;
  short tmp ;

  {
#line 1219
  square = (short )PieceList[xside___0][0];
#line 1219
  if ((int )board[square] != 14) {
#line 1220
    return;
  }
#line 1222
  piece = (short)1;
  {
#line 1222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1222
    if (! ((int )piece < 14)) {
#line 1222
      goto while_break;
    }
#line 1224
    if (Captured[side][piece]) {
#line 1233
      ptyp = (short )ptype[xside___0][piece];
#line 1237
      ppos = (*(nextpos[ptyp]))[square];
#line 1238
      pdir = (*(nextdir[ptyp]))[square];
#line 1239
      u = (short )*(ppos + square);
      {
#line 1241
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1243
        if ((int )color[u] == 2) {
#line 1245
          if ((int )piece != 1) {
#line 1245
            goto _L;
          } else {
            {
#line 1245
            tmp = DropPossible((short)1, side, u);
            }
#line 1245
            if (tmp) {
              _L: /* CIL Label */ 
#line 1248
              f = (short )(81 + (int )piece);
#line 1250
              if ((int )side == 1) {
#line 1251
                f = (short )((int )f + 15);
              }
              {
#line 1253
              LinkMove(ply, f, u, (unsigned short )((32 | (int )piece) | 256), xside___0,
                       (short)1);
              }
            }
          }
#line 1260
          u = (short )*(ppos + u);
        } else {
#line 1268
          u = (short )*(pdir + u);
        }
#line 1241
        if (! ((int )u != (int )square)) {
#line 1241
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1222
    piece = (short )((int )piece + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1275
  return;
}
}
#line 1288 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
void MoveList(short side , short ply , short in_check , short blockable ) 
{ 
  short i___0 ;
  short xside___0 ;
  short u ;
  struct leaf *firstnode ;
  short flag_tsume ;
  short num ;
  unsigned short hiHt ;
  unsigned short hi0 ;
  unsigned short hi1 ;
  unsigned short hi2 ;
  unsigned short hi3 ;
  unsigned short hi4 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1297
  hiHt = (unsigned short)0;
#line 1297
  hi0 = (unsigned short)0;
#line 1297
  hi1 = (unsigned short)0;
#line 1297
  hi2 = (unsigned short)0;
#line 1297
  hi3 = (unsigned short)0;
#line 1297
  hi4 = (unsigned short)0;
#line 1300
  flag_tsume = flag.tsume;
#line 1302
  xside___0 = (short )((int )side ^ 1);
#line 1304
  sqking = (short )PieceList[side][0];
#line 1305
  sqxking = (short )PieceList[xside___0][0];
#line 1307
  if ((int )in_check >= 0) {
#line 1309
    InCheck = in_check;
  } else
#line 1313
  if ((int )board[sqking] == 14) {
    {
#line 1313
    tmp = SqAttacked(sqking, xside___0, & blockable);
#line 1313
    InCheck = (short )tmp;
    }
  } else {
#line 1313
    InCheck = (short)0;
  }
#line 1318
  if ((int )in_check == -2) {
#line 1318
    tmp___0 = 1;
  } else
#line 1318
  if (generate_move_flags) {
#line 1318
    tmp___0 = 1;
  } else {
#line 1318
    tmp___0 = 0;
  }
#line 1318
  GenerateAllMoves = (short )tmp___0;
#line 1320
  if (InCheck) {
#line 1323
    flag.tsume = (short)1;
  }
#line 1326
  TrP = & TrPnt[(int )ply + 1];
#line 1327
  *TrP = TrPnt[ply];
#line 1329
  node = Tree + *TrP;
#line 1329
  firstnode = node;
#line 1331
  if (! PV) {
#line 1332
    Swag0 = killr0[ply];
  } else {
#line 1334
    Swag0 = PV;
  }
#line 1336
  Swag1 = killr1[ply];
#line 1337
  Swag2 = killr2[ply];
#line 1338
  Swag3 = killr3[ply];
#line 1340
  if ((int )ply > 2) {
#line 1341
    Swag4 = killr1[(int )ply - 2];
  } else {
#line 1343
    Swag4 = (unsigned short)0;
  }
#line 1346
  if (use_history) {
#line 1348
    if (side) {
#line 1348
      tmp___1 = 1 << 15;
    } else {
#line 1348
      tmp___1 = 0;
    }
#line 1348
    hiHt = (unsigned short )(tmp___1 | (((int )SwagHt & 32767) ^ 21845));
#line 1348
    *(history + hiHt) = (unsigned short )((int )*(history + hiHt) + 5000);
#line 1349
    if (side) {
#line 1349
      tmp___2 = 1 << 15;
    } else {
#line 1349
      tmp___2 = 0;
    }
#line 1349
    hi0 = (unsigned short )(tmp___2 | (((int )Swag0 & 32767) ^ 21845));
#line 1349
    *(history + hi0) = (unsigned short )((int )*(history + hi0) + 2000);
#line 1350
    if (side) {
#line 1350
      tmp___3 = 1 << 15;
    } else {
#line 1350
      tmp___3 = 0;
    }
#line 1350
    hi1 = (unsigned short )(tmp___3 | (((int )Swag1 & 32767) ^ 21845));
#line 1350
    *(history + hi1) = (unsigned short )((int )*(history + hi1) + 60);
#line 1351
    if (side) {
#line 1351
      tmp___4 = 1 << 15;
    } else {
#line 1351
      tmp___4 = 0;
    }
#line 1351
    hi2 = (unsigned short )(tmp___4 | (((int )Swag2 & 32767) ^ 21845));
#line 1351
    *(history + hi2) = (unsigned short )((int )*(history + hi2) + 50);
#line 1352
    if (side) {
#line 1352
      tmp___5 = 1 << 15;
    } else {
#line 1352
      tmp___5 = 0;
    }
#line 1352
    hi3 = (unsigned short )(tmp___5 | (((int )Swag3 & 32767) ^ 21845));
#line 1352
    *(history + hi3) = (unsigned short )((int )*(history + hi3) + 40);
#line 1353
    if (side) {
#line 1353
      tmp___6 = 1 << 15;
    } else {
#line 1353
      tmp___6 = 0;
    }
#line 1353
    hi4 = (unsigned short )(tmp___6 | (((int )Swag4 & 32767) ^ 21845));
#line 1353
    *(history + hi4) = (unsigned short )((int )*(history + hi4) + 30);
  }
#line 1357
  i___0 = (short )PieceCnt[side];
  {
#line 1357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1357
    if (! ((int )i___0 >= 0)) {
#line 1357
      goto while_break;
    }
    {
#line 1358
    GenMoves(ply, (short )PieceList[side][i___0], side, xside___0);
#line 1357
    i___0 = (short )((int )i___0 - 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1360
  if (! InCheck) {
#line 1360
    goto _L;
  } else
#line 1360
  if (blockable) {
    _L: /* CIL Label */ 
#line 1362
    if (flag.tsume) {
#line 1365
      if (InCheck) {
        {
#line 1366
        LinkPreventCheckDrops(side, xside___0, ply);
        }
      } else {
        {
#line 1368
        LinkCheckDrops(side, xside___0, ply);
        }
      }
    } else {
#line 1372
      u = (short)0;
      {
#line 1372
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1372
        if (! ((int )u < 81)) {
#line 1372
          goto while_break___0;
        }
        {
#line 1373
        DropToSquare(side, xside___0, ply, u);
#line 1372
        u = (short )((int )u + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1378
  if (use_history) {
#line 1380
    *(history + hiHt) = (unsigned short )((int )*(history + hiHt) - 5000);
#line 1381
    *(history + hi0) = (unsigned short )((int )*(history + hi0) - 2000);
#line 1382
    *(history + hi1) = (unsigned short )((int )*(history + hi1) - 60);
#line 1383
    *(history + hi2) = (unsigned short )((int )*(history + hi2) - 50);
#line 1384
    *(history + hi3) = (unsigned short )((int )*(history + hi3) - 40);
#line 1385
    *(history + hi4) = (unsigned short )((int )*(history + hi4) - 30);
  }
#line 1389
  SwagHt = (unsigned short)0;
#line 1391
  if (flag.tsume) {
#line 1391
    if ((unsigned long )node == (unsigned long )firstnode) {
#line 1392
      *TrP = (short )((int )*TrP + 1);
    }
  }
#line 1394
  num = (short )((int )TrPnt[(int )ply + 1] - (int )TrPnt[ply]);
#line 1394
  GenCnt += (long )num;
#line 1405
  flag.tsume = flag_tsume;
#line 1406
  return;
}
}
#line 1422 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
void CaptureList(short side , short ply , short in_check , short blockable ) 
{ 
  short u ;
  short sq ;
  short xside___0 ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short i___0 ;
  short piece ;
  short flag_tsume ;
  signed char *PL ;
  int tmp ;
  short ptyp ;
  short PP ;
  int tmp___0 ;

  {
#line 1435
  xside___0 = (short )((int )side ^ 1);
#line 1437
  TrP = & TrPnt[(int )ply + 1];
#line 1438
  *TrP = TrPnt[ply];
#line 1439
  node = Tree + *TrP;
#line 1441
  flag_tsume = flag.tsume;
#line 1443
  sqking = (short )PieceList[side][0];
#line 1444
  sqxking = (short )PieceList[xside___0][0];
#line 1446
  if ((int )in_check >= 0) {
#line 1448
    InCheck = in_check;
  } else
#line 1452
  if ((int )board[sqking] == 14) {
    {
#line 1452
    tmp = SqAttacked(sqking, xside___0, & blockable);
#line 1452
    InCheck = (short )tmp;
    }
  } else {
#line 1452
    InCheck = (short)0;
  }
#line 1457
  GenerateAllMoves = (short )((int )in_check == -2);
#line 1459
  if (InCheck) {
#line 1459
    if ((int )ply > 1) {
#line 1462
      flag.tsume = (short)1;
    } else
#line 1459
    if ((int )side == (int )computer) {
#line 1462
      flag.tsume = (short)1;
    }
  }
#line 1465
  check_determined = (short)0;
#line 1467
  PL = PieceList[side];
#line 1469
  i___0 = (short)0;
  {
#line 1469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1469
    if (! ((int )i___0 <= (int )PieceCnt[side])) {
#line 1469
      goto while_break;
    }
#line 1472
    sq = (short )*(PL + i___0);
#line 1473
    piece = (short )board[sq];
#line 1474
    ptyp = (short )ptype[side][piece];
#line 1478
    ppos = (*(nextpos[ptyp]))[sq];
#line 1479
    pdir = (*(nextdir[ptyp]))[sq];
#line 1480
    u = (short )*(ppos + sq);
    {
#line 1482
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1484
      if ((int )color[u] == 2) {
#line 1489
        u = (short )*(ppos + u);
      } else {
#line 1494
        if ((int )color[u] == (int )xside___0) {
#line 1494
          if ((int )board[u] != 14) {
            {
#line 1498
            tmp___0 = PromotionPossible((short )color[sq], sq, u, piece);
#line 1498
            PP = (short )tmp___0;
            }
#line 1498
            if (PP) {
              {
#line 1500
              Link(side, piece, sq, u, (unsigned short)528, (short )(((int )(*value)[stage][board[u]] + (int )svalue[board[u]]) - (int )relative_value[piece]));
              }
            }
#line 1509
            if (! PP) {
              {
#line 1511
              Link(side, piece, sq, u, (unsigned short)512, (short )(((int )(*value)[stage][board[u]] + (int )svalue[board[u]]) - (int )relative_value[piece]));
              }
            } else
#line 1509
            if (flag.tsume) {
              {
#line 1511
              Link(side, piece, sq, u, (unsigned short)512, (short )(((int )(*value)[stage][board[u]] + (int )svalue[board[u]]) - (int )relative_value[piece]));
              }
            }
          }
        }
#line 1524
        u = (short )*(pdir + u);
      }
#line 1482
      if (! ((int )u != (int )sq)) {
#line 1482
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1469
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1531
  flag.tsume = flag_tsume;
#line 1533
  SwagHt = (unsigned short)0;
#line 1534
  return;
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/genmove.c"
short IsCheckmate(short side , short in_check , short blockable ) 
{ 
  short u ;
  short sq ;
  short xside___0 ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short i___0 ;
  short piece ;
  signed char *PL ;
  short tempb___2 ;
  short tempc___2 ;
  short ksq ;
  short threat ;
  short dummy ;
  short sqking___0 ;
  short InCheck___0 ;
  int tmp ;
  short ptyp ;
  int tmp___0 ;
  short f ;
  int tmp___1 ;
  short tmp___2 ;

  {
#line 1564
  xside___0 = (short )((int )side ^ 1);
#line 1566
  sqking___0 = (short )PieceList[side][0];
#line 1572
  if ((int )in_check >= 0) {
#line 1573
    InCheck___0 = in_check;
  } else
#line 1574
  if ((int )board[sqking___0] == 14) {
    {
#line 1575
    tmp = SqAttacked(sqking___0, xside___0, & blockable);
#line 1575
    InCheck___0 = (short )tmp;
    }
  } else {
#line 1577
    InCheck___0 = (short)0;
  }
#line 1579
  if (! InCheck___0) {
#line 1580
    return ((short)0);
  }
#line 1586
  PL = PieceList[side];
#line 1588
  i___0 = (short)0;
  {
#line 1588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1588
    if (! ((int )i___0 <= (int )PieceCnt[side])) {
#line 1588
      goto while_break;
    }
#line 1591
    sq = (short )*(PL + i___0);
#line 1592
    piece = (short )board[sq];
#line 1593
    ptyp = (short )ptype[side][piece];
#line 1597
    ppos = (*(nextpos[ptyp]))[sq];
#line 1598
    pdir = (*(nextdir[ptyp]))[sq];
#line 1599
    u = (short )*(ppos + sq);
    {
#line 1601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1603
      if ((int )color[u] == 2) {
#line 1603
        goto _L;
      } else
#line 1603
      if ((int )color[u] == (int )xside___0) {
        _L: /* CIL Label */ 
        {
#line 1605
        GenMakeMove(side, sq, u, & tempb___2, & tempc___2, (short)0);
        }
#line 1606
        if ((int )sq == (int )sqking___0) {
#line 1606
          ksq = u;
        } else {
#line 1606
          ksq = sqking___0;
        }
        {
#line 1607
        tmp___0 = SqAttacked(ksq, xside___0, & dummy);
#line 1607
        threat = (short )tmp___0;
#line 1608
        GenUnmakeMove(side, sq, u, tempb___2, tempc___2, (short)0);
        }
#line 1610
        if (! threat) {
#line 1611
          return ((short)0);
        }
      }
#line 1619
      if ((int )color[u] == 2) {
#line 1619
        u = (short )*(ppos + u);
      } else {
#line 1619
        u = (short )*(pdir + u);
      }
#line 1601
      if (! ((int )u != (int )sq)) {
#line 1601
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1588
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1630
  if ((int )blockable != 0) {
#line 1632
    piece = (short)13;
    {
#line 1632
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1632
      if (! ((int )piece >= 1)) {
#line 1632
        goto while_break___1;
      }
#line 1634
      if (Captured[side][piece]) {
#line 1636
        u = (short)0;
        {
#line 1636
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1636
          if (! ((int )u < 81)) {
#line 1636
            goto while_break___2;
          }
          {
#line 1638
          tmp___2 = DropPossible(piece, side, u);
          }
#line 1638
          if (tmp___2) {
#line 1641
            f = (short )(81 + (int )piece);
#line 1643
            if ((int )side == 1) {
#line 1644
              f = (short )((int )f + 15);
            }
            {
#line 1646
            GenMakeMove(side, f, u, & tempb___2, & tempc___2, (short)0);
#line 1647
            tmp___1 = SqAttacked(sqking___0, xside___0, & dummy);
#line 1647
            threat = (short )tmp___1;
#line 1648
            GenUnmakeMove(side, f, u, tempb___2, tempc___2, (short)0);
            }
#line 1650
            if (! threat) {
#line 1651
              return ((short)0);
            }
          }
#line 1636
          u = (short )((int )u + 1);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1661
        if ((int )piece >= 4) {
#line 1662
          goto while_break___1;
        }
      }
#line 1632
      piece = (short )((int )piece - 1);
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1667
  return ((short)1);
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
unsigned int TTadd ;
#line 781
signed char diagonal(short d ) ;
#line 915
void Initialize_dist(void) ;
#line 972
void ZeroTTable(void) ;
#line 1002
void Initialize_moves(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
short hard_time_limit  =    (short)1;
#line 53 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
short barebones  =    (short)0;
#line 58 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
short nolist  =    (short)1;
#line 66 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
display_t display_type  =    (display_t )2;
#line 78 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
signed char const   sweep[15]  = 
#line 78
  {      (signed char const   )0,      (signed char const   )0,      (signed char const   )1,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )0};
#line 100 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
short distance(short a , short b ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 103
  if (use_distdata) {
#line 103
    tmp___6 = (int )((short )(*distdata)[(int )a][(int )b]);
  } else {
    {
#line 103
    tmp___4 = abs((int )a % 9 - (int )b % 9);
#line 103
    tmp___5 = abs((int )a / 9 - (int )b / 9);
    }
#line 103
    if (tmp___4 > tmp___5) {
      {
#line 103
      tmp___1 = abs((int )a % 9 - (int )b % 9);
#line 103
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 103
      tmp___2 = abs((int )a / 9 - (int )b / 9);
#line 103
      tmp___3 = tmp___2;
      }
    }
#line 103
    tmp___6 = (int )((short )tmp___3);
  }
#line 103
  return ((short )tmp___6);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
void Initialize_dist(void) 
{ 
  short a ;
  short b ;
  short d ;
  short di ;
  short ptyp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  short tmp___2 ;

  {
#line 115
  a = (short)0;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((int )a < 81)) {
#line 115
      goto while_break;
    }
#line 117
    b = (short)0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! ((int )b < 81)) {
#line 117
        goto while_break___0;
      }
      {
#line 119
      tmp = abs((int )a % 9 - (int )b % 9);
#line 119
      d = (short )tmp;
#line 120
      tmp___0 = abs((int )a / 9 - (int )b / 9);
#line 120
      di = (short )tmp___0;
      }
#line 121
      if ((int )d > (int )di) {
#line 121
        tmp___1 = (int )d;
      } else {
#line 121
        tmp___1 = (int )di;
      }
#line 121
      (*distdata)[a][b] = (signed char )tmp___1;
#line 117
      b = (short )((int )b + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    a = (short )((int )a + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  ptyp = (short)0;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! ((int )ptyp < 15)) {
#line 126
      goto while_break___1;
    }
#line 128
    a = (short)0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! ((int )a < 81)) {
#line 128
        goto while_break___2;
      }
#line 129
      b = (short)0;
      {
#line 129
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 129
        if (! ((int )b < 81)) {
#line 129
          goto while_break___3;
        }
        {
#line 130
        tmp___2 = ptype_distance(ptyp, a, b);
#line 130
        (*(ptype_distdata[ptyp]))[a][b] = (signed char )tmp___2;
#line 129
        b = (short )((int )b + 1);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 128
      a = (short )((int )a + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 126
    ptyp = (short )((int )ptyp + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
signed char const   is_promoted[15]  = 
#line 161
  {      (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )0};
#line 179 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
static signed char const   direc[15][8]  = 
#line 179
  { {        (signed char const   )11,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )11,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )21,        (signed char const   )23,        (signed char const   )0,        (signed char const   )0, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )10,        (signed char const   )11,        (signed char const   )12,        (signed char const   )-12, 
            (signed char const   )-10,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )10,        (signed char const   )11,        (signed char const   )12,        (signed char const   )-1, 
            (signed char const   )1,        (signed char const   )-11,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )10,        (signed char const   )12,        (signed char const   )-12,        (signed char const   )-10, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )11,        (signed char const   )-1,        (signed char const   )1,        (signed char const   )-11, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )10,        (signed char const   )12,        (signed char const   )-12,        (signed char const   )-10, 
            (signed char const   )11,        (signed char const   )-1,        (signed char const   )1,        (signed char const   )-11}, 
   {        (signed char const   )11,        (signed char const   )-1,        (signed char const   )1,        (signed char const   )-11, 
            (signed char const   )10,        (signed char const   )12,        (signed char const   )-12,        (signed char const   )-10}, 
   {        (signed char const   )10,        (signed char const   )11,        (signed char const   )12,        (signed char const   )-1, 
            (signed char const   )1,        (signed char const   )-12,        (signed char const   )-11,        (signed char const   )-10}, 
   {        (signed char const   )-11,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )-11,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )-21,        (signed char const   )-23,        (signed char const   )0,        (signed char const   )0, 
            (signed char const   )0,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )-10,        (signed char const   )-11,        (signed char const   )-12,        (signed char const   )12, 
            (signed char const   )10,        (signed char const   )0,        (signed char const   )0,        (signed char const   )0}, 
   {        (signed char const   )-10,        (signed char const   )-11,        (signed char const   )-12,        (signed char const   )1, 
            (signed char const   )-1,        (signed char const   )11,        (signed char const   )0,        (signed char const   )0}};
#line 220 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
signed char diagonal(short d ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 222
  tmp = abs((int )d);
  }
#line 222
  if (tmp == 10) {
#line 222
    tmp___1 = 1;
  } else {
    {
#line 222
    tmp___0 = abs((int )d);
    }
#line 222
    if (tmp___0 == 12) {
#line 222
      tmp___1 = 1;
    } else {
#line 222
      tmp___1 = 0;
    }
  }
#line 222
  return ((signed char )tmp___1);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
static signed char const   max_steps[15]  = 
#line 228
  {      (signed char const   )1,      (signed char const   )8,      (signed char const   )1,      (signed char const   )1, 
        (signed char const   )1,      (signed char const   )8,      (signed char const   )8,      (signed char const   )8, 
        (signed char const   )8,      (signed char const   )1,      (signed char const   )1,      (signed char const   )8, 
        (signed char const   )1,      (signed char const   )1,      (signed char const   )1};
#line 240 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
signed char const   nunmap[143]  = 
#line 240
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )0, 
        (signed char const   )1,      (signed char const   )2,      (signed char const   )3,      (signed char const   )4, 
        (signed char const   )5,      (signed char const   )6,      (signed char const   )7,      (signed char const   )8, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )18,      (signed char const   )19,      (signed char const   )20, 
        (signed char const   )21,      (signed char const   )22,      (signed char const   )23,      (signed char const   )24, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )27,      (signed char const   )28,      (signed char const   )29,      (signed char const   )30, 
        (signed char const   )31,      (signed char const   )32,      (signed char const   )33,      (signed char const   )34, 
        (signed char const   )35,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )45,      (signed char const   )46, 
        (signed char const   )47,      (signed char const   )48,      (signed char const   )49,      (signed char const   )50, 
        (signed char const   )51,      (signed char const   )52,      (signed char const   )53,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )54,      (signed char const   )55,      (signed char const   )56, 
        (signed char const   )57,      (signed char const   )58,      (signed char const   )59,      (signed char const   )60, 
        (signed char const   )61,      (signed char const   )62,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )63,      (signed char const   )64,      (signed char const   )65,      (signed char const   )66, 
        (signed char const   )67,      (signed char const   )68,      (signed char const   )69,      (signed char const   )70, 
        (signed char const   )71,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )72, 
        (signed char const   )73,      (signed char const   )74,      (signed char const   )75,      (signed char const   )76, 
        (signed char const   )77,      (signed char const   )78,      (signed char const   )79,      (signed char const   )80, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 258 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
signed char const   inunmap[81]  = 
#line 258
  {      (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )26, 
        (signed char const   )27,      (signed char const   )28,      (signed char const   )29,      (signed char const   )30, 
        (signed char const   )31,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )45,      (signed char const   )46, 
        (signed char const   )47,      (signed char const   )48,      (signed char const   )49,      (signed char const   )50, 
        (signed char const   )51,      (signed char const   )52,      (signed char const   )53,      (signed char const   )56, 
        (signed char const   )57,      (signed char const   )58,      (signed char const   )59,      (signed char const   )60, 
        (signed char const   )61,      (signed char const   )62,      (signed char const   )63,      (signed char const   )64, 
        (signed char const   )67,      (signed char const   )68,      (signed char const   )69,      (signed char const   )70, 
        (signed char const   )71,      (signed char const   )72,      (signed char const   )73,      (signed char const   )74, 
        (signed char const   )75,      (signed char const   )78,      (signed char const   )79,      (signed char const   )80, 
        (signed char const   )81,      (signed char const   )82,      (signed char const   )83,      (signed char const   )84, 
        (signed char const   )85,      (signed char const   )86,      (signed char const   )89,      (signed char const   )90, 
        (signed char const   )91,      (signed char const   )92,      (signed char const   )93,      (signed char const   )94, 
        (signed char const   )95,      (signed char const   )96,      (signed char const   )97,      (signed char const   )100, 
        (signed char const   )101,      (signed char const   )102,      (signed char const   )103,      (signed char const   )104, 
        (signed char const   )105,      (signed char const   )106,      (signed char const   )107,      (signed char const   )108, 
        (signed char const   )111,      (signed char const   )112,      (signed char const   )113,      (signed char const   )114, 
        (signed char const   )115,      (signed char const   )116,      (signed char const   )117,      (signed char const   )118, 
        (signed char const   )119};
#line 293 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
int InitFlag  =    0;
#line 355 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
void Initialize_moves(void) 
{ 
  short ptyp ;
  short po ;
  short p0 ;
  short d ;
  short di ;
  short s ;
  short delta ;
  unsigned char *ppos ;
  unsigned char *pdir ;
  short dest[8][9] ;
  short sorted[9] ;
  short steps[8] ;
  short fpo ;
  short tpo ;
  signed char tmp ;
  signed char tmp___0 ;

  {
#line 363
  fpo = (short )inunmap[0];
#line 363
  tpo = (short )(1 + (int )inunmap[80]);
#line 368
  ptyp = (short)0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((int )ptyp < 15)) {
#line 368
      goto while_break;
    }
#line 370
    po = (short)0;
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 370
      if (! ((int )po < 81)) {
#line 370
        goto while_break___0;
      }
#line 372
      p0 = (short)0;
      {
#line 372
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 372
        if (! ((int )p0 < 81)) {
#line 372
          goto while_break___1;
        }
#line 374
        (*(nextpos[ptyp]))[po][p0] = (unsigned char )po;
#line 375
        (*(nextdir[ptyp]))[po][p0] = (unsigned char )po;
#line 372
        p0 = (short )((int )p0 + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 370
      po = (short )((int )po + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 368
    ptyp = (short )((int )ptyp + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  ptyp = (short)0;
  {
#line 380
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 380
    if (! ((int )ptyp < 15)) {
#line 380
      goto while_break___2;
    }
#line 382
    po = fpo;
    {
#line 382
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 382
      if (! ((int )po < (int )tpo)) {
#line 382
        goto while_break___3;
      }
#line 384
      if ((int const   )nunmap[po] >= 0) {
#line 386
        ppos = (*(nextpos[ptyp]))[nunmap[po]];
#line 387
        pdir = (*(nextdir[ptyp]))[nunmap[po]];
#line 390
        d = (short)0;
        {
#line 390
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 390
          if (! ((int )d < 8)) {
#line 390
            goto while_break___4;
          }
#line 392
          dest[d][0] = (short )nunmap[po];
#line 393
          delta = (short )direc[ptyp][d];
#line 395
          if ((int )delta != 0) {
#line 397
            p0 = po;
#line 399
            s = (short)0;
            {
#line 399
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 399
              if (! ((int )s < (int )max_steps[ptyp])) {
#line 399
                goto while_break___5;
              }
#line 401
              p0 = (short )((int )p0 + (int )delta);
#line 409
              if ((int const   )nunmap[p0] < 0) {
#line 416
                goto while_break___5;
              } else
#line 409
              if ((int )ptyp == 8) {
#line 409
                if ((int )s > 0) {
                  {
#line 409
                  tmp = diagonal(delta);
                  }
#line 409
                  if (tmp) {
#line 416
                    goto while_break___5;
                  } else {
#line 409
                    goto _L___0;
                  }
                } else {
#line 409
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 409
              if ((int )ptyp == 7) {
#line 409
                if ((int )s > 0) {
                  {
#line 409
                  tmp___0 = diagonal(delta);
                  }
#line 409
                  if (tmp___0) {
#line 418
                    dest[d][s] = (short )nunmap[p0];
                  } else {
#line 416
                    goto while_break___5;
                  }
                } else {
#line 418
                  dest[d][s] = (short )nunmap[p0];
                }
              } else {
#line 418
                dest[d][s] = (short )nunmap[p0];
              }
#line 399
              s = (short )((int )s + 1);
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 423
            s = (short)0;
          }
#line 432
          steps[d] = s;
#line 434
          di = d;
          {
#line 434
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 434
            if ((int )s > 0) {
#line 434
              if (! ((int )di > 0)) {
#line 434
                goto while_break___6;
              }
            } else {
#line 434
              goto while_break___6;
            }
#line 436
            if ((int )steps[sorted[(int )di - 1]] == 0) {
#line 437
              sorted[di] = sorted[(int )di - 1];
            } else {
#line 439
              goto while_break___6;
            }
#line 434
            di = (short )((int )di - 1);
          }
          while_break___6: /* CIL Label */ ;
          }
#line 442
          sorted[di] = d;
#line 390
          d = (short )((int )d + 1);
        }
        while_break___4: /* CIL Label */ ;
        }
#line 449
        p0 = (short )nunmap[po];
#line 450
        *(pdir + p0) = (unsigned char )dest[sorted[0]][0];
#line 452
        d = (short)0;
        {
#line 452
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 452
          if (! ((int )d < 8)) {
#line 452
            goto while_break___7;
          }
#line 454
          s = (short)0;
          {
#line 454
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 454
            if (! ((int )s < (int )steps[sorted[d]])) {
#line 454
              goto while_break___8;
            }
#line 456
            *(ppos + p0) = (unsigned char )dest[sorted[d]][s];
#line 457
            p0 = dest[sorted[d]][s];
#line 459
            if ((int )d < 7) {
#line 460
              *(pdir + p0) = (unsigned char )dest[sorted[(int )d + 1]][0];
            }
#line 454
            s = (short )((int )s + 1);
          }
          while_break___8: /* CIL Label */ ;
          }
#line 452
          d = (short )((int )d + 1);
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 382
      po = (short )((int )po + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 380
    ptyp = (short )((int )ptyp + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
void NewGame(void) 
{ 
  short l ;
  short c ;
  short p ;
  short max_opening_sequence ;
  struct timeval tv ;
  unsigned char tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  char sx[256] ;

  {
#line 487
  oppptr = 0;
#line 487
  compptr = oppptr;
#line 488
  stage = (short)0;
#line 489
  stage2 = (short)-1;
#line 490
  flag.force = (short)0;
#line 490
  flag.onemove = flag.force;
#line 490
  flag.bothsides = flag.onemove;
#line 490
  flag.reverse = flag.bothsides;
#line 490
  flag.quit = flag.reverse;
#line 490
  flag.post = flag.quit;
#line 490
  flag.mate = flag.post;
#line 490
  flag.illegal = flag.mate;
#line 493
  flag.rcptr = (short)1;
#line 493
  flag.beep = flag.rcptr;
#line 493
  flag.easy = flag.beep;
#line 493
  flag.hash = flag.easy;
#line 493
  flag.coords = flag.hash;
#line 493
  flag.material = flag.coords;
#line 496
  flag.musttimeout = (short)0;
#line 496
  flag.back = flag.musttimeout;
#line 496
  flag.shade = flag.back;
#line 496
  flag.stars = flag.shade;
#line 497
  flag.gamein = (short)0;
#line 498
  flag.rv = (short)1;
#line 500
  mycnt2 = 0;
#line 500
  mycnt1 = mycnt2;
#line 501
  XCmore = (short)0;
#line 501
  dither = XCmore;
#line 501
  et0 = (long )dither;
#line 501
  NodeCnt = et0;
#line 501
  GenCnt = NodeCnt;
#line 502
  if (flag.tsume) {
#line 502
    znodes = 400L;
  } else {
#line 502
    znodes = 1000L;
  }
#line 503
  WAwindow = (short)90;
#line 504
  WBwindow = (short)90;
#line 505
  BAwindow = (short)90;
#line 506
  BBwindow = (short)90;
#line 507
  xwndw = (short)90;
#line 509
  if (! MaxSearchDepth) {
#line 510
    MaxSearchDepth = (short)39;
  }
  {
#line 512
  contempt = (short)0;
#line 513
  GameCnt = (short)0;
#line 514
  Game50 = (short)1;
#line 515
  TesujiFlag[0] = (signed char)0;
#line 515
  CptrFlag[0] = TesujiFlag[0];
#line 516
  hint = (unsigned short)5149;
#line 517
  ZeroRPT();
#line 518
  GameType[1] = (char )'U';
#line 518
  GameType[0] = GameType[1];
#line 519
  Tscore[0] = (short)15000;
#line 519
  Pscore[0] = Tscore[0];
#line 520
  player = (short)0;
#line 520
  opponent = player;
#line 521
  computer = (short)1;
#line 523
  l = (short)0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! ((int )l < 4000)) {
#line 523
      goto while_break;
    }
#line 524
    tmp = (unsigned char)0;
#line 524
    (Tree + l)->t = tmp;
#line 524
    (Tree + l)->f = tmp;
#line 523
    l = (short )((int )l + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 526
  gsrand(1U);
  }
#line 528
  if (! InitFlag) {
#line 530
    c = (short)0;
    {
#line 530
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 530
      if (! ((int )c <= 1)) {
#line 530
        goto while_break___0;
      }
#line 532
      p = (short)1;
      {
#line 532
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 532
        if (! ((int )p <= 14)) {
#line 532
          goto while_break___1;
        }
#line 534
        l = (short)0;
        {
#line 534
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 534
          if (! ((int )l < 81)) {
#line 534
            goto while_break___2;
          }
          {
#line 536
          tmp___0 = urand();
#line 536
          (*hashcode)[c][p][l].key = (unsigned long )tmp___0;
#line 538
          tmp___1 = urand();
#line 538
          (*hashcode)[c][p][l].key += (unsigned long )tmp___1 << 16;
#line 540
          tmp___2 = urand();
#line 540
          (*hashcode)[c][p][l].bd = (unsigned long )tmp___2;
#line 542
          tmp___3 = urand();
#line 542
          (*hashcode)[c][p][l].bd += (unsigned long )tmp___3 << 16;
#line 545
          tmp___4 = urand();
#line 545
          (*hashcode)[c][p][l].key += (unsigned long )tmp___4 << 32;
#line 547
          tmp___5 = urand();
#line 547
          (*hashcode)[c][p][l].key += (unsigned long )tmp___5 << 48;
#line 549
          tmp___6 = urand();
#line 549
          (*hashcode)[c][p][l].bd += (unsigned long )tmp___6 << 32;
#line 551
          tmp___7 = urand();
#line 551
          (*hashcode)[c][p][l].bd += (unsigned long )tmp___7 << 48;
#line 534
          l = (short )((int )l + 1);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 532
        p = (short )((int )p + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 530
      c = (short )((int )c + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 558
    c = (short)0;
    {
#line 558
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 558
      if (! ((int )c <= 1)) {
#line 558
        goto while_break___3;
      }
#line 560
      p = (short)1;
      {
#line 560
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 560
        if (! ((int )p <= 14)) {
#line 560
          goto while_break___4;
        }
#line 562
        l = (short)0;
        {
#line 562
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 562
          if (! ((int )l < 19)) {
#line 562
            goto while_break___5;
          }
          {
#line 564
          tmp___8 = urand();
#line 564
          (*drop_hashcode)[c][p][l].key = (unsigned long )tmp___8;
#line 566
          tmp___9 = urand();
#line 566
          (*drop_hashcode)[c][p][l].key += (unsigned long )tmp___9 << 16;
#line 568
          tmp___10 = urand();
#line 568
          (*drop_hashcode)[c][p][l].bd = (unsigned long )tmp___10;
#line 570
          tmp___11 = urand();
#line 570
          (*drop_hashcode)[c][p][l].bd += (unsigned long )tmp___11 << 16;
#line 573
          tmp___12 = urand();
#line 573
          (*drop_hashcode)[c][p][l].key += (unsigned long )tmp___12 << 32;
#line 575
          tmp___13 = urand();
#line 575
          (*drop_hashcode)[c][p][l].key += (unsigned long )tmp___13 << 48;
#line 577
          tmp___14 = urand();
#line 577
          (*drop_hashcode)[c][p][l].bd += (unsigned long )tmp___14 << 32;
#line 579
          tmp___15 = urand();
#line 579
          (*drop_hashcode)[c][p][l].bd += (unsigned long )tmp___15 << 48;
#line 562
          l = (short )((int )l + 1);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 560
        p = (short )((int )p + 1);
      }
      while_break___4: /* CIL Label */ ;
      }
#line 558
      c = (short )((int )c + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 587
  l = (short)0;
  {
#line 587
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 587
    if (! ((int )l < 81)) {
#line 587
      goto while_break___6;
    }
#line 589
    board[l] = (signed char )Stboard[l];
#line 590
    color[l] = (signed char )Stcolor[l];
#line 591
    Mvboard[l] = (signed char)0;
#line 587
    l = (short )((int )l + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 594
  memset((void *)((char *)(Captured)), 0, sizeof(Captured));
#line 595
  ClearScreen();
#line 596
  InitializeStats();
#line 599
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 600
  time0 = tv.tv_sec * 100L + tv.tv_usec / 10000L;
#line 606
  ElapsedTime((ElapsedTime_mode )1);
#line 607
  flag.regularstart = (short)1;
#line 608
  Book = 20;
  }
#line 610
  if (! InitFlag) {
    {
#line 613
    strcpy((char */* __restrict  */)(sx), (char const   */* __restrict  */)"level");
    }
#line 615
    if (TCflag) {
      {
#line 616
      SetTimeControl();
      }
    } else
#line 617
    if (MaxResponseTime == 0L) {
      {
#line 618
      SelectLevel(sx);
      }
    }
    {
#line 620
    UpdateDisplay((short)0, (short)0, (short)1, (short)0);
#line 621
    GetOpenings();
#line 622
    GetOpeningPatterns(& max_opening_sequence);
#line 624
    InitFlag = 1;
    }
  }
#line 628
  if (TTadd) {
    {
#line 630
    ZeroTTable();
#line 631
    TTadd = 0U;
    }
  }
#line 635
  hashkey = 0UL;
#line 635
  hashbd = hashkey;
#line 636
  return;
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
int InitMain(void) 
{ 
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 645
  tmp = time((long *)0);
#line 645
  starttime = (unsigned int )tmp;
#line 645
  gsrand(starttime);
#line 648
  ttblsize = 100001U;
#line 649
  rehash = (short)-1;
#line 652
  tmp___0 = Initialize_data();
  }
#line 652
  if (tmp___0 != 0) {
#line 653
    return (1);
  }
  {
#line 655
  strcpy((char */* __restrict  */)(ColorStr[0]), (char const   */* __restrict  */)"Black");
#line 656
  strcpy((char */* __restrict  */)(ColorStr[1]), (char const   */* __restrict  */)"White");
#line 658
  XC = (short)0;
#line 659
  MaxResponseTime = 0L;
  }
#line 661
  if ((unsigned int )display_type == 2U) {
#line 663
    TCmoves = (short)40;
#line 664
    TCminutes = (short)5;
#line 665
    TCseconds = (short)0;
#line 666
    TCadd = 0;
#line 668
    TCflag = (short)1;
#line 669
    OperatorTime = (short)0;
#line 670
    barebones = (short)1;
  } else {
#line 674
    TCflag = (short)0;
#line 675
    OperatorTime = (short)0;
#line 676
    barebones = (short)0;
  }
  {
#line 679
  Initialize();
#line 680
  Initialize_dist();
#line 681
  Initialize_eval();
#line 683
  Initialize_moves();
#line 686
  NewGame();
#line 688
  flag.easy = ahead;
#line 689
  flag.hash = hash;
  }
#line 691
  if (xwin) {
    {
#line 692
    tmp___1 = atoi((char const   *)xwin);
#line 692
    xwndw = (short )tmp___1;
    }
  }
  {
#line 695
  hashfile = (FILE *)((void *)0);
#line 700
  hashfile = fopen((char const   */* __restrict  */)"/usr/local/lib/gnushogi/gnushogi.hsh",
                   (char const   */* __restrict  */)"r+");
  }
#line 702
  if (hashfile) {
    {
#line 704
    fseek(hashfile, 0L, 2);
#line 705
    tmp___2 = ftell(hashfile);
#line 705
    filesz = (long )(((unsigned long )tmp___2 / sizeof(struct fileentry ) - 1UL) - 7UL);
#line 706
    hashmask = filesz >> 1;
#line 707
    hashbase = hashmask + 1L;
    }
  }
#line 712
  savefile[0] = (char )'\000';
#line 713
  listfile[0] = (char )'\000';
#line 715
  return (0);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/init.c"
void ExitMain(void) 
{ 


  {
#line 724
  if (hashfile) {
    {
#line 725
    fclose(hashfile);
    }
  }
  {
#line 729
  ExitShogi();
  }
#line 730
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 685 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
char mvstr[4][6]  ;
#line 1102
void skip(void) ;
#line 1103
void skipb(void) ;
#line 1125
int VerifyMove(char *s , VerifyMove_mode iop , unsigned short *mv ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
char *InPtr  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
int InBackground  =    0;
#line 148 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void algbr(short f , short t , short flag___0 ) 
{ 
  short piece ;
  short piece___0 ;

  {
#line 151
  if ((int )f > 81) {
#line 155
    piece = (short )((int )f - 81);
#line 157
    if ((int )f > 96) {
#line 158
      piece = (short )((int )piece - 15);
    }
#line 160
    flag___0 = (short )(32 | (int )piece);
  }
#line 163
  if (((int )t & 128) != 0) {
#line 165
    flag___0 = (short )((int )flag___0 | 16);
#line 166
    t = (short )((int )t & 127);
  }
#line 169
  if ((int )f == (int )t) {
#line 169
    if ((int )f != 0) {
#line 169
      goto _L___1;
    } else
#line 169
    if ((int )t != 0) {
      _L___1: /* CIL Label */ 
#line 171
      if (! barebones) {
        {
#line 172
        Printf("error in algbr: FROM=TO=%d, flag=0x%4x\n", (int )t, (int )flag___0);
        }
      }
#line 175
      mvstr[3][0] = (char )'\000';
#line 175
      mvstr[2][0] = mvstr[3][0];
#line 175
      mvstr[1][0] = mvstr[2][0];
#line 175
      mvstr[0][0] = mvstr[1][0];
    } else {
#line 169
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 177
  if (((int )flag___0 & 32) != 0) {
    {
#line 179
    piece___0 = (short )((int )flag___0 & 15);
#line 181
    mvstr[0][0] = (char )*(" PLNSGBRPLNSBRK " + piece___0);
#line 182
    mvstr[0][1] = (char )'*';
#line 183
    mvstr[0][2] = (char )*("987654321" + (int )t % 9);
#line 184
    mvstr[0][3] = (char )*("ihgfedcba" + (int )t / 9);
#line 185
    mvstr[0][4] = (char )'\000';
#line 186
    strcpy((char */* __restrict  */)(mvstr[1]), (char const   */* __restrict  */)(mvstr[0]));
#line 187
    strcpy((char */* __restrict  */)(mvstr[2]), (char const   */* __restrict  */)(mvstr[0]));
#line 188
    strcpy((char */* __restrict  */)(mvstr[3]), (char const   */* __restrict  */)(mvstr[0]));
    }
  } else
#line 190
  if ((int )f != 0) {
#line 190
    goto _L;
  } else
#line 190
  if ((int )t != 0) {
    _L: /* CIL Label */ 
    {
#line 193
    mvstr[0][0] = (char )*("987654321" + (int )f % 9);
#line 194
    mvstr[0][1] = (char )*("ihgfedcba" + (int )f / 9);
#line 195
    mvstr[0][2] = (char )*("987654321" + (int )t % 9);
#line 196
    mvstr[0][3] = (char )*("ihgfedcba" + (int )t / 9);
#line 197
    mvstr[3][0] = (char )'\000';
#line 197
    mvstr[0][4] = mvstr[3][0];
#line 198
    mvstr[1][0] = (char )*(" PLNSGBRPLNSBRK " + board[f]);
#line 200
    mvstr[2][0] = mvstr[1][0];
#line 201
    mvstr[2][1] = mvstr[0][1];
#line 203
    mvstr[1][1] = mvstr[0][2];
#line 203
    mvstr[2][2] = mvstr[1][1];
#line 204
    mvstr[1][2] = mvstr[0][3];
#line 204
    mvstr[2][3] = mvstr[1][2];
#line 205
    mvstr[1][3] = (char )'\000';
#line 205
    mvstr[2][4] = mvstr[1][3];
#line 206
    strcpy((char */* __restrict  */)(mvstr[3]), (char const   */* __restrict  */)(mvstr[2]));
#line 207
    mvstr[3][1] = mvstr[0][0];
    }
#line 209
    if ((int )flag___0 & 16) {
      {
#line 211
      strcat((char */* __restrict  */)(mvstr[0]), (char const   */* __restrict  */)"+");
#line 212
      strcat((char */* __restrict  */)(mvstr[1]), (char const   */* __restrict  */)"+");
#line 213
      strcat((char */* __restrict  */)(mvstr[2]), (char const   */* __restrict  */)"+");
#line 214
      strcat((char */* __restrict  */)(mvstr[3]), (char const   */* __restrict  */)"+");
      }
    }
  } else {
#line 219
    mvstr[3][0] = (char )'\000';
#line 219
    mvstr[2][0] = mvstr[3][0];
#line 219
    mvstr[1][0] = mvstr[2][0];
#line 219
    mvstr[0][0] = mvstr[1][0];
  }
#line 221
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static short pnt___1  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static short tempb___1  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static short tempc___1  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static short tempsf___1  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static short tempst___1  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static short cnt___0  ;
#line 234 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static struct leaf xnode___0  ;
#line 230 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
int VerifyMove(char *s , VerifyMove_mode iop , unsigned short *mv ) 
{ 
  struct leaf *node___0 ;
  short i___0 ;
  short l ;
  short local_flags ;
  char buffer___1[60] ;
  size_t tmp ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  short blocked ;
  short tmp___5 ;
  char buf[20] ;
  short tmp___6 ;
  int tmp___7 ;

  {
  {
#line 240
  local_flags = (short)0;
#line 240
  i___0 = local_flags;
#line 240
  tmp = strlen((char const   *)s);
#line 240
  l = (short )tmp;
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((int )i___0 < (int )l)) {
#line 240
      goto while_break;
    }
    {
#line 244
    if ((int )*(s + i___0) == 63) {
#line 244
      goto case_63;
    }
#line 249
    if ((int )*(s + i___0) == 33) {
#line 249
      goto case_33;
    }
#line 242
    goto switch_break;
    case_63: /* CIL Label */ 
#line 245
    local_flags = (short )((int )local_flags | 2048);
#line 246
    *(s + i___0) = (char )'\000';
#line 247
    goto switch_break;
    case_33: /* CIL Label */ 
#line 250
    local_flags = (short )((int )local_flags | 128);
#line 251
    *(s + i___0) = (char )'\000';
#line 252
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 240
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  *mv = (unsigned short)0;
#line 265
  if ((unsigned int )iop == 2U) {
    {
#line 267
    UnmakeMove(opponent, & xnode___0, & tempb___1, & tempc___1, & tempsf___1, & tempst___1);
    }
#line 268
    return (0);
  }
#line 271
  cnt___0 = (short)0;
#line 273
  if ((unsigned int )iop == 0U) {
#line 274
    generate_move_flags = (short)1;
  }
  {
#line 276
  MoveList(opponent, (short)2, (short)-1, (short)1);
#line 277
  generate_move_flags = (short)0;
#line 278
  pnt___1 = TrPnt[2];
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! ((int )pnt___1 < (int )TrPnt[3])) {
#line 280
      goto while_break___0;
    }
    {
#line 282
    tmp___0 = pnt___1;
#line 282
    pnt___1 = (short )((int )pnt___1 + 1);
#line 282
    node___0 = Tree + tmp___0;
#line 283
    algbr((short )node___0->f, (short )node___0->t, (short )node___0->flags);
#line 285
    tmp___1 = strcmp((char const   *)s, (char const   *)(mvstr[0]));
    }
#line 285
    if (tmp___1 == 0) {
#line 290
      cnt___0 = (short )((int )cnt___0 + 1);
#line 291
      xnode___0 = *node___0;
    } else {
      {
#line 285
      tmp___2 = strcmp((char const   *)s, (char const   *)(mvstr[1]));
      }
#line 285
      if (tmp___2 == 0) {
#line 290
        cnt___0 = (short )((int )cnt___0 + 1);
#line 291
        xnode___0 = *node___0;
      } else {
        {
#line 285
        tmp___3 = strcmp((char const   *)s, (char const   *)(mvstr[2]));
        }
#line 285
        if (tmp___3 == 0) {
#line 290
          cnt___0 = (short )((int )cnt___0 + 1);
#line 291
          xnode___0 = *node___0;
        } else {
          {
#line 285
          tmp___4 = strcmp((char const   *)s, (char const   *)(mvstr[3]));
          }
#line 285
          if (tmp___4 == 0) {
#line 290
            cnt___0 = (short )((int )cnt___0 + 1);
#line 291
            xnode___0 = *node___0;
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  if ((int )cnt___0 == 1) {
#line 295
    if ((int )xnode___0.score > -32760) {
      {
#line 299
      MakeMove(opponent, & xnode___0, & tempb___1, & tempc___1, & tempsf___1, & tempst___1,
               & INCscore);
#line 302
      tmp___7 = SqAttacked((short )PieceList[opponent][0], computer, & blocked);
      }
#line 302
      if (tmp___7) {
        {
#line 304
        UnmakeMove(opponent, & xnode___0, & tempb___1, & tempc___1, & tempsf___1,
                   & tempst___1);
#line 305
        AlwaysShowMessage("Illegal move (in check) %s", s);
        }
#line 306
        return (0);
      } else {
#line 310
        if ((unsigned int )iop == 1U) {
#line 311
          return (1);
        }
        {
#line 313
        UpdateDisplay((short )xnode___0.f, (short )xnode___0.t, (short)0, (short )xnode___0.flags);
#line 314
        tmp___5 = (short)0;
#line 314
        (GameList + GameCnt)->score = tmp___5;
#line 314
        (GameList + GameCnt)->depth = tmp___5;
#line 315
        (GameList + GameCnt)->nodes = 0L;
#line 316
        ElapsedTime((ElapsedTime_mode )1);
#line 317
        (GameList + GameCnt)->time = (long )((int )((short )(et + 50L)) / 100);
#line 318
        (GameList + GameCnt)->flags = (short )((int )(GameList + GameCnt)->flags | (int )local_flags);
        }
#line 320
        if (TCflag) {
#line 322
          TimeControl.clock[opponent] -= et;
#line 323
          timeopp[oppptr] = (int )et;
#line 324
          TimeControl.moves[opponent] = (short )((int )TimeControl.moves[opponent] - 1);
        }
        {
#line 327
        *mv = (unsigned short )(((int )xnode___0.f << 8) | (int )xnode___0.t);
#line 328
        algbr((short )xnode___0.f, (short )xnode___0.t, (short)0);
        }
#line 331
        if (flag.force) {
          {
#line 333
          tmp___6 = IsCheckmate((short )((int )opponent ^ 1), (short)-1, (short)-1);
          }
#line 333
          if (tmp___6) {
            {
#line 337
            sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s mates!\n",
                    ColorStr[opponent]);
#line 338
            ShowMessage(buf);
#line 339
            flag.mate = (short)1;
            }
          }
        }
#line 343
        return (1);
      }
    }
  }
  {
#line 347
  AlwaysShowMessage("Illegal move (no match) %s", s);
  }
#line 349
  if (! barebones) {
#line 349
    if ((int )cnt___0 > 1) {
      {
#line 351
      sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"Ambiguous Move %s!",
              s);
#line 352
      ShowMessage(buffer___1);
      }
    }
  }
#line 355
  return (0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
static int parser(char *f , int side , short *fpiece ) 
{ 
  int c1___0 ;
  int r1 ;
  int c2___0 ;
  int r2 ;
  short i___0 ;
  short p ;

  {
#line 364
  p = (short)0;
#line 366
  if ((int )*f == 43) {
#line 367
    f ++;
#line 367
    p = (short)1;
  }
#line 369
  i___0 = (short)1;
#line 369
  *fpiece = (short)0;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((int )i___0 < 15)) {
#line 369
      goto while_break;
    }
#line 371
    if ((int )*(f + 0) == (int )*(" PLNSGBRPLNSBRK " + i___0)) {
#line 371
      goto _L;
    } else
#line 371
    if ((int )*(f + 0) == (int )*(" plnsgbrplnsbrk " + i___0)) {
      _L: /* CIL Label */ 
#line 373
      if (p) {
#line 373
        *fpiece = (short )promoted[i___0];
      } else {
#line 373
        *fpiece = (short )unpromoted[i___0];
      }
#line 374
      goto while_break;
    }
#line 369
    i___0 = (short )((int )i___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  if ((int )*(f + 1) == 42) {
#line 380
    c2___0 = 57 - (int )*(f + 2);
#line 381
    r2 = 105 - (int )*(f + 3);
#line 383
    return (((81 + (int )*fpiece) << 8) | (r2 * 9 + c2___0));
  } else
#line 378
  if ((int )*(f + 1) == 39) {
#line 380
    c2___0 = 57 - (int )*(f + 2);
#line 381
    r2 = 105 - (int )*(f + 3);
#line 383
    return (((81 + (int )*fpiece) << 8) | (r2 * 9 + c2___0));
  } else {
#line 387
    c1___0 = 57 - (int )*(f + 1);
#line 388
    r1 = 105 - (int )*(f + 2);
#line 389
    c2___0 = 57 - (int )*(f + 3);
#line 390
    r2 = 105 - (int )*(f + 4);
#line 391
    if ((int )*(f + 5) == 43) {
#line 391
      p = (short)128;
    } else {
#line 391
      p = (short)0;
    }
#line 393
    return ((((r1 * 9 + c1___0) << 8) | (r2 * 9 + c2___0)) | (int )p);
  }
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void skip(void) 
{ 


  {
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! ((int )*InPtr != 32)) {
#line 401
      goto while_break;
    }
#line 402
    InPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 404
    if (! ((int )*InPtr == 32)) {
#line 404
      goto while_break___0;
    }
#line 405
    InPtr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 406
  return;
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void skipb(void) 
{ 


  {
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! ((int )*InPtr == 32)) {
#line 413
      goto while_break;
    }
#line 414
    InPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return;
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void GetGame(void) 
{ 
  FILE *fd ;
  char fname[256] ;
  char *p ;
  int c ;
  int i___0 ;
  int j ;
  short sq ;
  short side ;
  short isp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct GameRec *g___0 ;
  int side___0 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  short i___1 ;
  short piece ;
  char *tmp___18 ;

  {
#line 428
  if (savefile[0]) {
    {
#line 429
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)(savefile));
    }
  } else {
    {
#line 431
    ShowMessage((char *)"Enter file name: ");
#line 432
    RequestInputString(fname, (unsigned int )(sizeof(fname) - 1UL));
    }
  }
#line 435
  if ((int )fname[0] == 0) {
    {
#line 436
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)"shogi.000");
    }
  }
  {
#line 438
  fd = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
  }
#line 438
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 440
    NewGame();
#line 441
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 442
    opponent = (short)0;
#line 442
    computer = opponent;
#line 443
    InPtr = fname;
#line 444
    skip();
    }
#line 446
    if ((int )*InPtr == 99) {
#line 447
      computer = (short)1;
    } else {
#line 449
      opponent = (short)1;
    }
    {
#line 453
    skip();
#line 454
    skip();
#line 455
    skip();
#line 456
    tmp = atoi((char const   *)InPtr);
#line 456
    Game50 = (short )tmp;
#line 457
    skip();
#line 458
    flag.force = (short )((int )*InPtr == 102);
#line 459
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 460
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 461
    InPtr = & fname[11];
#line 462
    skipb();
#line 463
    tmp___0 = atoi((char const   *)InPtr);
#line 463
    TCflag = (short )tmp___0;
#line 464
    skip();
#line 465
    InPtr += 14;
#line 466
    skipb();
#line 467
    tmp___1 = atoi((char const   *)InPtr);
#line 467
    OperatorTime = (short )tmp___1;
#line 468
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 469
    InPtr = & fname[11];
#line 470
    skipb();
#line 471
    TimeControl.clock[0] = atol((char const   *)InPtr);
#line 472
    skip();
#line 473
    skip();
#line 474
    tmp___2 = atoi((char const   *)InPtr);
#line 474
    TimeControl.moves[0] = (short )tmp___2;
#line 475
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 476
    InPtr = & fname[11];
#line 477
    skipb();
#line 478
    TimeControl.clock[1] = atol((char const   *)InPtr);
#line 479
    skip();
#line 480
    skip();
#line 481
    tmp___3 = atoi((char const   *)InPtr);
#line 481
    TimeControl.moves[1] = (short )tmp___3;
#line 482
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 484
    i___0 = 8;
    }
    {
#line 484
    while (1) {
      while_continue: /* CIL Label */ ;
#line 484
      if (! (i___0 > -1)) {
#line 484
        goto while_break;
      }
      {
#line 486
      fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 487
      p = & fname[2];
#line 488
      InPtr = & fname[23];
#line 490
      j = 0;
      }
      {
#line 490
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 490
        if (! (j < 9)) {
#line 490
          goto while_break___0;
        }
#line 492
        sq = (short )(i___0 * 9 + j);
#line 493
        isp = (short )((int )*p == 43);
#line 494
        p ++;
#line 496
        if ((int )*p == 45) {
#line 498
          board[sq] = (signed char)0;
#line 499
          color[sq] = (signed char)2;
        } else {
#line 503
          c = 0;
          {
#line 503
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 503
            if (! (c < 15)) {
#line 503
              goto while_break___1;
            }
#line 505
            if ((int )*p == (int )*(" PLNSGBRPLNSBRK " + c)) {
#line 507
              if (isp) {
#line 508
                board[sq] = (signed char )promoted[c];
              } else {
#line 510
                board[sq] = (signed char )unpromoted[c];
              }
#line 512
              color[sq] = (signed char)1;
            }
#line 503
            c ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 516
          c = 0;
          {
#line 516
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 516
            if (! (c < 15)) {
#line 516
              goto while_break___2;
            }
#line 518
            if ((int )*p == (int )*(" plnsgbrplnsbrk " + c)) {
#line 520
              if (isp) {
#line 521
                board[sq] = (signed char )promoted[c];
              } else {
#line 523
                board[sq] = (signed char )unpromoted[c];
              }
#line 525
              color[sq] = (signed char)0;
            }
#line 516
            c ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 530
        p ++;
#line 531
        tmp___4 = atoi((char const   *)InPtr);
#line 531
        Mvboard[sq] = (signed char )tmp___4;
#line 532
        skip();
#line 490
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 484
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 536
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 537
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 538
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 539
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 540
    memset((void *)((char *)(Captured)), 0, sizeof(Captured));
#line 542
    side = (short)0;
    }
    {
#line 542
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 542
      if (! ((int )side <= 1)) {
#line 542
        goto while_break___3;
      }
      {
#line 544
      fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 545
      InPtr = fname;
#line 546
      skip();
#line 547
      skipb();
#line 548
      tmp___5 = atoi((char const   *)InPtr);
#line 548
      Captured[side][1] = (signed char )tmp___5;
#line 549
      skip();
#line 551
      tmp___6 = atoi((char const   *)InPtr);
#line 551
      Captured[side][2] = (signed char )tmp___6;
#line 552
      skip();
#line 553
      tmp___7 = atoi((char const   *)InPtr);
#line 553
      Captured[side][3] = (signed char )tmp___7;
#line 554
      skip();
#line 556
      tmp___8 = atoi((char const   *)InPtr);
#line 556
      Captured[side][4] = (signed char )tmp___8;
#line 557
      skip();
#line 558
      tmp___9 = atoi((char const   *)InPtr);
#line 558
      Captured[side][5] = (signed char )tmp___9;
#line 559
      skip();
#line 560
      tmp___10 = atoi((char const   *)InPtr);
#line 560
      Captured[side][6] = (signed char )tmp___10;
#line 561
      skip();
#line 562
      tmp___11 = atoi((char const   *)InPtr);
#line 562
      Captured[side][7] = (signed char )tmp___11;
#line 563
      skip();
#line 564
      tmp___12 = atoi((char const   *)InPtr);
#line 564
      Captured[side][14] = (signed char )tmp___12;
#line 542
      side = (short )((int )side + 1);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 567
    GameCnt = (short)0;
#line 568
    flag.regularstart = (short)1;
#line 569
    Book = 20;
#line 570
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 571
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
    }
    {
#line 573
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 573
      tmp___18 = fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
      }
#line 573
      if (! tmp___18) {
#line 573
        goto while_break___4;
      }
      {
#line 576
      side___0 = (int )computer;
#line 578
      side___0 ^= 1;
#line 579
      GameCnt = (short )((int )GameCnt + 1);
#line 580
      InPtr = fname;
#line 581
      skipb();
#line 582
      g___0 = GameList + GameCnt;
#line 583
      tmp___13 = parser(InPtr, side___0, & g___0->fpiece);
#line 583
      g___0->gmove = (unsigned short )tmp___13;
#line 584
      skip();
#line 585
      tmp___14 = atoi((char const   *)InPtr);
#line 585
      g___0->score = (short )tmp___14;
#line 586
      skip();
#line 587
      tmp___15 = atoi((char const   *)InPtr);
#line 587
      g___0->depth = (short )tmp___15;
#line 588
      skip();
#line 589
      g___0->nodes = atol((char const   *)InPtr);
#line 590
      skip();
#line 591
      g___0->time = atol((char const   *)InPtr);
#line 592
      skip();
#line 593
      c = atoi((char const   *)InPtr);
#line 593
      g___0->flags = (short )c;
#line 594
      skip();
#line 595
      tmp___16 = strtol((char const   */* __restrict  */)InPtr, (char **/* __restrict  */)((char **)((void *)0)),
                        16);
#line 595
      g___0->hashkey = (unsigned long )tmp___16;
#line 596
      skip();
#line 597
      tmp___17 = strtol((char const   */* __restrict  */)InPtr, (char **/* __restrict  */)((char **)((void *)0)),
                        16);
#line 597
      g___0->hashbd = (unsigned long )tmp___17;
      }
#line 599
      if (c & 512) {
        {
#line 603
        skip();
#line 605
        piece = (short)0;
#line 605
        i___1 = (short)0;
        }
        {
#line 605
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 605
          if (! ((int )i___1 < 15)) {
#line 605
            goto while_break___5;
          }
#line 607
          if ((int const   )*(" PLNSGBRPLNSBRK " + i___1) == (int const   )*InPtr) {
#line 609
            piece = i___1;
#line 610
            goto while_break___5;
          }
#line 605
          i___1 = (short )((int )i___1 + 1);
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 614
        skip();
        }
#line 615
        if ((int )*InPtr == 87) {
#line 615
          g___0->color = (short)1;
        } else {
#line 615
          g___0->color = (short)0;
        }
        {
#line 616
        skip();
        }
#line 617
        if ((int )*InPtr == 43) {
#line 617
          g___0->piece = (short )promoted[piece];
        } else {
#line 617
          g___0->piece = (short )unpromoted[piece];
        }
      } else {
#line 623
        g___0->color = (short)2;
#line 624
        g___0->piece = (short)0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 628
    if (TimeControl.clock[0] > 0L) {
#line 629
      TCflag = (short)1;
    }
    {
#line 631
    fclose(fd);
    }
  }
  {
#line 634
  ZeroRPT();
#line 635
  InitializeStats();
#line 636
  UpdateDisplay((short)0, (short)0, (short)1, (short)0);
#line 637
  Sdepth = (short)0;
#line 638
  hint = (unsigned short)0;
  }
#line 639
  return;
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void SaveGame(void) 
{ 
  FILE *fd ;
  char fname[256] ;
  short sq ;
  short i___0 ;
  short c ;
  short f ;
  short t ;
  char p ;
  short side ;
  short piece ;
  char empty[2] ;
  char *b ;
  char *w ;
  char const   *tmp ;
  int tmp___0 ;
  struct GameRec *g___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 651
  empty[0] = (char )'\n';
#line 651
  empty[1] = (char )'\000';
#line 653
  if (savefile[0]) {
    {
#line 654
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)(savefile));
    }
  } else {
    {
#line 656
    ShowMessage((char *)"Enter file name: ");
#line 657
    RequestInputString(fname, (unsigned int )(sizeof(fname) - 1UL));
    }
  }
#line 660
  if ((int )fname[0] == 0) {
    {
#line 661
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)"shogi.000");
    }
  }
  {
#line 663
  fd = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"w");
  }
#line 663
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
#line 666
    w = (char *)"Human   ";
#line 666
    b = w;
#line 668
    if ((int )computer == 1) {
#line 669
      w = (char *)"computer";
    }
#line 671
    if ((int )computer == 0) {
#line 672
      b = (char *)"computer";
    }
#line 674
    if (flag.force) {
#line 674
      tmp = "force";
    } else {
#line 674
      tmp = "";
    }
    {
#line 674
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"White %s Black %s %d %s\n",
            w, b, (int )Game50, tmp);
#line 676
    fputs((char const   */* __restrict  */)(empty), (FILE */* __restrict  */)fd);
#line 677
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"TimeControl %d Operator Time %d\n",
            (int )TCflag, (int )OperatorTime);
#line 678
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"Black Clock %ld Moves %d\nWhite Clock %ld Moves %d\n",
            TimeControl.clock[0], (int )TimeControl.moves[0], TimeControl.clock[1],
            (int )TimeControl.moves[1]);
#line 681
    fputs((char const   */* __restrict  */)(empty), (FILE */* __restrict  */)fd);
#line 683
    i___0 = (short)8;
    }
    {
#line 683
    while (1) {
      while_continue: /* CIL Label */ ;
#line 683
      if (! ((int )i___0 > -1)) {
#line 683
        goto while_break;
      }
      {
#line 685
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c ",
              105 - (int )i___0);
#line 687
      c = (short)0;
      }
      {
#line 687
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 687
        if (! ((int )c < 9)) {
#line 687
          goto while_break___0;
        }
#line 689
        sq = (short )((int )i___0 * 9 + (int )c);
#line 690
        piece = (short )board[sq];
#line 691
        if (is_promoted[piece]) {
#line 691
          p = (char )'+';
        } else {
#line 691
          p = (char )' ';
        }
        {
#line 692
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c",
                (int )p);
        }
        {
#line 696
        if ((int )color[sq] == 1) {
#line 696
          goto case_1;
        }
#line 700
        if ((int )color[sq] == 0) {
#line 700
          goto case_0;
        }
#line 704
        goto switch_default;
        case_1: /* CIL Label */ 
#line 697
        p = (char )*(" PLNSGBRPLNSBRK " + piece);
#line 698
        goto switch_break;
        case_0: /* CIL Label */ 
#line 701
        p = (char )*(" plnsgbrplnsbrk " + piece);
#line 702
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 705
        p = (char )'-';
        switch_break: /* CIL Label */ ;
        }
        {
#line 708
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c",
                (int )p);
#line 687
        c = (short )((int )c + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 711
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  ");
#line 713
      f = (short )((int )i___0 * 9);
      }
      {
#line 713
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 713
        if (! ((int )f < (int )i___0 * 9 + 9)) {
#line 713
          goto while_break___1;
        }
        {
#line 714
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %d",
                (int )Mvboard[f]);
#line 713
        f = (short )((int )f + 1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 716
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 683
      i___0 = (short )((int )i___0 - 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 719
    fputs((char const   */* __restrict  */)(empty), (FILE */* __restrict  */)fd);
#line 721
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"   9 8 7 6 5 4 3 2 1\n");
#line 722
    fputs((char const   */* __restrict  */)(empty), (FILE */* __restrict  */)fd);
#line 723
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"   p  l  n  s  g  b  r  k\n");
#line 730
    side = (short)0;
    }
    {
#line 730
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 730
      if (! ((int )side <= 1)) {
#line 730
        goto while_break___2;
      }
#line 732
      if ((int )side == 0) {
#line 732
        tmp___0 = 'B';
      } else {
#line 732
        tmp___0 = 'W';
      }
      {
#line 732
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c",
              tmp___0);
#line 733
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][1]);
#line 735
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][2]);
#line 736
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][3]);
#line 738
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][4]);
#line 739
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][5]);
#line 740
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][6]);
#line 741
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][7]);
#line 742
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" %2d",
              (int )Captured[side][14]);
#line 743
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 730
      side = (short )((int )side + 1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 746
    fputs((char const   */* __restrict  */)(empty), (FILE */* __restrict  */)fd);
#line 747
    fputs((char const   */* __restrict  */)"  move   score depth   nodes   time flags                         capture\n",
          (FILE */* __restrict  */)fd);
#line 749
    i___0 = (short)1;
    }
    {
#line 749
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 749
      if (! ((int )i___0 <= (int )GameCnt)) {
#line 749
        goto while_break___3;
      }
      {
#line 751
      g___0 = GameList + i___0;
#line 753
      f = (short )((int )g___0->gmove >> 8);
#line 754
      t = (short )((int )g___0->gmove & 255);
#line 755
      algbr(f, t, g___0->flags);
      }
#line 757
      if ((int )f > 81) {
#line 757
        tmp___1 = & mvstr[0][1];
      } else {
#line 757
        tmp___1 = mvstr[0];
      }
#line 757
      if ((int )f > 81) {
#line 757
        tmp___3 = ' ';
      } else {
#line 757
        if (is_promoted[g___0->fpiece]) {
#line 757
          tmp___2 = '+';
        } else {
#line 757
          tmp___2 = ' ';
        }
#line 757
        tmp___3 = tmp___2;
      }
      {
#line 757
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c%c%-5s %6d %5d %7ld %6ld %5d  0x%08lx 0x%08lx",
              tmp___3, (int const   )*(" PLNSGBRPLNSBRK " + g___0->fpiece), tmp___1,
              (int )g___0->score, (int )g___0->depth, g___0->nodes, g___0->time, (int )g___0->flags,
              g___0->hashkey, g___0->hashbd);
      }
#line 767
      if ((int )g___0->piece != 0) {
#line 769
        if (is_promoted[g___0->piece]) {
#line 769
          tmp___4 = '+';
        } else {
#line 769
          tmp___4 = ' ';
        }
        {
#line 769
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  %c %s %c\n",
                (int const   )*(" PLNSGBRPLNSBRK " + g___0->piece), ColorStr[g___0->color],
                tmp___4);
        }
      } else {
        {
#line 775
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
        }
      }
#line 749
      i___0 = (short )((int )i___0 + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 779
    fclose(fd);
#line 781
    ShowMessage((char *)"Game saved");
    }
  } else {
    {
#line 785
    ShowMessage((char *)"Could not open file");
    }
  }
#line 787
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void GetXGame(void) 
{ 
  FILE *fd ;
  char fname[256] ;
  char *p ;
  int c ;
  int i___0 ;
  int j ;
  short sq ;
  short side ;
  short isp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 805
  ShowMessage((char *)"Enter file name: ");
#line 806
  RequestInputString(fname, (unsigned int )(sizeof(fname) - 1UL));
  }
#line 808
  if ((int )fname[0] == 0) {
    {
#line 809
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)"xshogi.position.read");
    }
  }
  {
#line 811
  fd = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
  }
#line 811
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 813
    NewGame();
#line 814
    flag.regularstart = (short)0;
#line 815
    Book = 0;
#line 818
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 828
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 830
    fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 832
    i___0 = 8;
    }
    {
#line 832
    while (1) {
      while_continue: /* CIL Label */ ;
#line 832
      if (! (i___0 > -1)) {
#line 832
        goto while_break;
      }
      {
#line 834
      fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 835
      p = fname;
#line 837
      j = 0;
      }
      {
#line 837
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 837
        if (! (j < 9)) {
#line 837
          goto while_break___0;
        }
#line 839
        sq = (short )(i___0 * 9 + j);
#line 840
        isp = (short )((int )*p == 43);
#line 841
        p ++;
#line 843
        if ((int )*p == 46) {
#line 845
          board[sq] = (signed char)0;
#line 846
          color[sq] = (signed char)2;
        } else {
#line 850
          c = 0;
          {
#line 850
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 850
            if (! (c < 15)) {
#line 850
              goto while_break___1;
            }
#line 852
            if ((int )*p == (int )*(" plnsgbrplnsbrk " + c)) {
#line 854
              if (isp) {
#line 855
                board[sq] = (signed char )promoted[c];
              } else {
#line 857
                board[sq] = (signed char )unpromoted[c];
              }
#line 859
              color[sq] = (signed char)1;
            }
#line 850
            c ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 863
          c = 0;
          {
#line 863
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 863
            if (! (c < 15)) {
#line 863
              goto while_break___2;
            }
#line 865
            if ((int )*p == (int )*(" PLNSGBRPLNSBRK " + c)) {
#line 867
              if (isp) {
#line 868
                board[sq] = (signed char )promoted[c];
              } else {
#line 870
                board[sq] = (signed char )unpromoted[c];
              }
#line 872
              color[sq] = (signed char)0;
            }
#line 863
            c ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 877
        p ++;
#line 837
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 832
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 881
    memset((void *)((char *)(Captured)), 0, sizeof(Captured));
#line 883
    side = (short)0;
    }
    {
#line 883
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 883
      if (! ((int )side <= 1)) {
#line 883
        goto while_break___3;
      }
      {
#line 885
      fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
#line 886
      InPtr = fname;
#line 887
      tmp = atoi((char const   *)InPtr);
#line 887
      Captured[side][1] = (signed char )tmp;
#line 888
      skip();
#line 890
      tmp___0 = atoi((char const   *)InPtr);
#line 890
      Captured[side][2] = (signed char )tmp___0;
#line 891
      skip();
#line 892
      tmp___1 = atoi((char const   *)InPtr);
#line 892
      Captured[side][3] = (signed char )tmp___1;
#line 893
      skip();
#line 895
      tmp___2 = atoi((char const   *)InPtr);
#line 895
      Captured[side][4] = (signed char )tmp___2;
#line 896
      skip();
#line 897
      tmp___3 = atoi((char const   *)InPtr);
#line 897
      Captured[side][5] = (signed char )tmp___3;
#line 898
      skip();
#line 899
      tmp___4 = atoi((char const   *)InPtr);
#line 899
      Captured[side][6] = (signed char )tmp___4;
#line 900
      skip();
#line 901
      tmp___5 = atoi((char const   *)InPtr);
#line 901
      Captured[side][7] = (signed char )tmp___5;
#line 902
      skip();
#line 903
      tmp___6 = atoi((char const   *)InPtr);
#line 903
      Captured[side][14] = (signed char )tmp___6;
#line 883
      side = (short )((int )side + 1);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 906
    tmp___7 = fgets((char */* __restrict  */)(fname), 256, (FILE */* __restrict  */)fd);
    }
#line 906
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {
#line 906
      tmp___8 = strncmp((char const   *)(fname), "white", (size_t )5);
      }
#line 906
      if (tmp___8 == 0) {
#line 908
        computer = (short)0;
#line 909
        opponent = (short)1;
#line 910
        xwndw = (short)90;
      }
    }
    {
#line 913
    fclose(fd);
    }
  }
  {
#line 916
  Game50 = (short)1;
#line 917
  ZeroRPT();
#line 918
  InitializeStats();
#line 919
  UpdateDisplay((short)0, (short)0, (short)1, (short)0);
#line 920
  Sdepth = (short)0;
#line 921
  hint = (unsigned short)0;
  }
#line 922
  return;
}
}
#line 925 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void SaveXGame(void) 
{ 
  FILE *fd ;
  char fname[256] ;
  char *p ;
  int i___0 ;
  int j ;
  short sq ;
  short piece ;
  short side ;
  short isp ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 934
  ShowMessage((char *)"Enter file name: ");
#line 935
  RequestInputString(fname, (unsigned int )(sizeof(fname) - 1UL));
  }
#line 937
  if ((int )fname[0] == 0) {
    {
#line 938
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)"xshogi.position.read");
    }
  }
  {
#line 940
  fd = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"w");
  }
#line 940
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 942
    fputs((char const   */* __restrict  */)"# xshogi position file -- \n", (FILE */* __restrict  */)fd);
#line 943
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fd);
#line 944
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fd);
#line 946
    i___0 = 8;
    }
    {
#line 946
    while (1) {
      while_continue: /* CIL Label */ ;
#line 946
      if (! (i___0 > -1)) {
#line 946
        goto while_break;
      }
#line 948
      p = fname;
#line 950
      j = 0;
      {
#line 950
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 950
        if (! (j < 9)) {
#line 950
          goto while_break___0;
        }
#line 952
        sq = (short )(i___0 * 9 + j);
#line 953
        piece = (short )board[sq];
#line 954
        isp = (short )is_promoted[piece];
#line 955
        if (isp) {
#line 955
          *p = (char )'+';
        } else {
#line 955
          *p = (char )' ';
        }
#line 956
        p ++;
#line 958
        if ((int )piece == 0) {
#line 959
          *p = (char )'.';
        } else
#line 960
        if ((int )color[sq] == 1) {
#line 961
          *p = (char )*(" plnsgbrplnsbrk " + piece);
        } else {
#line 963
          *p = (char )*(" PLNSGBRPLNSBRK " + piece);
        }
#line 965
        p ++;
#line 950
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 968
      tmp = p;
#line 968
      p ++;
#line 968
      *tmp = (char )'\n';
#line 969
      tmp___0 = p;
#line 969
      p ++;
#line 969
      *tmp___0 = (char )'\000';
#line 970
      fputs((char const   */* __restrict  */)(fname), (FILE */* __restrict  */)fd);
#line 946
      i___0 --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 973
    side = (short)0;
    {
#line 973
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 973
      if (! ((int )side <= 1)) {
#line 973
        goto while_break___1;
      }
      {
#line 975
      sprintf((char */* __restrict  */)(fname), (char const   */* __restrict  */)"%d %d %d %d %d %d %d %d\n",
              (int )Captured[side][1], (int )Captured[side][2], (int )Captured[side][3],
              (int )Captured[side][4], (int )Captured[side][5], (int )Captured[side][6],
              (int )Captured[side][7], (int )Captured[side][14]);
#line 992
      fputs((char const   */* __restrict  */)(fname), (FILE */* __restrict  */)fd);
#line 973
      side = (short )((int )side + 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 995
    if ((int )computer == 0) {
      {
#line 996
      fputs((char const   */* __restrict  */)"white to play\n", (FILE */* __restrict  */)fd);
      }
    } else {
      {
#line 998
      fputs((char const   */* __restrict  */)"black to play\n", (FILE */* __restrict  */)fd);
      }
    }
    {
#line 1000
    fclose(fd);
    }
  }
#line 1002
  return;
}
}
#line 1005 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void BookSave(void) 
{ 
  FILE *fd ;
  char fname[256] ;
  char sflags[4] ;
  short i___0 ;
  short j ;
  short f ;
  short t ;
  struct GameRec *g___0 ;
  char mvnr[20] ;
  char mvs[20] ;
  short tmp ;
  short tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1012
  if (savefile[0]) {
    {
#line 1013
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)(savefile));
    }
  } else {
    {
#line 1016
    ShowMessage((char *)"Enter file name: ");
#line 1017
    RequestInputString(fname, (unsigned int )(sizeof(fname) - 1UL));
    }
  }
#line 1020
  if ((int )fname[0] == 0) {
#line 1021
    return;
  }
  {
#line 1023
  fd = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"a");
  }
#line 1023
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 1025
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#\n");
#line 1027
    i___0 = (short)1;
    }
    {
#line 1027
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1027
      if (! ((int )i___0 <= (int )GameCnt)) {
#line 1027
        goto while_break;
      }
#line 1029
      g___0 = GameList + i___0;
#line 1032
      if ((int )i___0 % 2) {
        {
#line 1033
        sprintf((char */* __restrict  */)(mvnr), (char const   */* __restrict  */)"%d.",
                ((int )i___0 + 1) / 2);
        }
      } else {
        {
#line 1035
        strcpy((char */* __restrict  */)(mvnr), (char const   */* __restrict  */)"");
        }
      }
      {
#line 1037
      f = (short )((int )g___0->gmove >> 8);
#line 1038
      t = (short )((int )g___0->gmove & 255);
#line 1039
      algbr(f, t, g___0->flags);
#line 1040
      j = (short)0;
      }
#line 1043
      if ((int )g___0->flags & 128) {
#line 1044
        tmp = j;
#line 1044
        j = (short )((int )j + 1);
#line 1044
        sflags[tmp] = (char )'!';
      }
#line 1046
      if ((int )g___0->flags & 2048) {
#line 1047
        tmp___0 = j;
#line 1047
        j = (short )((int )j + 1);
#line 1047
        sflags[tmp___0] = (char )'?';
      }
#line 1054
      sflags[j] = (char )'\000';
#line 1057
      if ((int )f > 81) {
        {
#line 1059
        sprintf((char */* __restrict  */)(mvs), (char const   */* __restrict  */)"%s%s ",
                & mvstr[0][1], sflags);
        }
      } else {
#line 1063
        if ((int )mvstr[0][4] == 43) {
#line 1063
          tmp___1 = "+";
        } else {
#line 1063
          tmp___1 = "";
        }
#line 1063
        if ((int )g___0->flags & 512) {
#line 1063
          tmp___2 = 'x';
        } else {
#line 1063
          tmp___2 = '-';
        }
        {
#line 1063
        sprintf((char */* __restrict  */)(mvs), (char const   */* __restrict  */)"%c%c%c%c%c%s%s ",
                (int )mvstr[0][0], (int )mvstr[0][1], tmp___2, (int )mvstr[0][2],
                (int )mvstr[0][3], tmp___1, sflags);
        }
      }
#line 1071
      if ((int )f > 81) {
#line 1071
        tmp___4 = "";
      } else {
#line 1071
        if (is_promoted[g___0->fpiece]) {
#line 1071
          tmp___3 = "+";
        } else {
#line 1071
          tmp___3 = "";
        }
#line 1071
        tmp___4 = tmp___3;
      }
      {
#line 1071
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s%s%c%s",
              mvnr, tmp___4, (int const   )*(" PLNSGBRPLNSBRK " + g___0->fpiece),
              mvs);
      }
#line 1079
      if ((int )i___0 % 10 == 0) {
        {
#line 1080
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
        }
      }
#line 1027
      i___0 = (short )((int )i___0 + 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 1083
    if ((int )i___0 % 10 != 1) {
      {
#line 1084
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 1086
    fclose(fd);
#line 1088
    ShowMessage((char *)"Game saved");
    }
  } else {
    {
#line 1092
    ShowMessage((char *)"Could not open file");
    }
  }
#line 1094
  return;
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void ListGame(void) 
{ 
  FILE *fd ;
  short i___0 ;
  short f ;
  short t ;
  time_t when ;
  char fname[256] ;
  char dbuf[256] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  short j ;

  {
#line 1106
  if (listfile[0]) {
    {
#line 1108
    strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)(listfile));
    }
  } else {
    {
#line 1112
    time(& when);
#line 1113
    tmp = ctime((time_t const   *)(& when));
#line 1113
    strncpy((char */* __restrict  */)(dbuf), (char const   */* __restrict  */)tmp,
            (size_t )20);
#line 1114
    dbuf[7] = (char )'\000';
#line 1115
    dbuf[10] = (char )'\000';
#line 1116
    dbuf[13] = (char )'\000';
#line 1117
    dbuf[16] = (char )'\000';
#line 1118
    dbuf[19] = (char )'\000';
#line 1125
    sprintf((char */* __restrict  */)(fname), (char const   */* __restrict  */)"CL.%s%s-%s%s%s%c",
            dbuf + 4, dbuf + 8, dbuf + 11, dbuf + 14, dbuf + 17, (int )ColorStr[computer][0]);
#line 1130
    i___0 = (short)0;
    }
    {
#line 1130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1130
      if (! ((int )fname[i___0] != 0)) {
#line 1130
        goto while_break;
      }
#line 1132
      if ((int )fname[i___0] == 32) {
#line 1133
        fname[i___0] = (char )'0';
      }
#line 1130
      i___0 = (short )((int )i___0 + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1137
  fd = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"w");
  }
#line 1139
  if (! fd) {
    {
#line 1141
    printf((char const   */* __restrict  */)"Open failure for file: %s", fname);
#line 1142
    exit(1);
    }
  }
  {
#line 1145
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"gnushogi %s game\n",
          "1.4.1");
#line 1146
  fputs((char const   */* __restrict  */)"         score  depth   nodes  time         ",
        (FILE */* __restrict  */)fd);
#line 1147
  fputs((char const   */* __restrict  */)"         score  depth   nodes  time\n",
        (FILE */* __restrict  */)fd);
#line 1149
  i___0 = (short)1;
  }
  {
#line 1149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1149
    if (! ((int )i___0 <= (int )GameCnt)) {
#line 1149
      goto while_break___0;
    }
    {
#line 1151
    f = (short )((int )(GameList + i___0)->gmove >> 8);
#line 1152
    t = (short )((int )(GameList + i___0)->gmove & 255);
#line 1153
    algbr(f, t, (GameList + i___0)->flags);
    }
#line 1155
    if ((int )(GameList + i___0)->flags & 16384) {
#line 1157
      if ((int )f > 81) {
#line 1157
        tmp___0 = & mvstr[0][1];
      } else {
#line 1157
        tmp___0 = mvstr[0];
      }
#line 1157
      if ((int )f > 81) {
#line 1157
        tmp___2 = ' ';
      } else {
#line 1157
        if (is_promoted[(GameList + i___0)->fpiece]) {
#line 1157
          tmp___1 = '+';
        } else {
#line 1157
          tmp___1 = ' ';
        }
#line 1157
        tmp___2 = tmp___1;
      }
      {
#line 1157
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c%c%-5s  %5d    Book%7ld %5ld",
              tmp___2, (int const   )*(" PLNSGBRPLNSBRK " + (GameList + i___0)->fpiece),
              tmp___0, (int )(GameList + i___0)->score, (GameList + i___0)->nodes,
              (GameList + i___0)->time);
      }
    } else {
#line 1170
      if ((int )f > 81) {
#line 1170
        tmp___3 = & mvstr[0][1];
      } else {
#line 1170
        tmp___3 = mvstr[0];
      }
#line 1170
      if ((int )f > 81) {
#line 1170
        tmp___5 = ' ';
      } else {
#line 1170
        if (is_promoted[(GameList + i___0)->fpiece]) {
#line 1170
          tmp___4 = '+';
        } else {
#line 1170
          tmp___4 = ' ';
        }
#line 1170
        tmp___5 = tmp___4;
      }
      {
#line 1170
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%c%c%-5s  %5d     %2d %7ld %5ld",
              tmp___5, (int const   )*(" PLNSGBRPLNSBRK " + (GameList + i___0)->fpiece),
              tmp___3, (int )(GameList + i___0)->score, (int )(GameList + i___0)->depth,
              (GameList + i___0)->nodes, (GameList + i___0)->time);
      }
    }
#line 1180
    if ((int )i___0 % 2 == 0) {
      {
#line 1182
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 1186
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"         ");
      }
    }
#line 1149
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1190
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n\n");
  }
#line 1192
  if ((int )(GameList + GameCnt)->flags & 1024) {
    {
#line 1194
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"Draw %s\n",
            DRAW);
    }
#line 1196
    if ((unsigned long )DRAW == (unsigned long )DRAW_REPETITION) {
      {
#line 1200
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"repetition by positions ");
#line 1202
      j = (short )((int )GameCnt - 1);
      }
      {
#line 1202
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1202
        if (! ((int )j >= (int )Game50)) {
#line 1202
          goto while_break___1;
        }
#line 1204
        if ((GameList + j)->hashkey == hashkey) {
#line 1204
          if ((GameList + j)->hashbd == hashbd) {
            {
#line 1206
            fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d ",
                    (int )j);
            }
          }
        }
#line 1202
        j = (short )((int )j - 2);
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1209
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
      }
    }
  } else
#line 1212
  if ((int )(GameList + GameCnt)->score == -12999) {
    {
#line 1214
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s\n",
            ColorStr[player]);
    }
  } else
#line 1216
  if ((int )(GameList + GameCnt)->score == 12998) {
    {
#line 1218
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s\n",
            ColorStr[(int )player ^ 1]);
    }
  }
  {
#line 1221
  fclose(fd);
  }
#line 1222
  return;
}
}
#line 1226 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void FlagMove(char c ) 
{ 


  {
  {
#line 1231
  if ((int )c == 63) {
#line 1231
    goto case_63;
  }
#line 1235
  if ((int )c == 33) {
#line 1235
    goto case_33;
  }
#line 1229
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1232
  (GameList + GameCnt)->flags = (short )((int )(GameList + GameCnt)->flags | 2048);
#line 1233
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1236
  (GameList + GameCnt)->flags = (short )((int )(GameList + GameCnt)->flags | 128);
#line 1237
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1245
  return;
}
}
#line 1254 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void Undo(void) 
{ 
  short f ;
  short t ;

  {
#line 1259
  f = (short )((int )(GameList + GameCnt)->gmove >> 8);
#line 1260
  t = (short )((int )(GameList + GameCnt)->gmove & 127);
#line 1262
  if ((int )f > 81) {
#line 1265
    Captured[color[t]][board[t]] = (signed char )((int )Captured[color[t]][board[t]] + 1);
#line 1266
    board[t] = (signed char)0;
#line 1267
    color[t] = (signed char)2;
#line 1268
    Mvboard[t] = (signed char )((int )Mvboard[t] - 1);
  } else {
#line 1272
    if ((int )(GameList + GameCnt)->flags & 16) {
#line 1273
      board[f] = (signed char )unpromoted[board[t]];
    } else {
#line 1275
      board[f] = board[t];
    }
#line 1277
    color[f] = color[t];
#line 1278
    board[t] = (signed char )(GameList + GameCnt)->piece;
#line 1279
    color[t] = (signed char )(GameList + GameCnt)->color;
#line 1281
    if ((int )board[t] != 0) {
#line 1282
      Captured[color[f]][unpromoted[board[t]]] = (signed char )((int )Captured[color[f]][unpromoted[board[t]]] - 1);
    }
#line 1284
    if ((int )color[t] != 2) {
#line 1285
      Mvboard[t] = (signed char )((int )Mvboard[t] - 1);
    }
#line 1287
    Mvboard[f] = (signed char )((int )Mvboard[f] - 1);
  }
  {
#line 1290
  InitializeStats();
  }
#line 1292
  if (TCflag) {
#line 1292
    if ((int )TCmoves > 1) {
#line 1293
      TimeControl.moves[color[f]] = (short )((int )TimeControl.moves[color[f]] + 1);
    }
  }
  {
#line 1295
  hashkey = (GameList + GameCnt)->hashkey;
#line 1296
  hashbd = (GameList + GameCnt)->hashbd;
#line 1297
  GameCnt = (short )((int )GameCnt - 1);
#line 1298
  computer = (short )((int )computer ^ 1);
#line 1299
  opponent = (short )((int )opponent ^ 1);
#line 1300
  flag.mate = (short)0;
#line 1301
  Sdepth = (short)0;
#line 1302
  player = (short )((int )player ^ 1);
#line 1303
  ShowSidetoMove();
#line 1304
  UpdateDisplay((short)0, (short)0, (short)1, (short)0);
  }
#line 1306
  if (flag.regularstart) {
#line 1307
    Book = 0;
  }
#line 1308
  return;
}
}
#line 1312 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void FlagString(unsigned short flags , char *s ) 
{ 
  short l ;
  short piece ;
  size_t tmp ;
  short tmp___0 ;
  short tmp___1 ;

  {
#line 1316
  *s = (char )'\000';
#line 1318
  if ((int )flags & 16) {
    {
#line 1319
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" promote");
    }
  }
#line 1321
  if ((int )flags & 32) {
    {
#line 1322
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" drop:");
    }
  }
#line 1324
  piece = (short )((int )flags & 15);
#line 1324
  if (piece) {
    {
#line 1326
    tmp = strlen((char const   *)s);
#line 1326
    l = (short )tmp;
    }
#line 1328
    if (is_promoted[piece]) {
#line 1329
      tmp___0 = l;
#line 1329
      l = (short )((int )l + 1);
#line 1329
      *(s + tmp___0) = (char )'+';
    }
#line 1331
    tmp___1 = l;
#line 1331
    l = (short )((int )l + 1);
#line 1331
    *(s + tmp___1) = (char )*(" PLNSGBRPLNSBRK " + piece);
#line 1332
    *(s + l) = (char )'\000';
  }
#line 1335
  if ((int )flags & 512) {
    {
#line 1336
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" capture");
    }
  }
#line 1338
  if ((int )flags & 64) {
    {
#line 1339
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" exact");
    }
  }
#line 1341
  if ((int )flags & 128) {
    {
#line 1342
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" tesuji");
    }
  }
#line 1344
  if ((int )flags & 256) {
    {
#line 1345
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" check");
    }
  }
#line 1347
  if ((int )flags & 1024) {
    {
#line 1348
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" draw");
    }
  }
#line 1350
  if ((int )flags & 2048) {
    {
#line 1351
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" stupid");
    }
  }
#line 1353
  if ((int )flags & 4096) {
    {
#line 1354
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" questionable");
    }
  }
#line 1356
  if ((int )flags & 8192) {
    {
#line 1357
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" kingattack");
    }
  }
#line 1359
  if ((int )flags & 16384) {
    {
#line 1360
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)" book");
    }
  }
#line 1361
  return;
}
}
#line 1365 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void TestSpeed(void (*f)(short side , short ply , short in_check , short blockable ) ,
               unsigned int j ) 
{ 
  unsigned int i___0 ;
  long cnt___1 ;
  long t1 ;
  long t2 ;
  struct timeval tv ;

  {
  {
#line 1382
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1383
  t1 = tv.tv_sec * 100L + tv.tv_usec / 10000L;
#line 1388
  i___0 = 0U;
  }
  {
#line 1388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1388
    if (! (i___0 < j)) {
#line 1388
      goto while_break;
    }
    {
#line 1390
    (*f)(opponent, (short)2, (short)-1, (short)1);
#line 1388
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1402
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1403
  t2 = tv.tv_sec * 100L + tv.tv_usec / 10000L;
#line 1408
  cnt___1 = (long )(j * (unsigned int )((int )TrPnt[3] - (int )TrPnt[2]));
  }
#line 1410
  if (t2 - t1) {
#line 1411
    et = t2 - t1;
  } else {
#line 1413
    et = 1L;
  }
  {
#line 1415
  ShowNodeCnt(cnt___1);
  }
#line 1416
  return;
}
}
#line 1420 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void TestPSpeed(short (*f)(short side ) , unsigned int j ) 
{ 
  short i___0 ;
  long cnt___1 ;
  long t1 ;
  long t2 ;
  struct timeval tv ;

  {
  {
#line 1430
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1431
  t1 = tv.tv_sec * 100L + tv.tv_usec / 10000L;
#line 1436
  i___0 = (short)0;
  }
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! ((unsigned int )i___0 < j)) {
#line 1436
      goto while_break;
    }
    {
#line 1437
    (*f)(opponent);
#line 1436
    i___0 = (short )((int )i___0 + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1440
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1441
  t2 = tv.tv_sec * 100L + tv.tv_usec / 10000L;
#line 1446
  cnt___1 = (long )j;
  }
#line 1448
  if (t2 - t1) {
#line 1449
    et = t2 - t1;
  } else {
#line 1451
    et = 1L;
  }
  {
#line 1453
  ShowNodeCnt(cnt___1);
  }
#line 1454
  return;
}
}
#line 1458 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void SetOppTime(char *s ) 
{ 
  char *time___0 ;
  int m ;
  int t ;
  int sec ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1464
  sec = 0;
#line 1465
  tmp = strlen("otime");
#line 1465
  time___0 = s + tmp;
#line 1466
  tmp___0 = strtol((char const   */* __restrict  */)time___0, (char **/* __restrict  */)(& time___0),
                   10);
#line 1466
  t = (int )tmp___0;
  }
#line 1468
  if ((int )*time___0 == 58) {
    {
#line 1470
    time___0 ++;
#line 1471
    tmp___1 = strtol((char const   */* __restrict  */)time___0, (char **/* __restrict  */)(& time___0),
                     10);
#line 1471
    sec = (int )tmp___1;
    }
  }
  {
#line 1474
  tmp___2 = strtol((char const   */* __restrict  */)time___0, (char **/* __restrict  */)(& time___0),
                   10);
#line 1474
  m = (int )tmp___2;
  }
#line 1476
  if (t) {
#line 1477
    TimeControl.clock[opponent] = (long )t;
  }
#line 1479
  if (m) {
#line 1480
    TimeControl.moves[opponent] = (short )m;
  }
  {
#line 1482
  ElapsedTime((ElapsedTime_mode )1);
  }
#line 1484
  if ((unsigned int )display_type == 2U) {
    {
#line 1487
    printf((char const   */* __restrict  */)"otime %d %d\n", t, m);
    }
  }
#line 1489
  return;
}
}
#line 1493 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void SetMachineTime(char *s ) 
{ 
  char *time___0 ;
  int m ;
  int t ;
  int sec ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1499
  tmp = strlen("time");
#line 1499
  time___0 = s + tmp;
#line 1500
  sec = 0;
#line 1501
  tmp___0 = strtol((char const   */* __restrict  */)time___0, (char **/* __restrict  */)(& time___0),
                   10);
#line 1501
  t = (int )tmp___0;
  }
#line 1503
  if ((int )*time___0 == 58) {
    {
#line 1505
    time___0 ++;
#line 1506
    tmp___1 = strtol((char const   */* __restrict  */)time___0, (char **/* __restrict  */)(& time___0),
                     10);
#line 1506
    sec = (int )tmp___1;
    }
  }
  {
#line 1509
  tmp___2 = strtol((char const   */* __restrict  */)time___0, (char **/* __restrict  */)(& time___0),
                   10);
#line 1509
  m = (int )tmp___2;
  }
#line 1511
  if (t) {
#line 1512
    TimeControl.clock[computer] = (long )t;
  }
#line 1514
  if (m) {
#line 1515
    TimeControl.moves[computer] = (short )m;
  }
  {
#line 1517
  ElapsedTime((ElapsedTime_mode )1);
  }
#line 1519
  if ((unsigned int )display_type == 2U) {
    {
#line 1522
    printf((char const   */* __restrict  */)"time %d %d\n", t, m);
    }
  }
#line 1524
  return;
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void InputCommand(char *command ) 
{ 
  int eof ;
  short have_shown_prompt ;
  short ok ;
  short done ;
  short is_move ;
  unsigned short mv ;
  char s[80] ;
  char sx[80] ;
  int tmp ;
  short old_xshogi ;
  short temp ;
  short rpt___0 ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;

  {
#line 1544
  eof = 0;
#line 1545
  have_shown_prompt = (short)0;
#line 1546
  is_move = (short)0;
#line 1550
  done = (short)0;
#line 1550
  flag.quit = done;
#line 1550
  ok = flag.quit;
#line 1551
  player = opponent;
#line 1554
  if (TTadd > ttbllimit) {
    {
#line 1555
    ZeroTTable();
    }
  }
#line 1558
  if ((int )hint > 0) {
#line 1558
    if (! flag.easy) {
#line 1558
      if (! flag.force) {
        {
#line 1566
        ft = time0;
#line 1567
        fflush(stdout);
#line 1568
        algbr((short )((int )((short )hint) >> 8), (short )((int )((short )hint) & 255),
              (short)0);
#line 1569
        strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)(mvstr[0]));
        }
#line 1572
        if (flag.post) {
          {
#line 1573
          GiveHint();
          }
        }
        {
#line 1577
        tmp = VerifyMove(s, (VerifyMove_mode )1, & mv);
        }
#line 1577
        if (tmp) {
          {
#line 1579
          Sdepth = (short)0;
#line 1582
          ShowPrompt();
#line 1583
          have_shown_prompt = (short)1;
#line 1596
          SelectMove(computer, (SelectMove_mode )2);
#line 1613
          VerifyMove(s, (VerifyMove_mode )2, & mv);
#line 1614
          Sdepth = (short)0;
          }
        }
#line 1617
        time0 = ft;
      }
    }
  }
  {
#line 1620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1620
    if (ok) {
#line 1620
      goto while_break;
    } else
#line 1620
    if (flag.quit) {
#line 1620
      goto while_break;
    } else
#line 1620
    if (done) {
#line 1620
      goto while_break;
    }
#line 1622
    player = opponent;
#line 1625
    if (! have_shown_prompt) {
      {
#line 1629
      ShowPrompt();
      }
    }
#line 1634
    have_shown_prompt = (short)0;
#line 1637
    if ((unsigned long )command == (unsigned long )((void *)0)) {
#line 1638
      if ((unsigned int )display_type == 2U) {
#line 1639
        s[0] = (char )'\000';
      } else
#line 1638
      if ((unsigned int )display_type == 0U) {
#line 1639
        s[0] = (char )'\000';
      }
      {
#line 1641
      eof = GetString(sx);
      }
    } else {
      {
#line 1643
      strcpy((char */* __restrict  */)(sx), (char const   */* __restrict  */)command);
#line 1644
      done = (short)1;
      }
    }
    {
#line 1647
    sscanf((char const   */* __restrict  */)(sx), (char const   */* __restrict  */)"%s",
           s);
    }
#line 1649
    if (eof) {
      {
#line 1650
      ExitShogi();
      }
    }
#line 1652
    if ((int )s[0] == 0) {
#line 1653
      goto while_continue;
    }
    {
#line 1655
    tmp___58 = strcmp((char const   *)(s), "bd");
    }
#line 1655
    if (tmp___58 == 0) {
#line 1658
      old_xshogi = (short )((unsigned int )display_type == 2U);
#line 1660
      if (old_xshogi) {
#line 1661
        display_type = (display_t )0;
      }
      {
#line 1663
      ClearScreen();
#line 1664
      UpdateDisplay((short)0, (short)0, (short)1, (short)0);
      }
#line 1666
      if (old_xshogi) {
#line 1667
        display_type = (display_t )2;
      }
    } else {
      {
#line 1669
      tmp___57 = strcmp((char const   *)(s), "post");
      }
#line 1669
      if (tmp___57 == 0) {
#line 1671
        flag.post = (short )(! flag.post);
      } else {
        {
#line 1673
        tmp___56 = strcmp((char const   *)(s), "alg");
        }
#line 1673
        if (! (tmp___56 == 0)) {
          {
#line 1677
          tmp___54 = strcmp((char const   *)(s), "quit");
          }
#line 1677
          if (tmp___54 == 0) {
#line 1680
            flag.quit = (short)1;
          } else {
            {
#line 1677
            tmp___55 = strcmp((char const   *)(s), "exit");
            }
#line 1677
            if (tmp___55 == 0) {
#line 1680
              flag.quit = (short)1;
            } else {
              {
#line 1683
              tmp___53 = strcmp((char const   *)(s), "post");
              }
#line 1683
              if (tmp___53 == 0) {
#line 1685
                flag.post = (short )(! flag.post);
              } else {
                {
#line 1688
                tmp___51 = strcmp((char const   *)(s), "set");
                }
#line 1688
                if (tmp___51 == 0) {
                  {
#line 1691
                  EditBoard();
                  }
                } else {
                  {
#line 1688
                  tmp___52 = strcmp((char const   *)(s), "edit");
                  }
#line 1688
                  if (tmp___52 == 0) {
                    {
#line 1691
                    EditBoard();
                    }
                  } else {
                    {
#line 1693
                    tmp___50 = strcmp((char const   *)(s), "setup");
                    }
#line 1693
                    if (tmp___50 == 0) {
                      {
#line 1695
                      SetupBoard();
                      }
                    } else {
                      {
#line 1697
                      tmp___49 = strcmp((char const   *)(s), "first");
                      }
#line 1697
                      if (tmp___49 == 0) {
#line 1699
                        ok = (short)1;
                      } else {
                        {
#line 1701
                        tmp___48 = strcmp((char const   *)(s), "go");
                        }
#line 1701
                        if (tmp___48 == 0) {
#line 1703
                          ok = (short)1;
#line 1704
                          flag.force = (short)0;
#line 1706
                          if ((int )computer == 0) {
#line 1708
                            computer = (short)1;
#line 1709
                            opponent = (short)0;
                          } else {
#line 1713
                            computer = (short)0;
#line 1714
                            opponent = (short)1;
                          }
                        } else {
                          {
#line 1717
                          tmp___47 = strcmp((char const   *)(s), "help");
                          }
#line 1717
                          if (tmp___47 == 0) {
                            {
#line 1719
                            help();
                            }
                          } else {
                            {
#line 1721
                            tmp___46 = strcmp((char const   *)(s), "material");
                            }
#line 1721
                            if (tmp___46 == 0) {
#line 1723
                              flag.material = (short )(! flag.material);
                            } else {
                              {
#line 1725
                              tmp___45 = strcmp((char const   *)(s), "force");
                              }
#line 1725
                              if (tmp___45 == 0) {
#line 1727
                                if ((unsigned int )display_type == 2U) {
#line 1729
                                  flag.force = (short)1;
#line 1730
                                  flag.bothsides = (short)0;
                                } else {
#line 1734
                                  flag.force = (short )(! flag.force);
#line 1735
                                  flag.bothsides = (short)0;
                                }
                              } else {
                                {
#line 1738
                                tmp___44 = strcmp((char const   *)(s), "book");
                                }
#line 1738
                                if (tmp___44 == 0) {
#line 1740
                                  if (Book) {
#line 1740
                                    Book = 0;
                                  } else {
#line 1740
                                    Book = 20;
                                  }
                                } else {
                                  {
#line 1742
                                  tmp___43 = strcmp((char const   *)(s), "new");
                                  }
#line 1742
                                  if (tmp___43 == 0) {
                                    {
#line 1744
                                    NewGame();
#line 1745
                                    UpdateDisplay((short)0, (short)0, (short)1, (short)0);
                                    }
                                  } else {
                                    {
#line 1747
                                    tmp___42 = strcmp((char const   *)(s), "list");
                                    }
#line 1747
                                    if (tmp___42 == 0) {
                                      {
#line 1749
                                      ListGame();
                                      }
                                    } else {
                                      {
#line 1751
                                      tmp___40 = strcmp((char const   *)(s), "level");
                                      }
#line 1751
                                      if (tmp___40 == 0) {
                                        {
#line 1754
                                        SelectLevel(sx);
                                        }
                                      } else {
                                        {
#line 1751
                                        tmp___41 = strcmp((char const   *)(s), "clock");
                                        }
#line 1751
                                        if (tmp___41 == 0) {
                                          {
#line 1754
                                          SelectLevel(sx);
                                          }
                                        } else {
                                          {
#line 1756
                                          tmp___39 = strcmp((char const   *)(s), "hash");
                                          }
#line 1756
                                          if (tmp___39 == 0) {
#line 1758
                                            flag.hash = (short )(! flag.hash);
                                          } else {
                                            {
#line 1760
                                            tmp___38 = strcmp((char const   *)(s),
                                                              "gamein");
                                            }
#line 1760
                                            if (tmp___38 == 0) {
#line 1762
                                              flag.gamein = (short )(! flag.gamein);
                                            } else {
                                              {
#line 1764
                                              tmp___37 = strcmp((char const   *)(s),
                                                                "beep");
                                              }
#line 1764
                                              if (tmp___37 == 0) {
#line 1766
                                                flag.beep = (short )(! flag.beep);
                                              } else {
                                                {
#line 1768
                                                tmp___36 = strcmp((char const   *)(s),
                                                                  "time");
                                                }
#line 1768
                                                if (tmp___36 == 0) {
                                                  {
#line 1770
                                                  SetMachineTime(sx);
                                                  }
                                                } else {
                                                  {
#line 1772
                                                  tmp___35 = strcmp((char const   *)(s),
                                                                    "otime");
                                                  }
#line 1772
                                                  if (tmp___35 == 0) {
                                                    {
#line 1774
                                                    SetOppTime(sx);
                                                    }
                                                  } else {
                                                    {
#line 1776
                                                    tmp___34 = strcmp((char const   *)(s),
                                                                      "Awindow");
                                                    }
#line 1776
                                                    if (tmp___34 == 0) {
                                                      {
#line 1778
                                                      ChangeAlphaWindow();
                                                      }
                                                    } else {
                                                      {
#line 1780
                                                      tmp___33 = strcmp((char const   *)(s),
                                                                        "Bwindow");
                                                      }
#line 1780
                                                      if (tmp___33 == 0) {
                                                        {
#line 1782
                                                        ChangeBetaWindow();
                                                        }
                                                      } else {
                                                        {
#line 1784
                                                        tmp___32 = strcmp((char const   *)(s),
                                                                          "rcptr");
                                                        }
#line 1784
                                                        if (tmp___32 == 0) {
#line 1786
                                                          flag.rcptr = (short )(! flag.rcptr);
                                                        } else {
                                                          {
#line 1788
                                                          tmp___31 = strcmp((char const   *)(s),
                                                                            "hint");
                                                          }
#line 1788
                                                          if (tmp___31 == 0) {
                                                            {
#line 1790
                                                            GiveHint();
                                                            }
                                                          } else {
                                                            {
#line 1792
                                                            tmp___30 = strcmp((char const   *)(s),
                                                                              "both");
                                                            }
#line 1792
                                                            if (tmp___30 == 0) {
                                                              {
#line 1794
                                                              flag.bothsides = (short )(! flag.bothsides);
#line 1795
                                                              flag.force = (short)0;
#line 1796
                                                              Sdepth = (short)0;
#line 1797
                                                              ElapsedTime((ElapsedTime_mode )1);
#line 1798
                                                              SelectMove(opponent,
                                                                         (SelectMove_mode )1);
#line 1799
                                                              ok = (short)1;
                                                              }
                                                            } else {
                                                              {
#line 1801
                                                              tmp___29 = strcmp((char const   *)(s),
                                                                                "reverse");
                                                              }
#line 1801
                                                              if (tmp___29 == 0) {
                                                                {
#line 1803
                                                                flag.reverse = (short )(! flag.reverse);
#line 1804
                                                                ClearScreen();
#line 1805
                                                                UpdateDisplay((short)0,
                                                                              (short)0,
                                                                              (short)1,
                                                                              (short)0);
                                                                }
                                                              } else {
                                                                {
#line 1807
                                                                tmp___28 = strcmp((char const   *)(s),
                                                                                  "switch");
                                                                }
#line 1807
                                                                if (tmp___28 == 0) {
#line 1809
                                                                  computer = (short )((int )computer ^ 1);
#line 1810
                                                                  opponent = (short )((int )opponent ^ 1);
#line 1811
                                                                  if ((int )computer == 0) {
#line 1811
                                                                    xwndw = (short)90;
                                                                  } else {
#line 1811
                                                                    xwndw = (short)90;
                                                                  }
#line 1812
                                                                  flag.force = (short)0;
#line 1813
                                                                  Sdepth = (short)0;
#line 1814
                                                                  ok = (short)1;
                                                                } else {
                                                                  {
#line 1816
                                                                  tmp___27 = strcmp((char const   *)(s),
                                                                                    "black");
                                                                  }
#line 1816
                                                                  if (tmp___27 == 0) {
#line 1818
                                                                    computer = (short)1;
#line 1819
                                                                    opponent = (short)0;
#line 1820
                                                                    xwndw = (short)90;
#line 1821
                                                                    flag.force = (short)0;
#line 1822
                                                                    Sdepth = (short)0;
                                                                  } else {
                                                                    {
#line 1828
                                                                    tmp___26 = strcmp((char const   *)(s),
                                                                                      "white");
                                                                    }
#line 1828
                                                                    if (tmp___26 == 0) {
#line 1830
                                                                      computer = (short)0;
#line 1831
                                                                      opponent = (short)1;
#line 1832
                                                                      xwndw = (short)90;
#line 1833
                                                                      flag.force = (short)0;
#line 1834
                                                                      Sdepth = (short)0;
                                                                    } else {
                                                                      {
#line 1840
                                                                      tmp___25 = strcmp((char const   *)(s),
                                                                                        "undo");
                                                                      }
#line 1840
                                                                      if (tmp___25 == 0) {
#line 1840
                                                                        if ((int )GameCnt > 0) {
                                                                          {
#line 1842
                                                                          Undo();
                                                                          }
                                                                        } else {
#line 1840
                                                                          goto _L___7;
                                                                        }
                                                                      } else {
                                                                        _L___7: /* CIL Label */ 
                                                                        {
#line 1844
                                                                        tmp___24 = strcmp((char const   *)(s),
                                                                                          "remove");
                                                                        }
#line 1844
                                                                        if (tmp___24 == 0) {
#line 1844
                                                                          if ((int )GameCnt > 1) {
                                                                            {
#line 1846
                                                                            Undo();
#line 1847
                                                                            Undo();
                                                                            }
                                                                          } else {
#line 1844
                                                                            goto _L___6;
                                                                          }
                                                                        } else
                                                                        _L___6: /* CIL Label */ 
#line 1850
                                                                        if (! ((unsigned int )display_type == 2U)) {
                                                                          {
#line 1850
                                                                          tmp___23 = strcmp((char const   *)(s),
                                                                                            "xget");
                                                                          }
#line 1850
                                                                          if (tmp___23 == 0) {
                                                                            {
#line 1852
                                                                            GetXGame();
                                                                            }
                                                                          } else {
#line 1850
                                                                            goto _L___5;
                                                                          }
                                                                        } else
                                                                        _L___5: /* CIL Label */ 
#line 1854
                                                                        if (! ((unsigned int )display_type == 2U)) {
                                                                          {
#line 1854
                                                                          tmp___22 = strcmp((char const   *)(s),
                                                                                            "xsave");
                                                                          }
#line 1854
                                                                          if (tmp___22 == 0) {
                                                                            {
#line 1856
                                                                            SaveXGame();
                                                                            }
                                                                          } else {
#line 1854
                                                                            goto _L___4;
                                                                          }
                                                                        } else
                                                                        _L___4: /* CIL Label */ 
#line 1858
                                                                        if (! ((unsigned int )display_type == 2U)) {
                                                                          {
#line 1858
                                                                          tmp___21 = strcmp((char const   *)(s),
                                                                                            "bsave");
                                                                          }
#line 1858
                                                                          if (tmp___21 == 0) {
                                                                            {
#line 1860
                                                                            BookSave();
                                                                            }
                                                                          } else {
#line 1858
                                                                            goto _L___3;
                                                                          }
                                                                        } else {
                                                                          _L___3: /* CIL Label */ 
                                                                          {
#line 1867
                                                                          tmp___19 = strcmp((char const   *)(s),
                                                                                            "?");
                                                                          }
#line 1867
                                                                          if (tmp___19 == 0) {
                                                                            {
#line 1871
                                                                            FlagMove(s[0]);
                                                                            }
                                                                          } else {
                                                                            {
#line 1867
                                                                            tmp___20 = strcmp((char const   *)(s),
                                                                                              "!");
                                                                            }
#line 1867
                                                                            if (tmp___20 == 0) {
                                                                              {
#line 1871
                                                                              FlagMove(s[0]);
                                                                              }
                                                                            } else {
                                                                              {
#line 1873
                                                                              tmp___18 = strcmp((char const   *)(s),
                                                                                                "get");
                                                                              }
#line 1873
                                                                              if (tmp___18 == 0) {
                                                                                {
#line 1875
                                                                                GetGame();
                                                                                }
                                                                              } else {
                                                                                {
#line 1877
                                                                                tmp___17 = strcmp((char const   *)(s),
                                                                                                  "save");
                                                                                }
#line 1877
                                                                                if (tmp___17 == 0) {
                                                                                  {
#line 1879
                                                                                  SaveGame();
                                                                                  }
                                                                                } else {
                                                                                  {
#line 1881
                                                                                  tmp___16 = strcmp((char const   *)(s),
                                                                                                    "depth");
                                                                                  }
#line 1881
                                                                                  if (tmp___16 == 0) {
                                                                                    {
#line 1883
                                                                                    ChangeSearchDepth();
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 1885
                                                                                    tmp___15 = strcmp((char const   *)(s),
                                                                                                      "hashdepth");
                                                                                    }
#line 1885
                                                                                    if (tmp___15 == 0) {
                                                                                      {
#line 1887
                                                                                      ChangeHashDepth();
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 1889
                                                                                      tmp___14 = strcmp((char const   *)(s),
                                                                                                        "random");
                                                                                      }
#line 1889
                                                                                      if (tmp___14 == 0) {
#line 1891
                                                                                        dither = (short)5;
                                                                                      } else {
                                                                                        {
#line 1893
                                                                                        tmp___13 = strcmp((char const   *)(s),
                                                                                                          "hard");
                                                                                        }
#line 1893
                                                                                        if (tmp___13 == 0) {
#line 1895
                                                                                          flag.easy = (short)0;
                                                                                        } else {
                                                                                          {
#line 1897
                                                                                          tmp___12 = strcmp((char const   *)(s),
                                                                                                            "easy");
                                                                                          }
#line 1897
                                                                                          if (tmp___12 == 0) {
#line 1899
                                                                                            flag.easy = (short )(! flag.easy);
                                                                                          } else {
                                                                                            {
#line 1901
                                                                                            tmp___11 = strcmp((char const   *)(s),
                                                                                                              "tsume");
                                                                                            }
#line 1901
                                                                                            if (tmp___11 == 0) {
#line 1903
                                                                                              flag.tsume = (short )(! flag.tsume);
                                                                                            } else {
                                                                                              {
#line 1905
                                                                                              tmp___10 = strcmp((char const   *)(s),
                                                                                                                "contempt");
                                                                                              }
#line 1905
                                                                                              if (tmp___10 == 0) {
                                                                                                {
#line 1907
                                                                                                SetContempt();
                                                                                                }
                                                                                              } else {
                                                                                                {
#line 1909
                                                                                                tmp___9 = strcmp((char const   *)(s),
                                                                                                                 "xwndw");
                                                                                                }
#line 1909
                                                                                                if (tmp___9 == 0) {
                                                                                                  {
#line 1911
                                                                                                  ChangeXwindow();
                                                                                                  }
                                                                                                } else {
                                                                                                  {
#line 1913
                                                                                                  tmp___8 = strcmp((char const   *)(s),
                                                                                                                   "rv");
                                                                                                  }
#line 1913
                                                                                                  if (tmp___8 == 0) {
                                                                                                    {
#line 1915
                                                                                                    flag.rv = (short )(! flag.rv);
#line 1916
                                                                                                    UpdateDisplay((short)0,
                                                                                                                  (short)0,
                                                                                                                  (short)1,
                                                                                                                  (short)0);
                                                                                                    }
                                                                                                  } else {
                                                                                                    {
#line 1918
                                                                                                    tmp___7 = strcmp((char const   *)(s),
                                                                                                                     "coords");
                                                                                                    }
#line 1918
                                                                                                    if (tmp___7 == 0) {
                                                                                                      {
#line 1920
                                                                                                      flag.coords = (short )(! flag.coords);
#line 1921
                                                                                                      UpdateDisplay((short)0,
                                                                                                                    (short)0,
                                                                                                                    (short)1,
                                                                                                                    (short)0);
                                                                                                      }
                                                                                                    } else {
                                                                                                      {
#line 1923
                                                                                                      tmp___6 = strcmp((char const   *)(s),
                                                                                                                       "stars");
                                                                                                      }
#line 1923
                                                                                                      if (tmp___6 == 0) {
                                                                                                        {
#line 1925
                                                                                                        flag.stars = (short )(! flag.stars);
#line 1926
                                                                                                        UpdateDisplay((short)0,
                                                                                                                      (short)0,
                                                                                                                      (short)1,
                                                                                                                      (short)0);
                                                                                                        }
                                                                                                      } else
#line 1928
                                                                                                      if (! ((unsigned int )display_type == 2U)) {
                                                                                                        {
#line 1928
                                                                                                        tmp___5 = strcmp((char const   *)(s),
                                                                                                                         "moves");
                                                                                                        }
#line 1928
                                                                                                        if (tmp___5 == 0) {
#line 1933
                                                                                                          if ((int )GameCnt > 0) {
#line 1937
                                                                                                            if ((int )(GameList + GameCnt)->gmove == (int )PrVar[1]) {
#line 1937
                                                                                                              SwagHt = PrVar[2];
                                                                                                            } else {
#line 1937
                                                                                                              SwagHt = (unsigned short)0;
                                                                                                            }
                                                                                                          } else {
#line 1942
                                                                                                            SwagHt = (unsigned short)0;
                                                                                                          }
                                                                                                          {
#line 1944
                                                                                                          ShowMessage((char *)"Testing MoveList Speed");
#line 1945
                                                                                                          temp = generate_move_flags;
#line 1946
                                                                                                          generate_move_flags = (short)1;
#line 1947
                                                                                                          TestSpeed(& MoveList,
                                                                                                                    1U);
#line 1948
                                                                                                          generate_move_flags = temp;
#line 1949
                                                                                                          ShowMessage((char *)"Testing CaptureList Speed");
#line 1950
                                                                                                          TestSpeed(& CaptureList,
                                                                                                                    1U);
#line 1951
                                                                                                          ShowMessage((char *)"Testing Eval Speed");
#line 1952
                                                                                                          ExaminePosition(opponent);
#line 1953
                                                                                                          TestPSpeed(& ScorePosition,
                                                                                                                     1U);
                                                                                                          }
                                                                                                        } else {
#line 1928
                                                                                                          goto _L___2;
                                                                                                        }
                                                                                                      } else
                                                                                                      _L___2: /* CIL Label */ 
#line 1955
                                                                                                      if (! ((unsigned int )display_type == 2U)) {
                                                                                                        {
#line 1955
                                                                                                        tmp___4 = strcmp((char const   *)(s),
                                                                                                                         "test");
                                                                                                        }
#line 1955
                                                                                                        if (tmp___4 == 0) {
                                                                                                          {
#line 1966
                                                                                                          ShowMessage((char *)"Testing MoveList Speed");
#line 1967
                                                                                                          TestSpeed(& MoveList,
                                                                                                                    20000U);
#line 1968
                                                                                                          ShowMessage((char *)"Testing CaptureList Speed");
#line 1969
                                                                                                          TestSpeed(& CaptureList,
                                                                                                                    30000U);
#line 1970
                                                                                                          ShowMessage((char *)"Testing Eval Speed");
#line 1971
                                                                                                          ExaminePosition(opponent);
#line 1972
                                                                                                          TestPSpeed(& ScorePosition,
                                                                                                                     15000U);
                                                                                                          }
                                                                                                        } else {
#line 1955
                                                                                                          goto _L___1;
                                                                                                        }
                                                                                                      } else
                                                                                                      _L___1: /* CIL Label */ 
#line 1975
                                                                                                      if (! ((unsigned int )display_type == 2U)) {
                                                                                                        {
#line 1975
                                                                                                        tmp___3 = strcmp((char const   *)(s),
                                                                                                                         "p");
                                                                                                        }
#line 1975
                                                                                                        if (tmp___3 == 0) {
                                                                                                          {
#line 1977
                                                                                                          ShowPostnValues();
                                                                                                          }
                                                                                                        } else {
#line 1975
                                                                                                          goto _L___0;
                                                                                                        }
                                                                                                      } else
                                                                                                      _L___0: /* CIL Label */ 
#line 1979
                                                                                                      if (! ((unsigned int )display_type == 2U)) {
                                                                                                        {
#line 1979
                                                                                                        tmp___2 = strcmp((char const   *)(s),
                                                                                                                         "debug");
                                                                                                        }
#line 1979
                                                                                                        if (tmp___2 == 0) {
                                                                                                          {
#line 1981
                                                                                                          DoDebug();
                                                                                                          }
                                                                                                        } else {
#line 1979
                                                                                                          goto _L;
                                                                                                        }
                                                                                                      } else {
                                                                                                        _L: /* CIL Label */ 
#line 1985
                                                                                                        if (flag.mate) {
#line 1987
                                                                                                          ok = (short)1;
                                                                                                        } else {
                                                                                                          {
#line 1989
                                                                                                          tmp___1 = VerifyMove(s,
                                                                                                                               (VerifyMove_mode )0,
                                                                                                                               & mv);
#line 1989
                                                                                                          ok = (short )tmp___1;
                                                                                                          }
#line 1989
                                                                                                          if (ok) {
                                                                                                            {
#line 1992
                                                                                                            tmp___0 = repetition();
#line 1992
                                                                                                            rpt___0 = tmp___0;
                                                                                                            }
#line 1994
                                                                                                            if ((int )rpt___0 >= 3) {
                                                                                                              {
#line 1996
                                                                                                              DRAW = DRAW_REPETITION;
#line 1997
                                                                                                              ShowMessage(DRAW);
#line 1998
                                                                                                              (GameList + GameCnt)->flags = (short )((int )(GameList + GameCnt)->flags | 1024);
#line 2000
                                                                                                              flag.mate = (short)1;
                                                                                                              }
                                                                                                            } else {
#line 2004
                                                                                                              is_move = (short)1;
                                                                                                            }
                                                                                                          }
                                                                                                        }
#line 2008
                                                                                                        Sdepth = (short)0;
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2012
  ElapsedTime((ElapsedTime_mode )1);
  }
#line 2014
  if (flag.force) {
#line 2016
    computer = opponent;
#line 2017
    opponent = (short )((int )computer ^ 1);
  }
#line 2020
  if ((unsigned int )display_type == 2U) {
#line 2023
    if (is_move) {
      {
#line 2025
      mycnt2 ++;
#line 2025
      printf((char const   */* __restrict  */)"%d. %s %ld\n", mycnt2, s, TimeControl.clock[player] * 10L);
      }
    }
  }
#line 2048
  return;
}
}
#line 2053 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/commondsp.c"
void SetTimeControl(void) 
{ 


  {
#line 2056
  if (TCflag) {
#line 2058
    TimeControl.moves[1] = TCmoves;
#line 2058
    TimeControl.moves[0] = TimeControl.moves[1];
#line 2059
    TimeControl.clock[0] += 6000L * (long )TCminutes + (long )((int )TCseconds * 100);
#line 2060
    TimeControl.clock[1] += 6000L * (long )TCminutes + (long )((int )TCseconds * 100);
  } else {
#line 2064
    TimeControl.moves[1] = (short)0;
#line 2064
    TimeControl.moves[0] = TimeControl.moves[1];
#line 2065
    TimeControl.clock[1] = 0L;
#line 2065
    TimeControl.clock[0] = TimeControl.clock[1];
  }
  {
#line 2068
  flag.onemove = (short )((int )TCmoves == 1);
#line 2069
  et = 0L;
#line 2070
  ElapsedTime((ElapsedTime_mode )1);
  }
#line 2071
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 918 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/gnushogi.h"
int parse(FILE *fd , unsigned short *mv , short side , char *opening ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
unsigned int TTadd  =    0U;
#line 36 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
short recycle  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
short ISZERO  =    (short)1;
#line 40 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int parse(FILE *fd , unsigned short *mv , short side , char *opening ) 
{ 
  int c ;
  int i___0 ;
  int r1 ;
  int r2 ;
  int c1___0 ;
  int c2___0 ;
  char s[128] ;
  char *p ;
  char *tmp ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    c = _IO_getc(fd);
    }
#line 47
    if (! (c == 32)) {
#line 47
      if (! (c == 10)) {
#line 47
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  i___0 = 0;
#line 50
  s[0] = (char )c;
#line 52
  if (c == 33) {
#line 54
    p = opening;
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 57
      tmp = p;
#line 57
      p ++;
#line 57
      *tmp = (char )c;
#line 58
      c = _IO_getc(fd);
      }
#line 60
      if (c == 10) {
#line 62
        *p = (char )'\000';
#line 63
        return (0);
      } else
#line 60
      if (c == -1) {
#line 62
        *p = (char )'\000';
#line 63
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 69
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 69
    if (c != 63) {
#line 69
      if (c != 32) {
#line 69
        if (c != 9) {
#line 69
          if (c != 10) {
#line 69
            if (! (c != -1)) {
#line 69
              goto while_break___1;
            }
          } else {
#line 69
            goto while_break___1;
          }
        } else {
#line 69
          goto while_break___1;
        }
      } else {
#line 69
        goto while_break___1;
      }
    } else {
#line 69
      goto while_break___1;
    }
    {
#line 72
    i___0 ++;
#line 72
    c = _IO_getc(fd);
#line 72
    s[i___0] = (char )c;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 75
  i___0 ++;
#line 75
  s[i___0] = (char )'\000';
#line 77
  if (c == -1) {
#line 78
    return (-1);
  }
#line 80
  if ((int )s[0] == 33) {
#line 80
    goto _L;
  } else
#line 80
  if ((int )s[0] == 59) {
#line 80
    goto _L;
  } else
#line 80
  if (i___0 < 3) {
    _L: /* CIL Label */ 
    {
#line 82
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 82
      if (c != 10) {
#line 82
        if (! (c != -1)) {
#line 82
          goto while_break___2;
        }
      } else {
#line 82
        goto while_break___2;
      }
      {
#line 83
      c = _IO_getc(fd);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 85
    return (0);
  }
#line 88
  c1___0 = 57 - (int )s[0];
#line 89
  r1 = 105 - (int )s[1];
#line 90
  c2___0 = 57 - (int )s[2];
#line 91
  r2 = 105 - (int )s[3];
#line 92
  *mv = (unsigned short )(((r1 * 9 + c1___0) << 8) | (r2 * 9 + c2___0));
#line 94
  if (c == 63) {
    {
#line 97
    *mv = (unsigned short )((int )*mv | 32768);
#line 98
    c = _IO_getc(fd);
    }
  }
#line 101
  return (1);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
unsigned char CB(short sq ) 
{ 
  short i___0 ;
  int tmp ;

  {
#line 117
  i___0 = sq;
#line 119
  if ((int )i___0 < 81) {
#line 121
    if ((int )color[i___0] == 1) {
#line 121
      tmp = 128 | (int )board[i___0];
    } else {
#line 121
      tmp = (int )board[i___0];
    }
#line 121
    return ((unsigned char )tmp);
  } else {
#line 125
    i___0 = (short )((int )i___0 - 81);
#line 126
    return ((unsigned char )(((int )Captured[0][i___0] << 4) | (int )Captured[1][i___0]));
  }
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int ProbeTTable(short side , short depth , short ply , short *alpha___0 , short *beta___0 ,
                short *score___0 ) 
{ 
  struct hashentry *ptbl ;
  short i___0 ;

  {
#line 148
  i___0 = (short)0;
#line 150
  ptbl = ttable[side] + hashkey % (unsigned long )ttblsize;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if ((int )ptbl->depth == 0) {
#line 155
      return (0);
    }
#line 157
    if (ptbl->hashbd == hashbd) {
#line 158
      goto while_break;
    }
#line 160
    i___0 = (short )((int )i___0 + 1);
#line 160
    if ((int )i___0 > (int )rehash) {
#line 161
      return (0);
    }
#line 163
    ptbl ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if ((int )((short )ptbl->depth) >= (int )depth) {
#line 191
    SwagHt = ptbl->mv;
#line 191
    PV = SwagHt;
#line 193
    HashCnt ++;
#line 195
    if ((int )ptbl->flags & 1) {
#line 197
      *score___0 = ptbl->score;
#line 200
      if ((int )*score___0 > 12000) {
#line 201
        *score___0 = (short )((int )*score___0 - (int )ply);
      } else
#line 202
      if ((int )*score___0 < -12000) {
#line 203
        *score___0 = (short )((int )*score___0 + (int )ply);
      }
#line 205
      *beta___0 = (short)-26000;
    } else
#line 207
    if ((int )ptbl->flags & 2) {
#line 209
      if ((int )ptbl->score > (int )*alpha___0) {
#line 210
        *alpha___0 = (short )((int )ptbl->score - 1);
      }
    }
#line 213
    return (1);
  }
#line 216
  return (0);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int PutInTTable(short side , short score___0 , short depth , short ply , short alpha___0 ,
                short beta___0 , unsigned short mv ) 
{ 
  struct hashentry *ptbl ;
  short i___0 ;

  {
#line 235
  i___0 = (short)0;
#line 237
  ptbl = ttable[side] + hashkey % (unsigned long )ttblsize;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if ((int )ptbl->depth == 0) {
#line 242
      goto while_break;
    } else
#line 241
    if (ptbl->hashbd == hashbd) {
#line 242
      goto while_break;
    }
#line 244
    i___0 = (short )((int )i___0 + 1);
#line 244
    if ((int )i___0 > (int )rehash) {
#line 246
      THashCol ++;
#line 247
      ptbl += (int )recycle;
#line 249
      goto while_break;
    }
#line 252
    ptbl ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  TTadd ++;
#line 256
  HashAdd ++;
#line 260
  if ((int )score___0 > 12000) {
#line 261
    score___0 = (short )((int )score___0 + (int )ply);
  } else
#line 262
  if ((int )score___0 < -12000) {
#line 263
    score___0 = (short )((int )score___0 - (int )ply);
  }
#line 265
  ptbl->hashbd = hashbd;
#line 266
  ptbl->depth = (unsigned char )depth;
#line 267
  ptbl->score = score___0;
#line 268
  ptbl->mv = mv;
#line 270
  if ((int )score___0 > (int )beta___0) {
#line 272
    ptbl->flags = (unsigned char)2;
#line 273
    ptbl->score = (short )((int )beta___0 + 1);
  } else {
#line 277
    ptbl->flags = (unsigned char)1;
  }
#line 285
  return (1);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
void ZeroTTable(void) 
{ 


  {
  {
#line 293
  memset((void *)ttable[0], 0, (size_t )(ttblsize + (unsigned int )rehash));
#line 294
  memset((void *)ttable[1], 0, (size_t )(ttblsize + (unsigned int )rehash));
#line 297
  memset((void *)etab[0], 0, sizeof(struct etable ) * 10001UL);
#line 298
  memset((void *)etab[1], 0, sizeof(struct etable ) * 10001UL);
#line 301
  TTadd = 0U;
  }
#line 302
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int Fbdcmp(unsigned char *a , unsigned char *b ) 
{ 
  int i___0 ;

  {
#line 313
  i___0 = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i___0 < 96)) {
#line 313
      goto while_break;
    }
#line 315
    if ((int )*(a + i___0) != (int )*(b + i___0)) {
#line 316
      return (0);
    }
#line 313
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (1);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int ProbeFTable(short side , short depth , short ply , short *alpha___0 , short *beta___0 ,
                short *score___0 ) 
{ 
  short i___0 ;
  unsigned long hashix ;
  struct fileentry new ;
  struct fileentry t ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 340
  if ((int )side == 0) {
#line 340
    tmp = hashkey & 4294967294UL;
  } else {
#line 340
    tmp = hashkey | 1UL;
  }
#line 340
  hashix = tmp % (unsigned long )filesz;
#line 343
  i___0 = (short)0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((int )i___0 < 96)) {
#line 343
      goto while_break;
    }
    {
#line 344
    new.bd[i___0] = CB(i___0);
#line 343
    i___0 = (short )((int )i___0 + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  new.flags = (unsigned char)0;
#line 348
  i___0 = (short)0;
  {
#line 348
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 348
    if (! ((int )i___0 < 6)) {
#line 348
      goto while_break___0;
    }
    {
#line 350
    fseek(hashfile, (long )(sizeof(struct fileentry ) * ((hashix + (unsigned long )(2 * (int )i___0)) % (unsigned long )filesz)),
          0);
#line 353
    fread((void */* __restrict  */)(& t), sizeof(struct fileentry ), (size_t )1, (FILE */* __restrict  */)hashfile);
    }
#line 355
    if (! t.depth) {
#line 356
      goto while_break___0;
    }
    {
#line 358
    tmp___0 = Fbdcmp(t.bd, new.bd);
    }
#line 358
    if (! tmp___0) {
#line 359
      goto __Cont;
    }
#line 361
    if ((int )((short )t.depth) >= (int )depth) {
#line 361
      if ((int )new.flags == (int )((unsigned short )((int )t.flags & 24))) {
#line 365
        FHashCnt ++;
#line 367
        PV = (unsigned short )(((int )t.f << 8) | (int )t.t);
#line 368
        *score___0 = (short )(((int )t.sh << 8) | (int )t.sl);
#line 371
        if ((int )*score___0 > 12000) {
#line 372
          *score___0 = (short )((int )*score___0 - (int )ply);
        } else
#line 373
        if ((int )*score___0 < -12000) {
#line 374
          *score___0 = (short )((int )*score___0 + (int )ply);
        }
#line 376
        if ((int )t.flags & 1) {
#line 378
          *beta___0 = (short)-26000;
        } else
#line 380
        if ((int )t.flags & 2) {
#line 382
          if ((int )*score___0 > (int )*alpha___0) {
#line 383
            *alpha___0 = (short )((int )*score___0 - 1);
          }
        } else
#line 385
        if ((int )t.flags & 4) {
#line 387
          if ((int )*score___0 < (int )*beta___0) {
#line 388
            *beta___0 = (short )((int )*score___0 + 1);
          }
        }
#line 391
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 348
    i___0 = (short )((int )i___0 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 395
  return (0);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
void PutInFTable(short side , short score___0 , short depth , short ply , short alpha___0 ,
                 short beta___0 , unsigned short f , unsigned short t ) 
{ 
  unsigned short i___0 ;
  unsigned long hashix ;
  struct fileentry new ;
  struct fileentry tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 418
  if ((int )side == 0) {
#line 418
    tmp___0 = hashkey & 4294967294UL;
  } else {
#line 418
    tmp___0 = hashkey | 1UL;
  }
#line 418
  hashix = tmp___0 % (unsigned long )filesz;
#line 421
  i___0 = (unsigned short)0;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! ((int )i___0 < 96)) {
#line 421
      goto while_break;
    }
    {
#line 422
    new.bd[i___0] = CB((short )i___0);
#line 421
    i___0 = (unsigned short )((int )i___0 + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  new.f = (unsigned char )f;
#line 425
  new.t = (unsigned char )t;
#line 427
  if ((int )score___0 < (int )alpha___0) {
#line 428
    new.flags = (unsigned char)4;
  } else
#line 430
  if ((int )score___0 > (int )beta___0) {
#line 430
    new.flags = (unsigned char)2;
  } else {
#line 430
    new.flags = (unsigned char)1;
  }
#line 432
  new.depth = (unsigned char )depth;
#line 435
  if ((int )score___0 > 12000) {
#line 436
    score___0 = (short )((int )score___0 + (int )ply);
  } else
#line 437
  if ((int )score___0 < -12000) {
#line 438
    score___0 = (short )((int )score___0 - (int )ply);
  }
#line 441
  new.sh = (unsigned char )((int )score___0 >> 8);
#line 442
  new.sl = (unsigned char )((int )score___0 & 255);
#line 444
  i___0 = (unsigned short)0;
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    if (! ((int )i___0 < 6)) {
#line 444
      goto while_break___0;
    }
    {
#line 446
    fseek(hashfile, (long )(sizeof(struct fileentry ) * ((hashix + (unsigned long )(2 * (int )i___0)) % (unsigned long )filesz)),
          0);
#line 450
    tmp___1 = fread((void */* __restrict  */)(& tmp), sizeof(struct fileentry ), (size_t )1,
                    (FILE */* __restrict  */)hashfile);
    }
#line 450
    if (! tmp___1) {
      {
#line 452
      perror("hashfile");
#line 453
      exit(1);
      }
    }
#line 456
    if (tmp.depth) {
      {
#line 456
      tmp___2 = Fbdcmp(tmp.bd, new.bd);
      }
#line 456
      if (! tmp___2) {
#line 457
        goto __Cont;
      }
    }
#line 459
    if ((int )tmp.depth == (int )depth) {
#line 460
      goto while_break___0;
    }
#line 462
    if (! tmp.depth) {
      {
#line 464
      fseek(hashfile, (long )(sizeof(struct fileentry ) * ((hashix + (unsigned long )(2 * (int )i___0)) % (unsigned long )filesz)),
            0);
#line 468
      fwrite((void const   */* __restrict  */)(& new), sizeof(struct fileentry ),
             (size_t )1, (FILE */* __restrict  */)hashfile);
#line 469
      FHashAdd ++;
      }
#line 471
      goto while_break___0;
    } else
#line 462
    if ((int )((short )tmp.depth) < (int )depth) {
      {
#line 464
      fseek(hashfile, (long )(sizeof(struct fileentry ) * ((hashix + (unsigned long )(2 * (int )i___0)) % (unsigned long )filesz)),
            0);
#line 468
      fwrite((void const   */* __restrict  */)(& new), sizeof(struct fileentry ),
             (size_t )1, (FILE */* __restrict  */)hashfile);
#line 469
      FHashAdd ++;
      }
#line 471
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 444
    i___0 = (unsigned short )((int )i___0 + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 474
  return;
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
void ZeroRPT(void) 
{ 


  {
#line 484
  if (ISZERO) {
    {
#line 486
    memset((void *)(rpthash), 0, sizeof(rpthash));
#line 487
    ISZERO = (short)0;
    }
  }
#line 489
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
void PutInEETable(short side , int score___0 ) 
{ 
  struct etable *ptbl ;

  {
  {
#line 504
  ptbl = & (*(etab[side]))[hashkey % 10001UL];
#line 505
  ptbl->ehashbd = hashbd;
#line 506
  ptbl->escore[0] = pscore[0];
#line 507
  ptbl->escore[1] = pscore[1];
#line 508
  ptbl->hung[0] = (signed char )hung[0];
#line 509
  ptbl->hung[1] = (signed char )hung[1];
#line 510
  ptbl->score = (short )score___0;
#line 513
  memcpy((void */* __restrict  */)(& ptbl->sscore), (void const   */* __restrict  */)(svalue),
         sizeof(svalue));
#line 516
  EADD ++;
  }
#line 518
  return;
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int CheckEETable(short side ) 
{ 
  struct etable *ptbl ;

  {
#line 530
  ptbl = & (*(etab[side]))[hashkey % 10001UL];
#line 532
  if (hashbd == ptbl->ehashbd) {
#line 533
    return (1);
  }
#line 535
  return (0);
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/util.c"
int ProbeEETable(short side , short *score___0 ) 
{ 
  struct etable *ptbl ;

  {
#line 547
  ptbl = & (*(etab[side]))[hashkey % 10001UL];
#line 549
  if (hashbd == ptbl->ehashbd) {
    {
#line 551
    pscore[0] = ptbl->escore[0];
#line 552
    pscore[1] = ptbl->escore[1];
#line 557
    memcpy((void */* __restrict  */)(svalue), (void const   */* __restrict  */)(& ptbl->sscore),
           sizeof(svalue));
#line 560
    *score___0 = ptbl->score;
#line 561
    hung[0] = (short )ptbl->hung[0];
#line 562
    hung[1] = (short )ptbl->hung[1];
#line 564
    EGET ++;
    }
#line 566
    return (1);
  }
#line 569
  return (0);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/pat2inc.c"
void ReadOpeningSequences(short *pindex ) ;
#line 40
void WriteOpeningSequences(short pindex ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
static char *patternfile  =    (char *)"../misc/gnushogi.pat";
#line 58 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
static void skipbb(char **s ) 
{ 


  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! ((int )*(*s) == 32)) {
#line 61
      if (! ((int )*(*s) == 124)) {
#line 61
        if (! ((int )*(*s) == 91)) {
#line 61
          goto while_break;
        }
      }
    }
#line 63
    if ((int )*(*s) == 91) {
      {
#line 65
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 65
        if (! ((int )*(*s) != 93)) {
#line 65
          goto while_break___0;
        }
#line 66
        (*s) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 69
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
static void skipi(char **s ) 
{ 


  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if ((int )*(*s) >= 48) {
#line 79
      if (! ((int )*(*s) <= 57)) {
#line 79
        goto while_break;
      }
    } else {
#line 79
      goto while_break;
    }
#line 80
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  skipbb(s);
  }
#line 83
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
static short ScanPiece(char **s , signed char *side , signed char *piece , signed char *square ) 
{ 
  short isp ;
  short isw ;
  short c ;
  short r ;

  {
#line 93
  if ((int )*(*s) == 43) {
#line 94
    isp = (short)1;
#line 94
    (*s) ++;
  } else {
#line 96
    isp = (short)0;
  }
#line 99
  c = (short)0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((int )c < 15)) {
#line 99
      goto while_break;
    }
#line 101
    isw = (short )((int )*(*s) == (int )*(" PLNSGBRPLNSBRK " + c));
#line 101
    if (isw) {
#line 101
      goto _L;
    } else
#line 101
    if ((int )*(*s) == (int )*(" plnsgbrplnsbrk " + c)) {
      _L: /* CIL Label */ 
#line 103
      if (isp) {
#line 103
        *piece = (signed char )promoted[c];
      } else {
#line 103
        *piece = (signed char )unpromoted[c];
      }
#line 104
      *side = (signed char )isw;
#line 105
      (*s) ++;
#line 106
      goto while_break;
    }
#line 99
    c = (short )((int )c + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if ((int )c == 15) {
#line 111
    return ((short)1);
  }
#line 113
  if ((int )*(*s) == 42) {
#line 116
    (*s) ++;
#line 117
    *square = (signed char )(81 + (int )*piece);
  } else {
#line 122
    c = (short)0;
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 122
      if (! ((int )c < 9)) {
#line 122
        goto while_break___0;
      }
#line 124
      if ((int )*(*s) == (int )*("987654321" + c)) {
#line 126
        (*s) ++;
#line 127
        goto while_break___0;
      }
#line 122
      c = (short )((int )c + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    if ((int )c >= 9) {
#line 132
      return ((short)1);
    }
#line 135
    r = (short)0;
    {
#line 135
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 135
      if (! ((int )r < 9)) {
#line 135
        goto while_break___1;
      }
#line 137
      if ((int )*(*s) == (int )*("ihgfedcba" + r)) {
#line 139
        (*s) ++;
#line 140
        goto while_break___1;
      }
#line 135
      r = (short )((int )r + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 144
    if ((int )r >= 9) {
#line 145
      return ((short)1);
    }
#line 148
    *square = (signed char )((int )r * 9 + (int )c);
  }
  {
#line 151
  skipbb(s);
  }
#line 152
  return ((short)0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
static short ScanPattern(char *s , short *pindex ) 
{ 
  signed char side ;
  signed char piece ;
  signed char square ;
  short tmp ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;

  {
  {
#line 160
  skipbb(& s);
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if ((int )*s >= 48) {
#line 162
      if (! ((int )*s <= 57)) {
#line 162
        goto while_break;
      }
    } else {
#line 162
      goto while_break;
    }
    {
#line 164
    tmp = *pindex;
#line 164
    *pindex = (short )((int )*pindex + 1);
#line 164
    tmp___0 = atoi((char const   *)s);
#line 164
    pattern_data[tmp] = (signed char )tmp___0;
#line 165
    skipi(& s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  tmp___1 = *pindex;
#line 168
  *pindex = (short )((int )*pindex + 1);
#line 168
  pattern_data[tmp___1] = (signed char)-3;
#line 169
  skipbb(& s);
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if ((int )*s == 0) {
#line 171
      goto while_break___0;
    } else
#line 171
    if ((int )*s == 10) {
#line 171
      goto while_break___0;
    }
    {
#line 173
    tmp___4 = ScanPiece(& s, & side, & piece, & square);
    }
#line 173
    if (tmp___4) {
#line 175
      return ((short)1);
    } else {
#line 179
      tmp___2 = *pindex;
#line 179
      *pindex = (short )((int )*pindex + 1);
#line 179
      pattern_data[tmp___2] = piece;
#line 180
      tmp___3 = *pindex;
#line 180
      *pindex = (short )((int )*pindex + 1);
#line 180
      if (side) {
#line 180
        pattern_data[tmp___3] = (signed char )(- ((int )square));
      } else {
#line 180
        pattern_data[tmp___3] = square;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  tmp___5 = *pindex;
#line 185
  *pindex = (short )((int )*pindex + 1);
#line 185
  pattern_data[tmp___5] = (signed char)-4;
#line 186
  return ((short)0);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
void ReadOpeningSequences(short *pindex ) 
{ 
  FILE *fd ;
  char s[256] ;
  short max_pattern ;
  short max_opening_sequence ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  char *tmp___4 ;
  short tmp___5 ;
  short tmp___6 ;

  {
  {
#line 195
  max_pattern = (short)0;
#line 196
  max_opening_sequence = (short)0;
#line 198
  fd = fopen((char const   */* __restrict  */)patternfile, (char const   */* __restrict  */)"r");
  }
#line 198
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 199
    fd = fopen((char const   */* __restrict  */)"gnushogi.pat", (char const   */* __restrict  */)"r");
    }
  }
#line 201
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
#line 203
    *pindex = (short)0;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 205
      tmp___4 = fgets((char */* __restrict  */)(s), 256, (FILE */* __restrict  */)fd);
      }
#line 205
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 205
        goto while_break;
      }
#line 207
      if (! ((int )s[0] == 35)) {
#line 211
        if ((int )s[0] >= 97) {
#line 211
          if ((int )s[0] <= 122) {
#line 211
            goto _L;
          } else {
#line 211
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 211
        if ((int )s[0] >= 65) {
#line 211
          if ((int )s[0] <= 90) {
            _L: /* CIL Label */ 
#line 213
            tmp___0 = max_opening_sequence;
#line 213
            max_opening_sequence = (short )((int )max_opening_sequence + 1);
#line 213
            if ((int )tmp___0 > 0) {
#line 215
              tmp = *pindex;
#line 215
              *pindex = (short )((int )*pindex + 1);
#line 215
              pattern_data[tmp] = (signed char)-2;
            }
            {
#line 218
            tmp___1 = *pindex;
#line 218
            *pindex = (short )((int )*pindex + 1);
#line 218
            tmp___2 = ValueOfOpeningName(s);
#line 218
            pattern_data[tmp___1] = (signed char )tmp___2;
            }
          } else {
#line 211
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 222
          tmp___3 = ScanPattern(s, pindex);
          }
#line 222
          if (tmp___3) {
            {
#line 224
            ShowMessage((char *)"error in pattern sequence...");
#line 225
            exit(1);
            }
          } else {
#line 229
            max_pattern = (short )((int )max_pattern + 1);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 234
    tmp___5 = *pindex;
#line 234
    *pindex = (short )((int )*pindex + 1);
#line 234
    pattern_data[tmp___5] = (signed char)-2;
#line 235
    tmp___6 = *pindex;
#line 235
    *pindex = (short )((int )*pindex + 1);
#line 235
    pattern_data[tmp___6] = (signed char)-1;
#line 237
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"Pattern: %d bytes for %d sequences with %d patterns.\n",
            (int )*pindex, (int )max_opening_sequence, (int )max_pattern);
#line 240
    ShowMessage(s);
#line 242
    fclose(fd);
    }
  } else {
    {
#line 244
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"no pattern file \'%s\'",
            patternfile);
#line 245
    ShowMessage(s);
    }
  }
#line 247
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/gnushogi-1.4.1/gnushogi/makepattern.c"
void WriteOpeningSequences(short pindex ) 
{ 
  FILE *fd ;
  short n ;
  short max_pattern ;
  short max_opening_sequence ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;

  {
  {
#line 254
  n = (short)0;
#line 255
  max_pattern = (short)0;
#line 256
  max_opening_sequence = (short)0;
#line 258
  fd = fopen((char const   */* __restrict  */)"pattern.inc", (char const   */* __restrict  */)"w");
#line 259
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"#define MAX_PATTERN_DATA %d\n\n",
          (int )pindex);
#line 260
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"small_short pattern_data[MAX_PATTERN_DATA] =\n{\n");
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 264
    tmp = n;
#line 264
    n = (short )((int )n + 1);
#line 264
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  %d,\n",
            (int )pattern_data[tmp]);
    }
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 268
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    ");
      }
      {
#line 271
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 271
        if (! ((int )pattern_data[n] != -3)) {
#line 271
          goto while_break___1;
        }
        {
#line 273
        tmp___0 = n;
#line 273
        n = (short )((int )n + 1);
#line 273
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d, ",
                (int )pattern_data[tmp___0]);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 276
      tmp___1 = n;
#line 276
      n = (short )((int )n + 1);
#line 276
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d, ",
              (int )pattern_data[tmp___1]);
      }
      {
#line 279
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 281
        tmp___2 = n;
#line 281
        n = (short )((int )n + 1);
#line 281
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d,",
                (int )pattern_data[tmp___2]);
        }
#line 279
        if (! ((int )pattern_data[n] != -4)) {
#line 279
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 285
      tmp___3 = n;
#line 285
      n = (short )((int )n + 1);
#line 285
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d,\n",
              (int )pattern_data[tmp___3]);
#line 286
      max_pattern = (short )((int )max_pattern + 1);
      }
#line 266
      if (! ((int )pattern_data[n] != -2)) {
#line 266
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 290
    tmp___4 = n;
#line 290
    n = (short )((int )n + 1);
#line 290
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"    %d,\n",
            (int )pattern_data[tmp___4]);
#line 291
    max_opening_sequence = (short )((int )max_opening_sequence + 1);
    }
#line 262
    if (! ((int )pattern_data[n] != -1)) {
#line 262
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  tmp___5 = n;
#line 295
  n = (short )((int )n + 1);
#line 295
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"  %d\n}; \n",
          (int )pattern_data[tmp___5]);
#line 296
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n#define MAX_OPENING_SEQUENCE %d\n",
          (int )max_opening_sequence);
#line 297
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n#define MAX_PATTERN %d\n",
          (int )max_pattern);
#line 298
  fclose(fd);
  }
#line 299
  return;
}
}
