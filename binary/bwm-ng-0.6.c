/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 34 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct inout_long {
   unsigned long long in ;
   unsigned long long out ;
};
#line 40 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct inouttotal_double {
   long double in ;
   long double out ;
   long double total ;
};
#line 46 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct double_types {
   struct inouttotal_double bytes ;
   struct inouttotal_double packets ;
   struct inouttotal_double errors ;
};
#line 53 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct iface_speed_stats {
   struct inout_long bytes ;
   struct inout_long packets ;
   struct inout_long errors ;
};
#line 59 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
typedef struct iface_speed_stats t_iface_speed_stats;
#line 62 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct double_list {
   struct double_types data ;
   struct double_list *next ;
};
#line 67 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct t_avg {
   struct double_list *first ;
   struct double_list *last ;
   int items ;
   struct double_types item_sum ;
};
#line 77 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
struct iface_stats {
   char *if_name ;
   t_iface_speed_stats data ;
   struct double_types max ;
   struct iface_speed_stats sum ;
   struct t_avg avg ;
   struct timeval time ;
};
#line 90 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
typedef struct iface_stats t_iface_stats;
#line 91 "/home/june/collector/temp/bwm-ng-0.6/src/types.h"
typedef struct double_types t_double_types;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_59 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_59 sync_serial_settings;
#line 45 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_60 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_60 te1_settings;
#line 52 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_61 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_61 raw_hdlc_proto;
#line 57 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_62 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_62 fr_proto;
#line 67 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_63 {
   unsigned int dlci ;
};
#line 67 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_63 fr_proto_pvc;
#line 71 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_64 {
   unsigned int dlci ;
   char master[16] ;
};
#line 71 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_64 fr_proto_pvc_info;
#line 76 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_65 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_65 cisco_proto;
#line 143 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 153 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_68 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 153 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_68 ifs_ifsu ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_69 {
   char ifrn_name[16] ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_70 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 177 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_69 ifr_ifrn ;
   union __anonunion_ifr_ifru_70 ifr_ifru ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 699
extern int mvwprintw(WINDOW * , int  , int  , char const   *  , ...) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 1386
extern WINDOW *stdscr ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 44 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned int delay ;
#line 46
unsigned int avg_length ;
#line 48
char output_unit ;
#line 49
char output_type ;
#line 50
char dynamic ;
#line 52
char show_all_if ;
#line 54
int output_method ;
#line 56
unsigned short cols ;
#line 57
unsigned short rows ;
#line 58
unsigned int max_rt ;
#line 59
unsigned int scale ;
#line 60
unsigned int show_only_if ;
#line 66
char csv_char ;
#line 69
FILE *out_file ;
#line 75
char ansi_output ;
#line 77
int input_method ;
#line 80
int html_refresh ;
#line 81
int html_header ;
#line 35 "/home/june/collector/temp/bwm-ng-0.6/src/output.h"
int print_header(int option ) ;
#line 36
void print_values(int y , int x , char *if_name , t_iface_speed_stats stats , float multiplier ,
                  t_iface_stats full_stats ) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
static char str[25]  ;
#line 28 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
__inline char *output_type2str(void) 
{ 


  {
  {
#line 33
  if ((int )output_type == 1) {
#line 33
    goto case_1;
  }
#line 37
  if ((int )output_type == 2) {
#line 37
    goto case_2;
  }
#line 40
  if ((int )output_type == 3) {
#line 40
    goto case_3;
  }
#line 43
  if ((int )output_type == 4) {
#line 43
    goto case_4;
  }
#line 32
  goto switch_break;
  case_1: /* CIL Label */ 
#line 34
  return ((char *)"rate");
#line 35
  goto switch_break;
  case_2: /* CIL Label */ 
#line 38
  return ((char *)"max");
#line 39
  goto switch_break;
  case_3: /* CIL Label */ 
#line 41
  return ((char *)"sum");
#line 42
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 44
  snprintf((char */* __restrict  */)(str), (size_t )24, (char const   */* __restrict  */)"avg (%is)",
           (int )avg_length / 1000);
  }
#line 45
  return (str);
#line 46
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 49
  return ((char *)"");
}
}
#line 53 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
__inline char *input2str(void) 
{ 


  {
  {
#line 66
  if (input_method == 1) {
#line 66
    goto case_1;
  }
#line 89
  if (input_method == 2) {
#line 89
    goto case_2;
  }
#line 107
  if (input_method == 128) {
#line 107
    goto case_128;
  }
#line 54
  goto switch_break;
  case_1: /* CIL Label */ 
#line 67
  return ((char *)"netstat -i");
#line 68
  goto switch_break;
  case_2: /* CIL Label */ 
#line 90
  return ((char *)"/proc/net/dev");
#line 91
  goto switch_break;
  case_128: /* CIL Label */ 
#line 108
  return ((char *)"disk IO");
#line 109
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 112
  return ((char *)"");
}
}
#line 115 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
__inline char *show_all_if2str(void) 
{ 


  {
  {
#line 117
  if ((int )show_all_if == 1) {
#line 117
    goto case_1;
  }
#line 120
  if ((int )show_all_if == 2) {
#line 120
    goto case_2;
  }
#line 116
  goto switch_break;
  case_1: /* CIL Label */ 
#line 118
  return ((char *)" (all)");
#line 119
  goto switch_break;
  case_2: /* CIL Label */ 
#line 121
  if (input_method & 3) {
#line 122
    return ((char *)" (all and down)");
  } else {
#line 124
    return ((char *)" (all)");
  }
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 127
  return ((char *)"");
}
}
#line 132 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
int print_header(int option ) 
{ 
  FILE *tmp_out_file ;
  unsigned int row ;
  unsigned int col ;
  unsigned int width ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 137
  row = 0U;
#line 138
  col = 0U;
#line 139
  width = 0U;
  {
#line 143
  if (output_method == 0) {
#line 143
    goto case_0;
  }
#line 154
  if (output_method == 5) {
#line 154
    goto case_5;
  }
#line 216
  if (output_method == 3) {
#line 216
    goto case_3;
  }
#line 233
  if (output_method == 1) {
#line 233
    goto case_1;
  }
#line 233
  if (output_method == 4) {
#line 233
    goto case_1;
  }
#line 141
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 144
  werase(stdscr);
#line 145
  mvwprintw(stdscr, 1, 2, "bwm-ng v0.6 (probing every %2.3fs), press \'h\' for help",
            (double )((float )delay / (float )1000));
#line 146
  tmp = output_type2str();
#line 146
  tmp___0 = input2str();
#line 146
  mvwprintw(stdscr, 2, 2, "input: %s type: %s", tmp___0, tmp);
#line 147
  tmp___1 = show_all_if2str();
#line 147
  wprintw(stdscr, (char const   *)tmp___1);
#line 148
  mvwprintw(stdscr, 3, 2, "%c         iface                   Rx                   Tx                Total",
            (int )((char )*("-\\|/" + option)));
#line 150
  option ++;
  }
#line 151
  if (option > 3) {
#line 151
    option = 0;
  }
  {
#line 152
  mvwprintw(stdscr, 4, 2, "==============================================================================");
  }
#line 153
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 155
  werase(stdscr);
  }
#line 156
  if ((int )cols < 48) {
    {
#line 157
    mvwprintw(stdscr, 1, 2, "window size too small.\n  it has to be at least 48x45.");
    }
  } else
#line 156
  if ((int )rows < 45) {
    {
#line 157
    mvwprintw(stdscr, 1, 2, "window size too small.\n  it has to be at least 48x45.");
    }
  } else {
    {
#line 159
    width = (unsigned int )(((((int )cols - 3) - 16) - 4) / 3);
#line 160
    mvwprintw(stdscr, 1, 2, "+---{ bwm-ng v0.6 }");
#line 161
    col = (unsigned int )(17UL + sizeof("0.6"));
    }
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! (col < (unsigned int )((32 + (int )cols) - 48))) {
#line 161
        goto while_break;
      }
      {
#line 162
      mvwprintw(stdscr, 1, (int )col, "-");
#line 161
      col ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 163
    mvwprintw(stdscr, 1, (32 + (int )cols) - 48, "+- -- - -- -->");
#line 164
    mvwprintw(stdscr, 2, 2, "|");
#line 164
    mvwprintw(stdscr, 2, (32 + (int )cols) - 48, "|------.");
#line 165
    col = 0U;
    }
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      if (! (col < width - 2U)) {
#line 165
        goto while_break___0;
      }
      {
#line 166
      tmp___2 = wmove(stdscr, 2, (int )(col + 6U));
      }
#line 166
      if (! (tmp___2 == -1)) {
        {
#line 166
        waddch(stdscr, (chtype const   )acs_map[(unsigned char )'q']);
        }
      }
      {
#line 167
      wattr_on(stdscr, 1UL << 8, (void *)0);
#line 167
      mvwprintw(stdscr, 35, (int )(col + 6U), " ");
#line 167
      wattr_off(stdscr, 1UL << 8, (void *)0);
#line 168
      tmp___3 = wmove(stdscr, 2, (int )((2U * width + 6U) + col));
      }
#line 168
      if (! (tmp___3 == -1)) {
        {
#line 168
        waddch(stdscr, (chtype const   )acs_map[(unsigned char )'q']);
        }
      }
      {
#line 169
      wattr_on(stdscr, 2UL << 8, (void *)0);
#line 169
      mvwprintw(stdscr, 35, (int )((2U * width + 6U) + col), " ");
#line 169
      wattr_off(stdscr, 2UL << 8, (void *)0);
#line 165
      col ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 171
    row = 3U;
    {
#line 171
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 171
      if (! (row <= 36U)) {
#line 171
        goto while_break___1;
      }
      {
#line 172
      mvwprintw(stdscr, (int )row, 2, "|");
#line 173
      mvwprintw(stdscr, (int )row, (32 + (int )cols) - 48, "|");
#line 171
      row ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 175
    mvwprintw(stdscr, 34, (33 + (int )cols) - 48, "<");
#line 175
    mvwprintw(stdscr, 35, (33 + (int )cols) - 48, "------\'");
#line 176
    mvwprintw(stdscr, 36, (int )((width - 8U) / 2U + 5U), "%c%c%cRx%c%c%c", (int const   )*("   >--<   " + (option + 2)),
              (int const   )*("   >--<   " + (option + 1)), (int const   )*("   >--<   " + option),
              (int const   )*("   >--<   " + (9 - option)), (int const   )*("   >--<   " + (8 - option)),
              (int const   )*("   >--<   " + (7 - option)));
#line 183
    mvwprintw(stdscr, 36, (int )(((width - 8U) / 2U + 5U) + 2U * width), "%c%c%cTx%c%c%c",
              (int const   )*("   >--<   " + (9 - option)), (int const   )*("   >--<   " + (8 - option)),
              (int const   )*("   >--<   " + (7 - option)), (int const   )*("   >--<   " + (option + 2)),
              (int const   )*("   >--<   " + (option + 1)), (int const   )*("   >--<   " + option));
#line 192
    mvwprintw(stdscr, 37, 2, "+");
#line 192
    mvwprintw(stdscr, 37, (32 + (int )cols) - 48, "+");
#line 193
    col = 3U;
    }
    {
#line 193
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 193
      if (! (col < (unsigned int )((32 + (int )cols) - 48))) {
#line 193
        goto while_break___2;
      }
      {
#line 194
      mvwprintw(stdscr, 37, (int )col, "-");
#line 193
      col ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 196
    mvwprintw(stdscr, 38, 2, "`+--> %c probing every: %2.3fs", (int )((char )*("-\\|/" + option)),
              (double )((float )delay / (float )1000));
#line 197
    mvwprintw(stdscr, 39, 2, " +-----> interface: wait...   ");
#line 198
    tmp___4 = output_type2str();
#line 198
    mvwprintw(stdscr, 40, 2, " +--------> type: %s", tmp___4);
#line 199
    tmp___5 = input2str();
#line 199
    mvwprintw(stdscr, 41, 2, " `-----------> input: %s", tmp___5);
#line 200
    scale = max_rt / 32U;
    }
#line 202
    if (max_rt >= 1024U) {
#line 203
      row = 0U;
      {
#line 203
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 203
        if (! (row <= 31U)) {
#line 203
          goto while_break___3;
        }
        {
#line 204
        mvwprintw(stdscr, (int )(row + 3U), (34 + (int )cols) - 48, "%2.2fM|", (double )((float )(max_rt - row * scale) / (float )1024));
#line 203
        row ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 206
      row = 0U;
      {
#line 206
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 206
        if (! (row <= 31U)) {
#line 206
          goto while_break___4;
        }
        {
#line 207
        mvwprintw(stdscr, (int )(row + 3U), (34 + (int )cols) - 48, "%4uk|", max_rt - row * scale);
#line 206
        row ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 211
  option ++;
#line 212
  if (option > 3) {
#line 212
    option = 0;
  }
#line 213
  goto switch_break;
  case_3: /* CIL Label */ 
#line 217
  if ((unsigned long )out_file == (unsigned long )((void *)0)) {
#line 217
    tmp_out_file = stdout;
  } else {
#line 217
    tmp_out_file = out_file;
  }
#line 218
  if (html_header) {
    {
#line 219
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n<head>\n");
#line 220
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n");
#line 221
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<META HTTP-EQUIV=Refresh CONTENT=\"%i\">\n",
            html_refresh);
#line 222
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<link rel=\"stylesheet\" href=\"bwm-ng.css\" type=\"text/css\" media=\"screen,projection,print\">\n");
#line 223
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<title>bwm-ng stats</title>\n</head>\n<body>\n");
    }
  }
  {
#line 225
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<div class=\"bwm-ng-header\">bwm-ng bwm-ng v0.6 (refresh %is); input: ",
          html_refresh);
#line 226
  tmp___6 = input2str();
#line 226
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%s",
          tmp___6);
#line 227
  tmp___7 = show_all_if2str();
#line 227
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%s",
          tmp___7);
#line 228
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"</div><table class=\"bwm-ng-output\">");
#line 229
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<tr class=\"bwm-ng-head\"><td class=\"bwm-ng-name\">Interface</td><td>Rx</td><td>Tx</td><td>Total</td></tr>");
  }
#line 230
  goto switch_break;
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 234
  if (output_method == 1) {
#line 234
    if (ansi_output) {
      {
#line 234
      printf((char const   */* __restrict  */)"\033[1;2H");
      }
    }
  }
  {
#line 235
  printf((char const   */* __restrict  */)"bwm-ng v0.6 (delay %2.3fs); ", (double )((float )delay / (float )1000));
  }
#line 236
  if (output_method == 1) {
#line 236
    if (ansi_output) {
#line 236
      tmp___8 = "\033[2;2H";
    } else {
#line 236
      tmp___8 = "";
    }
    {
#line 236
    printf((char const   */* __restrict  */)"press \'ctrl-c\' to end this%s", tmp___8);
    }
  } else {
    {
#line 236
    printf((char const   */* __restrict  */)"input: ");
    }
  }
  {
#line 237
  tmp___9 = input2str();
#line 237
  printf((char const   */* __restrict  */)"%s", tmp___9);
#line 238
  tmp___10 = show_all_if2str();
#line 238
  printf((char const   */* __restrict  */)"%s\n", tmp___10);
  }
#line 239
  if (output_method == 1) {
#line 240
    if (ansi_output) {
      {
#line 241
      printf((char const   */* __restrict  */)"\033[3;2H");
      }
    }
    {
#line 242
    printf((char const   */* __restrict  */)"%c", (int )((char )*("-\\|/" + option)));
    }
  } else {
    {
#line 243
    printf((char const   */* __restrict  */)" ");
    }
  }
  {
#line 244
  printf((char const   */* __restrict  */)"         iface                    Rx                   Tx               Total\n");
  }
#line 245
  if (output_method == 1) {
#line 245
    if (ansi_output) {
      {
#line 245
      printf((char const   */* __restrict  */)"\033[4;2H");
      }
    }
  }
  {
#line 246
  printf((char const   */* __restrict  */)"==============================================================================\n");
#line 248
  option ++;
  }
#line 249
  if (option > 3) {
#line 249
    option = 0;
  }
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 252
  return (option);
}
}
#line 256 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
__inline unsigned long long direction2value(char mode , struct inout_long stats ) 
{ 


  {
  {
#line 258
  if ((int )mode == 0) {
#line 258
    goto case_0;
  }
#line 260
  if ((int )mode == 1) {
#line 260
    goto case_1;
  }
#line 262
  if ((int )mode == 2) {
#line 262
    goto case_2;
  }
#line 257
  goto switch_break;
  case_0: /* CIL Label */ 
#line 259
  return (stats.in);
  case_1: /* CIL Label */ 
#line 261
  return (stats.out);
  case_2: /* CIL Label */ 
#line 263
  return (stats.in + stats.out);
  switch_break: /* CIL Label */ ;
  }
#line 265
  return (0ULL);
}
}
#line 269 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
__inline double direction_max2value(char mode , struct inouttotal_double stats , int items ) 
{ 


  {
  {
#line 271
  if ((int )mode == 0) {
#line 271
    goto case_0;
  }
#line 273
  if ((int )mode == 1) {
#line 273
    goto case_1;
  }
#line 275
  if ((int )mode == 2) {
#line 275
    goto case_2;
  }
#line 270
  goto switch_break;
  case_0: /* CIL Label */ 
#line 272
  return ((double )(stats.in / (long double )items));
  case_1: /* CIL Label */ 
#line 274
  return ((double )(stats.out / (long double )items));
  case_2: /* CIL Label */ 
#line 276
  return ((double )(stats.total / (long double )items));
  switch_break: /* CIL Label */ ;
  }
#line 278
  return ((double )0);
}
}
#line 282 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
__inline char *dyn_byte_value2str(double value , char *str___0 , int buf_size ) 
{ 


  {
#line 283
  if (dynamic) {
#line 284
    if (value < (double )1024) {
      {
#line 285
      snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%15.2f  ",
               value);
      }
    } else
#line 287
    if (value < (double )1048576) {
      {
#line 288
      snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%15.2f K",
               value / (double )1024);
      }
    } else
#line 290
    if (value < (double )1073741824) {
      {
#line 291
      snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%15.2f M",
               value / (double )1048576);
      }
    } else {
      {
#line 293
      snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%15.2f G",
               value / (double )1073741824);
      }
    }
  } else {
    {
#line 295
    snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%15.2f K",
             value / (double )1024);
    }
  }
#line 297
  return (str___0);
}
}
#line 300 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
char *values2str(char mode , t_iface_speed_stats stats , t_iface_stats full_stats ,
                 float multiplier , char *str___0 , int buf_size ) 
{ 
  char byte_char ;
  char speed[3] ;
  double value ;
  char *str_buf ;
  unsigned long long tmp ;
  unsigned long long tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  unsigned long long tmp___4 ;
  unsigned long long tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  unsigned long long tmp___10 ;
  unsigned long long tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;

  {
#line 301
  byte_char = (char )' ';
#line 303
  value = (double )0;
#line 304
  str_buf = (char *)((void *)0);
#line 305
  if ((int )output_type == 1) {
    {
#line 311
    strncpy((char */* __restrict  */)(speed), (char const   */* __restrict  */)"/s",
            (size_t )3);
#line 311
    speed[2] = (char )'\000';
    }
  } else
#line 305
  if ((int )output_type == 2) {
    {
#line 311
    strncpy((char */* __restrict  */)(speed), (char const   */* __restrict  */)"/s",
            (size_t )3);
#line 311
    speed[2] = (char )'\000';
    }
  } else
#line 305
  if ((int )output_type == 4) {
    {
#line 311
    strncpy((char */* __restrict  */)(speed), (char const   */* __restrict  */)"/s",
            (size_t )3);
#line 311
    speed[2] = (char )'\000';
    }
  } else {
    {
#line 313
    strncpy((char */* __restrict  */)(speed), (char const   */* __restrict  */)"  ",
            (size_t )3);
#line 313
    speed[2] = (char )'\000';
    }
  }
#line 315
  if (input_method == 1) {
#line 315
    goto _L;
  } else
#line 315
  if ((int )output_unit == 3) {
    _L: /* CIL Label */ 
    {
#line 321
    if ((int )output_type == 1) {
#line 321
      goto case_1;
    }
#line 325
    if ((int )output_type == 3) {
#line 325
      goto case_3;
    }
#line 328
    if ((int )output_type == 2) {
#line 328
      goto case_2;
    }
#line 331
    if ((int )output_type == 4) {
#line 331
      goto case_4;
    }
#line 320
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 322
    tmp = direction2value(mode, stats.packets);
#line 322
    value = (double )tmp * (double )multiplier;
    }
#line 323
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 326
    tmp___0 = direction2value(mode, full_stats.sum.packets);
#line 326
    value = (double )tmp___0;
    }
#line 327
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 329
    tmp___1 = direction_max2value(mode, full_stats.max.packets, 1);
#line 329
    value = tmp___1;
    }
#line 330
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 332
    tmp___2 = direction_max2value(mode, full_stats.avg.item_sum.packets, full_stats.avg.items);
#line 332
    value = tmp___2;
    }
#line 333
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 336
    if (input_method & 3) {
#line 336
      tmp___3 = 'P';
    } else {
#line 336
      tmp___3 = '#';
    }
    {
#line 336
    snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%16.2f %c%s",
             value, tmp___3, speed);
    }
  } else {
    {
#line 340
    if ((int )output_unit == 1) {
#line 340
      goto case_1___0;
    }
#line 340
    if ((int )output_unit == 2) {
#line 340
      goto case_1___0;
    }
#line 364
    if ((int )output_unit == 4) {
#line 364
      goto case_4___1;
    }
#line 338
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    {
#line 342
    if ((int )output_type == 1) {
#line 342
      goto case_1___1;
    }
#line 346
    if ((int )output_type == 3) {
#line 346
      goto case_3___0;
    }
#line 349
    if ((int )output_type == 2) {
#line 349
      goto case_2___1;
    }
#line 352
    if ((int )output_type == 4) {
#line 352
      goto case_4___0;
    }
#line 341
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 343
    tmp___4 = direction2value(mode, stats.bytes);
#line 343
    value = (double )tmp___4 * (double )multiplier;
    }
#line 344
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    {
#line 347
    tmp___5 = direction2value(mode, full_stats.sum.bytes);
#line 347
    value = (double )tmp___5;
    }
#line 348
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 350
    tmp___6 = direction_max2value(mode, full_stats.max.bytes, 1);
#line 350
    value = tmp___6;
    }
#line 351
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
#line 353
    tmp___7 = direction_max2value(mode, full_stats.avg.item_sum.bytes, full_stats.avg.items);
#line 353
    value = tmp___7;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 356
    if ((int )output_unit == 2) {
#line 357
      byte_char = (char )'b';
#line 358
      value *= (double )8;
    } else {
#line 360
      byte_char = (char )'B';
    }
    {
#line 361
    tmp___8 = malloc((size_t )buf_size);
#line 361
    str_buf = (char *)tmp___8;
#line 362
    tmp___9 = dyn_byte_value2str(value, str_buf, buf_size);
#line 362
    snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%s%c%s",
             tmp___9, (int )byte_char, speed);
    }
#line 363
    goto switch_break___0;
    case_4___1: /* CIL Label */ 
    {
#line 366
    if ((int )output_type == 1) {
#line 366
      goto case_1___2;
    }
#line 370
    if ((int )output_type == 3) {
#line 370
      goto case_3___1;
    }
#line 373
    if ((int )output_type == 2) {
#line 373
      goto case_2___2;
    }
#line 376
    if ((int )output_type == 4) {
#line 376
      goto case_4___2;
    }
#line 365
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 367
    tmp___10 = direction2value(mode, stats.errors);
#line 367
    value = (double )tmp___10 * (double )multiplier;
    }
#line 368
    goto switch_break___2;
    case_3___1: /* CIL Label */ 
    {
#line 371
    tmp___11 = direction2value(mode, full_stats.sum.errors);
#line 371
    value = (double )tmp___11;
    }
#line 372
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
    {
#line 374
    tmp___12 = direction_max2value(mode, full_stats.max.errors, 1);
#line 374
    value = tmp___12;
    }
#line 375
    goto switch_break___2;
    case_4___2: /* CIL Label */ 
    {
#line 377
    tmp___13 = direction_max2value(mode, full_stats.avg.item_sum.errors, full_stats.avg.items);
#line 377
    value = tmp___13;
    }
#line 378
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 381
    snprintf((char */* __restrict  */)str___0, (size_t )buf_size, (char const   */* __restrict  */)"%16.2f E%s",
             value, speed);
    }
#line 382
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 385
  if ((unsigned long )str_buf != (unsigned long )((void *)0)) {
    {
#line 385
    free((void *)str_buf);
    }
  }
#line 386
  return (str___0);
}
}
#line 390 "/home/june/collector/temp/bwm-ng-0.6/src/output.c"
void print_values(int y , int x , char *if_name , t_iface_speed_stats stats , float multiplier ,
                  t_iface_stats full_stats ) 
{ 
  char buffer[50] ;
  FILE *tmp_out_file ;
  t_iface_speed_stats *stats_csv ;
  t_double_types stats_csv_d ;
  unsigned int row ;
  unsigned int col ;
  unsigned int width ;
  int i ;
  int j ;
  char adjust ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  time_t tmp___14 ;

  {
#line 395
  stats_csv = (t_iface_speed_stats *)((void *)0);
#line 398
  row = 0U;
#line 399
  col = 0U;
#line 400
  width = 0U;
#line 401
  i = 0;
#line 401
  j = 0;
#line 402
  adjust = (char)0;
  {
#line 406
  if (output_method == 0) {
#line 406
    goto case_0;
  }
#line 432
  if (output_method == 5) {
#line 432
    goto case_5;
  }
#line 490
  if (output_method == 1) {
#line 490
    goto case_1___0;
  }
#line 490
  if (output_method == 4) {
#line 490
    goto case_1___0;
  }
#line 499
  if (output_method == 3) {
#line 499
    goto case_3___0;
  }
#line 513
  if (output_method == 2) {
#line 513
    goto case_2___0;
  }
#line 404
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 407
  mvwprintw(stdscr, y, x, "%15s:", if_name);
  }
#line 409
  if (stats.errors.in) {
#line 409
    if ((int )output_unit != 4) {
      {
#line 409
      wattr_on(stdscr, 1UL << 18, (void *)0);
      }
    }
  }
  {
#line 411
  tmp = values2str((char)0, stats, full_stats, multiplier, buffer, 49);
#line 411
  wprintw(stdscr, "%s", tmp);
  }
#line 413
  if (stats.errors.in) {
#line 413
    if ((int )output_unit != 4) {
      {
#line 413
      wattr_off(stdscr, 1UL << 18, (void *)0);
      }
    }
  }
  {
#line 415
  wprintw(stdscr, " ");
  }
#line 417
  if (stats.errors.out) {
#line 417
    if ((int )output_unit != 4) {
      {
#line 417
      wattr_on(stdscr, 1UL << 18, (void *)0);
      }
    }
  }
  {
#line 419
  tmp___0 = values2str((char)1, stats, full_stats, multiplier, buffer, 49);
#line 419
  wprintw(stdscr, "%s", tmp___0);
  }
#line 421
  if (stats.errors.out) {
#line 421
    if ((int )output_unit != 4) {
      {
#line 421
      wattr_off(stdscr, 1UL << 18, (void *)0);
      }
    }
  }
  {
#line 423
  wprintw(stdscr, " ");
  }
#line 425
  if (stats.errors.out) {
#line 425
    goto _L;
  } else
#line 425
  if (stats.errors.in) {
    _L: /* CIL Label */ 
#line 425
    if ((int )output_unit != 4) {
      {
#line 425
      wattr_on(stdscr, 1UL << 18, (void *)0);
      }
    }
  }
  {
#line 427
  tmp___1 = values2str((char)2, stats, full_stats, multiplier, buffer, 49);
#line 427
  wprintw(stdscr, "%s", tmp___1);
  }
#line 429
  if (stats.errors.out) {
#line 429
    goto _L___0;
  } else
#line 429
  if (stats.errors.in) {
    _L___0: /* CIL Label */ 
#line 429
    if ((int )output_unit != 4) {
      {
#line 429
      wattr_off(stdscr, 1UL << 18, (void *)0);
      }
    }
  }
#line 431
  goto switch_break;
  case_5: /* CIL Label */ 
#line 433
  if ((int )cols < 48) {
    {
#line 433
    mvwprintw(stdscr, 1, 2, "window size too small.\n  it has to be at least 49x46.");
    }
  } else
#line 433
  if ((int )rows < 45) {
    {
#line 433
    mvwprintw(stdscr, 1, 2, "window size too small.\n  it has to be at least 49x46.");
    }
  } else
#line 435
  if (show_only_if + 5U == (unsigned int )y) {
    {
#line 436
    width = (unsigned int )(((((int )cols - 3) - 16) - 4) / 3);
#line 437
    mvwprintw(stdscr, 39, 2, " +-----> interface: %s        ", if_name);
    }
    {
#line 439
    if ((int )output_type == 1) {
#line 439
      goto case_1;
    }
#line 444
    if ((int )output_type == 2) {
#line 444
      goto case_2;
    }
#line 448
    if ((int )output_type == 3) {
#line 448
      goto case_3;
    }
#line 452
    if ((int )output_type == 4) {
#line 452
      goto case_4;
    }
#line 438
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 440
    i = (int )(((float )stats.bytes.in * multiplier) / (float )1024);
#line 441
    j = (int )(((float )stats.bytes.out * multiplier) / (float )1024);
#line 442
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 445
    i = (int )(full_stats.max.bytes.in / (long double )1024);
#line 446
    j = (int )(full_stats.max.bytes.out / (long double )1024);
#line 447
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 449
    i = (int )(full_stats.sum.bytes.in / 1024ULL);
#line 450
    j = (int )(full_stats.sum.bytes.out / 1024ULL);
#line 451
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 453
    i = (int )(full_stats.avg.item_sum.bytes.in / (long double )1024);
#line 454
    j = (int )(full_stats.avg.item_sum.bytes.out / (long double )1024);
#line 455
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 459
    if ((unsigned int )i > max_rt) {
#line 459
      goto _L___1;
    } else
#line 459
    if ((unsigned int )j > max_rt) {
      _L___1: /* CIL Label */ 
#line 460
      adjust = (char)1;
#line 461
      if (i > j) {
#line 461
        max_rt = (unsigned int )i;
      } else {
#line 461
        max_rt = (unsigned int )j;
      }
    } else
#line 462
    if ((unsigned int )i <= max_rt - 24U * scale) {
#line 462
      if ((unsigned int )j <= max_rt - 24U * scale) {
#line 462
        adjust = (char)1;
#line 462
        max_rt = 31U * scale;
      }
    }
#line 463
    if (adjust) {
#line 464
      adjust = (char )(! adjust);
#line 465
      if (max_rt < 32U) {
#line 465
        max_rt = 32U;
      }
#line 467
      scale = max_rt / 32U;
#line 468
      if (max_rt >= 1024U) {
#line 468
        row = 0U;
        {
#line 468
        while (1) {
          while_continue: /* CIL Label */ ;
#line 468
          if (! (row <= 31U)) {
#line 468
            goto while_break;
          }
          {
#line 468
          mvwprintw(stdscr, (int )(row + 3U), (34 + (int )cols) - 48, "%2.2fM|", (double )((float )(max_rt - row * scale) / (float )1024));
#line 468
          row ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 469
        row = 0U;
        {
#line 469
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 469
          if (! (row <= 31U)) {
#line 469
            goto while_break___0;
          }
          {
#line 469
          mvwprintw(stdscr, (int )(row + 3U), (3 + (int )cols) - 484, "%4uk|", max_rt - row * scale);
#line 469
          row ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 472
    if (i > 0) {
#line 472
      if ((unsigned int )i < max_rt - 31U * scale) {
#line 472
        i = 1;
      } else {
#line 472
        i = (int )(((unsigned int )i - (max_rt - 31U * scale)) / scale + 2U);
      }
    }
#line 473
    row = 34U;
    {
#line 473
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 473
      if (! (row >= 3U)) {
#line 473
        goto while_break___1;
      }
#line 474
      if (i > 0) {
        {
#line 474
        wattr_on(stdscr, 1UL << 8, (void *)0);
        }
      }
#line 475
      col = 0U;
      {
#line 475
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 475
        if (! (col < width)) {
#line 475
          goto while_break___2;
        }
        {
#line 475
        tmp___2 = wmove(stdscr, (int )row, (int )(col + 5U));
        }
#line 475
        if (! (tmp___2 == -1)) {
          {
#line 475
          waddch(stdscr, (chtype const   )acs_map[(unsigned char )'q']);
          }
        }
#line 475
        col ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 476
      if (i > 0) {
        {
#line 476
        wattr_off(stdscr, 1UL << 8, (void *)0);
#line 476
        i --;
        }
      }
#line 473
      row --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 479
    if (j > 0) {
#line 479
      if ((unsigned int )j < max_rt - 31U * scale) {
#line 479
        j = 1;
      } else {
#line 479
        j = (int )(((unsigned int )j - (max_rt - 31U * scale)) / scale + 2U);
      }
    }
#line 480
    row = 34U;
    {
#line 480
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 480
      if (! (row >= 3U)) {
#line 480
        goto while_break___3;
      }
#line 481
      if (j > 0) {
        {
#line 481
        wattr_on(stdscr, 2UL << 8, (void *)0);
        }
      }
#line 482
      col = 0U;
      {
#line 482
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 482
        if (! (col < width)) {
#line 482
          goto while_break___4;
        }
        {
#line 482
        tmp___3 = wmove(stdscr, (int )row, (int )((2U * width + 5U) + col));
        }
#line 482
        if (! (tmp___3 == -1)) {
          {
#line 482
          waddch(stdscr, (chtype const   )acs_map[(unsigned char )'q']);
          }
        }
#line 482
        col ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 483
      if (j > 0) {
        {
#line 483
        wattr_off(stdscr, 2UL << 8, (void *)0);
#line 483
        j --;
        }
      }
#line 480
      row --;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 485
  if (show_only_if + 6U == (unsigned int )y) {
    {
#line 485
    tmp___4 = strcmp("total", (char const   *)if_name);
    }
#line 485
    if (tmp___4 == 0) {
#line 485
      show_only_if = 0U;
    }
  }
#line 487
  goto switch_break;
  case_1___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
#line 491
  if (output_method == 1) {
#line 491
    if (ansi_output) {
      {
#line 491
      printf((char const   */* __restrict  */)"\033[%d;2H", y);
      }
    }
  }
  {
#line 492
  printf((char const   */* __restrict  */)"%15s:", if_name);
#line 493
  tmp___5 = values2str((char)2, stats, full_stats, multiplier, buffer, 49);
#line 493
  tmp___6 = values2str((char)1, stats, full_stats, multiplier, buffer, 49);
#line 493
  tmp___7 = values2str((char)0, stats, full_stats, multiplier, buffer, 49);
#line 493
  printf((char const   */* __restrict  */)"%s %s %s\n", tmp___7, tmp___6, tmp___5);
  }
#line 497
  goto switch_break;
  case_3___0: /* CIL Label */ 
#line 500
  if ((unsigned long )out_file == (unsigned long )((void *)0)) {
#line 500
    tmp_out_file = stdout;
  } else {
#line 500
    tmp_out_file = out_file;
  }
#line 501
  if (stats.errors.in) {
#line 501
    if ((int )output_unit != 4) {
#line 501
      tmp___8 = "error";
    } else {
#line 501
      tmp___8 = "dummy";
    }
  } else {
#line 501
    tmp___8 = "dummy";
  }
  {
#line 501
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"<tr><td class=\"bwm-ng-name\">%15s:</td><td class=\"bwm-ng-in\"><span class=\"bwm-ng-%s\">",
          if_name, tmp___8);
  }
#line 503
  if (stats.errors.out) {
#line 503
    if ((int )output_unit != 4) {
#line 503
      tmp___9 = "error";
    } else {
#line 503
      tmp___9 = "dummy";
    }
  } else {
#line 503
    tmp___9 = "dummy";
  }
  {
#line 503
  tmp___10 = values2str((char)0, stats, full_stats, multiplier, buffer, 49);
#line 503
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%s</span> </td><td class=\"bwm-ng-out\"><span class=\"bwm-ng-%s\">",
          tmp___10, tmp___9);
  }
#line 506
  if (stats.errors.out) {
#line 506
    goto _L___2;
  } else
#line 506
  if (stats.errors.in) {
    _L___2: /* CIL Label */ 
#line 506
    if ((int )output_unit != 4) {
#line 506
      tmp___11 = "error";
    } else {
#line 506
      tmp___11 = "dummy";
    }
  } else {
#line 506
    tmp___11 = "dummy";
  }
  {
#line 506
  tmp___12 = values2str((char)1, stats, full_stats, multiplier, buffer, 49);
#line 506
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%s</span> </td><td class=\"bwm-ng-total\"><span class=\"bwm-ng-%s\">",
          tmp___12, tmp___11);
#line 509
  tmp___13 = values2str((char)2, stats, full_stats, multiplier, buffer, 49);
#line 509
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%s</span></td><tr>\n",
          tmp___13);
  }
#line 510
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 514
  if ((unsigned long )out_file == (unsigned long )((void *)0)) {
#line 514
    tmp_out_file = stdout;
  } else {
#line 514
    tmp_out_file = out_file;
  }
  {
#line 515
  tmp___14 = time((time_t *)((void *)0));
#line 515
  fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%i%c%s%c",
          (int )tmp___14, (int )csv_char, if_name, (int )csv_char);
  }
#line 516
  if ((int )output_type == 1) {
#line 516
    goto _L___3;
  } else
#line 516
  if ((int )output_type == 3) {
    _L___3: /* CIL Label */ 
#line 517
    if ((int )output_type == 1) {
#line 518
      stats_csv = & stats;
#line 520
      if (input_method != 1) {
        {
#line 523
        fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%.2f%c%.2f%c%.2f%c%llu%c%llu%c",
                (double )((float )stats_csv->bytes.out * multiplier), (int )csv_char,
                (double )((float )stats_csv->bytes.in * multiplier), (int )csv_char,
                (double )((float )(stats_csv->bytes.out + stats_csv->bytes.in) * multiplier),
                (int )csv_char, stats_csv->bytes.in, (int )csv_char, stats_csv->bytes.out,
                (int )csv_char);
        }
      }
      {
#line 525
      fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%.2f%c%.2f%c%.2f%c%llu%c%llu",
              (double )stats_csv->packets.out * (double )multiplier, (int )csv_char,
              (double )stats_csv->packets.in * (double )multiplier, (int )csv_char,
              (double )(stats_csv->packets.out + stats_csv->packets.in) * (double )multiplier,
              (int )csv_char, stats_csv->packets.in, (int )csv_char, stats_csv->packets.out);
#line 526
      fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%c%.2f%c%.2f%c%llu%c%llu\n",
              (int )csv_char, (double )((float )stats_csv->errors.out * multiplier),
              (int )csv_char, (double )((float )stats_csv->errors.in * multiplier),
              (int )csv_char, stats_csv->errors.in, (int )csv_char, stats_csv->errors.out);
      }
    } else {
#line 529
      stats_csv = & full_stats.sum;
#line 531
      if (input_method != 1) {
        {
#line 534
        fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%llu%c%llu%c%llu%c",
                stats_csv->bytes.out, (int )csv_char, stats_csv->bytes.in, (int )csv_char,
                stats_csv->bytes.out + stats_csv->bytes.in, (int )csv_char);
        }
      }
      {
#line 536
      fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%llu%c%llu%c%llu",
              stats_csv->packets.out, (int )csv_char, stats_csv->packets.in, (int )csv_char,
              stats_csv->packets.out + stats_csv->packets.in);
#line 537
      fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%c%llu%c%llu\n",
              (int )csv_char, stats_csv->errors.out, (int )csv_char, stats_csv->errors.in);
      }
    }
  } else {
#line 540
    if ((int )output_type == 2) {
#line 541
      stats_csv_d = full_stats.max;
    } else {
#line 543
      stats_csv_d.bytes.out = full_stats.avg.item_sum.bytes.out / (long double )full_stats.avg.items;
#line 544
      stats_csv_d.bytes.in = full_stats.avg.item_sum.bytes.in / (long double )full_stats.avg.items;
#line 545
      stats_csv_d.bytes.total = full_stats.avg.item_sum.bytes.total / (long double )full_stats.avg.items;
#line 546
      stats_csv_d.packets.out = full_stats.avg.item_sum.packets.out / (long double )full_stats.avg.items;
#line 547
      stats_csv_d.packets.in = full_stats.avg.item_sum.packets.in / (long double )full_stats.avg.items;
#line 548
      stats_csv_d.packets.total = full_stats.avg.item_sum.packets.total / (long double )full_stats.avg.items;
#line 549
      stats_csv_d.errors.out = full_stats.avg.item_sum.errors.out / (long double )full_stats.avg.items;
#line 550
      stats_csv_d.errors.in = full_stats.avg.item_sum.errors.in / (long double )full_stats.avg.items;
#line 551
      stats_csv_d.errors.total = full_stats.avg.item_sum.errors.total / (long double )full_stats.avg.items;
    }
#line 554
    if (input_method != 1) {
      {
#line 557
      fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%.2Lf%c%.2Lf%c%.2Lf%c",
              stats_csv_d.bytes.out, (int )csv_char, stats_csv_d.bytes.in, (int )csv_char,
              stats_csv_d.bytes.total, (int )csv_char);
      }
    }
    {
#line 559
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%.2Lf%c%.2Lf%c%.2Lf",
            stats_csv_d.packets.out, (int )csv_char, stats_csv_d.packets.in, (int )csv_char,
            stats_csv_d.packets.total);
#line 560
    fprintf((FILE */* __restrict  */)tmp_out_file, (char const   */* __restrict  */)"%c%.2Lf%c%.2Lf\n",
            (int )csv_char, stats_csv_d.errors.out, (int )csv_char, stats_csv_d.errors.in);
    }
  }
#line 563
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 566
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 38 "/home/june/collector/temp/bwm-ng-0.6/src/input/../global_vars.h"
char PROC_DISKSTATS_FILE[4096] ;
#line 39
char PROC_PARTITIONS_FILE[4096] ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 41 "/home/june/collector/temp/bwm-ng-0.6/src/input/../bwm-ng.h"
 __attribute__((__noreturn__)) void deinit(int code , char *error_msg  , ...) ;
#line 32 "/home/june/collector/temp/bwm-ng-0.6/src/input/../process.h"
void finish_iface_stats(char verbose , t_iface_speed_stats stats , int hidden_if ,
                        int iface_number ) ;
#line 33
int process_if_data(int hidden_if , t_iface_speed_stats tmp_if_stats , t_iface_speed_stats *stats ,
                    char *name , int iface_number , char verbose , char iface_is_up ) ;
#line 32 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_diskstats.h"
void get_disk_stats_proc(char verbose ) ;
#line 31 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_diskstats.c"
int get_short_devfs_name(char *devicename ) 
{ 
  char *short_devicename ;
  char *ptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  short_devicename = (char *)((void *)0);
#line 33
  ptr = (char *)((void *)0);
#line 35
  ptr = strchr((char const   *)devicename, '/');
  }
#line 35
  if (ptr) {
    {
#line 36
    tmp = malloc((size_t )1024);
#line 36
    short_devicename = (char *)tmp;
    }
#line 36
    if (! short_devicename) {
#line 37
      return (0);
    }
    {
#line 38
    strncpy((char */* __restrict  */)short_devicename, (char const   */* __restrict  */)devicename,
            (size_t )((int )(ptr - devicename)));
#line 39
    *(short_devicename + (int )(ptr - devicename)) = (char)0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 40
      ptr = strchr((char const   *)ptr, '/');
      }
#line 40
      if (! ptr) {
#line 40
        goto while_break;
      }
      {
#line 41
      ptr ++;
#line 42
      strncat((char */* __restrict  */)short_devicename, (char const   */* __restrict  */)(ptr + 0),
              (size_t )1);
      }
      {
#line 43
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 43
        tmp___0 = tolower((int )*(ptr + 0));
        }
#line 43
        if (tmp___0 >= 97) {
          {
#line 43
          tmp___1 = tolower((int )*(ptr + 0));
          }
#line 43
          if (! (tmp___1 <= 122)) {
#line 43
            goto while_break___0;
          }
        } else {
#line 43
          goto while_break___0;
        }
#line 43
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 44
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 44
        if ((int )*(ptr + 0) >= 48) {
#line 44
          if (! ((int )*(ptr + 0) <= 57)) {
#line 44
            goto while_break___1;
          }
        } else {
#line 44
          goto while_break___1;
        }
        {
#line 45
        strncat((char */* __restrict  */)short_devicename, (char const   */* __restrict  */)(ptr + 0),
                (size_t )1);
#line 46
        ptr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 49
    strcpy((char */* __restrict  */)devicename, (char const   */* __restrict  */)short_devicename);
#line 50
    free((void *)short_devicename);
    }
#line 51
    return (1);
  }
#line 53
  return (-1);
}
}
#line 62 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_diskstats.c"
static char diskstats_works  =    (char)1;
#line 63 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_diskstats.c"
static char proc_stat[4096]  = {      (char )'\000'};
#line 57 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_diskstats.c"
void get_disk_stats_proc(char verbose ) 
{ 
  FILE *f ;
  FILE *f_s ;
  char *buffer ;
  char *name ;
  char *ptr ;
  unsigned long long tmp_long ;
  int n ;
  int major ;
  int minor ;
  int maj_s ;
  int min_s ;
  int hidden_if ;
  int current_if_num ;
  t_iface_speed_stats stats ;
  t_iface_speed_stats tmp_if_stats ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 58
  f = (FILE *)((void *)0);
#line 58
  f_s = (FILE *)((void *)0);
#line 59
  buffer = (char *)((void *)0);
#line 59
  name = (char *)((void *)0);
#line 65
  hidden_if = 0;
#line 65
  current_if_num = 0;
#line 69
  memset((void *)(& stats), 0, sizeof(t_iface_speed_stats ));
  }
#line 71
  if (diskstats_works) {
    {
#line 71
    f = fopen((char const   */* __restrict  */)(PROC_DISKSTATS_FILE), (char const   */* __restrict  */)"r");
    }
#line 71
    if (! f) {
#line 72
      diskstats_works = (char)0;
    }
  }
  {
#line 74
  tmp = malloc((size_t )1024);
#line 74
  buffer = (char *)tmp;
#line 75
  tmp___0 = malloc((size_t )1024);
#line 75
  name = (char *)tmp___0;
  }
#line 76
  if (! name) {
#line 76
    goto _L;
  } else
#line 76
  if (! buffer) {
    _L: /* CIL Label */ 
#line 77
    if (name) {
      {
#line 77
      free((void *)name);
      }
    }
#line 78
    if (buffer) {
      {
#line 78
      free((void *)buffer);
      }
    }
#line 79
    if (f) {
      {
#line 79
      fclose(f);
      }
    }
    {
#line 80
    tmp___1 = __errno_location();
#line 80
    tmp___2 = strerror(*tmp___1);
#line 80
    deinit(1, (char *)"mem alloc failed: %s\n", tmp___2);
    }
  }
#line 83
  if (! diskstats_works) {
    {
#line 84
    f = fopen((char const   */* __restrict  */)(PROC_PARTITIONS_FILE), (char const   */* __restrict  */)"r");
    }
#line 84
    if (f) {
      {
#line 88
      tmp___5 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
      }
#line 88
      if (tmp___5) {
        {
#line 88
        tmp___6 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
        }
#line 88
        if (! tmp___6) {
          {
#line 94
          tmp___3 = __errno_location();
#line 94
          tmp___4 = strerror(*tmp___3);
#line 94
          deinit(1, (char *)"reading %s failed, or file was too short: %s\n", PROC_PARTITIONS_FILE,
                 tmp___4);
          }
        }
      } else {
        {
#line 94
        tmp___3 = __errno_location();
#line 94
        tmp___4 = strerror(*tmp___3);
#line 94
        deinit(1, (char *)"reading %s failed, or file was too short: %s\n", PROC_PARTITIONS_FILE,
               tmp___4);
        }
      }
    } else {
#line 85
      diskstats_works = (char)1;
    }
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp___13 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
    }
#line 99
    if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 99
      goto while_break;
    }
#line 100
    if (diskstats_works) {
#line 100
      tmp___7 = "%i %i %s %llu%llu%llu%llu%llu%llu%llu%*i";
    } else {
#line 100
      tmp___7 = "%i %i %*i %s %llu%llu%llu%llu%llu%llu%llu%*i";
    }
    {
#line 100
    n = sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)tmp___7,
               & major, & minor, name, & tmp_if_stats.packets.in, & tmp_if_stats.errors.in,
               & tmp_if_stats.bytes.in, & tmp_long, & tmp_if_stats.packets.out, & tmp_if_stats.errors.out,
               & tmp_if_stats.bytes.out);
    }
#line 104
    if (major == 7) {
#line 104
      goto while_continue;
    }
#line 105
    if (n == 7) {
#line 107
      tmp_if_stats.packets.out = tmp_if_stats.bytes.in;
#line 108
      tmp_if_stats.bytes.in = tmp_if_stats.errors.in;
#line 109
      tmp_if_stats.bytes.out = tmp_long;
#line 110
      tmp_if_stats.errors.in = 0ULL;
#line 111
      tmp_if_stats.errors.out = 0ULL;
    } else
#line 114
    if (n != 10) {
#line 115
      if ((int )diskstats_works == 0) {
#line 115
        if (n == 3) {
#line 118
          if ((int )proc_stat[0] == 0) {
            {
#line 120
            strcpy((char */* __restrict  */)(proc_stat), (char const   */* __restrict  */)(PROC_PARTITIONS_FILE));
#line 121
            ptr = strrchr((char const   *)(proc_stat), '/');
            }
#line 121
            if (ptr) {
              {
#line 122
              ptr ++;
#line 123
              strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"stat");
              }
            } else {
              {
#line 125
              free((void *)name);
#line 126
              free((void *)buffer);
#line 127
              deinit(1, (char *)"strange /proc/partitions name, couldnt build /proc/stats name\n");
              }
            }
          }
          {
#line 130
          f_s = fopen((char const   */* __restrict  */)(proc_stat), (char const   */* __restrict  */)"r");
          }
#line 130
          if (! f_s) {
            {
#line 131
            free((void *)name);
#line 132
            free((void *)buffer);
#line 133
            tmp___8 = __errno_location();
#line 133
            tmp___9 = strerror(*tmp___8);
#line 133
            deinit(1, (char *)"couldnt open %s: %s\n", proc_stat, tmp___9);
            }
          }
          {
#line 135
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 135
            tmp___11 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f_s);
            }
#line 135
            if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 135
              goto while_break___0;
            }
            {
#line 136
            tmp___10 = strncmp("disk_io:", (char const   *)buffer, (size_t )8);
            }
#line 136
            if (! tmp___10) {
#line 137
              ptr = buffer + 9;
              {
#line 138
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 138
                if (! ((int )*(ptr + 0) != 0)) {
#line 138
                  goto while_break___1;
                }
                {
#line 139
                n = sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"(%i,%i): (%*i,%llu,%llu,%llu,%llu)",
                           & maj_s, & min_s, & tmp_if_stats.packets.in, & tmp_if_stats.bytes.in,
                           & tmp_if_stats.packets.out, & tmp_if_stats.bytes.out);
                }
#line 140
                if (maj_s == major) {
#line 140
                  if (min_s == minor) {
                    {
#line 142
                    fclose(f_s);
#line 143
                    f_s = (FILE *)((void *)0);
                    }
#line 144
                    goto while_break___1;
                  }
                }
                {
#line 146
                ptr = strchr((char const   *)ptr, ' ');
                }
#line 146
                if (! ptr) {
#line 147
                  goto while_break___1;
                }
#line 148
                ptr ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 150
              if (! f_s) {
#line 151
                goto while_break___0;
              }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 154
          if (f_s) {
            {
#line 155
            fclose(f_s);
            }
#line 157
            goto while_continue;
          }
        } else {
          {
#line 161
          free((void *)name);
#line 162
          free((void *)buffer);
#line 163
          deinit(1, (char *)"wrong format of procfile. %i: %s\n", n, buffer);
          }
        }
      } else {
        {
#line 161
        free((void *)name);
#line 162
        free((void *)buffer);
#line 163
        deinit(1, (char *)"wrong format of procfile. %i: %s\n", n, buffer);
        }
      }
    }
    {
#line 168
    tmp_if_stats.bytes.in *= 512ULL;
#line 169
    tmp_if_stats.bytes.out *= 512ULL;
#line 171
    get_short_devfs_name(name);
    }
#line 173
    if (n == 10) {
#line 173
      tmp___12 = 1;
    } else
#line 173
    if ((int )proc_stat[0] != 0) {
#line 173
      tmp___12 = 1;
    } else {
#line 173
      tmp___12 = 0;
    }
    {
#line 173
    hidden_if = process_if_data(hidden_if, tmp_if_stats, & stats, name, current_if_num,
                                verbose, (char )tmp___12);
#line 174
    current_if_num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  finish_iface_stats(verbose, stats, hidden_if, current_if_num);
#line 179
  free((void *)buffer);
#line 180
  free((void *)name);
#line 182
  fclose(f);
  }
#line 183
  return;
}
}
#line 35 "/home/june/collector/temp/bwm-ng-0.6/src/input/../global_vars.h"
char PROC_FILE[4096] ;
#line 45 "/home/june/collector/temp/bwm-ng-0.6/src/input/retrieve.h"
char check_if_up(char *ifname ) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_net_dev.h"
void get_iface_stats_proc(char verbose ) ;
#line 28 "/home/june/collector/temp/bwm-ng-0.6/src/input/proc_net_dev.c"
void get_iface_stats_proc(char verbose ) 
{ 
  char *ptr ;
  FILE *f ;
  char *buffer ;
  char *name ;
  int hidden_if ;
  int current_if_num ;
  t_iface_speed_stats stats ;
  t_iface_speed_stats tmp_if_stats ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 31
  f = (FILE *)((void *)0);
#line 32
  buffer = (char *)((void *)0);
#line 32
  name = (char *)((void *)0);
#line 34
  hidden_if = 0;
#line 34
  current_if_num = 0;
#line 38
  memset((void *)(& stats), 0, sizeof(t_iface_speed_stats ));
#line 40
  f = fopen((char const   */* __restrict  */)(PROC_FILE), (char const   */* __restrict  */)"r");
  }
#line 40
  if (! f) {
    {
#line 41
    tmp = __errno_location();
#line 41
    tmp___0 = strerror(*tmp);
#line 41
    deinit(1, (char *)"open of procfile failed: %s\n", tmp___0);
    }
  }
  {
#line 43
  tmp___1 = malloc((size_t )1024);
#line 43
  buffer = (char *)tmp___1;
#line 46
  tmp___4 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
  }
#line 46
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
#line 48
    tmp___2 = __errno_location();
#line 48
    tmp___3 = strerror(*tmp___2);
#line 48
    deinit(1, (char *)"read of proc failed: %s\n", tmp___3);
    }
  } else {
    {
#line 46
    tmp___5 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
    }
#line 46
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 48
      tmp___2 = __errno_location();
#line 48
      tmp___3 = strerror(*tmp___2);
#line 48
      deinit(1, (char *)"read of proc failed: %s\n", tmp___3);
      }
    }
  }
  {
#line 50
  tmp___6 = malloc((size_t )1024);
#line 50
  name = (char *)tmp___6;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___9 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
    }
#line 51
    if (! ((unsigned long )tmp___9 != (unsigned long )((void *)0))) {
#line 51
      goto while_break;
    }
    {
#line 53
    ptr = strchr((char const   *)buffer, ':');
    }
#line 55
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 55
      deinit(1, (char *)"wrong format of input stream\n");
      }
    }
    {
#line 57
    tmp___7 = ptr;
#line 57
    ptr ++;
#line 57
    *tmp___7 = (char)0;
#line 58
    sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"%llu%llu%llu%*i%*i%*i%*i%*i%llu%llu%llu",
           & tmp_if_stats.bytes.in, & tmp_if_stats.packets.in, & tmp_if_stats.errors.in,
           & tmp_if_stats.bytes.out, & tmp_if_stats.packets.out, & tmp_if_stats.errors.out);
#line 59
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"%s",
           name);
#line 61
    tmp___8 = check_if_up(name);
#line 61
    hidden_if = process_if_data(hidden_if, tmp_if_stats, & stats, name, current_if_num,
                                verbose, tmp___8);
#line 68
    current_if_num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  finish_iface_stats(verbose, stats, hidden_if, current_if_num);
#line 73
  free((void *)buffer);
#line 74
  free((void *)name);
#line 76
  fclose(f);
  }
#line 77
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 33 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int if_count  ;
#line 35 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char PROC_FILE[4096]  ;
#line 38 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char PROC_DISKSTATS_FILE[4096]  ;
#line 39 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char PROC_PARTITIONS_FILE[4096]  ;
#line 42 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char NETSTAT_FILE[4096]  ;
#line 44 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned int delay  ;
#line 46 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned int avg_length  ;
#line 48 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char output_unit  ;
#line 49 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char output_type  ;
#line 50 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char dynamic  ;
#line 52 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char show_all_if  ;
#line 54 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int output_method  ;
#line 55 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
WINDOW *mywin  ;
#line 56 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned short cols  ;
#line 57 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned short rows  ;
#line 58 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned int max_rt  ;
#line 59 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned int scale  ;
#line 60 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
unsigned int show_only_if  ;
#line 64 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char *iface_list  ;
#line 66 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char csv_char  ;
#line 69 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
FILE *out_file  ;
#line 70 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char *out_file_path  ;
#line 72 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int output_count  ;
#line 73 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char daemonize  ;
#line 74 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char sumhidden  ;
#line 75 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
char ansi_output  ;
#line 77 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int input_method  ;
#line 80 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int html_refresh  ;
#line 81 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int html_header  ;
#line 85 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
int skfd  ;
#line 92 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
t_iface_stats *if_stats  ;
#line 94 "/home/june/collector/temp/bwm-ng-0.6/src/global_vars.h"
t_iface_stats if_stats_total  ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 32 "/home/june/collector/temp/bwm-ng-0.6/src/help.h"
 __attribute__((__noreturn__)) void cmdln_printhelp(void) ;
#line 44 "/home/june/collector/temp/bwm-ng-0.6/src/options.h"
void get_cmdln_options(int argc , char **argv ) ;
#line 32 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
static char *getToken(char **str___0 , char const   *delims ) 
{ 
  char *token ;
  char *tmp ;

  {
#line 36
  if ((unsigned long )*str___0 == (unsigned long )((void *)0)) {
#line 38
    return ((char *)((void *)0));
  }
#line 41
  token = *str___0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! ((int )*(*str___0) != 0)) {
#line 42
      goto while_break;
    }
    {
#line 43
    tmp = strchr(delims, (int )*(*str___0));
    }
#line 43
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 44
      *(*str___0) = (char )'\000';
#line 45
      (*str___0) ++;
#line 46
      return (token);
    }
#line 48
    (*str___0) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  *str___0 = (char *)((void *)0);
#line 52
  return (token);
}
}
#line 57 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
__inline int str2output_unit(char *optarg___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 58
  if (optarg___0) {
    {
#line 59
    tmp = strcasecmp((char const   *)optarg___0, "bytes");
    }
#line 59
    if (! tmp) {
#line 59
      return (1);
    }
    {
#line 60
    tmp___0 = strcasecmp((char const   *)optarg___0, "bits");
    }
#line 60
    if (! tmp___0) {
#line 60
      return (2);
    }
    {
#line 61
    tmp___1 = strcasecmp((char const   *)optarg___0, "packets");
    }
#line 61
    if (! tmp___1) {
#line 61
      return (3);
    }
    {
#line 62
    tmp___2 = strcasecmp((char const   *)optarg___0, "errors");
    }
#line 62
    if (! tmp___2) {
#line 62
      return (4);
    }
  }
#line 64
  return (1);
}
}
#line 68 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
__inline int str2output_type(char *optarg___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 69
  if (optarg___0) {
    {
#line 70
    tmp = strcasecmp((char const   *)optarg___0, "rate");
    }
#line 70
    if (! tmp) {
#line 70
      return (1);
    }
    {
#line 71
    tmp___0 = strcasecmp((char const   *)optarg___0, "max");
    }
#line 71
    if (! tmp___0) {
#line 71
      return (2);
    }
    {
#line 72
    tmp___1 = strcasecmp((char const   *)optarg___0, "sum");
    }
#line 72
    if (! tmp___1) {
#line 72
      return (3);
    }
    {
#line 73
    tmp___2 = strcasecmp((char const   *)optarg___0, "avg");
    }
#line 73
    if (! tmp___2) {
#line 73
      return (4);
    }
  }
#line 75
  return (1);
}
}
#line 79 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
__inline int str2out_method(char *optarg___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 80
  if (optarg___0) {
    {
#line 81
    tmp___3 = strcasecmp((char const   *)optarg___0, "plain");
    }
#line 81
    if (tmp___3) {
      {
#line 84
      tmp___2 = strcasecmp((char const   *)optarg___0, "curses");
      }
#line 84
      if (tmp___2) {
        {
#line 86
        tmp___1 = strcasecmp((char const   *)optarg___0, "curses2");
        }
#line 86
        if (tmp___1) {
          {
#line 90
          tmp___0 = strcasecmp((char const   *)optarg___0, "csv");
          }
#line 90
          if (tmp___0) {
            {
#line 94
            tmp = strcasecmp((char const   *)optarg___0, "html");
            }
#line 94
            if (! tmp) {
#line 94
              return (3);
            }
          } else {
#line 90
            return (2);
          }
        } else {
#line 86
          return (5);
        }
      } else {
#line 84
        return (0);
      }
    } else {
#line 81
      return (1);
    }
  }
#line 97
  return (-1);
}
}
#line 101 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
__inline int str2in_method(char *optarg___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 102
  if (optarg___0) {
    {
#line 104
    tmp = strcasecmp((char const   *)optarg___0, "proc");
    }
#line 104
    if (! tmp) {
#line 104
      return (2);
    }
    {
#line 107
    tmp___0 = strcasecmp((char const   *)optarg___0, "netstat");
    }
#line 107
    if (! tmp___0) {
#line 107
      return (1);
    }
    {
#line 126
    tmp___1 = strcasecmp((char const   *)optarg___0, "disk");
    }
#line 126
    if (! tmp___1) {
#line 126
      return (128);
    }
  }
#line 139
  return (-1);
}
}
#line 144 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
char *trim_whitespace(char *str___0 ) 
{ 
  char *dud ;
  int i ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 145
  dud = str___0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if ((int )*dud) {
      {
#line 149
      tmp = __ctype_b_loc();
      }
#line 149
      if (! ((int const   )*(*tmp + (int )*dud) & 8192)) {
#line 149
        goto while_break;
      }
    } else {
#line 149
      goto while_break;
    }
#line 150
    dud ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp___0 = strlen((char const   *)dud);
#line 152
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (i >= 0) {
      {
#line 153
      tmp___1 = __ctype_b_loc();
      }
#line 153
      if (! ((int const   )*(*tmp___1 + (int )*(dud + i)) & 8192)) {
#line 153
        goto while_break___0;
      }
    } else {
#line 153
      goto while_break___0;
    }
#line 154
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 155
  *(dud + (i + 1)) = (char)0;
#line 156
  return (dud);
}
}
#line 160 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
int read_config(char *config_file ) 
{ 
  FILE *fp ;
  char *buffer ;
  char *token ;
  char *value ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;

  {
#line 165
  if ((unsigned long )config_file == (unsigned long )((void *)0)) {
#line 165
    return (-1);
  }
  {
#line 167
  fp = fopen((char const   */* __restrict  */)config_file, (char const   */* __restrict  */)"r");
  }
#line 167
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 168
    return (-1);
  }
  {
#line 171
  tmp = malloc(sizeof(char ) * 4096UL);
#line 171
  buffer = (char *)tmp;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    tmp___33 = fgets((char */* __restrict  */)buffer, 4096, (FILE */* __restrict  */)fp);
    }
#line 173
    if (! tmp___33) {
#line 173
      goto while_break;
    }
    {
#line 174
    value = trim_whitespace(buffer);
#line 175
    token = getToken(& value, "=");
    }
#line 176
    if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 177
      goto while_continue;
    }
    {
#line 178
    token = trim_whitespace(token);
#line 180
    tmp___32 = strcasecmp((char const   *)token, "TIMEOUT");
    }
#line 180
    if (tmp___32 == 0) {
#line 181
      if (value) {
        {
#line 181
        tmp___1 = atol((char const   *)value);
        }
#line 181
        if (tmp___1 > 0L) {
          {
#line 181
          tmp___0 = atol((char const   *)value);
#line 181
          delay = (unsigned int )tmp___0;
          }
        }
      }
    } else {
      {
#line 183
      tmp___31 = strcasecmp((char const   *)token, "PROCFILE");
      }
#line 183
      if (tmp___31 == 0) {
#line 184
        if (value) {
          {
#line 184
          tmp___2 = strlen((char const   *)value);
          }
#line 184
          if (tmp___2 < 4096UL) {
            {
#line 184
            strcpy((char */* __restrict  */)(PROC_FILE), (char const   */* __restrict  */)value);
            }
          }
        }
      } else {
        {
#line 187
        tmp___30 = strcasecmp((char const   *)token, "DISKSTATSFILE");
        }
#line 187
        if (tmp___30 == 0) {
#line 188
          if (value) {
            {
#line 188
            tmp___3 = strlen((char const   *)value);
            }
#line 188
            if (tmp___3 < 4096UL) {
              {
#line 188
              strcpy((char */* __restrict  */)(PROC_DISKSTATS_FILE), (char const   */* __restrict  */)value);
              }
            }
          }
        } else {
          {
#line 189
          tmp___29 = strcasecmp((char const   *)token, "PARTITIONSFILE");
          }
#line 189
          if (tmp___29 == 0) {
#line 190
            if (value) {
              {
#line 190
              tmp___4 = strlen((char const   *)value);
              }
#line 190
              if (tmp___4 < 4096UL) {
                {
#line 190
                strcpy((char */* __restrict  */)(PROC_PARTITIONS_FILE), (char const   */* __restrict  */)value);
                }
              }
            }
          } else {
            {
#line 198
            tmp___28 = strcasecmp((char const   *)token, "INPUT");
            }
#line 198
            if (tmp___28 == 0) {
#line 199
              if (value) {
                {
#line 199
                input_method = str2in_method(value);
                }
              }
            } else {
              {
#line 200
              tmp___27 = strcasecmp((char const   *)token, "ANSIOUT");
              }
#line 200
              if (tmp___27 == 0) {
#line 201
                if (value) {
#line 201
                  if ((int )*(value + 0) == 48) {
#line 201
                    ansi_output = (char)1;
                  } else {
#line 201
                    ansi_output = (char)0;
                  }
                }
              } else {
                {
#line 202
                tmp___26 = strcasecmp((char const   *)token, "DYNAMIC");
                }
#line 202
                if (tmp___26 == 0) {
#line 203
                  if (value) {
#line 203
                    if ((int )*(value + 0) == 48) {
#line 203
                      dynamic = (char)1;
                    } else {
#line 203
                      dynamic = (char)0;
                    }
                  }
                } else {
                  {
#line 204
                  tmp___25 = strcasecmp((char const   *)token, "UNIT");
                  }
#line 204
                  if (tmp___25 == 0) {
#line 205
                    if (value) {
                      {
#line 205
                      tmp___5 = str2output_unit(value);
#line 205
                      output_unit = (char )tmp___5;
                      }
                    }
                  } else {
                    {
#line 207
                    tmp___24 = strcasecmp((char const   *)token, "TYPE");
                    }
#line 207
                    if (tmp___24 == 0) {
#line 208
                      if (value) {
                        {
#line 208
                        tmp___6 = str2output_type(value);
#line 208
                        output_type = (char )tmp___6;
                        }
                      }
                    } else {
                      {
#line 209
                      tmp___23 = strcasecmp((char const   *)token, "AVGLENGTH");
                      }
#line 209
                      if (tmp___23 == 0) {
#line 210
                        if (value) {
                          {
#line 210
                          tmp___7 = atoi((char const   *)value);
#line 210
                          avg_length = (unsigned int )(tmp___7 * 1000);
                          }
                        }
                      } else {
                        {
#line 212
                        tmp___22 = strcasecmp((char const   *)token, "ALLIF");
                        }
#line 212
                        if (tmp___22 == 0) {
#line 213
                          if (value) {
#line 213
                            show_all_if = *(value + 0);
                          }
                        } else {
                          {
#line 214
                          tmp___21 = strcasecmp((char const   *)token, "INTERFACES");
                          }
#line 214
                          if (tmp___21 == 0) {
#line 215
                            if (value) {
                              {
#line 215
                              tmp___8 = strdup((char const   *)value);
#line 215
                              iface_list = tmp___8;
                              }
                            }
                          } else {
                            {
#line 216
                            tmp___20 = strcasecmp((char const   *)token, "OUTPUT");
                            }
#line 216
                            if (tmp___20 == 0) {
#line 217
                              if (value) {
                                {
#line 217
                                output_method = str2out_method(value);
                                }
                              }
                            } else {
                              {
#line 219
                              tmp___19 = strcasecmp((char const   *)token, "CSVCHAR");
                              }
#line 219
                              if (tmp___19 == 0) {
#line 220
                                if (value) {
#line 220
                                  csv_char = *(value + 0);
                                }
                              } else {
                                {
#line 223
                                tmp___18 = strcasecmp((char const   *)token, "OUTFILE");
                                }
#line 223
                                if (tmp___18 == 0) {
#line 224
                                  if (value) {
#line 225
                                    if (out_file) {
                                      {
#line 225
                                      fclose(out_file);
                                      }
                                    }
                                    {
#line 226
                                    out_file = fopen((char const   */* __restrict  */)value,
                                                     (char const   */* __restrict  */)"a");
                                    }
#line 227
                                    if (! out_file) {
                                      {
#line 227
                                      deinit(1, (char *)"failed to open outfile\n");
                                      }
                                    }
#line 228
                                    if (out_file_path) {
                                      {
#line 228
                                      free((void *)out_file_path);
                                      }
                                    }
                                    {
#line 229
                                    tmp___9 = strdup((char const   *)value);
#line 229
                                    out_file_path = tmp___9;
                                    }
                                  }
                                } else {
                                  {
#line 232
                                  tmp___17 = strcasecmp((char const   *)token, "COUNT");
                                  }
#line 232
                                  if (tmp___17 == 0) {
#line 233
                                    if (value) {
                                      {
#line 233
                                      tmp___10 = atol((char const   *)value);
#line 233
                                      output_count = (int )tmp___10;
                                      }
                                    }
                                  } else {
                                    {
#line 234
                                    tmp___16 = strcasecmp((char const   *)token, "DAEMON");
                                    }
#line 234
                                    if (tmp___16 == 0) {
#line 235
                                      if (value) {
#line 235
                                        if ((int )*(value + 0) == 48) {
#line 235
                                          daemonize = (char)0;
                                        } else {
#line 235
                                          daemonize = (char)1;
                                        }
                                      }
                                    } else {
                                      {
#line 236
                                      tmp___15 = strcasecmp((char const   *)token,
                                                            "SUMHIDDEN");
                                      }
#line 236
                                      if (tmp___15 == 0) {
#line 237
                                        if (value) {
#line 237
                                          if ((int )*(value + 0) == 48) {
#line 237
                                            sumhidden = (char)0;
                                          } else {
#line 237
                                            sumhidden = (char)1;
                                          }
                                        }
                                      } else {
                                        {
#line 243
                                        tmp___14 = strcasecmp((char const   *)token,
                                                              "HTMLREFRESH");
                                        }
#line 243
                                        if (tmp___14 == 0) {
#line 244
                                          if (value) {
                                            {
#line 244
                                            tmp___12 = atol((char const   *)value);
                                            }
#line 244
                                            if (tmp___12 > 0L) {
                                              {
#line 244
                                              tmp___11 = atol((char const   *)value);
#line 244
                                              html_refresh = (int )tmp___11;
                                              }
                                            }
                                          }
                                        } else {
                                          {
#line 245
                                          tmp___13 = strcasecmp((char const   *)token,
                                                                "HTMLHEADER");
                                          }
#line 245
                                          if (tmp___13 == 0) {
#line 246
                                            if (value) {
#line 246
                                              if ((int )*(value + 0) == 48) {
#line 246
                                                html_header = 0;
                                              } else {
#line 246
                                                html_header = 1;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  free((void *)buffer);
#line 251
  fclose(fp);
  }
#line 253
  return (0);
}
}
#line 262 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
static struct passwd *pwd_entry  ;
#line 267 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
static struct option long_options[23]  = 
#line 267
  {      {"timeout", 1, (int *)0, 't'}, 
        {"procfile", 1, (int *)0, 'f'}, 
        {"diskstatsfile", 1, (int *)0, 1000}, 
        {"partitionsfile", 1, (int *)0, 1001}, 
        {"input", 1, (int *)0, 'i'}, 
        {"dynamic", 1, (int *)0, 'd'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"allif", 1, (int *)0, 'a'}, 
        {"unit", 1, (int *)0, 'u'}, 
        {"ansiout", 0, (int *)0, 'N'}, 
        {"type", 1, (int *)0, 'T'}, 
        {"avglength", 1, (int *)0, 'A'}, 
        {"interfaces", 1, (int *)0, 'I'}, 
        {"sumhidden", 1, (int *)0, 'S'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"csvchar", 1, (int *)0, 'C'}, 
        {"csvfile", 1, (int *)0, 'F'}, 
        {"count", 1, (int *)0, 'c'}, 
        {"daemon", 1, (int *)0, 'D'}, 
        {"htmlrefresh", 1, (int *)0, 'R'}, 
        {"htmlheader", 1, (int *)0, 'H'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 259 "/home/june/collector/temp/bwm-ng-0.6/src/options.c"
void get_cmdln_options(int argc , char **argv ) 
{ 
  int o ;
  char *str___0 ;
  int option_index ;
  __uid_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 266
  option_index = 0;
#line 311
  opterr = 0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    o = getopt_long(argc, (char * const  *)argv, ":ht:d:Va:u:I:i:o:c:D:S:NA:T:f:H:R:C:F:",
                    (struct option  const  *)(long_options), & option_index);
    }
#line 318
    if (o == -1) {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  opterr = 1;
#line 321
  if (optind < argc) {
    {
#line 322
    read_config(*(argv + optind));
    }
  } else {
    {
#line 324
    read_config((char *)"/etc/bwm-ng.conf");
#line 326
    tmp = getuid();
#line 326
    pwd_entry = getpwuid(tmp);
    }
#line 327
    if ((unsigned long )pwd_entry != (unsigned long )((void *)0)) {
      {
#line 328
      tmp___0 = strlen((char const   *)pwd_entry->pw_dir);
#line 328
      tmp___1 = malloc(tmp___0 + 14UL);
#line 328
      str___0 = (char *)tmp___1;
#line 329
      tmp___2 = strlen((char const   *)pwd_entry->pw_dir);
#line 329
      snprintf((char */* __restrict  */)str___0, tmp___2 + 14UL, (char const   */* __restrict  */)"%s/.bwm-ng.conf",
               pwd_entry->pw_dir);
#line 330
      read_config(str___0);
#line 331
      free((void *)str___0);
      }
    }
  }
#line 336
  optind = 1;
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 341
    o = getopt_long(argc, (char * const  *)argv, ":ht:d:Va:u:I:i:o:c:D:S:NA:T:f:H:R:C:F:",
                    (struct option  const  *)(long_options), & option_index);
    }
#line 345
    if (o == -1) {
#line 345
      goto while_break___0;
    }
    {
#line 347
    if (o == 63) {
#line 347
      goto case_63;
    }
#line 351
    if (o == 58) {
#line 351
      goto case_58;
    }
#line 369
    if (o == 1000) {
#line 369
      goto case_1000;
    }
#line 373
    if (o == 1001) {
#line 373
      goto case_1001;
    }
#line 383
    if (o == 68) {
#line 383
      goto case_68;
    }
#line 387
    if (o == 82) {
#line 387
      goto case_82;
    }
#line 390
    if (o == 72) {
#line 390
      goto case_72;
    }
#line 394
    if (o == 99) {
#line 394
      goto case_99;
    }
#line 398
    if (o == 70) {
#line 398
      goto case_70;
    }
#line 409
    if (o == 67) {
#line 409
      goto case_67;
    }
#line 413
    if (o == 104) {
#line 413
      goto case_104;
    }
#line 417
    if (o == 102) {
#line 417
      goto case_102;
    }
#line 421
    if (o == 105) {
#line 421
      goto case_105;
    }
#line 426
    if (o == 73) {
#line 426
      goto case_73;
    }
#line 429
    if (o == 83) {
#line 429
      goto case_83;
    }
#line 432
    if (o == 111) {
#line 432
      goto case_111;
    }
#line 437
    if (o == 78) {
#line 437
      goto case_78;
    }
#line 439
    if (o == 97) {
#line 439
      goto case_97;
    }
#line 442
    if (o == 116) {
#line 442
      goto case_116;
    }
#line 446
    if (o == 84) {
#line 446
      goto case_84;
    }
#line 449
    if (o == 65) {
#line 449
      goto case_65;
    }
#line 453
    if (o == 100) {
#line 453
      goto case_100;
    }
#line 456
    if (o == 117) {
#line 456
      goto case_117;
    }
#line 464
    if (o == 86) {
#line 464
      goto case_86;
    }
#line 346
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 347
    printf((char const   */* __restrict  */)"unknown option: %s\n", *(argv + (optind - 1)));
#line 348
    exit(1);
    }
#line 349
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 351
    tmp___11 = strcmp((char const   *)*(argv + (optind - 1)), "-a");
    }
#line 351
    if (tmp___11) {
      {
#line 351
      tmp___12 = strcasecmp((char const   *)*(argv + (optind - 1)), "--allif");
      }
#line 351
      if (tmp___12) {
        {
#line 353
        tmp___9 = strcmp((char const   *)*(argv + (optind - 1)), "-d");
        }
#line 353
        if (tmp___9) {
          {
#line 353
          tmp___10 = strcasecmp((char const   *)*(argv + (optind - 1)), "--dynamic");
          }
#line 353
          if (tmp___10) {
            {
#line 355
            tmp___7 = strcmp((char const   *)*(argv + (optind - 1)), "-D");
            }
#line 355
            if (tmp___7) {
              {
#line 355
              tmp___8 = strcasecmp((char const   *)*(argv + (optind - 1)), "--daemon");
              }
#line 355
              if (tmp___8) {
                {
#line 358
                tmp___5 = strcmp((char const   *)*(argv + (optind - 1)), "-H");
                }
#line 358
                if (tmp___5) {
                  {
#line 358
                  tmp___6 = strcasecmp((char const   *)*(argv + (optind - 1)), "--htmlheader");
                  }
#line 358
                  if (tmp___6) {
                    {
#line 361
                    tmp___3 = strcmp((char const   *)*(argv + (optind - 1)), "-S");
                    }
#line 361
                    if (tmp___3) {
                      {
#line 361
                      tmp___4 = strcasecmp((char const   *)*(argv + (optind - 1)),
                                           "--sumhidden");
                      }
#line 361
                      if (tmp___4) {
                        {
#line 364
                        printf((char const   */* __restrict  */)"%s requires an argument!\n",
                               *(argv + (optind - 1)));
#line 365
                        exit(1);
                        }
                      } else {
#line 362
                        sumhidden = (char)1;
                      }
                    } else {
#line 362
                      sumhidden = (char)1;
                    }
                  } else {
#line 359
                    html_header = 1;
                  }
                } else {
#line 359
                  html_header = 1;
                }
              } else {
#line 356
                daemonize = (char)1;
              }
            } else {
#line 356
              daemonize = (char)1;
            }
          } else {
#line 354
            dynamic = (char)1;
          }
        } else {
#line 354
          dynamic = (char)1;
        }
      } else {
#line 352
        show_all_if = (char)1;
      }
    } else {
#line 352
      show_all_if = (char)1;
    }
#line 367
    goto switch_break;
    case_1000: /* CIL Label */ 
    {
#line 370
    tmp___13 = strlen((char const   *)optarg);
    }
#line 370
    if (tmp___13 < 4096UL) {
      {
#line 371
      strcpy((char */* __restrict  */)(PROC_DISKSTATS_FILE), (char const   */* __restrict  */)optarg);
      }
    }
#line 372
    goto switch_break;
    case_1001: /* CIL Label */ 
    {
#line 374
    tmp___14 = strlen((char const   *)optarg);
    }
#line 374
    if (tmp___14 < 4096UL) {
      {
#line 375
      strcpy((char */* __restrict  */)(PROC_PARTITIONS_FILE), (char const   */* __restrict  */)optarg);
      }
    }
#line 376
    goto switch_break;
    case_68: /* CIL Label */ 
#line 384
    if (optarg) {
      {
#line 384
      tmp___15 = atoi((char const   *)optarg);
#line 384
      daemonize = (char )tmp___15;
      }
    }
#line 385
    goto switch_break;
    case_82: /* CIL Label */ 
#line 388
    if (optarg) {
      {
#line 388
      tmp___17 = atol((char const   *)optarg);
      }
#line 388
      if (tmp___17 > 0L) {
        {
#line 388
        tmp___16 = atol((char const   *)optarg);
#line 388
        html_refresh = (int )tmp___16;
        }
      }
    }
#line 389
    goto switch_break;
    case_72: /* CIL Label */ 
#line 391
    if (optarg) {
      {
#line 391
      html_header = atoi((char const   *)optarg);
      }
    }
#line 392
    goto switch_break;
    case_99: /* CIL Label */ 
#line 395
    if (optarg) {
      {
#line 395
      tmp___18 = atol((char const   *)optarg);
#line 395
      output_count = (int )tmp___18;
      }
    }
#line 396
    goto switch_break;
    case_70: /* CIL Label */ 
#line 399
    if (optarg) {
#line 400
      if (out_file) {
        {
#line 400
        fclose(out_file);
        }
      }
      {
#line 401
      out_file = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"a");
      }
#line 402
      if (! out_file) {
        {
#line 402
        deinit(1, (char *)"failed to open outfile\n");
        }
      }
#line 403
      if (out_file_path) {
        {
#line 403
        free((void *)out_file_path);
        }
      }
      {
#line 404
      tmp___19 = strdup((char const   *)optarg);
#line 404
      out_file_path = tmp___19;
      }
    }
#line 406
    goto switch_break;
    case_67: /* CIL Label */ 
#line 410
    if (optarg) {
#line 410
      csv_char = *(optarg + 0);
    }
#line 411
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 414
    cmdln_printhelp();
    }
#line 415
    goto switch_break;
    case_102: /* CIL Label */ 
#line 418
    if (optarg) {
      {
#line 418
      tmp___20 = strlen((char const   *)optarg);
      }
#line 418
      if (tmp___20 < 4096UL) {
        {
#line 418
        strcpy((char */* __restrict  */)(PROC_FILE), (char const   */* __restrict  */)optarg);
        }
      }
    }
#line 419
    goto switch_break;
    case_105: /* CIL Label */ 
#line 422
    if (optarg) {
      {
#line 423
      input_method = str2in_method(optarg);
      }
    }
#line 425
    goto switch_break;
    case_73: /* CIL Label */ 
#line 427
    if (optarg) {
      {
#line 427
      tmp___21 = strdup((char const   *)optarg);
#line 427
      iface_list = tmp___21;
      }
    }
#line 428
    goto switch_break;
    case_83: /* CIL Label */ 
#line 430
    if (optarg) {
      {
#line 430
      tmp___22 = atoi((char const   *)optarg);
#line 430
      sumhidden = (char )tmp___22;
      }
    }
#line 431
    goto switch_break;
    case_111: /* CIL Label */ 
#line 433
    if (optarg) {
      {
#line 434
      output_method = str2out_method(optarg);
      }
    }
#line 436
    goto switch_break;
    case_78: /* CIL Label */ 
#line 438
    ansi_output = (char )(! ansi_output);
    case_97: /* CIL Label */ 
#line 440
    if (optarg) {
      {
#line 440
      tmp___23 = atoi((char const   *)optarg);
#line 440
      show_all_if = (char )tmp___23;
      }
    }
#line 441
    goto switch_break;
    case_116: /* CIL Label */ 
#line 443
    if (optarg) {
      {
#line 443
      tmp___25 = atol((char const   *)optarg);
      }
#line 443
      if (tmp___25 > 0L) {
        {
#line 443
        tmp___24 = atol((char const   *)optarg);
#line 443
        delay = (unsigned int )tmp___24;
        }
      }
    }
#line 444
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 447
    tmp___26 = str2output_type(optarg);
#line 447
    output_type = (char )tmp___26;
    }
#line 448
    goto switch_break;
    case_65: /* CIL Label */ 
#line 450
    if (optarg) {
      {
#line 450
      tmp___27 = atoi((char const   *)optarg);
#line 450
      avg_length = (unsigned int )(tmp___27 * 1000);
      }
    }
#line 451
    goto switch_break;
    case_100: /* CIL Label */ 
#line 454
    if (optarg) {
      {
#line 454
      tmp___28 = atoi((char const   *)optarg);
#line 454
      dynamic = (char )tmp___28;
      }
    }
#line 455
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 457
    tmp___29 = str2output_unit(optarg);
#line 457
    output_unit = (char )tmp___29;
    }
#line 458
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 465
    printf((char const   */* __restrict  */)"Bandwidth Monitor NG (bwm-ng) v0.6\nCopyright (C) 2004-2007 Volker Gropp <bwmng@gropp.org>\n");
#line 466
    exit(0);
    }
#line 467
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 470
  if ((unsigned long )iface_list == (unsigned long )((void *)0)) {
#line 470
    if ((int )show_all_if == 1) {
#line 470
      show_all_if = (char)2;
    }
  }
#line 473
  if (avg_length == 0U) {
#line 474
    if (delay < 15000U) {
#line 475
      avg_length = 30000U;
    } else {
#line 477
      avg_length = delay * 2U + 1U;
    }
  } else
#line 479
  if (delay * 2U >= avg_length) {
    {
#line 479
    deinit(1, (char *)"avglength needs to be a least twice the value of timeout\n");
    }
  }
#line 481
  if ((int )output_unit == 4) {
#line 481
    if (! (input_method & 3)) {
#line 483
      output_unit = (char)1;
    } else {
#line 481
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 481
  if ((int )output_unit == 3) {
#line 481
    if (input_method == 0) {
#line 483
      output_unit = (char)1;
    }
  }
#line 484
  return;
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/input/netstat.h"
void get_iface_stats_netstat(char verbose ) ;
#line 64 "/home/june/collector/temp/bwm-ng-0.6/src/input/retrieve.h"
__inline void get_iface_stats(char _n ) ;
#line 28 "/home/june/collector/temp/bwm-ng-0.6/src/input/retrieve.c"
char check_if_up(char *ifname ) 
{ 
  struct ifreq ifr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 32
  if (skfd < 0) {
    {
#line 33
    skfd = socket(1, 2, 0);
    }
#line 33
    if (skfd < 0) {
      {
#line 34
      tmp = __errno_location();
#line 34
      tmp___0 = strerror(*tmp);
#line 34
      deinit(1, (char *)"socket error: %s\n", tmp___0);
      }
    }
  }
  {
#line 38
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(ifr.ifr_ifrn.ifrn_name));
#line 39
  ifr.ifr_ifrn.ifrn_name[sizeof(ifr.ifr_ifrn.ifrn_name) - 1UL] = (char )'\000';
#line 41
  tmp___1 = ioctl(skfd, 35091UL, & ifr);
  }
#line 41
  if (tmp___1 < 0) {
#line 42
    return ((char)0);
  }
#line 45
  return ((char )((int )ifr.ifr_ifru.ifru_flags & 1));
}
}
#line 50 "/home/june/collector/temp/bwm-ng-0.6/src/input/retrieve.c"
__inline void get_iface_stats(char _n ) 
{ 


  {
  {
#line 53
  if (input_method == 1) {
#line 53
    goto case_1;
  }
#line 66
  if (input_method == 2) {
#line 66
    goto case_2;
  }
#line 102
  if (input_method == 128) {
#line 102
    goto case_128;
  }
#line 51
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 54
  get_iface_stats_netstat(_n);
  }
#line 55
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 67
  get_iface_stats_proc(_n);
  }
#line 68
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 103
  get_disk_stats_proc(_n);
  }
#line 104
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 873 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 53 "/home/june/collector/temp/bwm-ng-0.6/src/input/netstat.c"
void get_iface_stats_netstat(char verbose ) 
{ 
  int current_if_num ;
  int hidden_if ;
  char *buffer ;
  char *name ;
  FILE *f ;
  t_iface_speed_stats stats ;
  t_iface_speed_stats tmp_if_stats ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  FILE *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 54
  current_if_num = 0;
#line 54
  hidden_if = 0;
#line 55
  buffer = (char *)((void *)0);
#line 55
  name = (char *)((void *)0);
#line 65
  f = (FILE *)((void *)0);
#line 69
  memset((void *)(& stats), 0, sizeof(t_iface_speed_stats ));
  }
#line 70
  if (show_all_if) {
#line 70
    tmp___1 = "netstat -ia";
  } else {
#line 70
    tmp___1 = "netstat -i";
  }
  {
#line 70
  tmp___2 = popen(tmp___1, "r");
#line 70
  f = tmp___2;
  }
#line 70
  if (! f) {
    {
#line 91
    tmp = __errno_location();
#line 91
    tmp___0 = strerror(*tmp);
#line 91
    deinit(1, (char *)"no input stream found: %s\n", tmp___0);
    }
  }
  {
#line 99
  tmp___3 = malloc((size_t )1024);
#line 99
  buffer = (char *)tmp___3;
#line 102
  tmp___6 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
  }
#line 102
  if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
    {
#line 103
    tmp___4 = __errno_location();
#line 103
    tmp___5 = strerror(*tmp___4);
#line 103
    deinit(1, (char *)"read of netstat failed: %s\n", tmp___5);
    }
  } else {
    {
#line 102
    tmp___7 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
    }
#line 102
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
      {
#line 103
      tmp___4 = __errno_location();
#line 103
      tmp___5 = strerror(*tmp___4);
#line 103
      deinit(1, (char *)"read of netstat failed: %s\n", tmp___5);
      }
    }
  }
  {
#line 110
  tmp___8 = malloc((size_t )1024);
#line 110
  name = (char *)tmp___8;
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    tmp___9 = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)f);
    }
#line 112
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 112
      if (! ((int )*(buffer + 0) != 10)) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
    {
#line 113
    memset((void *)(& tmp_if_stats), 0, sizeof(t_iface_speed_stats ));
#line 115
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"%s%*i%*i%llu%llu%*i%*i%llu%llu",
           name, & tmp_if_stats.packets.in, & tmp_if_stats.errors.in, & tmp_if_stats.packets.out,
           & tmp_if_stats.errors.out);
#line 145
    hidden_if = process_if_data(hidden_if, tmp_if_stats, & stats, name, current_if_num,
                                verbose, (char)1);
#line 153
    current_if_num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  finish_iface_stats(verbose, stats, hidden_if, current_if_num);
#line 158
  free((void *)buffer);
#line 167
  free((void *)name);
#line 169
  pclose(f);
  }
#line 170
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 377 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 597 "/usr/include/curses.h"
extern int curs_set(int  ) ;
#line 611
extern int endwin(void) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 46 "/home/june/collector/temp/bwm-ng-0.6/src/curses_tools.h"
void handle_gui_input(char c ) ;
#line 47
int init_curses(void) ;
#line 48
void sigwinch(int sig ) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/bwm-ng.c"
 __attribute__((__noreturn__)) void deinit(int code , char *error_msg  , ...) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/bwm-ng.c"
void deinit(int code , char *error_msg  , ...) 
{ 
  va_list ap ;
  int local_if_count ;
  struct double_list *list_p ;

  {
#line 41
  if ((unsigned long )mywin != (unsigned long )((void *)0)) {
#line 41
    if (output_method == 0) {
      {
#line 44
      curs_set(1);
#line 46
      endwin();
      }
    } else
#line 41
    if (output_method == 5) {
      {
#line 44
      curs_set(1);
#line 46
      endwin();
      }
    }
  }
#line 51
  if (skfd >= 0) {
    {
#line 52
    close(skfd);
    }
  }
#line 56
  if ((unsigned long )if_stats != (unsigned long )((void *)0)) {
#line 59
    local_if_count = 0;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
#line 59
      if (! (local_if_count < if_count)) {
#line 59
        goto while_break;
      }
      {
#line 61
      free((void *)(if_stats + local_if_count)->if_name);
      }
      {
#line 62
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 62
        if (! ((unsigned long )(if_stats + local_if_count)->avg.first != (unsigned long )((void *)0))) {
#line 62
          goto while_break___0;
        }
        {
#line 63
        list_p = (if_stats + local_if_count)->avg.first;
#line 64
        (if_stats + local_if_count)->avg.first = ((if_stats + local_if_count)->avg.first)->next;
#line 65
        free((void *)list_p);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 59
      local_if_count ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 69
    free((void *)if_stats);
    }
  }
#line 72
  if ((unsigned long )iface_list != (unsigned long )((void *)0)) {
    {
#line 72
    free((void *)iface_list);
    }
  }
#line 75
  if ((unsigned long )out_file != (unsigned long )((void *)0)) {
    {
#line 75
    fclose(out_file);
    }
  }
#line 76
  if ((unsigned long )out_file_path != (unsigned long )((void *)0)) {
    {
#line 76
    free((void *)out_file_path);
    }
  }
#line 80
  if ((unsigned long )error_msg != (unsigned long )((void *)0)) {
    {
#line 81
    __builtin_va_start(ap, error_msg);
#line 82
    vprintf((char const   */* __restrict  */)error_msg, ap);
    }
  }
  {
#line 89
  exit(code);
  }
}
}
#line 94
 __attribute__((__noreturn__)) void sigint(int sig ) ;
#line 97
 __attribute__((__noreturn__)) void sigint(int sig ) ;
#line 97 "/home/june/collector/temp/bwm-ng-0.6/src/bwm-ng.c"
void sigint(int sig ) 
{ 


  {
  {
#line 99
  deinit(0, (char *)((void *)0));
  }
}
}
#line 102 "/home/june/collector/temp/bwm-ng-0.6/src/bwm-ng.c"
__inline void init(void) 
{ 


  {
  {
#line 103
  if_count = 0;
#line 104
  delay = 500U;
#line 106
  avg_length = 0U;
#line 108
  output_unit = (char)1;
#line 109
  output_type = (char)1;
#line 110
  show_all_if = (char)0;
#line 112
  output_method = 0;
#line 113
  mywin = (WINDOW *)((void *)0);
#line 114
  max_rt = 32U;
#line 115
  scale = 0U;
#line 116
  show_only_if = 0U;
#line 120
  iface_list = (char *)((void *)0);
#line 122
  csv_char = (char )';';
#line 126
  out_file = (FILE *)((void *)0);
#line 127
  out_file_path = (char *)((void *)0);
#line 130
  output_count = -1;
#line 131
  daemonize = (char)0;
#line 132
  sumhidden = (char)0;
#line 135
  input_method = 2;
#line 155
  ansi_output = (char)1;
#line 158
  html_refresh = 5;
#line 159
  html_header = 0;
#line 162
  skfd = -1;
#line 164
  if_stats = (t_iface_stats *)((void *)0);
#line 166
  strncpy((char */* __restrict  */)(PROC_FILE), (char const   */* __restrict  */)"/proc/net/dev",
          (size_t )4096);
#line 170
  strncpy((char */* __restrict  */)(PROC_DISKSTATS_FILE), (char const   */* __restrict  */)"/proc/diskstats",
          (size_t )4096);
#line 173
  strncpy((char */* __restrict  */)(PROC_PARTITIONS_FILE), (char const   */* __restrict  */)"/proc/partitions",
          (size_t )4096);
  }
#line 180
  return;
}
}
#line 183 "/home/june/collector/temp/bwm-ng-0.6/src/bwm-ng.c"
int main(int argc , char **argv ) 
{ 
  unsigned char idle_chars_p ;
  char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct _IO_FILE *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct _IO_FILE *tmp___6 ;

  {
  {
#line 184
  idle_chars_p = (unsigned char)0;
#line 187
  init();
#line 190
  get_cmdln_options(argc, argv);
  }
#line 192
  if (output_method < 0) {
    {
#line 193
    deinit(1, (char *)"invalid output selected\n");
    }
  }
#line 194
  if (input_method < 0) {
    {
#line 195
    deinit(1, (char *)"invalid input selected\n");
    }
  }
  {
#line 198
  memset((void *)(& if_stats_total), 0, sizeof(t_iface_stats ));
  }
#line 200
  if (output_method == 0) {
#line 200
    goto _L;
  } else
#line 200
  if (output_method == 5) {
    _L: /* CIL Label */ 
    {
#line 202
    tmp = init_curses();
    }
#line 202
    if (tmp) {
      {
#line 203
      signal(28, & sigwinch);
      }
    }
  }
  {
#line 207
  signal(2, & sigint);
#line 208
  signal(15, & sigint);
  }
#line 211
  if (output_method == 2) {
#line 211
    if (output_count > -1) {
      {
#line 212
      get_iface_stats((char)0);
#line 214
      tmp___0 = usleep(delay * 1000U);
      }
#line 214
      if (22 == tmp___0) {
        {
#line 216
        usleep((__useconds_t )999999);
        }
      }
    }
  }
#line 235
  if (output_count == 0) {
#line 235
    output_count = -1;
  }
#line 236
  if (output_method == 1) {
#line 236
    if (output_count == 1) {
#line 236
      output_method = 4;
    }
  }
#line 237
  if (output_method == 1) {
    {
#line 237
    printf((char const   */* __restrict  */)"\033[2J");
    }
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (output_method == 3) {
#line 241
      if (out_file_path) {
#line 242
        if (out_file) {
          {
#line 242
          fclose(out_file);
          }
        }
        {
#line 243
        out_file = fopen((char const   */* __restrict  */)out_file_path, (char const   */* __restrict  */)"w");
        }
      }
    }
#line 247
    if (output_method == 4) {
#line 247
      tmp___1 = 0;
    } else
#line 247
    if (output_method == 3) {
#line 247
      if (! daemonize) {
#line 247
        tmp___1 = 0;
      } else {
#line 247
        tmp___1 = 1;
      }
    } else {
#line 247
      tmp___1 = 1;
    }
#line 247
    ch = (char )tmp___1;
#line 254
    if (ch) {
      {
#line 254
      tmp___2 = print_header((int )idle_chars_p);
#line 254
      idle_chars_p = (unsigned char )tmp___2;
      }
    }
    {
#line 256
    get_iface_stats(ch);
    }
#line 260
    if (output_method == 3) {
#line 260
      if (html_header) {
#line 260
        if (daemonize) {
#line 261
          if ((unsigned long )out_file == (unsigned long )((void *)0)) {
#line 261
            tmp___3 = stdout;
          } else {
#line 261
            tmp___3 = out_file;
          }
          {
#line 261
          fprintf((FILE */* __restrict  */)tmp___3, (char const   */* __restrict  */)"</table>\n</body>\n</html>\n");
          }
        }
      }
    }
#line 263
    if (out_file) {
#line 263
      if (output_method == 3) {
#line 263
        if (daemonize) {
          {
#line 263
          fclose(out_file);
#line 263
          out_file = (FILE *)((void *)0);
          }
        }
      }
    }
#line 266
    if (output_method == 2) {
#line 266
      goto _L___0;
    } else
#line 266
    if (output_method == 1) {
      _L___0: /* CIL Label */ 
#line 266
      if (output_count > 0) {
#line 271
        output_count --;
#line 273
        if (output_count == 0) {
#line 273
          goto while_break;
        }
      }
    }
#line 277
    if (output_method == 0) {
      {
#line 278
      wrefresh(stdscr);
#line 279
      tmp___4 = wgetch(stdscr);
#line 279
      handle_gui_input((char )tmp___4);
      }
    } else
#line 277
    if (output_method == 5) {
      {
#line 278
      wrefresh(stdscr);
#line 279
      tmp___4 = wgetch(stdscr);
#line 279
      handle_gui_input((char )tmp___4);
      }
    } else {
      {
#line 284
      tmp___5 = usleep(delay * 1000U);
      }
#line 284
      if (tmp___5 == 22) {
        {
#line 285
        usleep((__useconds_t )999999);
#line 286
        delay = 999U;
        }
      }
    }
#line 293
    if (output_method == 4) {
#line 297
      goto while_break;
    } else
#line 293
    if (output_method == 3) {
#line 293
      if (! daemonize) {
#line 297
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (output_method == 3) {
#line 301
    if (! daemonize) {
      {
#line 302
      print_header(0);
#line 303
      get_iface_stats((char)1);
      }
#line 304
      if (html_header) {
#line 304
        if ((unsigned long )out_file == (unsigned long )((void *)0)) {
#line 304
          tmp___6 = stdout;
        } else {
#line 304
          tmp___6 = out_file;
        }
        {
#line 304
        fprintf((FILE */* __restrict  */)tmp___6, (char const   */* __restrict  */)"</table>\n</body>\n</html>\n");
        }
      }
    }
  }
#line 308
  if (output_method == 4) {
    {
#line 309
    print_header(0);
#line 310
    get_iface_stats((char)1);
    }
  }
  {
#line 312
  deinit(0, (char *)((void *)0));
  }
#line 313
  return (0);
}
}
#line 858 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 586 "/usr/include/curses.h"
extern _Bool can_change_color(void) ;
#line 587
extern int cbreak(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 718
extern int pair_content(short  , short * , short * ) ;
#line 764
extern int start_color(void) ;
#line 838
extern void wtimeout(WINDOW * , int  ) ;
#line 35 "/home/june/collector/temp/bwm-ng-0.6/src/help.h"
void print_online_help(void) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/curses_tools.c"
void handle_gui_input(char c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 33
  if ((int )c == 43) {
#line 33
    goto case_43;
  }
#line 37
  if ((int )c == 45) {
#line 37
    goto case_45;
  }
#line 44
  if ((int )c == 65) {
#line 44
    goto case_65;
  }
#line 44
  if ((int )c == 97) {
#line 44
    goto case_65;
  }
#line 55
  if ((int )c == 83) {
#line 55
    goto case_83;
  }
#line 55
  if ((int )c == 115) {
#line 55
    goto case_83;
  }
#line 64
  if ((int )c == 78) {
#line 64
    goto case_78;
  }
#line 64
  if ((int )c == 110) {
#line 64
    goto case_78;
  }
#line 76
  if ((int )c == 81) {
#line 76
    goto case_81;
  }
#line 76
  if ((int )c == 113) {
#line 76
    goto case_81;
  }
#line 83
  if ((int )c == 75) {
#line 83
    goto case_75;
  }
#line 83
  if ((int )c == 107) {
#line 83
    goto case_75;
  }
#line 83
  if ((int )c == 68) {
#line 83
    goto case_75;
  }
#line 83
  if ((int )c == 100) {
#line 83
    goto case_75;
  }
#line 92
  if ((int )c == 85) {
#line 92
    goto case_85;
  }
#line 92
  if ((int )c == 117) {
#line 92
    goto case_85;
  }
#line 102
  if ((int )c == 84) {
#line 102
    goto case_84;
  }
#line 102
  if ((int )c == 116) {
#line 102
    goto case_84;
  }
#line 110
  if ((int )c == 104) {
#line 110
    goto case_104;
  }
#line 31
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 34
  delay += 100U;
#line 35
  wtimeout(stdscr, (int )delay);
  }
#line 36
  goto switch_break;
  case_45: /* CIL Label */ 
#line 38
  if (delay > 100U) {
    {
#line 39
    delay += 4294967196U;
#line 40
    wtimeout(stdscr, (int )delay);
    }
  }
#line 42
  goto switch_break;
  case_65: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 45
  show_all_if = (char )((int )show_all_if + 1);
#line 46
  if ((int )show_all_if > 2) {
#line 46
    show_all_if = (char)0;
  }
#line 47
  if ((unsigned long )iface_list == (unsigned long )((void *)0)) {
#line 47
    if ((int )show_all_if == 1) {
#line 47
      show_all_if = (char)2;
    }
  }
  {
#line 49
  get_iface_stats((char)0);
#line 52
  usleep((__useconds_t )100);
  }
#line 53
  goto switch_break;
  case_83: /* CIL Label */ 
  case_115: /* CIL Label */ 
  {
#line 56
  sumhidden = (char )(! sumhidden);
#line 58
  get_iface_stats((char)0);
#line 61
  usleep((__useconds_t )100);
  }
#line 62
  goto switch_break;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    input_method <<= 1;
#line 67
    if (input_method > 131) {
#line 67
      input_method = 1;
    }
#line 65
    if (! (! (input_method & 131))) {
#line 65
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  free((void *)if_stats);
#line 71
  if_stats = (t_iface_stats *)((void *)0);
#line 72
  if_count = 0;
#line 73
  memset((void *)(& if_stats_total), 0, sizeof(t_iface_stats ));
  }
#line 74
  goto switch_break;
  case_81: /* CIL Label */ 
  case_113: /* CIL Label */ 
  {
#line 78
  deinit(0, (char *)((void *)0));
  }
#line 79
  goto switch_break;
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 84
  if (output_method == 5) {
#line 86
    show_only_if ++;
  } else {
#line 89
    dynamic = (char )(! dynamic);
  }
#line 90
  goto switch_break;
  case_85: /* CIL Label */ 
  case_117: /* CIL Label */ 
#line 93
  if (output_method == 0) {
#line 94
    if (! (input_method & 3)) {
#line 94
      if (input_method == 0) {
#line 94
        tmp = 2;
      } else {
#line 94
        tmp = 3;
      }
#line 94
      tmp___0 = tmp;
    } else {
#line 94
      tmp___0 = 4;
    }
#line 94
    if ((int )output_unit < tmp___0) {
#line 95
      output_unit = (char )((int )output_unit + 1);
    } else {
#line 97
      output_unit = (char)1;
    }
  }
#line 99
  goto switch_break;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 103
  if ((int )output_type < 4) {
#line 104
    output_type = (char )((int )output_type + 1);
  } else {
#line 106
    output_type = (char)1;
  }
#line 107
  if (output_method == 5) {
#line 107
    max_rt = 32U;
  }
#line 108
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 111
  print_online_help();
  }
#line 112
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 116 "/home/june/collector/temp/bwm-ng-0.6/src/curses_tools.c"
int init_curses(void) 
{ 
  struct winsize size ;
  short fg ;
  short bg ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 119
  mywin = initscr();
  }
#line 120
  if ((unsigned long )mywin != (unsigned long )((void *)0)) {
#line 120
    if (output_method == 5) {
      {
#line 120
      tmp___3 = has_colors();
      }
#line 120
      if (tmp___3) {
#line 120
        goto _L___1;
      } else {
        {
#line 120
        tmp___4 = can_change_color();
        }
#line 120
        if (tmp___4) {
#line 120
          goto _L___1;
        } else {
#line 120
          goto _L;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 121
      cbreak();
#line 122
      noecho();
#line 123
      nonl();
#line 125
      curs_set(0);
#line 127
      wtimeout(stdscr, (int )delay);
      }
#line 128
      if (output_method == 5) {
        {
#line 129
        start_color();
#line 130
        pair_content((short)0, & fg, & bg);
#line 131
        init_pair((short)1, fg, (short)2);
#line 132
        init_pair((short)2, fg, (short)1);
#line 133
        tmp = fileno(stdout);
#line 133
        tmp___0 = ioctl(tmp, 21523UL, & size);
        }
#line 133
        if (tmp___0 == 0) {
#line 134
          cols = size.ws_col;
#line 135
          rows = size.ws_row;
        }
      }
#line 138
      return (1);
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 140
    tmp___1 = __errno_location();
#line 140
    tmp___2 = strerror(*tmp___1);
#line 140
    printf((char const   */* __restrict  */)"curses newterm() failed: %s\n", tmp___2);
#line 141
    sleep(1U);
#line 142
    output_method = 1;
    }
#line 143
    return (0);
  }
}
}
#line 147 "/home/june/collector/temp/bwm-ng-0.6/src/curses_tools.c"
void sigwinch(int sig ) 
{ 
  struct winsize size ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 149
  tmp___2 = fileno(stdout);
#line 149
  tmp___3 = ioctl(tmp___2, 21523UL, & size);
  }
#line 149
  if (tmp___3 == 0) {
    {
#line 150
    tmp___1 = endwin();
    }
#line 150
    if (tmp___1 == -1) {
      {
#line 150
      tmp = __errno_location();
#line 150
      tmp___0 = strerror(*tmp);
#line 150
      deinit(1, (char *)"failed to deinit curses: %s\n", tmp___0);
      }
    }
    {
#line 151
    init_curses();
    }
  }
#line 153
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 776
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__const__)) ;
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 30 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
short show_iface(char *instr___0 , char *searchstr , char iface_is_up ) 
{ 
  int pos ;
  int k ;
  int i ;
  int success_ret ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 31
  pos = 0;
#line 31
  i = 0;
#line 31
  success_ret = 1;
#line 32
  if ((unsigned long )instr___0 == (unsigned long )((void *)0)) {
#line 32
    if (iface_is_up) {
#line 32
      tmp = 1;
    } else
#line 32
    if ((int )show_all_if == 2) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
#line 32
    return ((short )tmp);
  }
#line 33
  if ((int )*(instr___0 + 0) == 37) {
#line 34
    success_ret = ! success_ret;
#line 35
    i ++;
  }
  {
#line 37
  tmp___0 = strlen((char const   *)searchstr);
#line 37
  k = (int )tmp___0;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp___3 = strlen((char const   *)instr___0);
    }
#line 38
    if (! ((size_t )i <= tmp___3)) {
#line 38
      goto while_break;
    }
    {
#line 41
    if ((int )*(instr___0 + i) == 44) {
#line 41
      goto case_44;
    }
#line 41
    if ((int )*(instr___0 + i) == 0) {
#line 41
      goto case_44;
    }
#line 47
    goto switch_default;
    case_44: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 42
    if (k == pos) {
      {
#line 42
      tmp___2 = strncasecmp((char const   *)((instr___0 + i) - pos), (char const   *)searchstr,
                            (size_t )pos);
      }
#line 42
      if (! tmp___2) {
#line 43
        if (success_ret) {
#line 43
          tmp___1 = 1;
        } else
#line 43
        if (iface_is_up) {
#line 43
          if (show_all_if) {
#line 43
            tmp___1 = 1;
          } else {
#line 43
            tmp___1 = 0;
          }
        } else {
#line 43
          tmp___1 = 0;
        }
#line 43
        return ((short )tmp___1);
      }
    }
#line 45
    pos = 0;
#line 46
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 48
    pos ++;
#line 49
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 38
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (! success_ret) {
#line 52
    tmp___4 = 1;
  } else
#line 52
  if (iface_is_up) {
#line 52
    if (show_all_if) {
#line 52
      tmp___4 = 1;
    } else {
#line 52
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 52
  if ((int )show_all_if == 2) {
#line 52
    tmp___4 = 1;
  } else {
#line 52
    tmp___4 = 0;
  }
#line 52
  return ((short )tmp___4);
}
}
#line 59 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline long tvdiff(struct timeval newer , struct timeval older ) 
{ 
  long tmp ;

  {
  {
#line 60
  tmp = labs((newer.tv_sec - older.tv_sec) * 1000L + (newer.tv_usec - older.tv_usec) / 1000L);
  }
#line 60
  return (tmp);
}
}
#line 65 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
float get_time_delay(int iface_num ) 
{ 
  struct timeval now ;
  float ret ;
  long tmp ;

  {
  {
#line 68
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 69
  tmp = tvdiff(now, (if_stats + iface_num)->time);
#line 69
  ret = (float )1000 / (float )tmp;
#line 70
  (if_stats + iface_num)->time.tv_sec = now.tv_sec;
#line 71
  (if_stats + iface_num)->time.tv_usec = now.tv_usec;
  }
#line 72
  return (ret);
}
}
#line 77 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline unsigned long long calc_new_values(unsigned long long new , unsigned long long old ) 
{ 
  unsigned long long tmp ;

  {
#line 79
  if (new >= old) {
#line 79
    tmp = new - old;
  } else {
#line 79
    tmp = (0xffffffffffffffffULL - old) + new;
  }
#line 79
  return (tmp);
}
}
#line 90 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
t_iface_speed_stats convert2calced_values(t_iface_speed_stats new , t_iface_speed_stats old ) 
{ 
  t_iface_speed_stats calced_stats ;

  {
  {
#line 92
  calced_stats.errors.in = calc_new_values(new.errors.in, old.errors.in);
#line 93
  calced_stats.errors.out = calc_new_values(new.errors.out, old.errors.out);
#line 94
  calced_stats.packets.out = calc_new_values(new.packets.out, old.packets.out);
#line 95
  calced_stats.packets.in = calc_new_values(new.packets.in, old.packets.in);
#line 96
  calced_stats.bytes.out = calc_new_values(new.bytes.out, old.bytes.out);
#line 97
  calced_stats.bytes.in = calc_new_values(new.bytes.in, old.bytes.in);
  }
#line 98
  return (calced_stats);
}
}
#line 102 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
t_iface_speed_stats convert2calced_disk_values(t_iface_speed_stats new , t_iface_speed_stats old ) 
{ 
  t_iface_speed_stats calced_stats ;
  unsigned long long tmp ;
  unsigned long long tmp___0 ;
  unsigned long long tmp___1 ;
  unsigned long long tmp___2 ;

  {
  {
#line 104
  calced_stats.bytes.out = calc_new_values(new.bytes.out, old.bytes.out);
#line 105
  calced_stats.bytes.in = calc_new_values(new.bytes.in, old.bytes.in);
#line 107
  tmp = calc_new_values(new.packets.out, old.packets.out);
#line 107
  tmp___0 = calc_new_values(new.errors.out, old.errors.out);
#line 107
  calced_stats.packets.out = tmp * (tmp___0 + 1ULL);
#line 108
  tmp___1 = calc_new_values(new.packets.in, old.packets.in);
#line 108
  tmp___2 = calc_new_values(new.errors.in, old.errors.in);
#line 108
  calced_stats.packets.in = tmp___1 * (tmp___2 + 1ULL);
#line 109
  calced_stats.errors.in = 0ULL;
#line 110
  calced_stats.errors.out = 0ULL;
  }
#line 111
  return (calced_stats);
}
}
#line 118 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline void sub_avg_values(struct inouttotal_double *values , struct inouttotal_double data ) 
{ 


  {
#line 119
  values->in -= data.in;
#line 120
  values->out -= data.out;
#line 121
  values->total -= data.total;
#line 122
  return;
}
}
#line 124 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline void add_avg_values(struct inouttotal_double *values , struct inouttotal_double data ) 
{ 


  {
#line 125
  values->in += data.in;
#line 126
  values->out += data.out;
#line 127
  values->total += data.total;
#line 128
  return;
}
}
#line 133 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline void save_avg_values(struct inouttotal_double *values , struct inouttotal_double *data ,
                              struct inout_long calced_stats , float multiplier ) 
{ 


  {
  {
#line 134
  data->in = (long double )((float )calced_stats.in * multiplier);
#line 135
  data->out = (long double )((float )calced_stats.out * multiplier);
#line 136
  data->total = (long double )((float )(calced_stats.in + calced_stats.out) * multiplier);
#line 137
  add_avg_values(values, *data);
  }
#line 138
  return;
}
}
#line 145 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
void save_avg(struct t_avg *avg , struct iface_speed_stats calced_stats , float multiplier ) 
{ 
  struct double_list *list_p ;
  struct double_list *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 147
  if ((unsigned long )avg->first == (unsigned long )((void *)0)) {
    {
#line 148
    tmp___0 = malloc(sizeof(struct double_list ));
#line 148
    tmp = (struct double_list *)tmp___0;
#line 148
    avg->last = tmp;
#line 148
    avg->first = tmp;
#line 150
    memset((void *)avg->first, 0, sizeof(struct double_list ));
#line 152
    save_avg_values(& avg->item_sum.bytes, & (avg->first)->data.bytes, calced_stats.bytes,
                    multiplier);
#line 153
    save_avg_values(& avg->item_sum.errors, & (avg->first)->data.errors, calced_stats.errors,
                    multiplier);
#line 154
    save_avg_values(& avg->item_sum.packets, & (avg->first)->data.packets, calced_stats.packets,
                    multiplier);
#line 155
    avg->items = 1;
    }
  } else {
    {
#line 157
    tmp___1 = malloc(sizeof(struct double_list ));
#line 157
    (avg->last)->next = (struct double_list *)tmp___1;
#line 158
    memset((void *)(avg->last)->next, 0, sizeof(struct double_list ));
#line 159
    avg->last = (avg->last)->next;
#line 161
    save_avg_values(& avg->item_sum.bytes, & (avg->last)->data.bytes, calced_stats.bytes,
                    multiplier);
#line 162
    save_avg_values(& avg->item_sum.errors, & (avg->last)->data.errors, calced_stats.errors,
                    multiplier);
#line 163
    save_avg_values(& avg->item_sum.packets, & (avg->last)->data.packets, calced_stats.packets,
                    multiplier);
#line 164
    (avg->items) ++;
    }
    {
#line 168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 168
      if ((unsigned long )(avg->first)->next != (unsigned long )((void *)0)) {
#line 168
        if (! ((unsigned int )avg->items > avg_length / delay)) {
#line 168
          goto while_break;
        }
      } else {
#line 168
        goto while_break;
      }
      {
#line 170
      list_p = avg->first;
#line 171
      avg->first = (avg->first)->next;
#line 173
      sub_avg_values(& avg->item_sum.bytes, list_p->data.bytes);
#line 174
      sub_avg_values(& avg->item_sum.errors, list_p->data.errors);
#line 175
      sub_avg_values(& avg->item_sum.packets, list_p->data.packets);
#line 176
      free((void *)list_p);
#line 177
      (avg->items) --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 180
  return;
}
}
#line 183 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline void save_sum(struct inout_long *stats , struct inout_long new_stats_values ) 
{ 


  {
#line 184
  stats->in += new_stats_values.in;
#line 185
  stats->out += new_stats_values.out;
#line 186
  return;
}
}
#line 189 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
__inline void save_max(struct inouttotal_double *stats , struct inout_long calced_stats ,
                       float multiplier ) 
{ 


  {
#line 190
  if ((long double )(multiplier * (float )calced_stats.in) > stats->in) {
#line 191
    stats->in = (long double )(multiplier * (float )calced_stats.in);
  }
#line 192
  if ((long double )(multiplier * (float )calced_stats.out) > stats->out) {
#line 193
    stats->out = (long double )(multiplier * (float )calced_stats.out);
  }
#line 194
  if ((long double )(multiplier * (float )(calced_stats.out + calced_stats.in)) > stats->total) {
#line 195
    stats->total = (long double )(multiplier * (float )(calced_stats.in + calced_stats.out));
  }
#line 196
  return;
}
}
#line 202 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
int process_if_data(int hidden_if , t_iface_speed_stats tmp_if_stats , t_iface_speed_stats *stats ,
                    char *name , int iface_number , char verbose , char iface_is_up ) 
{ 
  float multiplier ;
  int local_if_count ;
  t_iface_speed_stats calced_stats ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  short tmp___3 ;
  float tmp___4 ;
  short tmp___5 ;
  short tmp___6 ;

  {
#line 212
  local_if_count = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (local_if_count < if_count)) {
#line 212
      goto while_break;
    }
    {
#line 214
    tmp = strcmp((char const   *)name, (char const   *)(if_stats + local_if_count)->if_name);
    }
#line 214
    if (! tmp) {
#line 214
      goto while_break;
    }
#line 212
    local_if_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if (local_if_count == if_count) {
    {
#line 218
    if_count ++;
#line 220
    tmp___0 = realloc((void *)if_stats, sizeof(t_iface_stats ) * (unsigned long )if_count);
#line 220
    if_stats = (t_iface_stats *)tmp___0;
#line 221
    memset((void *)(if_stats + local_if_count), 0, sizeof(t_iface_stats ));
    }
#line 223
    if ((int )*(name + 0) != 0) {
      {
#line 224
      tmp___1 = strdup((char const   *)name);
#line 224
      (if_stats + (if_count - 1))->if_name = tmp___1;
      }
    } else {
      {
#line 226
      tmp___2 = strdup("unknown");
#line 226
      (if_stats + (if_count - 1))->if_name = tmp___2;
      }
    }
    {
#line 228
    (if_stats + local_if_count)->data = tmp_if_stats;
#line 229
    tmp___3 = show_iface(iface_list, name, iface_is_up);
    }
#line 229
    if (tmp___3) {
#line 229
      if (input_method & 3) {
#line 229
        goto _L;
      } else
#line 229
      if (iface_is_up) {
        _L: /* CIL Label */ 
#line 231
        if_stats_total.data.bytes.out += tmp_if_stats.bytes.out;
#line 232
        if_stats_total.data.bytes.in += tmp_if_stats.bytes.in;
#line 233
        if_stats_total.data.packets.out += tmp_if_stats.packets.out;
#line 234
        if_stats_total.data.packets.in += tmp_if_stats.packets.in;
#line 235
        if_stats_total.data.errors.out += tmp_if_stats.errors.out;
#line 236
        if_stats_total.data.errors.in += tmp_if_stats.errors.in;
      }
    }
  }
  {
#line 240
  tmp___4 = get_time_delay(local_if_count);
#line 240
  multiplier = tmp___4;
  }
#line 243
  if (input_method & 3) {
    {
#line 244
    calced_stats = convert2calced_values(tmp_if_stats, (if_stats + local_if_count)->data);
    }
  } else {
    {
#line 246
    calced_stats = convert2calced_disk_values(tmp_if_stats, (if_stats + local_if_count)->data);
    }
  }
  {
#line 249
  save_max(& (if_stats + local_if_count)->max.bytes, calced_stats.bytes, multiplier);
#line 250
  save_max(& (if_stats + local_if_count)->max.errors, calced_stats.errors, multiplier);
#line 251
  save_max(& (if_stats + local_if_count)->max.packets, calced_stats.packets, multiplier);
#line 253
  save_sum(& (if_stats + local_if_count)->sum.bytes, calced_stats.bytes);
#line 254
  save_sum(& (if_stats + local_if_count)->sum.packets, calced_stats.packets);
#line 255
  save_sum(& (if_stats + local_if_count)->sum.errors, calced_stats.errors);
#line 257
  save_avg(& (if_stats + local_if_count)->avg, calced_stats, multiplier);
  }
#line 259
  if (verbose) {
    {
#line 261
    tmp___5 = show_iface(iface_list, name, iface_is_up);
    }
#line 261
    if (tmp___5) {
      {
#line 262
      print_values((5 + iface_number) - hidden_if, 2, name, calced_stats, multiplier,
                   *(if_stats + local_if_count));
      }
    } else {
#line 264
      hidden_if ++;
    }
  }
  {
#line 267
  (if_stats + local_if_count)->data = tmp_if_stats;
#line 269
  tmp___6 = show_iface(iface_list, name, iface_is_up);
  }
#line 269
  if (tmp___6) {
#line 270
    stats->bytes.out += tmp_if_stats.bytes.out;
#line 271
    stats->bytes.in += tmp_if_stats.bytes.in;
#line 272
    stats->packets.out += tmp_if_stats.packets.out;
#line 273
    stats->packets.in += tmp_if_stats.packets.in;
#line 274
    stats->errors.out += tmp_if_stats.errors.out;
#line 275
    stats->errors.in += tmp_if_stats.errors.in;
  }
#line 277
  return (hidden_if);
}
}
#line 281 "/home/june/collector/temp/bwm-ng-0.6/src/process.c"
void finish_iface_stats(char verbose , t_iface_speed_stats stats , int hidden_if ,
                        int iface_number ) 
{ 
  int i ;
  t_iface_speed_stats calced_stats ;
  struct timeval now ;
  float multiplier ;
  long tmp ;
  char const   *tmp___0 ;

  {
  {
#line 287
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 288
  tmp = tvdiff(now, if_stats_total.time);
#line 288
  multiplier = (float )1000 / (float )tmp;
#line 289
  if_stats_total.time.tv_sec = now.tv_sec;
#line 290
  if_stats_total.time.tv_usec = now.tv_usec;
  }
#line 294
  if (input_method & 3) {
    {
#line 295
    calced_stats = convert2calced_values(stats, if_stats_total.data);
    }
  } else {
    {
#line 297
    calced_stats = convert2calced_disk_values(stats, if_stats_total.data);
    }
  }
  {
#line 300
  save_max(& if_stats_total.max.bytes, calced_stats.bytes, multiplier);
#line 301
  save_max(& if_stats_total.max.errors, calced_stats.errors, multiplier);
#line 302
  save_max(& if_stats_total.max.packets, calced_stats.packets, multiplier);
#line 303
  save_sum(& if_stats_total.sum.bytes, calced_stats.bytes);
#line 304
  save_sum(& if_stats_total.sum.packets, calced_stats.packets);
#line 305
  save_sum(& if_stats_total.sum.errors, calced_stats.errors);
#line 306
  save_avg(& if_stats_total.avg, calced_stats, multiplier);
  }
#line 308
  if (verbose) {
#line 311
    if (output_method == 0) {
      {
#line 312
      mvwprintw(stdscr, (5 + iface_number) - hidden_if, 2, "------------------------------------------------------------------------------");
      }
    } else
#line 315
    if (output_method == 1) {
#line 315
      goto _L;
    } else
#line 315
    if (output_method == 4) {
      _L: /* CIL Label */ 
#line 316
      if (output_method == 1) {
#line 316
        tmp___0 = " ";
      } else {
#line 316
        tmp___0 = "";
      }
      {
#line 316
      printf((char const   */* __restrict  */)"%s------------------------------------------------------------------------------\n",
             tmp___0);
      }
    }
    {
#line 317
    print_values((6 + iface_number) - hidden_if, 2, (char *)"total", calced_stats,
                 multiplier, if_stats_total);
    }
  }
#line 320
  if_stats_total.data = stats;
#line 321
  if (output_method == 1) {
#line 322
    i = 0;
    {
#line 322
    while (1) {
      while_continue: /* CIL Label */ ;
#line 322
      if (! (i < if_count - iface_number)) {
#line 322
        goto while_break;
      }
      {
#line 322
      printf((char const   */* __restrict  */)"%70s\n", " ");
#line 322
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 323
  return;
}
}
#line 603 "/usr/include/curses.h"
extern int delwin(WINDOW * ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 27 "/home/june/collector/temp/bwm-ng-0.6/src/help.c"
__inline void print_help_line(char *short_c , char *long_c , char *descr ) 
{ 


  {
  {
#line 29
  printf((char const   */* __restrict  */)"  %-23s", long_c);
#line 33
  printf((char const   */* __restrict  */)" %s\n", descr);
  }
#line 34
  return;
}
}
#line 38
 __attribute__((__noreturn__)) void cmdln_printhelp(void) ;
#line 38 "/home/june/collector/temp/bwm-ng-0.6/src/help.c"
void cmdln_printhelp(void) 
{ 


  {
  {
#line 39
  printf((char const   */* __restrict  */)"Bandwidth Monitor NG (bwm-ng) v0.6\nCopyright (C) 2004-2007 Volker Gropp <bwmng@gropp.org>\n");
#line 40
  printf((char const   */* __restrict  */)"USAGE: bwm-ng [OPTION] ...");
#line 42
  printf((char const   */* __restrict  */)" [CONFIGFILE]\n");
#line 46
  printf((char const   */* __restrict  */)"displays current ethernet interfaces stats\n\n");
#line 47
  printf((char const   */* __restrict  */)"Options:\n");
#line 48
  print_help_line((char *)"-t <msec>", (char *)"-t, --timeout <msec>", (char *)"displays stats every <msec> (1msec = 1/1000sec)");
#line 49
  print_help_line((char *)"", (char *)"", (char *)"default: 500");
#line 50
  print_help_line((char *)"-d", (char *)"-d, --dynamic [value]", (char *)"show values dynamicly (Byte KB or MB)");
#line 51
  print_help_line((char *)"-a [mode]", (char *)"-a, --allif [mode]", (char *)"where mode is one of:");
#line 52
  print_help_line((char *)"", (char *)"", (char *)"0=show only up (and selected) interfaces");
#line 53
  print_help_line((char *)"", (char *)"", (char *)"1=show all up interfaces (default)");
#line 54
  print_help_line((char *)"", (char *)"", (char *)"2=show all and down interfaces");
#line 55
  print_help_line((char *)"-I <list>", (char *)"-I, --interfaces <list>", (char *)"show only interfaces in <list> (comma seperated), or");
#line 56
  print_help_line((char *)"", (char *)"", (char *)"if list is prefaced with % show all but interfaces");
#line 57
  print_help_line((char *)"", (char *)"", (char *)"in list");
#line 58
  print_help_line((char *)"-S", (char *)"-S, --sumhidden [value]", (char *)"count hidden interfaces for total");
#line 60
  print_help_line((char *)"-A", (char *)"-A, --avglength <sec>", (char *)"sets the span of average stats (Default 30s)");
#line 62
  print_help_line((char *)"-D", (char *)"-D, --daemon [value]", (char *)"fork into background and daemonize");
#line 63
  print_help_line((char *)"-h", (char *)"-h, --help", (char *)"displays this help");
#line 64
  print_help_line((char *)"-V", (char *)"-V, --version", (char *)"print version info");
#line 65
  printf((char const   */* __restrict  */)"\nInput:\n");
#line 66
  print_help_line((char *)"-i <method>", (char *)"-i, --input <method>", (char *)"input method, one of: proc netstat disk");
#line 68
  print_help_line((char *)"-f <file>", (char *)"-f, --procfile <file>", (char *)"filename to read raw data from. (/proc/net/dev)");
#line 71
  print_help_line((char *)"", (char *)"    --diskstatsfile <file>", (char *)"filename to read diskstats (Linux 2.6+) from. (/proc/diskstats)");
#line 72
  print_help_line((char *)"", (char *)"    --partitionsfile <file>", (char *)"filename to read diskstats (Linux 2.4) from. (/proc/partitions)");
#line 79
  printf((char const   */* __restrict  */)"\nOutput:\n");
#line 80
  print_help_line((char *)"-o <method>", (char *)"-o, --output <method>", (char *)"output method, one of: ");
#line 81
  print_help_line((char *)"", (char *)"", (char *)"plain, curses, curses2, csv, html");
#line 82
  print_help_line((char *)"-u", (char *)"-u, --unit <value>", (char *)"unit to show. one of bytes, bits, packets, errors");
#line 84
  print_help_line((char *)"-T", (char *)"-T, --type <value>", (char *)"type of stats. one of rate, max, sum, avg");
#line 87
  print_help_line((char *)"-C <char>", (char *)"-C, --csvchar <char>", (char *)"delimiter for csv");
#line 90
  print_help_line((char *)"-F <file>", (char *)"-F, --outfile <file>", (char *)"output file for csv and html (default stdout)");
#line 93
  print_help_line((char *)"-R <num>", (char *)"-R, --htmlrefresh <num>", (char *)"meta refresh for html output");
#line 94
  print_help_line((char *)"-H", (char *)"-H, --htmlheader", (char *)"show <html> and <meta> frame for html output");
#line 96
  print_help_line((char *)"-c <num>", (char *)"-c, --count <num>", (char *)"number of query/output for plain & csv");
#line 97
  print_help_line((char *)"-N", (char *)"-N, --ansiout", (char *)"disable ansi codes for plain output");
#line 98
  print_help_line((char *)"", (char *)"", (char *)"(ie 1 for one single output)");
#line 99
  printf((char const   */* __restrict  */)"\n");
#line 100
  exit(0);
  }
}
}
#line 104 "/home/june/collector/temp/bwm-ng-0.6/src/help.c"
void print_online_help(void) 
{ 
  WINDOW *helpwin ;

  {
  {
#line 106
  helpwin = newwin(15, 76, 0, 1);
#line 107
  wborder(helpwin, acs_map[(unsigned char )'x'], acs_map[(unsigned char )'x'], acs_map[(unsigned char )'q'],
          acs_map[(unsigned char )'q'], (chtype )0, (chtype )0, (chtype )0, (chtype )0);
#line 108
  mvwprintw(helpwin, 0, 2, "bwm-ng v0.6 - Keybindings:");
#line 109
  mvwprintw(helpwin, 2, 2, "\'h\'  show this help");
#line 110
  mvwprintw(helpwin, 3, 2, "\'q\'  exit");
#line 111
  mvwprintw(helpwin, 4, 2, "\'+\'  increases timeout by 100ms");
#line 112
  mvwprintw(helpwin, 5, 2, "\'-\'  decreases timeout by 100ms");
  }
#line 113
  if (output_method == 0) {
    {
#line 114
    mvwprintw(helpwin, 6, 2, "\'d\'  switch KB and auto assign Byte/KB/MB/GB");
    }
  } else {
    {
#line 116
    mvwprintw(helpwin, 6, 2, "\'d\'  cycle: show interfaces step by step");
    }
  }
  {
#line 117
  mvwprintw(helpwin, 7, 2, "\'a\'  cycle: show all interfaces, only those which are up,");
#line 118
  mvwprintw(helpwin, 8, 2, "            only up and not hidden");
#line 119
  mvwprintw(helpwin, 9, 2, "\'s\'  sum hidden ifaces to total aswell or not");
#line 120
  mvwprintw(helpwin, 10, 2, "\'n\'  cycle: input methods");
  }
#line 121
  if (output_method == 0) {
    {
#line 121
    mvwprintw(helpwin, 11, 2, "\'u\'  cycle: bytes,bits,packets,errors");
#line 123
    mvwprintw(helpwin, 12, 2, "\'t\'  cycle: current rate, max, sum since start, average for last 30s");
    }
  } else {
    {
#line 128
    mvwprintw(helpwin, 11, 2, "\'t\'  cycle: current rate, max, sum since start, average for last 30s");
    }
  }
  {
#line 131
  mvwprintw(helpwin, 14, 2, " press any key to continue... ");
#line 132
  wrefresh(helpwin);
#line 133
  wtimeout(stdscr, -1);
#line 134
  wgetch(stdscr);
#line 135
  wtimeout(stdscr, (int )delay);
#line 136
  delwin(helpwin);
  }
#line 137
  return;
}
}
