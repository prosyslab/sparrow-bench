/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 67 "../lib/headers/gss/api.h"
struct gss_ctx_id_struct;
#line 67 "../lib/headers/gss/api.h"
typedef struct gss_ctx_id_struct *gss_ctx_id_t;
#line 80 "../lib/headers/gss/api.h"
typedef unsigned int gss_uint32;
#line 89 "../lib/headers/gss/api.h"
typedef gss_uint32 OM_uint32;
#line 91 "../lib/headers/gss/api.h"
struct gss_OID_desc_struct {
   OM_uint32 length ;
   void *elements ;
};
#line 91 "../lib/headers/gss/api.h"
typedef struct gss_OID_desc_struct *gss_OID;
#line 103 "../lib/headers/gss/api.h"
struct gss_buffer_desc_struct {
   size_t length ;
   void *value ;
};
#line 103 "../lib/headers/gss/api.h"
typedef struct gss_buffer_desc_struct *gss_buffer_t;
#line 121 "../lib/headers/gss/api.h"
typedef OM_uint32 gss_qop_t;
#line 60 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/internal.h"
struct gss_ctx_id_struct {
   gss_OID mech ;
};
#line 68 "../lib/headers/gss/api.h"
struct gss_cred_id_struct;
#line 68 "../lib/headers/gss/api.h"
typedef struct gss_cred_id_struct *gss_cred_id_t;
#line 69
struct gss_name_struct;
#line 69 "../lib/headers/gss/api.h"
typedef struct gss_name_struct *gss_name_t;
#line 91 "../lib/headers/gss/api.h"
typedef struct gss_OID_desc_struct gss_OID_desc;
#line 97 "../lib/headers/gss/api.h"
struct gss_OID_set_desc_struct {
   size_t count ;
   gss_OID elements ;
};
#line 97 "../lib/headers/gss/api.h"
typedef struct gss_OID_set_desc_struct *gss_OID_set;
#line 103 "../lib/headers/gss/api.h"
typedef struct gss_buffer_desc_struct gss_buffer_desc;
#line 109 "../lib/headers/gss/api.h"
struct gss_channel_bindings_struct {
   OM_uint32 initiator_addrtype ;
   gss_buffer_desc initiator_address ;
   OM_uint32 acceptor_addrtype ;
   gss_buffer_desc acceptor_address ;
   gss_buffer_desc application_data ;
};
#line 109 "../lib/headers/gss/api.h"
typedef struct gss_channel_bindings_struct *gss_channel_bindings_t;
#line 123 "../lib/headers/gss/api.h"
typedef int gss_cred_usage_t;
#line 654 "../lib/headers/gss/api.h"
typedef gss_OID_desc const   *gss_const_OID;
#line 45 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/internal.h"
struct gss_name_struct {
   size_t length ;
   char *value ;
   gss_OID type ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/internal.h"
struct gss_cred_id_struct {
   gss_OID mech ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.h"
struct _gss_mech_api_struct {
   gss_OID mech ;
   char const   *sasl_name ;
   char const   *mech_name ;
   char const   *mech_description ;
   gss_OID name_types[5] ;
   OM_uint32 (*init_sec_context)(OM_uint32 *minor_status , gss_cred_id_t const   initiator_cred_handle ,
                                 gss_ctx_id_t *context_handle , gss_name_t const   target_name ,
                                 gss_OID const   mech_type , OM_uint32 req_flags ,
                                 OM_uint32 time_req , gss_channel_bindings_t const   input_chan_bindings ,
                                 gss_buffer_t const   input_token , gss_OID *actual_mech_type ,
                                 gss_buffer_t output_token , OM_uint32 *ret_flags ,
                                 OM_uint32 *time_rec ) ;
   OM_uint32 (*canonicalize_name)(OM_uint32 *minor_status , gss_name_t const   input_name ,
                                  gss_OID const   mech_type , gss_name_t *output_name ) ;
   OM_uint32 (*export_name)(OM_uint32 *minor_status , gss_name_t const   input_name ,
                            gss_buffer_t exported_name ) ;
   OM_uint32 (*wrap)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     int conf_req_flag , gss_qop_t qop_req , gss_buffer_t const   input_message_buffer ,
                     int *conf_state , gss_buffer_t output_message_buffer ) ;
   OM_uint32 (*unwrap)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                       gss_buffer_t const   input_message_buffer , gss_buffer_t output_message_buffer ,
                       int *conf_state , gss_qop_t *qop_state ) ;
   OM_uint32 (*get_mic)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                        gss_qop_t qop_req , gss_buffer_t const   message_buffer ,
                        gss_buffer_t message_token ) ;
   OM_uint32 (*verify_mic)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                           gss_buffer_t const   message_buffer , gss_buffer_t const   token_buffer ,
                           gss_qop_t *qop_state ) ;
   OM_uint32 (*display_status)(OM_uint32 *minor_status , OM_uint32 status_value ,
                               int status_type , gss_OID const   mech_type , OM_uint32 *message_context ,
                               gss_buffer_t status_string ) ;
   OM_uint32 (*acquire_cred)(OM_uint32 *minor_status , gss_name_t const   desired_name ,
                             OM_uint32 time_req , gss_OID_set const   desired_mechs ,
                             gss_cred_usage_t cred_usage , gss_cred_id_t *output_cred_handle ,
                             gss_OID_set *actual_mechs , OM_uint32 *time_rec ) ;
   OM_uint32 (*release_cred)(OM_uint32 *minor_status , gss_cred_id_t *cred_handle ) ;
   OM_uint32 (*accept_sec_context)(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                   gss_cred_id_t const   acceptor_cred_handle , gss_buffer_t const   input_token_buffer ,
                                   gss_channel_bindings_t const   input_chan_bindings ,
                                   gss_name_t *src_name , gss_OID *mech_type , gss_buffer_t output_token ,
                                   OM_uint32 *ret_flags , OM_uint32 *time_rec , gss_cred_id_t *delegated_cred_handle ) ;
   OM_uint32 (*delete_sec_context)(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                   gss_buffer_t output_token ) ;
   OM_uint32 (*context_time)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                             OM_uint32 *time_rec ) ;
   OM_uint32 (*inquire_cred)(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                             gss_name_t *name , OM_uint32 *lifetime , gss_cred_usage_t *cred_usage ,
                             gss_OID_set *mechanisms ) ;
   OM_uint32 (*inquire_cred_by_mech)(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                                     gss_OID const   mech_type , gss_name_t *name ,
                                     OM_uint32 *initiator_lifetime , OM_uint32 *acceptor_lifetime ,
                                     gss_cred_usage_t *cred_usage ) ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.h"
typedef struct _gss_mech_api_struct *_gss_mech_api_t;
#line 30 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.h"
typedef struct _gss_mech_api_struct _gss_mech_api_desc;
#line 28 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
struct gss_status_codes {
   gss_uint32 err ;
   char const   *name ;
   char const   *text ;
};
#line 648 "../lib/headers/gss/api.h"
typedef gss_buffer_desc const   *gss_const_buffer_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss_cmd.h"
struct gengetopt_args_info {
   char const   *help_help ;
   char const   *version_help ;
   long major_arg ;
   char *major_orig ;
   char const   *major_help ;
   char const   *list_mechanisms_help ;
   int quiet_flag ;
   char const   *quiet_help ;
   unsigned int help_given ;
   unsigned int version_given ;
   unsigned int major_given ;
   unsigned int list_mechanisms_given ;
   unsigned int quiet_given ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 442 "../lib/headers/gss/api.h"
OM_uint32 gss_get_mic(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                      gss_qop_t qop_req , gss_buffer_t const   message_buffer , gss_buffer_t message_token ) ;
#line 448
OM_uint32 gss_verify_mic(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                         gss_buffer_t const   message_buffer , gss_buffer_t const   token_buffer ,
                         gss_qop_t *qop_state ) ;
#line 454
OM_uint32 gss_wrap(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                   int conf_req_flag , gss_qop_t qop_req , gss_buffer_t const   input_message_buffer ,
                   int *conf_state , gss_buffer_t output_message_buffer ) ;
#line 462
OM_uint32 gss_unwrap(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     gss_buffer_t const   input_message_buffer , gss_buffer_t output_message_buffer ,
                     int *conf_state , gss_qop_t *qop_state ) ;
#line 603
OM_uint32 gss_sign(OM_uint32 *minor_status , gss_ctx_id_t context_handle , int qop_req ,
                   gss_buffer_t message_buffer , gss_buffer_t message_token ) ;
#line 610
OM_uint32 gss_verify(OM_uint32 *minor_status , gss_ctx_id_t context_handle , gss_buffer_t message_buffer ,
                     gss_buffer_t token_buffer , int *qop_state ) ;
#line 616
OM_uint32 gss_seal(OM_uint32 *minor_status , gss_ctx_id_t context_handle , int conf_req_flag ,
                   int qop_req , gss_buffer_t input_message_buffer , int *conf_state ,
                   gss_buffer_t output_message_buffer ) ;
#line 625
OM_uint32 gss_unseal(OM_uint32 *minor_status , gss_ctx_id_t context_handle , gss_buffer_t input_message_buffer ,
                     gss_buffer_t output_message_buffer , int *conf_state , int *qop_state ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/obsolete.c"
OM_uint32 gss_sign(OM_uint32 *minor_status , gss_ctx_id_t context_handle , int qop_req ,
                   gss_buffer_t message_buffer , gss_buffer_t message_token ) 
{ 
  OM_uint32 tmp ;

  {
  {
#line 31
  tmp = gss_get_mic(minor_status, (gss_ctx_id_t const   )context_handle, (gss_qop_t )qop_req,
                    (gss_buffer_t const   )message_buffer, message_token);
  }
#line 31
  return (tmp);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/obsolete.c"
OM_uint32 gss_verify(OM_uint32 *minor_status , gss_ctx_id_t context_handle , gss_buffer_t message_buffer ,
                     gss_buffer_t token_buffer , int *qop_state ) 
{ 
  OM_uint32 tmp ;

  {
  {
#line 42
  tmp = gss_verify_mic(minor_status, (gss_ctx_id_t const   )context_handle, (gss_buffer_t const   )message_buffer,
                       (gss_buffer_t const   )token_buffer, (gss_qop_t *)qop_state);
  }
#line 42
  return (tmp);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/obsolete.c"
OM_uint32 gss_seal(OM_uint32 *minor_status , gss_ctx_id_t context_handle , int conf_req_flag ,
                   int qop_req , gss_buffer_t input_message_buffer , int *conf_state ,
                   gss_buffer_t output_message_buffer ) 
{ 
  OM_uint32 tmp ;

  {
  {
#line 54
  tmp = gss_wrap(minor_status, (gss_ctx_id_t const   )context_handle, conf_req_flag,
                 (gss_qop_t )qop_req, (gss_buffer_t const   )input_message_buffer,
                 conf_state, output_message_buffer);
  }
#line 54
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/obsolete.c"
OM_uint32 gss_unseal(OM_uint32 *minor_status , gss_ctx_id_t context_handle , gss_buffer_t input_message_buffer ,
                     gss_buffer_t output_message_buffer , int *conf_state , int *qop_state ) 
{ 
  OM_uint32 tmp ;

  {
  {
#line 67
  tmp = gss_unwrap(minor_status, (gss_ctx_id_t const   )context_handle, (gss_buffer_t const   )input_message_buffer,
                   output_message_buffer, conf_state, (gss_qop_t *)qop_state);
  }
#line 67
  return (tmp);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 476 "../lib/headers/gss/api.h"
OM_uint32 gss_indicate_mechs(OM_uint32 *minor_status , gss_OID_set *mech_set ) ;
#line 479
OM_uint32 gss_compare_name(OM_uint32 *minor_status , gss_name_t const   name1 , gss_name_t const   name2 ,
                           int *name_equal ) ;
#line 484
OM_uint32 gss_display_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                           gss_buffer_t output_name_buffer , gss_OID *output_name_type ) ;
#line 490
OM_uint32 gss_import_name(OM_uint32 *minor_status , gss_buffer_t const   input_name_buffer ,
                          gss_OID const   input_name_type , gss_name_t *output_name ) ;
#line 495
OM_uint32 gss_export_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                          gss_buffer_t exported_name ) ;
#line 499
OM_uint32 gss_release_name(OM_uint32 *minor_status , gss_name_t *name ) ;
#line 503
OM_uint32 gss_release_oid_set(OM_uint32 *minor_status , gss_OID_set *set ) ;
#line 560
OM_uint32 gss_create_empty_oid_set(OM_uint32 *minor_status , gss_OID_set *oid_set ) ;
#line 563
OM_uint32 gss_add_oid_set_member(OM_uint32 *minor_status , gss_OID const   member_oid ,
                                 gss_OID_set *oid_set ) ;
#line 567
OM_uint32 gss_test_oid_set_member(OM_uint32 *minor_status , gss_OID const   member ,
                                  gss_OID_set const   set , int *present ) ;
#line 572
OM_uint32 gss_inquire_names_for_mech(OM_uint32 *minor_status , gss_OID const   mechanism ,
                                     gss_OID_set *name_types ) ;
#line 577
OM_uint32 gss_inquire_mechs_for_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                                     gss_OID_set *mech_types ) ;
#line 582
OM_uint32 gss_canonicalize_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                                gss_OID const   mech_type , gss_name_t *output_name ) ;
#line 587
OM_uint32 gss_duplicate_name(OM_uint32 *minor_status , gss_name_t const   src_name ,
                             gss_name_t *dest_name ) ;
#line 659
int gss_oid_equal(gss_const_OID first_oid , gss_const_OID second_oid ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.h"
_gss_mech_api_t _gss_find_mech(gss_OID const   oid ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_import_name(OM_uint32 *minor_status , gss_buffer_t const   input_name_buffer ,
                          gss_OID const   input_name_type , gss_name_t *output_name ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 67
  if (! output_name) {
#line 69
    if (minor_status) {
#line 70
      *minor_status = (OM_uint32 )0;
    }
#line 71
    return ((OM_uint32 )((2UL << 16) | (2UL << 24)));
  }
  {
#line 74
  tmp = malloc(sizeof(*(*output_name)));
#line 74
  *output_name = (gss_name_t )tmp;
  }
#line 75
  if (! *output_name) {
#line 77
    if (minor_status) {
#line 78
      *minor_status = (OM_uint32 )12;
    }
#line 79
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 81
  (*output_name)->length = input_name_buffer->length;
#line 82
  tmp___0 = malloc(input_name_buffer->length);
#line 82
  (*output_name)->value = (char *)tmp___0;
  }
#line 83
  if (! (*output_name)->value) {
    {
#line 85
    free((void *)*output_name);
    }
#line 86
    if (minor_status) {
#line 87
      *minor_status = (OM_uint32 )12;
    }
#line 88
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 90
  memcpy((void */* __restrict  */)(*output_name)->value, (void const   */* __restrict  */)input_name_buffer->value,
         input_name_buffer->length);
#line 93
  (*output_name)->type = (gss_OID )input_name_type;
  }
#line 95
  if (minor_status) {
#line 96
    *minor_status = (OM_uint32 )0;
  }
#line 97
  return ((OM_uint32 )0);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_display_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                           gss_buffer_t output_name_buffer , gss_OID *output_name_type ) 
{ 


  {
#line 139
  if (! input_name) {
#line 141
    if (minor_status) {
#line 142
      *minor_status = (OM_uint32 )0;
    }
#line 143
    return ((OM_uint32 )(2UL << 16));
  }
  {
#line 146
  output_name_buffer->length = input_name->length;
#line 147
  output_name_buffer->value = malloc(input_name->length + 1UL);
  }
#line 148
  if (! output_name_buffer->value) {
#line 150
    if (minor_status) {
#line 151
      *minor_status = (OM_uint32 )12;
    }
#line 152
    return ((OM_uint32 )(13UL << 16));
  }
#line 154
  if (input_name->value) {
    {
#line 155
    memcpy((void */* __restrict  */)output_name_buffer->value, (void const   */* __restrict  */)input_name->value,
           input_name->length);
    }
  }
#line 157
  if (output_name_type) {
#line 158
    *output_name_type = input_name->type;
  }
#line 160
  if (minor_status) {
#line 161
    *minor_status = (OM_uint32 )0;
  }
#line 162
  return ((OM_uint32 )0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_compare_name(OM_uint32 *minor_status , gss_name_t const   name1 , gss_name_t const   name2 ,
                           int *name_equal ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 194
  if (minor_status) {
#line 195
    *minor_status = (OM_uint32 )0;
  }
#line 197
  if (! name1) {
#line 198
    return ((OM_uint32 )((2UL << 16) | (1UL << 24)));
  } else
#line 197
  if (! name2) {
#line 198
    return ((OM_uint32 )((2UL << 16) | (1UL << 24)));
  }
  {
#line 200
  tmp = gss_oid_equal((gss_const_OID )name1->type, (gss_const_OID )name2->type);
  }
#line 200
  if (! tmp) {
#line 201
    return ((OM_uint32 )(3UL << 16));
  }
#line 203
  if (name_equal) {
#line 204
    if (name1->length == name2->length) {
      {
#line 204
      tmp___0 = memcmp((void const   *)name1->value, (void const   *)name2->value,
                       name1->length);
      }
#line 204
      if (tmp___0 == 0) {
#line 204
        tmp___1 = 1;
      } else {
#line 204
        tmp___1 = 0;
      }
    } else {
#line 204
      tmp___1 = 0;
    }
#line 204
    *name_equal = tmp___1;
  }
#line 207
  return ((OM_uint32 )0);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_release_name(OM_uint32 *minor_status , gss_name_t *name ) 
{ 


  {
#line 228
  if (minor_status) {
#line 229
    *minor_status = (OM_uint32 )0;
  }
#line 231
  if (! name) {
#line 232
    return ((OM_uint32 )((2UL << 16) | (1UL << 24)));
  }
#line 234
  if ((unsigned long )*name != (unsigned long )((gss_name_t )0)) {
#line 236
    if ((*name)->value) {
      {
#line 237
      free((void *)(*name)->value);
      }
    }
    {
#line 239
    free((void *)*name);
#line 240
    *name = (gss_name_t )0;
    }
  }
#line 243
  return ((OM_uint32 )0);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_inquire_names_for_mech(OM_uint32 *minor_status , gss_OID const   mechanism ,
                                     gss_OID_set *name_types ) 
{ 
  OM_uint32 maj_stat ;
  _gss_mech_api_t mech ;
  int i ;

  {
  {
#line 268
  mech = _gss_find_mech(mechanism);
#line 270
  maj_stat = gss_create_empty_oid_set(minor_status, name_types);
  }
#line 271
  if (maj_stat != 0U) {
#line 272
    return (maj_stat);
  }
#line 274
  i = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! mech->name_types[i]) {
#line 274
      goto while_break;
    }
    {
#line 276
    maj_stat = gss_add_oid_set_member(minor_status, (gss_OID const   )mech->name_types[i],
                                      name_types);
    }
#line 278
    if (maj_stat != 0U) {
      {
#line 280
      gss_release_oid_set(minor_status, name_types);
      }
#line 281
      return (maj_stat);
    }
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (minor_status) {
#line 286
    *minor_status = (OM_uint32 )0;
  }
#line 287
  return ((OM_uint32 )0);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
static OM_uint32 _gss_inquire_mechs_for_name3(OM_uint32 *minor_status , gss_OID mech ,
                                              gss_OID name_type , gss_OID_set *mech_types ) 
{ 
  gss_OID_set oids ;
  int supported ;
  OM_uint32 maj_stat ;

  {
  {
#line 301
  maj_stat = gss_inquire_names_for_mech(minor_status, (gss_OID const   )mech, & oids);
  }
#line 302
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 303
    return (maj_stat);
  }
  {
#line 305
  maj_stat = gss_test_oid_set_member(minor_status, (gss_OID const   )name_type, (gss_OID_set const   )oids,
                                     & supported);
#line 307
  gss_release_oid_set(minor_status, & oids);
  }
#line 308
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 309
    return (maj_stat);
  }
#line 311
  if (supported) {
    {
#line 313
    maj_stat = gss_add_oid_set_member(minor_status, (gss_OID const   )mech, mech_types);
    }
#line 314
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 315
      return (maj_stat);
    }
  }
#line 318
  if (minor_status) {
#line 319
    *minor_status = (OM_uint32 )0;
  }
#line 320
  return ((OM_uint32 )0);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
static OM_uint32 _gss_inquire_mechs_for_name2(OM_uint32 *minor_status , gss_OID name_type ,
                                              gss_OID_set *out_mech_types , gss_OID_set supported_mech_types ) 
{ 
  OM_uint32 maj_stat ;
  size_t i ;

  {
#line 335
  i = (size_t )0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i < supported_mech_types->count)) {
#line 335
      goto while_break;
    }
    {
#line 337
    maj_stat = _gss_inquire_mechs_for_name3(minor_status, supported_mech_types->elements + i,
                                            name_type, out_mech_types);
    }
#line 340
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 341
      return (maj_stat);
    }
#line 335
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  if (minor_status) {
#line 345
    *minor_status = (OM_uint32 )0;
  }
#line 346
  return ((OM_uint32 )0);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
static OM_uint32 _gss_inquire_mechs_for_name1(OM_uint32 *minor_status , gss_OID name_type ,
                                              gss_OID_set *out_mech_types ) 
{ 
  OM_uint32 maj_stat ;
  gss_OID_set supported_mech_types ;

  {
  {
#line 359
  maj_stat = gss_indicate_mechs(minor_status, & supported_mech_types);
  }
#line 360
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 361
    return (maj_stat);
  }
  {
#line 363
  maj_stat = _gss_inquire_mechs_for_name2(minor_status, name_type, out_mech_types,
                                          supported_mech_types);
#line 366
  gss_release_oid_set(minor_status, & supported_mech_types);
  }
#line 367
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 368
    return (maj_stat);
  }
#line 370
  if (minor_status) {
#line 371
    *minor_status = (OM_uint32 )0;
  }
#line 372
  return ((OM_uint32 )0);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_inquire_mechs_for_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                                     gss_OID_set *mech_types ) 
{ 
  OM_uint32 maj_stat ;

  {
#line 416
  if ((unsigned long )input_name == (unsigned long )((gss_name_t )0)) {
#line 418
    if (minor_status) {
#line 419
      *minor_status = (OM_uint32 )0;
    }
#line 420
    return ((OM_uint32 )((2UL << 16) | (1UL << 24)));
  }
  {
#line 423
  maj_stat = gss_create_empty_oid_set(minor_status, mech_types);
  }
#line 424
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 425
    return (maj_stat);
  }
  {
#line 427
  maj_stat = _gss_inquire_mechs_for_name1(minor_status, input_name->type, mech_types);
  }
#line 429
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
    {
#line 431
    gss_release_oid_set(minor_status, mech_types);
    }
#line 432
    return (maj_stat);
  }
#line 435
  if (minor_status) {
#line 436
    *minor_status = (OM_uint32 )0;
  }
#line 437
  return ((OM_uint32 )0);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_export_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                          gss_buffer_t exported_name ) 
{ 
  OM_uint32 maj_stat ;
  gss_OID_set mechs ;
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
  {
#line 476
  maj_stat = gss_inquire_mechs_for_name(minor_status, input_name, & mechs);
  }
#line 477
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 478
    return (maj_stat);
  }
#line 480
  if (mechs->count == 0UL) {
#line 482
    if (minor_status) {
#line 483
      *minor_status = (OM_uint32 )0;
    }
#line 484
    return ((OM_uint32 )(3UL << 16));
  }
  {
#line 491
  mech = _gss_find_mech((gss_OID const   )mechs->elements);
  }
#line 492
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 494
    if (minor_status) {
#line 495
      *minor_status = (OM_uint32 )0;
    }
#line 496
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 499
  tmp = (*(mech->export_name))(minor_status, input_name, exported_name);
  }
#line 499
  return (tmp);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_canonicalize_name(OM_uint32 *minor_status , gss_name_t const   input_name ,
                                gss_OID const   mech_type , gss_name_t *output_name ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
  {
#line 533
  mech = _gss_find_mech(mech_type);
  }
#line 534
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 536
    if (minor_status) {
#line 537
      *minor_status = (OM_uint32 )0;
    }
#line 538
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 541
  tmp = (*(mech->canonicalize_name))(minor_status, input_name, mech_type, output_name);
  }
#line 541
  return (tmp);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
OM_uint32 gss_duplicate_name(OM_uint32 *minor_status , gss_name_t const   src_name ,
                             gss_name_t *dest_name ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 568
  if ((unsigned long )src_name == (unsigned long )((gss_name_t )0)) {
#line 570
    if (minor_status) {
#line 571
      *minor_status = (OM_uint32 )0;
    }
#line 572
    return ((OM_uint32 )(2UL << 16));
  }
#line 575
  if (! dest_name) {
#line 577
    if (minor_status) {
#line 578
      *minor_status = (OM_uint32 )0;
    }
#line 579
    return ((OM_uint32 )((13UL << 16) | (2UL << 24)));
  }
  {
#line 582
  tmp = malloc(sizeof(*(*dest_name)));
#line 582
  *dest_name = (gss_name_t )tmp;
  }
#line 583
  if (! *dest_name) {
#line 585
    if (minor_status) {
#line 586
      *minor_status = (OM_uint32 )12;
    }
#line 587
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 589
  (*dest_name)->type = src_name->type;
#line 590
  (*dest_name)->length = src_name->length;
#line 591
  tmp___0 = malloc(src_name->length + 1UL);
#line 591
  (*dest_name)->value = (char *)tmp___0;
  }
#line 592
  if (! (*dest_name)->value) {
    {
#line 594
    free((void *)*dest_name);
    }
#line 595
    if (minor_status) {
#line 596
      *minor_status = (OM_uint32 )12;
    }
#line 597
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 599
  memcpy((void */* __restrict  */)(*dest_name)->value, (void const   */* __restrict  */)src_name->value,
         src_name->length);
#line 600
  *((*dest_name)->value + src_name->length) = (char )'\000';
  }
#line 602
  if (minor_status) {
#line 603
    *minor_status = (OM_uint32 )0;
  }
#line 604
  return ((OM_uint32 )0);
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.h"
_gss_mech_api_t _gss_find_mech_no_default(gss_OID const   oid ) ;
#line 126
_gss_mech_api_t _gss_find_mech_by_saslname(gss_buffer_t const   sasl_mech_name ) ;
#line 128
OM_uint32 _gss_indicate_mechs1(OM_uint32 *minor_status , gss_OID_set *mech_set ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.c"
static _gss_mech_api_desc _gss_mech_apis[1]  = {      {(gss_OID )((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0), {(gss_OID )((void *)0), (gss_OID )((void *)0),
                                    (gss_OID )((void *)0)}, (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                           gss_cred_id_t const   initiator_cred_handle ,
                                                                           gss_ctx_id_t *context_handle ,
                                                                           gss_name_t const   target_name ,
                                                                           gss_OID const   mech_type ,
                                                                           OM_uint32 req_flags ,
                                                                           OM_uint32 time_req ,
                                                                           gss_channel_bindings_t const   input_chan_bindings ,
                                                                           gss_buffer_t const   input_token ,
                                                                           gss_OID *actual_mech_type ,
                                                                           gss_buffer_t output_token ,
                                                                           OM_uint32 *ret_flags ,
                                                                           OM_uint32 *time_rec ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_name_t const   input_name , gss_OID const   mech_type ,
                     gss_name_t *output_name ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                           gss_name_t const   input_name ,
                                                                           gss_buffer_t exported_name ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     int conf_req_flag , gss_qop_t qop_req , gss_buffer_t const   input_message_buffer ,
                     int *conf_state , gss_buffer_t output_message_buffer ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     gss_buffer_t const   input_message_buffer , gss_buffer_t output_message_buffer ,
                     int *conf_state , gss_qop_t *qop_state ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                                          gss_ctx_id_t const   context_handle ,
                                                                                          gss_qop_t qop_req ,
                                                                                          gss_buffer_t const   message_buffer ,
                                                                                          gss_buffer_t message_token ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     gss_buffer_t const   message_buffer , gss_buffer_t const   token_buffer ,
                     gss_qop_t *qop_state ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                        OM_uint32 status_value ,
                                                                        int status_type ,
                                                                        gss_OID const   mech_type ,
                                                                        OM_uint32 *message_context ,
                                                                        gss_buffer_t status_string ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_name_t const   desired_name , OM_uint32 time_req ,
                     gss_OID_set const   desired_mechs , gss_cred_usage_t cred_usage ,
                     gss_cred_id_t *output_cred_handle , gss_OID_set *actual_mechs ,
                     OM_uint32 *time_rec ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                       gss_cred_id_t *cred_handle ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t *context_handle , gss_cred_id_t const   acceptor_cred_handle ,
                     gss_buffer_t const   input_token_buffer , gss_channel_bindings_t const   input_chan_bindings ,
                     gss_name_t *src_name , gss_OID *mech_type , gss_buffer_t output_token ,
                     OM_uint32 *ret_flags , OM_uint32 *time_rec , gss_cred_id_t *delegated_cred_handle ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t *context_handle , gss_buffer_t output_token ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     OM_uint32 *time_rec ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                       gss_cred_id_t const   cred_handle ,
                                                                       gss_name_t *name ,
                                                                       OM_uint32 *lifetime ,
                                                                       gss_cred_usage_t *cred_usage ,
                                                                       gss_OID_set *mechanisms ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                     gss_OID const   mech_type , gss_name_t *name , OM_uint32 *initiator_lifetime ,
                     OM_uint32 *acceptor_lifetime , gss_cred_usage_t *cred_usage ))((void *)0)}};
#line 85 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.c"
_gss_mech_api_t _gss_find_mech_no_default(gss_OID const   oid ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 90
  i = (size_t )0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! _gss_mech_apis[i].mech) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp = gss_oid_equal((gss_const_OID )oid, (gss_const_OID )_gss_mech_apis[i].mech);
    }
#line 91
    if (tmp) {
#line 92
      return (& _gss_mech_apis[i]);
    }
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return ((_gss_mech_api_t )((void *)0));
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.c"
_gss_mech_api_t _gss_find_mech(gss_OID const   oid ) 
{ 
  _gss_mech_api_t p ;
  _gss_mech_api_t tmp ;

  {
  {
#line 100
  tmp = _gss_find_mech_no_default(oid);
#line 100
  p = tmp;
  }
#line 102
  if (! p) {
#line 102
    if (_gss_mech_apis[0].mech) {
#line 105
      return (& _gss_mech_apis[0]);
    }
  }
#line 107
  return (p);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.c"
_gss_mech_api_t _gss_find_mech_by_saslname(gss_buffer_t const   sasl_mech_name ) 
{ 
  size_t i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 115
  if ((unsigned long )sasl_mech_name == (unsigned long )((void *)0)) {
#line 117
    return ((_gss_mech_api_t )((void *)0));
  } else
#line 115
  if ((unsigned long )sasl_mech_name->value == (unsigned long )((void *)0)) {
#line 117
    return ((_gss_mech_api_t )((void *)0));
  } else
#line 115
  if (sasl_mech_name->length == 0UL) {
#line 117
    return ((_gss_mech_api_t )((void *)0));
  }
#line 119
  i = (size_t )0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! _gss_mech_apis[i].mech) {
#line 119
      goto while_break;
    }
    {
#line 120
    tmp = strlen(_gss_mech_apis[i].sasl_name);
    }
#line 120
    if (tmp == sasl_mech_name->length) {
      {
#line 120
      tmp___0 = memcmp((void const   *)_gss_mech_apis[i].sasl_name, (void const   *)sasl_mech_name->value,
                       sasl_mech_name->length);
      }
#line 120
      if (tmp___0 == 0) {
#line 123
        return (& _gss_mech_apis[i]);
      }
    }
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return ((_gss_mech_api_t )((void *)0));
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.c"
OM_uint32 _gss_indicate_mechs1(OM_uint32 *minor_status , gss_OID_set *mech_set ) 
{ 
  OM_uint32 maj_stat ;
  int i ;

  {
#line 134
  i = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! _gss_mech_apis[i].mech) {
#line 134
      goto while_break;
    }
    {
#line 136
    maj_stat = gss_add_oid_set_member(minor_status, (gss_OID const   )_gss_mech_apis[i].mech,
                                      mech_set);
    }
#line 138
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 139
      return (maj_stat);
    }
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (minor_status) {
#line 143
    *minor_status = (OM_uint32 )0;
  }
#line 144
  return ((OM_uint32 )0);
}
}
#line 584 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 30 "../lib/headers/gss/ext.h"
char const   *gss_check_version(char const   *req_version ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/version.c"
char const   *gss_check_version(char const   *req_version ) 
{ 
  int tmp ;

  {
#line 44
  if (! req_version) {
#line 45
    return ("1.0.2");
  } else {
    {
#line 44
    tmp = strverscmp(req_version, "1.0.2");
    }
#line 44
    if (tmp <= 0) {
#line 45
      return ("1.0.2");
    }
  }
#line 47
  return ((char const   *)((void *)0));
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/msg.c"
OM_uint32 gss_get_mic(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                      gss_qop_t qop_req , gss_buffer_t const   message_buffer , gss_buffer_t message_token ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
#line 74
  if (! context_handle) {
#line 76
    if (minor_status) {
#line 77
      *minor_status = (OM_uint32 )0;
    }
#line 78
    return ((OM_uint32 )(8UL << 16));
  }
  {
#line 81
  mech = _gss_find_mech((gss_OID const   )context_handle->mech);
  }
#line 82
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 84
    if (minor_status) {
#line 85
      *minor_status = (OM_uint32 )0;
    }
#line 86
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 89
  tmp = (*(mech->get_mic))(minor_status, context_handle, qop_req, message_buffer,
                           message_token);
  }
#line 89
  return (tmp);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/msg.c"
OM_uint32 gss_verify_mic(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                         gss_buffer_t const   message_buffer , gss_buffer_t const   token_buffer ,
                         gss_qop_t *qop_state ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
#line 149
  if (! context_handle) {
#line 151
    if (minor_status) {
#line 152
      *minor_status = (OM_uint32 )0;
    }
#line 153
    return ((OM_uint32 )(8UL << 16));
  }
  {
#line 156
  mech = _gss_find_mech((gss_OID const   )context_handle->mech);
  }
#line 157
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 159
    if (minor_status) {
#line 160
      *minor_status = (OM_uint32 )0;
    }
#line 161
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 164
  tmp = (*(mech->verify_mic))(minor_status, context_handle, message_buffer, token_buffer,
                              qop_state);
  }
#line 164
  return (tmp);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/msg.c"
OM_uint32 gss_wrap(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                   int conf_req_flag , gss_qop_t qop_req , gss_buffer_t const   input_message_buffer ,
                   int *conf_state , gss_buffer_t output_message_buffer ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
#line 223
  if (! context_handle) {
#line 225
    if (minor_status) {
#line 226
      *minor_status = (OM_uint32 )0;
    }
#line 227
    return ((OM_uint32 )(8UL << 16));
  }
  {
#line 230
  mech = _gss_find_mech((gss_OID const   )context_handle->mech);
  }
#line 231
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 233
    if (minor_status) {
#line 234
      *minor_status = (OM_uint32 )0;
    }
#line 235
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 238
  tmp = (*(mech->wrap))(minor_status, context_handle, conf_req_flag, qop_req, input_message_buffer,
                        conf_state, output_message_buffer);
  }
#line 238
  return (tmp);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/msg.c"
OM_uint32 gss_unwrap(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     gss_buffer_t const   input_message_buffer , gss_buffer_t output_message_buffer ,
                     int *conf_state , gss_qop_t *qop_state ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
#line 304
  if (! context_handle) {
#line 306
    if (minor_status) {
#line 307
      *minor_status = (OM_uint32 )0;
    }
#line 308
    return ((OM_uint32 )(8UL << 16));
  }
  {
#line 311
  mech = _gss_find_mech((gss_OID const   )context_handle->mech);
  }
#line 312
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 314
    if (minor_status) {
#line 315
      *minor_status = (OM_uint32 )0;
    }
#line 316
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 319
  tmp = (*(mech->unwrap))(minor_status, context_handle, input_message_buffer, output_message_buffer,
                          conf_state, qop_state);
  }
#line 319
  return (tmp);
}
}
#line 33 "../lib/headers/gss/ext.h"
int gss_userok(gss_name_t const   name , char const   *username ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/ext.c"
int gss_userok(gss_name_t const   name , char const   *username ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 44
  tmp = strlen(username);
  }
#line 44
  if (name->length == tmp) {
    {
#line 44
    tmp___0 = memcmp((void const   *)name->value, (void const   *)username, name->length);
    }
#line 44
    if (tmp___0 == 0) {
#line 44
      tmp___1 = 1;
    } else {
#line 44
      tmp___1 = 0;
    }
  } else {
#line 44
    tmp___1 = 0;
  }
#line 44
  return (tmp___1);
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dgettext)(char const   *__domainname ,
                                                                                 char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 469 "../lib/headers/gss/api.h"
OM_uint32 gss_display_status(OM_uint32 *minor_status , OM_uint32 status_value , int status_type ,
                             gss_OID const   mech_type , OM_uint32 *message_context ,
                             gss_buffer_t status_string ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
static struct gss_status_codes gss_calling_errors[3]  = {      {(gss_uint32 )(1UL << 24), "GSS_S_CALL_INACCESSIBLE_READ", "A required input parameter could not be read"}, 
        {(gss_uint32 )(2UL << 24),
      "GSS_S_CALL_INACCESSIBLE_WRITE", "A required output parameter could not be written"}, 
        {(gss_uint32 )(3UL << 24),
      "GSS_S_CALL_BAD_STRUCTURE", "A parameter was malformed"}};
#line 44 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
static struct gss_status_codes gss_routine_errors[18]  = 
#line 44
  {      {(gss_uint32 )(1UL << 16), "GSS_S_BAD_MECH", "An unsupported mechanism was requested"}, 
        {(gss_uint32 )(2UL << 16),
      "GSS_S_BAD_NAME", "An invalid name was supplied"}, 
        {(gss_uint32 )(3UL << 16), "GSS_S_BAD_NAMETYPE", "A supplied name was of an unsupported type"}, 
        {(gss_uint32 )(4UL << 16),
      "GSS_S_BAD_BINDINGS", "Incorrect channel bindings were supplied"}, 
        {(gss_uint32 )(5UL << 16), "GSS_S_BAD_STATUS", "An invalid status code was supplied"}, 
        {(gss_uint32 )(6UL << 16),
      "GSS_S_BAD_SIG", "A token had an invalid MIC"}, 
        {(gss_uint32 )(7UL << 16), "GSS_S_NO_CRED", "No credentials were supplied, or the credentials were unavailable or inaccessible"}, 
        {(gss_uint32 )(8UL << 16),
      "GSS_S_NO_CONTEXT", "No context has been established"}, 
        {(gss_uint32 )(9UL << 16), "GSS_S_DEFECTIVE_TOKEN", "A token was invalid"}, 
        {(gss_uint32 )(10UL << 16), "GSS_S_DEFECTIVE_CREDENTIAL", "A credential was invalid"}, 
        {(gss_uint32 )(11UL << 16),
      "GSS_S_CREDENTIALS_EXPIRED", "The referenced credentials have expired"}, 
        {(gss_uint32 )(12UL << 16), "GSS_S_CONTEXT_EXPIRED", "The context has expired"}, 
        {(gss_uint32 )(13UL << 16),
      "GSS_S_FAILURE", "Unspecified error in underlying mechanism"}, 
        {(gss_uint32 )(14UL << 16), "GSS_S_BAD_QOP", "The quality-of-protection requested could not be provided"}, 
        {(gss_uint32 )(15UL << 16),
      "GSS_S_UNAUTHORIZED", "The operation is forbidden by local security policy"}, 
        {(gss_uint32 )(16UL << 16),
      "GSS_S_UNAVAILABLE", "The operation or option is unavailable"}, 
        {(gss_uint32 )(17UL << 16), "GSS_S_DUPLICATE_ELEMENT", "The requested credential element already exists"}, 
        {(gss_uint32 )(18UL << 16),
      "GSS_S_NAME_NOT_MN", "The provided name was not a mechanism name"}};
#line 84 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
static struct gss_status_codes gss_supplementary_errors[5]  = {      {(gss_uint32 )1UL, "GSS_S_CONTINUE_NEEDED", "The gss_init_sec_context() or gss_accept_sec_context() function must be called again to complete its function"}, 
        {(gss_uint32 )(1UL << 1),
      "GSS_S_DUPLICATE_TOKEN", "The token was a duplicate of an earlier token"}, 
        {(gss_uint32 )(1UL << 2), "GSS_S_OLD_TOKEN", "The token\'s validity period has expired"}, 
        {(gss_uint32 )(1UL << 3),
      "GSS_S_UNSEQ_TOKEN", "A later token has already been processed"}, 
        {(gss_uint32 )(1UL << 4), "GSS_S_GAP_TOKEN", "An expected per-message token was not received"}};
#line 182 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
OM_uint32 gss_display_status(OM_uint32 *minor_status , OM_uint32 status_value , int status_type ,
                             gss_OID const   mech_type , OM_uint32 *message_context ,
                             gss_buffer_t status_string ) 
{ 
  size_t i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  _gss_mech_api_t mech ;
  OM_uint32 tmp___7 ;

  {
  {
#line 191
  bindtextdomain("gss", "/usr/local/share/locale");
  }
#line 193
  if (minor_status) {
#line 194
    *minor_status = (OM_uint32 )0;
  }
#line 196
  if (message_context) {
#line 197
    status_value &= ~ *message_context;
  }
  {
#line 201
  if (status_type == 1) {
#line 201
    goto case_1;
  }
#line 322
  if (status_type == 2) {
#line 322
    goto case_2;
  }
#line 333
  goto switch_default___1;
  case_1: /* CIL Label */ 
#line 202
  if (message_context) {
#line 204
    *message_context = (OM_uint32 )((unsigned long )*message_context | (255UL << 16));
#line 206
    if ((status_value & ~ *message_context) == 0U) {
#line 207
      *message_context = (OM_uint32 )0;
    }
  }
  {
#line 212
  if (((unsigned long )status_value & (255UL << 16)) == 0UL) {
#line 212
    goto case_0;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 18UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 17UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 16UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 15UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 14UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 13UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 12UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 11UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 10UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 9UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 8UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 7UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 6UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 5UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 4UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 3UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 2UL << 16) {
#line 232
    goto case_exp;
  }
#line 232
  if (((unsigned long )status_value & (255UL << 16)) == 1UL << 16) {
#line 232
    goto case_exp;
  }
#line 247
  goto switch_default;
  case_0: /* CIL Label */ 
#line 213
  goto switch_break___0;
  case_exp: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  case_exp___2: /* CIL Label */ 
  case_exp___3: /* CIL Label */ 
  case_exp___4: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
  case_exp___6: /* CIL Label */ 
  case_exp___7: /* CIL Label */ 
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
  case_exp___10: /* CIL Label */ 
  case_exp___11: /* CIL Label */ 
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
  case_exp___14: /* CIL Label */ 
  case_exp___15: /* CIL Label */ 
  case_exp___16: /* CIL Label */ 
  {
#line 233
  tmp = dgettext("gss", gss_routine_errors[(((unsigned long )status_value & (255UL << 16)) >> 16) - 1UL].text);
#line 233
  tmp___0 = strdup((char const   *)tmp);
#line 233
  status_string->value = (void *)tmp___0;
  }
#line 237
  if (! status_string->value) {
#line 239
    if (minor_status) {
#line 240
      *minor_status = (OM_uint32 )12;
    }
#line 241
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 243
  status_string->length = strlen((char const   *)status_string->value);
  }
#line 244
  return ((OM_uint32 )0);
#line 245
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 248
  return ((OM_uint32 )(5UL << 16));
#line 249
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 252
  if (message_context) {
#line 254
    *message_context = (OM_uint32 )((unsigned long )*message_context | (255UL << 24));
#line 256
    if ((status_value & ~ *message_context) == 0U) {
#line 257
      *message_context = (OM_uint32 )0;
    }
  }
  {
#line 262
  if (((unsigned long )status_value & (255UL << 24)) == 0UL) {
#line 262
    goto case_0___0;
  }
#line 267
  if (((unsigned long )status_value & (255UL << 24)) == 3UL << 24) {
#line 267
    goto case_exp___17;
  }
#line 267
  if (((unsigned long )status_value & (255UL << 24)) == 2UL << 24) {
#line 267
    goto case_exp___17;
  }
#line 267
  if (((unsigned long )status_value & (255UL << 24)) == 1UL << 24) {
#line 267
    goto case_exp___17;
  }
#line 282
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 263
  goto switch_break___1;
  case_exp___17: /* CIL Label */ 
  case_exp___18: /* CIL Label */ 
  case_exp___19: /* CIL Label */ 
  {
#line 268
  tmp___1 = dgettext("gss", gss_calling_errors[(((unsigned long )status_value & (255UL << 24)) >> 24) - 1UL].text);
#line 268
  tmp___2 = strdup((char const   *)tmp___1);
#line 268
  status_string->value = (void *)tmp___2;
  }
#line 272
  if (! status_string->value) {
#line 274
    if (minor_status) {
#line 275
      *minor_status = (OM_uint32 )12;
    }
#line 276
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 278
  status_string->length = strlen((char const   *)status_string->value);
  }
#line 279
  return ((OM_uint32 )0);
#line 280
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 283
  return ((OM_uint32 )(5UL << 16));
#line 284
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 287
  i = (size_t )0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < sizeof(gss_supplementary_errors) / sizeof(gss_supplementary_errors[0]))) {
#line 287
      goto while_break;
    }
#line 289
    if ((unsigned long )gss_supplementary_errors[i].err & ((unsigned long )status_value & 65535UL)) {
      {
#line 292
      tmp___3 = dgettext("gss", gss_supplementary_errors[i].text);
#line 292
      tmp___4 = strdup((char const   *)tmp___3);
#line 292
      status_string->value = (void *)tmp___4;
      }
#line 294
      if (! status_string->value) {
#line 296
        if (minor_status) {
#line 297
          *minor_status = (OM_uint32 )12;
        }
#line 298
        return ((OM_uint32 )(13UL << 16));
      }
      {
#line 300
      status_string->length = strlen((char const   *)status_string->value);
#line 301
      *message_context |= gss_supplementary_errors[i].err;
      }
#line 302
      if ((status_value & ~ *message_context) == 0U) {
#line 303
        *message_context = (OM_uint32 )0;
      }
#line 304
      return ((OM_uint32 )0);
    }
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if ((unsigned long )status_value & 65535UL) {
#line 308
    return ((OM_uint32 )(5UL << 16));
  }
#line 310
  if (message_context) {
#line 311
    *message_context = (OM_uint32 )0;
  }
  {
#line 312
  tmp___5 = dgettext("gss", "No error");
#line 312
  tmp___6 = strdup((char const   *)tmp___5);
#line 312
  status_string->value = (void *)tmp___6;
  }
#line 313
  if (! status_string->value) {
#line 315
    if (minor_status) {
#line 316
      *minor_status = (OM_uint32 )12;
    }
#line 317
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 319
  status_string->length = strlen((char const   *)status_string->value);
  }
#line 320
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 326
  mech = _gss_find_mech(mech_type);
#line 327
  tmp___7 = (*(mech->display_status))(minor_status, status_value, status_type, mech_type,
                                      message_context, status_string);
  }
#line 327
  return (tmp___7);
#line 331
  goto switch_break;
  switch_default___1: /* CIL Label */ 
#line 334
  return ((OM_uint32 )(5UL << 16));
  switch_break: /* CIL Label */ ;
  }
#line 337
  return ((OM_uint32 )0);
}
}
#line 634 "../lib/headers/gss/api.h"
OM_uint32 gss_inquire_saslname_for_mech(OM_uint32 *minor_status , gss_OID const   desired_mech ,
                                        gss_buffer_t sasl_mech_name , gss_buffer_t mech_name ,
                                        gss_buffer_t mech_description ) ;
#line 641
OM_uint32 gss_inquire_mech_for_saslname(OM_uint32 *minor_status , gss_buffer_t const   sasl_mech_name ,
                                        gss_OID *mech_type ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/saslname.c"
static OM_uint32 dup_data(OM_uint32 *minor_status , gss_buffer_t out , char const   *str ,
                          int translate ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 32
  if (! out) {
#line 33
    return ((OM_uint32 )0);
  }
#line 35
  if (translate) {
    {
#line 36
    tmp = dgettext("gss", str);
#line 36
    tmp___0 = strdup((char const   *)tmp);
#line 36
    out->value = (void *)tmp___0;
    }
  } else {
    {
#line 38
    tmp___1 = strdup(str);
#line 38
    out->value = (void *)tmp___1;
    }
  }
#line 39
  if (! out->value) {
#line 41
    if (minor_status) {
#line 42
      *minor_status = (OM_uint32 )12;
    }
#line 43
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 45
  out->length = strlen(str);
  }
#line 47
  return ((OM_uint32 )0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/saslname.c"
OM_uint32 gss_inquire_saslname_for_mech(OM_uint32 *minor_status , gss_OID const   desired_mech ,
                                        gss_buffer_t sasl_mech_name , gss_buffer_t mech_name ,
                                        gss_buffer_t mech_description ) 
{ 
  _gss_mech_api_t m ;
  OM_uint32 tmp ;
  OM_uint32 tmp___0 ;
  OM_uint32 tmp___1 ;

  {
#line 86
  if (! desired_mech) {
#line 88
    if (minor_status) {
#line 89
      *minor_status = (OM_uint32 )0;
    }
#line 90
    return ((OM_uint32 )(1UL << 24));
  }
  {
#line 93
  m = _gss_find_mech_no_default(desired_mech);
  }
#line 94
  if (! m) {
#line 96
    if (minor_status) {
#line 97
      *minor_status = (OM_uint32 )0;
    }
#line 98
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 101
  bindtextdomain("gss", "/usr/local/share/locale");
#line 103
  tmp = dup_data(minor_status, sasl_mech_name, m->sasl_name, 0);
  }
#line 103
  if (tmp != 0U) {
#line 105
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 106
  tmp___0 = dup_data(minor_status, mech_name, m->mech_name, 0);
  }
#line 106
  if (tmp___0 != 0U) {
#line 108
    if (sasl_mech_name) {
      {
#line 109
      free(sasl_mech_name->value);
      }
    }
#line 110
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 112
  tmp___1 = dup_data(minor_status, mech_description, m->mech_description, 1);
  }
#line 112
  if (tmp___1 != 0U) {
#line 115
    if (sasl_mech_name) {
      {
#line 116
      free(sasl_mech_name->value);
      }
    }
#line 117
    if (mech_name) {
      {
#line 118
      free(mech_name->value);
      }
    }
#line 119
    return ((OM_uint32 )(13UL << 16));
  }
#line 122
  return ((OM_uint32 )0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/saslname.c"
OM_uint32 gss_inquire_mech_for_saslname(OM_uint32 *minor_status , gss_buffer_t const   sasl_mech_name ,
                                        gss_OID *mech_type ) 
{ 
  _gss_mech_api_t m ;

  {
#line 152
  if (! sasl_mech_name) {
#line 154
    if (minor_status) {
#line 155
      *minor_status = (OM_uint32 )0;
    }
#line 156
    return ((OM_uint32 )(1UL << 24));
  }
  {
#line 159
  m = _gss_find_mech_by_saslname(sasl_mech_name);
  }
#line 160
  if (! m) {
#line 162
    if (minor_status) {
#line 163
      *minor_status = (OM_uint32 )0;
    }
#line 164
    return ((OM_uint32 )(1UL << 16));
  }
#line 167
  if (mech_type) {
#line 168
    *mech_type = m->mech;
  }
#line 170
  return ((OM_uint32 )0);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 501 "../lib/headers/gss/api.h"
OM_uint32 gss_release_buffer(OM_uint32 *minor_status , gss_buffer_t buffer ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
OM_uint32 gss_create_empty_oid_set(OM_uint32 *minor_status , gss_OID_set *oid_set ) 
{ 
  void *tmp ;

  {
#line 49
  if (minor_status) {
#line 50
    *minor_status = (OM_uint32 )0;
  }
  {
#line 52
  tmp = malloc(sizeof(*(*oid_set)));
#line 52
  *oid_set = (gss_OID_set )tmp;
  }
#line 53
  if (! *oid_set) {
#line 55
    if (minor_status) {
#line 56
      *minor_status = (OM_uint32 )12;
    }
#line 57
    return ((OM_uint32 )(13UL << 16));
  }
#line 59
  (*oid_set)->count = (size_t )0;
#line 60
  (*oid_set)->elements = (gss_OID )((void *)0);
#line 62
  return ((OM_uint32 )0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
static OM_uint32 _gss_copy_oid(OM_uint32 *minor_status , gss_OID const   src_oid ,
                               gss_OID dest_oid ) 
{ 


  {
#line 88
  if (minor_status) {
#line 89
    *minor_status = (OM_uint32 )0;
  }
#line 91
  if (! src_oid) {
#line 92
    return ((OM_uint32 )((13UL << 16) | (1UL << 24)));
  }
#line 94
  if (src_oid->length == 0U) {
#line 95
    return ((OM_uint32 )((13UL << 16) | (3UL << 24)));
  } else
#line 94
  if ((unsigned long )src_oid->elements == (unsigned long )((void *)0)) {
#line 95
    return ((OM_uint32 )((13UL << 16) | (3UL << 24)));
  }
  {
#line 97
  dest_oid->length = src_oid->length;
#line 98
  dest_oid->elements = malloc((size_t )src_oid->length);
  }
#line 99
  if (! dest_oid->elements) {
#line 101
    if (minor_status) {
#line 102
      *minor_status = (OM_uint32 )12;
    }
#line 103
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 105
  memcpy((void */* __restrict  */)dest_oid->elements, (void const   */* __restrict  */)src_oid->elements,
         (size_t )src_oid->length);
  }
#line 107
  return ((OM_uint32 )0);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
OM_uint32 gss_add_oid_set_member(OM_uint32 *minor_status , gss_OID const   member_oid ,
                                 gss_OID_set *oid_set ) 
{ 
  OM_uint32 major_stat ;
  int present ;
  gss_OID tmp ;
  void *tmp___0 ;

  {
#line 142
  if (! member_oid) {
#line 142
    goto _L;
  } else
#line 142
  if (member_oid->length == 0U) {
#line 142
    goto _L;
  } else
#line 142
  if ((unsigned long )member_oid->elements == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 144
    if (minor_status) {
#line 145
      *minor_status = (OM_uint32 )0;
    }
#line 146
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 149
  major_stat = gss_test_oid_set_member(minor_status, member_oid, (gss_OID_set const   )*oid_set,
                                       & present);
  }
#line 151
  if ((unsigned long )major_stat & ((255UL << 24) | (255UL << 16))) {
#line 152
    return (major_stat);
  }
#line 154
  if (present) {
#line 156
    if (minor_status) {
#line 157
      *minor_status = (OM_uint32 )0;
    }
#line 158
    return ((OM_uint32 )0);
  }
#line 161
  if ((*oid_set)->count + 1UL == 0UL) {
#line 163
    if (minor_status) {
#line 164
      *minor_status = (OM_uint32 )0;
    }
#line 165
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 168
  ((*oid_set)->count) ++;
#line 172
  tmp___0 = realloc((void *)(*oid_set)->elements, (*oid_set)->count * sizeof(*((*oid_set)->elements)));
#line 172
  tmp = (gss_OID )tmp___0;
  }
#line 174
  if (! tmp) {
#line 176
    if (minor_status) {
#line 177
      *minor_status = (OM_uint32 )12;
    }
#line 178
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 181
  (*oid_set)->elements = tmp;
#line 184
  major_stat = _gss_copy_oid(minor_status, member_oid, (*oid_set)->elements + ((*oid_set)->count - 1UL));
  }
#line 186
  if ((unsigned long )major_stat & ((255UL << 24) | (255UL << 16))) {
#line 187
    return (major_stat);
  }
#line 189
  return ((OM_uint32 )0);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
OM_uint32 gss_test_oid_set_member(OM_uint32 *minor_status , gss_OID const   member ,
                                  gss_OID_set const   set , int *present ) 
{ 
  gss_OID cur ;
  size_t i ;
  int tmp ;

  {
#line 219
  if (minor_status) {
#line 220
    *minor_status = (OM_uint32 )0;
  }
#line 222
  *present = 0;
#line 224
  if ((unsigned long )member == (unsigned long )((gss_OID )0)) {
#line 225
    return ((OM_uint32 )0);
  }
#line 227
  i = (size_t )0;
#line 227
  cur = set->elements;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < set->count)) {
#line 227
      goto while_break;
    }
#line 229
    if (cur->length == member->length) {
      {
#line 229
      tmp = memcmp((void const   *)cur->elements, (void const   *)member->elements,
                   (size_t )member->length);
      }
#line 229
      if (tmp == 0) {
#line 232
        *present = 1;
#line 233
        return ((OM_uint32 )0);
      }
    }
#line 227
    i ++;
#line 227
    cur ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return ((OM_uint32 )0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
OM_uint32 gss_release_oid_set(OM_uint32 *minor_status , gss_OID_set *set ) 
{ 
  gss_OID cur ;
  size_t i ;

  {
#line 265
  if (minor_status) {
#line 266
    *minor_status = (OM_uint32 )0;
  }
#line 268
  if (! set) {
#line 269
    return ((OM_uint32 )0);
  } else
#line 268
  if ((unsigned long )*set == (unsigned long )((gss_OID_set )0)) {
#line 269
    return ((OM_uint32 )0);
  }
#line 271
  i = (size_t )0;
#line 271
  cur = (*set)->elements;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < (*set)->count)) {
#line 271
      goto while_break;
    }
    {
#line 272
    free(cur->elements);
#line 271
    i ++;
#line 271
    cur ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  free((void *)(*set)->elements);
#line 274
  free((void *)*set);
#line 275
  *set = (gss_OID_set )0;
  }
#line 277
  return ((OM_uint32 )0);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
OM_uint32 gss_indicate_mechs(OM_uint32 *minor_status , gss_OID_set *mech_set ) 
{ 
  OM_uint32 maj_stat ;

  {
  {
#line 301
  maj_stat = gss_create_empty_oid_set(minor_status, mech_set);
  }
#line 302
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 303
    return (maj_stat);
  }
  {
#line 305
  maj_stat = _gss_indicate_mechs1(minor_status, mech_set);
  }
#line 306
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
    {
#line 308
    gss_release_oid_set((OM_uint32 *)((void *)0), mech_set);
    }
#line 309
    return (maj_stat);
  }
#line 312
  if (minor_status) {
#line 313
    *minor_status = (OM_uint32 )0;
  }
#line 314
  return ((OM_uint32 )0);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
OM_uint32 gss_release_buffer(OM_uint32 *minor_status , gss_buffer_t buffer ) 
{ 


  {
#line 340
  if (minor_status) {
#line 341
    *minor_status = (OM_uint32 )0;
  }
#line 343
  if ((unsigned long )buffer != (unsigned long )((gss_buffer_t )0)) {
    {
#line 345
    free(buffer->value);
#line 346
    buffer->value = (void *)0;
#line 347
    buffer->length = (size_t )0;
    }
  }
#line 350
  return ((OM_uint32 )0);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 402 "../lib/headers/gss/api.h"
OM_uint32 gss_init_sec_context(OM_uint32 *minor_status , gss_cred_id_t const   initiator_cred_handle ,
                               gss_ctx_id_t *context_handle , gss_name_t const   target_name ,
                               gss_OID const   mech_type , OM_uint32 req_flags , OM_uint32 time_req ,
                               gss_channel_bindings_t const   input_chan_bindings ,
                               gss_buffer_t const   input_token , gss_OID *actual_mech_type ,
                               gss_buffer_t output_token , OM_uint32 *ret_flags ,
                               OM_uint32 *time_rec ) ;
#line 416
OM_uint32 gss_accept_sec_context(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                 gss_cred_id_t const   acceptor_cred_handle , gss_buffer_t const   input_token_buffer ,
                                 gss_channel_bindings_t const   input_chan_bindings ,
                                 gss_name_t *src_name , gss_OID *mech_type , gss_buffer_t output_token ,
                                 OM_uint32 *ret_flags , OM_uint32 *time_rec , gss_cred_id_t *delegated_cred_handle ) ;
#line 428
OM_uint32 gss_process_context_token(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                                    gss_buffer_t const   token_buffer ) ;
#line 433
OM_uint32 gss_delete_sec_context(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                 gss_buffer_t output_token ) ;
#line 438
OM_uint32 gss_context_time(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                           OM_uint32 *time_rec ) ;
#line 512
OM_uint32 gss_inquire_context(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                              gss_name_t *src_name , gss_name_t *targ_name , OM_uint32 *lifetime_rec ,
                              gss_OID *mech_type , OM_uint32 *ctx_flags , int *locally_initiated ,
                              int *open ) ;
#line 522
OM_uint32 gss_wrap_size_limit(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                              int conf_req_flag , gss_qop_t qop_req , OM_uint32 req_output_size ,
                              OM_uint32 *max_input_size ) ;
#line 550
OM_uint32 gss_export_sec_context(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                 gss_buffer_t interprocess_token ) ;
#line 555
OM_uint32 gss_import_sec_context(OM_uint32 *minor_status , gss_buffer_t const   interprocess_token ,
                                 gss_ctx_id_t *context_handle ) ;
#line 343 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_init_sec_context(OM_uint32 *minor_status , gss_cred_id_t const   initiator_cred_handle ,
                               gss_ctx_id_t *context_handle , gss_name_t const   target_name ,
                               gss_OID const   mech_type , OM_uint32 req_flags , OM_uint32 time_req ,
                               gss_channel_bindings_t const   input_chan_bindings ,
                               gss_buffer_t const   input_token , gss_OID *actual_mech_type ,
                               gss_buffer_t output_token , OM_uint32 *ret_flags ,
                               OM_uint32 *time_rec ) 
{ 
  OM_uint32 maj_stat ;
  _gss_mech_api_t mech ;
  int freecontext ;
  void *tmp ;

  {
#line 359
  freecontext = 0;
#line 361
  if (output_token) {
#line 363
    output_token->length = (size_t )0;
#line 364
    output_token->value = (void *)0;
  }
#line 367
  if (ret_flags) {
#line 368
    *ret_flags = (OM_uint32 )0;
  }
#line 370
  if (! context_handle) {
#line 372
    if (minor_status) {
#line 373
      *minor_status = (OM_uint32 )0;
    }
#line 374
    return ((OM_uint32 )((8UL << 16) | (1UL << 24)));
  }
#line 377
  if ((unsigned long )output_token == (unsigned long )((gss_buffer_t )0)) {
#line 379
    if (minor_status) {
#line 380
      *minor_status = (OM_uint32 )0;
    }
#line 381
    return ((OM_uint32 )((13UL << 16) | (3UL << 24)));
  }
#line 384
  if ((unsigned long )*context_handle == (unsigned long )((gss_ctx_id_t )0)) {
    {
#line 385
    mech = _gss_find_mech(mech_type);
    }
  } else {
    {
#line 387
    mech = _gss_find_mech((gss_OID const   )(*context_handle)->mech);
    }
  }
#line 388
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 390
    if (minor_status) {
#line 391
      *minor_status = (OM_uint32 )0;
    }
#line 392
    return ((OM_uint32 )(1UL << 16));
  }
#line 395
  if (actual_mech_type) {
#line 396
    *actual_mech_type = mech->mech;
  }
#line 398
  if ((unsigned long )*context_handle == (unsigned long )((gss_ctx_id_t )0)) {
    {
#line 400
    tmp = calloc(sizeof(*(*context_handle)), (size_t )1);
#line 400
    *context_handle = (gss_ctx_id_t )tmp;
    }
#line 401
    if (! *context_handle) {
#line 403
      if (minor_status) {
#line 404
        *minor_status = (OM_uint32 )12;
      }
#line 405
      return ((OM_uint32 )(13UL << 16));
    }
#line 407
    (*context_handle)->mech = mech->mech;
#line 408
    freecontext = 1;
  }
  {
#line 411
  maj_stat = (*(mech->init_sec_context))(minor_status, initiator_cred_handle, context_handle,
                                         target_name, mech_type, req_flags, time_req,
                                         input_chan_bindings, input_token, actual_mech_type,
                                         output_token, ret_flags, time_rec);
  }
#line 423
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 423
    if (freecontext) {
      {
#line 425
      free((void *)*context_handle);
#line 426
      *context_handle = (gss_ctx_id_t )0;
      }
    }
  }
#line 429
  return (maj_stat);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_accept_sec_context(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                 gss_cred_id_t const   acceptor_cred_handle , gss_buffer_t const   input_token_buffer ,
                                 gss_channel_bindings_t const   input_chan_bindings ,
                                 gss_name_t *src_name , gss_OID *mech_type , gss_buffer_t output_token ,
                                 OM_uint32 *ret_flags , OM_uint32 *time_rec , gss_cred_id_t *delegated_cred_handle ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
#line 699
  if (! context_handle) {
#line 701
    if (minor_status) {
#line 702
      *minor_status = (OM_uint32 )0;
    }
#line 703
    return ((OM_uint32 )((8UL << 16) | (1UL << 24)));
  }
#line 706
  if ((unsigned long )*context_handle == (unsigned long )((gss_ctx_id_t )0)) {
    {
#line 710
    mech = _gss_find_mech((gss_OID const   )((gss_OID )0));
    }
  } else {
    {
#line 713
    mech = _gss_find_mech((gss_OID const   )(*context_handle)->mech);
    }
  }
#line 714
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 716
    if (minor_status) {
#line 717
      *minor_status = (OM_uint32 )0;
    }
#line 718
    return ((OM_uint32 )(1UL << 16));
  }
#line 721
  if (mech_type) {
#line 722
    *mech_type = mech->mech;
  }
  {
#line 724
  tmp = (*(mech->accept_sec_context))(minor_status, context_handle, acceptor_cred_handle,
                                      input_token_buffer, input_chan_bindings, src_name,
                                      mech_type, output_token, ret_flags, time_rec,
                                      delegated_cred_handle);
  }
#line 724
  return (tmp);
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_delete_sec_context(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                 gss_buffer_t output_token ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 ret ;

  {
#line 791
  if (! context_handle) {
#line 793
    if (minor_status) {
#line 794
      *minor_status = (OM_uint32 )0;
    }
#line 795
    return ((OM_uint32 )((8UL << 16) | (1UL << 24)));
  }
#line 798
  if ((unsigned long )*context_handle == (unsigned long )((gss_ctx_id_t )0)) {
#line 800
    if (minor_status) {
#line 801
      *minor_status = (OM_uint32 )0;
    }
#line 802
    return ((OM_uint32 )((8UL << 16) | (3UL << 24)));
  }
#line 805
  if ((unsigned long )output_token != (unsigned long )((gss_buffer_t )0)) {
#line 807
    output_token->length = (size_t )0;
#line 808
    output_token->value = (void *)0;
  }
  {
#line 811
  mech = _gss_find_mech((gss_OID const   )(*context_handle)->mech);
  }
#line 812
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 814
    if (minor_status) {
#line 815
      *minor_status = (OM_uint32 )0;
    }
#line 816
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 819
  ret = (*(mech->delete_sec_context))((OM_uint32 *)((void *)0), context_handle, output_token);
#line 821
  free((void *)*context_handle);
#line 822
  *context_handle = (gss_ctx_id_t )0;
  }
#line 824
  return (ret);
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_process_context_token(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                                    gss_buffer_t const   token_buffer ) 
{ 


  {
#line 865
  return ((OM_uint32 )(13UL << 16));
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_context_time(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                           OM_uint32 *time_rec ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 tmp ;

  {
#line 896
  if ((unsigned long )context_handle == (unsigned long )((gss_ctx_id_t )0)) {
#line 898
    if (minor_status) {
#line 899
      *minor_status = (OM_uint32 )0;
    }
#line 900
    return ((OM_uint32 )((8UL << 16) | (3UL << 24)));
  }
  {
#line 903
  mech = _gss_find_mech((gss_OID const   )context_handle->mech);
  }
#line 904
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 906
    if (minor_status) {
#line 907
      *minor_status = (OM_uint32 )0;
    }
#line 908
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 911
  tmp = (*(mech->context_time))(minor_status, context_handle, time_rec);
  }
#line 911
  return (tmp);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_inquire_context(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                              gss_name_t *src_name , gss_name_t *targ_name , OM_uint32 *lifetime_rec ,
                              gss_OID *mech_type , OM_uint32 *ctx_flags , int *locally_initiated ,
                              int *open ) 
{ 


  {
#line 1027
  return ((OM_uint32 )(13UL << 16));
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_wrap_size_limit(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                              int conf_req_flag , gss_qop_t qop_req , OM_uint32 req_output_size ,
                              OM_uint32 *max_input_size ) 
{ 


  {
#line 1089
  return ((OM_uint32 )(13UL << 16));
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_export_sec_context(OM_uint32 *minor_status , gss_ctx_id_t *context_handle ,
                                 gss_buffer_t interprocess_token ) 
{ 


  {
#line 1158
  return ((OM_uint32 )(16UL << 16));
}
}
#line 1189 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/context.c"
OM_uint32 gss_import_sec_context(OM_uint32 *minor_status , gss_buffer_t const   interprocess_token ,
                                 gss_ctx_id_t *context_handle ) 
{ 


  {
#line 1194
  return ((OM_uint32 )(16UL << 16));
}
}
#line 225 "../lib/headers/gss/api.h"
gss_OID GSS_C_NT_USER_NAME ;
#line 238
gss_OID GSS_C_NT_MACHINE_UID_NAME ;
#line 251
gss_OID GSS_C_NT_STRING_UID_NAME ;
#line 270
gss_OID GSS_C_NT_HOSTBASED_SERVICE_X ;
#line 283
gss_OID GSS_C_NT_HOSTBASED_SERVICE ;
#line 295
gss_OID GSS_C_NT_ANONYMOUS ;
#line 308
gss_OID GSS_C_NT_EXPORT_NAME ;
#line 37 "../lib/headers/gss/ext.h"
gss_OID_desc GSS_C_NT_USER_NAME_static ;
#line 38
gss_OID_desc GSS_C_NT_MACHINE_UID_NAME_static ;
#line 39
gss_OID_desc GSS_C_NT_STRING_UID_NAME_static ;
#line 40
gss_OID_desc GSS_C_NT_HOSTBASED_SERVICE_X_static ;
#line 41
gss_OID_desc GSS_C_NT_HOSTBASED_SERVICE_static ;
#line 42
gss_OID_desc GSS_C_NT_ANONYMOUS_static ;
#line 43
gss_OID_desc GSS_C_NT_EXPORT_NAME_static ;
#line 36 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_USER_NAME_static  =    {(OM_uint32 )10, (void *)"*\206H\206\367\022\001\002\001\001"};
#line 40 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_USER_NAME  =    & GSS_C_NT_USER_NAME_static;
#line 53 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_MACHINE_UID_NAME_static  =    {(OM_uint32 )10, (void *)"*\206H\206\367\022\001\002\001\002"};
#line 57 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_MACHINE_UID_NAME  =    & GSS_C_NT_MACHINE_UID_NAME_static;
#line 70 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_STRING_UID_NAME_static  =    {(OM_uint32 )10, (void *)"*\206H\206\367\022\001\002\001\003"};
#line 74 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_STRING_UID_NAME  =    & GSS_C_NT_STRING_UID_NAME_static;
#line 93 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_HOSTBASED_SERVICE_X_static  =    {(OM_uint32 )6, (void *)"+\006\001\005\006\002"};
#line 97 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_HOSTBASED_SERVICE_X  =    & GSS_C_NT_HOSTBASED_SERVICE_X_static;
#line 110 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_HOSTBASED_SERVICE_static  =    {(OM_uint32 )10, (void *)"*\206H\206\367\022\001\002\001\004"};
#line 114 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_HOSTBASED_SERVICE  =    & GSS_C_NT_HOSTBASED_SERVICE_static;
#line 126 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_ANONYMOUS_static  =    {(OM_uint32 )6, (void *)"+\006\001\005\006\003"};
#line 130 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_ANONYMOUS  =    & GSS_C_NT_ANONYMOUS_static;
#line 143 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID_desc GSS_C_NT_EXPORT_NAME_static  =    {(OM_uint32 )6, (void *)"+\006\001\005\006\004"};
#line 147 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
gss_OID GSS_C_NT_EXPORT_NAME  =    & GSS_C_NT_EXPORT_NAME_static;
#line 161 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/oid.c"
int gss_oid_equal(gss_const_OID first_oid , gss_const_OID second_oid ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 164
  if (first_oid) {
#line 164
    if (second_oid) {
#line 164
      if (first_oid->length == second_oid->length) {
        {
#line 164
        tmp = memcmp((void const   *)first_oid->elements, (void const   *)second_oid->elements,
                     (size_t )second_oid->length);
        }
#line 164
        if (tmp == 0) {
#line 164
          tmp___0 = 1;
        } else {
#line 164
          tmp___0 = 0;
        }
      } else {
#line 164
        tmp___0 = 0;
      }
    } else {
#line 164
      tmp___0 = 0;
    }
  } else {
#line 164
    tmp___0 = 0;
  }
#line 164
  return (tmp___0);
}
}
#line 663 "../lib/headers/gss/api.h"
extern OM_uint32 gss_encapsulate_token(gss_const_buffer_t input_token , gss_const_OID token_oid ,
                                       gss_buffer_t output_token ) ;
#line 668
OM_uint32 gss_decapsulate_token(gss_const_buffer_t input_token , gss_const_OID token_oid ,
                                gss_buffer_t output_token ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/internal.h"
OM_uint32 _gss_encapsulate_token_prefix(char const   *prefix , size_t prefixlen ,
                                        char const   *in , size_t inlen , char const   *oid ,
                                        OM_uint32 oidlen , void **out , size_t *outlen ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
static void _gss_asn1_length_der(size_t len , unsigned char *ans , size_t *ans_len ) 
{ 
  size_t k ;
  unsigned char temp[sizeof(len)] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 35
  if (len < 128UL) {
#line 37
    if ((unsigned long )ans != (unsigned long )((void *)0)) {
#line 38
      *(ans + 0) = (unsigned char )len;
    }
#line 39
    *ans_len = (size_t )1;
  } else {
#line 43
    k = (size_t )0;
    {
#line 45
    while (1) {
      while_continue: /* CIL Label */ ;
#line 45
      if (! len) {
#line 45
        goto while_break;
      }
#line 47
      tmp = k;
#line 47
      k ++;
#line 47
      temp[tmp] = (unsigned char )(len & 255UL);
#line 48
      len >>= 8;
    }
    while_break: /* CIL Label */ ;
    }
#line 51
    *ans_len = k + 1UL;
#line 53
    if ((unsigned long )ans != (unsigned long )((void *)0)) {
#line 55
      *(ans + 0) = (unsigned char )(((int )((unsigned char )k) & 127) + 128);
      {
#line 56
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 56
        tmp___0 = k;
#line 56
        k --;
#line 56
        if (! tmp___0) {
#line 56
          goto while_break___0;
        }
#line 57
        *(ans + ((*ans_len - 1UL) - k)) = temp[k];
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
static size_t _gss_asn1_get_length_der(char const   *der , size_t der_len , size_t *len ) 
{ 
  size_t ans ;
  size_t k ;
  size_t punt ;
  size_t last ;
  size_t tmp ;

  {
#line 68
  *len = (size_t )0;
#line 69
  if (der_len <= 0UL) {
#line 70
    return ((size_t )0);
  }
#line 72
  if (! ((int const   )*(der + 0) & 128)) {
#line 75
    *len = (size_t )1;
#line 76
    return ((size_t )((unsigned char )*(der + 0)));
  } else {
#line 81
    k = (size_t )((int )((unsigned char )*(der + 0)) & 127);
#line 82
    punt = (size_t )1;
#line 83
    if (k) {
#line 85
      ans = (size_t )0;
      {
#line 86
      while (1) {
        while_continue: /* CIL Label */ ;
#line 86
        if (punt <= k) {
#line 86
          if (! (punt < der_len)) {
#line 86
            goto while_break;
          }
        } else {
#line 86
          goto while_break;
        }
#line 88
        last = ans;
#line 90
        tmp = punt;
#line 90
        punt ++;
#line 90
        ans = ans * 256UL + (size_t )((unsigned char )*(der + tmp));
#line 91
        if (ans < last) {
#line 93
          return ((size_t )-2);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 98
      ans = (size_t )-1;
    }
#line 101
    *len = punt;
#line 102
    return (ans);
  }
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
OM_uint32 _gss_encapsulate_token_prefix(char const   *prefix , size_t prefixlen ,
                                        char const   *in , size_t inlen , char const   *oid ,
                                        OM_uint32 oidlen , void **out , size_t *outlen ) 
{ 
  size_t oidlenlen ;
  size_t asn1len ;
  size_t asn1lenlen ;
  unsigned char *p ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 116
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 117
    prefixlen = (size_t )0;
  }
  {
#line 119
  _gss_asn1_length_der((size_t )oidlen, (unsigned char *)((void *)0), & oidlenlen);
#line 120
  asn1len = (((1UL + oidlenlen) + (size_t )oidlen) + prefixlen) + inlen;
#line 121
  _gss_asn1_length_der(asn1len, (unsigned char *)((void *)0), & asn1lenlen);
#line 123
  *outlen = (1UL + asn1lenlen) + asn1len;
#line 124
  tmp = malloc(*outlen);
#line 124
  *out = tmp;
#line 124
  p = (unsigned char *)tmp;
  }
#line 125
  if (! p) {
#line 126
    return ((OM_uint32 )-1);
  }
  {
#line 128
  tmp___0 = p;
#line 128
  p ++;
#line 128
  *tmp___0 = (unsigned char )'`';
#line 129
  _gss_asn1_length_der(asn1len, p, & asn1lenlen);
#line 130
  p += asn1lenlen;
#line 131
  tmp___1 = p;
#line 131
  p ++;
#line 131
  *tmp___1 = (unsigned char )'\006';
#line 132
  _gss_asn1_length_der((size_t )oidlen, p, & oidlenlen);
#line 133
  p += oidlenlen;
#line 134
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)oid, (size_t )oidlen);
#line 135
  p += oidlen;
  }
#line 136
  if (prefixlen > 0UL) {
    {
#line 138
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)prefix, prefixlen);
#line 139
    p += prefixlen;
    }
  }
  {
#line 141
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)in, inlen);
  }
#line 143
  return ((OM_uint32 )0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
extern OM_uint32 gss_encapsulate_token(gss_const_buffer_t input_token , gss_const_OID token_oid ,
                                       gss_buffer_t output_token ) 
{ 
  int rc ;
  OM_uint32 tmp ;

  {
#line 175
  if (! input_token) {
#line 176
    return ((OM_uint32 )(1UL << 24));
  }
#line 177
  if (! token_oid) {
#line 178
    return ((OM_uint32 )(1UL << 24));
  }
#line 179
  if (! output_token) {
#line 180
    return ((OM_uint32 )(2UL << 24));
  }
  {
#line 182
  tmp = _gss_encapsulate_token_prefix((char const   *)((void *)0), (size_t )0, (char const   *)input_token->value,
                                      (size_t )input_token->length, (char const   *)token_oid->elements,
                                      (OM_uint32 )token_oid->length, & output_token->value,
                                      & output_token->length);
#line 182
  rc = (int )tmp;
  }
#line 189
  if (rc != 0) {
#line 190
    return ((OM_uint32 )(13UL << 16));
  }
#line 192
  return ((OM_uint32 )0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
static int _gss_decapsulate_token(char const   *in , size_t inlen , char **oid , size_t *oidlen ,
                                  char **out , size_t *outlen ) 
{ 
  size_t i ;
  size_t asn1lenlen ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;

  {
#line 203
  tmp = inlen;
#line 203
  inlen --;
#line 203
  if (tmp == 0UL) {
#line 204
    return (-1);
  }
#line 205
  tmp___0 = in;
#line 205
  in ++;
#line 205
  if ((int const   )*tmp___0 != 96) {
#line 206
    return (-1);
  }
  {
#line 208
  i = inlen;
#line 209
  asn1lenlen = _gss_asn1_get_length_der(in, inlen, & i);
  }
#line 210
  if (inlen < i) {
#line 211
    return (-1);
  }
#line 213
  inlen -= i;
#line 214
  in += i;
#line 216
  if (inlen != asn1lenlen) {
#line 217
    return (-1);
  }
#line 219
  tmp___1 = inlen;
#line 219
  inlen --;
#line 219
  if (tmp___1 == 0UL) {
#line 220
    return (-1);
  }
#line 221
  tmp___2 = in;
#line 221
  in ++;
#line 221
  if ((int const   )*tmp___2 != 6) {
#line 222
    return (-1);
  }
  {
#line 224
  i = inlen;
#line 225
  asn1lenlen = _gss_asn1_get_length_der(in, inlen, & i);
  }
#line 226
  if (inlen < i) {
#line 227
    return (-1);
  }
#line 229
  inlen -= i;
#line 230
  in += i;
#line 232
  if (inlen < asn1lenlen) {
#line 233
    return (-1);
  }
#line 235
  *oidlen = asn1lenlen;
#line 236
  *oid = (char *)in;
#line 238
  inlen -= asn1lenlen;
#line 239
  in += asn1lenlen;
#line 241
  *outlen = inlen;
#line 242
  *out = (char *)in;
#line 244
  return (0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
OM_uint32 gss_decapsulate_token(gss_const_buffer_t input_token , gss_const_OID token_oid ,
                                gss_buffer_t output_token ) 
{ 
  gss_OID_desc tmpoid ;
  char *oid ;
  char *out ;
  size_t oidlen ;
  size_t outlen ;
  int tmp ;
  int tmp___0 ;

  {
#line 277
  oid = (char *)((void *)0);
#line 277
  out = (char *)((void *)0);
#line 278
  oidlen = (size_t )0;
#line 278
  outlen = (size_t )0;
#line 280
  if (! input_token) {
#line 281
    return ((OM_uint32 )(1UL << 24));
  }
#line 282
  if (! token_oid) {
#line 283
    return ((OM_uint32 )(1UL << 24));
  }
#line 284
  if (! output_token) {
#line 285
    return ((OM_uint32 )(2UL << 24));
  }
  {
#line 287
  tmp = _gss_decapsulate_token((char const   *)((char *)input_token->value), (size_t )input_token->length,
                               & oid, & oidlen, & out, & outlen);
  }
#line 287
  if (tmp != 0) {
#line 290
    return ((OM_uint32 )(9UL << 16));
  }
  {
#line 292
  tmpoid.length = (OM_uint32 )oidlen;
#line 293
  tmpoid.elements = (void *)oid;
#line 295
  tmp___0 = gss_oid_equal(token_oid, (gss_const_OID )(& tmpoid));
  }
#line 295
  if (! tmp___0) {
#line 296
    return ((OM_uint32 )(9UL << 16));
  }
  {
#line 298
  output_token->length = outlen;
#line 299
  output_token->value = malloc(outlen);
  }
#line 300
  if (! output_token->value) {
#line 301
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 303
  memcpy((void */* __restrict  */)output_token->value, (void const   */* __restrict  */)out,
         outlen);
  }
#line 305
  return ((OM_uint32 )0);
}
}
#line 390 "../lib/headers/gss/api.h"
OM_uint32 gss_acquire_cred(OM_uint32 *minor_status , gss_name_t const   desired_name ,
                           OM_uint32 time_req , gss_OID_set const   desired_mechs ,
                           gss_cred_usage_t cred_usage , gss_cred_id_t *output_cred_handle ,
                           gss_OID_set *actual_mechs , OM_uint32 *time_rec ) ;
#line 399
OM_uint32 gss_release_cred(OM_uint32 *minor_status , gss_cred_id_t *cred_handle ) ;
#line 505
OM_uint32 gss_inquire_cred(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                           gss_name_t *name , OM_uint32 *lifetime , gss_cred_usage_t *cred_usage ,
                           gss_OID_set *mechanisms ) ;
#line 529
OM_uint32 gss_add_cred(OM_uint32 *minor_status , gss_cred_id_t const   input_cred_handle ,
                       gss_name_t const   desired_name , gss_OID const   desired_mech ,
                       gss_cred_usage_t cred_usage , OM_uint32 initiator_time_req ,
                       OM_uint32 acceptor_time_req , gss_cred_id_t *output_cred_handle ,
                       gss_OID_set *actual_mechs , OM_uint32 *initiator_time_rec ,
                       OM_uint32 *acceptor_time_rec ) ;
#line 541
OM_uint32 gss_inquire_cred_by_mech(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                                   gss_OID const   mech_type , gss_name_t *name ,
                                   OM_uint32 *initiator_lifetime , OM_uint32 *acceptor_lifetime ,
                                   gss_cred_usage_t *cred_usage ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/cred.c"
OM_uint32 gss_acquire_cred(OM_uint32 *minor_status , gss_name_t const   desired_name ,
                           OM_uint32 time_req , gss_OID_set const   desired_mechs ,
                           gss_cred_usage_t cred_usage , gss_cred_id_t *output_cred_handle ,
                           gss_OID_set *actual_mechs , OM_uint32 *time_rec ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 maj_stat ;
  size_t i ;
  void *tmp ;

  {
#line 128
  mech = (_gss_mech_api_t )((void *)0);
#line 131
  if (! output_cred_handle) {
#line 132
    return ((OM_uint32 )((7UL << 16) | (2UL << 24)));
  }
#line 134
  if ((unsigned long )desired_mechs != (unsigned long )((gss_OID_set )0)) {
#line 145
    i = (size_t )0;
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
#line 145
      if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 145
        if (! (i < desired_mechs->count)) {
#line 145
          goto while_break;
        }
      } else {
#line 145
        goto while_break;
      }
      {
#line 146
      mech = _gss_find_mech((gss_OID const   )*(& desired_mechs->elements + i));
#line 145
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 149
    mech = _gss_find_mech((gss_OID const   )((gss_OID )0));
    }
  }
#line 151
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 153
    if (minor_status) {
#line 154
      *minor_status = (OM_uint32 )0;
    }
#line 155
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 158
  tmp = calloc(sizeof(*(*output_cred_handle)), (size_t )1);
#line 158
  *output_cred_handle = (gss_cred_id_t )tmp;
  }
#line 159
  if (! *output_cred_handle) {
#line 161
    if (minor_status) {
#line 162
      *minor_status = (OM_uint32 )12;
    }
#line 163
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 165
  (*output_cred_handle)->mech = mech->mech;
#line 167
  maj_stat = (*(mech->acquire_cred))(minor_status, desired_name, time_req, desired_mechs,
                                     cred_usage, output_cred_handle, actual_mechs,
                                     time_rec);
  }
#line 173
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
    {
#line 175
    free((void *)*output_cred_handle);
#line 176
    *output_cred_handle = (gss_cred_id_t )0;
    }
#line 177
    return (maj_stat);
  }
#line 180
  return ((OM_uint32 )0);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/cred.c"
OM_uint32 gss_add_cred(OM_uint32 *minor_status , gss_cred_id_t const   input_cred_handle ,
                       gss_name_t const   desired_name , gss_OID const   desired_mech ,
                       gss_cred_usage_t cred_usage , OM_uint32 initiator_time_req ,
                       OM_uint32 acceptor_time_req , gss_cred_id_t *output_cred_handle ,
                       gss_OID_set *actual_mechs , OM_uint32 *initiator_time_rec ,
                       OM_uint32 *acceptor_time_rec ) 
{ 


  {
#line 334
  return ((OM_uint32 )(16UL << 16));
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/cred.c"
OM_uint32 gss_inquire_cred(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                           gss_name_t *name , OM_uint32 *lifetime , gss_cred_usage_t *cred_usage ,
                           gss_OID_set *mechanisms ) 
{ 
  gss_cred_id_t credh ;
  _gss_mech_api_t mech ;
  OM_uint32 maj_stat ;

  {
#line 381
  credh = (gss_cred_id_t )cred_handle;
#line 385
  if ((unsigned long )cred_handle == (unsigned long )((gss_cred_id_t )0)) {
    {
#line 387
    maj_stat = gss_acquire_cred(minor_status, (gss_name_t const   )((gss_name_t )0),
                                (OM_uint32 )4294967295UL, (gss_OID_set const   )((gss_OID_set )0),
                                1, & credh, (gss_OID_set *)((void *)0), (OM_uint32 *)((void *)0));
    }
#line 390
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 391
      return (maj_stat);
    }
  }
  {
#line 394
  mech = _gss_find_mech((gss_OID const   )credh->mech);
  }
#line 395
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 397
    if (minor_status) {
#line 398
      *minor_status = (OM_uint32 )0;
    }
#line 399
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 402
  maj_stat = (*(mech->inquire_cred))(minor_status, (gss_cred_id_t const   )credh,
                                     name, lifetime, cred_usage, mechanisms);
  }
#line 405
  if ((unsigned long )cred_handle == (unsigned long )((gss_cred_id_t )0)) {
    {
#line 406
    gss_release_cred((OM_uint32 *)((void *)0), & credh);
    }
  }
#line 408
  return (maj_stat);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/cred.c"
OM_uint32 gss_inquire_cred_by_mech(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                                   gss_OID const   mech_type , gss_name_t *name ,
                                   OM_uint32 *initiator_lifetime , OM_uint32 *acceptor_lifetime ,
                                   gss_cred_usage_t *cred_usage ) 
{ 
  _gss_mech_api_t mech ;
  gss_cred_id_t credh ;
  OM_uint32 maj_stat ;

  {
#line 468
  credh = (gss_cred_id_t )cred_handle;
#line 471
  if ((unsigned long )mech_type == (unsigned long )((gss_OID )0)) {
#line 473
    if (minor_status) {
#line 474
      *minor_status = (OM_uint32 )0;
    }
#line 475
    return ((OM_uint32 )(1UL << 16));
  }
  {
#line 478
  mech = _gss_find_mech(mech_type);
  }
#line 479
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 481
    if (minor_status) {
#line 482
      *minor_status = (OM_uint32 )0;
    }
#line 483
    return ((OM_uint32 )(1UL << 16));
  }
#line 486
  if ((unsigned long )cred_handle == (unsigned long )((gss_cred_id_t )0)) {
    {
#line 488
    maj_stat = gss_acquire_cred(minor_status, (gss_name_t const   )((gss_name_t )0),
                                (OM_uint32 )4294967295UL, (gss_OID_set const   )((gss_OID_set )0),
                                1, & credh, (gss_OID_set *)((void *)0), (OM_uint32 *)((void *)0));
    }
#line 496
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 497
      return (maj_stat);
    }
  }
  {
#line 500
  maj_stat = (*(mech->inquire_cred_by_mech))(minor_status, (gss_cred_id_t const   )credh,
                                             mech_type, name, initiator_lifetime,
                                             acceptor_lifetime, cred_usage);
  }
#line 504
  if ((unsigned long )cred_handle == (unsigned long )((gss_cred_id_t )0)) {
    {
#line 505
    gss_release_cred((OM_uint32 *)((void *)0), & credh);
    }
  }
#line 507
  return (maj_stat);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/cred.c"
OM_uint32 gss_release_cred(OM_uint32 *minor_status , gss_cred_id_t *cred_handle ) 
{ 
  _gss_mech_api_t mech ;
  OM_uint32 maj_stat ;

  {
#line 535
  if (! cred_handle) {
#line 537
    if (minor_status) {
#line 538
      *minor_status = (OM_uint32 )0;
    }
#line 539
    return ((OM_uint32 )((7UL << 16) | (1UL << 24)));
  }
#line 542
  if ((unsigned long )*cred_handle == (unsigned long )((gss_cred_id_t )0)) {
#line 544
    if (minor_status) {
#line 545
      *minor_status = (OM_uint32 )0;
    }
#line 546
    return ((OM_uint32 )0);
  }
  {
#line 549
  mech = _gss_find_mech((gss_OID const   )(*cred_handle)->mech);
  }
#line 550
  if ((unsigned long )mech == (unsigned long )((void *)0)) {
#line 552
    if (minor_status) {
#line 553
      *minor_status = (OM_uint32 )0;
    }
#line 554
    return ((OM_uint32 )(10UL << 16));
  }
  {
#line 557
  maj_stat = (*(mech->release_cred))(minor_status, cred_handle);
#line 558
  free((void *)*cred_handle);
#line 559
  *cred_handle = (gss_cred_id_t )0;
  }
#line 560
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 561
    return (maj_stat);
  }
#line 563
  return ((OM_uint32 )0);
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/conftest.c"
int main(void) 
{ 
  char *tmp ;

  {
  {
#line 73
  tmp = strerror(-2);
  }
#line 73
  if (! *tmp) {
#line 73
    return (1);
  }
#line 75
  return (0);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/saslname.c"
static OM_uint32 dup_data___0(OM_uint32 *minor_status , gss_buffer_t out , char const   *str ,
                              int translate ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 32
  if (! out) {
#line 33
    return ((OM_uint32 )0);
  }
#line 35
  if (translate) {
    {
#line 36
    tmp = dgettext("gss", str);
#line 36
    tmp___0 = strdup((char const   *)tmp);
#line 36
    out->value = (void *)tmp___0;
    }
  } else {
    {
#line 38
    tmp___1 = strdup(str);
#line 38
    out->value = (void *)tmp___1;
    }
  }
#line 39
  if (! out->value) {
#line 41
    if (minor_status) {
#line 42
      *minor_status = (OM_uint32 )12;
    }
#line 43
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 45
  out->length = strlen(str);
  }
#line 47
  return ((OM_uint32 )0);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 54 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 54
extern char *program_invocation_short_name ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
static OM_uint32 _gss_inquire_mechs_for_name3___0(OM_uint32 *minor_status , gss_OID mech ,
                                                  gss_OID name_type , gss_OID_set *mech_types ) 
{ 
  gss_OID_set oids ;
  int supported ;
  OM_uint32 maj_stat ;

  {
  {
#line 301
  maj_stat = gss_inquire_names_for_mech(minor_status, (gss_OID const   )mech, & oids);
  }
#line 302
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 303
    return (maj_stat);
  }
  {
#line 305
  maj_stat = gss_test_oid_set_member(minor_status, (gss_OID const   )name_type, (gss_OID_set const   )oids,
                                     & supported);
#line 307
  gss_release_oid_set(minor_status, & oids);
  }
#line 308
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 309
    return (maj_stat);
  }
#line 311
  if (supported) {
    {
#line 313
    maj_stat = gss_add_oid_set_member(minor_status, (gss_OID const   )mech, mech_types);
    }
#line 314
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 315
      return (maj_stat);
    }
  }
#line 318
  if (minor_status) {
#line 319
    *minor_status = (OM_uint32 )0;
  }
#line 320
  return ((OM_uint32 )0);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
static OM_uint32 _gss_inquire_mechs_for_name2___0(OM_uint32 *minor_status , gss_OID name_type ,
                                                  gss_OID_set *out_mech_types , gss_OID_set supported_mech_types ) 
{ 
  OM_uint32 maj_stat ;
  size_t i ;

  {
#line 335
  i = (size_t )0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i < supported_mech_types->count)) {
#line 335
      goto while_break;
    }
    {
#line 337
    maj_stat = _gss_inquire_mechs_for_name3___0(minor_status, supported_mech_types->elements + i,
                                                name_type, out_mech_types);
    }
#line 340
    if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 341
      return (maj_stat);
    }
#line 335
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  if (minor_status) {
#line 345
    *minor_status = (OM_uint32 )0;
  }
#line 346
  return ((OM_uint32 )0);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/name.c"
static OM_uint32 _gss_inquire_mechs_for_name1___0(OM_uint32 *minor_status , gss_OID name_type ,
                                                  gss_OID_set *out_mech_types ) 
{ 
  OM_uint32 maj_stat ;
  gss_OID_set supported_mech_types ;

  {
  {
#line 359
  maj_stat = gss_indicate_mechs(minor_status, & supported_mech_types);
  }
#line 360
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 361
    return (maj_stat);
  }
  {
#line 363
  maj_stat = _gss_inquire_mechs_for_name2___0(minor_status, name_type, out_mech_types,
                                              supported_mech_types);
#line 366
  gss_release_oid_set(minor_status, & supported_mech_types);
  }
#line 367
  if ((unsigned long )maj_stat & ((255UL << 24) | (255UL << 16))) {
#line 368
    return (maj_stat);
  }
#line 370
  if (minor_status) {
#line 371
    *minor_status = (OM_uint32 )0;
  }
#line 372
  return ((OM_uint32 )0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss_cmd.h"
extern int cmdline_parser(int argc , char **argv , struct gengetopt_args_info *args_info ) ;
#line 42 "../src/gl/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 34 "../src/gl/version-etc.h"
char const   version_etc_copyright[33] ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss.c"
char const   version_etc_copyright[33]  = 
#line 45 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'S',      (char const   )'i',      (char const   )'m',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'J',      (char const   )'o', 
        (char const   )'s',      (char const   )'e',      (char const   )'f',      (char const   )'s', 
        (char const   )'s',      (char const   )'o',      (char const   )'n',      (char const   )'.', 
        (char const   )'\000'};
#line 58
static  __attribute__((__noreturn__)) void usage(int status ) ;
#line 62
static  __attribute__((__noreturn__)) void usage(int status ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss.c"
static void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 64
  if (status != 0) {
    {
#line 65
    tmp = gettext("Try `%s --help\' for more information.\n");
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name);
    }
  } else {
    {
#line 69
    tmp___0 = gettext("Usage: %s OPTIONS...\n");
#line 69
    printf((char const   */* __restrict  */)tmp___0, program_name);
#line 72
    tmp___1 = gettext("Command line interface to GSS, used to explain error codes.\n\n");
#line 72
    fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 76
    tmp___2 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
#line 76
    fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 79
    tmp___3 = gettext("  -h, --help        Print help and exit.\n  -V, --version     Print version and exit.\n  -l, --list-mechanisms\n                    List information about supported mechanisms\n                    in a human readable format.\n  -m, --major=LONG  Describe a `major status\' error code value.\n");
#line 79
    fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 87
    tmp___4 = gettext("  -q, --quiet       Silent operation (default=off).\n");
#line 87
    fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stdout);
#line 90
    emit_bug_reporting_address();
    }
  }
  {
#line 92
  exit(status);
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss.c"
static int describe_major(unsigned int quiet , long major ) 
{ 
  gss_buffer_desc status_string ;
  OM_uint32 message_context ;
  OM_uint32 maj ;
  OM_uint32 min ;
  size_t i ;
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 99
  message_context = (OM_uint32 )0;
#line 100
  maj = (OM_uint32 )0;
#line 102
  rc = 0;
#line 104
  if (! quiet) {
    {
#line 106
    tmp = gettext("GSS-API major status code %ld (0x%lx).\n\n");
#line 106
    printf((char const   */* __restrict  */)tmp, major, major);
#line 109
    tmp___0 = gettext("   MSB                                                                 LSB\n   +-----------------+-----------------+---------------------------------+\n   |  Calling Error  |  Routine Error  |       Supplementary Info        |\n   | ");
#line 109
    printf((char const   */* __restrict  */)tmp___0);
#line 115
    i = (size_t )0;
    }
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! (i < 8UL)) {
#line 115
        goto while_break;
      }
      {
#line 116
      printf((char const   */* __restrict  */)"%ld ", (major >> (31UL - i)) & 1L);
#line 115
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 117
    printf((char const   */* __restrict  */)"| ");
#line 118
    i = (size_t )0;
    }
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! (i < 8UL)) {
#line 118
        goto while_break___0;
      }
      {
#line 119
      printf((char const   */* __restrict  */)"%ld ", (major >> (23UL - i)) & 1L);
#line 118
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 120
    printf((char const   */* __restrict  */)"| ");
#line 121
    i = (size_t )0;
    }
    {
#line 121
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 121
      if (! (i < 16UL)) {
#line 121
        goto while_break___1;
      }
      {
#line 122
      printf((char const   */* __restrict  */)"%ld ", (major >> (15UL - i)) & 1L);
#line 121
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 123
    tmp___1 = gettext("|\n   +-----------------+-----------------+---------------------------------+\nBit 31            24  23            16  15                             0\n\n");
#line 123
    printf((char const   */* __restrict  */)tmp___1);
    }
  }
#line 130
  if ((unsigned long )major & (255UL << 16)) {
#line 132
    if (! quiet) {
      {
#line 133
      tmp___2 = gettext("Masked routine error %ld (0x%lx) shifted into %ld (0x%lx):\n");
#line 133
      printf((char const   */* __restrict  */)tmp___2, (unsigned long )major & (255UL << 16),
             (unsigned long )major & (255UL << 16), ((unsigned long )major & (255UL << 16)) >> 16,
             ((unsigned long )major & (255UL << 16)) >> 16);
      }
    }
#line 142
    message_context = (OM_uint32 )0;
    {
#line 143
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 145
      maj = gss_display_status(& min, (OM_uint32 )((unsigned long )major & (255UL << 16)),
                               1, (gss_OID const   )((gss_OID )0), & message_context,
                               & status_string);
      }
#line 148
      if ((unsigned long )maj & ((255UL << 24) | (255UL << 16))) {
        {
#line 150
        tmp___3 = gettext("displaying status code failed (%d)");
#line 150
        error(0, 0, (char const   *)tmp___3, maj);
#line 151
        rc = 1;
        }
#line 152
        goto while_break___2;
      }
      {
#line 155
      printf((char const   */* __restrict  */)"%.*s\n", (int )status_string.length,
             (char *)status_string.value);
#line 158
      gss_release_buffer(& min, & status_string);
      }
#line 143
      if (! message_context) {
#line 143
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 162
    if (! quiet) {
      {
#line 163
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 166
  if ((unsigned long )major & (255UL << 24)) {
#line 168
    if (! quiet) {
      {
#line 169
      tmp___4 = gettext("Masked calling error %ld (0x%lx) shifted into %ld (0x%lx):\n");
#line 169
      printf((char const   */* __restrict  */)tmp___4, (unsigned long )major & (255UL << 24),
             (unsigned long )major & (255UL << 24), ((unsigned long )major & (255UL << 24)) >> 24,
             ((unsigned long )major & (255UL << 24)) >> 24);
      }
    }
#line 176
    message_context = (OM_uint32 )0;
    {
#line 177
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 179
      maj = gss_display_status(& min, (OM_uint32 )((unsigned long )major & (255UL << 24)),
                               1, (gss_OID const   )((gss_OID )0), & message_context,
                               & status_string);
      }
#line 182
      if ((unsigned long )maj & ((255UL << 24) | (255UL << 16))) {
        {
#line 184
        tmp___5 = gettext("displaying status code failed (%d)");
#line 184
        error(0, 0, (char const   *)tmp___5, maj);
#line 185
        rc = 1;
        }
#line 186
        goto while_break___3;
      }
      {
#line 189
      printf((char const   */* __restrict  */)"%.*s\n", (int )status_string.length,
             (char *)status_string.value);
#line 192
      gss_release_buffer(& min, & status_string);
      }
#line 177
      if (! message_context) {
#line 177
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 196
    if (! quiet) {
      {
#line 197
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 200
  if ((unsigned long )major & 65535UL) {
#line 202
    if (! quiet) {
      {
#line 203
      tmp___6 = gettext("Masked supplementary info %ld (0x%lx) shifted into %ld (0x%lx):\n");
#line 203
      printf((char const   */* __restrict  */)tmp___6, (unsigned long )major & 65535UL,
             (unsigned long )major & 65535UL, (unsigned long )major & 65535UL, (unsigned long )major & 65535UL);
      }
    }
#line 212
    message_context = (OM_uint32 )0;
    {
#line 213
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 215
      maj = gss_display_status(& min, (OM_uint32 )((unsigned long )major & 65535UL),
                               1, (gss_OID const   )((gss_OID )0), & message_context,
                               & status_string);
      }
#line 219
      if ((unsigned long )maj & ((255UL << 24) | (255UL << 16))) {
        {
#line 221
        tmp___7 = gettext("displaying status code failed (%d)");
#line 221
        error(0, 0, (char const   *)tmp___7, maj);
#line 222
        rc = 1;
        }
#line 223
        goto while_break___4;
      }
      {
#line 226
      printf((char const   */* __restrict  */)"%.*s\n", (int )status_string.length,
             (char *)status_string.value);
#line 229
      gss_release_buffer(& min, & status_string);
      }
#line 213
      if (! message_context) {
#line 213
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 233
    if (! quiet) {
      {
#line 234
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 237
  if (major == 0L) {
    {
#line 238
    tmp___8 = gettext("No error\n");
#line 238
    printf((char const   */* __restrict  */)tmp___8);
    }
  }
#line 240
  return (rc);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gss.c"
static int list_mechanisms(unsigned int quiet ) 
{ 
  OM_uint32 maj ;
  OM_uint32 min ;
  gss_OID_set mech_set ;
  size_t i ;
  gss_buffer_desc sasl_mech_name ;
  gss_buffer_desc mech_name ;
  gss_buffer_desc mech_description ;
  char *tmp ;
  gss_OID tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 253
  maj = gss_indicate_mechs(& min, & mech_set);
  }
#line 254
  if ((unsigned long )maj & ((255UL << 24) | (255UL << 16))) {
    {
#line 256
    tmp = gettext("indicating mechanisms failed (%d)");
#line 256
    error(0, 0, (char const   *)tmp, maj);
    }
#line 257
    return (1);
  }
  {
#line 260
  printf((char const   */* __restrict  */)"Found %lu supported mechanisms.\n", mech_set->count);
#line 262
  i = (size_t )0;
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < mech_set->count)) {
#line 262
      goto while_break;
    }
    {
#line 264
    printf((char const   */* __restrict  */)"\nMechanism %lu:\n", i);
#line 266
    tmp___0 = mech_set->elements;
#line 266
    (mech_set->elements) ++;
#line 266
    maj = gss_inquire_saslname_for_mech(& min, (gss_OID const   )tmp___0, & sasl_mech_name,
                                        & mech_name, & mech_description);
    }
#line 269
    if ((unsigned long )maj & ((255UL << 24) | (255UL << 16))) {
      {
#line 271
      tmp___1 = gettext("inquiring information about mechanism failed (%d)");
#line 271
      error(0, 0, (char const   *)tmp___1, maj);
      }
#line 273
      goto __Cont;
    }
    {
#line 276
    printf((char const   */* __restrict  */)"\tMechanism name: %.*s\n", (int )mech_name.length,
           (char *)mech_name.value);
#line 278
    printf((char const   */* __restrict  */)"\tMechanism description: %.*s\n", (int )mech_description.length,
           (char *)mech_description.value);
#line 280
    printf((char const   */* __restrict  */)"\tSASL Mechanism name: %.*s\n", (int )sasl_mech_name.length,
           (char *)sasl_mech_name.value);
    }
    __Cont: /* CIL Label */ 
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (0);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
static void _gss_asn1_length_der___0(size_t len , unsigned char *ans , size_t *ans_len ) 
{ 
  size_t k ;
  unsigned char temp[sizeof(len)] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 35
  if (len < 128UL) {
#line 37
    if ((unsigned long )ans != (unsigned long )((void *)0)) {
#line 38
      *(ans + 0) = (unsigned char )len;
    }
#line 39
    *ans_len = (size_t )1;
  } else {
#line 43
    k = (size_t )0;
    {
#line 45
    while (1) {
      while_continue: /* CIL Label */ ;
#line 45
      if (! len) {
#line 45
        goto while_break;
      }
#line 47
      tmp = k;
#line 47
      k ++;
#line 47
      temp[tmp] = (unsigned char )(len & 255UL);
#line 48
      len >>= 8;
    }
    while_break: /* CIL Label */ ;
    }
#line 51
    *ans_len = k + 1UL;
#line 53
    if ((unsigned long )ans != (unsigned long )((void *)0)) {
#line 55
      *(ans + 0) = (unsigned char )(((int )((unsigned char )k) & 127) + 128);
      {
#line 56
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 56
        tmp___0 = k;
#line 56
        k --;
#line 56
        if (! tmp___0) {
#line 56
          goto while_break___0;
        }
#line 57
        *(ans + ((*ans_len - 1UL) - k)) = temp[k];
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
static size_t _gss_asn1_get_length_der___0(char const   *der , size_t der_len , size_t *len ) 
{ 
  size_t ans ;
  size_t k ;
  size_t punt ;
  size_t last ;
  size_t tmp ;

  {
#line 68
  *len = (size_t )0;
#line 69
  if (der_len <= 0UL) {
#line 70
    return ((size_t )0);
  }
#line 72
  if (! ((int const   )*(der + 0) & 128)) {
#line 75
    *len = (size_t )1;
#line 76
    return ((size_t )((unsigned char )*(der + 0)));
  } else {
#line 81
    k = (size_t )((int )((unsigned char )*(der + 0)) & 127);
#line 82
    punt = (size_t )1;
#line 83
    if (k) {
#line 85
      ans = (size_t )0;
      {
#line 86
      while (1) {
        while_continue: /* CIL Label */ ;
#line 86
        if (punt <= k) {
#line 86
          if (! (punt < der_len)) {
#line 86
            goto while_break;
          }
        } else {
#line 86
          goto while_break;
        }
#line 88
        last = ans;
#line 90
        tmp = punt;
#line 90
        punt ++;
#line 90
        ans = ans * 256UL + (size_t )((unsigned char )*(der + tmp));
#line 91
        if (ans < last) {
#line 93
          return ((size_t )-2);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 98
      ans = (size_t )-1;
    }
#line 101
    *len = punt;
#line 102
    return (ans);
  }
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/asn1.c"
static int _gss_decapsulate_token___0(char const   *in , size_t inlen , char **oid ,
                                      size_t *oidlen , char **out , size_t *outlen ) 
{ 
  size_t i ;
  size_t asn1lenlen ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;

  {
#line 203
  tmp = inlen;
#line 203
  inlen --;
#line 203
  if (tmp == 0UL) {
#line 204
    return (-1);
  }
#line 205
  tmp___0 = in;
#line 205
  in ++;
#line 205
  if ((int const   )*tmp___0 != 96) {
#line 206
    return (-1);
  }
  {
#line 208
  i = inlen;
#line 209
  asn1lenlen = _gss_asn1_get_length_der___0(in, inlen, & i);
  }
#line 210
  if (inlen < i) {
#line 211
    return (-1);
  }
#line 213
  inlen -= i;
#line 214
  in += i;
#line 216
  if (inlen != asn1lenlen) {
#line 217
    return (-1);
  }
#line 219
  tmp___1 = inlen;
#line 219
  inlen --;
#line 219
  if (tmp___1 == 0UL) {
#line 220
    return (-1);
  }
#line 221
  tmp___2 = in;
#line 221
  in ++;
#line 221
  if ((int const   )*tmp___2 != 6) {
#line 222
    return (-1);
  }
  {
#line 224
  i = inlen;
#line 225
  asn1lenlen = _gss_asn1_get_length_der___0(in, inlen, & i);
  }
#line 226
  if (inlen < i) {
#line 227
    return (-1);
  }
#line 229
  inlen -= i;
#line 230
  in += i;
#line 232
  if (inlen < asn1lenlen) {
#line 233
    return (-1);
  }
#line 235
  *oidlen = asn1lenlen;
#line 236
  *oid = (char *)in;
#line 238
  inlen -= asn1lenlen;
#line 239
  in += asn1lenlen;
#line 241
  *outlen = inlen;
#line 242
  *out = (char *)in;
#line 244
  return (0);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/meta.c"
static _gss_mech_api_desc _gss_mech_apis___0[1]  = {      {(gss_OID )((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0), {(gss_OID )((void *)0), (gss_OID )((void *)0),
                                    (gss_OID )((void *)0)}, (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                           gss_cred_id_t const   initiator_cred_handle ,
                                                                           gss_ctx_id_t *context_handle ,
                                                                           gss_name_t const   target_name ,
                                                                           gss_OID const   mech_type ,
                                                                           OM_uint32 req_flags ,
                                                                           OM_uint32 time_req ,
                                                                           gss_channel_bindings_t const   input_chan_bindings ,
                                                                           gss_buffer_t const   input_token ,
                                                                           gss_OID *actual_mech_type ,
                                                                           gss_buffer_t output_token ,
                                                                           OM_uint32 *ret_flags ,
                                                                           OM_uint32 *time_rec ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_name_t const   input_name , gss_OID const   mech_type ,
                     gss_name_t *output_name ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                           gss_name_t const   input_name ,
                                                                           gss_buffer_t exported_name ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     int conf_req_flag , gss_qop_t qop_req , gss_buffer_t const   input_message_buffer ,
                     int *conf_state , gss_buffer_t output_message_buffer ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     gss_buffer_t const   input_message_buffer , gss_buffer_t output_message_buffer ,
                     int *conf_state , gss_qop_t *qop_state ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                                          gss_ctx_id_t const   context_handle ,
                                                                                          gss_qop_t qop_req ,
                                                                                          gss_buffer_t const   message_buffer ,
                                                                                          gss_buffer_t message_token ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     gss_buffer_t const   message_buffer , gss_buffer_t const   token_buffer ,
                     gss_qop_t *qop_state ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                        OM_uint32 status_value ,
                                                                        int status_type ,
                                                                        gss_OID const   mech_type ,
                                                                        OM_uint32 *message_context ,
                                                                        gss_buffer_t status_string ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_name_t const   desired_name , OM_uint32 time_req ,
                     gss_OID_set const   desired_mechs , gss_cred_usage_t cred_usage ,
                     gss_cred_id_t *output_cred_handle , gss_OID_set *actual_mechs ,
                     OM_uint32 *time_rec ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                       gss_cred_id_t *cred_handle ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t *context_handle , gss_cred_id_t const   acceptor_cred_handle ,
                     gss_buffer_t const   input_token_buffer , gss_channel_bindings_t const   input_chan_bindings ,
                     gss_name_t *src_name , gss_OID *mech_type , gss_buffer_t output_token ,
                     OM_uint32 *ret_flags , OM_uint32 *time_rec , gss_cred_id_t *delegated_cred_handle ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t *context_handle , gss_buffer_t output_token ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_ctx_id_t const   context_handle ,
                     OM_uint32 *time_rec ))((void *)0), (OM_uint32 (*)(OM_uint32 *minor_status ,
                                                                       gss_cred_id_t const   cred_handle ,
                                                                       gss_name_t *name ,
                                                                       OM_uint32 *lifetime ,
                                                                       gss_cred_usage_t *cred_usage ,
                                                                       gss_OID_set *mechanisms ))((void *)0),
      (OM_uint32 (*)(OM_uint32 *minor_status , gss_cred_id_t const   cred_handle ,
                     gss_OID const   mech_type , gss_name_t *name , OM_uint32 *initiator_lifetime ,
                     OM_uint32 *acceptor_lifetime , gss_cred_usage_t *cred_usage ))((void *)0)}};
#line 35 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
static struct gss_status_codes gss_calling_errors___0[3]  = {      {(gss_uint32 )(1UL << 24), "GSS_S_CALL_INACCESSIBLE_READ", "A required input parameter could not be read"}, 
        {(gss_uint32 )(2UL << 24),
      "GSS_S_CALL_INACCESSIBLE_WRITE", "A required output parameter could not be written"}, 
        {(gss_uint32 )(3UL << 24),
      "GSS_S_CALL_BAD_STRUCTURE", "A parameter was malformed"}};
#line 44 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
static struct gss_status_codes gss_routine_errors___0[18]  = 
#line 44
  {      {(gss_uint32 )(1UL << 16), "GSS_S_BAD_MECH", "An unsupported mechanism was requested"}, 
        {(gss_uint32 )(2UL << 16),
      "GSS_S_BAD_NAME", "An invalid name was supplied"}, 
        {(gss_uint32 )(3UL << 16), "GSS_S_BAD_NAMETYPE", "A supplied name was of an unsupported type"}, 
        {(gss_uint32 )(4UL << 16),
      "GSS_S_BAD_BINDINGS", "Incorrect channel bindings were supplied"}, 
        {(gss_uint32 )(5UL << 16), "GSS_S_BAD_STATUS", "An invalid status code was supplied"}, 
        {(gss_uint32 )(6UL << 16),
      "GSS_S_BAD_SIG", "A token had an invalid MIC"}, 
        {(gss_uint32 )(7UL << 16), "GSS_S_NO_CRED", "No credentials were supplied, or the credentials were unavailable or inaccessible"}, 
        {(gss_uint32 )(8UL << 16),
      "GSS_S_NO_CONTEXT", "No context has been established"}, 
        {(gss_uint32 )(9UL << 16), "GSS_S_DEFECTIVE_TOKEN", "A token was invalid"}, 
        {(gss_uint32 )(10UL << 16), "GSS_S_DEFECTIVE_CREDENTIAL", "A credential was invalid"}, 
        {(gss_uint32 )(11UL << 16),
      "GSS_S_CREDENTIALS_EXPIRED", "The referenced credentials have expired"}, 
        {(gss_uint32 )(12UL << 16), "GSS_S_CONTEXT_EXPIRED", "The context has expired"}, 
        {(gss_uint32 )(13UL << 16),
      "GSS_S_FAILURE", "Unspecified error in underlying mechanism"}, 
        {(gss_uint32 )(14UL << 16), "GSS_S_BAD_QOP", "The quality-of-protection requested could not be provided"}, 
        {(gss_uint32 )(15UL << 16),
      "GSS_S_UNAUTHORIZED", "The operation is forbidden by local security policy"}, 
        {(gss_uint32 )(16UL << 16),
      "GSS_S_UNAVAILABLE", "The operation or option is unavailable"}, 
        {(gss_uint32 )(17UL << 16), "GSS_S_DUPLICATE_ELEMENT", "The requested credential element already exists"}, 
        {(gss_uint32 )(18UL << 16),
      "GSS_S_NAME_NOT_MN", "The provided name was not a mechanism name"}};
#line 84 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/error.c"
static struct gss_status_codes gss_supplementary_errors___0[5]  = {      {(gss_uint32 )1UL, "GSS_S_CONTINUE_NEEDED", "The gss_init_sec_context() or gss_accept_sec_context() function must be called again to complete its function"}, 
        {(gss_uint32 )(1UL << 1),
      "GSS_S_DUPLICATE_TOKEN", "The token was a duplicate of an earlier token"}, 
        {(gss_uint32 )(1UL << 2), "GSS_S_OLD_TOKEN", "The token\'s validity period has expired"}, 
        {(gss_uint32 )(1UL << 3),
      "GSS_S_UNSEQ_TOKEN", "A later token has already been processed"}, 
        {(gss_uint32 )(1UL << 4), "GSS_S_GAP_TOKEN", "An expected per-message token was not received"}};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 52 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/version-etc.h"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2011);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/src/gl/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-gss@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU Generic Security Service",
         "http://www.gnu.org/software/gss/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/gss-1.0.2/lib/misc.c"
static OM_uint32 _gss_copy_oid___0(OM_uint32 *minor_status , gss_OID const   src_oid ,
                                   gss_OID dest_oid ) 
{ 


  {
#line 88
  if (minor_status) {
#line 89
    *minor_status = (OM_uint32 )0;
  }
#line 91
  if (! src_oid) {
#line 92
    return ((OM_uint32 )((13UL << 16) | (1UL << 24)));
  }
#line 94
  if (src_oid->length == 0U) {
#line 95
    return ((OM_uint32 )((13UL << 16) | (3UL << 24)));
  } else
#line 94
  if ((unsigned long )src_oid->elements == (unsigned long )((void *)0)) {
#line 95
    return ((OM_uint32 )((13UL << 16) | (3UL << 24)));
  }
  {
#line 97
  dest_oid->length = src_oid->length;
#line 98
  dest_oid->elements = malloc((size_t )src_oid->length);
  }
#line 99
  if (! dest_oid->elements) {
#line 101
    if (minor_status) {
#line 102
      *minor_status = (OM_uint32 )12;
    }
#line 103
    return ((OM_uint32 )(13UL << 16));
  }
  {
#line 105
  memcpy((void */* __restrict  */)dest_oid->elements, (void const   */* __restrict  */)src_oid->elements,
         (size_t )src_oid->length);
  }
#line 107
  return ((OM_uint32 )0);
}
}
