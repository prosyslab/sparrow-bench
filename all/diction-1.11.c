/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/diction-1.11/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
enum lc_ctype_int {
    ASCII = 0,
    ISO_8859_1 = 1
} ;
#line 61 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
struct Hit {
   int *data ;
   int capacity ;
   int size ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_4 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_4 regmatch_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 49 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
struct badPhrase {
   char *phrase ;
   regex_t phrase_r ;
   char *suggest ;
   int beginner ;
};
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/diction-1.11/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 149
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.h"
int endingInPossesiveS(char const   *s , size_t length ) ;
#line 31
void sentence(char const   *cmd , FILE *in , char const   *file , void (*process)(char const   * ,
                                                                                  size_t  ,
                                                                                  char const   * ,
                                                                                  int  ) ,
              char const   *lang ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *lc_ctype  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static enum lc_ctype_int lc_ctype_int  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *docLanguage  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *phraseEnd  =    (char const   *)0;
#line 68 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static void newHit(struct Hit *hit ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 70
  tmp___1 = 3;
#line 70
  hit->capacity = tmp___1;
#line 70
  tmp___2 = malloc((unsigned long )tmp___1 * sizeof(int ));
#line 70
  tmp___0 = (int *)tmp___2;
#line 70
  hit->data = tmp___0;
  }
#line 70
  if ((unsigned long )tmp___0 == (unsigned long )((int *)0)) {
    {
#line 72
    tmp = gettext("style: out of memory\n");
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 73
    exit(1);
    }
  }
  {
#line 75
  memset((void *)hit->data, 0, (unsigned long )hit->capacity * sizeof(int ));
#line 76
  hit->size = 0;
  }
#line 77
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static void noteHit(struct Hit *hit , int n ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 81
  if (n == 0) {
#line 81
    return;
  }
#line 82
  if (n > hit->capacity) {
    {
#line 84
    tmp___1 = realloc((void *)hit->data, (unsigned long )(n * 2) * sizeof(int ));
#line 84
    tmp___0 = (int *)tmp___1;
#line 84
    hit->data = tmp___0;
    }
#line 84
    if ((unsigned long )tmp___0 == (unsigned long )((int *)0)) {
      {
#line 86
      tmp = gettext("style: out of memory\n");
#line 86
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 87
      exit(1);
      }
    }
    {
#line 89
    memset((void *)(hit->data + hit->capacity), 0, (unsigned long )(n * 2 - hit->capacity) * sizeof(int ));
#line 90
    hit->capacity = n * 2;
    }
  }
#line 92
  (*(hit->data + (n - 1))) ++;
#line 93
  if (n > hit->size) {
#line 93
    hit->size = n;
  }
#line 94
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double kincaid(int syllables___0 , int words___0 , int sentences___1 ) 
{ 


  {
#line 106
  return ((11.8 * ((double )syllables___0 / (double )words___0) + 0.39 * ((double )words___0 / (double )sentences___1)) - 15.59);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double ari(int letters , int words___0 , int sentences___1 ) 
{ 


  {
#line 118
  return ((4.71 * ((double )letters / (double )words___0) + 0.5 * ((double )words___0 / (double )sentences___1)) - 21.43);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double coleman_liau(int letters , int words___0 , int sentences___1 ) 
{ 


  {
#line 134
  return (((5.879851 * (double )letters) / (double )words___0 - (29.587280 * (double )sentences___1) / (double )words___0) - 15.800804);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double flesch(int syllables___0 , int words___0 , int sentences___1 ) 
{ 


  {
#line 147
  return ((206.835 - 84.6 * ((double )syllables___0 / (double )words___0)) - 1.015 * ((double )words___0 / (double )sentences___1));
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double fog(int words___0 , int bigwords___0 , int sentences___1 ) 
{ 


  {
#line 159
  return (((double )words___0 / (double )sentences___1 + (100.0 * (double )bigwords___0) / (double )words___0) * 0.4);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double lix(int *grade , int words___0 , int longwords___0 , int sentences___1 ) 
{ 
  double idx ;

  {
#line 213
  idx = (double )words___0 / (double )sentences___1 + (100.0 * (double )longwords___0) / (double )words___0;
#line 215
  if (idx < (double )34) {
#line 215
    *grade = 0;
  } else
#line 216
  if (idx < (double )38) {
#line 216
    *grade = 5;
  } else
#line 217
  if (idx < (double )41) {
#line 217
    *grade = 6;
  } else
#line 218
  if (idx < (double )44) {
#line 218
    *grade = 7;
  } else
#line 219
  if (idx < (double )48) {
#line 219
    *grade = 8;
  } else
#line 220
  if (idx < (double )51) {
#line 220
    *grade = 9;
  } else
#line 221
  if (idx < (double )54) {
#line 221
    *grade = 10;
  } else
#line 222
  if (idx < (double )57) {
#line 222
    *grade = 11;
  } else {
#line 223
    *grade = 99;
  }
#line 224
  return (idx);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static double smog(int bigwords___0 , int sentences___1 ) 
{ 
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
  {
#line 235
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 235
  if (tmp___1 == 0) {
    {
#line 235
    tmp = sqrt(((double )bigwords___0 / (double )sentences___1) * (double )30);
    }
#line 235
    return (tmp - 2.0);
  } else {
    {
#line 236
    tmp___0 = sqrt(((double )bigwords___0 / (double )sentences___1) * 30.0);
    }
#line 236
    return (tmp___0 + 3.0);
  }
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int wordcmp(char const   *r , char const   *s ) 
{ 
  int res ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! *r) {
#line 245
      goto while_break;
    }
    {
#line 247
    tmp = tolower((int )*s);
#line 247
    res = (int )((int const   )*r - (int const   )tmp);
    }
#line 247
    if (res != 0) {
#line 247
      return (res);
    }
#line 248
    r ++;
#line 248
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  tmp___0 = __ctype_b_loc();
  }
#line 250
  return ((int )((int const   )*(*tmp___0 + (int )*s) & 1024));
}
}
#line 260
static int article(char const   *word , size_t l ) ;
#line 260 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de[13]  = 
#line 260
  {      "der",      "die",      "das",      "des", 
        "dem",      "den",      "ein",      "eine", 
        "einer",      "eines",      "einem",      "einen", 
        (char const   *)0};
#line 266 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en[4]  = {      "the",      "a",      "an",      (char const   *)0};
#line 271 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl[4]  = {      "de",      "het",      "een",      (char const   *)0};
#line 258 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int article(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 278
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 278
  if (tmp___1 == 0) {
#line 278
    list = de;
  } else {
    {
#line 279
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 279
    if (tmp___0 == 0) {
#line 279
      list = en;
    } else {
      {
#line 280
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 280
      if (tmp == 0) {
#line 280
        list = nl;
      } else {
        {
#line 281
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      281U, "article");
        }
      }
    }
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! *list) {
#line 283
      goto while_break;
    }
    {
#line 283
    tmp___2 = wordcmp(*list, word);
    }
#line 283
    if (tmp___2 == 0) {
#line 283
      return (1);
    } else {
#line 283
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (0);
}
}
#line 294
static int pronoun(char const   *word , size_t l ) ;
#line 294 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___0[52]  = 
#line 294
  {      "ich",      "du",      "er",      "sie", 
        "es",      "wir",      "ihr",      "mich", 
        "dich",      "ihn",      "uns",      "euch", 
        "mir",      "dir",      "ihm",      "ihnen", 
        "mein",      "dein",      "sein",      "unser", 
        "euer",      "meiner",      "deiner",      "seiner", 
        "unserer",      "eurer",      "ihrer",      "meine", 
        "deine",      "seine",      "unsere",      "eure", 
        "ihre",      "meines",      "deines",      "seines", 
        "unseres",      "eures",      "ihres",      "meinem", 
        "deinem",      "seinem",      "unserem",      "eurem", 
        "ihrem",      "meinen",      "deinen",      "seinen", 
        "unseren",      "euren",      "ihren",      (char const   *)0};
#line 308 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___0[40]  = 
#line 308
  {      "i",      "me",      "we",      "us", 
        "you",      "he",      "him",      "she", 
        "her",      "it",      "they",      "them", 
        "thou",      "thee",      "ye",      "myself", 
        "yourself",      "himself",      "herself",      "itself", 
        "ourselves",      "yourselves",      "themselves",      "oneself", 
        "my",      "mine",      "his",      "hers", 
        "yours",      "ours",      "theirs",      "its", 
        "our",      "that",      "their",      "these", 
        "this",      "those",      "your",      (char const   *)0};
#line 317 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___0[54]  = 
#line 317
  {      "ik",      "jij",      "je",      "u", 
        "gij",      "ge",      "hij",      "zij", 
        "ze",      "het",      "wij",      "we", 
        "jullie",      "me",      "mijzelf",      "mezelf", 
        "je",      "jezelf",      "uzelf",      "zich", 
        "zichzelf",      "haarzelf",      "onszelf",      "elkaar", 
        "elkaars",      "elkander",      "elkanders",      "mekaar", 
        "mekaars",      "mijnen",      "deinen",      "zijnen", 
        "haren",      "onzen",      "uwen",      "hunnen", 
        "haren",      "mijner",      "deiner",      "zijner", 
        "harer",      "onzer",      "uwer",      "hunner", 
        "harer",      "mijnes",      "deines",      "zijnes", 
        "hares",      "onzes",      "uwes",      "hunnes", 
        "hares",      (char const   *)0};
#line 292 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int pronoun(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 332
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 332
  if (tmp___1 == 0) {
#line 332
    list = de___0;
  } else {
    {
#line 333
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 333
    if (tmp___0 == 0) {
#line 333
      list = en___0;
    } else {
      {
#line 334
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 334
      if (tmp == 0) {
#line 334
        list = nl___0;
      } else {
        {
#line 335
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      335U, "pronoun");
        }
      }
    }
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! *list) {
#line 337
      goto while_break;
    }
    {
#line 337
    tmp___2 = wordcmp(*list, word);
    }
#line 337
    if (tmp___2 == 0) {
#line 337
      return (1);
    } else {
#line 337
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return (0);
}
}
#line 349
static int interrogativePronoun(char const   *word , size_t l ) ;
#line 349 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___1[13]  = 
#line 349
  {      "wer",      "was",      "wem",      "wen", 
        "wessen",      "wo",      "wie",      "warum", 
        "weshalb",      "wann",      "wieso",      "weswegen", 
        (char const   *)0};
#line 355 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___1[8]  = 
#line 355
  {      "why",      "who",      "what",      "whom", 
        "when",      "where",      "how",      (char const   *)0};
#line 360 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___1[10]  = 
#line 360
  {      "welke",      "wat",      "wat voor",      "wat voor een", 
        "welk",      "wie",      "waar",      "wanneer", 
        "hoe",      (char const   *)0};
#line 347 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int interrogativePronoun(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 369
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 369
  if (tmp___1 == 0) {
#line 369
    list = de___1;
  } else {
    {
#line 370
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 370
    if (tmp___0 == 0) {
#line 370
      list = en___1;
    } else {
      {
#line 371
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 371
      if (tmp == 0) {
#line 371
        list = nl___1;
      } else {
        {
#line 372
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      372U, "interrogativePronoun");
        }
      }
    }
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! *list) {
#line 374
      goto while_break;
    }
    {
#line 374
    tmp___2 = wordcmp(*list, word);
    }
#line 374
    if (tmp___2 == 0) {
#line 374
      return (1);
    } else {
#line 374
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return (0);
}
}
#line 386
static int conjunction(char const   *word , size_t l ) ;
#line 386 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___2[12]  = 
#line 386
  {      "und",      "oder",      "aber",      "sondern", 
        "doch",      "nur",      "blo\337",      "denn", 
        "weder",      "noch",      "sowie",      (char const   *)0};
#line 392 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___2[6]  = {      "and",      "but",      "or",      "yet", 
        "nor",      (char const   *)0};
#line 397 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___2[6]  = {      "en",      "maar",      "of",      "want", 
        "dus",      (char const   *)0};
#line 384 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int conjunction(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 405
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 405
  if (tmp___1 == 0) {
#line 405
    list = de___2;
  } else {
    {
#line 406
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 406
    if (tmp___0 == 0) {
#line 406
      list = en___2;
    } else {
      {
#line 407
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 407
      if (tmp == 0) {
#line 407
        list = nl___2;
      } else {
        {
#line 408
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      408U, "conjunction");
        }
      }
    }
  }
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! *list) {
#line 410
      goto while_break;
    }
    {
#line 410
    tmp___2 = wordcmp(*list, word);
    }
#line 410
    if (tmp___2 == 0) {
#line 410
      return (1);
    } else {
#line 410
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return (0);
}
}
#line 422
static int nominalization(char const   *word , size_t l ) ;
#line 422 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___3[6]  = {      "ung",      "heit",      "keit",      "nis", 
        "tum",      (char const   *)0};
#line 427 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___3[5]  = {      "tion",      "ment",      "ence",      "ance", 
        (char const   *)0};
#line 433 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___3[6]  = {      "tie",      "heid",      "ing",      "end", 
        "ende",      (char const   *)0};
#line 420 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int nominalization(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 443
  if (l < 7UL) {
#line 443
    return (0);
  }
  {
#line 445
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 445
  if (tmp___1 == 0) {
#line 445
    list = de___3;
  } else {
    {
#line 446
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 446
    if (tmp___0 == 0) {
#line 446
      list = en___3;
    } else {
      {
#line 447
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 447
      if (tmp == 0) {
#line 447
        list = nl___3;
      } else {
        {
#line 448
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      448U, "nominalization");
        }
      }
    }
  }
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! *list) {
#line 450
      goto while_break;
    }
    {
#line 450
    tmp___2 = strlen(*list);
#line 450
    tmp___3 = wordcmp(*list, (word + l) - tmp___2);
    }
#line 450
    if (tmp___3 == 0) {
#line 450
      return (1);
    } else {
#line 450
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return (0);
}
}
#line 462
static int subConjunction(char const   *word , size_t l ) ;
#line 462 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___4[52]  = 
#line 462
  {      "als",      "als dass",      "als da\337",      "als ob", 
        "anstatt dass",      "anstatt da\337",      "ausser dass",      "ausser da\337", 
        "ausser wenn",      "bevor",      "bis",      "da", 
        "damit",      "dass",      "da\337",      "ehe", 
        "falls",      "indem",      "je",      "nachdem", 
        "ob",      "obgleich",      "obschon",      "obwohl", 
        "ohne dass",      "ohne da\337",      "seit",      "so da\337", 
        "sodass",      "sobald",      "sofern",      "solange", 
        "so oft",      "statt dass",      "statt da\337",      "w\344hrend", 
        "weil",      "wenn",      "wenn auch",      "wenngleich", 
        "wie",      "wie wenn",      "wiewohl",      "wobei", 
        "wohingegen",      "zumalals zu",      "anstatt zu",      "ausser zu", 
        "ohne zu",      "statt zu",      "um zu",      (char const   *)0};
#line 477 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___4[29]  = 
#line 477
  {      "after",      "because",      "lest",      "till", 
        "\'til",      "although",      "before",      "now that", 
        "unless",      "as",      "even if",      "provided that", 
        "provided",      "until",      "as if",      "even though", 
        "since",      "as long as",      "so that",      "whenever", 
        "as much as",      "if",      "than",      "as soon as", 
        "inasmuch",      "in order that",      "though",      "while", 
        (char const   *)0};
#line 486 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___4[32]  = 
#line 486
  {      "aangezien",      "als",      "alsof",      "behalve", 
        "daar",      "daarom",      "dat",      "derhalve", 
        "doch",      "doordat",      "hoewel",      "mits", 
        "nadat",      "noch",      "ofschoon",      "omdat", 
        "ondanks",      "opdat",      "sedert",      "sinds", 
        "tenzij",      "terwijl",      "toen",      "totdat", 
        "voordat",      "wanneer",      "zoals",      "zodat", 
        "zodra",      "zonder dat",      "om te",      (char const   *)0};
#line 460 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int subConjunction(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 502
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 502
  if (tmp___1 == 0) {
#line 502
    list = de___4;
  } else {
    {
#line 503
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 503
    if (tmp___0 == 0) {
#line 503
      list = en___4;
    } else {
      {
#line 504
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 504
      if (tmp == 0) {
#line 504
        list = nl___4;
      } else {
        {
#line 505
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      505U, "subConjunction");
        }
      }
    }
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! *list) {
#line 507
      goto while_break;
    }
    {
#line 509
    tmp___3 = wordcmp(*list, word);
    }
#line 509
    if (tmp___3 == 0) {
      {
#line 511
      tmp___2 = strlen(*list);
#line 511
      phraseEnd = word + tmp___2;
      }
#line 512
      return (1);
    } else {
#line 514
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 516
  return (0);
}
}
#line 527
static int preposition(char const   *word , size_t l ) ;
#line 527 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___5[29]  = 
#line 527
  {      "aus",      "au\337er",      "bei",      "mit", 
        "nach",      "seit",      "von",      "zu", 
        "bis",      "durch",      "f\374r",      "gegen", 
        "ohne",      "um",      "an",      "auf", 
        "hinter",      "in",      "neben",      "\374ber", 
        "unter",      "vor",      "zwischen",      "anstatt", 
        "statt",      "trotz",      "w\344hrend",      "wegen", 
        (char const   *)0};
#line 535 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___5[100]  = 
#line 535
  {      "aboard",      "about",      "above",      "according to", 
        "across from",      "after",      "against",      "alongside", 
        "alongside of",      "along with",      "amid",      "among", 
        "apart from",      "around",      "aside from",      "at", 
        "away from",      "back of",      "because of",      "before", 
        "behind",      "below",      "beneath",      "beside", 
        "besides",      "between",      "beyond",      "but", 
        "by means of",      "concerning",      "considering",      "despite", 
        "down",      "down from",      "during",      "except", 
        "except for",      "excepting for",      "from among",      "from between", 
        "from under",      "in addition to",      "in behalf of",      "in front of", 
        "in place of",      "in regard to",      "inside of",      "inside", 
        "in spite of",      "instead of",      "into",      "like", 
        "near to",      "off",      "on account of",      "on behalf of", 
        "onto",      "on top of",      "on",      "opposite", 
        "out of",      "out",      "outside",      "outside of", 
        "over to",      "over",      "owing to",      "past", 
        "prior to",      "regarding",      "round about",      "round", 
        "since",      "subsequent to",      "together",      "with", 
        "throughout",      "through",      "till",      "toward", 
        "under",      "underneath",      "until",      "unto", 
        "up",      "up to",      "upon",      "with", 
        "within",      "without",      "across",      "along", 
        "by",      "of",      "in",      "to", 
        "near",      "of",      "from",      (char const   *)0};
#line 556 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___5[76]  = 
#line 556
  {      "\340",      "aan",      "ad",      "achter", 
        "behalve",      "beneden",      "betreffende",      "bij", 
        "binnen",      "blijkens",      "boven",      "buiten", 
        "circa",      "conform",      "contra",      "cum", 
        "dankzij",      "door",      "gedurende",      "gezien", 
        "hangende",      "in",      "ingevolge",      "inzake", 
        "jegens",      "krachtens",      "langs",      "met", 
        "middels",      "mits",      "na",      "naar", 
        "naast",      "nabij",      "namens",      "niettegenstaande", 
        "nopens",      "om",      "omstreeks",      "omtrent", 
        "ondanks",      "onder",      "ongeacht",      "onverminderd", 
        "op",      "over",      "overeenkomstig",      "per", 
        "plus",      "richting",      "rond",      "rondom", 
        "sedert",      "staande",      "te",      "tegen", 
        "tegenover",      "ten",      "ter",      "tijdens", 
        "tot",      "tussen",      "uit",      "uitgezonderd", 
        "van",      "vanaf",      "vanuit",      "vanwege", 
        "versus",      "via",      "volgens",      "voor", 
        "voorbij",      "wegens",      "zonder",      (char const   *)0};
#line 525 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int preposition(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 570
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 570
  if (tmp___1 == 0) {
#line 570
    list = de___5;
  } else {
    {
#line 571
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 571
    if (tmp___0 == 0) {
#line 571
      list = en___5;
    } else {
      {
#line 572
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 572
      if (tmp == 0) {
#line 572
        list = nl___5;
      } else {
        {
#line 573
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      573U, "preposition");
        }
      }
    }
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! *list) {
#line 575
      goto while_break;
    }
    {
#line 577
    tmp___3 = wordcmp(*list, word);
    }
#line 577
    if (tmp___3 == 0) {
      {
#line 579
      tmp___2 = strlen(*list);
#line 579
      phraseEnd = word + tmp___2;
      }
#line 580
      return (1);
    } else {
#line 582
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  return (0);
}
}
#line 595
static int auxVerb(char const   *word , size_t l ) ;
#line 595 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___6[56]  = 
#line 595
  {      "haben",      "habe",      "hast",      "hat", 
        "habt",      "gehabt",      "h\344tte",      "h\344ttest", 
        "h\344tten",      "h\344ttet",      "werden",      "werde", 
        "wirst",      "wird",      "werdet",      "geworden", 
        "w\374rde",      "w\374rdest",      "w\374rden",      "w\374rdet", 
        "k\366nnen",      "kann",      "kannst",      "k\366nnt", 
        "konnte",      "konntest",      "konnten",      "konntet", 
        "gekonnt",      "k\366nnte",      "k\366nntest",      "k\366nnten", 
        "k\366nntet",      "m\374ssen",      "muss",      "mu\337", 
        "musst",      "m\374sst",      "musste",      "musstest", 
        "mussten",      "gemusst",      "m\374sste",      "m\374sstest", 
        "m\374ssten",      "m\374sstet",      "sollen",      "soll", 
        "sollst",      "sollt",      "sollte",      "solltest", 
        "solltet",      "sollten",      "gesollt",      (char const   *)0};
#line 610 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___6[15]  = 
#line 610
  {      "will",      "shall",      "cannot",      "may", 
        "need to",      "would",      "should",      "could", 
        "might",      "must",      "ought",      "ought to", 
        "can\'t",      "can",      (char const   *)0};
#line 617 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___6[54]  = 
#line 617
  {      "heb",      "hebt",      "heeft",      "hebben", 
        "had",      "hadden",      "gehad",      "word", 
        "wordt",      "worden",      "werd",      "werden", 
        "geworden",      "kan",      "kan",      "kunnen", 
        "kon",      "konden",      "gekund",      "wil", 
        "willen",      "wilde",      "wilden",      "gewild", 
        "wou",      "wouden",      "zal",      "zult", 
        "zullen",      "zou",      "zouden",      "mag", 
        "mogen",      "mocht",      "mochten",      "gemogen", 
        "moet",      "moeten",      "moest",      "moesten", 
        "gemoeten",      "hoef",      "hoeft",      "hoeven", 
        "hoefde",      "hoefden",      "gehoeven",      "doe", 
        "doet",      "doen",      "deed",      "deden", 
        "gedaan",      (char const   *)0};
#line 593 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int auxVerb(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 638
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 638
  if (tmp___1 == 0) {
#line 638
    list = de___6;
  } else {
    {
#line 639
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 639
    if (tmp___0 == 0) {
#line 639
      list = en___6;
    } else {
      {
#line 640
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 640
      if (tmp == 0) {
#line 640
        list = nl___6;
      } else {
        {
#line 641
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      641U, "auxVerb");
        }
      }
    }
  }
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! *list) {
#line 643
      goto while_break;
    }
    {
#line 645
    tmp___3 = wordcmp(*list, word);
    }
#line 645
    if (tmp___3 == 0) {
      {
#line 647
      tmp___2 = strlen(*list);
#line 647
      phraseEnd = word + tmp___2;
      }
#line 648
      return (1);
    } else {
#line 650
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return (0);
}
}
#line 663
static int tobeVerb(char const   *word , size_t l ) ;
#line 663 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *de___7[18]  = 
#line 663
  {      "sein",      "bin",      "bist",      "ist", 
        "sind",      "seid",      "war",      "warst", 
        "wart",      "waren",      "gewesen",      "w\344re", 
        "w\344rst",      "w\344r",      "w\344ren",      "w\344rt", 
        "w\344ret",      (char const   *)0};
#line 670 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *en___7[8]  = 
#line 670
  {      "be",      "being",      "was",      "were", 
        "been",      "are",      "is",      (char const   *)0};
#line 675 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static char const   *nl___7[8]  = 
#line 675
  {      "ben",      "bent",      "is",      "zijn", 
        "was",      "waren",      "geweest",      (char const   *)0};
#line 661 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int tobeVerb(char const   *word , size_t l ) 
{ 
  char const   **list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  tmp___1 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 684
  if (tmp___1 == 0) {
#line 684
    list = de___7;
  } else {
    {
#line 685
    tmp___0 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 685
    if (tmp___0 == 0) {
#line 685
      list = en___7;
    } else {
      {
#line 686
      tmp = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 686
      if (tmp == 0) {
#line 686
        list = nl___7;
      } else {
        {
#line 687
        __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                      687U, "tobeVerb");
        }
      }
    }
  }
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! *list) {
#line 689
      goto while_break;
    }
    {
#line 689
    tmp___2 = wordcmp(*list, word);
    }
#line 689
    if (tmp___2 == 0) {
#line 689
      return (1);
    } else {
#line 689
      list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  return (0);
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int vowel(char c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 700
  if ((int )c == 121) {
    {
#line 700
    tmp = strncmp(docLanguage, "en", (size_t )2);
    }
#line 700
    if (tmp) {
#line 700
      return (1);
    }
  }
  {
#line 704
  if ((unsigned int )lc_ctype_int == 0U) {
#line 704
    goto case_0;
  }
#line 705
  if ((unsigned int )lc_ctype_int == 1U) {
#line 705
    goto case_1;
  }
#line 707
  goto switch_default;
  case_0: /* CIL Label */ 
#line 704
  if ((int )c == 97) {
#line 704
    tmp___0 = 1;
  } else
#line 704
  if ((int )c == 101) {
#line 704
    tmp___0 = 1;
  } else
#line 704
  if ((int )c == 105) {
#line 704
    tmp___0 = 1;
  } else
#line 704
  if ((int )c == 111) {
#line 704
    tmp___0 = 1;
  } else
#line 704
  if ((int )c == 117) {
#line 704
    tmp___0 = 1;
  } else
#line 704
  if ((int )c == 121) {
#line 704
    tmp___0 = 1;
  } else {
#line 704
    tmp___0 = 0;
  }
#line 704
  return (tmp___0);
  case_1: /* CIL Label */ 
#line 705
  if ((int )c == 97) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -28) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == 101) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == 105) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == 111) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -10) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == 117) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -4) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -21) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -23) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -24) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -32) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == 105) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == -17) {
#line 705
    tmp___1 = 1;
  } else
#line 705
  if ((int )c == 121) {
#line 705
    tmp___1 = 1;
  } else {
#line 705
    tmp___1 = 0;
  }
#line 705
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 707
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                707U, "vowel");
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int syll_en(char const   *s , size_t l ) 
{ 
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 719
  count = 0;
#line 721
  if (l >= 2UL) {
#line 721
    if ((int const   )*((s + l) - 2) == 101) {
#line 721
      if ((int const   )*((s + l) - 1) == 100) {
#line 721
        l -= 2UL;
      }
    }
  }
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 722
    if (! l) {
#line 722
      goto while_break;
    }
#line 724
    if (l >= 2UL) {
      {
#line 724
      tmp = vowel((char )*s);
      }
#line 724
      if (tmp) {
        {
#line 724
        tmp___0 = vowel((char )*(s + 1));
        }
#line 724
        if (tmp___0) {
#line 725
          s ++;
#line 725
          l --;
        } else {
#line 724
          count ++;
#line 724
          s += 2;
#line 724
          l -= 2UL;
        }
      } else {
#line 725
        s ++;
#line 725
        l --;
      }
    } else {
#line 725
      s ++;
#line 725
      l --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  if (count == 0) {
#line 727
    tmp___1 = 1;
  } else {
#line 727
    tmp___1 = count;
  }
#line 727
  return (tmp___1);
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int syll_de(char const   *s , size_t l ) 
{ 
  int count ;
  size_t ol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 741
  count = 0;
#line 742
  ol = l;
#line 744
  tmp___4 = vowel((char )*s);
  }
#line 744
  if (tmp___4) {
    {
#line 745
    while (1) {
      while_continue: /* CIL Label */ ;
#line 745
      if (! l) {
#line 745
        goto while_break;
      }
#line 747
      if (l >= 2UL) {
        {
#line 747
        tmp___0 = vowel((char )*s);
        }
#line 747
        if (tmp___0) {
          {
#line 747
          tmp___1 = vowel((char )*(s + 1));
          }
#line 747
          if (tmp___1) {
#line 747
            goto _L___0;
          } else {
#line 747
            count ++;
#line 747
            s += 2;
#line 747
            l -= 2UL;
          }
        } else {
#line 747
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 748
      if (l == 1UL) {
#line 748
        if (ol > 1UL) {
          {
#line 748
          tmp = vowel((char )*(s - 1));
          }
#line 748
          if (tmp) {
#line 749
            s ++;
#line 749
            l --;
          } else
#line 748
          if ((int const   )*s == 101) {
#line 748
            count ++;
#line 748
            s ++;
#line 748
            l --;
          } else {
#line 749
            s ++;
#line 749
            l --;
          }
        } else {
#line 749
          s ++;
#line 749
          l --;
        }
      } else {
#line 749
        s ++;
#line 749
        l --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 752
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 752
      if (! l) {
#line 752
        goto while_break___0;
      }
#line 754
      if (l >= 2UL) {
        {
#line 754
        tmp___2 = vowel((char )*s);
        }
#line 754
        if (tmp___2) {
#line 755
          s ++;
#line 755
          l --;
        } else {
          {
#line 754
          tmp___3 = vowel((char )*(s + 1));
          }
#line 754
          if (tmp___3) {
#line 754
            count ++;
#line 754
            s += 2;
#line 754
            l -= 2UL;
          } else {
#line 755
            s ++;
#line 755
            l --;
          }
        }
      } else {
#line 755
        s ++;
#line 755
        l --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 757
  if (count == 0) {
#line 757
    tmp___5 = 1;
  } else {
#line 757
    tmp___5 = count;
  }
#line 757
  return (tmp___5);
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int syll_nl(char const   *s , size_t l ) 
{ 
  int count ;
  size_t ol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 771
  count = 0;
#line 772
  ol = l;
#line 774
  tmp___4 = vowel((char )*s);
  }
#line 774
  if (tmp___4) {
    {
#line 775
    while (1) {
      while_continue: /* CIL Label */ ;
#line 775
      if (! l) {
#line 775
        goto while_break;
      }
#line 777
      if (l >= 2UL) {
        {
#line 777
        tmp___0 = vowel((char )*s);
        }
#line 777
        if (tmp___0) {
          {
#line 777
          tmp___1 = vowel((char )*(s + 1));
          }
#line 777
          if (tmp___1) {
#line 777
            goto _L___0;
          } else {
#line 777
            count ++;
#line 777
            s += 2;
#line 777
            l -= 2UL;
          }
        } else {
#line 777
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 778
      if (l == 1UL) {
#line 778
        if (ol > 1UL) {
          {
#line 778
          tmp = vowel((char )*(s - 1));
          }
#line 778
          if (tmp) {
#line 779
            s ++;
#line 779
            l --;
          } else
#line 778
          if ((int const   )*s == 101) {
#line 778
            count ++;
#line 778
            s ++;
#line 778
            l --;
          } else {
#line 779
            s ++;
#line 779
            l --;
          }
        } else {
#line 779
          s ++;
#line 779
          l --;
        }
      } else {
#line 779
        s ++;
#line 779
        l --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 782
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 782
      if (! l) {
#line 782
        goto while_break___0;
      }
#line 784
      if (l >= 2UL) {
        {
#line 784
        tmp___2 = vowel((char )*s);
        }
#line 784
        if (tmp___2) {
#line 785
          s ++;
#line 785
          l --;
        } else {
          {
#line 784
          tmp___3 = vowel((char )*(s + 1));
          }
#line 784
          if (tmp___3) {
#line 784
            count ++;
#line 784
            s += 2;
#line 784
            l -= 2UL;
          } else {
#line 785
            s ++;
#line 785
            l --;
          }
        }
      } else {
#line 785
        s ++;
#line 785
        l --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 787
  if (count == 0) {
#line 787
    tmp___5 = 1;
  } else {
#line 787
    tmp___5 = count;
  }
#line 787
  return (tmp___5);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int syll(char const   *s , size_t l ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 799
  if (! ((unsigned long )s != (unsigned long )((char const   *)0))) {
    {
#line 799
    __assert_fail("s!=(const char*)0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                  799U, "syll");
    }
  }
#line 800
  if (! (l >= 1UL)) {
    {
#line 800
    __assert_fail("l>=1", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                  800U, "syll");
    }
  }
  {
#line 802
  tmp___5 = strncmp(docLanguage, "de", (size_t )2);
  }
#line 802
  if (tmp___5 == 0) {
    {
#line 802
    tmp = syll_de(s, l);
    }
#line 802
    return (tmp);
  } else {
    {
#line 803
    tmp___4 = strncmp(docLanguage, "en", (size_t )2);
    }
#line 803
    if (tmp___4 == 0) {
      {
#line 803
      tmp___0 = syll_en(s, l);
      }
#line 803
      return (tmp___0);
    } else {
      {
#line 804
      tmp___3 = strncmp(docLanguage, "nl", (size_t )2);
      }
#line 804
      if (tmp___3 == 0) {
        {
#line 804
        tmp___1 = syll_nl(s, l);
        }
#line 804
        return (tmp___1);
      } else {
        {
#line 805
        tmp___2 = syll_en(s, l);
        }
#line 805
        return (tmp___2);
      }
    }
  }
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int characters  ;
#line 812 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int syllables  ;
#line 813 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int words  ;
#line 814 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int shortwords  ;
#line 815 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int longwords  ;
#line 816 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int bigwords  ;
#line 817 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int sentences  ;
#line 818 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int questions  ;
#line 819 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int passiveSent  ;
#line 820 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int beginArticles  ;
#line 821 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int beginPronouns  ;
#line 822 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int pronouns  ;
#line 823 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int beginInterrogativePronouns  ;
#line 824 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int interrogativePronouns  ;
#line 825 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int beginConjunctions  ;
#line 826 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int conjunctions  ;
#line 827 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int nominalizations  ;
#line 828 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int prepositions  ;
#line 829 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int beginPrepositions  ;
#line 830 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int beginSubConjunctions  ;
#line 831 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int subConjunctions  ;
#line 832 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int auxVerbs  ;
#line 833 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int tobeVerbs  ;
#line 834 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int shortestLine  ;
#line 834 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int shortestLength  ;
#line 835 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int longestLine  ;
#line 835 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int longestLength  ;
#line 836 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int paragraphs  ;
#line 837 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int printLongSentences  =    0;
#line 838 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int printNomSentences  =    0;
#line 839 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static int printPassiveSentences  =    0;
#line 840 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static float printARI  =    (float )0.0;
#line 841 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static struct Hit lengths  ;
#line 849 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static void style(char const   *str , size_t length , char const   *file , int line ) 
{ 
  int firstWord ;
  int inword ;
  int innumber ;
  int wordLength ;
  int sentWords ;
  int sentLetters ;
  int count ;
  int passive ;
  int nom ;
  char const   *s ;
  char const   *end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  double tmp___14 ;

  {
#line 851
  firstWord = 1;
#line 852
  inword = 0;
#line 853
  innumber = 0;
#line 854
  wordLength = -1;
#line 855
  sentWords = 0;
#line 856
  sentLetters = 0;
#line 858
  passive = 0;
#line 859
  nom = 0;
#line 860
  s = str;
#line 860
  end = s + length;
#line 862
  if (length < 2UL) {
#line 862
    paragraphs ++;
#line 862
    return;
  }
#line 863
  if (! ((unsigned long )str != (unsigned long )((char const   *)0))) {
    {
#line 863
    __assert_fail("str!=(const char*)0", "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c",
                  863U, "style");
    }
  }
#line 864
  phraseEnd = (char const   *)0;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )s < (unsigned long )end)) {
#line 865
      goto while_break;
    }
#line 867
    if (inword) {
      {
#line 869
      tmp___8 = __ctype_b_loc();
      }
#line 869
      if ((int const   )*(*tmp___8 + (int )*s) & 1024) {
#line 922
        wordLength ++;
#line 923
        characters ++;
#line 924
        sentLetters ++;
      } else
#line 869
      if ((int const   )*s != 45) {
        {
#line 869
        tmp___9 = endingInPossesiveS(str, (size_t )((s - str) + 2L));
        }
#line 869
        if (tmp___9) {
#line 922
          wordLength ++;
#line 923
          characters ++;
#line 924
          sentLetters ++;
        } else {
          {
#line 871
          inword = 0;
#line 872
          count = syll(s - wordLength, (size_t )wordLength);
#line 873
          syllables += count;
          }
#line 874
          if (count >= 3) {
#line 874
            bigwords ++;
          } else
#line 875
          if (count == 1) {
#line 875
            shortwords ++;
          }
#line 876
          if (wordLength > 6) {
#line 876
            longwords ++;
          }
#line 877
          if ((unsigned long )(s - wordLength) > (unsigned long )phraseEnd) {
            {
#line 880
            tmp___7 = article(s - wordLength, (size_t )wordLength);
            }
#line 880
            if (tmp___7) {
#line 880
              if (firstWord) {
#line 880
                beginArticles ++;
              } else {
#line 880
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 881
              tmp___6 = pronoun(s - wordLength, (size_t )wordLength);
              }
#line 881
              if (tmp___6) {
#line 883
                pronouns ++;
#line 884
                if (firstWord) {
#line 884
                  beginPronouns ++;
                }
              } else {
                {
#line 886
                tmp___5 = interrogativePronoun(s - wordLength, (size_t )wordLength);
                }
#line 886
                if (tmp___5) {
#line 888
                  interrogativePronouns ++;
#line 889
                  if (firstWord) {
#line 889
                    beginInterrogativePronouns ++;
                  }
                } else {
                  {
#line 891
                  tmp___4 = conjunction(s - wordLength, (size_t )wordLength);
                  }
#line 891
                  if (tmp___4) {
#line 893
                    conjunctions ++;
#line 894
                    if (firstWord) {
#line 894
                      beginConjunctions ++;
                    }
                  } else {
                    {
#line 896
                    tmp___3 = subConjunction(s - wordLength, (size_t )wordLength);
                    }
#line 896
                    if (tmp___3) {
#line 898
                      subConjunctions ++;
#line 899
                      if (firstWord) {
#line 899
                        beginSubConjunctions ++;
                      }
                    } else {
                      {
#line 901
                      tmp___2 = preposition(s - wordLength, (size_t )wordLength);
                      }
#line 901
                      if (tmp___2) {
#line 903
                        prepositions ++;
#line 904
                        if (firstWord) {
#line 904
                          beginPrepositions ++;
                        }
                      } else {
                        {
#line 906
                        tmp___1 = tobeVerb(s - wordLength, (size_t )wordLength);
                        }
#line 906
                        if (tmp___1) {
#line 908
                          passive ++;
#line 909
                          tobeVerbs ++;
                        } else {
                          {
#line 911
                          tmp___0 = auxVerb(s - wordLength, (size_t )wordLength);
                          }
#line 911
                          if (tmp___0) {
#line 911
                            auxVerbs ++;
                          } else {
                            {
#line 912
                            tmp = nominalization(s - wordLength, (size_t )wordLength);
                            }
#line 912
                            if (tmp) {
#line 914
                              nom ++;
#line 915
                              nominalizations ++;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#line 918
          if (firstWord) {
#line 918
            firstWord = 0;
          }
        }
      } else {
#line 922
        wordLength ++;
#line 923
        characters ++;
#line 924
        sentLetters ++;
      }
    } else
#line 927
    if (innumber) {
      {
#line 929
      tmp___10 = __ctype_b_loc();
      }
#line 929
      if ((int const   )*(*tmp___10 + (int )*s) & 2048) {
#line 931
        wordLength ++;
#line 932
        characters ++;
#line 933
        sentLetters ++;
      } else
#line 929
      if ((int const   )*s == 46) {
#line 929
        goto _L___0;
      } else
#line 929
      if ((int const   )*s == 44) {
        _L___0: /* CIL Label */ 
        {
#line 929
        tmp___11 = __ctype_b_loc();
        }
#line 929
        if ((int const   )*(*tmp___11 + (int )*(s + 1)) & 2048) {
#line 931
          wordLength ++;
#line 932
          characters ++;
#line 933
          sentLetters ++;
        } else {
#line 937
          innumber = 0;
#line 938
          syllables ++;
        }
      } else {
#line 937
        innumber = 0;
#line 938
        syllables ++;
      }
    } else {
      {
#line 943
      tmp___13 = __ctype_b_loc();
      }
#line 943
      if ((int const   )*(*tmp___13 + (int )*s) & 1024) {
#line 945
        words ++;
#line 946
        sentWords ++;
#line 947
        inword = 1;
#line 948
        wordLength = 1;
#line 949
        characters ++;
#line 950
        sentLetters ++;
      } else {
        {
#line 952
        tmp___12 = __ctype_b_loc();
        }
#line 952
        if ((int const   )*(*tmp___12 + (int )*s) & 2048) {
#line 954
          words ++;
#line 955
          sentWords ++;
#line 956
          innumber = 1;
#line 957
          wordLength = 1;
#line 958
          characters ++;
#line 959
          sentLetters ++;
        }
      }
    }
#line 962
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 964
  sentences ++;
#line 965
  if (shortestLine == 0) {
#line 967
    shortestLine = sentences;
#line 968
    shortestLength = sentWords;
  } else
#line 965
  if (sentWords < shortestLength) {
#line 967
    shortestLine = sentences;
#line 968
    shortestLength = sentWords;
  }
#line 970
  if (longestLine == 0) {
#line 972
    longestLine = sentences;
#line 973
    longestLength = sentWords;
  } else
#line 970
  if (sentWords > longestLength) {
#line 972
    longestLine = sentences;
#line 973
    longestLength = sentWords;
  }
#line 975
  if ((int const   )*(str + (length - 1UL)) == 63) {
#line 975
    questions ++;
  }
  {
#line 976
  noteHit(& lengths, sentWords);
  }
#line 977
  if (passive) {
#line 977
    passiveSent ++;
  }
#line 978
  if (printLongSentences) {
#line 978
    if (sentWords >= printLongSentences) {
      {
#line 981
      printf((char const   */* __restrict  */)"%s:%d: %s\n", file, line, str);
      }
    } else {
#line 978
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 978
  if (printARI) {
    {
#line 978
    tmp___14 = ari(sentLetters, sentWords, 1);
    }
#line 978
    if (tmp___14 > (double )printARI) {
      {
#line 981
      printf((char const   */* __restrict  */)"%s:%d: %s\n", file, line, str);
      }
    } else {
#line 978
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 978
  if (printPassiveSentences) {
#line 978
    if (passive) {
      {
#line 981
      printf((char const   */* __restrict  */)"%s:%d: %s\n", file, line, str);
      }
    } else {
#line 978
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 978
  if (printNomSentences) {
#line 978
    if (nom) {
      {
#line 981
      printf((char const   */* __restrict  */)"%s:%d: %s\n", file, line, str);
      }
    }
  }
#line 982
  return;
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static void print_usage(FILE *handle ) 
{ 
  char *tmp ;

  {
  {
#line 987
  tmp = gettext("Usage: style [-L language] [-l length] [-r ari] [file ...]\n       style [--language language] [--print-long length] [--print-ari ari]\n             [file ...]\n       style --version\n");
#line 987
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)handle);
  }
#line 992
  return;
}
}
#line 999
int main(int argc , char **argv ) ;
#line 999 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
static struct option lopts[9]  = 
#line 999
  {      {"help", 0, (int *)0, 'h'}, 
        {"print-long", 1, (int *)0, 'l'}, 
        {"language", 1, (int *)0, 'L'}, 
        {"print-ari", 1, (int *)0, 'r'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"print-passive", 0, (int *)0, 'p'}, 
        {"print-nom", 0, (int *)0, 'N'}, 
        {"print-nom-passive", 0, (int *)0, 'N'}, 
        {(char const   *)0, 0, (int *)0, '\000'}};
#line 995 "/home/june/repo/benchmarks/collector/temp/diction-1.11/style.c"
int main(int argc , char **argv ) 
{ 
  int usage ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *end ;
  long tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *end___0 ;
  double tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  FILE *fp ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  double fl ;
  int lixg ;
  int i ;
  int shortLength ;
  int shortSent ;
  int longLength ;
  int longSent ;
  char *tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  double tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;

  {
  {
#line 998
  usage = 0;
#line 1014
  setlocale(6, "");
#line 1016
  bindtextdomain("diction", "/usr/local/share/locale");
#line 1017
  textdomain("diction");
#line 1025
  tmp = getenv("LC_CTYPE");
#line 1025
  lc_ctype = (char const   *)tmp;
  }
#line 1025
  if ((unsigned long )lc_ctype == (unsigned long )((char const   *)0)) {
#line 1025
    lc_ctype = "C";
  }
  {
#line 1026
  tmp___0 = getenv("LC_MESSAGES");
#line 1026
  docLanguage = (char const   *)tmp___0;
  }
#line 1026
  if ((unsigned long )docLanguage == (unsigned long )((char const   *)0)) {
#line 1026
    docLanguage = "C";
  }
  {
#line 1028
  tmp___1 = strcmp(docLanguage, "C");
  }
#line 1028
  if (tmp___1 == 0) {
#line 1028
    docLanguage = "en";
  }
  {
#line 1029
  tmp___2 = strstr(lc_ctype, "8859-1");
  }
#line 1029
  if (tmp___2) {
#line 1029
    lc_ctype_int = (enum lc_ctype_int )1;
  } else {
#line 1030
    lc_ctype_int = (enum lc_ctype_int )0;
  }
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1031
    c = getopt_long(argc, (char * const  *)argv, "l:L:r:hpnN", (struct option  const  *)(lopts),
                    (int *)0);
    }
#line 1031
    if (! (c != -1)) {
#line 1031
      goto while_break;
    }
    {
#line 1033
    if (c == 108) {
#line 1033
      goto case_108;
    }
#line 1040
    if (c == 76) {
#line 1040
      goto case_76;
    }
#line 1050
    if (c == 114) {
#line 1050
      goto case_114;
    }
#line 1057
    if (c == 112) {
#line 1057
      goto case_112;
    }
#line 1062
    if (c == 78) {
#line 1062
      goto case_78;
    }
#line 1067
    if (c == 110) {
#line 1067
      goto case_110;
    }
#line 1073
    if (c == 118) {
#line 1073
      goto case_118;
    }
#line 1074
    if (c == 104) {
#line 1074
      goto case_104;
    }
#line 1075
    goto switch_default;
    case_108: /* CIL Label */ 
    {
#line 1036
    tmp___3 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end),
                     10);
#line 1036
    printLongSentences = (int )tmp___3;
    }
#line 1037
    if ((unsigned long )end == (unsigned long )optarg) {
#line 1037
      usage = 1;
    } else
#line 1037
    if ((int )*end != 0) {
#line 1037
      usage = 1;
    }
#line 1038
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1042
    docLanguage = (char const   *)optarg;
#line 1043
    tmp___5 = strncmp(docLanguage, "de", (size_t )2);
    }
#line 1043
    if (tmp___5) {
      {
#line 1043
      tmp___6 = strncmp(docLanguage, "en", (size_t )2);
      }
#line 1043
      if (tmp___6) {
        {
#line 1043
        tmp___7 = strncmp(docLanguage, "nl", (size_t )2);
        }
#line 1043
        if (tmp___7) {
          {
#line 1045
          tmp___4 = gettext("style: Incorrect language option `%s\'.\n");
#line 1045
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                  docLanguage);
#line 1046
          exit(1);
          }
        }
      }
    }
#line 1048
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1053
    tmp___8 = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end___0));
#line 1053
    printARI = (float )tmp___8;
    }
#line 1054
    if ((unsigned long )end___0 == (unsigned long )optarg) {
#line 1054
      usage = 1;
    } else
#line 1054
    if ((int )*end___0 != 0) {
#line 1054
      usage = 1;
    }
#line 1055
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1059
    printPassiveSentences = 1;
#line 1060
    goto switch_break;
    case_78: /* CIL Label */ 
#line 1064
    printNomSentences = 1;
#line 1065
    goto switch_break;
    case_110: /* CIL Label */ 
#line 1069
    printNomSentences = 1;
#line 1070
    printPassiveSentences = 1;
#line 1071
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 1073
    fputs((char const   */* __restrict  */)"GNU style 1.11\n", (FILE */* __restrict  */)stdout);
#line 1073
    exit(0);
    }
    case_104: /* CIL Label */ 
#line 1074
    usage = 2;
#line 1074
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1075
    usage = 1;
#line 1075
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (usage == 1) {
    {
#line 1079
    print_usage(stderr);
#line 1080
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
#line 1081
    tmp___9 = gettext("Try style -h|--help for more information.\n");
#line 1081
    fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stderr);
#line 1082
    exit(1);
    }
  } else
#line 1084
  if (usage == 2) {
    {
#line 1086
    print_usage(stdout);
#line 1087
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
#line 1088
    tmp___10 = gettext("Analyse surface characteristics of a document.\n\n");
#line 1088
    fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stdout);
#line 1089
    tmp___11 = gettext("-L, --language          set the document language.\n-l, --print-long        print all sentences longer than <length> words\n-r, --print-ari         print all sentences with an ARI greater than than <ari>\n-p, --print-passive     print all sentences phrased in the passive voice\n-N, --print-nom         print all sentences containing nominalizations\n-n, --print-nom-passive print all sentences phrased in the passive voice or\n                        containing nominalizations\n");
#line 1089
    fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)stdout);
#line 1097
    tmp___12 = gettext("-h, --help              print this message\n    --version           print the version\n");
#line 1097
    fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)stdout);
#line 1100
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
#line 1101
    tmp___13 = gettext("Report bugs to <michael@moria.de>.\n");
#line 1101
    fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)stdout);
#line 1102
    exit(0);
    }
  }
  {
#line 1105
  newHit(& lengths);
  }
#line 1106
  if (optind == argc) {
    {
#line 1106
    sentence("style", stdin, "(stdin)", & style, docLanguage);
    }
  } else {
    {
#line 1107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1107
      if (! (optind < argc)) {
#line 1107
        goto while_break___0;
      }
      {
#line 1110
      fp = fopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"r");
      }
#line 1110
      if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
        {
#line 1111
        tmp___14 = __errno_location();
#line 1111
        tmp___15 = strerror(*tmp___14);
#line 1111
        tmp___16 = gettext("style: Opening `%s\' failed (%s).\n");
#line 1111
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
                *(argv + optind), tmp___15);
        }
      } else {
        {
#line 1114
        sentence("style", fp, (char const   *)*(argv + optind), & style, docLanguage);
#line 1115
        fclose(fp);
        }
      }
#line 1117
      optind ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1119
  if (sentences == 0) {
    {
#line 1121
    tmp___17 = gettext("No sentences found.\n");
#line 1121
    printf((char const   */* __restrict  */)tmp___17);
    }
  } else {
    {
#line 1130
    tmp___18 = gettext("readability grades:\n");
#line 1130
    printf((char const   */* __restrict  */)tmp___18);
#line 1131
    tmp___19 = kincaid(syllables, words, sentences);
#line 1131
    printf((char const   */* __restrict  */)"        %s: %.1f\n", "Kincaid", tmp___19);
#line 1132
    tmp___20 = ari(characters, words, sentences);
#line 1132
    printf((char const   */* __restrict  */)"        %s: %.1f\n", "ARI", tmp___20);
#line 1133
    tmp___21 = coleman_liau(characters, words, sentences);
#line 1133
    printf((char const   */* __restrict  */)"        %s: %.1f\n", "Coleman-Liau",
           tmp___21);
#line 1134
    fl = flesch(syllables, words, sentences);
    }
#line 1135
    if (fl >= (double )60) {
#line 1135
      if (fl <= (double )70) {
        {
#line 1135
        tmp___22 = gettext("/100 (plain English)");
#line 1135
        tmp___24 = tmp___22;
        }
      } else {
        {
#line 1135
        tmp___23 = gettext("/100");
#line 1135
        tmp___24 = tmp___23;
        }
      }
    } else {
      {
#line 1135
      tmp___23 = gettext("/100");
#line 1135
      tmp___24 = tmp___23;
      }
    }
    {
#line 1135
    printf((char const   */* __restrict  */)"        %s: %.1f%s\n", "Flesch Index",
           fl, tmp___24);
#line 1136
    tmp___25 = fog(words, bigwords, sentences);
#line 1136
    printf((char const   */* __restrict  */)"        %s: %.1f\n", "Fog Index", tmp___25);
#line 1144
    tmp___26 = lix(& lixg, words, longwords, sentences);
#line 1144
    tmp___27 = gettext("Lix");
#line 1144
    printf((char const   */* __restrict  */)"        %s: %.1f = ", tmp___27, tmp___26);
    }
#line 1145
    if (lixg == 0) {
      {
#line 1145
      tmp___28 = gettext("below school year 5\n");
#line 1145
      printf((char const   */* __restrict  */)tmp___28);
      }
    } else
#line 1146
    if (lixg == 99) {
      {
#line 1146
      tmp___29 = gettext("higher than school year 11\n");
#line 1146
      printf((char const   */* __restrict  */)tmp___29);
      }
    } else {
      {
#line 1147
      tmp___30 = gettext("school year %d\n");
#line 1147
      printf((char const   */* __restrict  */)tmp___30, lixg);
      }
    }
    {
#line 1148
    tmp___31 = smog(bigwords, sentences);
#line 1148
    tmp___32 = gettext("SMOG-Grading");
#line 1148
    printf((char const   */* __restrict  */)"        %s: %.1f\n", tmp___32, tmp___31);
#line 1150
    tmp___33 = gettext("sentence info:\n");
#line 1150
    printf((char const   */* __restrict  */)tmp___33);
#line 1151
    tmp___34 = gettext("        %d characters\n");
#line 1151
    printf((char const   */* __restrict  */)tmp___34, characters);
#line 1152
    tmp___35 = gettext("        %d words, average length %.2f characters = %.2f syllables\n");
#line 1152
    printf((char const   */* __restrict  */)tmp___35, words, (double )characters / (double )words,
           (double )syllables / (double )words);
#line 1153
    tmp___36 = gettext("        %d sentences, average length %.1f words\n");
#line 1153
    printf((char const   */* __restrict  */)tmp___36, sentences, (double )words / (double )sentences);
#line 1154
    shortLength = (int )((double )words / (double )sentences - 4.5);
    }
#line 1155
    if (shortLength < 1) {
#line 1155
      shortLength = 1;
    }
#line 1156
    i = 0;
#line 1156
    shortSent = 0;
    {
#line 1156
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1156
      if (! (i <= shortLength)) {
#line 1156
        goto while_break___1;
      }
#line 1156
      shortSent += *(lengths.data + i);
#line 1156
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1157
    tmp___37 = gettext("        %d%% (%d) short sentences (at most %d words)\n");
#line 1157
    printf((char const   */* __restrict  */)tmp___37, (100 * shortSent) / sentences,
           shortSent, shortLength);
#line 1158
    longLength = (int )((double )words / (double )sentences + 10.5);
#line 1159
    i = longLength - 1;
#line 1159
    longSent = 0;
    }
    {
#line 1159
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1159
      if (! (i <= lengths.size)) {
#line 1159
        goto while_break___2;
      }
#line 1159
      longSent += *(lengths.data + i);
#line 1159
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1160
    tmp___38 = gettext("        %d%% (%d) long sentences (at least %d words)\n");
#line 1160
    printf((char const   */* __restrict  */)tmp___38, (100 * longSent) / sentences,
           longSent, longLength);
#line 1161
    tmp___39 = gettext("        %d paragraphs, average length %.1f sentences\n");
#line 1161
    printf((char const   */* __restrict  */)tmp___39, paragraphs, (double )sentences / (double )paragraphs);
#line 1162
    tmp___40 = gettext("        %d%% (%d) questions\n");
#line 1162
    printf((char const   */* __restrict  */)tmp___40, (100 * questions) / sentences,
           questions);
#line 1163
    tmp___41 = gettext("        %d%% (%d) passive sentences\n");
#line 1163
    printf((char const   */* __restrict  */)tmp___41, (100 * passiveSent) / sentences,
           passiveSent);
#line 1164
    tmp___42 = gettext("        longest sent %d wds at sent %d; shortest sent %d wds at sent %d\n");
#line 1164
    printf((char const   */* __restrict  */)tmp___42, longestLength, longestLine,
           shortestLength, shortestLine);
#line 1181
    tmp___43 = gettext("word usage:\n");
#line 1181
    printf((char const   */* __restrict  */)tmp___43);
#line 1182
    tmp___44 = gettext("        verb types:\n");
#line 1182
    printf((char const   */* __restrict  */)tmp___44);
#line 1183
    tmp___45 = gettext("        to be (%d) auxiliary (%d) \n");
#line 1183
    printf((char const   */* __restrict  */)tmp___45, tobeVerbs, auxVerbs);
#line 1184
    tmp___46 = gettext("        types as %% of total:\n");
#line 1184
    printf((char const   */* __restrict  */)tmp___46);
#line 1185
    tmp___47 = gettext("        conjunctions %1.f% (%d) pronouns %1.f% (%d) prepositions %1.f% (%d)\n");
#line 1185
    printf((char const   */* __restrict  */)tmp___47, (100.0 * (double )(conjunctions + subConjunctions)) / (double )words,
           conjunctions + subConjunctions, (100.0 * (double )pronouns) / (double )words,
           pronouns, (100.0 * (double )prepositions) / (double )words, prepositions);
#line 1190
    tmp___48 = gettext("        nominalizations %1.f% (%d)\n");
#line 1190
    printf((char const   */* __restrict  */)tmp___48, (100.0 * (double )nominalizations) / (double )words,
           nominalizations);
#line 1193
    tmp___49 = gettext("sentence beginnings:\n");
#line 1193
    printf((char const   */* __restrict  */)tmp___49);
#line 1194
    tmp___50 = gettext("        pronoun (%d) interrogative pronoun (%d) article (%d)\n");
#line 1194
    printf((char const   */* __restrict  */)tmp___50, beginPronouns, beginInterrogativePronouns,
           beginArticles);
#line 1195
    tmp___51 = gettext("        subordinating conjunction (%d) conjunction (%d) preposition (%d)\n");
#line 1195
    printf((char const   */* __restrict  */)tmp___51, beginSubConjunctions, beginConjunctions,
           beginPrepositions);
    }
  }
  {
#line 1204
  exit(0);
  }
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_de[6]  = {      "Dr",      "bzw",      "etc",      "sog", 
        "usw",      (char const   *)0};
#line 62 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_en[49]  = 
#line 62
  {      "ch",      "Ch",      "ckts",      "dB", 
        "Dept",      "dept",      "Depts",      "depts", 
        "Dr",      "Drs",      "Eq",      "eq", 
        "etc",      "et al",      "Fig",      "fig", 
        "Figs",      "figs",      "ft",      "0 in", 
        "1 in",      "2 in",      "3 in",      "4 in", 
        "5 in",      "6 in",      "7 in",      "8 in", 
        "9 in",      "Inc",      "Jr",      "jr", 
        "mi",      "Mr",      "Mrs",      "Ms", 
        "No",      "no",      "Nos",      "nos", 
        "Ph",      "Ref",      "ref",      "Refs", 
        "refs",      "St",      "vs",      "yr", 
        (char const   *)0};
#line 115 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_nl[20]  = 
#line 115
  {      "as",      "aub",      "bijv",      "bv", 
        "ca",      "dd",      "dr",      "drs", 
        "ed",      "jl",      "maw",      "muv", 
        "oa",      "tav",      "tzt",      "zg", 
        "zgn",      "zoz",      "zsm",      (char const   *)0};
#line 139 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_none[1]  = {      (char const   *)0};
#line 144 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   **abbreviations  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static int endingInAbbrev(char const   *s , size_t length , char const   *lang ) 
{ 
  char const   **abbrev ;
  size_t aLength ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  abbrev = abbreviations;
#line 151
  tmp = __ctype_b_loc();
  }
#line 151
  if (! ((int const   )*(*tmp + (int )*(s + (length - 1UL))) & 1024)) {
#line 151
    return (0);
  }
  {
#line 152
  tmp___0 = endingInPossesiveS(s, length);
  }
#line 152
  if (tmp___0) {
#line 152
    return (0);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((unsigned long )*abbrev != (unsigned long )((char const   *)0))) {
#line 153
      goto while_break;
    }
    {
#line 155
    aLength = strlen(*abbrev);
    }
#line 155
    if (aLength < length) {
      {
#line 157
      tmp___1 = __ctype_b_loc();
      }
#line 157
      if (! ((int const   )*(*tmp___1 + (int )*(s + (length - 2UL))) & 1024)) {
#line 157
        return (1);
      }
      {
#line 158
      tmp___2 = __ctype_b_loc();
      }
#line 158
      if (! ((int const   )*(*tmp___2 + (int )*(s + ((length - aLength) - 1UL))) & 1024)) {
        {
#line 158
        tmp___3 = strncmp((s + length) - aLength, *abbrev, aLength);
        }
#line 158
        if (tmp___3 == 0) {
#line 158
          return (1);
        }
      }
    } else {
#line 162
      if (length == 1UL) {
#line 162
        return (1);
      }
#line 163
      if (aLength == length) {
        {
#line 163
        tmp___4 = strncmp(s, *abbrev, aLength);
        }
#line 163
        if (tmp___4 == 0) {
#line 163
          return (1);
        }
      }
    }
#line 165
    abbrev ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
int endingInPossesiveS(char const   *s , size_t length ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 173
  if ((unsigned long )abbreviations == (unsigned long )(abbreviations_en)) {
#line 173
    if (length >= 3UL) {
      {
#line 173
      tmp = strncmp((s + length) - 2, "\'s", (size_t )2);
      }
#line 173
      if (tmp == 0) {
#line 173
        tmp___0 = 1;
      } else {
#line 173
        tmp___0 = 0;
      }
    } else {
#line 173
      tmp___0 = 0;
    }
  } else {
#line 173
    tmp___0 = 0;
  }
#line 173
  return (tmp___0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
void sentence(char const   *cmd , FILE *in , char const   *file , void (*process)(char const   * ,
                                                                                  size_t  ,
                                                                                  char const   * ,
                                                                                  int  ) ,
              char const   *lang ) 
{ 
  int voc ;
  int oc ;
  int c ;
  char *sent ;
  void *tmp ;
  size_t length ;
  size_t capacity ;
  int inSentence ;
  int inWhiteSpace ;
  int inParagraph ;
  int ellipsis ;
  int line ;
  int beginLine ;
  int err ;
  regex_t hashLine ;
  char filebuf[257] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char buf[256] ;
  size_t len ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char buf___0[276] ;
  regmatch_t found[3] ;
  size_t len___0 ;
  long tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  unsigned short const   **tmp___14 ;
  char foo ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  int tmp___24 ;
  unsigned short const   **tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  size_t tmp___29 ;
  unsigned short const   **tmp___30 ;

  {
  {
#line 180
  tmp = malloc((size_t )128);
#line 180
  sent = (char *)tmp;
#line 181
  length = (size_t )0;
#line 181
  capacity = (size_t )128;
#line 182
  inSentence = 0;
#line 183
  inWhiteSpace = 0;
#line 184
  inParagraph = 0;
#line 185
  ellipsis = 0;
#line 186
  line = 1;
#line 186
  beginLine = 1;
#line 192
  tmp___3 = strncmp(lang, "en", (size_t )2);
  }
#line 192
  if (tmp___3 == 0) {
#line 192
    abbreviations = abbreviations_en;
  } else {
    {
#line 193
    tmp___2 = strncmp(lang, "C", (size_t )1);
    }
#line 193
    if (tmp___2 == 0) {
#line 193
      abbreviations = abbreviations_en;
    } else {
      {
#line 194
      tmp___1 = strncmp(lang, "de", (size_t )2);
      }
#line 194
      if (tmp___1 == 0) {
#line 194
        abbreviations = abbreviations_de;
      } else {
        {
#line 195
        tmp___0 = strncmp(lang, "nl", (size_t )2);
        }
#line 195
        if (tmp___0 == 0) {
#line 195
          abbreviations = abbreviations_nl;
        } else {
#line 196
          abbreviations = abbreviations_none;
        }
      }
    }
  }
  {
#line 198
  err = regcomp((regex_t */* __restrict  */)(& hashLine), (char const   */* __restrict  */)"^[ \t]*line[ \t]*\\([0-9][0-9]*\\)[ \t]*\"\\([^\"]*\\)\"",
                0);
  }
#line 198
  if (err) {
    {
#line 201
    tmp___4 = regerror(err, (regex_t const   */* __restrict  */)(& hashLine), (char */* __restrict  */)(buf),
                       sizeof(buf) - 1UL);
#line 201
    len = tmp___4;
#line 202
    buf[len] = (char )'\000';
#line 203
    tmp___5 = gettext("%s: internal error, compiling a regular expression failed (%s).\n");
#line 203
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            cmd, buf);
#line 204
    exit(2);
    }
  }
  {
#line 207
  voc = '\n';
#line 208
  c = _IO_getc(in);
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    oc = c;
#line 209
    if (! (oc != -1)) {
#line 209
      goto while_break;
    }
    {
#line 211
    c = _IO_getc(in);
    }
#line 212
    if (oc == 10) {
#line 212
      line ++;
    }
#line 213
    if (voc == 10) {
#line 213
      if (oc == 35) {
        {
#line 218
        buf___0[0] = (char )c;
#line 218
        buf___0[1] = (char )'\000';
#line 219
        fgets((char */* __restrict  */)(buf___0 + 1), (int )(sizeof(buf___0) - 1UL),
              (FILE */* __restrict  */)in);
#line 220
        tmp___7 = regexec((regex_t const   */* __restrict  */)(& hashLine), (char const   */* __restrict  */)(buf___0),
                          (size_t )3, (regmatch_t */* __restrict  */)(found), 0);
        }
#line 220
        if (tmp___7 == 0) {
          {
#line 224
          tmp___6 = strtol((char const   */* __restrict  */)(buf___0 + found[1].rm_so),
                           (char **/* __restrict  */)((char **)0), 10);
#line 224
          line = (int )(tmp___6 - 1L);
#line 225
          len___0 = (size_t )(found[2].rm_eo - found[2].rm_so);
          }
#line 226
          if (len___0 > 256UL) {
#line 226
            len___0 = (size_t )256;
          }
          {
#line 227
          strncpy((char */* __restrict  */)(filebuf), (char const   */* __restrict  */)(buf___0 + found[2].rm_so),
                  len___0);
#line 228
          filebuf[len___0] = (char )'\000';
#line 229
          file = (char const   *)(filebuf);
          }
        }
#line 232
        c = '\n';
#line 233
        goto while_continue;
      }
    }
#line 236
    if (length) {
#line 238
      if (length >= capacity - 1UL) {
        {
#line 238
        capacity *= 2UL;
#line 238
        tmp___11 = realloc((void *)sent, capacity);
#line 238
        sent = (char *)tmp___11;
        }
#line 238
        if ((unsigned long )sent == (unsigned long )((char *)0)) {
          {
#line 240
          tmp___8 = __errno_location();
#line 240
          tmp___9 = strerror(*tmp___8);
#line 240
          tmp___10 = gettext("%s: increasing sentence buffer failed: %s\n");
#line 240
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                  cmd, tmp___9);
#line 241
          exit(2);
          }
        }
      }
      {
#line 243
      tmp___28 = __ctype_b_loc();
      }
#line 243
      if ((int const   )*(*tmp___28 + oc) & 8192) {
#line 245
        if (! inWhiteSpace) {
#line 247
          tmp___12 = length;
#line 247
          length ++;
#line 247
          *(sent + tmp___12) = (char )' ';
#line 248
          inWhiteSpace = 1;
        }
      } else {
        {
#line 253
        tmp___13 = length;
#line 253
        length ++;
#line 253
        *(sent + tmp___13) = (char )oc;
#line 254
        tmp___14 = __ctype_b_loc();
        }
#line 254
        if ((int const   )*(*tmp___14 + oc) & 1024) {
#line 254
          inSentence = 1;
        }
#line 255
        if (length == 3UL) {
          {
#line 255
          tmp___24 = strncmp((char const   *)((sent + length) - 3), "...", (size_t )3);
          }
#line 255
          if (tmp___24 == 0) {
#line 255
            if (c == -1) {
#line 262
              inWhiteSpace = 0;
            } else {
              {
#line 255
              tmp___25 = __ctype_b_loc();
              }
#line 255
              if ((int const   )*(*tmp___25 + c) & 8192) {
#line 262
                inWhiteSpace = 0;
              } else {
#line 255
                goto _L___13;
              }
            }
          } else {
#line 255
            goto _L___13;
          }
        } else
        _L___13: /* CIL Label */ 
#line 255
        if (length >= 4UL) {
          {
#line 255
          tmp___26 = strncmp((char const   *)((sent + length) - 4), " ...", (size_t )4);
          }
#line 255
          if (tmp___26 == 0) {
#line 255
            if (c == -1) {
#line 262
              inWhiteSpace = 0;
            } else {
              {
#line 255
              tmp___27 = __ctype_b_loc();
              }
#line 255
              if ((int const   )*(*tmp___27 + c) & 8192) {
#line 262
                inWhiteSpace = 0;
              } else {
#line 255
                goto _L___11;
              }
            }
          } else {
#line 255
            goto _L___11;
          }
        } else
        _L___11: /* CIL Label */ 
#line 264
        if (length >= 4UL) {
          {
#line 264
          tmp___21 = __ctype_b_loc();
          }
#line 264
          if ((int const   )*(*tmp___21 + (int )*(sent + (length - 4UL))) & 8192) {
#line 264
            goto _L___9;
          } else {
            {
#line 264
            tmp___22 = strncmp((char const   *)((sent + length) - 3), "...", (size_t )3);
            }
#line 264
            if (tmp___22 == 0) {
#line 264
              if (c == -1) {
#line 264
                goto _L___7;
              } else {
                {
#line 264
                tmp___23 = __ctype_b_loc();
                }
#line 264
                if ((int const   )*(*tmp___23 + c) & 8192) {
                  _L___7: /* CIL Label */ 
#line 269
                  foo = *(sent + (length - 3UL));
#line 270
                  *(sent + (length - 3UL)) = (char )'\000';
#line 271
                  if (inSentence) {
                    {
#line 271
                    (*process)((char const   *)sent, length - 3UL, file, beginLine);
                    }
                  }
                  {
#line 272
                  *(sent + (length - 3UL)) = foo;
#line 273
                  memmove((void *)sent, (void const   *)((sent + length) - 3), (size_t )3);
#line 274
                  length = (size_t )3;
#line 275
                  inParagraph = 0;
#line 276
                  inWhiteSpace = 0;
#line 277
                  beginLine = line;
#line 278
                  inSentence = 0;
                  }
                } else {
#line 264
                  goto _L___9;
                }
              }
            } else {
#line 264
              goto _L___9;
            }
          }
        } else
        _L___9: /* CIL Label */ 
#line 280
        if (length >= 4UL) {
          {
#line 280
          tmp___19 = strncmp((char const   *)((sent + length) - 4), "...", (size_t )3);
          }
#line 280
          if (tmp___19 == 0) {
#line 280
            if (c == -1) {
#line 280
              goto _L___4;
            } else {
              {
#line 280
              tmp___20 = __ctype_b_loc();
              }
#line 280
              if ((int const   )*(*tmp___20 + c) & 8192) {
                _L___4: /* CIL Label */ 
#line 283
                if (inWhiteSpace) {
#line 283
                  length --;
                }
#line 284
                *(sent + length) = (char )'\000';
#line 285
                if (inSentence) {
                  {
#line 285
                  (*process)((char const   *)sent, length, file, beginLine);
                  }
                }
#line 286
                length = (size_t )0;
#line 287
                inWhiteSpace = 0;
#line 288
                inSentence = 0;
              } else {
#line 280
                goto _L___5;
              }
            }
          } else {
#line 280
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 290
        if (oc == 46) {
#line 290
          goto _L___2;
        } else
#line 290
        if (oc == 58) {
#line 290
          goto _L___2;
        } else
#line 290
        if (oc == 33) {
#line 290
          goto _L___2;
        } else
#line 290
        if (oc == 63) {
          _L___2: /* CIL Label */ 
#line 290
          if (c == -1) {
#line 290
            goto _L___1;
          } else {
            {
#line 290
            tmp___15 = __ctype_b_loc();
            }
#line 290
            if ((int const   )*(*tmp___15 + c) & 8192) {
#line 290
              goto _L___1;
            } else
#line 290
            if (c == 34) {
              _L___1: /* CIL Label */ 
              {
#line 290
              tmp___16 = __ctype_b_loc();
              }
#line 290
              if ((int const   )*(*tmp___16 + voc) & 2048) {
#line 290
                if (oc != 46) {
#line 290
                  goto _L___0;
                } else {
                  {
#line 290
                  tmp___17 = __ctype_b_loc();
                  }
#line 290
                  if ((int const   )*(*tmp___17 + c) & 2048) {
#line 303
                    inWhiteSpace = 0;
                  } else
                  _L___0: /* CIL Label */ 
#line 290
                  if (oc != 46) {
#line 290
                    goto _L;
                  } else {
                    {
#line 290
                    tmp___18 = endingInAbbrev((char const   *)sent, length, lang);
                    }
#line 290
                    if (tmp___18) {
#line 303
                      inWhiteSpace = 0;
                    } else {
                      _L: /* CIL Label */ 
#line 293
                      if (inWhiteSpace) {
#line 293
                        length --;
                      }
#line 294
                      *(sent + length) = (char )'\000';
#line 295
                      if (inSentence) {
                        {
#line 295
                        (*process)((char const   *)sent, length, file, beginLine);
                        }
                      }
#line 296
                      length = (size_t )0;
#line 297
                      inWhiteSpace = 0;
#line 298
                      inSentence = 0;
                    }
                  }
                }
              } else {
#line 290
                goto _L___0;
              }
            } else {
#line 303
              inWhiteSpace = 0;
            }
          }
        } else {
#line 303
          inWhiteSpace = 0;
        }
      }
    } else {
      {
#line 307
      tmp___30 = __ctype_b_loc();
      }
#line 307
      if ((int const   )*(*tmp___30 + oc) & 256) {
#line 309
        inParagraph = 0;
#line 310
        tmp___29 = length;
#line 310
        length ++;
#line 310
        *(sent + tmp___29) = (char )oc;
#line 311
        inWhiteSpace = 0;
#line 312
        beginLine = line;
#line 313
        inSentence = 1;
      } else
#line 315
      if (! inParagraph) {
#line 315
        if (oc == 10) {
#line 315
          if (c == 10) {
            {
#line 317
            (*process)("", (size_t )0, file, line);
#line 318
            inParagraph = 1;
            }
          }
        }
      }
    }
#line 320
    voc = oc;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (! inParagraph) {
    {
#line 322
    (*process)("", (size_t )0, file, line);
    }
  }
  {
#line 323
  regfree(& hashLine);
  }
#line 324
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_de___0[6]  = {      "Dr",      "bzw",      "etc",      "sog", 
        "usw",      (char const   *)0};
#line 62 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_en___0[49]  = 
#line 62
  {      "ch",      "Ch",      "ckts",      "dB", 
        "Dept",      "dept",      "Depts",      "depts", 
        "Dr",      "Drs",      "Eq",      "eq", 
        "etc",      "et al",      "Fig",      "fig", 
        "Figs",      "figs",      "ft",      "0 in", 
        "1 in",      "2 in",      "3 in",      "4 in", 
        "5 in",      "6 in",      "7 in",      "8 in", 
        "9 in",      "Inc",      "Jr",      "jr", 
        "mi",      "Mr",      "Mrs",      "Ms", 
        "No",      "no",      "Nos",      "nos", 
        "Ph",      "Ref",      "ref",      "Refs", 
        "refs",      "St",      "vs",      "yr", 
        (char const   *)0};
#line 115 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_nl___0[20]  = 
#line 115
  {      "as",      "aub",      "bijv",      "bv", 
        "ca",      "dd",      "dr",      "drs", 
        "ed",      "jl",      "maw",      "muv", 
        "oa",      "tav",      "tzt",      "zg", 
        "zgn",      "zoz",      "zsm",      (char const   *)0};
#line 139 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   *abbreviations_none___0[1]  = {      (char const   *)0};
#line 144 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static char const   **abbreviations___0  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/diction-1.11/sentence.c"
static int endingInAbbrev___0(char const   *s , size_t length , char const   *lang ) 
{ 
  char const   **abbrev ;
  size_t aLength ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 148
  abbrev = abbreviations___0;
#line 151
  tmp = __ctype_b_loc();
  }
#line 151
  if (! ((int const   )*(*tmp + (int )*(s + (length - 1UL))) & 1024)) {
#line 151
    return (0);
  }
  {
#line 152
  tmp___0 = endingInPossesiveS(s, length);
  }
#line 152
  if (tmp___0) {
#line 152
    return (0);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((unsigned long )*abbrev != (unsigned long )((char const   *)0))) {
#line 153
      goto while_break;
    }
    {
#line 155
    aLength = strlen(*abbrev);
    }
#line 155
    if (aLength < length) {
      {
#line 157
      tmp___1 = __ctype_b_loc();
      }
#line 157
      if (! ((int const   )*(*tmp___1 + (int )*(s + (length - 2UL))) & 1024)) {
#line 157
        return (1);
      }
      {
#line 158
      tmp___2 = __ctype_b_loc();
      }
#line 158
      if (! ((int const   )*(*tmp___2 + (int )*(s + ((length - aLength) - 1UL))) & 1024)) {
        {
#line 158
        tmp___3 = strncmp((s + length) - aLength, *abbrev, aLength);
        }
#line 158
        if (tmp___3 == 0) {
#line 158
          return (1);
        }
      }
    } else {
#line 162
      if (length == 1UL) {
#line 162
        return (1);
      }
#line 163
      if (aLength == length) {
        {
#line 163
        tmp___4 = strncmp(s, *abbrev, aLength);
        }
#line 163
        if (tmp___4 == 0) {
#line 163
          return (1);
        }
      }
    }
#line 165
    abbrev ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (0);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int doubleWords  =    1;
#line 59 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static char phraseLanguage[32]  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static struct badPhrase *badPhrases  =    (struct badPhrase *)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int badPhraseCapacity  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int badPhraseSize  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int sentences___0  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int hits  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int beginner  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int quiet  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static int suggest  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static void loadPhrases(char const   *file ) 
{ 
  FILE *fp ;
  char ln[1024] ;
  char *tab ;
  char *tab2 ;
  size_t l ;
  int fix ;
  int j ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 76
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 76
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
    {
#line 78
    tmp = __errno_location();
#line 78
    tmp___0 = strerror(*tmp);
#line 78
    tmp___1 = gettext("diction: Opening `%s\' failed (%s).\n");
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            file, tmp___0);
#line 79
    exit(1);
    }
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    tmp___12 = fgets((char */* __restrict  */)(ln), (int )sizeof(ln), (FILE */* __restrict  */)fp);
    }
#line 81
    if (! tmp___12) {
#line 81
      goto while_break;
    }
    {
#line 83
    l = strlen((char const   *)(ln));
    }
#line 84
    if (l) {
#line 84
      if ((int )ln[l - 1UL] == 10) {
#line 84
        l --;
#line 84
        ln[l] = (char )'\000';
      }
    }
#line 85
    if (ln[0]) {
#line 89
      if (badPhraseSize == badPhraseCapacity) {
        {
#line 91
        badPhraseCapacity = 3 * (badPhraseCapacity + 32);
#line 91
        tmp___3 = realloc((void *)badPhrases, (unsigned long )badPhraseCapacity * sizeof(struct badPhrase ));
#line 91
        badPhrases = (struct badPhrase *)tmp___3;
        }
#line 91
        if ((unsigned long )badPhrases == (unsigned long )((struct badPhrase *)0)) {
          {
#line 93
          tmp___2 = gettext("diction: out of memory.\n");
#line 93
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
#line 94
          exit(2);
          }
        }
      }
      {
#line 98
      tab = strchr((char const   *)(ln), '\t');
      }
#line 98
      if (tab) {
#line 100
        *tab = (char )'\000';
#line 101
        tab ++;
      }
#line 103
      if ((unsigned long )tab != (unsigned long )((char *)0)) {
        {
#line 103
        tab2 = strchr((char const   *)tab, '\t');
        }
#line 103
        if (tab2) {
#line 105
          *tab2 = (char )'\000';
#line 106
          tab2 ++;
        } else {
#line 108
          tab2 = (char *)0;
        }
      } else {
#line 108
        tab2 = (char *)0;
      }
      {
#line 109
      tmp___6 = strlen((char const   *)(ln));
#line 109
      tmp___7 = malloc(tmp___6 + 1UL);
#line 109
      tmp___5 = (char *)tmp___7;
#line 109
      (badPhrases + badPhraseSize)->phrase = tmp___5;
      }
#line 109
      if ((unsigned long )tmp___5 == (unsigned long )((char *)0)) {
        {
#line 111
        tmp___4 = gettext("diction: out of memory.\n");
#line 111
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 112
        exit(2);
        }
      }
      {
#line 114
      strcpy((char */* __restrict  */)(badPhrases + badPhraseSize)->phrase, (char const   */* __restrict  */)(ln));
      }
#line 125
      if (tab) {
        {
#line 127
        tmp___10 = strlen((char const   *)tab);
#line 127
        tmp___11 = malloc(tmp___10 + 1UL);
#line 127
        tmp___9 = (char *)tmp___11;
#line 127
        (badPhrases + badPhraseSize)->suggest = tmp___9;
        }
#line 127
        if ((unsigned long )tmp___9 == (unsigned long )((char *)0)) {
          {
#line 129
          tmp___8 = gettext("diction: out of memory.\n");
#line 129
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8);
#line 130
          exit(2);
          }
        }
        {
#line 132
        strcpy((char */* __restrict  */)(badPhrases + badPhraseSize)->suggest, (char const   */* __restrict  */)tab);
        }
      } else {
#line 134
        (badPhrases + badPhraseSize)->suggest = (char *)0;
      }
#line 135
      if (tab2) {
#line 137
        (badPhrases + badPhraseSize)->beginner = 1;
      } else {
#line 141
        (badPhrases + badPhraseSize)->beginner = 0;
      }
#line 143
      badPhraseSize ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  fix = 0;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! (fix < badPhraseSize)) {
#line 147
      goto while_break___0;
    }
#line 149
    if ((badPhrases + fix)->suggest) {
#line 149
      if ((int )*((badPhrases + fix)->suggest) == 61) {
#line 151
        j = 0;
        {
#line 151
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 151
          if (! (j < badPhraseSize)) {
#line 151
            goto while_break___1;
          }
#line 153
          if (j != fix) {
            {
#line 153
            tmp___13 = strcmp((char const   *)(badPhrases + j)->phrase, (char const   *)((badPhrases + fix)->suggest + 1));
            }
#line 153
            if (tmp___13 == 0) {
              {
#line 155
              free((void *)(badPhrases + fix)->suggest);
#line 156
              (badPhrases + fix)->suggest = (badPhrases + j)->suggest;
              }
#line 157
              goto while_break___1;
            }
          }
#line 159
          if (j == badPhraseSize) {
            {
#line 161
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"diction: Warning: Unable to resolve %s.\n",
                    (badPhrases + fix)->suggest);
            }
          }
#line 151
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 147
    fix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static void diction(char const   *sent , size_t length , char const   *file , int line ) 
{ 
  char const   *lastout ;
  char const   *s ;
  char const   *end ;
  char const   *lastWord ;
  int j ;
  struct badPhrase  const  *bp ;
  char const   *badword ;
  char const   *str ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *badword___0 ;
  char const   *str___0 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  char const   *tmp___17 ;

  {
#line 171
  lastout = sent;
#line 172
  s = sent;
#line 173
  end = sent + length;
#line 174
  lastWord = (char const   *)0;
#line 177
  if (length == 0UL) {
#line 177
    return;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )s < (unsigned long )end)) {
#line 178
      goto while_break;
    }
#line 181
    j = 0;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! (j < badPhraseSize)) {
#line 181
        goto while_break___0;
      }
#line 186
      bp = (struct badPhrase  const  *)(badPhrases + j);
#line 187
      badword = (char const   *)bp->phrase;
#line 188
      if ((int const   )*badword == 32) {
#line 190
        if ((unsigned long )s > (unsigned long )sent) {
          {
#line 190
          tmp = __ctype_b_loc();
          }
#line 190
          if ((int const   )*(*tmp + (int )*(s - 1)) & 1024) {
#line 190
            goto __Cont;
          }
        }
#line 191
        badword ++;
      } else
#line 195
      if ((unsigned long )(s - 2) < (unsigned long )sent) {
#line 195
        goto __Cont;
      } else {
        {
#line 195
        tmp___0 = __ctype_b_loc();
        }
#line 195
        if ((int const   )*(*tmp___0 + (int )*(s - 1)) & 1024) {
          {
#line 195
          tmp___1 = __ctype_b_loc();
          }
#line 195
          if (! ((int const   )*(*tmp___1 + (int )*(s - 2)) & 1024)) {
#line 195
            goto __Cont;
          }
        } else {
#line 195
          goto __Cont;
        }
      }
#line 197
      str = s;
      {
#line 198
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 198
        tmp___2 = tolower((int )*str);
        }
#line 198
        if ((int const   )*badword == (int const   )tmp___2) {
#line 198
          goto _L;
        } else
#line 198
        if ((int const   )*badword == (int const   )*str) {
          _L: /* CIL Label */ 
#line 198
          if (*badword) {
#line 198
            if (! *str) {
#line 198
              goto while_break___1;
            }
          } else {
#line 198
            goto while_break___1;
          }
        } else {
#line 198
          goto while_break___1;
        }
#line 198
        badword ++;
#line 198
        str ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 199
      if ((int const   )*badword == 0) {
        {
#line 199
        tmp___5 = __ctype_b_loc();
        }
#line 199
        if ((int const   )*(*tmp___5 + (int )*str) & 1024) {
#line 199
          goto _L___1;
        } else {
#line 199
          goto _L___0;
        }
      } else
      _L___1: /* CIL Label */ 
#line 199
      if ((int const   )*badword == 126) {
        {
#line 199
        tmp___6 = __ctype_b_loc();
        }
#line 199
        if ((int const   )*(*tmp___6 + (int )*str) & 1024) {
          _L___0: /* CIL Label */ 
#line 201
          if (bp->suggest) {
#line 201
            if ((int )*(bp->suggest) != 33) {
#line 201
              if (bp->beginner <= (int const   )beginner) {
#line 203
                hits ++;
#line 204
                if ((unsigned long )lastout == (unsigned long )sent) {
#line 206
                  if (quiet) {
                    {
#line 206
                    printf((char const   */* __restrict  */)"%d: ", line);
                    }
                  } else {
                    {
#line 207
                    printf((char const   */* __restrict  */)"%s:%d: ", file, line);
                    }
                  }
                }
                {
#line 209
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 209
                  if (! ((unsigned long )lastout < (unsigned long )s)) {
#line 209
                    goto while_break___2;
                  }
                  {
#line 209
                  tmp___3 = lastout;
#line 209
                  lastout ++;
#line 209
                  _IO_putc((int )*tmp___3, stdout);
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
                {
#line 210
                _IO_putc('[', stdout);
                }
                {
#line 211
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 211
                  if (! ((unsigned long )lastout < (unsigned long )str)) {
#line 211
                    goto while_break___3;
                  }
                  {
#line 211
                  tmp___4 = lastout;
#line 211
                  lastout ++;
#line 211
                  _IO_putc((int )*tmp___4, stdout);
                  }
                }
                while_break___3: /* CIL Label */ ;
                }
#line 212
                if (suggest) {
#line 212
                  if (bp->suggest) {
                    {
#line 214
                    _IO_putc(' ', stdout);
#line 215
                    _IO_putc('-', stdout);
#line 216
                    _IO_putc('>', stdout);
#line 217
                    _IO_putc(' ', stdout);
#line 218
                    fputs((char const   */* __restrict  */)bp->suggest, (FILE */* __restrict  */)stdout);
                    }
                  }
                }
                {
#line 220
                _IO_putc(']', stdout);
                }
              }
            }
          }
#line 222
          s = str - 1;
#line 223
          goto while_break___0;
        }
      }
      __Cont: /* CIL Label */ 
#line 181
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 228
    if (doubleWords) {
#line 232
      if ((unsigned long )s > (unsigned long )sent) {
        {
#line 232
        tmp___16 = __ctype_b_loc();
        }
#line 232
        if (! ((int const   )*(*tmp___16 + (int )*(s - 1)) & 1024)) {
#line 235
          badword___0 = s - 1;
          {
#line 236
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 236
            if ((unsigned long )badword___0 > (unsigned long )sent) {
              {
#line 236
              tmp___7 = __ctype_b_loc();
              }
#line 236
              if ((int const   )*(*tmp___7 + (int )*badword___0) & 1024) {
#line 236
                goto while_break___4;
              }
            } else {
#line 236
              goto while_break___4;
            }
#line 236
            badword___0 --;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 237
          if ((unsigned long )badword___0 > (unsigned long )sent) {
            {
#line 240
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 240
              if ((unsigned long )badword___0 > (unsigned long )sent) {
                {
#line 240
                tmp___8 = __ctype_b_loc();
                }
#line 240
                if (! ((int const   )*(*tmp___8 + (int )*badword___0) & 1024)) {
#line 240
                  goto while_break___5;
                }
              } else {
#line 240
                goto while_break___5;
              }
#line 240
              badword___0 --;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 241
            tmp___9 = __ctype_b_loc();
            }
#line 241
            if (! ((int const   )*(*tmp___9 + (int )*badword___0) & 1024)) {
#line 241
              badword___0 ++;
            }
#line 242
            str___0 = s;
            {
#line 243
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 243
              if ((int const   )*badword___0 == (int const   )*str___0) {
#line 243
                if ((unsigned long )badword___0 < (unsigned long )s) {
                  {
#line 243
                  tmp___10 = __ctype_b_loc();
                  }
#line 243
                  if (! ((int const   )*(*tmp___10 + (int )*str___0) & 1024)) {
#line 243
                    goto while_break___6;
                  }
                } else {
#line 243
                  goto while_break___6;
                }
              } else {
#line 243
                goto while_break___6;
              }
#line 243
              badword___0 ++;
#line 243
              str___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 244
            if ((unsigned long )badword___0 < (unsigned long )s) {
              {
#line 244
              tmp___14 = __ctype_b_loc();
              }
#line 244
              if (! ((int const   )*(*tmp___14 + (int )*badword___0) & 1024)) {
                {
#line 244
                tmp___15 = __ctype_b_loc();
                }
#line 244
                if (! ((int const   )*(*tmp___15 + (int )*str___0) & 1024)) {
#line 246
                  if ((unsigned long )lastout == (unsigned long )sent) {
#line 248
                    if (quiet) {
                      {
#line 248
                      printf((char const   */* __restrict  */)"%d: ", line);
                      }
                    } else {
                      {
#line 249
                      printf((char const   */* __restrict  */)"%s:%d: ", file, line);
                      }
                    }
                  }
                  {
#line 251
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 251
                    if (! ((unsigned long )lastout < (unsigned long )s)) {
#line 251
                      goto while_break___7;
                    }
                    {
#line 251
                    tmp___11 = lastout;
#line 251
                    lastout ++;
#line 251
                    _IO_putc((int )*tmp___11, stdout);
                    }
                  }
                  while_break___7: /* CIL Label */ ;
                  }
                  {
#line 252
                  _IO_putc('[', stdout);
                  }
                  {
#line 253
                  while (1) {
                    while_continue___8: /* CIL Label */ ;
#line 253
                    if (! ((unsigned long )lastout < (unsigned long )str___0)) {
#line 253
                      goto while_break___8;
                    }
                    {
#line 253
                    tmp___12 = lastout;
#line 253
                    lastout ++;
#line 253
                    _IO_putc((int )*tmp___12, stdout);
                    }
                  }
                  while_break___8: /* CIL Label */ ;
                  }
#line 254
                  if (suggest) {
                    {
#line 256
                    _IO_putc(' ', stdout);
#line 257
                    _IO_putc('-', stdout);
#line 258
                    _IO_putc('>', stdout);
#line 259
                    _IO_putc(' ', stdout);
#line 260
                    tmp___13 = gettext("Double word.");
#line 260
                    fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)stdout);
                    }
                  }
                  {
#line 262
                  _IO_putc(']', stdout);
#line 263
                  lastWord = s;
#line 264
                  s = str___0 - 1;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 270
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  sentences___0 ++;
#line 273
  if ((unsigned long )lastout != (unsigned long )sent) {
    {
#line 275
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 275
      if (! ((unsigned long )lastout < (unsigned long )end)) {
#line 275
        goto while_break___9;
      }
      {
#line 275
      tmp___17 = lastout;
#line 275
      lastout ++;
#line 275
      _IO_putc((int )*tmp___17, stdout);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 276
    _IO_putc('\n', stdout);
#line 277
    _IO_putc('\n', stdout);
    }
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static void print_usage___0(FILE *handle ) 
{ 
  char *tmp ;

  {
  {
#line 283
  tmp = gettext("Usage: diction [-b] [-d] [-f file [-n|-L language]] [-q] [file ...]\n       diction [--beginner] [--ignore-double-words]\n               [--file file [--no-default-file|--language]] [--quiet] [file ...]\n       diction --version\n");
#line 283
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)handle);
  }
#line 288
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/diction-1.11/diction.c"
static struct option lopts___0[10]  = 
#line 296
  {      {"beginner", 0, (int *)0, 'b'}, 
        {"ignore-double-words", 0, (int *)0, 'd'}, 
        {"suggest", 0, (int *)0, 's'}, 
        {"file", 1, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"language", 1, (int *)0, 'L'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"no-default-file", 0, (int *)0, 'n'}, 
        {(char const   *)0, 0, (int *)0, '\000'}};
