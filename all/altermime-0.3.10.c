/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 26 "/home/june/collector/temp/altermime-0.3.10/logger.c"
struct LOGGER_globals {
   int wrap ;
   int wraplength ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_30 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_30 regmatch_t;
#line 27 "/home/june/collector/temp/altermime-0.3.10/ffget.h"
struct _FFGET_FILE {
   FILE *f ;
   char buffer[8196] ;
   char *startpoint ;
   char *endpoint ;
   char *buffer_end ;
   size_t last_block_read_from ;
   int FILEEND ;
   int FFEOF ;
   char c ;
   unsigned long bytes ;
   unsigned long linecount ;
   int ungetcset ;
   int trueblank ;
   char lastchar ;
   int linebreak ;
   char lastbreak[10] ;
};
#line 49 "/home/june/collector/temp/altermime-0.3.10/ffget.h"
typedef struct _FFGET_FILE FFGET_FILE;
#line 14 "/home/june/collector/temp/altermime-0.3.10/pldstr.h"
struct PLD_strreplace {
   char *source ;
   char *searchfor ;
   char *replacewith ;
   char *preexist ;
   char *postexist ;
   int replacenumber ;
   int insensitive ;
};
#line 8 "/home/june/collector/temp/altermime-0.3.10/strstack.h"
struct SS_node {
   char *data ;
   size_t data_length ;
   struct SS_node *next ;
};
#line 14 "/home/june/collector/temp/altermime-0.3.10/strstack.h"
struct SS_object {
   int debug ;
   int verbose ;
   int count ;
   int detect_limit ;
   struct SS_node *stringstack ;
   char datastacksafe[1024] ;
};
#line 94 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.h"
struct MIMEH_header_info {
   char scratch[1024] ;
   int content_type ;
   char content_type_string[129] ;
   char content_description_string[129] ;
   char boundary[1024] ;
   int boundary_located ;
   char subject[129] ;
   char filename[129] ;
   char name[1024] ;
   char from[1024] ;
   char date[1024] ;
   char to[1024] ;
   char messageid[1024] ;
   char received[1024] ;
   struct SS_object ss_filenames ;
   struct SS_object ss_names ;
   int content_transfer_encoding ;
   char content_transfer_encoding_string[257] ;
   int content_disposition ;
   char content_disposition_string[257] ;
   int charset ;
   int format ;
   int file_has_uuencode ;
   char uudec_name[129] ;
   int current_recursion_level ;
   int defects[100] ;
   int header_defect_count ;
   int x_mac ;
   int sanity ;
   int is_mime ;
   char delimeter[3] ;
   int crlf_count ;
   int crcr_count ;
   int lf_count ;
};
#line 26 "/home/june/collector/temp/altermime-0.3.10/mime_alter.h"
struct AM_disclaimer_details {
   int content_type ;
   int content_encoding ;
   int boundary_found ;
   char boundary[1024] ;
   int isb64 ;
   int ishtml ;
   int isfile ;
   int text_inserted ;
   int html_inserted ;
   int b64_inserted ;
   char *disclaimer_text_plain ;
   char *disclaimer_text_HTML ;
   char *disclaimer_text_b64 ;
   char textpos[1024] ;
   char htmlpos[1024] ;
};
#line 60 "/home/june/collector/temp/altermime-0.3.10/mime_alter.h"
struct AM_globals {
   int debug ;
   int verbose ;
   int paranoid ;
   int HTML_too ;
   int force_for_bad_html ;
   int force_into_b64 ;
   int multipart_insert ;
   int nullify_all ;
   int alter_signed ;
   int header_long_search ;
   char ldelimeter[3] ;
   char *disclaimer_plain ;
   int disclaimer_plain_type ;
   char *disclaimer_HTML ;
   int disclaimer_HTML_type ;
   char *disclaimer_b64 ;
   int disclaimer_b64_type ;
   char *headerbuffer[100] ;
   int headerbuffermax ;
};
#line 58 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
struct MIMEH_globals {
   int doubleCR ;
   int doubleCR_save ;
   char doubleCRname[1024] ;
   char appledouble_filename[1024] ;
   char subject[1024] ;
   char *headerline ;
   char *headerline_original ;
   int save_headers ;
   int save_headers_original ;
   int test_mailbox ;
   int debug ;
   int webform ;
   int doubleCR_count ;
   int header_fix ;
   int verbose ;
   int verbose_contenttype ;
   int header_longsearch ;
   int longsearch_limit ;
   char output_dir[1024] ;
   FILE *header_file ;
   FILE *original_header_file ;
   int original_header_save_to_file ;
};
#line 38 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
struct FNFILTER_globals {
   int debug ;
   int verbose ;
   int paranoid ;
   int x_mac ;
};
#line 92 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
struct ALTERMIMEAPP_globals {
   char *input_file ;
   char *disclaimer_file ;
   char *disclaimer_html_file ;
   char *disclaimer_b64_file ;
   char *pretext_file ;
   char *pretext_html_file ;
   int pretext_insert ;
   char *remove_filename ;
   char *replace ;
   char *with ;
   char *xheader ;
   char *alter_header ;
   char *alter_with ;
   int alter_mode ;
   int verbose ;
};
#line 20 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
struct BS_node;
#line 20 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
struct BS_globals {
   int debug ;
   int verbose ;
   int syslogging ;
   int errlogging ;
   int count ;
   int detect_limit ;
   int hold_limit ;
   int smallest_length ;
   int have_empty_boundary ;
   struct BS_node *boundarystack ;
   char boundarystacksafe[1024] ;
};
#line 34 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
struct BS_node {
   char *boundary ;
   int boundary_length ;
   int boundary_nhl ;
   struct BS_node *next ;
};
#line 8 "/home/june/collector/temp/altermime-0.3.10/pldstr.h"
struct PLD_strtok {
   char *start ;
   char delimeter ;
};
#line 75 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
struct MDECODE_globals {
   int debug ;
   int verbose ;
   int decode_qp ;
   int decode_b64 ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 19 "/home/june/collector/temp/altermime-0.3.10/logger.h"
int LOGGER_log(char *format  , ...) ;
#line 20
int LOGGER_set_output_mode(int modechoice ) ;
#line 21
int LOGGER_set_output_file(FILE *f ) ;
#line 22
int LOGGER_set_syslog_mode(int syslogmode ) ;
#line 23
int LOGGER_set_logfile(char *lfname ) ;
#line 24
int LOGGER_set_wraplength(int length ) ;
#line 25
int LOGGER_set_wrap(int level ) ;
#line 27
int LOGGER_close_logfile(void) ;
#line 28
FILE *LOGGER_get_file(void) ;
#line 18 "/home/june/collector/temp/altermime-0.3.10/logger.c"
static int _LOGGER_mode  =    4;
#line 19 "/home/june/collector/temp/altermime-0.3.10/logger.c"
static int _LOGGER_syslog_mode  =    (2 << 3) | 6;
#line 24 "/home/june/collector/temp/altermime-0.3.10/logger.c"
static FILE *_LOGGER_outf  ;
#line 34 "/home/june/collector/temp/altermime-0.3.10/logger.c"
static struct LOGGER_globals LOGGER_glb  =    {0, 0};
#line 44 "/home/june/collector/temp/altermime-0.3.10/logger.c"
FILE *LOGGER_get_file(void) 
{ 


  {
#line 46
  return (_LOGGER_outf);
}
}
#line 58 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_set_output_mode(int modechoice ) 
{ 


  {
#line 60
  _LOGGER_mode = modechoice;
#line 61
  return (0);
}
}
#line 72 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_set_output_file(FILE *f ) 
{ 


  {
#line 74
  _LOGGER_outf = f;
#line 75
  return (0);
}
}
#line 86 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_set_syslog_mode(int syslogmode ) 
{ 


  {
#line 88
  _LOGGER_syslog_mode = syslogmode;
#line 89
  return (0);
}
}
#line 103 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_set_logfile(char *lfname ) 
{ 
  int result ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 105
  result = 0;
#line 107
  _LOGGER_outf = fopen((char const   */* __restrict  */)lfname, (char const   */* __restrict  */)"a");
  }
#line 108
  if (! _LOGGER_outf) {
    {
#line 111
    tmp = __errno_location();
#line 111
    tmp___0 = strerror(*tmp);
#line 111
    syslog(1, "LOGGER_set_logfile: ERROR - Cannot open logfile \'%s\' (%s)", lfname,
           tmp___0);
#line 115
    result = -1;
    }
  }
#line 118
  return (result);
}
}
#line 130 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_set_wraplength(int length ) 
{ 


  {
#line 132
  if (length >= 0) {
#line 134
    LOGGER_glb.wraplength = length;
  }
#line 137
  return (LOGGER_glb.wraplength);
}
}
#line 147 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_set_wrap(int level ) 
{ 


  {
#line 149
  if (level >= 0) {
#line 151
    LOGGER_glb.wrap = level;
  }
#line 154
  return (LOGGER_glb.wrap);
}
}
#line 166 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_close_logfile(void) 
{ 
  int result ;

  {
#line 168
  result = 0;
#line 170
  if (_LOGGER_outf) {
    {
#line 170
    fclose(_LOGGER_outf);
    }
  }
#line 172
  return (result);
}
}
#line 187 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_clean_output(char *string , char **buffer ) 
{ 
  char *newstr ;
  char *p ;
  char *q ;
  char *next_space ;
  int pc ;
  int slen ;
  size_t tmp ;
  int line_size ;
  int maxsize ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 194
  tmp = strlen((char const   *)string);
#line 194
  slen = (int )tmp;
#line 196
  maxsize = slen * 2;
#line 199
  tmp___0 = malloc((size_t )(slen * 2 + 1));
#line 199
  newstr = (char *)tmp___0;
  }
#line 200
  if ((unsigned long )newstr == (unsigned long )((void *)0)) {
#line 203
    return (-1);
  }
#line 206
  p = newstr;
#line 207
  q = string;
#line 208
  pc = 0;
#line 209
  line_size = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    tmp___2 = slen;
#line 211
    slen --;
#line 211
    if (! tmp___2) {
#line 211
      goto while_break;
    }
#line 218
    if (LOGGER_glb.wrap > 0) {
      {
#line 220
      tmp___1 = __ctype_b_loc();
      }
#line 220
      if ((int const   )*(*tmp___1 + (int )*q) & 8192) {
        {
#line 222
        next_space = strpbrk((char const   *)(q + 1), "\t\r\n\v ");
        }
#line 223
        if ((unsigned long )next_space != (unsigned long )((void *)0)) {
#line 225
          if ((long )line_size + (next_space - q) >= (long )LOGGER_glb.wraplength) {
#line 227
            *p = (char )'\n';
#line 228
            p ++;
#line 229
            pc ++;
#line 230
            line_size = 0;
          }
        }
      }
#line 235
      if (line_size >= LOGGER_glb.wraplength) {
#line 237
        *p = (char )'\n';
#line 238
        p ++;
#line 239
        pc ++;
#line 240
        line_size = 0;
      }
    }
#line 247
    if ((int )*q == 37) {
#line 250
      *p = (char )'%';
#line 251
      p ++;
#line 252
      pc ++;
    }
#line 257
    *p = *q;
#line 260
    q ++;
#line 261
    p ++;
#line 262
    pc ++;
#line 263
    line_size ++;
#line 265
    if (pc > maxsize - 1) {
#line 266
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  *p = (char )'\000';
#line 273
  if (newstr) {
#line 273
    *buffer = newstr;
  }
#line 275
  return (0);
}
}
#line 286 "/home/june/collector/temp/altermime-0.3.10/logger.c"
int LOGGER_log(char *format  , ...) 
{ 
  va_list ptr ;
  char tmpoutput[10240] ;
  char linebreak[2] ;
  char nolinebreak[1] ;
  char *lineend ;
  char *output ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 290
  linebreak[0] = (char )'\n';
#line 290
  linebreak[1] = (char )'\000';
#line 291
  nolinebreak[0] = (char )'\000';
#line 297
  __builtin_va_start(ptr, format);
#line 303
  vsnprintf((char */* __restrict  */)(tmpoutput), sizeof(tmpoutput), (char const   */* __restrict  */)format,
            ptr);
#line 306
  LOGGER_clean_output(tmpoutput, & output);
#line 308
  tmp = strlen((char const   *)output);
  }
#line 308
  if ((int )*(output + (tmp - 1UL)) == 10) {
#line 309
    lineend = nolinebreak;
  } else {
#line 312
    lineend = linebreak;
  }
  {
#line 315
  tmp___0 = strlen((char const   *)output);
  }
#line 315
  if ((int )*(output + (tmp___0 - 1UL)) == 10) {
#line 315
    lineend = nolinebreak;
  } else {
#line 315
    lineend = linebreak;
  }
  {
#line 319
  if (_LOGGER_mode == 1) {
#line 319
    goto case_1;
  }
#line 322
  if (_LOGGER_mode == 4) {
#line 322
    goto case_4;
  }
#line 325
  if (_LOGGER_mode == 2) {
#line 325
    goto case_2;
  }
#line 329
  if (_LOGGER_mode == 3) {
#line 329
    goto case_3;
  }
#line 333
  if (_LOGGER_mode == 5) {
#line 333
    goto case_5;
  }
#line 335
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 320
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s",
          output, lineend);
  }
#line 321
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 323
  syslog(_LOGGER_syslog_mode, "%s", output);
  }
#line 324
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 326
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s%s",
          output, lineend);
#line 327
  fflush(stdout);
  }
#line 328
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 330
  fprintf((FILE */* __restrict  */)_LOGGER_outf, (char const   */* __restrict  */)"%s%s",
          output, lineend);
#line 331
  fflush(_LOGGER_outf);
  }
#line 332
  goto switch_break;
  case_5: /* CIL Label */ 
#line 334
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 336
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"LOGGER-Default: %s%s",
          output, lineend);
  }
  switch_break: /* CIL Label */ ;
  }
#line 340
  if (output) {
    {
#line 340
    free((void *)output);
    }
  }
#line 342
  return (0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 60 "/home/june/collector/temp/altermime-0.3.10/ffget.h"
int FFGET_setstream(FFGET_FILE *f , FILE *fi ) ;
#line 66
int FFGET_closestream(FFGET_FILE *f ) ;
#line 69
char *FFGET_fgets(char *linein , int maxsize , FFGET_FILE *f ) ;
#line 71
int FFGET_feof(FFGET_FILE *f ) ;
#line 28 "/home/june/collector/temp/altermime-0.3.10/pldstr.h"
char *PLD_strstr(char *haystack , char *needle , int insensitive ) ;
#line 34
int PLD_strlower(char *convertme ) ;
#line 36
char *PLD_strreplace_general(struct PLD_strreplace *replace_details ) ;
#line 37
char *PLD_strreplace(char **source , char *searchfor , char *replacewith , int replacenumber ) ;
#line 38
char *PLD_dprintf(char const   *format  , ...) ;
#line 24 "/home/june/collector/temp/altermime-0.3.10/strstack.h"
int SS_init(struct SS_object *ss ) ;
#line 2 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.h"
int BS_init(void) ;
#line 6
int BS_set_hold_limit(int limit ) ;
#line 8
int BS_clear(void) ;
#line 9
int BS_push(char *boundary ) ;
#line 12
int BS_cmp(char *boundary , int len ) ;
#line 170 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.h"
int MIMEH_set_debug(int level ) ;
#line 180
int MIMEH_set_doubleCR_save(int level ) ;
#line 184
int MIMEH_set_headers_nosave(void) ;
#line 186
char *MIMEH_get_headers_ptr(void) ;
#line 188
int MIMEH_set_headers_save_original(int level ) ;
#line 189
char *MIMEH_get_headers_original_ptr(void) ;
#line 191
int MIMEH_set_headers_original_save_to_file(FILE *f ) ;
#line 196
int MIMEH_set_header_longsearch(int level ) ;
#line 200
int MIMEH_headers_get(struct MIMEH_header_info *hinfo , FFGET_FILE *f ) ;
#line 201
int MIMEH_headers_process(struct MIMEH_header_info *hinfo , char *headers ) ;
#line 202
int MIMEH_headers_cleanup(void) ;
#line 203
int MIMEH_parse_headers(FFGET_FILE *f , struct MIMEH_header_info *hinfo ) ;
#line 104 "/home/june/collector/temp/altermime-0.3.10/mime_alter.h"
unsigned int altermime_status_flags  ;
#line 107
int AM_version(void) ;
#line 109
int AM_init(void) ;
#line 110
int AM_done(void) ;
#line 111
int AM_set_debug(int level ) ;
#line 113
char *AM_set_disclaimer_b64(char *filename , int disclaimer_type ) ;
#line 114
char *AM_set_disclaimer_plain(char *filename , int disclaimer_type ) ;
#line 115
char *AM_set_disclaimer_HTML(char *filename , int disclaimer_type ) ;
#line 123
int AM_add_disclaimer(char *mpackname ) ;
#line 124
int AM_nullify_attachment(char *mpackname , char *attachmentname ) ;
#line 125
int AM_set_verbose(int level ) ;
#line 126
int AM_set_HTMLtoo(int level ) ;
#line 127
int AM_set_force_for_bad_html(int level ) ;
#line 128
int AM_set_force_into_b64(int level ) ;
#line 129
int AM_set_multipart_insert(int level ) ;
#line 130
int AM_set_nullifyall(int level ) ;
#line 131
int AM_set_altersigned(int level ) ;
#line 132
int AM_set_header_long_search(int level ) ;
#line 133
int AM_base64_encode(char *enc_fname , char *out_fname ) ;
#line 134
int AM_attachment_replace(char *mpackname , char *attachmentname , char *new_attachment_name ) ;
#line 135
int AM_insert_Xheader(char *fname , char *xheader ) ;
#line 136
int AM_alter_header(char *filename , char *header , char *change , int change_mode ) ;
#line 5 "/home/june/collector/temp/altermime-0.3.10/qpe.h"
int qp_encode(char *out , size_t out_size , char *in , size_t in_size ) ;
#line 36 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
unsigned char AM_encode64[64]  = 
#line 36 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
  {      (unsigned char)65,      (unsigned char)66,      (unsigned char)67,      (unsigned char)68, 
        (unsigned char)69,      (unsigned char)70,      (unsigned char)71,      (unsigned char)72, 
        (unsigned char)73,      (unsigned char)74,      (unsigned char)75,      (unsigned char)76, 
        (unsigned char)77,      (unsigned char)78,      (unsigned char)79,      (unsigned char)80, 
        (unsigned char)81,      (unsigned char)82,      (unsigned char)83,      (unsigned char)84, 
        (unsigned char)85,      (unsigned char)86,      (unsigned char)87,      (unsigned char)88, 
        (unsigned char)89,      (unsigned char)90,      (unsigned char)97,      (unsigned char)98, 
        (unsigned char)99,      (unsigned char)100,      (unsigned char)101,      (unsigned char)102, 
        (unsigned char)103,      (unsigned char)104,      (unsigned char)105,      (unsigned char)106, 
        (unsigned char)107,      (unsigned char)108,      (unsigned char)109,      (unsigned char)110, 
        (unsigned char)111,      (unsigned char)112,      (unsigned char)113,      (unsigned char)114, 
        (unsigned char)115,      (unsigned char)116,      (unsigned char)117,      (unsigned char)118, 
        (unsigned char)119,      (unsigned char)120,      (unsigned char)121,      (unsigned char)122, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)43,      (unsigned char)47};
#line 44 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
static unsigned char b64[256]  = 
#line 44
  {      (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)62, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)63, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)8,      (unsigned char)9,      (unsigned char)10, 
        (unsigned char)11,      (unsigned char)12,      (unsigned char)13,      (unsigned char)14, 
        (unsigned char)15,      (unsigned char)16,      (unsigned char)17,      (unsigned char)18, 
        (unsigned char)19,      (unsigned char)20,      (unsigned char)21,      (unsigned char)22, 
        (unsigned char)23,      (unsigned char)24,      (unsigned char)25,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)26,      (unsigned char)27,      (unsigned char)28, 
        (unsigned char)29,      (unsigned char)30,      (unsigned char)31,      (unsigned char)32, 
        (unsigned char)33,      (unsigned char)34,      (unsigned char)35,      (unsigned char)36, 
        (unsigned char)37,      (unsigned char)38,      (unsigned char)39,      (unsigned char)40, 
        (unsigned char)41,      (unsigned char)42,      (unsigned char)43,      (unsigned char)44, 
        (unsigned char)45,      (unsigned char)46,      (unsigned char)47,      (unsigned char)48, 
        (unsigned char)49,      (unsigned char)50,      (unsigned char)51,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128};
#line 64 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
static struct AM_globals glb  ;
#line 84 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_version(void) 
{ 


  {
  {
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"alterMIME: %s",
          "200811161138");
  }
#line 88
  return (0);
}
}
#line 107 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_init(void) 
{ 


  {
  {
#line 109
  glb.debug = 0;
#line 110
  glb.verbose = 0;
#line 111
  glb.paranoid = 1;
#line 112
  glb.HTML_too = 1;
#line 113
  glb.multipart_insert = 0;
#line 114
  glb.nullify_all = 0;
#line 115
  glb.alter_signed = 0;
#line 116
  glb.header_long_search = 1;
#line 117
  glb.force_into_b64 = 0;
#line 118
  glb.force_for_bad_html = 0;
#line 120
  snprintf((char */* __restrict  */)(glb.ldelimeter), sizeof(glb.ldelimeter), (char const   */* __restrict  */)"\r\n");
#line 122
  glb.disclaimer_plain = (char *)((void *)0);
#line 123
  glb.disclaimer_plain_type = 0;
#line 125
  glb.disclaimer_HTML = (char *)((void *)0);
#line 126
  glb.disclaimer_HTML_type = 0;
#line 128
  glb.disclaimer_b64 = (char *)((void *)0);
#line 129
  glb.disclaimer_b64_type = 0;
#line 139
  glb.headerbuffermax = 0;
  }
#line 141
  return (0);
}
}
#line 161 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_done(void) 
{ 


  {
#line 163
  if ((unsigned long )glb.disclaimer_plain != (unsigned long )((void *)0)) {
    {
#line 163
    free((void *)glb.disclaimer_plain);
    }
  }
#line 164
  if ((unsigned long )glb.disclaimer_HTML != (unsigned long )((void *)0)) {
    {
#line 164
    free((void *)glb.disclaimer_HTML);
    }
  }
#line 165
  if ((unsigned long )glb.disclaimer_b64 != (unsigned long )((void *)0)) {
    {
#line 165
    free((void *)glb.disclaimer_b64);
    }
  }
#line 167
  return (0);
}
}
#line 186 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_force_for_bad_html(int level ) 
{ 


  {
#line 188
  glb.force_for_bad_html = level;
#line 189
  return (glb.force_for_bad_html);
}
}
#line 214 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_force_into_b64(int level ) 
{ 


  {
#line 216
  glb.force_into_b64 = level;
#line 217
  return (glb.force_into_b64);
}
}
#line 260 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_debug(int level ) 
{ 


  {
  {
#line 262
  glb.debug = level;
#line 263
  AM_set_verbose(level);
#line 264
  MIMEH_set_debug(level);
  }
#line 266
  return (level);
}
}
#line 286 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_hbuffer_reset(void) 
{ 
  int i ;

  {
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < glb.headerbuffermax)) {
#line 290
      goto while_break;
    }
#line 292
    if (glb.headerbuffer[i]) {
      {
#line 292
      free((void *)glb.headerbuffer[i]);
      }
    }
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  glb.headerbuffermax = 0;
#line 295
  return (0);
}
}
#line 315 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_hbuffer_add(char *headerline , FILE *f ) 
{ 
  int i ;
  void *tmp ;

  {
#line 319
  if (glb.headerbuffermax == 100) {
#line 321
    if (glb.headerbuffer[0]) {
      {
#line 323
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", glb.headerbuffer[0]);
#line 324
      free((void *)glb.headerbuffer[0]);
      }
    }
#line 326
    i = 0;
    {
#line 326
    while (1) {
      while_continue: /* CIL Label */ ;
#line 326
      if (! (i < 99)) {
#line 326
        goto while_break;
      }
#line 328
      glb.headerbuffer[i] = glb.headerbuffer[i + 1];
#line 326
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 330
    glb.headerbuffermax = 99;
  }
  {
#line 333
  tmp = malloc(sizeof(char ) * 1025UL);
#line 333
  glb.headerbuffer[glb.headerbuffermax] = (char *)tmp;
  }
#line 335
  if (! glb.headerbuffer[glb.headerbuffermax]) {
    {
#line 337
    LOGGER_log((char *)"alterMIME: AM_hbuffer_add: Error: cannot allocate %d bytes for new header",
               1025);
    }
#line 338
    return ((char *)((void *)0));
  }
  {
#line 341
  strncpy((char */* __restrict  */)glb.headerbuffer[glb.headerbuffermax], (char const   */* __restrict  */)headerline,
          (size_t )1024);
#line 342
  (glb.headerbuffermax) ++;
  }
#line 344
  return (glb.headerbuffer[glb.headerbuffermax - 1]);
}
}
#line 355 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_hbuffer_getmax(void) 
{ 


  {
#line 357
  return (glb.headerbuffermax);
}
}
#line 370 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_hbuffer_getline(int index___0 ) 
{ 


  {
#line 372
  if (index___0 >= 0) {
#line 372
    if (index___0 < glb.headerbuffermax) {
#line 373
      return (glb.headerbuffer[index___0]);
    } else {
#line 374
      return ((char *)((void *)0));
    }
  } else {
#line 374
    return ((char *)((void *)0));
  }
}
}
#line 386 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_paranoid(int level ) 
{ 


  {
#line 388
  glb.paranoid = level;
#line 389
  return (glb.paranoid);
}
}
#line 410 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_header_long_search(int level ) 
{ 


  {
#line 412
  glb.header_long_search = level;
#line 413
  return (glb.header_long_search);
}
}
#line 423 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_verbose(int level ) 
{ 


  {
#line 425
  glb.verbose = level;
#line 426
  return (glb.verbose);
}
}
#line 439 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_HTMLtoo(int level ) 
{ 


  {
#line 441
  glb.HTML_too = level;
#line 442
  return (glb.HTML_too);
}
}
#line 454 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_multipart_insert(int level ) 
{ 


  {
#line 456
  glb.multipart_insert = level;
#line 457
  return (glb.multipart_insert);
}
}
#line 482 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_set_disclaimer_plain(char *filename , int disclaimer_type ) 
{ 


  {
  {
#line 484
  glb.disclaimer_plain = strdup((char const   *)filename);
#line 485
  glb.disclaimer_plain_type = disclaimer_type;
  }
#line 487
  return (glb.disclaimer_plain);
}
}
#line 508 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_set_disclaimer_HTML(char *filename , int disclaimer_type ) 
{ 


  {
  {
#line 510
  glb.disclaimer_HTML = strdup((char const   *)filename);
#line 511
  glb.disclaimer_HTML_type = disclaimer_type;
  }
#line 513
  return (glb.disclaimer_HTML);
}
}
#line 535 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_set_disclaimer_b64(char *filename , int disclaimer_type ) 
{ 


  {
  {
#line 537
  glb.disclaimer_b64 = strdup((char const   *)filename);
#line 538
  glb.disclaimer_b64_type = disclaimer_type;
  }
#line 540
  return (glb.disclaimer_b64);
}
}
#line 606 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_nullifyall(int level ) 
{ 


  {
#line 608
  glb.nullify_all = level;
#line 609
  return (glb.nullify_all);
}
}
#line 622 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_set_altersigned(int level ) 
{ 


  {
#line 624
  glb.alter_signed = level;
#line 625
  return (glb.alter_signed);
}
}
#line 649 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_ntorn(char *in , FILE *out ) 
{ 
  char *p ;
  char lastchar ;

  {
#line 651
  p = in;
#line 652
  lastchar = (char )' ';
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if (! *p) {
#line 654
      goto while_break;
    }
#line 656
    if ((int )*p == 10) {
#line 656
      if ((int )lastchar != 13) {
        {
#line 656
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\r");
        }
      }
    }
    {
#line 657
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c", (int )*p);
#line 658
    lastchar = *p;
#line 659
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return (0);
}
}
#line 687 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_adapt_linebreak(char *in , char *lb ) 
{ 
  char safe[3] ;
  char *newblock ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 689
  safe[0] = (char )'\r';
#line 689
  safe[1] = (char )'\n';
#line 689
  safe[2] = (char )'\000';
#line 693
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 693
    return ((char *)((void *)0));
  }
#line 696
  if ((unsigned long )lb == (unsigned long )((void *)0)) {
#line 696
    lb = safe;
  } else
#line 696
  if ((int )*(lb + 0) == 0) {
#line 696
    lb = safe;
  }
#line 698
  if (glb.debug > 0) {
    {
#line 698
    LOGGER_log((char *)"%s:%d:AM_adapt_linebreak:DEBUG: Linebreak=%x:%x", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               698, (int )*(lb + 0), (int )*(lb + 1));
    }
  }
#line 700
  if ((int )*(lb + 0) == 13) {
    {
#line 701
    tmp = strchr((char const   *)in, '\r');
    }
#line 701
    if (tmp) {
#line 702
      if (glb.debug > 0) {
        {
#line 702
        LOGGER_log((char *)"%s:%d:AM_adapt_linebreak:DEBUG: email and disclaimer are CRLF, no change",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 702);
        }
      }
#line 703
      return (in);
    } else {
#line 705
      if (glb.debug > 0) {
        {
#line 705
        LOGGER_log((char *)"%s:%d:AM_adapt_linebreak:DEBUG: chaging LF only to CRLF",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 705);
        }
      }
      {
#line 706
      newblock = strdup((char const   *)in);
#line 707
      newblock = PLD_strreplace(& newblock, (char *)"\n", (char *)"\r\n", 0);
      }
    }
  } else
#line 709
  if ((int )*(lb + 0) == 10) {
    {
#line 710
    tmp___0 = strchr((char const   *)in, '\r');
    }
#line 710
    if (tmp___0) {
#line 714
      if (glb.debug > 0) {
        {
#line 714
        LOGGER_log((char *)"%s:%d:AM_adapt_linebreak:DEBUG: changing CRLF to LF",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 714);
        }
      }
      {
#line 715
      newblock = strdup((char const   *)in);
#line 716
      newblock = PLD_strreplace(& newblock, (char *)"\r\n", (char *)"\n", 0);
      }
    } else {
#line 711
      if (glb.debug > 0) {
        {
#line 711
        LOGGER_log((char *)"%s:%d:AM_adapt_linebreak:DEBUG: email and disclaimer are LF only, no change",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 711);
        }
      }
#line 712
      return (in);
    }
  }
#line 720
  return (newblock);
}
}
#line 732 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_encodef(FILE *fin , FILE *fout ) 
{ 
  unsigned char inbuf[3] ;
  unsigned char outbuf[4] ;
  int cc ;
  int byte_count ;
  size_t bc ;
  size_t tmp ;

  {
#line 739
  if (! fin) {
    {
#line 741
    LOGGER_log((char *)"AM_base64_encodef: Error: input file stream not open, please use AM_base64_encode(infile,outfile)");
    }
#line 742
    return (-1);
  }
#line 745
  if (! fout) {
    {
#line 747
    LOGGER_log((char *)"AM_base64_encodef: Error: output file stream not open, please use AM_base64_encode(infile,outfile)");
    }
#line 748
    return (-1);
  }
#line 751
  cc = 0;
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 753
    tmp = fread((void */* __restrict  */)(inbuf), (size_t )1, (size_t )3, (FILE */* __restrict  */)fin);
#line 753
    byte_count = (int )tmp;
    }
#line 753
    if (! byte_count) {
#line 753
      goto while_break;
    }
#line 759
    outbuf[0] = AM_encode64[((int )inbuf[0] & 252) >> 2];
#line 760
    outbuf[1] = AM_encode64[(((int )inbuf[0] & 3) << 4) | (((int )inbuf[1] & 240) >> 4)];
#line 761
    outbuf[2] = AM_encode64[(((int )inbuf[1] & 15) << 2) | (((int )inbuf[2] & 192) >> 6)];
#line 762
    outbuf[3] = AM_encode64[(int )inbuf[2] & 63];
#line 766
    if (byte_count < 3) {
#line 769
      if (byte_count == 2) {
#line 769
        outbuf[3] = (unsigned char )'=';
      }
#line 770
      if (byte_count == 1) {
#line 770
        outbuf[2] = (unsigned char )'=';
#line 770
        outbuf[3] = outbuf[2];
      }
      {
#line 772
      bc = fwrite((void const   */* __restrict  */)(outbuf), (size_t )1, (size_t )4,
                  (FILE */* __restrict  */)fout);
      }
#line 773
      if (bc != 4UL) {
        {
#line 773
        LOGGER_log((char *)"%s:%d:AM_base64_encode:ERROR: Wrote %d bytes rather than %d to output",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 773,
                   bc);
        }
      }
      {
#line 775
      bc = fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)fout);
      }
#line 776
      if (bc != 1UL) {
        {
#line 776
        LOGGER_log((char *)"%s:%d:AM_base64_encode:ERROR: Wrote %d bytes rather than %d to output",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 776,
                   bc);
        }
      }
#line 777
      goto while_break;
    }
    {
#line 780
    bc = fwrite((void const   */* __restrict  */)(outbuf), (size_t )1, (size_t )4,
                (FILE */* __restrict  */)fout);
    }
#line 781
    if (bc != 4UL) {
      {
#line 781
      LOGGER_log((char *)"%s:%d:AM_base64_encode:ERROR: Wrote %d bytes rather than %d to output",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 781, bc);
      }
    }
#line 783
    cc += 4;
#line 785
    if (cc > 76) {
      {
#line 787
      bc = fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)fout);
      }
#line 788
      if (bc != 1UL) {
        {
#line 788
        LOGGER_log((char *)"%s:%d:AM_base64_encode:ERROR: Wrote %d bytes rather than %d to output",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 788,
                   bc);
        }
      }
#line 789
      cc = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  return (0);
}
}
#line 810 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_encode(char *enc_fname , char *out_fname ) 
{ 
  FILE *fin ;
  FILE *fout ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 814
  fin = fopen((char const   */* __restrict  */)enc_fname, (char const   */* __restrict  */)"rb");
  }
#line 815
  if (! fin) {
    {
#line 817
    tmp = __errno_location();
#line 817
    tmp___0 = strerror(*tmp);
#line 817
    LOGGER_log((char *)"AM_base64_encode: Cannot open \"%s\" for reading.(%s)", enc_fname,
               tmp___0);
    }
#line 818
    return (-1);
  }
  {
#line 821
  fout = fopen((char const   */* __restrict  */)out_fname, (char const   */* __restrict  */)"wb");
  }
#line 822
  if (! fout) {
    {
#line 824
    tmp___1 = __errno_location();
#line 824
    tmp___2 = strerror(*tmp___1);
#line 824
    LOGGER_log((char *)"AM_base64_encode: Cannot open \"%s\" for writing.(%s)", out_fname,
               tmp___2);
#line 825
    fclose(fin);
    }
#line 826
    return (-1);
  }
  {
#line 829
  AM_base64_encodef(fin, fout);
#line 831
  fclose(fin);
#line 832
  fclose(fout);
  }
#line 834
  return (0);
}
}
#line 862 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_encode_buffer_to_FILE(char *buffer , size_t buffer_size , FILE *fout ) 
{ 
  unsigned char outbuf[4] ;
  int cc ;
  int chars ;
  size_t tmp ;
  size_t bc ;

  {
  {
#line 866
  tmp = strlen((char const   *)buffer);
#line 866
  chars = (int )tmp;
  }
#line 869
  if ((unsigned long )fout == (unsigned long )((void *)0)) {
    {
#line 870
    LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:ERROR: Output file stream was NULL",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 870);
    }
#line 871
    return (-1);
  }
#line 874
  cc = 0;
#line 876
  if (glb.debug > 0) {
    {
#line 876
    LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:DEBUG: Encoding %d chars",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 876, chars);
    }
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! (chars > 0)) {
#line 878
      goto while_break;
    }
#line 882
    if (chars >= 3) {
#line 883
      outbuf[0] = AM_encode64[((int )*(buffer + 0) & 252) >> 2];
#line 884
      outbuf[1] = AM_encode64[(((int )*(buffer + 0) & 3) << 4) | (((int )*(buffer + 1) & 240) >> 4)];
#line 885
      outbuf[2] = AM_encode64[(((int )*(buffer + 1) & 15) << 2) | (((int )*(buffer + 2) & 192) >> 6)];
#line 886
      outbuf[3] = AM_encode64[(int )*(buffer + 2) & 63];
#line 887
      buffer += 3;
#line 888
      chars -= 3;
    } else {
#line 893
      if (glb.debug > 0) {
        {
#line 893
        LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:DEBUG: Encoding remaining %d chars \'%s\'",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 893,
                   chars, buffer);
        }
      }
#line 895
      if (chars == 2) {
#line 896
        if (glb.debug > 0) {
          {
#line 896
          LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:DEBUG: \'%c\' \'%c\'",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 896,
                     (int )*(buffer + 0), (int )*(buffer + 1));
          }
        }
#line 897
        outbuf[0] = AM_encode64[((int )*(buffer + 0) & 252) >> 2];
#line 898
        outbuf[1] = AM_encode64[(((int )*(buffer + 0) & 3) << 4) | (((int )*(buffer + 1) & 240) >> 4)];
#line 899
        outbuf[2] = AM_encode64[((int )*(buffer + 1) & 15) << 2];
#line 900
        outbuf[3] = (unsigned char )'=';
      }
#line 902
      if (chars == 1) {
#line 903
        if (glb.debug > 0) {
          {
#line 903
          LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:DEBUG: \'%c\'",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 903,
                     (int )*(buffer + 0));
          }
        }
#line 904
        outbuf[0] = AM_encode64[((int )*(buffer + 0) & 252) >> 2];
#line 905
        outbuf[1] = AM_encode64[((int )*(buffer + 0) & 3) << 4];
#line 906
        outbuf[2] = (unsigned char )'=';
#line 906
        outbuf[3] = outbuf[2];
      }
      {
#line 909
      bc = fwrite((void const   */* __restrict  */)(outbuf), (size_t )1, (size_t )4,
                  (FILE */* __restrict  */)fout);
      }
#line 910
      if (bc != 4UL) {
        {
#line 910
        LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:ERROR: Wrote %d bytes rather than %d to output",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 910,
                   bc);
        }
      }
      {
#line 911
      bc = fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)fout);
      }
#line 912
      if (bc != 1UL) {
        {
#line 912
        LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:ERROR: Wrote %d bytes rather than %d to output",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 912,
                   bc);
        }
      }
#line 913
      goto while_break;
    }
    {
#line 916
    bc = fwrite((void const   */* __restrict  */)(outbuf), (size_t )1, (size_t )4,
                (FILE */* __restrict  */)fout);
    }
#line 917
    if (bc != 4UL) {
      {
#line 917
      LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:ERROR: Wrote %d bytes rather than %d to output",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 917, bc);
      }
    }
#line 919
    cc += 4;
#line 921
    if (cc > 76) {
      {
#line 923
      bc = fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)fout);
      }
#line 924
      if (bc != 1UL) {
        {
#line 924
        LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:ERROR: Wrote %d bytes rather than %d to output",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 924,
                   bc);
        }
      }
#line 925
      cc = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 929
  bc = fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)fout);
  }
#line 930
  if (bc != 1UL) {
    {
#line 930
    LOGGER_log((char *)"%s:%d:AM_base64_encode_buffer_to_FILE:ERROR: Wrote %d bytes rather than %d to output",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 930, bc);
    }
  }
#line 931
  return (0);
}
}
#line 949 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_decode_buffer(char *buffer , size_t length ) 
{ 
  int i ;
  int realm_size ;
  int stopcount ;
  int c ;
  int char_count ;
  char output[3] ;
  char input[4] ;
  char *outstring ;

  {
#line 952
  realm_size = (int )length;
#line 953
  stopcount = 0;
#line 955
  char_count = 0;
#line 958
  outstring = buffer;
#line 960
  char_count = 0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (char_count < realm_size)) {
#line 961
      goto while_break;
    }
#line 965
    input[3] = (char)0;
#line 965
    input[2] = input[3];
#line 965
    input[1] = input[2];
#line 965
    input[0] = input[1];
#line 968
    i = 0;
    {
#line 968
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 968
      if (! (i < 4)) {
#line 968
        goto while_break___0;
      }
#line 970
      length --;
#line 973
      c = (int )*buffer;
#line 975
      if (c == 0) {
#line 975
        goto while_break___0;
      }
#line 977
      buffer ++;
#line 980
      char_count ++;
#line 983
      if (c == 61) {
#line 984
        stopcount ++;
      }
#line 988
      if ((int )b64[c] == 128) {
#line 989
        i --;
#line 990
        goto __Cont;
      }
#line 994
      input[i] = (char )b64[c];
      __Cont: /* CIL Label */ 
#line 968
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    output[0] = (char )(((int )input[0] << 2) | ((int )input[1] >> 4));
#line 1000
    output[1] = (char )(((int )input[1] << 4) | ((int )input[2] >> 2));
#line 1001
    output[2] = (char )(((int )input[2] << 6) | (int )input[3]);
#line 1004
    if (i == 4) {
#line 1005
      i = 0;
      {
#line 1005
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1005
        if (! (i < 3 - stopcount)) {
#line 1005
          goto while_break___1;
        }
#line 1006
        *outstring = output[i];
#line 1007
        outstring ++;
#line 1005
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  *outstring = (char )'\000';
#line 1015
  return (0);
}
}
#line 1038 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_decodef(FILE *fin , FILE *fout , size_t input_size ) 
{ 
  char *buffer ;
  size_t bytes_read ;
  void *tmp ;

  {
  {
#line 1044
  tmp = malloc(input_size * sizeof(char ));
#line 1044
  buffer = (char *)tmp;
  }
#line 1045
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1046
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:ERROR: Cannot allocate %d bytes for base64 decoding",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1046, input_size);
    }
  }
#line 1049
  if (glb.debug > 0) {
    {
#line 1049
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:DEBUG: Reading in %d bytes of RAW base64 data",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1049, input_size);
    }
  }
  {
#line 1052
  bytes_read = fread((void */* __restrict  */)buffer, sizeof(char ), input_size, (FILE */* __restrict  */)fin);
  }
#line 1053
  if (bytes_read != input_size) {
    {
#line 1054
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:WARNING: Requested %d bytes from input file, only received %d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1054, input_size,
               bytes_read);
    }
  }
#line 1057
  if (glb.debug > 0) {
    {
#line 1057
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:DEBUG: %d bytes read", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               1057, bytes_read);
    }
  }
#line 1060
  *(buffer + bytes_read) = (char )'\000';
#line 1062
  if (glb.debug > 0) {
    {
#line 1062
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:DEBUG: Raw input -------\n%s\n----------",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1062, buffer);
    }
  }
  {
#line 1064
  AM_base64_decode_buffer(buffer, bytes_read);
  }
#line 1067
  if (glb.debug > 0) {
    {
#line 1067
    LOGGER_log((char *)"%s:%d:AM_base64_decode_buffer:DEBUG: decoded output: ----------\n%s\n----------",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1067, buffer);
    }
  }
  {
#line 1069
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s", buffer);
#line 1070
  fflush(fout);
#line 1073
  free((void *)buffer);
  }
#line 1075
  return (0);
}
}
#line 1107 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_decode_to_bufferf(FILE *fin , size_t input_size , char **decoded_buffer ) 
{ 
  char *buffer ;
  size_t bytes_read ;
  void *tmp ;

  {
  {
#line 1113
  tmp = malloc(input_size * sizeof(char ) + 1UL);
#line 1113
  buffer = (char *)tmp;
  }
#line 1114
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1115
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:ERROR: Cannot allocate %d bytes for base64 decoding",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1115, input_size);
    }
  }
#line 1118
  if (glb.debug > 0) {
    {
#line 1118
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:DEBUG: Reading in %d bytes of RAW base64 data",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1118, input_size);
    }
  }
  {
#line 1121
  bytes_read = fread((void */* __restrict  */)buffer, sizeof(char ), input_size, (FILE */* __restrict  */)fin);
  }
#line 1122
  if (bytes_read != input_size) {
    {
#line 1123
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:WARNING: Requested %d bytes from input file, only received %d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1123, input_size,
               bytes_read);
    }
  }
#line 1126
  if (glb.debug > 0) {
    {
#line 1126
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:DEBUG: %d bytes read", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               1126, bytes_read);
    }
  }
#line 1129
  *(buffer + bytes_read) = (char )'\000';
#line 1131
  if (glb.debug > 0) {
    {
#line 1131
    LOGGER_log((char *)"%s:%d:AM_base64_decodef:DEBUG: Raw input -------\n%s\n----------",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1131, buffer);
    }
  }
  {
#line 1133
  AM_base64_decode_buffer(buffer, bytes_read);
  }
#line 1137
  if (glb.debug > 0) {
    {
#line 1137
    LOGGER_log((char *)"%s:%d:AM_base64_decode_buffer:DEBUG: decoded output: ----------\n%s\n----------",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1137, buffer);
    }
  }
#line 1138
  *decoded_buffer = buffer;
#line 1140
  return (0);
}
}
#line 1166 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_decode(char *in_fname , char *out_fname ) 
{ 
  FILE *fin ;
  FILE *fout ;
  struct stat st ;
  int stat_result ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1173
  stat_result = stat((char const   */* __restrict  */)in_fname, (struct stat */* __restrict  */)(& st));
  }
#line 1174
  if (stat_result) {
    {
#line 1175
    tmp = __errno_location();
#line 1175
    tmp___0 = strerror(*tmp);
#line 1175
    LOGGER_log((char *)"%s:%d:AM_base64_decode:ERROR: Error stat\'ing \'%s\' (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1175, in_fname,
               tmp___0);
    }
#line 1176
    return (-1);
  }
#line 1179
  if (glb.debug > 0) {
    {
#line 1179
    LOGGER_log((char *)"%s:%d:AM_base64_decode:DEBUG: %s size = %d bytes", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               1179, in_fname, st.st_size);
    }
  }
  {
#line 1181
  fin = fopen((char const   */* __restrict  */)in_fname, (char const   */* __restrict  */)"rb");
  }
#line 1182
  if (! fin) {
    {
#line 1184
    tmp___1 = __errno_location();
#line 1184
    tmp___2 = strerror(*tmp___1);
#line 1184
    LOGGER_log((char *)"AM_base64_decode: Cannot open \"%s\" for reading.(%s)", in_fname,
               tmp___2);
    }
#line 1185
    return (-1);
  }
  {
#line 1188
  fout = fopen((char const   */* __restrict  */)out_fname, (char const   */* __restrict  */)"wb");
  }
#line 1189
  if (! fout) {
    {
#line 1191
    tmp___3 = __errno_location();
#line 1191
    tmp___4 = strerror(*tmp___3);
#line 1191
    LOGGER_log((char *)"AM_base64_decode: Cannot open \"%s\" for writing.(%s)", out_fname,
               tmp___4);
#line 1192
    fclose(fin);
    }
#line 1193
    return (-1);
  }
  {
#line 1196
  AM_base64_decodef(fin, fout, (size_t )st.st_size);
#line 1198
  fclose(fin);
#line 1199
  fclose(fout);
  }
#line 1201
  return (0);
}
}
#line 1225 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_base64_decode_to_buffer(char *in_fname , char **buffer ) 
{ 
  FILE *fin ;
  struct stat st ;
  int stat_result ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1232
  stat_result = stat((char const   */* __restrict  */)in_fname, (struct stat */* __restrict  */)(& st));
  }
#line 1233
  if (stat_result) {
    {
#line 1234
    tmp = __errno_location();
#line 1234
    tmp___0 = strerror(*tmp);
#line 1234
    LOGGER_log((char *)"%s:%d:AM_base64_decode:ERROR: Error stat\'ing \'%s\' (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1234, in_fname,
               tmp___0);
    }
#line 1235
    return (-1);
  }
#line 1238
  if (glb.debug > 0) {
    {
#line 1238
    LOGGER_log((char *)"%s:%d:AM_base64_decode:DEBUG: %s size = %d bytes", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               1238, in_fname, st.st_size);
    }
  }
  {
#line 1240
  fin = fopen((char const   */* __restrict  */)in_fname, (char const   */* __restrict  */)"rb");
  }
#line 1241
  if (! fin) {
    {
#line 1243
    tmp___1 = __errno_location();
#line 1243
    tmp___2 = strerror(*tmp___1);
#line 1243
    LOGGER_log((char *)"AM_base64_decode: Cannot open \"%s\" for reading.(%s)", in_fname,
               tmp___2);
    }
#line 1244
    return (-1);
  }
  {
#line 1247
  AM_base64_decode_to_bufferf(fin, (size_t )st.st_size, buffer);
#line 1249
  fclose(fin);
  }
#line 1251
  return (0);
}
}
#line 1268 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_read_headers(struct AM_disclaimer_details *dd , FFGET_FILE *f , FILE *newf ) 
{ 
  struct MIMEH_header_info hinfo ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1272
  if (glb.debug > 0) {
    {
#line 1272
    LOGGER_log((char *)"%s:%d:AM_read_headers:DEBUG: Starting to read headers", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               1272);
    }
  }
  {
#line 1274
  dd->isfile = 0;
#line 1275
  dd->ishtml = 0;
#line 1277
  memset((void *)(& hinfo), '\000', sizeof(struct MIMEH_header_info ));
#line 1279
  hinfo.uudec_name[0] = (char )'\000';
#line 1281
  tmp = FFGET_feof(f);
  }
#line 1281
  if (tmp != 0) {
#line 1281
    return (-1);
  }
  {
#line 1284
  MIMEH_set_doubleCR_save(0);
#line 1285
  MIMEH_set_header_longsearch(0);
#line 1286
  MIMEH_set_headers_original_save_to_file(newf);
#line 1287
  MIMEH_parse_headers(f, & hinfo);
#line 1289
  MIMEH_set_headers_original_save_to_file((FILE *)((void *)0));
#line 1290
  MIMEH_set_doubleCR_save(1);
#line 1291
  MIMEH_set_headers_nosave();
  }
#line 1293
  if (glb.debug > 0) {
    {
#line 1293
    LOGGER_log((char *)"%s:%d:AM_read_headers:DEBUG: lfcount=%d, crlfcount=%d", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               1293, hinfo.lf_count, hinfo.crlf_count);
    }
  }
#line 1294
  if (hinfo.lf_count > hinfo.crlf_count) {
#line 1295
    if (glb.debug > 0) {
      {
#line 1295
      LOGGER_log((char *)"%s:%d:AM_read_headers:DEBUG:Delimeter set to LF only", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                 1295);
      }
    }
    {
#line 1296
    snprintf((char */* __restrict  */)(glb.ldelimeter), sizeof(glb.ldelimeter), (char const   */* __restrict  */)"\n");
    }
  } else {
#line 1298
    if (glb.debug > 0) {
      {
#line 1298
      LOGGER_log((char *)"%s:%d:AM_read_headers:DEBUG:Delimeter set to CRLF ", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                 1298);
      }
    }
    {
#line 1299
    snprintf((char */* __restrict  */)(glb.ldelimeter), sizeof(glb.ldelimeter), (char const   */* __restrict  */)"\r\n");
    }
  }
#line 1304
  dd->content_type = hinfo.content_type;
#line 1305
  dd->content_encoding = hinfo.content_transfer_encoding;
#line 1306
  if (hinfo.boundary_located > 0) {
    {
#line 1307
    dd->boundary_found = 1;
#line 1308
    snprintf((char */* __restrict  */)(dd->boundary), sizeof(dd->boundary), (char const   */* __restrict  */)"%s",
             hinfo.boundary);
    }
  }
  {
#line 1311
  tmp___0 = strlen((char const   *)(hinfo.filename));
  }
#line 1311
  if (tmp___0 > 0UL) {
#line 1311
    dd->isfile = 1;
  }
  {
#line 1312
  tmp___1 = strlen((char const   *)(hinfo.name));
  }
#line 1312
  if (tmp___1 > 0UL) {
#line 1312
    dd->isfile = 1;
  }
  {
#line 1321
  if (hinfo.content_transfer_encoding == 105) {
#line 1321
    goto case_105;
  }
#line 1321
  if (hinfo.content_transfer_encoding == 106) {
#line 1321
    goto case_105;
  }
#line 1318
  goto switch_break;
  case_105: /* CIL Label */ 
  case_106: /* CIL Label */ 
#line 1322
  dd->isfile = 1;
#line 1323
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1328
  if (hinfo.content_type == 500) {
#line 1328
    goto case_500;
  }
#line 1328
  if (hinfo.content_type == 105) {
#line 1328
    goto case_500;
  }
#line 1326
  goto switch_break___0;
  case_500: /* CIL Label */ 
  case_105___0: /* CIL Label */ 
#line 1329
  dd->isfile = 1;
#line 1330
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1337
  if (dd->content_type == 203) {
#line 1337
    dd->ishtml = 1;
  }
#line 1339
  if (hinfo.content_type == 106) {
#line 1341
    if (glb.debug > 0) {
      {
#line 1341
      LOGGER_log((char *)"%s:%d:AM_read_headers:DEBUG: Email is signed, return SIGNED_EMAIL",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1341);
      }
    }
#line 1342
    return (10);
  }
#line 1345
  if (glb.debug > 0) {
    {
#line 1345
    LOGGER_log((char *)"%s:%d:AM_read_headers:DEBUG: Exit ( Header read section ).\n\t-- isfile=%d ishtml=%d boundaryfound=%d\n\n",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1345, dd->isfile,
               dd->ishtml, dd->boundary_found);
    }
  }
#line 1347
  return (0);
}
}
#line 1361 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_disclaimer_load_text(char *fname , char **textptr ) 
{ 
  FILE *f ;
  struct stat st ;
  size_t bc ;
  char *p ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1367
  *textptr = (char *)((void *)0);
#line 1369
  tmp___4 = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& st));
  }
#line 1369
  if (0 == tmp___4) {
    {
#line 1372
    tmp = malloc((unsigned long )(st.st_size + 1L) * sizeof(char ));
#line 1372
    p = (char *)tmp;
    }
#line 1373
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 1374
      LOGGER_log((char *)"%s:%d:AM_disclaimer_load_text:ERROR: Unable to allocate memory to load file \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1374,
                 fname);
      }
#line 1375
      return (1);
    }
#line 1378
    if (p) {
      {
#line 1381
      memset((void *)p, '\000', (size_t )(st.st_size + 1L));
#line 1383
      f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
      }
#line 1384
      if (! f) {
        {
#line 1386
        tmp___0 = __errno_location();
#line 1386
        tmp___1 = strerror(*tmp___0);
#line 1386
        LOGGER_log((char *)"%s:%d:AM_disclaimer_load_text:ERROR: Cannot open %s for reading (%s)",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1386,
                   fname, tmp___1);
        }
#line 1387
        return (0);
      }
      {
#line 1390
      bc = fread((void */* __restrict  */)p, (size_t )1, (size_t )st.st_size, (FILE */* __restrict  */)f);
      }
#line 1391
      if (bc != (size_t )st.st_size) {
        {
#line 1391
        LOGGER_log((char *)"%s:%d:AM_disclaimer_load_text:ERROR: Read %d bytes instead of %d from %s",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1391,
                   bc, st.st_size, fname);
        }
      }
#line 1394
      if (glb.debug > 0) {
        {
#line 1394
        LOGGER_log((char *)"%s:%d:AM_disclaimer_load_text:DEBUG: Disclaimer Loaded (%s:%d):\n%s",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1394,
                   fname, st.st_size, p);
        }
      }
      {
#line 1395
      fclose(f);
#line 1397
      *textptr = p;
      }
    }
  } else {
    {
#line 1401
    tmp___2 = __errno_location();
#line 1401
    tmp___3 = strerror(*tmp___2);
#line 1401
    LOGGER_log((char *)"%s:%d:AM_disclaimer_load_text:ERROR: Cannot stat \'%s\' (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1401, fname,
               tmp___3);
    }
  }
#line 1405
  return (0);
}
}
#line 1430 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_disclaimer_html_perform_insertion(struct AM_disclaimer_details *dd , FFGET_FILE *f ,
                                         FILE *newf ) 
{ 
  char *p ;
  char *qp_data ;
  size_t qp_data_size ;
  char *data_to_use ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1434
  if (dd->content_encoding == 103) {
#line 1439
    if ((unsigned long )dd->disclaimer_text_HTML == (unsigned long )((void *)0)) {
#line 1439
      data_to_use = dd->disclaimer_text_plain;
    } else {
#line 1440
      data_to_use = dd->disclaimer_text_HTML;
    }
    {
#line 1442
    tmp = strlen((char const   *)data_to_use);
#line 1442
    qp_data_size = tmp * 3UL + 1UL;
#line 1443
    tmp___0 = malloc(qp_data_size * sizeof(char ));
#line 1443
    qp_data = (char *)tmp___0;
    }
#line 1444
    if ((unsigned long )qp_data == (unsigned long )((void *)0)) {
      {
#line 1445
      LOGGER_log((char *)"%s:%d:AM_disclaimer_html_perform_insertion:DEBUG: Error trying to allocate %d bytes of memory for QP encoded disclaimer",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1445,
                 qp_data_size);
      }
#line 1446
      return (-1);
    }
    {
#line 1448
    tmp___1 = strlen((char const   *)data_to_use);
#line 1448
    qp_encode(qp_data, qp_data_size, data_to_use, tmp___1);
#line 1449
    p = AM_adapt_linebreak(qp_data, glb.ldelimeter);
    }
#line 1451
    if (glb.debug > 0) {
      {
#line 1451
      LOGGER_log((char *)"%s:%d:AM_disclaimer_html_perform_insertion:DEBUG: Inserting QP encoded disclaimer",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1451);
      }
    }
#line 1452
    if ((unsigned long )dd->disclaimer_text_HTML == (unsigned long )((void *)0)) {
      {
#line 1453
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"<br><pre>=%s",
              glb.ldelimeter);
#line 1454
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
              p);
#line 1455
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"</pre><br>=%s",
              glb.ldelimeter);
      }
    } else {
      {
#line 1457
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"<br>=%s",
              glb.ldelimeter);
#line 1458
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
              p);
#line 1459
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"<br>=%s",
              glb.ldelimeter);
      }
    }
#line 1464
    if (qp_data) {
      {
#line 1464
      free((void *)qp_data);
      }
    }
  } else
#line 1470
  if ((unsigned long )dd->disclaimer_text_HTML == (unsigned long )((void *)0)) {
    {
#line 1472
    fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"<br><pre>%s",
            glb.ldelimeter);
#line 1473
    p = AM_adapt_linebreak(dd->disclaimer_text_plain, glb.ldelimeter);
#line 1474
    fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s</pre><br>%s",
            p, glb.ldelimeter);
    }
  } else {
    {
#line 1478
    fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"<br>%s",
            glb.ldelimeter);
#line 1479
    p = AM_adapt_linebreak(dd->disclaimer_text_HTML, glb.ldelimeter);
#line 1480
    fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s<br>%s",
            p, glb.ldelimeter);
    }
  }
#line 1484
  return (0);
}
}
#line 1497 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_add_disclaimer_insert_html(struct AM_disclaimer_details *dd , FFGET_FILE *f ,
                                  FILE *newf ) 
{ 
  char boundary[1025] ;
  int boundary_length ;
  char line[1025] ;
  char lline[1025] ;
  char *prebody ;
  char *tmpbody ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 1500
  boundary_length = 0;
#line 1505
  if (glb.debug > 0) {
    {
#line 1505
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_insert_html:DEBUG: Starting to attempt to insert HTML disclaimer",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1505);
    }
  }
#line 1507
  if (dd->boundary_found == 1) {
    {
#line 1509
    snprintf((char */* __restrict  */)(boundary), sizeof(boundary), (char const   */* __restrict  */)"--%s",
             dd->boundary);
#line 1510
    tmp = strlen((char const   *)(boundary));
#line 1510
    boundary_length = (int )tmp;
    }
  }
  {
#line 1513
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1513
    tmp___1 = FFGET_fgets(line, 1024, f);
    }
#line 1513
    if (! tmp___1) {
#line 1513
      goto while_break;
    }
#line 1520
    if (dd->boundary_found == 1) {
      {
#line 1520
      tmp___0 = strncmp((char const   *)(boundary), (char const   *)(line), (size_t )boundary_length);
      }
#line 1520
      if (tmp___0 == 0) {
#line 1522
        if (glb.debug > 0) {
          {
#line 1522
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer_insert_html: End of boundary reached before html disclamer was added...",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1522);
          }
        }
#line 1523
        if (glb.force_for_bad_html == 1) {
#line 1525
          if (glb.debug > 0) {
            {
#line 1525
            LOGGER_log((char *)"%s:%d:Forcing insertion of html disclaimer into non valid html body...",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       1525);
            }
          }
          {
#line 1527
          dd->html_inserted = 1;
#line 1529
          AM_disclaimer_html_perform_insertion(dd, f, newf);
          }
        }
        {
#line 1534
        fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
                line);
        }
#line 1537
        goto while_break;
      }
    }
    {
#line 1546
    strcpy((char */* __restrict  */)(lline), (char const   */* __restrict  */)(line));
#line 1547
    PLD_strlower(lline);
#line 1551
    prebody = strstr((char const   *)(lline), "</body");
    }
#line 1552
    if (! prebody) {
      {
#line 1552
      prebody = strstr((char const   *)(lline), "</html");
      }
    }
#line 1558
    if ((unsigned long )prebody != (unsigned long )((void *)0)) {
#line 1560
      if (glb.debug > 0) {
        {
#line 1560
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer_insert_html:DEBUG: prebody = %s",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1560,
                   prebody);
        }
      }
#line 1561
      if (glb.debug > 0) {
        {
#line 1561
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer_insert_html:DEBUG: Inserting html-body disclaimer",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1561);
        }
      }
      {
#line 1563
      dd->html_inserted = 1;
#line 1567
      tmpbody = line + (prebody - lline);
#line 1568
      *tmpbody = (char )'\000';
#line 1572
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s%s",
              line, glb.ldelimeter);
#line 1573
      AM_disclaimer_html_perform_insertion(dd, f, newf);
#line 1574
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"<%s",
              tmpbody + 1);
      }
#line 1576
      goto while_break;
    } else {
      {
#line 1579
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
              line);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1584
  return (dd->html_inserted);
}
}
#line 1608 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_add_disclaimer_cleanup(FILE *mp , FILE *newf , char *mpacktmp , char *mpackname ) 
{ 
  int tmp ;

  {
  {
#line 1614
  tmp = strcmp((char const   *)mpackname, "-");
  }
#line 1614
  if (tmp) {
    {
#line 1618
    fclose(mp);
#line 1619
    fclose(newf);
#line 1623
    rename((char const   *)mpacktmp, (char const   *)mpackname);
    }
  }
#line 1626
  return (0);
}
}
#line 1645 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_add_disclaimer_flush(FFGET_FILE *f , FILE *newf ) 
{ 
  char line[1025] ;
  unsigned int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1647
  line[0] = (char )'\000';
#line 1647
  tmp = 1U;
  {
#line 1647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1647
    if (tmp >= 1025U) {
#line 1647
      goto while_break;
    }
#line 1647
    line[tmp] = (char)0;
#line 1647
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1649
  tmp___1 = FFGET_feof(f);
  }
#line 1649
  if (! tmp___1) {
#line 1651
    if (glb.debug > 0) {
      {
#line 1651
      LOGGER_log((char *)"%s:%d:AM_add_disclaimer_flush:DEBUG: Appending remaining of file",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1651);
      }
    }
    {
#line 1652
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1652
      tmp___0 = FFGET_fgets(line, 1024, f);
      }
#line 1652
      if (! tmp___0) {
#line 1652
        goto while_break___0;
      }
      {
#line 1654
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
              line);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1656
    if (glb.debug > 0) {
      {
#line 1656
      LOGGER_log((char *)"%s:%d:AM_add_disclaimer_flush:DEBUG: Done appending.", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                 1656);
      }
    }
  }
#line 1659
  return (0);
}
}
#line 1683 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_read_to_boundary(FFGET_FILE *infile , FILE *outf , char *buffer , size_t buffer_size ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1685
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1685
    tmp___1 = FFGET_fgets(buffer, (int )buffer_size, infile);
    }
#line 1685
    if (! tmp___1) {
#line 1685
      goto while_break;
    }
    {
#line 1687
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"%s",
            buffer);
#line 1688
    tmp = strlen((char const   *)buffer);
#line 1688
    tmp___0 = BS_cmp(buffer, (int )tmp);
    }
#line 1688
    if (tmp___0 == 1) {
#line 1690
      if (glb.debug > 0) {
        {
#line 1690
        LOGGER_log((char *)"%s:%d:AM_read_to_boundary:DEBUG: Boundary hit while reading MIME segment, breaking out of while loop",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1690);
        }
      }
#line 1691
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1694
  return (0);
}
}
#line 1717 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_load_disclaimers(struct AM_disclaimer_details *dd ) 
{ 
  int dud_html ;
  int dud_text ;
  int dud_b64 ;
  size_t tmp ;

  {
#line 1719
  dud_html = 0;
#line 1719
  dud_text = 0;
#line 1719
  dud_b64 = 0;
#line 1721
  dd->disclaimer_text_HTML = (char *)((void *)0);
#line 1722
  dd->disclaimer_text_plain = (char *)((void *)0);
#line 1723
  dd->disclaimer_text_b64 = (char *)((void *)0);
#line 1725
  if ((unsigned long )glb.disclaimer_plain != (unsigned long )((void *)0)) {
#line 1725
    if (glb.disclaimer_plain_type != 0) {
#line 1727
      if (glb.disclaimer_plain_type == 1) {
        {
#line 1729
        AM_disclaimer_load_text(glb.disclaimer_plain, & dd->disclaimer_text_plain);
        }
      } else {
#line 1733
        dd->disclaimer_text_plain = glb.disclaimer_plain;
      }
    } else {
#line 1737
      dud_text = 1;
    }
  } else {
#line 1737
    dud_text = 1;
  }
#line 1741
  if ((unsigned long )glb.disclaimer_HTML != (unsigned long )((void *)0)) {
#line 1741
    if (glb.disclaimer_HTML_type != 0) {
#line 1743
      if (glb.disclaimer_HTML_type == 1) {
        {
#line 1745
        AM_disclaimer_load_text(glb.disclaimer_HTML, & dd->disclaimer_text_HTML);
        }
      } else {
#line 1749
        dd->disclaimer_text_HTML = glb.disclaimer_HTML;
      }
    } else {
#line 1753
      dud_html = 1;
    }
  } else {
#line 1753
    dud_html = 1;
  }
#line 1756
  if ((unsigned long )glb.disclaimer_b64 != (unsigned long )((void *)0)) {
#line 1756
    if (glb.disclaimer_b64_type != 0) {
#line 1758
      if (glb.disclaimer_b64_type == 1) {
        {
#line 1760
        AM_base64_decode_to_buffer(glb.disclaimer_b64, & dd->disclaimer_text_b64);
        }
      } else {
        {
#line 1762
        dd->disclaimer_text_b64 = strdup((char const   *)glb.disclaimer_b64);
#line 1763
        tmp = strlen((char const   *)dd->disclaimer_text_b64);
#line 1763
        AM_base64_decode_buffer(dd->disclaimer_text_b64, tmp);
        }
      }
    } else {
#line 1766
      dud_b64 = 1;
    }
  } else {
#line 1766
    dud_b64 = 1;
  }
#line 1770
  if (dud_html == 1) {
#line 1770
    if (dud_text == 1) {
#line 1770
      if (dud_b64 == 1) {
        {
#line 1772
        LOGGER_log((char *)"%s:%d:AM_load_disclaimers: Neither the Plain-text , HTML or BASE64 disclaimer were valid to insert, skipping disclaimer-insertion routine\n");
        }
#line 1773
        return (-1);
      }
    }
  }
#line 1776
  return (0);
}
}
#line 1801 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_insert_disclaimer_into_buffer(char *buffer , struct AM_disclaimer_details *dd ) 
{ 
  char *p ;
  size_t total_size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1803
  p = buffer;
#line 1806
  tmp = strlen((char const   *)dd->disclaimer_text_plain);
#line 1806
  tmp___0 = strlen((char const   *)buffer);
#line 1806
  total_size = (tmp + tmp___0) + 1UL;
#line 1808
  tmp___1 = malloc(total_size * sizeof(char ));
#line 1808
  p = (char *)tmp___1;
  }
#line 1809
  if (p) {
    {
#line 1810
    snprintf((char */* __restrict  */)p, total_size - 1UL, (char const   */* __restrict  */)"%s\n%s",
             buffer, dd->disclaimer_text_plain);
    }
  }
#line 1813
  return (p);
}
}
#line 1844 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
char *AM_insert_HTML_disclaimer_into_buffer(char *buffer , struct AM_disclaimer_details *dd ) 
{ 
  char *p ;
  char *new_buffer ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1847
  new_buffer = (char *)((void *)0);
#line 1849
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1850
    LOGGER_log((char *)"%s:%d:AM_insert_HTML_disclaimer_into_buffer:ERROR: Input buffer is NULL",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1850);
    }
  }
#line 1853
  if (glb.debug > 0) {
    {
#line 1853
    LOGGER_log((char *)"%s:%d:AM_insert_HTML_disclaimer_into_buffer:DEBUG: Searching for BODY closing tag\n\'\'\'%s\'\'\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1853, buffer);
    }
  }
  {
#line 1855
  p = PLD_strstr(buffer, (char *)"</BODY", 1);
  }
#line 1856
  if (! p) {
#line 1857
    if (glb.debug > 0) {
      {
#line 1857
      LOGGER_log((char *)"%s:%d:AM_insert_HTML_disclaimer_into_buffer:DEBUG: Searching for HTML closing tag",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1857);
      }
    }
    {
#line 1858
    p = PLD_strstr(buffer, (char *)"</HTML", 1);
    }
  }
#line 1863
  if (p) {
#line 1864
    *p = (char )'\000';
#line 1866
    if (glb.debug > 0) {
      {
#line 1866
      LOGGER_log((char *)"%s:%d:AM_insert_HTML_disclaimer_into_buffer:DEBUG: Composing HTML + disclaimer",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1866);
      }
    }
#line 1867
    if (dd->disclaimer_text_HTML) {
      {
#line 1868
      new_buffer = PLD_dprintf("%s\n%s\n<%s", buffer, dd->disclaimer_text_HTML, p + 1);
      }
    } else {
      {
#line 1874
      new_buffer = PLD_dprintf("%s\n<PRE>%s</pre>\n<%s", buffer, dd->disclaimer_text_plain,
                               p + 1);
      }
    }
#line 1881
    dd->html_inserted = 1;
  } else {
    {
#line 1887
    tmp = PLD_strstr(buffer, (char *)"<BR", 1);
    }
#line 1887
    if (tmp) {
#line 1887
      goto _L;
    } else {
      {
#line 1887
      tmp___0 = PLD_strstr(buffer, (char *)"<FONT", 1);
      }
#line 1887
      if (tmp___0) {
#line 1887
        goto _L;
      } else {
        {
#line 1887
        tmp___1 = PLD_strstr(buffer, (char *)"<A ", 1);
        }
#line 1887
        if (tmp___1) {
#line 1887
          goto _L;
        } else
#line 1887
        if (glb.force_for_bad_html == 1) {
          _L: /* CIL Label */ 
#line 1893
          if (dd->disclaimer_text_HTML) {
            {
#line 1894
            new_buffer = PLD_dprintf("%s\n%s", buffer, dd->disclaimer_text_HTML);
            }
          } else {
            {
#line 1896
            new_buffer = PLD_dprintf("%s\n<PRE>%s</pre>\n", buffer, dd->disclaimer_text_plain);
            }
          }
        } else {
          {
#line 1901
          new_buffer = strdup((char const   *)buffer);
          }
        }
      }
    }
  }
#line 1905
  if (glb.debug > 0) {
    {
#line 1905
    LOGGER_log((char *)"%s:%d:AM_insert_HTML_disclaimer_into_buffer:DEBUG: Final segment \'\'\'%s\'\'\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1905, new_buffer);
    }
  }
#line 1907
  return (new_buffer);
}
}
#line 1935 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_insert_disclaimer_into_segment64(FFGET_FILE *f , FILE *newf , struct AM_disclaimer_details *dd ) 
{ 
  char line[1025] ;
  unsigned int tmp ;
  int last_boundary_written ;
  int insert_success ;
  char *b64_buffer ;
  char *new_b64_buffer ;
  char b64_raw_fname[128] ;
  FILE *b64_raw_file ;
  __pid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 1937
  line[0] = (char )'\000';
#line 1937
  tmp = 1U;
  {
#line 1937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1937
    if (tmp >= 1025U) {
#line 1937
      goto while_break;
    }
#line 1937
    line[tmp] = (char)0;
#line 1937
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1938
  last_boundary_written = -1;
#line 1939
  insert_success = 0;
#line 1944
  if (glb.debug > 0) {
    {
#line 1944
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Inserting disclaimer into segment",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1944);
    }
  }
  {
#line 1951
  tmp___0 = getpid();
#line 1951
  snprintf((char */* __restrict  */)(b64_raw_fname), sizeof(b64_raw_fname), (char const   */* __restrict  */)"altermime-raw-%d.b64",
           tmp___0);
#line 1953
  b64_raw_file = fopen((char const   */* __restrict  */)(b64_raw_fname), (char const   */* __restrict  */)"w");
  }
#line 1954
  if ((unsigned long )b64_raw_file == (unsigned long )((void *)0)) {
#line 1955
    if (glb.debug > 0) {
      {
#line 1955
      tmp___1 = __errno_location();
#line 1955
      tmp___2 = strerror(*tmp___1);
#line 1955
      LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:ERROR: Cannot open \'%s\' (%s)",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 1955,
                 b64_raw_fname, tmp___2);
      }
    }
#line 1956
    return (1);
  }
#line 1961
  if (0 == dd->text_inserted) {
#line 1961
    if (dd->content_type == 201) {
#line 1961
      if (dd->content_encoding == 100) {
#line 1961
        if (dd->isfile == 0) {
#line 1967
          if (glb.debug > 0) {
            {
#line 1967
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Conditions right to insert disclaimer\n",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       1967);
            }
          }
#line 1968
          if (glb.debug > 0) {
            {
#line 1968
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Reading first segment looking for boundary line\n",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       1968);
            }
          }
          {
#line 1975
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 1975
            tmp___5 = FFGET_fgets(line, 1024, f);
            }
#line 1975
            if (! tmp___5) {
#line 1975
              goto while_break___0;
            }
            {
#line 1977
            last_boundary_written = 0;
#line 1978
            tmp___3 = strlen((char const   *)(line));
#line 1978
            tmp___4 = BS_cmp(line, (int )tmp___3);
            }
#line 1978
            if (tmp___4 == 1) {
#line 1980
              if (glb.debug > 0) {
                {
#line 1980
                LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Boundary hit",
                           "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                           1980);
                }
              }
#line 1981
              goto while_break___0;
            }
            {
#line 1983
            fprintf((FILE */* __restrict  */)b64_raw_file, (char const   */* __restrict  */)"%s",
                    line);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1988
          fclose(b64_raw_file);
#line 1996
          AM_base64_decode_to_buffer(b64_raw_fname, & b64_buffer);
#line 1999
          unlink((char const   *)(b64_raw_fname));
#line 2002
          new_b64_buffer = AM_insert_disclaimer_into_buffer(b64_buffer, dd);
          }
#line 2003
          if (new_b64_buffer) {
#line 2006
            if (glb.debug > 0) {
              {
#line 2006
              LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Inserting TEXT disclaimer (%s)\n",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2006, dd->disclaimer_text_plain);
              }
            }
            {
#line 2007
            tmp___6 = strlen((char const   *)new_b64_buffer);
#line 2007
            AM_base64_encode_buffer_to_FILE(new_b64_buffer, tmp___6, newf);
#line 2008
            dd->text_inserted = 1;
#line 2009
            free((void *)new_b64_buffer);
            }
          }
#line 2014
          insert_success = 1;
#line 2015
          if (glb.debug > 0) {
            {
#line 2015
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: TEXT disclaimer is inserted, now flushing file output",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2015);
            }
          }
          {
#line 2016
          fflush(newf);
          }
#line 2018
          if (last_boundary_written == 0) {
#line 2020
            if (glb.debug > 0) {
              {
#line 2020
              LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: writing the boundary line \'%s\'",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2020, line);
              }
            }
            {
#line 2021
            fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
                    line);
#line 2022
            last_boundary_written = 1;
            }
          }
        } else {
#line 1961
          goto _L___1;
        }
      } else {
#line 1961
        goto _L___1;
      }
    } else {
#line 1961
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2026
  if (glb.debug > 0) {
    {
#line 2026
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Conditions not right to insert a TEXT disclaimer",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2026);
    }
  }
#line 2033
  if (glb.debug > 0) {
    {
#line 2033
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: glb.HTML_too=%d, dd->html_inserted=%d, dd->content_type=%d, dd->isfile=%d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2034, glb.HTML_too,
               dd->html_inserted, dd->content_type, dd->isfile);
    }
  }
#line 2041
  if (glb.HTML_too) {
#line 2041
    if (0 == dd->html_inserted) {
#line 2041
      if (dd->content_type == 203) {
#line 2041
        if (dd->content_encoding == 100) {
#line 2041
          if (dd->isfile == 0) {
#line 2048
            if (glb.debug > 0) {
              {
#line 2048
              LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Conditions right for HTML disclaimer to be added",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2048);
              }
            }
            {
#line 2050
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 2050
              tmp___9 = FFGET_fgets(line, 1024, f);
              }
#line 2050
              if (! tmp___9) {
#line 2050
                goto while_break___1;
              }
              {
#line 2052
              last_boundary_written = 0;
#line 2053
              tmp___7 = strlen((char const   *)(line));
#line 2053
              tmp___8 = BS_cmp(line, (int )tmp___7);
              }
#line 2053
              if (tmp___8 == 1) {
#line 2055
                if (glb.debug > 0) {
                  {
#line 2055
                  LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Boundary hit",
                             "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                             2055);
                  }
                }
#line 2056
                goto while_break___1;
              }
              {
#line 2058
              fprintf((FILE */* __restrict  */)b64_raw_file, (char const   */* __restrict  */)"%s",
                      line);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 2062
            fclose(b64_raw_file);
#line 2065
            AM_base64_decode_to_buffer(b64_raw_fname, & b64_buffer);
#line 2068
            unlink((char const   *)(b64_raw_fname));
#line 2070
            new_b64_buffer = AM_insert_HTML_disclaimer_into_buffer(b64_buffer, dd);
            }
#line 2071
            if (! new_b64_buffer) {
#line 2072
              new_b64_buffer = b64_buffer;
            }
            {
#line 2074
            tmp___10 = strlen((char const   *)new_b64_buffer);
#line 2074
            AM_base64_encode_buffer_to_FILE(new_b64_buffer, tmp___10, newf);
#line 2075
            free((void *)new_b64_buffer);
            }
#line 2077
            if (glb.verbose) {
#line 2077
              if (0 == dd->html_inserted) {
                {
#line 2079
                LOGGER_log((char *)"WARNING: Could not insert HTML disclaimer into email");
                }
              } else {
#line 2081
                insert_success = 1;
              }
            } else {
#line 2081
              insert_success = 1;
            }
#line 2084
            if (last_boundary_written == 0) {
#line 2086
              if (glb.debug > 0) {
                {
#line 2086
                LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: writing the boundary line \'%s\'",
                           "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                           2086, line);
                }
              }
              {
#line 2087
              fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
                      line);
#line 2088
              last_boundary_written = 1;
              }
            }
          } else {
#line 2041
            goto _L___5;
          }
        } else {
#line 2041
          goto _L___5;
        }
      } else {
#line 2041
        goto _L___5;
      }
    } else {
#line 2041
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2092
  if (glb.debug > 0) {
    {
#line 2092
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Conditions not right to insert HTML disclaimer",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2092);
    }
  }
#line 2096
  if (insert_success == 0) {
    {
#line 2097
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2097
      tmp___13 = FFGET_fgets(line, 1024, f);
      }
#line 2097
      if (! tmp___13) {
#line 2097
        goto while_break___2;
      }
      {
#line 2098
      last_boundary_written = 0;
#line 2099
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
              line);
#line 2100
      tmp___11 = strlen((char const   *)(line));
#line 2100
      tmp___12 = BS_cmp(line, (int )tmp___11);
      }
#line 2100
      if (tmp___12 == 1) {
#line 2101
        if (glb.debug > 0) {
          {
#line 2101
          LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment64:DEBUG: Boundary hit, breaking out",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2101);
          }
        }
#line 2102
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2107
  return (0);
}
}
#line 2133 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_add_disclaimer_no_boudary(FFGET_FILE *f , FILE *newf , struct AM_disclaimer_details *dd ) 
{ 
  char line[1025] ;
  unsigned int tmp ;
  char *p ;
  int tmp___0 ;

  {
#line 2135
  line[0] = (char )'\000';
#line 2135
  tmp = 1U;
  {
#line 2135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2135
    if (tmp >= 1025U) {
#line 2135
      goto while_break;
    }
#line 2135
    line[tmp] = (char)0;
#line 2135
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2138
  if (glb.debug > 0) {
    {
#line 2138
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_no_boudary:DEBUG: Inserting disclaimer into a non-boundary email",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2138);
    }
  }
#line 2142
  if (dd->content_type == 204) {
#line 2143
    return (-1);
  }
#line 2146
  if (dd->content_encoding == 100) {
#line 2146
    if (dd->content_type == 203) {
#line 2146
      goto _L;
    } else
#line 2146
    if (dd->content_type == 201) {
      _L: /* CIL Label */ 
#line 2162
      if (glb.force_into_b64) {
        {
#line 2162
        tmp___0 = AM_insert_disclaimer_into_segment64(f, newf, dd);
        }
#line 2162
        return (tmp___0);
      } else {
#line 2163
        return (-1);
      }
      {
#line 2168
      LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:ERROR: Executed beyond base64 segment insert, please report this.",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2168);
      }
    }
  }
  {
#line 2176
  if (dd->content_type == 203) {
#line 2176
    goto case_203;
  }
#line 2188
  goto switch_default;
  case_203: /* CIL Label */ 
#line 2177
  if (glb.debug > 0) {
    {
#line 2177
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_no_boudary:DEBUG: Conditions right for HTML disclaimer to be added",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2177);
    }
  }
#line 2179
  if (dd->content_encoding != 100) {
    {
#line 2180
    AM_add_disclaimer_insert_html(dd, f, newf);
    }
  }
#line 2182
  if (glb.verbose) {
#line 2182
    if (dd->html_inserted == 0) {
      {
#line 2184
      LOGGER_log((char *)"WARNING: Could not insert HTML disclaimer into email\n");
      }
    }
  }
#line 2186
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2193
  if (glb.debug > 0) {
    {
#line 2193
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_insert_html:DEBUG: Seeking to the end of the file for plain-text insertion...",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2193);
    }
  }
  {
#line 2195
  AM_read_to_boundary(f, newf, line, (size_t )1024);
  }
#line 2197
  if (glb.debug > 0) {
    {
#line 2197
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_no_boudary:DEBUG: About to write disclaimer \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2197, dd->disclaimer_text_plain);
    }
  }
  {
#line 2198
  p = AM_adapt_linebreak(dd->disclaimer_text_plain, glb.ldelimeter);
#line 2199
  fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s", p);
#line 2200
  dd->text_inserted = 1;
  }
#line 2201
  if (glb.debug > 0) {
    {
#line 2201
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_no_boudary:DEBUG: Disclaimer now written to file",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2201);
    }
  }
#line 2202
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2205
  if (glb.debug > 0) {
    {
#line 2205
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer_no_boudary:DEBUG: Done, text-inserted=%d, html-inserted=%d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2206, dd->text_inserted,
               dd->html_inserted);
    }
  }
#line 2211
  return (0);
}
}
#line 2247 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_insert_disclaimer_into_segment(FFGET_FILE *f , FILE *newf , struct AM_disclaimer_details *dd ) 
{ 
  char line[1025] ;
  unsigned int tmp ;
  int last_boundary_written ;
  int result ;
  int insert_success ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *qp_data ;
  size_t qp_data_size ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *p ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
#line 2249
  line[0] = (char )'\000';
#line 2249
  tmp = 1U;
  {
#line 2249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2249
    if (tmp >= 1025U) {
#line 2249
      goto while_break;
    }
#line 2249
    line[tmp] = (char)0;
#line 2249
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2250
  last_boundary_written = -1;
#line 2251
  result = 0;
#line 2252
  insert_success = 0;
#line 2254
  if (glb.debug > 0) {
    {
#line 2254
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Inserting disclaimer into segment - encoding=%d type=%d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2254, dd->content_encoding,
               dd->content_type);
    }
  }
#line 2264
  if (dd->content_type == 204) {
#line 2265
    if (glb.debug > 0) {
      {
#line 2265
      LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Not inserting into a calendar file");
      }
    }
#line 2266
    return (-1);
  }
#line 2269
  if (dd->content_encoding == 100) {
#line 2269
    if (dd->content_type == 203) {
#line 2269
      goto _L;
    } else
#line 2269
    if (dd->content_type == 201) {
      _L: /* CIL Label */ 
#line 2285
      if (glb.force_into_b64) {
        {
#line 2285
        tmp___0 = AM_insert_disclaimer_into_segment64(f, newf, dd);
        }
#line 2285
        return (tmp___0);
      } else {
#line 2286
        return (-1);
      }
      {
#line 2291
      LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:ERROR: Executed beyond base64 segment insert, please report this.",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2291);
      }
    }
  }
#line 2295
  if (0 == dd->text_inserted) {
#line 2295
    if (dd->content_type == 201) {
#line 2295
      if (dd->isfile == 0) {
#line 2300
        if (glb.debug > 0) {
          {
#line 2300
          LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Conditions right to insert disclaimer\n",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2300);
          }
        }
#line 2301
        if (glb.debug > 0) {
          {
#line 2301
          LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Reading first segment looking for boundary line\n",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2301);
          }
        }
        {
#line 2308
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 2308
          tmp___3 = FFGET_fgets(line, 1024, f);
          }
#line 2308
          if (! tmp___3) {
#line 2308
            goto while_break___0;
          }
          {
#line 2310
          last_boundary_written = 0;
#line 2311
          tmp___1 = strlen((char const   *)(line));
#line 2311
          tmp___2 = BS_cmp(line, (int )tmp___1);
          }
#line 2311
          if (tmp___2 == 1) {
#line 2313
            if (glb.debug > 0) {
              {
#line 2313
              LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Boundary hit",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2313);
              }
            }
#line 2314
            goto while_break___0;
          }
          {
#line 2316
          fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
                  line);
#line 2317
          last_boundary_written = 1;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 2320
        tmp___4 = FFGET_feof(f);
        }
#line 2320
        if (tmp___4) {
#line 2320
          return (-1);
        }
#line 2322
        if (glb.debug > 0) {
          {
#line 2322
          LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Inserting TEXT disclaimer (%s)\n",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2322,
                     dd->disclaimer_text_plain);
          }
        }
#line 2324
        if (dd->content_encoding == 103) {
          {
#line 2330
          tmp___5 = strlen((char const   *)dd->disclaimer_text_plain);
#line 2330
          qp_data_size = tmp___5 * 3UL + 1UL;
#line 2331
          tmp___6 = malloc(qp_data_size * sizeof(char ));
#line 2331
          qp_data = (char *)tmp___6;
          }
#line 2332
          if ((unsigned long )qp_data == (unsigned long )((void *)0)) {
            {
#line 2333
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Error trying to allocate %d bytes of memory for QP encoded disclaimer",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2333, qp_data_size);
            }
#line 2334
            return (-1);
          }
          {
#line 2336
          tmp___7 = strlen((char const   *)dd->disclaimer_text_plain);
#line 2336
          qp_encode(qp_data, qp_data_size, dd->disclaimer_text_plain, tmp___7);
          }
#line 2337
          if (glb.debug > 0) {
            {
#line 2337
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Inserting QP encoded disclaimer",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2337);
            }
          }
          {
#line 2338
          fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s\n",
                  qp_data);
          }
#line 2341
          if (qp_data) {
            {
#line 2341
            free((void *)qp_data);
            }
          }
        } else {
          {
#line 2346
          p = AM_adapt_linebreak(dd->disclaimer_text_plain, glb.ldelimeter);
          }
#line 2347
          if (p) {
            {
#line 2348
            fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
                    p);
            }
          } else {
            {
#line 2350
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:WARNING: Disclaimer was NULL after linebreak adaption",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2350);
            }
          }
        }
#line 2354
        dd->text_inserted = 1;
#line 2355
        insert_success = 1;
#line 2356
        if (glb.debug > 0) {
          {
#line 2356
          LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: TEXT disclaimer is inserted, now flushing file output",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2356);
          }
        }
        {
#line 2357
        fflush(newf);
        }
#line 2359
        if (last_boundary_written == 0) {
#line 2361
          if (glb.debug > 0) {
            {
#line 2361
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Writing boundary down",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2361);
            }
          }
          {
#line 2362
          fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
                  line);
#line 2363
          last_boundary_written = 1;
          }
        }
      } else {
#line 2295
        goto _L___1;
      }
    } else {
#line 2295
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2367
  if (glb.debug > 0) {
    {
#line 2367
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Conditions not right to insert a TEXT disclaimer",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2367);
    }
  }
#line 2374
  if (glb.debug > 0) {
    {
#line 2374
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: glb.HTML_too=%d, dd->html_inserted=%d, dd->content_type=%d, dd->isfile=%d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2375, glb.HTML_too,
               dd->html_inserted, dd->content_type, dd->isfile);
    }
  }
#line 2382
  if (glb.HTML_too) {
#line 2382
    if (0 == dd->html_inserted) {
#line 2382
      if (dd->content_type == 203) {
#line 2382
        if (dd->isfile == 0) {
#line 2388
          if (glb.debug > 0) {
            {
#line 2388
            LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Conditions potentially right for HTML disclaimer to be added",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2388);
            }
          }
          {
#line 2390
          result = AM_add_disclaimer_insert_html(dd, f, newf);
          }
#line 2391
          if (glb.verbose) {
#line 2391
            if (0 == result) {
              {
#line 2393
              LOGGER_log((char *)"WARNING: Could not insert HTML disclaimer into email");
              }
            } else {
#line 2395
              dd->html_inserted = 1;
#line 2396
              insert_success = 1;
            }
          } else {
#line 2395
            dd->html_inserted = 1;
#line 2396
            insert_success = 1;
          }
        } else {
#line 2382
          goto _L___4;
        }
      } else {
#line 2382
        goto _L___4;
      }
    } else {
#line 2382
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2399
  if (glb.debug > 0) {
    {
#line 2399
    LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Conditions not right to insert HTML disclaimer",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2399);
    }
  }
#line 2403
  if (insert_success == 0) {
    {
#line 2404
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2404
      tmp___10 = FFGET_fgets(line, 1024, f);
      }
#line 2404
      if (! tmp___10) {
#line 2404
        goto while_break___1;
      }
      {
#line 2405
      last_boundary_written = 0;
#line 2406
      fprintf((FILE */* __restrict  */)newf, (char const   */* __restrict  */)"%s",
              line);
#line 2407
      tmp___8 = strlen((char const   *)(line));
#line 2407
      tmp___9 = BS_cmp(line, (int )tmp___8);
      }
#line 2407
      if (tmp___9 == 1) {
#line 2408
        if (glb.debug > 0) {
          {
#line 2408
          LOGGER_log((char *)"%s:%d:AM_insert_disclaimer_into_segment:DEBUG: Boundary hit, breaking out",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2408);
          }
        }
#line 2409
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2414
  return (0);
}
}
#line 2426 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_add_disclaimer(char *mpackname ) 
{ 
  FILE *mp ;
  FILE *newf ;
  FFGET_FILE f ;
  char line[1025] ;
  unsigned int tmp ;
  char mpacktmp[1025] ;
  unsigned int tmp___0 ;
  char mpackold[1025] ;
  unsigned int tmp___1 ;
  struct AM_disclaimer_details dd ;
  int result ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int depth ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 2430
  line[0] = (char )'\000';
#line 2430
  tmp = 1U;
  {
#line 2430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2430
    if (tmp >= 1025U) {
#line 2430
      goto while_break;
    }
#line 2430
    line[tmp] = (char)0;
#line 2430
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2431
  mpacktmp[0] = (char )'\000';
#line 2431
  tmp___0 = 1U;
  {
#line 2431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2431
    if (tmp___0 >= 1025U) {
#line 2431
      goto while_break___0;
    }
#line 2431
    mpacktmp[tmp___0] = (char)0;
#line 2431
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2432
  mpackold[0] = (char )'\000';
#line 2432
  tmp___1 = 1U;
  {
#line 2432
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2432
    if (tmp___1 >= 1025U) {
#line 2432
      goto while_break___1;
    }
#line 2432
    mpackold[tmp___1] = (char)0;
#line 2432
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2434
  result = 0;
#line 2437
  snprintf((char */* __restrict  */)(mpacktmp), (size_t )1024, (char const   */* __restrict  */)"%s.tmp",
           mpackname);
#line 2438
  snprintf((char */* __restrict  */)(mpackold), (size_t )1024, (char const   */* __restrict  */)"%s.old",
           mpackname);
#line 2440
  altermime_status_flags = 0U;
#line 2442
  tmp___2 = strcmp((char const   *)mpackname, "-");
  }
#line 2442
  if (tmp___2 == 0) {
#line 2444
    mp = stdin;
#line 2445
    newf = stdout;
  } else {
    {
#line 2448
    newf = fopen((char const   */* __restrict  */)(mpacktmp), (char const   */* __restrict  */)"w");
#line 2449
    mp = fopen((char const   */* __restrict  */)mpackname, (char const   */* __restrict  */)"r");
    }
  }
  {
#line 2453
  BS_init();
#line 2455
  BS_set_hold_limit(10);
  }
#line 2459
  if (! newf) {
    {
#line 2461
    tmp___3 = __errno_location();
#line 2461
    tmp___4 = strerror(*tmp___3);
#line 2461
    LOGGER_log((char *)"AM_add_disclaimer: Cannot open %s, %s", mpacktmp, tmp___4);
    }
#line 2462
    return (-1);
  }
#line 2465
  if (! mp) {
    {
#line 2467
    tmp___5 = __errno_location();
#line 2467
    tmp___6 = strerror(*tmp___5);
#line 2467
    LOGGER_log((char *)"AM_add_disclaimer: Cannot open %s, %s", mpacktmp, tmp___6);
    }
#line 2468
    return (-1);
  }
  {
#line 2474
  result = AM_load_disclaimers(& dd);
  }
#line 2475
  if (result == -1) {
#line 2475
    return (0);
  }
  {
#line 2479
  dd.content_type = 0;
#line 2480
  dd.content_encoding = 0;
#line 2481
  dd.boundary_found = 0;
#line 2482
  memset((void *)(dd.boundary), 0, sizeof(dd.boundary));
#line 2483
  dd.ishtml = 0;
#line 2484
  dd.isfile = 0;
#line 2485
  dd.text_inserted = 0;
#line 2486
  dd.html_inserted = 0;
#line 2487
  dd.b64_inserted = 0;
  }
#line 2490
  if (glb.verbose > 0) {
    {
#line 2490
    LOGGER_log((char *)"Attempting to add disclaimer");
    }
  }
  {
#line 2492
  FFGET_setstream(& f, mp);
  }
#line 2530
  if (glb.debug > 0) {
    {
#line 2530
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Reading main headers", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               2530);
    }
  }
  {
#line 2532
  result = AM_read_headers(& dd, & f, newf);
  }
#line 2533
  if (glb.debug > 0) {
    {
#line 2533
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Main Headers have been read",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2533);
    }
  }
#line 2538
  if (dd.content_encoding == 100) {
#line 2540
    if (dd.content_type == 203) {
#line 2540
      goto _L;
    } else
#line 2540
    if (dd.content_type == 201) {
      _L: /* CIL Label */ 
#line 2556
      if (glb.debug > 0) {
        {
#line 2556
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: B64 encoded body text(s)",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2556);
        }
      }
    } else {
      {
#line 2562
      AM_add_disclaimer_flush(& f, newf);
#line 2564
      fclose(newf);
#line 2565
      remove((char const   *)(mpacktmp));
      }
#line 2567
      if (glb.verbose > 0) {
        {
#line 2567
        LOGGER_log((char *)"Email is BASE64 encoded, we cannot insert into these emails\n");
        }
      }
#line 2568
      return (12);
    }
  }
#line 2575
  if (10 == result) {
#line 2575
    goto _L___0;
  } else
#line 2575
  if (-1 == result) {
    _L___0: /* CIL Label */ 
    {
#line 2577
    AM_add_disclaimer_flush(& f, newf);
#line 2578
    fclose(mp);
#line 2579
    fclose(newf);
#line 2580
    remove((char const   *)(mpacktmp));
    }
#line 2581
    if (glb.verbose > 0) {
      {
#line 2581
      LOGGER_log((char *)"Email is signed with a crypto, we do not alter these emails\n");
      }
    }
#line 2582
    return (10);
  }
#line 2589
  if (0 == dd.boundary_found) {
#line 2589
    if (0 == dd.isfile) {
#line 2594
      if (glb.debug > 0) {
        {
#line 2594
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Inserting disclaimer into an email with no boundary",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2594);
        }
      }
      {
#line 2595
      result = AM_add_disclaimer_no_boudary(& f, newf, & dd);
      }
#line 2596
      if (glb.debug > 0) {
        {
#line 2596
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Inserting done, txt-inserted=%d html-inserted=%d",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2597,
                   dd.text_inserted, dd.html_inserted);
        }
      }
    }
  }
#line 2618
  if (dd.boundary_found == 1) {
    {
#line 2620
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2625
      tmp___7 = FFGET_feof(& f);
      }
#line 2625
      if (tmp___7) {
#line 2625
        goto while_break___2;
      }
#line 2630
      if (glb.debug > 0) {
        {
#line 2630
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Inserting into a MIME email\n",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2630);
        }
      }
#line 2638
      if (glb.debug > 0) {
        {
#line 2638
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Reading spurilous data before first MIME segment\n",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2638);
        }
      }
      {
#line 2640
      AM_read_to_boundary(& f, newf, line, (size_t )1024);
#line 2641
      tmp___8 = FFGET_feof(& f);
      }
#line 2641
      if (tmp___8) {
#line 2643
        if (glb.debug > 0) {
          {
#line 2643
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: End of file is reached, pulling out early",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2643);
          }
        }
#line 2644
        goto while_break___2;
      }
      {
#line 2649
      tmp___9 = AM_read_headers(& dd, & f, newf);
      }
#line 2649
      if (tmp___9 == 0) {
#line 2653
        if (dd.boundary_found == 1) {
#line 2653
          if (dd.content_type != 500) {
#line 2655
            if (glb.debug > 0) {
              {
#line 2655
              LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Located a new non-RFC822 boundary, adding to list\n",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2655);
              }
            }
          }
        }
#line 2659
        if (glb.debug > 0) {
          {
#line 2659
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: inserting into SEGMENT 1",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2659);
          }
        }
        {
#line 2660
        AM_insert_disclaimer_into_segment(& f, newf, & dd);
        }
#line 2661
        if (glb.debug > 0) {
          {
#line 2661
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Finished inserting into SEGMENT 1",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2661);
          }
        }
      } else
#line 2663
      if (glb.debug > 0) {
        {
#line 2663
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer: Cannot read headers for SEGMENT 1",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2663);
        }
      }
      {
#line 2668
      tmp___10 = AM_read_headers(& dd, & f, newf);
      }
#line 2668
      if (tmp___10 == 0) {
#line 2672
        if (dd.boundary_found == 1) {
#line 2672
          if (dd.content_type != 500) {
#line 2674
            if (glb.debug > 0) {
              {
#line 2674
              LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Located a new non-RFC822 boundary, adding to list\n",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2674);
              }
            }
          }
        }
#line 2677
        if (glb.debug > 0) {
          {
#line 2677
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: inserting into SEGMENT 2",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2677);
          }
        }
        {
#line 2678
        AM_insert_disclaimer_into_segment(& f, newf, & dd);
        }
#line 2679
        if (glb.debug > 0) {
          {
#line 2679
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Finished inserting into SEGMENT 2",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2679);
          }
        }
      } else
#line 2681
      if (glb.debug > 0) {
        {
#line 2681
        LOGGER_log((char *)"%s:%d:AM_add_disclaimer: Cannot read headers for SEGMENT 2",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2681);
        }
      }
#line 2686
      depth = 0;
      {
#line 2687
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 2692
        tmp___11 = AM_read_headers(& dd, & f, newf);
        }
#line 2692
        if (tmp___11 == 0) {
#line 2696
          if (dd.boundary_found == 1) {
#line 2696
            if (dd.content_type != 500) {
#line 2698
              if (glb.debug > 0) {
                {
#line 2698
                LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Located a new non-RFC822 boundary, adding to list\n",
                           "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                           2698);
                }
              }
            }
          }
#line 2701
          if (dd.content_type == 500) {
#line 2702
            if (glb.debug > 0) {
              {
#line 2702
              LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Located RFC822 type of header, so no more attempts to insert disclaimers",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         2702);
              }
            }
#line 2703
            goto while_break___3;
          }
#line 2706
          if (glb.debug > 0) {
            {
#line 2706
            LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: inserting into SEGMENT %d",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2706, 3 + depth);
            }
          }
          {
#line 2707
          AM_insert_disclaimer_into_segment(& f, newf, & dd);
          }
#line 2708
          if (glb.debug > 0) {
            {
#line 2708
            LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Finished inserting into SEGMENT %d",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       2708, 3 + depth);
            }
          }
        } else
#line 2710
        if (glb.debug > 0) {
          {
#line 2710
          LOGGER_log((char *)"%s:%d:AM_add_disclaimer: Cannot read headers for SEGMENT %d",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2710,
                     3 + depth);
          }
        }
#line 2687
        if (dd.html_inserted == 0) {
#line 2687
          tmp___12 = depth;
#line 2687
          depth ++;
#line 2687
          if (! (tmp___12 < 3)) {
#line 2687
            goto while_break___3;
          }
        } else {
#line 2687
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2620
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2720
  AM_add_disclaimer_flush(& f, newf);
  }
#line 2723
  if (glb.verbose > 0) {
    {
#line 2723
    LOGGER_log((char *)"Done.\n");
    }
  }
  {
#line 2726
  AM_add_disclaimer_cleanup(mp, newf, mpacktmp, mpackname);
  }
#line 2730
  if (glb.disclaimer_plain_type == 1) {
#line 2730
    if (dd.disclaimer_text_plain) {
      {
#line 2732
      free((void *)dd.disclaimer_text_plain);
      }
    }
  }
#line 2735
  if (glb.disclaimer_HTML_type == 1) {
#line 2735
    if (dd.disclaimer_text_HTML) {
      {
#line 2737
      free((void *)dd.disclaimer_text_HTML);
      }
    }
  }
#line 2740
  if (glb.debug > 0) {
    {
#line 2740
    LOGGER_log((char *)"%s:%d:AM_add_disclaimer:DEBUG: Inserting done, txt-inserted=%d html-inserted=%d b64-inserted=%d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2741, dd.text_inserted,
               dd.html_inserted, dd.b64_inserted);
    }
  }
#line 2747
  altermime_status_flags |= (unsigned int )(((dd.text_inserted << 1) | (dd.html_inserted << 2)) | (dd.b64_inserted << 3));
#line 2749
  return (result);
}
}
#line 2766 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_filename_fix(char *line , char *removed_prefix , int removed_count ) 
{ 
  char *pos ;
  char lline[1024] ;

  {
  {
#line 2773
  pos = strrchr((char const   *)line, '=');
#line 2774
  pos ++;
#line 2775
  *pos = (char )'\000';
#line 2777
  sprintf((char */* __restrict  */)(lline), (char const   */* __restrict  */)"%s\"%s%d\"\n",
          line, removed_prefix, removed_count);
#line 2778
  strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)(lline));
  }
#line 2780
  return (0);
}
}
#line 2799 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_headers_remove_header(char *headers , char *header_name ) 
{ 
  char delimeter_size ;
  char *segment_start ;
  char *segment_end ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 2805
  if (glb.debug > 0) {
    {
#line 2805
    LOGGER_log((char *)"%s:%d:AM_headers_remove_header:DEBUG: Removing %s", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               2805, header_name);
    }
  }
  {
#line 2807
  delimeter_size = (char)1;
#line 2808
  tmp = strstr((char const   *)headers, "\n\r");
  }
#line 2808
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2808
    delimeter_size = (char)2;
  }
  {
#line 2809
  tmp___0 = strstr((char const   *)headers, "\r\n");
  }
#line 2809
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 2809
    delimeter_size = (char)2;
  }
  {
#line 2811
  segment_start = PLD_strstr(headers, header_name, 1);
  }
#line 2812
  if ((unsigned long )segment_start == (unsigned long )((void *)0)) {
#line 2812
    return (1);
  }
  {
#line 2814
  tmp___1 = strlen((char const   *)header_name);
#line 2814
  segment_end = segment_start + tmp___1;
  }
  {
#line 2815
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2816
    segment_end = strpbrk((char const   *)segment_end, "\n\r");
    }
#line 2817
    if ((int )delimeter_size == 2) {
#line 2817
      segment_end += 2;
    } else {
#line 2817
      segment_end ++;
    }
#line 2815
    if (! ((int )*segment_end == 32)) {
#line 2815
      if (! ((int )*segment_end == 9)) {
#line 2815
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2820
  p = segment_end;
  {
#line 2821
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2821
    if (! *p) {
#line 2821
      goto while_break___0;
    }
#line 2823
    *segment_start = *p;
#line 2824
    segment_start ++;
#line 2825
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2828
  *segment_start = (char )'\000';
#line 2830
  return (0);
}
}
#line 2849 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_nullify_attachment_clean_headers(struct MIMEH_header_info *hinfo , char *headers ) 
{ 


  {
  {
#line 2852
  AM_headers_remove_header(headers, (char *)"content-type:");
#line 2853
  AM_headers_remove_header(headers, (char *)"content-disposition:");
#line 2854
  AM_headers_remove_header(headers, (char *)"content-transfer-encoding");
  }
#line 2868
  return (0);
}
}
#line 2890 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_nullify_attachment_recurse(struct MIMEH_header_info *hinfo , FFGET_FILE *f ,
                                  FILE *outputfile , regex_t *preg , int match_mode ,
                                  int iteration ) 
{ 
  int result ;
  size_t bc ;
  int regresult ;
  char *header_ptr ;
  char *original_ptr ;
  char buffer[1024] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int sl ;
  size_t tmp___2 ;
  int buffer_len ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 2892
  result = 0;
#line 2895
  if (glb.debug > 0) {
    {
#line 2895
    LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse: Checking segment-iteration \'%d\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2895, iteration);
    }
  }
  {
#line 2896
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2898
    regresult = 0;
#line 2899
    header_ptr = (char *)((void *)0);
#line 2900
    original_ptr = (char *)((void *)0);
#line 2903
    MIMEH_set_doubleCR_save(0);
#line 2904
    MIMEH_set_header_longsearch(glb.header_long_search);
#line 2905
    MIMEH_set_doubleCR_save(1);
    }
#line 2907
    if (glb.debug > 0) {
      {
#line 2907
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:DEBUG: Reading headers... Iteration %d",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2907);
      }
    }
    {
#line 2908
    result = MIMEH_headers_get(hinfo, f);
    }
#line 2909
    if (result != 0) {
#line 2911
      if (glb.debug > 0) {
        {
#line 2911
        LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:DEBUG: Failure during header read (EOF?), exiting loop",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2911);
        }
      }
#line 2912
      goto while_break;
    }
#line 2916
    if (hinfo->content_type == 106) {
#line 2916
      if (glb.alter_signed == 0) {
#line 2917
        if (glb.debug > 0) {
          {
#line 2917
          LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:DEBUG: Message is signed, exiting",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2917);
          }
        }
#line 2918
        return (0);
      }
    }
    {
#line 2921
    original_ptr = MIMEH_get_headers_original_ptr();
#line 2922
    header_ptr = MIMEH_get_headers_ptr();
    }
#line 2924
    if (glb.debug > 0) {
      {
#line 2924
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:DEBUG: Headers =\n%s\n-----------END OF HEADERS\n",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2924,
                 original_ptr);
      }
    }
#line 2926
    if ((unsigned long )original_ptr == (unsigned long )((void *)0)) {
      {
#line 2928
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:ERROR: Original headers came back NULL",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2928);
      }
#line 2929
      return (1);
    }
#line 2932
    if ((unsigned long )header_ptr == (unsigned long )((void *)0)) {
      {
#line 2934
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:ERROR: Header ptr (for processing) came back NULL",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2934);
      }
#line 2935
      return (1);
    }
    {
#line 2938
    result = MIMEH_headers_process(hinfo, header_ptr);
    }
#line 2939
    if (result != 0) {
      {
#line 2941
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment:ERROR: While processing headers for mailpack",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2941);
      }
#line 2942
      goto while_break;
    }
#line 2946
    if (hinfo->content_type >= 100) {
#line 2946
      if (hinfo->content_type <= 199) {
#line 2946
        if (hinfo->boundary_located > 0) {
          {
#line 2949
          BS_push(hinfo->boundary);
          }
        }
      }
    }
#line 2953
    regresult = 1;
    {
#line 2955
    if (match_mode == 1) {
#line 2955
      goto case_1;
    }
#line 2967
    if (match_mode == 2) {
#line 2967
      goto case_2;
    }
#line 2974
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2956
    tmp = strlen((char const   *)(hinfo->filename));
    }
#line 2956
    if (tmp > 0UL) {
      {
#line 2958
      regresult = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)(hinfo->filename),
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
      }
#line 2959
      if (glb.debug > 0) {
        {
#line 2959
        LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Match result=%d for \'%s\'",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2959,
                   regresult, hinfo->filename);
        }
      }
    }
#line 2961
    if (regresult != 0) {
      {
#line 2961
      tmp___0 = strlen((char const   *)(hinfo->name));
      }
#line 2961
      if (tmp___0 > 0UL) {
        {
#line 2963
        regresult = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)(hinfo->name),
                            (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                            0);
        }
#line 2964
        if (glb.debug > 0) {
          {
#line 2964
          LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Match result=%d for \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2964,
                     regresult, hinfo->name);
          }
        }
      }
    }
#line 2966
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2968
    tmp___1 = strlen((char const   *)(hinfo->content_type_string));
    }
#line 2968
    if (tmp___1 > 0UL) {
      {
#line 2970
      regresult = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)(hinfo->content_type_string),
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
      }
#line 2971
      if (glb.debug > 0) {
        {
#line 2971
        LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Match result=%d for \'%s\'",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2971,
                   regresult, hinfo->content_type_string);
        }
      }
    }
#line 2973
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2975
    LOGGER_log((char *)"%s:%d:AM_nullify_attachment: unknown Nullify match mode \'%d\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 2975, match_mode);
    }
    switch_break: /* CIL Label */ ;
    }
#line 2988
    if (regresult != 0) {
#line 2988
      goto _L;
    } else
#line 2988
    if (iteration == 1) {
      _L: /* CIL Label */ 
#line 2996
      if (iteration == 1) {
#line 2996
        if (regresult == 0) {
          {
#line 2998
          AM_nullify_attachment_clean_headers(hinfo, original_ptr);
          }
        }
      }
      {
#line 3001
      tmp___2 = strlen((char const   *)original_ptr);
#line 3001
      sl = (int )tmp___2;
#line 3003
      bc = fwrite((void const   */* __restrict  */)original_ptr, sizeof(char ), (size_t )sl,
                  (FILE */* __restrict  */)outputfile);
      }
#line 3004
      if (bc != (size_t )sl) {
        {
#line 3004
        LOGGER_log((char *)"%s:%d:AM_nullify_attachment_clean_headers:ERROR: Wrote %d bytes instead of %d",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3004,
                   bc, sl);
        }
      }
    }
    {
#line 3008
    result = MIMEH_headers_cleanup();
    }
#line 3009
    if (result != 0) {
      {
#line 3011
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment:ERROR: while attempting to clean up headers memory allocation",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3011);
      }
#line 3012
      goto while_break;
    }
#line 3017
    if (hinfo->content_type == 500) {
      {
#line 3019
      result = AM_nullify_attachment_recurse(hinfo, f, outputfile, preg, match_mode,
                                             1);
      }
    }
    {
#line 3023
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3023
      tmp___5 = FFGET_fgets(buffer, (int )sizeof(buffer), f);
      }
#line 3023
      if (! tmp___5) {
#line 3023
        goto while_break___0;
      }
      {
#line 3025
      tmp___3 = strlen((char const   *)(buffer));
#line 3025
      buffer_len = (int )tmp___3;
      }
#line 3027
      if (regresult != 0) {
        {
#line 3029
        bc = fwrite((void const   */* __restrict  */)(buffer), sizeof(char ), (size_t )buffer_len,
                    (FILE */* __restrict  */)outputfile);
        }
#line 3030
        if (bc != (size_t )buffer_len) {
          {
#line 3030
          LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:ERROR: Wrote %d bytes instead of %d",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3030,
                     bc, buffer_len);
          }
        }
      }
      {
#line 3033
      tmp___4 = BS_cmp(buffer, buffer_len);
      }
#line 3033
      if (tmp___4 == 1) {
#line 3034
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3038
    tmp___6 = FFGET_feof(f);
    }
#line 3038
    if (tmp___6) {
#line 3038
      goto while_break;
    }
#line 3040
    iteration ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3044
  return (0);
}
}
#line 3057 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_nullify_attachment(char *mpackname , char *attachmentname ) 
{ 
  struct MIMEH_header_info hinfo ;
  regex_t preg ;
  int result ;
  int match_mode ;
  char tmpfname[256] ;
  char oldfname[256] ;
  FILE *inputfile ;
  FILE *outputfile ;
  FFGET_FILE f ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 3061
  result = 0;
#line 3062
  match_mode = 0;
#line 3078
  if (glb.debug > 0) {
    {
#line 3078
    LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Starting nullification of file \'%s\' from mailpack \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3078, attachmentname,
               mpackname);
    }
  }
  {
#line 3079
  BS_init();
#line 3081
  tmp = strcmp((char const   *)mpackname, "-");
  }
#line 3081
  if (tmp == 0) {
#line 3082
    inputfile = stdin;
  } else {
    {
#line 3084
    inputfile = fopen((char const   */* __restrict  */)mpackname, (char const   */* __restrict  */)"r");
    }
  }
#line 3087
  if ((unsigned long )inputfile == (unsigned long )((void *)0)) {
    {
#line 3088
    tmp___0 = __errno_location();
#line 3088
    tmp___1 = strerror(*tmp___0);
#line 3088
    LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Unable to open mailpack \'%s\' for reading (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3088, mpackname,
               tmp___1);
    }
#line 3089
    return (1);
  }
  {
#line 3092
  snprintf((char */* __restrict  */)(tmpfname), sizeof(tmpfname), (char const   */* __restrict  */)"%s.tmp",
           mpackname);
#line 3094
  tmp___2 = strcmp((char const   *)mpackname, "-");
  }
#line 3094
  if (tmp___2 == 0) {
#line 3095
    outputfile = stdout;
  } else {
    {
#line 3097
    outputfile = fopen((char const   */* __restrict  */)(tmpfname), (char const   */* __restrict  */)"w");
    }
  }
#line 3100
  if ((unsigned long )outputfile == (unsigned long )((void *)0)) {
#line 3102
    if ((unsigned long )inputfile != (unsigned long )((void *)0)) {
      {
#line 3102
      fclose(inputfile);
      }
    }
    {
#line 3103
    tmp___3 = __errno_location();
#line 3103
    tmp___4 = strerror(*tmp___3);
#line 3103
    LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Unable to open temporary file \'%s\' for writing (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3103, tmpfname,
               tmp___4);
    }
#line 3104
    return (1);
  }
  {
#line 3107
  FFGET_setstream(& f, inputfile);
#line 3109
  MIMEH_set_headers_nosave();
#line 3110
  MIMEH_set_headers_save_original(1);
#line 3114
  tmp___5 = strchr((char const   *)attachmentname, '/');
  }
#line 3114
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 3115
    match_mode = 1;
  } else {
#line 3117
    match_mode = 2;
  }
  {
#line 3121
  result = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)attachmentname,
                   (1 | (1 << 1)) | (((1 << 1) << 1) << 1));
  }
#line 3122
  if (result != 0) {
    {
#line 3124
    LOGGER_log((char *)"%s:%d:AM_nullify_attachment: Unable to compile regular expression \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3124, attachmentname);
    }
#line 3125
    return (0);
  }
  {
#line 3128
  SS_init(& hinfo.ss_filenames);
#line 3129
  SS_init(& hinfo.ss_names);
#line 3130
  result = AM_nullify_attachment_recurse(& hinfo, & f, outputfile, & preg, match_mode,
                                         1);
#line 3132
  MIMEH_set_headers_save_original(0);
#line 3134
  regfree(& preg);
#line 3135
  FFGET_closestream(& f);
#line 3136
  fclose(inputfile);
#line 3137
  fclose(outputfile);
#line 3139
  snprintf((char */* __restrict  */)(oldfname), sizeof(oldfname), (char const   */* __restrict  */)"%s.old",
           mpackname);
#line 3141
  tmp___12 = strcmp((char const   *)mpackname, "-");
  }
#line 3141
  if (tmp___12 != 0) {
    {
#line 3143
    result = rename((char const   *)mpackname, (char const   *)(oldfname));
    }
#line 3145
    if (result != 0) {
      {
#line 3147
      tmp___6 = __errno_location();
#line 3147
      tmp___7 = strerror(*tmp___6);
#line 3147
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:ERROR: Unable to rename original mailpack \'%s\' to \'%s\' (%s)",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3147,
                 mpackname, oldfname, tmp___7);
      }
#line 3148
      return (1);
    }
    {
#line 3151
    result = rename((char const   *)(tmpfname), (char const   *)mpackname);
    }
#line 3152
    if (result != 0) {
      {
#line 3154
      tmp___8 = __errno_location();
#line 3154
      tmp___9 = strerror(*tmp___8);
#line 3154
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:ERROR: Unable to rename temporary mailpack \'%s\' to \'%s\' (%s)",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3154,
                 tmpfname, mpackname, tmp___9);
      }
#line 3155
      return (1);
    }
    {
#line 3158
    result = unlink((char const   *)(oldfname));
    }
#line 3159
    if (result != 0) {
      {
#line 3161
      tmp___10 = __errno_location();
#line 3161
      tmp___11 = strerror(*tmp___10);
#line 3161
      LOGGER_log((char *)"%s:%d:AM_nullify_attachment_recurse:ERROR: Unable to unlink/remove \'%s\' (%s)",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3161,
                 oldfname, tmp___11);
      }
#line 3162
      return (1);
    }
  }
  {
#line 3167
  BS_clear();
  }
#line 3169
  return (result);
}
}
#line 3181 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_insert_Xheader(char *fname , char *xheader ) 
{ 
  char line[1025] ;
  char tpn[1025] ;
  int header_written ;
  int result ;
  struct stat st ;
  FFGET_FILE f ;
  FILE *fi ;
  FILE *fo ;
  size_t tmp ;
  size_t tmp___0 ;
  char *p ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 3188
  header_written = 0;
#line 3189
  result = 0;
#line 3201
  if (! fname) {
    {
#line 3202
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Filename is NULL", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               3202);
    }
#line 3203
    return (1);
  }
#line 3206
  if (! xheader) {
    {
#line 3207
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Xheader to insert is NULL",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3207);
    }
#line 3208
    return (1);
  }
  {
#line 3211
  tmp = strlen((char const   *)fname);
  }
#line 3211
  if (tmp < 1UL) {
    {
#line 3212
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Filename is too short", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               3212);
    }
#line 3213
    return (1);
  }
  {
#line 3216
  tmp___0 = strlen((char const   *)xheader);
  }
#line 3216
  if (tmp___0 < 1UL) {
    {
#line 3217
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Header to insert is too short",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3217);
    }
#line 3218
    return (1);
  }
  {
#line 3225
  p = strpbrk((char const   *)xheader, "\r\n");
  }
#line 3226
  if (p) {
#line 3226
    *p = (char )'\000';
  }
  {
#line 3233
  snprintf((char */* __restrict  */)(tpn), (size_t )1024, (char const   */* __restrict  */)"%s",
           fname);
  }
  {
#line 3235
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3236
    tmp___1 = strlen((char const   *)(tpn));
    }
#line 3236
    if (tmp___1 < sizeof(tpn) - 2UL) {
      {
#line 3242
      strcat((char */* __restrict  */)(tpn), (char const   */* __restrict  */)"X");
      }
    } else {
      {
#line 3245
      LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Temporary file name string buffer out of space!",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3245);
      }
#line 3246
      return (1);
    }
    {
#line 3235
    tmp___2 = stat((char const   */* __restrict  */)(tpn), (struct stat */* __restrict  */)(& st));
    }
#line 3235
    if (! (0 == tmp___2)) {
#line 3235
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3261
  fo = fopen((char const   */* __restrict  */)(tpn), (char const   */* __restrict  */)"w");
  }
#line 3262
  if (! fo) {
    {
#line 3264
    tmp___3 = __errno_location();
#line 3264
    tmp___4 = strerror(*tmp___3);
#line 3264
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Cannot open temporary file, \'%s\' for writing (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3264, tpn,
               tmp___4);
    }
#line 3265
    return (1);
  }
  {
#line 3270
  fi = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 3271
  if (! fi) {
    {
#line 3273
    tmp___5 = __errno_location();
#line 3273
    tmp___6 = strerror(*tmp___5);
#line 3273
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: Cannot open Mailpack file \'%s\' for reading, (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3273, fname,
               tmp___6);
    }
#line 3274
    return (2);
  }
  {
#line 3281
  FFGET_setstream(& f, fi);
#line 3282
  f.trueblank = 0;
  }
  {
#line 3290
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3290
    tmp___7 = FFGET_fgets(line, 1024, & f);
    }
#line 3290
    if (! tmp___7) {
#line 3290
      goto while_break___0;
    }
#line 3298
    if (0 != f.trueblank) {
#line 3298
      if (0 == header_written) {
        {
#line 3303
        fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s%s",
                xheader, line);
#line 3304
        header_written = 1;
        }
      }
    }
    {
#line 3311
    fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s", line);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3316
  FFGET_closestream(& f);
#line 3318
  fclose(fo);
#line 3319
  fclose(fi);
#line 3330
  tmp___10 = rename((char const   *)(tpn), (char const   *)fname);
  }
#line 3330
  if (tmp___10 == -1) {
    {
#line 3332
    result = 1;
#line 3333
    tmp___8 = __errno_location();
#line 3333
    tmp___9 = strerror(*tmp___8);
#line 3333
    LOGGER_log((char *)"%s:%d:AM_insert_Xheader:ERROR: while attempting to rename \'%s\' to \'%s\' (%s) ",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3333, tpn,
               fname, tmp___9);
    }
  }
#line 3336
  if (header_written) {
#line 3336
    altermime_status_flags |= (unsigned int )(1 << 4);
  }
#line 3338
  return (result);
}
}
#line 3352 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_alter_header(char *filename , char *header , char *change , int change_mode ) 
{ 
  char line[1025] ;
  char tpn[1025] ;
  int main_headers_complete ;
  int header_written ;
  int result ;
  struct stat st ;
  FFGET_FILE f ;
  FILE *fi ;
  FILE *fo ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int line_written ;
  char *p ;
  char low_line[1025] ;
  char *first_colon_position ;
  char *header_start ;
  char *header_end ;
  char startc ;
  char finishc ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 3357
  main_headers_complete = 0;
#line 3358
  header_written = 0;
#line 3359
  result = 0;
#line 3369
  if (glb.debug > 0) {
    {
#line 3369
    LOGGER_log((char *)"%s:%d:AM_alter_header:DEBUG: Start [ %s, %s, %s, %d ]", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               3369, filename, header, change, change_mode);
    }
  }
  {
#line 3371
  snprintf((char */* __restrict  */)(tpn), (size_t )1024, (char const   */* __restrict  */)"%s",
           filename);
  }
  {
#line 3373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3374
    tmp = strlen((char const   *)(tpn));
    }
#line 3374
    if (tmp < sizeof(tpn) - 2UL) {
      {
#line 3376
      strcat((char */* __restrict  */)(tpn), (char const   */* __restrict  */)"X");
      }
    } else {
      {
#line 3380
      LOGGER_log((char *)"%s:%d:AM_header_adjust:ERROR: Temporary file name string buffer out of space!\n",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3380);
      }
#line 3381
      return (1);
    }
    {
#line 3373
    tmp___0 = stat((char const   */* __restrict  */)(tpn), (struct stat */* __restrict  */)(& st));
    }
#line 3373
    if (! (0 == tmp___0)) {
#line 3373
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3386
  if (glb.debug > 0) {
    {
#line 3386
    LOGGER_log((char *)"%s:%d:AM_alter_header:DEBUG: Temporary filename = %s", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               3386, tpn);
    }
  }
  {
#line 3397
  fo = fopen((char const   */* __restrict  */)(tpn), (char const   */* __restrict  */)"w");
  }
#line 3398
  if (! fo) {
    {
#line 3400
    tmp___1 = __errno_location();
#line 3400
    tmp___2 = strerror(*tmp___1);
#line 3400
    LOGGER_log((char *)"%s:%d:AM_header_adjust:ERROR: Cannot open temporary file \'%s\' for writing",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3400, tpn,
               tmp___2);
    }
#line 3401
    return (1);
  }
  {
#line 3405
  fi = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 3406
  if (! fi) {
    {
#line 3408
    tmp___3 = __errno_location();
#line 3408
    tmp___4 = strerror(*tmp___3);
#line 3408
    LOGGER_log((char *)"%s:%d:AM_header_adjust:ERROR: Cannot open Mailpack file for reading, %s",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3408, filename,
               tmp___4);
    }
#line 3409
    return (2);
  }
  {
#line 3414
  FFGET_setstream(& f, fi);
#line 3419
  PLD_strlower(header);
  }
#line 3426
  if (glb.debug > 0) {
    {
#line 3426
    LOGGER_log((char *)"%s:%d:AM_header_adjust:DEBUG: Starting seek through file. header_written = %d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3426, header_written);
    }
  }
  {
#line 3427
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3427
    tmp___5 = FFGET_fgets(line, 1024, & f);
    }
#line 3427
    if (! tmp___5) {
#line 3427
      goto while_break___0;
    }
#line 3429
    line_written = 0;
#line 3435
    if (main_headers_complete == 0) {
#line 3435
      if (f.trueblank == 1) {
#line 3435
        main_headers_complete = 1;
      }
    }
#line 3447
    if (main_headers_complete == 0) {
#line 3447
      if (header_written == 0) {
#line 3452
        if (glb.debug > 0) {
          {
#line 3452
          LOGGER_log((char *)"%s:%d:AM_header_adjust: line=%s", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                     3452, line);
          }
        }
        {
#line 3457
        snprintf((char */* __restrict  */)(low_line), (size_t )1024, (char const   */* __restrict  */)"%s",
                 line);
#line 3458
        PLD_strlower(low_line);
#line 3460
        p = strstr((char const   *)(low_line), (char const   *)header);
        }
#line 3461
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 3470
          first_colon_position = strchr((char const   *)(low_line), ':');
          }
#line 3471
          if ((unsigned long )p < (unsigned long )first_colon_position) {
#line 3479
            p = line + (p - low_line);
#line 3481
            if (glb.debug > 0) {
              {
#line 3481
              LOGGER_log((char *)"%s:%d:AM_header_adjust:DEBUG: Located header line",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         3481);
              }
            }
            {
#line 3482
            header_start = strchr((char const   *)p, ':');
            }
#line 3483
            if ((unsigned long )header_start == (unsigned long )((void *)0)) {
              {
#line 3485
              LOGGER_log((char *)"%s:%d:AM_header_adjust:WARNING: Could not locate terminating \':\' character on header name (%s)",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         3485, p);
              }
#line 3486
              goto while_continue___0;
            }
            {
#line 3488
            header_start ++;
#line 3489
            startc = *header_start;
#line 3491
            header_end = strpbrk((char const   *)header_start, "\r\n;");
            }
#line 3492
            if ((unsigned long )header_end == (unsigned long )((void *)0)) {
              {
#line 3494
              LOGGER_log((char *)"%s:%d:AM_header_adjust:WARNING: Could not locate end of header value (%s)",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         3494, header_start);
              }
#line 3495
              goto while_continue___0;
            }
#line 3497
            finishc = *header_end;
            {
#line 3503
            if (change_mode == 1) {
#line 3503
              goto case_1;
            }
#line 3510
            if (change_mode == 2) {
#line 3510
              goto case_2;
            }
#line 3517
            if (change_mode == 4) {
#line 3517
              goto case_4;
            }
#line 3525
            goto switch_default;
            case_1: /* CIL Label */ 
            {
#line 3504
            *header_start = (char )'\000';
#line 3505
            fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s %s%c%s",
                    line, change, (int )startc, header_start + 1);
#line 3506
            header_written = 1;
#line 3507
            line_written = 1;
            }
#line 3508
            if (glb.debug > 0) {
              {
#line 3508
              LOGGER_log((char *)"%s:%d:AM_header_adjust:DEBUG: Prefix mode output written",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         3508);
              }
            }
#line 3509
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 3511
            *header_end = (char )'\000';
#line 3512
            fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s %s%c%s",
                    line, change, (int )finishc, header_end + 1);
#line 3513
            header_written = 1;
#line 3514
            line_written = 1;
            }
#line 3515
            if (glb.debug > 0) {
              {
#line 3515
              LOGGER_log((char *)"%s:%d:AM_header_adjust:DEBUG: Suffix mode output written",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         3515);
              }
            }
#line 3516
            goto switch_break;
            case_4: /* CIL Label */ 
            {
#line 3518
            *header_start = (char )'\000';
#line 3519
            fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s %s%s",
                    line, change, header_end);
#line 3520
            header_written = 1;
#line 3521
            line_written = 1;
            }
#line 3522
            if (glb.debug > 0) {
              {
#line 3522
              LOGGER_log((char *)"%s:%d:AM_header_adjust:DEBUG: Replace mode output written",
                         "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                         3522);
              }
            }
#line 3523
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 3526
            LOGGER_log((char *)"%s:%d:AM_header_adjust:ERROR: Unknown header adjustment mode \'%d\'",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       3526, change_mode);
            }
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 3537
    if (line_written == 0) {
      {
#line 3537
      fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%s",
              line);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3543
  fclose(fo);
#line 3544
  fclose(fi);
#line 3555
  tmp___8 = rename((char const   *)(tpn), (char const   *)filename);
  }
#line 3555
  if (tmp___8 == -1) {
    {
#line 3557
    result = 1;
#line 3558
    tmp___6 = __errno_location();
#line 3558
    tmp___7 = strerror(*tmp___6);
#line 3558
    LOGGER_log((char *)"%s:%d:AM_header_adjust:ERROR: while attempting to rename \'%s\' to \'%s\' (%s) ",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3558, tpn,
               filename, tmp___7);
    }
  }
#line 3561
  return (result);
}
}
#line 3587 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_attachment_replace_header_filter(struct MIMEH_header_info *hinfo , char *new_attachment_name ,
                                        char **headers ) 
{ 
  struct PLD_strreplace replace ;
  char CTE_string[256] ;
  size_t tmp ;

  {
#line 3595
  if (glb.debug > 0) {
    {
#line 3595
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_header_filter:DEBUG: Start.",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3595);
    }
  }
  {
#line 3596
  replace.source = *headers;
#line 3597
  replace.searchfor = hinfo->filename;
#line 3598
  replace.replacewith = new_attachment_name;
#line 3599
  replace.replacenumber = 1;
#line 3600
  replace.insensitive = 1;
#line 3601
  replace.postexist = (char *)((void *)0);
#line 3603
  replace.preexist = (char *)"content-type:";
#line 3604
  *headers = PLD_strreplace_general(& replace);
#line 3606
  replace.source = *headers;
#line 3607
  replace.preexist = (char *)"content-disposition:";
#line 3608
  *headers = PLD_strreplace_general(& replace);
  }
#line 3613
  if (hinfo->content_transfer_encoding != 100) {
    {
#line 3615
    tmp = strlen((char const   *)(hinfo->content_transfer_encoding_string));
    }
#line 3615
    if (tmp < 1UL) {
      {
#line 3619
      snprintf((char */* __restrict  */)(CTE_string), sizeof(CTE_string), (char const   */* __restrict  */)"Content-Transfer-Encoding: base64\nContent-Type:");
#line 3620
      replace.preexist = (char *)((void *)0);
#line 3621
      replace.source = *headers;
#line 3622
      replace.searchfor = (char *)"content-type:";
#line 3623
      replace.replacewith = CTE_string;
#line 3624
      *headers = PLD_strreplace_general(& replace);
      }
    } else {
      {
#line 3626
      replace.preexist = (char *)"content-transfer-encoding:";
#line 3627
      replace.source = *headers;
#line 3628
      replace.searchfor = hinfo->content_transfer_encoding_string;
#line 3629
      replace.replacewith = (char *)"base64";
#line 3630
      *headers = PLD_strreplace_general(& replace);
      }
    }
  }
#line 3634
  if (glb.debug > 0) {
    {
#line 3634
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_header_filter:DEBUG: End.", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               3634);
    }
  }
#line 3636
  return (0);
}
}
#line 3658 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_attachment_replace_write_data(char *new_attachment_name , FILE *outputfile ,
                                     char *delimeter ) 
{ 
  int result ;
  FILE *newatt ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 3660
  result = 0;
#line 3663
  newatt = fopen((char const   */* __restrict  */)new_attachment_name, (char const   */* __restrict  */)"r");
  }
#line 3664
  if ((unsigned long )newatt == (unsigned long )((void *)0)) {
    {
#line 3666
    tmp = __errno_location();
#line 3666
    tmp___0 = strerror(*tmp);
#line 3666
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_write_data:ERROR: Could not open \'%s\' for reading to insert into mailpack (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3667, new_attachment_name,
               tmp___0);
    }
#line 3668
    return (1);
  }
#line 3670
  if (glb.debug > 0) {
    {
#line 3670
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_write_data:DEBUG: Writing out new attachment data",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3670);
    }
  }
  {
#line 3671
  AM_base64_encodef(newatt, outputfile);
#line 3672
  fprintf((FILE */* __restrict  */)outputfile, (char const   */* __restrict  */)"%s%s",
          delimeter, delimeter);
  }
#line 3673
  if (glb.debug > 0) {
    {
#line 3673
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_write_data:DEBUG: done.", "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
               3673);
    }
  }
#line 3675
  return (result);
}
}
#line 3696 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_attachment_replace_recurse(struct MIMEH_header_info *hinfo , FFGET_FILE *f ,
                                  FILE *outputfile , regex_t *preg , char *new_attachment_name ,
                                  int iteration ) 
{ 
  int result ;
  size_t bc ;
  int regresult ;
  int attachment_data_written ;
  char *header_ptr ;
  char *original_ptr ;
  char buffer[1024] ;
  size_t tmp ;
  int bl ;
  size_t tmp___0 ;
  char *new_attachment_filename ;
  char *duplicate_headers ;
  int buflen ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3698
  result = 0;
#line 3701
  if (glb.debug > 0) {
    {
#line 3701
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Starting: iteration=%d",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3701, iteration);
    }
  }
  {
#line 3702
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3704
    regresult = 0;
#line 3705
    attachment_data_written = 0;
#line 3706
    header_ptr = (char *)((void *)0);
#line 3707
    original_ptr = (char *)((void *)0);
#line 3714
    MIMEH_set_doubleCR_save(0);
#line 3715
    result = MIMEH_headers_get(hinfo, f);
#line 3716
    MIMEH_set_doubleCR_save(1);
    }
#line 3717
    if (result != 0) {
#line 3719
      goto while_break;
    }
#line 3725
    if (hinfo->content_type == 106) {
#line 3725
      if (glb.alter_signed == 0) {
#line 3727
        return (0);
      }
    }
#line 3731
    if (glb.debug > 0) {
      {
#line 3731
      LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Headers read, now processing",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3731);
      }
    }
    {
#line 3733
    original_ptr = MIMEH_get_headers_original_ptr();
#line 3734
    header_ptr = MIMEH_get_headers_ptr();
    }
#line 3736
    if (glb.debug > 0) {
      {
#line 3736
      LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Headers=\n%s\n",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3736,
                 original_ptr);
      }
    }
#line 3738
    if ((unsigned long )original_ptr == (unsigned long )((void *)0)) {
      {
#line 3740
      LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Original headers came back NULL",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3740);
      }
#line 3741
      return (1);
    }
#line 3744
    if ((unsigned long )header_ptr == (unsigned long )((void *)0)) {
      {
#line 3746
      LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Header ptr (for processing) came back NULL",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3746);
      }
#line 3747
      return (1);
    }
    {
#line 3755
    result = MIMEH_headers_process(hinfo, header_ptr);
    }
#line 3756
    if (result != 0) {
      {
#line 3758
      LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: While processing headers for mailpack",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3758);
      }
#line 3759
      goto while_break;
    }
#line 3770
    if (hinfo->content_type == 500) {
#line 3770
      goto _L;
    } else
#line 3770
    if (hinfo->content_type >= 100) {
#line 3770
      if (hinfo->content_type <= 199) {
        _L: /* CIL Label */ 
#line 3770
        if (hinfo->boundary_located > 0) {
#line 3774
          if (glb.debug > 0) {
            {
#line 3774
            LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: pushing BS=\'%s\'",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       3774, hinfo->boundary);
            }
          }
          {
#line 3775
          BS_push(hinfo->boundary);
          }
        }
      }
    }
    {
#line 3779
    regresult = 1;
#line 3780
    tmp = strlen((char const   *)(hinfo->filename));
    }
#line 3780
    if (tmp > 0UL) {
      {
#line 3782
      regresult = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)(hinfo->filename),
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
      }
#line 3783
      if (glb.debug > 0) {
        {
#line 3783
        LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: FileName Regex match = %d [filename = \'%s\']",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3784,
                   regresult, hinfo->filename);
        }
      }
    }
#line 3797
    if (regresult > 0) {
      {
#line 3799
      tmp___0 = strlen((char const   *)original_ptr);
#line 3799
      bl = (int )tmp___0;
#line 3801
      bc = fwrite((void const   */* __restrict  */)original_ptr, sizeof(char ), (size_t )bl,
                  (FILE */* __restrict  */)outputfile);
      }
#line 3802
      if (bc != (size_t )bl) {
        {
#line 3802
        LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Wrote %d bytes instead of %d",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3802,
                   bc, bl);
        }
      }
#line 3803
      if (glb.debug > 0) {
        {
#line 3803
        LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Wrote original headers:\n%s",
                   "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3803,
                   original_ptr);
        }
      }
    } else {
      {
#line 3818
      new_attachment_filename = strrchr((char const   *)new_attachment_name, '/');
      }
#line 3821
      if ((unsigned long )new_attachment_filename == (unsigned long )((void *)0)) {
        {
#line 3821
        new_attachment_filename = strrchr((char const   *)new_attachment_name, '\\');
        }
      }
#line 3825
      if ((unsigned long )new_attachment_filename == (unsigned long )((void *)0)) {
#line 3827
        new_attachment_filename = new_attachment_name;
      } else {
#line 3832
        new_attachment_filename ++;
      }
#line 3847
      if (iteration > 1) {
#line 3852
        if (glb.debug > 0) {
          {
#line 3852
          LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Writing clean headers",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3852);
          }
        }
        {
#line 3854
        fprintf((FILE */* __restrict  */)outputfile, (char const   */* __restrict  */)"Content-Type: %s;name=\"%s\"%sContent-Transfer-Encoding: base64%sContent-Disposition: attachment;filename=\"%s\"%s%s",
                hinfo->content_type_string, new_attachment_filename, glb.ldelimeter,
                glb.ldelimeter, new_attachment_filename, glb.ldelimeter, glb.ldelimeter);
        }
      } else {
#line 3867
        if (glb.debug > 0) {
          {
#line 3867
          LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Primary header attachment replacement",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3867,
                     new_attachment_filename);
          }
        }
        {
#line 3868
        duplicate_headers = strdup((char const   *)original_ptr);
        }
#line 3869
        if ((unsigned long )duplicate_headers == (unsigned long )((void *)0)) {
          {
#line 3871
          LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Could not allocate memory to hold temporary copy of headers",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3871);
          }
#line 3872
          return (1);
        }
        {
#line 3876
        AM_attachment_replace_header_filter(hinfo, new_attachment_filename, & duplicate_headers);
        }
#line 3878
        if (glb.debug > 0) {
          {
#line 3878
          LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: Writing recycled headers\n%s",
                     "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3878,
                     duplicate_headers);
          }
        }
        {
#line 3879
        fprintf((FILE */* __restrict  */)outputfile, (char const   */* __restrict  */)"%s",
                duplicate_headers);
        }
#line 3881
        if ((unsigned long )duplicate_headers != (unsigned long )((void *)0)) {
          {
#line 3881
          free((void *)duplicate_headers);
          }
        }
      }
    }
    {
#line 3886
    result = MIMEH_headers_cleanup();
    }
#line 3887
    if (result != 0) {
      {
#line 3889
      LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: while attempting to clean up headers memory allocation",
                 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3889);
      }
#line 3890
      goto while_break;
    }
#line 3895
    if (regresult != 0) {
#line 3895
      if (hinfo->content_type == 500) {
        {
#line 3897
        result = AM_attachment_replace_recurse(hinfo, f, outputfile, preg, new_attachment_name,
                                               1);
        }
      }
    }
    {
#line 3905
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3908
      FFGET_fgets(buffer, (int )sizeof(buffer), f);
#line 3909
      tmp___3 = FFGET_feof(f);
      }
#line 3909
      if (tmp___3 == 0) {
        {
#line 3911
        tmp___1 = strlen((char const   *)(buffer));
#line 3911
        buflen = (int )tmp___1;
#line 3916
        tmp___2 = BS_cmp(buffer, buflen);
        }
#line 3916
        if (tmp___2 == 1) {
#line 3928
          if (regresult == 0) {
            {
#line 3930
            AM_attachment_replace_write_data(new_attachment_name, outputfile, glb.ldelimeter);
#line 3931
            attachment_data_written = 1;
            }
          }
          {
#line 3934
          bc = fwrite((void const   */* __restrict  */)(buffer), sizeof(char ), (size_t )buflen,
                      (FILE */* __restrict  */)outputfile);
          }
#line 3935
          if (bc != (size_t )buflen) {
            {
#line 3935
            LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Wrote %d bytes instead of %d",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       3935, bc, buflen);
            }
          }
#line 3936
          goto while_break___0;
        }
#line 3944
        if (regresult != 0) {
          {
#line 3946
          bc = fwrite((void const   */* __restrict  */)(buffer), sizeof(char ), (size_t )buflen,
                      (FILE */* __restrict  */)outputfile);
          }
#line 3947
          if (bc != (size_t )buflen) {
            {
#line 3947
            LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Wrote %d bytes instead of %d",
                       "/home/june/collector/temp/altermime-0.3.10/mime_alter.c",
                       3947, bc, buflen);
            }
          }
        }
      } else {
#line 3961
        if (regresult == 0) {
#line 3961
          if (attachment_data_written == 0) {
            {
#line 3963
            AM_attachment_replace_write_data(new_attachment_name, outputfile, glb.ldelimeter);
            }
          }
        }
#line 3966
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3972
    tmp___4 = FFGET_feof(f);
    }
#line 3972
    if (tmp___4) {
#line 3972
      goto while_break;
    }
#line 3975
    iteration ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3979
  if (glb.debug > 0) {
    {
#line 3979
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:DEBUG: End of function.",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 3979);
    }
  }
#line 3980
  return (0);
}
}
#line 4007 "/home/june/collector/temp/altermime-0.3.10/mime_alter.c"
int AM_attachment_replace(char *mpackname , char *attachmentname , char *new_attachment_name ) 
{ 
  struct MIMEH_header_info hinfo ;
  regex_t preg ;
  int result ;
  char tmpfname[256] ;
  char oldfname[256] ;
  FILE *inputfile ;
  FILE *outputfile ;
  FFGET_FILE f ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 4011
  result = 0;
#line 4027
  BS_init();
#line 4029
  inputfile = fopen((char const   */* __restrict  */)mpackname, (char const   */* __restrict  */)"r");
  }
#line 4030
  if ((unsigned long )inputfile == (unsigned long )((void *)0)) {
    {
#line 4032
    tmp = __errno_location();
#line 4032
    tmp___0 = strerror(*tmp);
#line 4032
    LOGGER_log((char *)"%s:%d:AM_replace_attachment: Unable to open mailpack \'%s\' for reading (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 4032, mpackname,
               tmp___0);
    }
#line 4033
    return (1);
  }
  {
#line 4036
  snprintf((char */* __restrict  */)(tmpfname), sizeof(tmpfname), (char const   */* __restrict  */)"%s.tmp",
           mpackname);
#line 4037
  outputfile = fopen((char const   */* __restrict  */)(tmpfname), (char const   */* __restrict  */)"w");
  }
#line 4038
  if ((unsigned long )outputfile == (unsigned long )((void *)0)) {
#line 4040
    if ((unsigned long )inputfile != (unsigned long )((void *)0)) {
      {
#line 4040
      fclose(inputfile);
      }
    }
    {
#line 4041
    tmp___1 = __errno_location();
#line 4041
    tmp___2 = strerror(*tmp___1);
#line 4041
    LOGGER_log((char *)"%s:%d:AM_replace_attachment: Unable to open temporary file \'%s\' for writing (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 4041, tmpfname,
               tmp___2);
    }
#line 4042
    return (1);
  }
  {
#line 4045
  FFGET_setstream(& f, inputfile);
#line 4046
  MIMEH_set_headers_nosave();
#line 4047
  MIMEH_set_headers_save_original(1);
#line 4051
  result = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)attachmentname,
                   (1 | (1 << 1)) | (((1 << 1) << 1) << 1));
  }
#line 4052
  if (result != 0) {
    {
#line 4054
    LOGGER_log((char *)"%s:%d:AM_replace_attachment: Unable to compile regular expression \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 4054, attachmentname);
    }
#line 4055
    return (0);
  }
  {
#line 4058
  result = AM_attachment_replace_recurse(& hinfo, & f, outputfile, & preg, new_attachment_name,
                                         1);
#line 4060
  MIMEH_set_headers_save_original(0);
#line 4062
  snprintf((char */* __restrict  */)(oldfname), sizeof(oldfname), (char const   */* __restrict  */)"%s.old",
           mpackname);
#line 4063
  result = rename((char const   *)mpackname, (char const   *)(oldfname));
  }
#line 4064
  if (result != 0) {
    {
#line 4066
    tmp___3 = __errno_location();
#line 4066
    tmp___4 = strerror(*tmp___3);
#line 4066
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Unable to rename original mailpack \'%s\' to \'%s\' (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 4066, mpackname,
               oldfname, tmp___4);
    }
#line 4067
    return (1);
  }
  {
#line 4070
  result = rename((char const   *)(tmpfname), (char const   *)mpackname);
  }
#line 4071
  if (result != 0) {
    {
#line 4073
    tmp___5 = __errno_location();
#line 4073
    tmp___6 = strerror(*tmp___5);
#line 4073
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Unable to rename temporary mailpack \'%s\' to \'%s\' (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 4073, tmpfname,
               mpackname, tmp___6);
    }
#line 4074
    return (1);
  }
  {
#line 4077
  result = unlink((char const   *)(oldfname));
  }
#line 4078
  if (result != 0) {
    {
#line 4080
    tmp___7 = __errno_location();
#line 4080
    tmp___8 = strerror(*tmp___7);
#line 4080
    LOGGER_log((char *)"%s:%d:AM_attachment_replace_recurse:ERROR: Unable to unlink/remove \'%s\' (%s)",
               "/home/june/collector/temp/altermime-0.3.10/mime_alter.c", 4080, oldfname,
               tmp___8);
    }
#line 4081
    return (1);
  }
  {
#line 4085
  BS_clear();
  }
#line 4087
  return (result);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 52 "/home/june/collector/temp/altermime-0.3.10/ffget.h"
int FFGET_doubleCR ;
#line 53
int FFGET_SDL_MODE ;
#line 64
char FFGET_fgetc(FFGET_FILE *f ) ;
#line 73
int FFGET_set_watch_SDL(int level ) ;
#line 76
long FFGET_ftell(FFGET_FILE *f ) ;
#line 29 "/home/june/collector/temp/altermime-0.3.10/pldstr.h"
char *PLD_strncpy(char *dst , char const   *src , size_t len ) ;
#line 25 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.h"
int MDECODE_decode_multipart(char *line ) ;
#line 28
int MDECODE_decode_ISO(char *isostring , int size ) ;
#line 28 "/home/june/collector/temp/altermime-0.3.10/strstack.h"
int SS_push(struct SS_object *ss , char *data , size_t data_length ) ;
#line 31
char *SS_cmp(struct SS_object *ss , char *find_me , size_t find_me_len ) ;
#line 34
int SS_count(struct SS_object *ss ) ;
#line 5 "/home/june/collector/temp/altermime-0.3.10/filename-filters.h"
int FNFILTER_set_mac(int level ) ;
#line 6
int FNFILTER_filter(char *fname , int size ) ;
#line 167 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.h"
int MIMEH_version(void) ;
#line 169
int MIMEH_init(void) ;
#line 171
int MIMEH_set_verbosity(int level ) ;
#line 172
int MIMEH_set_verbosity_contenttype(int level ) ;
#line 173
int MIMEH_get_verbosity_contenttype(void) ;
#line 176
int MIMEH_is_contenttype(int range_type , int content_type ) ;
#line 178
int MIMEH_set_mailbox(int level ) ;
#line 179
int MIMEH_set_doubleCR(int level ) ;
#line 181
int MIMEH_get_doubleCR_save(void) ;
#line 182
int MIMEH_set_headerfix(int level ) ;
#line 183
int MIMEH_set_headers_save(FILE *f ) ;
#line 185
int MIMEH_get_headers_save(void) ;
#line 193
int MIMEH_get_doubleCR(void) ;
#line 194
char *MIMEH_get_doubleCR_name(void) ;
#line 198
int MIMEH_read_headers(struct MIMEH_header_info *hinfo , FFGET_FILE *f ) ;
#line 206
int MIMEH_display_info(struct MIMEH_header_info *hinfo ) ;
#line 207
int MIMEH_set_webform(int level ) ;
#line 208
int MIMEH_set_outputdir(char *dir ) ;
#line 210
int MIMEH_set_defect(struct MIMEH_header_info *hinfo , int defect ) ;
#line 211
int MIMEH_dump_defects(struct MIMEH_header_info *hinfo ) ;
#line 212
int MIMEH_get_defect_count(struct MIMEH_header_info *hinfo ) ;
#line 54 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
char *MIMEH_defect_description_array[100]  ;
#line 91 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
static struct MIMEH_globals glb___0  ;
#line 110 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_version(void) 
{ 


  {
  {
#line 112
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"mimeheaders: %s\n",
          "200811151148");
  }
#line 114
  return (0);
}
}
#line 132 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_init(void) 
{ 


  {
#line 135
  glb___0.doubleCR = 0;
#line 136
  glb___0.headerline = (char *)((void *)0);
#line 137
  glb___0.headerline_original = (char *)((void *)0);
#line 138
  glb___0.header_file = (FILE *)((void *)0);
#line 139
  glb___0.original_header_file = (FILE *)((void *)0);
#line 140
  glb___0.original_header_save_to_file = 0;
#line 142
  glb___0.save_headers = 0;
#line 143
  glb___0.save_headers_original = 0;
#line 144
  glb___0.test_mailbox = 0;
#line 145
  glb___0.debug = 0;
#line 146
  glb___0.webform = 0;
#line 147
  glb___0.doubleCR_count = 0;
#line 148
  glb___0.doubleCR_save = 1;
#line 149
  glb___0.header_fix = 1;
#line 150
  glb___0.verbose = 0;
#line 151
  glb___0.verbose_contenttype = 0;
#line 152
  glb___0.output_dir[0] = (char )'\000';
#line 153
  glb___0.doubleCRname[0] = (char )'\000';
#line 154
  glb___0.appledouble_filename[0] = (char )'\000';
#line 155
  glb___0.header_longsearch = 0;
#line 156
  glb___0.longsearch_limit = 1;
#line 158
  return (0);
}
}
#line 176 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_get_doubleCR(void) 
{ 


  {
#line 178
  return (glb___0.doubleCR);
}
}
#line 196 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_doubleCR(int level ) 
{ 


  {
#line 198
  glb___0.doubleCR = level;
#line 200
  return (glb___0.doubleCR);
}
}
#line 219 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_headerfix(int level ) 
{ 


  {
#line 221
  glb___0.header_fix = level;
#line 222
  return (glb___0.header_fix);
}
}
#line 240 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_doubleCR_save(int level ) 
{ 


  {
#line 242
  glb___0.doubleCR_save = level;
#line 244
  return (glb___0.doubleCR_save);
}
}
#line 262 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_get_doubleCR_save(void) 
{ 


  {
#line 264
  return (glb___0.doubleCR_save);
}
}
#line 283 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
char *MIMEH_get_doubleCR_name(void) 
{ 


  {
#line 285
  return (glb___0.doubleCRname);
}
}
#line 304 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_debug(int level ) 
{ 


  {
#line 306
  glb___0.debug = level;
#line 307
  return (glb___0.debug);
}
}
#line 325 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_outputdir(char *dir ) 
{ 


  {
#line 327
  if (dir) {
    {
#line 327
    snprintf((char */* __restrict  */)(glb___0.output_dir), (size_t )1023, (char const   */* __restrict  */)"%s",
             dir);
    }
  }
#line 328
  return (0);
}
}
#line 346 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_webform(int level ) 
{ 


  {
#line 348
  glb___0.webform = level;
#line 349
  return (glb___0.webform);
}
}
#line 368 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_mailbox(int level ) 
{ 


  {
#line 370
  glb___0.test_mailbox = level;
#line 371
  return (level);
}
}
#line 389 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_verbosity(int level ) 
{ 


  {
#line 391
  glb___0.verbose = level;
#line 392
  return (level);
}
}
#line 410 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_verbosity_contenttype(int level ) 
{ 


  {
#line 412
  glb___0.verbose_contenttype = level;
#line 413
  return (level);
}
}
#line 431 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_get_verbosity_contenttype(void) 
{ 


  {
#line 433
  return (glb___0.verbose_contenttype);
}
}
#line 446 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_headers_save(FILE *f ) 
{ 


  {
#line 448
  glb___0.header_file = f;
#line 449
  glb___0.save_headers = 1;
#line 450
  return (0);
}
}
#line 469 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_headers_original_save_to_file(FILE *f ) 
{ 


  {
#line 471
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 471
    glb___0.original_header_save_to_file = 0;
  } else {
#line 472
    glb___0.original_header_save_to_file = 1;
  }
#line 473
  glb___0.original_header_file = f;
#line 475
  return (glb___0.original_header_save_to_file);
}
}
#line 493 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_headers_nosave(void) 
{ 


  {
#line 495
  glb___0.header_file = (FILE *)((void *)0);
#line 496
  glb___0.save_headers = 0;
#line 497
  return (0);
}
}
#line 515 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_get_headers_save(void) 
{ 


  {
#line 517
  return (glb___0.save_headers);
}
}
#line 536 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_headers_save_original(int level ) 
{ 


  {
#line 538
  glb___0.save_headers_original = level;
#line 540
  return (glb___0.save_headers_original);
}
}
#line 559 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
char *MIMEH_get_headers_ptr(void) 
{ 


  {
#line 561
  return (glb___0.headerline);
}
}
#line 580 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
char *MIMEH_get_headers_original_ptr(void) 
{ 


  {
#line 582
  return (glb___0.headerline_original);
}
}
#line 605 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_header_longsearch(int level ) 
{ 


  {
#line 607
  glb___0.header_longsearch = level;
#line 609
  return (glb___0.header_longsearch);
}
}
#line 628 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_set_defect(struct MIMEH_header_info *hinfo , int defect ) 
{ 


  {
#line 630
  if (defect >= 0) {
#line 630
    if (defect < 100) {
#line 632
      (hinfo->defects[defect]) ++;
#line 633
      (hinfo->header_defect_count) ++;
#line 634
      if (glb___0.debug >= 1) {
        {
#line 634
        LOGGER_log((char *)"%s:%d:MIMEH_set_defect:DEBUG: Setting defect index \'%d\' to \'%d\'",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 634,
                   defect, hinfo->defects[defect]);
        }
      }
    }
  }
#line 636
  return (0);
}
}
#line 655 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_is_contenttype(int range_type , int content_type ) 
{ 
  int diff ;

  {
#line 659
  diff = content_type - range_type;
#line 661
  if (diff < 99) {
#line 661
    if (diff > 0) {
#line 661
      return (1);
    } else {
#line 662
      return (0);
    }
  } else {
#line 662
    return (0);
  }
}
}
#line 681 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_is_binary(char *fname ) 
{ 
  char buffer[1024] ;
  int read_count ;
  FILE *f ;
  size_t tmp ;

  {
  {
#line 687
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 688
  if (! f) {
#line 688
    return (1);
  }
  {
#line 689
  tmp = fread((void */* __restrict  */)(buffer), (size_t )1, (size_t )1024, (FILE */* __restrict  */)f);
#line 689
  read_count = (int )tmp;
#line 690
  fclose(f);
  }
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! read_count) {
#line 692
      goto while_break;
    }
#line 694
    read_count --;
#line 695
    if ((int )buffer[read_count] == 0) {
#line 695
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return (0);
}
}
#line 716 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_are_headers_RFC822(char *headers ) 
{ 
  char conditions[7][16] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int hitcount ;
  int condition_item ;
  char *lc_headers ;
  char *p ;

  {
#line 718
  conditions[0][0] = (char )'r';
#line 718
  conditions[0][1] = (char )'e';
#line 718
  conditions[0][2] = (char )'c';
#line 718
  conditions[0][3] = (char )'e';
#line 718
  conditions[0][4] = (char )'i';
#line 718
  conditions[0][5] = (char )'v';
#line 718
  conditions[0][6] = (char )'e';
#line 718
  conditions[0][7] = (char )'d';
#line 718
  conditions[0][8] = (char )'\000';
#line 718
  tmp = 9U;
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (tmp >= 16U) {
#line 718
      goto while_break;
    }
#line 718
    conditions[0][tmp] = (char)0;
#line 718
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 718
  conditions[1][0] = (char )'f';
#line 718
  conditions[1][1] = (char )'r';
#line 718
  conditions[1][2] = (char )'o';
#line 718
  conditions[1][3] = (char )'m';
#line 718
  conditions[1][4] = (char )'\000';
#line 718
  tmp___0 = 5U;
  {
#line 718
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 718
    if (tmp___0 >= 16U) {
#line 718
      goto while_break___0;
    }
#line 718
    conditions[1][tmp___0] = (char)0;
#line 718
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 718
  conditions[2][0] = (char )'s';
#line 718
  conditions[2][1] = (char )'u';
#line 718
  conditions[2][2] = (char )'b';
#line 718
  conditions[2][3] = (char )'j';
#line 718
  conditions[2][4] = (char )'e';
#line 718
  conditions[2][5] = (char )'c';
#line 718
  conditions[2][6] = (char )'t';
#line 718
  conditions[2][7] = (char )'\000';
#line 718
  tmp___1 = 8U;
  {
#line 718
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 718
    if (tmp___1 >= 16U) {
#line 718
      goto while_break___1;
    }
#line 718
    conditions[2][tmp___1] = (char)0;
#line 718
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 718
  conditions[3][0] = (char )'d';
#line 718
  conditions[3][1] = (char )'a';
#line 718
  conditions[3][2] = (char )'t';
#line 718
  conditions[3][3] = (char )'e';
#line 718
  conditions[3][4] = (char )'\000';
#line 718
  tmp___2 = 5U;
  {
#line 718
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 718
    if (tmp___2 >= 16U) {
#line 718
      goto while_break___2;
    }
#line 718
    conditions[3][tmp___2] = (char)0;
#line 718
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 718
  conditions[4][0] = (char )'c';
#line 718
  conditions[4][1] = (char )'o';
#line 718
  conditions[4][2] = (char )'n';
#line 718
  conditions[4][3] = (char )'t';
#line 718
  conditions[4][4] = (char )'e';
#line 718
  conditions[4][5] = (char )'n';
#line 718
  conditions[4][6] = (char )'t';
#line 718
  conditions[4][7] = (char )'\000';
#line 718
  tmp___3 = 8U;
  {
#line 718
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 718
    if (tmp___3 >= 16U) {
#line 718
      goto while_break___3;
    }
#line 718
    conditions[4][tmp___3] = (char)0;
#line 718
    tmp___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 718
  conditions[5][0] = (char )'b';
#line 718
  conditions[5][1] = (char )'o';
#line 718
  conditions[5][2] = (char )'u';
#line 718
  conditions[5][3] = (char )'n';
#line 718
  conditions[5][4] = (char )'d';
#line 718
  conditions[5][5] = (char )'a';
#line 718
  conditions[5][6] = (char )'r';
#line 718
  conditions[5][7] = (char )'y';
#line 718
  conditions[5][8] = (char )'\000';
#line 718
  tmp___4 = 9U;
  {
#line 718
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 718
    if (tmp___4 >= 16U) {
#line 718
      goto while_break___4;
    }
#line 718
    conditions[5][tmp___4] = (char)0;
#line 718
    tmp___4 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 718
  tmp___5 = 6U;
  {
#line 718
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 718
    if (tmp___5 >= 7U) {
#line 718
      goto while_break___5;
    }
#line 718
    conditions[tmp___5][0] = (char)0;
#line 718
    conditions[tmp___5][1] = (char)0;
#line 718
    conditions[tmp___5][2] = (char)0;
#line 718
    conditions[tmp___5][3] = (char)0;
#line 718
    conditions[tmp___5][4] = (char)0;
#line 718
    conditions[tmp___5][5] = (char)0;
#line 718
    conditions[tmp___5][6] = (char)0;
#line 718
    conditions[tmp___5][7] = (char)0;
#line 718
    conditions[tmp___5][8] = (char)0;
#line 718
    conditions[tmp___5][9] = (char)0;
#line 718
    conditions[tmp___5][10] = (char)0;
#line 718
    conditions[tmp___5][11] = (char)0;
#line 718
    conditions[tmp___5][12] = (char)0;
#line 718
    conditions[tmp___5][13] = (char)0;
#line 718
    conditions[tmp___5][14] = (char)0;
#line 718
    conditions[tmp___5][15] = (char)0;
#line 718
    tmp___5 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 719
  hitcount = 0;
#line 721
  lc_headers = (char *)((void *)0);
#line 723
  if ((unsigned long )headers == (unsigned long )((void *)0)) {
#line 725
    if (glb___0.debug >= 1) {
      {
#line 725
      LOGGER_log((char *)"%s:%d:MIMEH_are_headers_RFC822:DEBUG: Headers are NULL");
      }
    }
#line 726
    return (0);
  }
#line 729
  if (glb___0.debug >= 1) {
    {
#line 729
    LOGGER_log((char *)"%s:%d:MIMEH_are_headers_RFC822:DEBUG:----\n%s\n----", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               729, headers);
    }
  }
  {
#line 731
  lc_headers = strdup((char const   *)headers);
  }
#line 732
  if ((unsigned long )lc_headers == (unsigned long )((void *)0)) {
#line 732
    return (0);
  }
  {
#line 735
  PLD_strlower(lc_headers);
  }
#line 737
  if (glb___0.debug >= 1) {
    {
#line 737
    LOGGER_log((char *)"%s:%d:MIMEH_are_headers_RFC822:DEBUG:----(lowercase)----\n%s\n----",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 737, lc_headers);
    }
  }
#line 739
  condition_item = 0;
  {
#line 739
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 739
    if (! (condition_item < 6)) {
#line 739
      goto while_break___6;
    }
#line 743
    if (glb___0.debug >= 1) {
      {
#line 743
      LOGGER_log((char *)"%s:%d:MIMEH_are_headers_RFC822:DEBUG: Condition test item[%d] = \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 743,
                 condition_item, conditions[condition_item]);
      }
    }
    {
#line 744
    p = strstr((char const   *)lc_headers, (char const   *)(conditions[condition_item]));
    }
#line 745
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 747
      if ((unsigned long )p > (unsigned long )lc_headers) {
#line 749
        if ((int )*(p - 1) == 10) {
#line 750
          hitcount ++;
        } else
#line 749
        if ((int )*(p - 1) == 13) {
#line 750
          hitcount ++;
        }
      } else
#line 751
      if ((unsigned long )p == (unsigned long )lc_headers) {
#line 751
        hitcount ++;
      }
    }
#line 739
    condition_item ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 755
  if ((unsigned long )lc_headers != (unsigned long )((void *)0)) {
    {
#line 755
    free((void *)lc_headers);
    }
  }
#line 757
  return (hitcount);
}
}
#line 776 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_save_doubleCR(FFGET_FILE *f ) 
{ 
  int c ;
  FILE *fo ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;

  {
  {
#line 786
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 787
    (glb___0.doubleCR_count) ++;
#line 788
    snprintf((char */* __restrict  */)(glb___0.doubleCRname), (size_t )1023, (char const   */* __restrict  */)"%s/doubleCR.%d",
             glb___0.output_dir, glb___0.doubleCR_count);
#line 786
    tmp = stat((char const   */* __restrict  */)(glb___0.doubleCRname), (struct stat */* __restrict  */)(& st));
    }
#line 786
    if (! (tmp == 0)) {
#line 786
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 793
  fo = fopen((char const   */* __restrict  */)(glb___0.doubleCRname), (char const   */* __restrict  */)"w");
  }
#line 794
  if (! fo) {
    {
#line 796
    tmp___0 = __errno_location();
#line 796
    tmp___1 = strerror(*tmp___0);
#line 796
    LOGGER_log((char *)"%s:%d:MIMEH_save_doubleCR:ERROR: unable to open \'%s\' to write (%s)",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 796, glb___0.doubleCRname,
               tmp___1);
    }
#line 797
    return (-1);
  }
#line 800
  if (glb___0.debug >= 1) {
    {
#line 800
    LOGGER_log((char *)"%s:%d:MIME_save_doubleCR:DEBUG: Saving DoubleCR header: %s\n",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 800, glb___0.doubleCRname);
    }
  }
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 804
    tmp___2 = FFGET_fgetc(f);
#line 804
    c = (int )tmp___2;
#line 805
    fprintf((FILE */* __restrict  */)fo, (char const   */* __restrict  */)"%c", c);
    }
#line 807
    if (c == -1) {
#line 809
      goto while_break___0;
    } else
#line 807
    if (c == 10) {
#line 809
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 813
  fclose(fo);
  }
#line 815
  return (0);
}
}
#line 834 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
char *MIMEH_absorb_whitespace(char *p ) 
{ 


  {
#line 836
  if (p) {
    {
#line 838
    while (1) {
      while_continue: /* CIL Label */ ;
#line 838
      if ((int )*p != 0) {
#line 838
        if (! ((int )*p == 32)) {
#line 838
          if (! ((int )*p == 9)) {
#line 838
            goto while_break;
          }
        }
      } else {
#line 838
        goto while_break;
      }
#line 838
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 841
  return (p);
}
}
#line 860 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_strip_comments(char *input ) 
{ 
  char *p ;
  char *p_org ;
  int in_quote ;
  char *q ;
  int stop_searching ;

  {
#line 863
  in_quote = 0;
#line 865
  if ((unsigned long )input == (unsigned long )((void *)0)) {
#line 865
    return (0);
  }
#line 867
  p_org = input;
#line 867
  p = p_org;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    q = (char *)((void *)0);
    {
#line 873
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 873
      if ((unsigned long )p_org != (unsigned long )((void *)0)) {
#line 873
        if (! ((int )*p_org != 40)) {
#line 873
          if (! (in_quote == 1)) {
#line 873
            goto while_break___0;
          }
        }
      } else {
#line 873
        goto while_break___0;
      }
      {
#line 876
      if ((int )*p_org == 34) {
#line 876
        goto case_34;
      }
#line 880
      if ((int )*p_org == 13) {
#line 880
        goto case_13;
      }
#line 880
      if ((int )*p_org == 10) {
#line 880
        goto case_13;
      }
#line 883
      if ((int )*p_org == 0) {
#line 883
        goto case_0;
      }
#line 875
      goto switch_break;
      case_34: /* CIL Label */ 
#line 877
      in_quote ^= 1;
#line 878
      goto switch_break;
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
#line 881
      in_quote = 0;
#line 882
      goto switch_break;
      case_0: /* CIL Label */ 
#line 884
      p_org = (char *)((void *)0);
#line 885
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 888
      if (p_org) {
#line 888
        p_org ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 891
    p = p_org;
#line 894
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 894
      if (in_quote == 0) {
#line 896
        stop_searching = 0;
#line 898
        if (glb___0.debug >= 1) {
          {
#line 898
          LOGGER_log((char *)"%s:%d:MIMEH_strip_comments:DEBUG: Located open ( at %s",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     898, p);
          }
        }
#line 902
        q = p;
        {
#line 903
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 903
          if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 903
            if (! (stop_searching == 0)) {
#line 903
              goto while_break___1;
            }
          } else {
#line 903
            goto while_break___1;
          }
          {
#line 906
          if ((int )*q == 0) {
#line 906
            goto case_0___0;
          }
#line 912
          if ((int )*q == 13) {
#line 912
            goto case_13___0;
          }
#line 912
          if ((int )*q == 10) {
#line 912
            goto case_13___0;
          }
#line 917
          if ((int )*q == 34) {
#line 917
            goto case_34___0;
          }
#line 921
          if ((int )*q == 41) {
#line 921
            goto case_41;
          }
#line 905
          goto switch_break___0;
          case_0___0: /* CIL Label */ 
#line 907
          stop_searching = 1;
#line 908
          q = (char *)((void *)0);
#line 909
          goto switch_break___0;
          case_13___0: /* CIL Label */ 
          case_10___0: /* CIL Label */ 
#line 913
          stop_searching = 1;
#line 914
          in_quote = 0;
#line 915
          goto switch_break___0;
          case_34___0: /* CIL Label */ 
#line 918
          in_quote ^= 1;
#line 919
          goto switch_break___0;
          case_41: /* CIL Label */ 
#line 922
          if (glb___0.debug >= 1) {
            {
#line 922
            LOGGER_log((char *)"%s:%d:MIMEH_strip_comments:DEBUG: Located closing ) at %s",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       922, q);
            }
          }
#line 923
          if (in_quote == 0) {
#line 923
            stop_searching = 1;
          }
#line 924
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 926
          if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 926
            if (stop_searching == 0) {
#line 926
              q ++;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 931
        if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 933
          if ((int )*q != 41) {
#line 937
            p_org ++;
#line 938
            goto __Cont;
          } else {
#line 942
            q ++;
#line 944
            if (glb___0.debug >= 1) {
              {
#line 944
              LOGGER_log((char *)"%s:%d:MIMEH_strip_comments:DEBUG: located closing ) at %s ",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         944, q);
              }
            }
            {
#line 947
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 947
              if (! ((int )*q != 0)) {
#line 947
                goto while_break___2;
              }
#line 949
              *p = *q;
#line 950
              p ++;
#line 951
              q ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 953
            if (glb___0.debug >= 1) {
              {
#line 953
              LOGGER_log((char *)"%s:%d:MIMEH_strip_comments:DEBUG: char copy done",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         953);
              }
            }
#line 956
            *p = (char )'\000';
          }
        } else {
#line 959
          goto while_break;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 869
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 869
      if (! ((unsigned long )p_org != (unsigned long )((void *)0))) {
#line 869
        goto while_break;
      }
    } else {
#line 869
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 965
  if (glb___0.debug >= 1) {
    {
#line 965
    LOGGER_log((char *)"%s:%d:MIMEH_strip_comments:DEBUG: Final string = \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 965, input);
    }
  }
#line 967
  return (0);
}
}
#line 999 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_fix_header_mistakes(char *data ) 
{ 
  int result ;
  char *p ;
  int nonblank_detected ;
  char *q ;

  {
#line 1001
  result = 0;
#line 1004
  if (glb___0.debug >= 1) {
    {
#line 1004
    LOGGER_log((char *)"%s:%d:MIMEH_fix_header_mistakes:DEBUG: Checking and fixing headers in \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1004,
               data);
    }
  }
#line 1006
  if (glb___0.header_fix == 0) {
#line 1006
    return (result);
  }
#line 1008
  p = data;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1009
    if (! p) {
#line 1009
      goto while_break;
    }
    {
#line 1010
    nonblank_detected = 0;
#line 1013
    p = strchr((char const   *)p, ';');
    }
#line 1014
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1014
      goto while_break;
    }
#line 1017
    q = p + 1;
#line 1019
    if (glb___0.debug >= 1) {
      {
#line 1019
      LOGGER_log((char *)"%s:%d:MIMEH_fix_header_mistakes:DEBUG: Located \';\' at offset %d \'%20s",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1019,
                 p - data, p);
      }
    }
#line 1021
    if ((int )*q == 10) {
#line 1022
      nonblank_detected = 0;
    } else
#line 1021
    if ((int )*q == 13) {
#line 1022
      nonblank_detected = 0;
    } else {
      {
#line 1027
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1027
        if (! ((int )*q != 0)) {
#line 1027
          if (! ((int )*q != 13)) {
#line 1027
            if (! ((int )*q != 10)) {
#line 1027
              goto while_break___0;
            }
          }
        }
        {
#line 1032
        if ((int )*q == 32) {
#line 1032
          goto case_32;
        }
#line 1032
        if ((int )*q == 13) {
#line 1032
          goto case_32;
        }
#line 1032
        if ((int )*q == 10) {
#line 1032
          goto case_32;
        }
#line 1032
        if ((int )*q == 9) {
#line 1032
          goto case_32;
        }
#line 1035
        goto switch_default;
        case_32: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 1033
        nonblank_detected = 0;
#line 1034
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1036
        nonblank_detected = 1;
        switch_break: /* CIL Label */ ;
        }
#line 1039
        if (nonblank_detected == 1) {
#line 1039
          goto while_break___0;
        }
#line 1041
        q ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1045
    if (nonblank_detected == 1) {
#line 1046
      if (glb___0.debug >= 1) {
        {
#line 1046
        LOGGER_log((char *)"%s:%d:MIMEH_fix_header_mistakes:DEBUG: Line was normal/safe, continue...",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1046);
        }
      }
#line 1047
      p ++;
#line 1048
      goto while_continue;
    }
#line 1053
    if ((int )*q != 0) {
#line 1054
      if (glb___0.debug >= 1) {
        {
#line 1054
        LOGGER_log((char *)"%s:%d:MIMEH_fix_header_mistakes:DEBUG: Line needs fixing",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1054);
        }
      }
#line 1055
      *q = (char )' ';
#line 1056
      q ++;
#line 1057
      if ((int )*q == 10) {
#line 1057
        *q = (char )' ';
      } else
#line 1057
      if ((int )*q == 13) {
#line 1057
        *q = (char )' ';
      }
#line 1058
      if (glb___0.debug >= 1) {
        {
#line 1058
        LOGGER_log((char *)"%s:%d:MIMEH_fix_header_mistakes:DEBUG: Line fixed", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                   1058);
        }
      }
#line 1059
      p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1064
  if (glb___0.debug >= 1) {
    {
#line 1064
    LOGGER_log((char *)"%s:%d:MIMEH_fix_header_mistakes:DEBUG: Done", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               1064);
    }
  }
#line 1066
  return (result);
}
}
#line 1077 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_read_headers(struct MIMEH_header_info *hinfo , FFGET_FILE *f ) 
{ 
  char buffer[1024] ;
  int totalsize ;
  int linesize ;
  int totalsize_original ;
  int result ;
  int search_count ;
  char *tmp ;
  char *tmp_original ;
  char *fget_result ;
  char *p ;
  char *linestart ;
  char *lineend ;
  int is_RFC822_headers ;
  long tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 1080
  totalsize = 0;
#line 1081
  linesize = 0;
#line 1082
  totalsize_original = 0;
#line 1083
  result = 0;
#line 1084
  search_count = 0;
#line 1087
  fget_result = (char *)((void *)0);
#line 1092
  is_RFC822_headers = 0;
#line 1103
  if (glb___0.debug >= 1) {
    {
#line 1103
    tmp___0 = FFGET_ftell(f);
#line 1103
    tmp___1 = FFGET_ftell(f);
#line 1103
    LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: File position = %ld [0x%0X]",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1104,
               tmp___1, tmp___0);
    }
  }
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1111
    search_count ++;
#line 1112
    glb___0.headerline = (char *)((void *)0);
#line 1113
    glb___0.headerline_original = (char *)((void *)0);
#line 1114
    tmp_original = (char *)((void *)0);
    {
#line 1117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1117
      fget_result = FFGET_fgets(buffer, 1023, f);
      }
#line 1117
      if (! fget_result) {
#line 1117
        goto while_break___0;
      }
      {
#line 1120
      linestart = buffer;
#line 1121
      tmp___2 = strlen((char const   *)linestart);
#line 1121
      linesize = (int )tmp___2;
#line 1122
      lineend = linestart + linesize;
#line 1124
      tmp___5 = strstr((char const   *)linestart, "\r\n");
      }
#line 1124
      if (tmp___5) {
#line 1124
        (hinfo->crlf_count) ++;
      } else {
        {
#line 1125
        tmp___4 = strstr((char const   *)linestart, "\r\r");
        }
#line 1125
        if (tmp___4) {
#line 1125
          (hinfo->crcr_count) ++;
        } else {
          {
#line 1126
          tmp___3 = strchr((char const   *)linestart, '\n');
          }
#line 1126
          if (tmp___3) {
#line 1126
            (hinfo->lf_count) ++;
          }
        }
      }
#line 1128
      if (glb___0.debug >= 1) {
        {
#line 1128
        LOGGER_log((char *)"%s:%d:MIMEH_read_headers: Data In=[sz=%d:tb=%d:mem=%p]\'%s\'",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1128,
                   linesize, f->trueblank, glb___0.headerline, buffer);
        }
      }
#line 1132
      if (glb___0.original_header_save_to_file > 0) {
#line 1132
        if ((unsigned long )glb___0.original_header_file != (unsigned long )((void *)0)) {
#line 1134
          if (glb___0.debug >= 1) {
            {
#line 1134
            LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: saving to file...",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       1134);
            }
          }
          {
#line 1135
          fprintf((FILE */* __restrict  */)glb___0.original_header_file, (char const   */* __restrict  */)"%s",
                  linestart);
          }
        }
      }
#line 1140
      if (glb___0.save_headers_original > 0) {
#line 1142
        if (glb___0.debug >= 1) {
          {
#line 1142
          tmp___6 = strlen((char const   *)linestart);
#line 1142
          LOGGER_log((char *)"MIMEH_read_headers:DEBUG:Data-In:[%d:%d] \'%s\'", tmp___6,
                     linesize, linestart);
          }
        }
        {
#line 1143
        tmp___7 = realloc((void *)glb___0.headerline_original, (size_t )((totalsize_original + linesize) + 1));
#line 1143
        tmp_original = (char *)tmp___7;
        }
#line 1144
        if ((unsigned long )tmp_original == (unsigned long )((void *)0)) {
          {
#line 1146
          LOGGER_log((char *)"%s:%d:MIMEH_read_headers:ERROR: Cannot allocate %d bytes to contain new headers_original ",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1146, (totalsize_original + linesize) + 1);
          }
#line 1147
          if ((unsigned long )glb___0.headerline_original != (unsigned long )((void *)0)) {
            {
#line 1147
            free((void *)glb___0.headerline_original);
            }
          }
#line 1148
          glb___0.headerline_original = (char *)((void *)0);
#line 1149
          return (-1);
        }
#line 1152
        if ((unsigned long )glb___0.headerline_original == (unsigned long )((void *)0)) {
          {
#line 1154
          glb___0.headerline_original = tmp_original;
#line 1155
          totalsize_original = linesize + 1;
#line 1156
          PLD_strncpy(glb___0.headerline_original, (char const   *)linestart, (size_t )(linesize + 1));
          }
#line 1157
          if (glb___0.debug >= 1) {
            {
#line 1157
            LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: \'%s\'", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       1157, glb___0.headerline_original);
            }
          }
        } else {
          {
#line 1159
          glb___0.headerline_original = tmp_original;
#line 1160
          PLD_strncpy((glb___0.headerline_original + totalsize_original) - 1, (char const   *)linestart,
                      (size_t )(linesize + 1));
#line 1161
          totalsize_original += linesize;
          }
#line 1162
          if (glb___0.debug >= 1) {
            {
#line 1162
            LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: HO =  \'%s\'", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       1162, glb___0.headerline_original);
            }
          }
        }
      }
#line 1169
      if (glb___0.debug >= 1) {
        {
#line 1169
        LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: realloc\'ing dataspace",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1169);
        }
      }
      {
#line 1170
      tmp___8 = realloc((void *)glb___0.headerline, (size_t )((totalsize + linesize) + 1));
#line 1170
      tmp = (char *)tmp___8;
      }
#line 1171
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 1173
        LOGGER_log((char *)"%s:%d:MIMEH_read_headers:ERROR: Cannot allocate %d bytes to contain new headers ",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1173,
                   (totalsize + linesize) + 1);
        }
#line 1174
        if ((unsigned long )glb___0.headerline != (unsigned long )((void *)0)) {
          {
#line 1174
          free((void *)glb___0.headerline);
          }
        }
#line 1175
        glb___0.headerline = (char *)((void *)0);
#line 1176
        return (-1);
      }
#line 1179
      if ((unsigned long )glb___0.headerline == (unsigned long )((void *)0)) {
#line 1181
        if (glb___0.debug >= 1) {
          {
#line 1181
          LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: Initial appending of head to dataspace headerline = NULL  realloc block = %p linestart = %p linesize = %d",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1181, tmp, linestart, linesize);
          }
        }
        {
#line 1182
        glb___0.headerline = tmp;
#line 1183
        totalsize = linesize;
#line 1184
        PLD_strncpy(glb___0.headerline, (char const   *)linestart, (size_t )(linesize + 1));
        }
      } else {
#line 1188
        if (glb___0.debug >= 1) {
          {
#line 1188
          LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: Appending of new data to existing header  existing-headerline = %p  new realloc block = %p linestart = %p linesize = %d",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1188, glb___0.headerline, tmp, linestart, linesize);
          }
        }
#line 1194
        glb___0.headerline = tmp;
#line 1196
        if ((unsigned long )linestart < (unsigned long )lineend) {
#line 1196
          if ((int )*linestart == 9) {
#line 1196
            goto _L;
          } else
#line 1196
          if ((int )*linestart == 32) {
            _L: /* CIL Label */ 
#line 1211
            p = (glb___0.headerline + totalsize) - 1;
#line 1212
            if (glb___0.debug >= 1) {
              {
#line 1212
              LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: unwrapping headers headers=%p, p = %p",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         1212, glb___0.headerline, p);
              }
            }
            {
#line 1213
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1213
              if ((unsigned long )p >= (unsigned long )glb___0.headerline) {
#line 1213
                if (! ((int )*p == 10)) {
#line 1213
                  if (! ((int )*p == 13)) {
#line 1213
                    goto while_break___1;
                  }
                }
              } else {
#line 1213
                goto while_break___1;
              }
#line 1215
              if (glb___0.debug >= 1) {
                {
#line 1215
                LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: Removing trailing space p=[%p]%c",
                           "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                           1215, p, (int )*p);
                }
              }
#line 1216
              *p = (char )'\000';
#line 1217
              p --;
#line 1218
              totalsize --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1222
            p = (glb___0.headerline + totalsize) - 1;
          }
        }
#line 1227
        if (glb___0.debug >= 1) {
          {
#line 1227
          LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: Memcopying line, source = %p, dest = %p, size = %d",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1227, linestart, glb___0.headerline + totalsize, linesize);
          }
        }
        {
#line 1228
        memcpy((void */* __restrict  */)(glb___0.headerline + totalsize), (void const   */* __restrict  */)linestart,
               (size_t )linesize);
#line 1229
        totalsize += linesize;
#line 1230
        *(glb___0.headerline + totalsize) = (char )'\000';
        }
      }
#line 1236
      if (f->trueblank) {
#line 1238
        if (glb___0.debug >= 1) {
          {
#line 1238
          LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: Trueblank line detected in header reading",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1238);
          }
        }
#line 1239
        if (glb___0.debug >= 1) {
          {
#line 1239
          LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: Headers /before/ decoding\n-------\n%s\n-------------------",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1239, glb___0.headerline);
          }
        }
        {
#line 1241
        MIMEH_fix_header_mistakes(glb___0.headerline);
#line 1242
        MDECODE_decode_ISO(glb___0.headerline, totalsize);
        }
#line 1244
        if (glb___0.save_headers) {
#line 1244
          if (glb___0.headerline) {
#line 1246
            if (glb___0.debug >= 1) {
              {
#line 1246
              LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: Saving header line.",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         1246);
              }
            }
            {
#line 1247
            fprintf((FILE */* __restrict  */)glb___0.header_file, (char const   */* __restrict  */)"%s",
                    glb___0.headerline);
            }
          }
        }
#line 1249
        if (glb___0.debug >= 1) {
          {
#line 1249
          LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: Final Headers\n------------------\n%s---------------",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1249, glb___0.headerline);
          }
        }
#line 1252
        goto while_break___0;
      }
#line 1260
      if (FFGET_doubleCR) {
#line 1262
        if (glb___0.doubleCR_save != 0) {
          {
#line 1264
          MIMEH_save_doubleCR(f);
#line 1265
          glb___0.doubleCR = 1;
          }
        }
#line 1267
        FFGET_doubleCR = 0;
#line 1268
        FFGET_SDL_MODE = 0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1280
    if (! fget_result) {
#line 1282
      if (glb___0.debug >= 1) {
        {
#line 1282
        LOGGER_log((char *)"%s:%d:MIME_read_headers:ERROR: FFGET module ran out of input while reading headers",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1282);
        }
      }
#line 1285
      if (glb___0.debug >= 1) {
        {
#line 1285
        LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: save_headers=%d totalsize=%d headerline=%s",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1285,
                   glb___0.save_headers, totalsize, glb___0.headerline);
        }
      }
#line 1287
      if (glb___0.save_headers) {
#line 1287
        if (glb___0.headerline) {
#line 1289
          if (glb___0.debug >= 1) {
            {
#line 1289
            LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: Saving header line.",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       1289);
            }
          }
          {
#line 1290
          MIMEH_fix_header_mistakes(glb___0.headerline);
#line 1291
          MDECODE_decode_ISO(glb___0.headerline, totalsize);
#line 1292
          fprintf((FILE */* __restrict  */)glb___0.header_file, (char const   */* __restrict  */)"%s",
                  glb___0.headerline);
          }
        }
      }
#line 1295
      result = -1;
    } else
#line 1298
    if (glb___0.header_longsearch > 0) {
      {
#line 1300
      is_RFC822_headers = MIMEH_are_headers_RFC822(glb___0.headerline);
      }
#line 1301
      if (is_RFC822_headers == 0) {
#line 1304
        if (glb___0.debug >= 1) {
          {
#line 1304
          LOGGER_log((char *)"%s:%d:MIME_read_headers:DEBUG: No RFC822 headers detected, cleanup.");
          }
        }
        {
#line 1305
        MIMEH_headers_cleanup();
        }
      }
    }
#line 1109
    if (is_RFC822_headers == 0) {
#line 1109
      if (glb___0.header_longsearch > 0) {
#line 1109
        if (result == 0) {
#line 1109
          if (! (search_count < glb___0.longsearch_limit)) {
#line 1109
            goto while_break;
          }
        } else {
#line 1109
          goto while_break;
        }
      } else {
#line 1109
        goto while_break;
      }
    } else {
#line 1109
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  if (glb___0.debug >= 1) {
    {
#line 1311
    LOGGER_log((char *)"%s:%d:MIMEH_read_headers:DEBUG: Finished.", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               1311);
    }
  }
#line 1312
  return (result);
}
}
#line 1325 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_display_info(struct MIMEH_header_info *hinfo ) 
{ 


  {
#line 1327
  if (hinfo) {
    {
#line 1329
    LOGGER_log((char *)"%s:%d:MIMEH_display_info:\t\t\t\tContent Type = %d\n\t\t\t\tBoundary = %s\n\t\t\t\tFilename = %s\n\t\t\t\tname = %s\n\t\t\t\tEncoding = %d\n\t\t\t\tDisposit = %d\n\t\t\t\t",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1337,
               hinfo->content_type, hinfo->boundary, hinfo->filename, hinfo->name,
               hinfo->content_transfer_encoding, hinfo->content_disposition);
#line 1344
    fflush(stdout);
    }
  }
#line 1346
  return (0);
}
}
#line 1365 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_decode_multivalue_language_string(char *input ) 
{ 
  int sq_count ;
  int language_set ;
  char *q ;
  char *tmp ;

  {
#line 1367
  sq_count = 0;
#line 1368
  language_set = 0;
#line 1369
  q = input;
#line 1371
  if (glb___0.debug >= 1) {
    {
#line 1371
    LOGGER_log((char *)"%s:%d:MIMEH_decode_multivalue_language_string:DEBUG: Decoding \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1371,
               input);
    }
  }
  {
#line 1373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1373
    if ((int )*q != 0) {
#line 1373
      if (! (sq_count != 2)) {
#line 1373
        goto while_break;
      }
    } else {
#line 1373
      goto while_break;
    }
#line 1373
    tmp = q;
#line 1373
    q ++;
#line 1373
    if ((int )*tmp == 39) {
#line 1373
      sq_count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1374
  if (sq_count < 2) {
#line 1377
    q = input;
  } else {
#line 1379
    language_set = 1;
  }
  {
#line 1385
  MDECODE_decode_multipart(q);
  }
#line 1389
  if (language_set == 1) {
    {
#line 1391
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1391
      if (! ((int )*q != 0)) {
#line 1391
        goto while_break___0;
      }
#line 1391
      *input = *q;
#line 1391
      input ++;
#line 1391
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1392
    *input = (char )'\000';
  }
#line 1395
  if (glb___0.debug >= 1) {
    {
#line 1395
    LOGGER_log((char *)"%s:%d:MIMEH_decode_multivalue_language_string:DEBUG: Output = \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1395,
               q);
    }
  }
#line 1398
  return (0);
}
}
#line 1436 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_recompose_multivalue(struct MIMEH_header_info *hinfo , char *header_name_prefix ,
                               char *header_value , char *buffer , size_t buffer_size ,
                               char **data_end_point ) 
{ 
  int result ;
  char *start_position ;
  char *q ;
  char *buffer_start ;
  size_t tmp ;
  size_t tmp___0 ;
  char *p ;
  char *end_point ;
  char end_point_char ;
  int decode_data ;
  int q_len ;
  char *ep ;
  int bl ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1438
  result = 0;
#line 1439
  start_position = header_value;
#line 1442
  if (glb___0.debug >= 1) {
    {
#line 1442
    LOGGER_log((char *)"%s:%d:MIMEH_recompose_multivalue:DEBUG: seeking for %s in %s and appending to \'%s\'. Buffer size=%d",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1442,
               header_name_prefix, header_value, buffer, buffer_size);
    }
  }
  {
#line 1446
  start_position = strstr((char const   *)header_value, (char const   *)header_name_prefix);
  }
#line 1447
  if ((unsigned long )start_position != (unsigned long )((void *)0)) {
    {
#line 1453
    tmp = strlen((char const   *)buffer);
#line 1453
    buffer_start = buffer + tmp;
#line 1454
    tmp___0 = strlen((char const   *)buffer);
#line 1454
    buffer_size -= tmp___0;
#line 1456
    q = start_position;
    }
    {
#line 1459
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1462
      end_point_char = (char )'\000';
#line 1463
      decode_data = 0;
#line 1466
      p = strstr((char const   *)q, (char const   *)header_name_prefix);
      }
#line 1467
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1467
        goto while_break;
      }
#line 1469
      if (glb___0.debug >= 1) {
        {
#line 1469
        LOGGER_log((char *)"%s:%d:MIMEH_recompose_multivalue:DEBUG: prefix = %s",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1469,
                   p);
        }
      }
      {
#line 1471
      q = strchr((char const   *)p, '=');
      }
#line 1472
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 1472
        goto while_break;
      }
#line 1475
      if ((int )*(q - 1) == 42) {
#line 1477
        decode_data = 1;
      }
#line 1481
      q ++;
#line 1483
      if (glb___0.debug >= 1) {
        {
#line 1483
        LOGGER_log((char *)"%s:%d:MIMEH_recompose_multivalue:DEBUG: data = %s", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                   1483, q);
        }
      }
      {
#line 1486
      end_point = strpbrk((char const   *)q, ";\t\n\r ");
      }
#line 1487
      if ((unsigned long )end_point != (unsigned long )((void *)0)) {
#line 1489
        *end_point = (char )'\000';
#line 1490
        end_point_char = *end_point;
#line 1491
        *data_end_point = end_point;
      } else {
#line 1496
        ep = q;
        {
#line 1497
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1497
          if (! ((int )*ep != 0)) {
#line 1497
            goto while_break___0;
          }
#line 1497
          ep ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1498
        *data_end_point = ep;
      }
#line 1502
      if ((int )*q == 34) {
        {
#line 1507
        q ++;
#line 1508
        tmp___1 = strlen((char const   *)q);
#line 1508
        bl = (int )tmp___1;
        }
#line 1509
        if ((int )*((q + bl) - 1) == 34) {
#line 1509
          *((q + bl) - 1) = (char )'\000';
        }
      }
#line 1513
      if (decode_data == 1) {
        {
#line 1515
        MIMEH_decode_multivalue_language_string(q);
        }
      }
#line 1518
      if (glb___0.debug >= 1) {
        {
#line 1518
        LOGGER_log((char *)"%s:%d:MIMEH_recompose_multivalue:DEBUG: segment value = \'%s\', appending to \'%s\'",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1518,
                   q, buffer);
        }
      }
      {
#line 1519
      snprintf((char */* __restrict  */)buffer_start, buffer_size, (char const   */* __restrict  */)"%s",
               q);
#line 1520
      tmp___2 = strlen((char const   *)q);
#line 1520
      q_len = (int )tmp___2;
#line 1521
      buffer_size -= (size_t )q_len;
#line 1522
      buffer_start += q_len;
      }
#line 1523
      if (glb___0.debug >= 1) {
        {
#line 1523
        LOGGER_log((char *)"%s:%d:MIMEH_recompose_multivalue:DEBUG: Buffer[remaining=%d]= \'%s\'",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1523,
                   buffer_size, buffer);
        }
      }
#line 1525
      if ((unsigned long )end_point != (unsigned long )((void *)0)) {
#line 1527
        *end_point = end_point_char;
#line 1528
        q = end_point + 1;
      } else {
#line 1530
        q = (char *)((void *)0);
      }
#line 1459
      if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 1459
        if (! (buffer_size > 0UL)) {
#line 1459
          goto while_break;
        }
      } else {
#line 1459
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1536
  if (glb___0.debug >= 1) {
    {
#line 1536
    LOGGER_log((char *)"%s:%d:MIMEH_recompose_multivalue:DEBUG: End point set to: [%d] \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1536,
               *data_end_point - header_value, *data_end_point);
    }
  }
#line 1537
  return (result);
}
}
#line 1570 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_header_parameter(struct MIMEH_header_info *hinfo , char *data , char *searchstr ,
                                 char *output_value , int output_value_size , char **data_end_point ) 
{ 
  int return_value ;
  char *p ;
  char *hl ;
  size_t tmp ;
  int tmp___0 ;
  char *string ;
  size_t tmp___1 ;
  char *before_string ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *endchar ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *string_end ;
  char *string_end___0 ;
  int slen ;
  size_t tmp___7 ;
  char *s ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 1572
  return_value = 0;
#line 1578
  *data_end_point = data;
#line 1582
  hl = strdup((char const   *)data);
#line 1584
  PLD_strlower(hl);
  }
#line 1586
  if (glb___0.debug >= 1) {
    {
#line 1586
    LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Seeking \'%s\' in \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1586,
               searchstr, hl);
    }
  }
  {
#line 1589
  tmp = strlen((char const   *)searchstr);
#line 1589
  tmp___0 = strncmp((char const   *)hl, (char const   *)searchstr, tmp);
  }
#line 1589
  if (tmp___0 == 0) {
#line 1589
    p = hl;
  } else {
#line 1589
    p = (char *)((void *)0);
  }
#line 1591
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1593
    string = (char *)((void *)0);
#line 1595
    if (glb___0.debug >= 1) {
      {
#line 1595
      LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: found %s in %s",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1595,
                 searchstr, p);
      }
    }
    {
#line 1605
    tmp___1 = strlen((char const   *)searchstr);
#line 1605
    string = (data + (p - hl)) + tmp___1;
    }
    {
#line 1620
    if ((int )*string == 9) {
#line 1620
      goto case_9;
    }
#line 1620
    if ((int )*string == 32) {
#line 1620
      goto case_9;
    }
#line 1620
    if ((int )*string == 61) {
#line 1620
      goto case_9;
    }
#line 1620
    if ((int )*string == 42) {
#line 1620
      goto case_9;
    }
#line 1626
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_42: /* CIL Label */ 
#line 1625
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1632
    if (hl) {
      {
#line 1632
      free((void *)hl);
      }
    }
#line 1633
    return (1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 1643
    tmp___2 = strlen((char const   *)searchstr);
#line 1643
    before_string = (string - 1) - tmp___2;
    }
#line 1644
    if ((unsigned long )before_string >= (unsigned long )data) {
      {
#line 1653
      if ((int )*before_string == 9) {
#line 1653
        goto case_9___0;
      }
#line 1653
      if ((int )*before_string == 32) {
#line 1653
        goto case_9___0;
      }
#line 1653
      if ((int )*before_string == 58) {
#line 1653
        goto case_9___0;
      }
#line 1653
      if ((int )*before_string == 59) {
#line 1653
        goto case_9___0;
      }
#line 1659
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_32___0: /* CIL Label */ 
      case_58: /* CIL Label */ 
      case_59: /* CIL Label */ 
#line 1658
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1665
      if (hl) {
        {
#line 1665
        free((void *)hl);
        }
      }
#line 1666
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1674
    if ((int )*string == 42) {
#line 1676
      if (glb___0.debug >= 1) {
        {
#line 1676
        LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Found a \'*\' after the name, so attempting multipart value decode",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1676);
        }
      }
      {
#line 1680
      return_value = MIMEH_recompose_multivalue(hinfo, searchstr, data, output_value,
                                                (size_t )output_value_size, data_end_point);
      }
    } else {
      {
#line 1686
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1686
        tmp___3 = __ctype_b_loc();
        }
#line 1686
        if (! ((int const   )*(*tmp___3 + (int )*string) & 8192)) {
#line 1686
          goto while_break;
        }
#line 1686
        string ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1689
      if ((int )*string == 0) {
#line 1691
        if (glb___0.debug >= 1) {
          {
#line 1691
          LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: In \'%s\' parsing, was expecting a \'=\' in the start of \'%s\'\n",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1691, searchstr, string);
          }
        }
      } else {
        {
#line 1700
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1700
          if ((int )*(string + 1) == 61) {
#line 1700
            if (! ((int )*(string + 1) != 0)) {
#line 1700
              goto while_break___0;
            }
          } else {
#line 1700
            goto while_break___0;
          }
          {
#line 1700
          string ++;
#line 1700
          MIMEH_set_defect(hinfo, 3);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1704
        tmp___4 = strlen((char const   *)string);
#line 1704
        endchar = (string + tmp___4) - 1;
#line 1705
        *data_end_point = endchar;
        }
        {
#line 1708
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1708
          if ((unsigned long )endchar > (unsigned long )string) {
            {
#line 1708
            tmp___5 = __ctype_b_loc();
            }
#line 1708
            if (! ((int const   )*(*tmp___5 + (int )*endchar) & 8192)) {
#line 1708
              goto while_break___1;
            }
          } else {
#line 1708
            goto while_break___1;
          }
#line 1710
          *endchar = (char )'\000';
#line 1711
          endchar --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1715
        if ((int )*string == 61) {
#line 1715
          string ++;
        } else {
          {
#line 1717
          MIMEH_set_defect(hinfo, 8);
          }
        }
        {
#line 1721
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1721
          tmp___6 = __ctype_b_loc();
          }
#line 1721
          if (! ((int const   )*(*tmp___6 + (int )*string) & 8192)) {
#line 1721
            goto while_break___2;
          }
#line 1721
          string ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1723
        if (glb___0.debug >= 1) {
          {
#line 1723
          LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Extracting value out of \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1723, string);
          }
        }
        {
#line 1736
        if ((int )*string == 34) {
#line 1736
          goto case_34;
        }
#line 1782
        goto switch_default___1;
        case_34: /* CIL Label */ 
#line 1744
        if (glb___0.debug >= 1) {
          {
#line 1744
          LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Using quoted-string tests",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1744);
          }
        }
#line 1747
        string ++;
        {
#line 1748
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1748
          if ((int )*string != 0) {
#line 1748
            if (! ((int )*string == 34)) {
#line 1748
              goto while_break___3;
            }
          } else {
#line 1748
            goto while_break___3;
          }
          {
#line 1748
          string ++;
#line 1748
          MIMEH_set_defect(hinfo, 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1750
        if ((int )*string == 0) {
#line 1750
          goto switch_break___1;
        }
        {
#line 1754
        string_end = strchr((char const   *)(string + 1), '\"');
        }
#line 1755
        if ((unsigned long )string_end != (unsigned long )((void *)0)) {
#line 1757
          if (glb___0.debug >= 1) {
            {
#line 1757
            LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: End of value found",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       1757);
            }
          }
#line 1758
          *string_end = (char )'\000';
#line 1759
          *data_end_point = string_end + 1;
        } else {
#line 1768
          if (hinfo) {
            {
#line 1768
            MIMEH_set_defect(hinfo, 2);
            }
          }
          {
#line 1769
          string_end = strpbrk((char const   *)string, "; \n\r\t");
          }
#line 1770
          if ((unsigned long )string_end != (unsigned long )((void *)0)) {
#line 1772
            *string_end = (char )'\000';
#line 1773
            *data_end_point = string_end + 1;
          }
        }
#line 1780
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 1786
        if (glb___0.debug >= 1) {
          {
#line 1786
          LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Using NON-quoted-string tests",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1786);
          }
        }
        {
#line 1787
        string_end___0 = strpbrk((char const   *)string, "; \n\r\t");
        }
#line 1788
        if ((unsigned long )string_end___0 != (unsigned long )((void *)0)) {
#line 1790
          *string_end___0 = (char )'\000';
#line 1791
          *data_end_point = string_end___0 + 1;
        }
#line 1797
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1800
        if (glb___0.debug >= 1) {
          {
#line 1800
          LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Extracting value out of \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1800, string);
          }
        }
#line 1802
        if ((int )*string == 34) {
          {
#line 1802
          tmp___8 = strlen((char const   *)string);
          }
#line 1802
          if ((int )*((string + tmp___8) - 1) == 34) {
#line 1802
            goto _L;
          } else {
#line 1802
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1802
        if ((int )*string == 39) {
          {
#line 1802
          tmp___9 = strlen((char const   *)string);
          }
#line 1802
          if ((int )*((string + tmp___9) - 1) == 39) {
            _L: /* CIL Label */ 
            {
#line 1805
            tmp___7 = strlen((char const   *)string);
#line 1805
            slen = (int )(tmp___7 - 2UL);
#line 1806
            s = string;
            }
#line 1807
            if (glb___0.debug >= 1) {
              {
#line 1807
              LOGGER_log((char *)"%s:%d:MIMEH_parse-header_parameter:DEBUG: Stripping quotes from \'%s\'",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         1807, string);
              }
            }
            {
#line 1808
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1808
              if (! (slen > 0)) {
#line 1808
                goto while_break___4;
              }
#line 1810
              *s = *(s + 1);
#line 1811
              s ++;
#line 1812
              slen --;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1814
            *s = (char )'\000';
          }
        }
        {
#line 1819
        snprintf((char */* __restrict  */)output_value, (size_t )output_value_size,
                 (char const   */* __restrict  */)"%s", string);
        }
#line 1820
        if (glb___0.debug >= 1) {
          {
#line 1820
          LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: Final value = \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     1820, output_value);
          }
        }
      }
    }
  } else {
#line 1826
    return_value = 1;
  }
#line 1829
  if ((unsigned long )hl != (unsigned long )((void *)0)) {
    {
#line 1829
    free((void *)hl);
    }
  }
#line 1831
  if (glb___0.debug >= 1) {
    {
#line 1831
    LOGGER_log((char *)"%s:%d:MIMEH_parse_header_parameter:DEBUG: [return=%d] Done seeking for \'%s\' data_end_point=%p (from %p)",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1831,
               return_value, searchstr, *data_end_point, data);
    }
  }
#line 1833
  return (return_value);
}
}
#line 1862 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_is_valid_header_prefix(char *data , char *prefix_name ) 
{ 
  int plen ;
  size_t tmp ;
  char end_char ;
  int tmp___0 ;

  {
  {
#line 1864
  tmp = strlen((char const   *)prefix_name);
#line 1864
  plen = (int )tmp;
#line 1867
  tmp___0 = strncasecmp((char const   *)data, (char const   *)prefix_name, (size_t )plen);
  }
#line 1867
  if (tmp___0 != 0) {
#line 1869
    return (0);
  } else {
#line 1877
    end_char = *(data + plen);
    {
#line 1882
    if ((int )end_char == 0) {
#line 1882
      goto case_0;
    }
#line 1882
    if ((int )end_char == 9) {
#line 1882
      goto case_0;
    }
#line 1882
    if ((int )end_char == 32) {
#line 1882
      goto case_0;
    }
#line 1882
    if ((int )end_char == 58) {
#line 1882
      goto case_0;
    }
#line 1885
    goto switch_default;
    case_0: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_58: /* CIL Label */ 
#line 1884
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1887
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 1891
  return (1);
}
}
#line 1913 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_contenttype_linear_EXPERIMENT(char *header_name , char *header_value ,
                                              struct MIMEH_header_info *hinfo ) 
{ 
  char *chv ;
  char *chn ;
  int boundary_found ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1915
  chv = header_value;
#line 1916
  chn = header_name;
#line 1917
  boundary_found = 0;
  {
#line 1922
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1922
    tmp = __ctype_b_loc();
    }
#line 1922
    if (! ((int const   )*(*tmp + (int )*chn) & 8192)) {
#line 1922
      goto while_break;
    }
#line 1922
    chn ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1925
  tmp___0 = MIMEH_is_valid_header_prefix(chn, (char *)"content-type");
  }
#line 1925
  if (tmp___0 == 0) {
#line 1925
    return (0);
  }
  {
#line 1928
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1928
    if (! *chv) {
#line 1928
      goto while_break___0;
    }
    {
#line 1930
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1930
      tmp___1 = __ctype_b_loc();
      }
#line 1930
      if (! ((int const   )*(*tmp___1 + (int )*chv) & 8192)) {
#line 1930
        goto while_break___1;
      }
#line 1930
      chv ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1931
    if (boundary_found == 0) {
      {
#line 1931
      tmp___2 = MIMEH_is_valid_header_prefix(chv, (char *)"boundary");
      }
#line 1931
      if (tmp___2 == 1) {
#line 1931
        tmp___3 = 1;
      } else {
#line 1931
        tmp___3 = 0;
      }
    } else {
#line 1931
      tmp___3 = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1940
  return (0);
}
}
#line 1961 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_contenttype(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int return_value ;
  char *p ;
  char *q ;
  char *hv ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *c ;
  char *param ;
  char *data_end_point ;
  size_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;

  {
  {
#line 1966
  tmp = strdup((char const   *)header_value);
#line 1966
  hv = tmp;
  }
#line 1972
  if (glb___0.debug >= 1) {
    {
#line 1972
    LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Start", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               1972);
    }
  }
  {
#line 1974
  p = strstr((char const   *)header_name, "content-type");
  }
#line 1975
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1977
    if (glb___0.debug >= 1) {
      {
#line 1977
      LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype: Content-type string found in header-name",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 1977);
      }
    }
    {
#line 1980
    (hinfo->sanity) ++;
#line 1981
    PLD_strlower(header_value);
#line 1982
    PLD_strlower(header_value);
#line 1983
    q = header_value;
#line 1985
    tmp___19 = strstr((char const   *)q, "multipart/appledouble");
    }
#line 1985
    if (tmp___19) {
#line 1985
      hinfo->content_type = 102;
    } else {
      {
#line 1986
      tmp___18 = strstr((char const   *)q, "multipart/signed");
      }
#line 1986
      if (tmp___18) {
#line 1986
        hinfo->content_type = 106;
      } else {
        {
#line 1987
        tmp___17 = strstr((char const   *)q, "multipart/related");
        }
#line 1987
        if (tmp___17) {
#line 1987
          hinfo->content_type = 103;
        } else {
          {
#line 1988
          tmp___16 = strstr((char const   *)q, "multipart/mixed");
          }
#line 1988
          if (tmp___16) {
#line 1988
            hinfo->content_type = 101;
          } else {
            {
#line 1989
            tmp___15 = strstr((char const   *)q, "multipart/alternative");
            }
#line 1989
            if (tmp___15) {
#line 1989
              hinfo->content_type = 104;
            } else {
              {
#line 1990
              tmp___14 = strstr((char const   *)q, "multipart/report");
              }
#line 1990
              if (tmp___14) {
#line 1990
                hinfo->content_type = 105;
              } else {
                {
#line 1991
                tmp___13 = strstr((char const   *)q, "multipart/");
                }
#line 1991
                if (tmp___13) {
#line 1991
                  hinfo->content_type = 100;
                } else {
                  {
#line 1992
                  tmp___12 = strstr((char const   *)q, "text/calendar");
                  }
#line 1992
                  if (tmp___12) {
#line 1992
                    hinfo->content_type = 204;
                  } else {
                    {
#line 1993
                    tmp___11 = strstr((char const   *)q, "text/plain");
                    }
#line 1993
                    if (tmp___11) {
#line 1993
                      hinfo->content_type = 201;
                    } else {
                      {
#line 1994
                      tmp___10 = strstr((char const   *)q, "text/html");
                      }
#line 1994
                      if (tmp___10) {
#line 1994
                        hinfo->content_type = 203;
                      } else {
                        {
#line 1995
                        tmp___9 = strstr((char const   *)q, "text/");
                        }
#line 1995
                        if (tmp___9) {
#line 1995
                          hinfo->content_type = 200;
                        } else {
                          {
#line 1996
                          tmp___8 = strstr((char const   *)q, "image/gif");
                          }
#line 1996
                          if (tmp___8) {
#line 1996
                            hinfo->content_type = 301;
                          } else {
                            {
#line 1997
                            tmp___7 = strstr((char const   *)q, "image/jpeg");
                            }
#line 1997
                            if (tmp___7) {
#line 1997
                              hinfo->content_type = 302;
                            } else {
                              {
#line 1998
                              tmp___6 = strstr((char const   *)q, "image/");
                              }
#line 1998
                              if (tmp___6) {
#line 1998
                                hinfo->content_type = 300;
                              } else {
                                {
#line 1999
                                tmp___5 = strstr((char const   *)q, "audio/");
                                }
#line 1999
                                if (tmp___5) {
#line 1999
                                  hinfo->content_type = 400;
                                } else {
                                  {
#line 2000
                                  tmp___4 = strstr((char const   *)q, "message/rfc822");
                                  }
#line 2000
                                  if (tmp___4) {
#line 2000
                                    hinfo->content_type = 500;
                                  } else {
                                    {
#line 2001
                                    tmp___3 = strstr((char const   *)q, "/octet-stream");
                                    }
#line 2001
                                    if (tmp___3) {
#line 2001
                                      hinfo->content_type = 800;
                                    } else {
                                      {
#line 2002
                                      tmp___2 = strstr((char const   *)q, "/ms-tnef");
                                      }
#line 2002
                                      if (tmp___2) {
#line 2002
                                        hinfo->content_type = 600;
                                      } else {
                                        {
#line 2003
                                        tmp___1 = strstr((char const   *)q, "application/applefile");
                                        }
#line 2003
                                        if (tmp___1) {
#line 2005
                                          hinfo->content_type = 701;
#line 2006
                                          if ((int )hinfo->filename[0] == 0) {
                                            {
#line 2008
                                            tmp___0 = strlen((char const   *)(glb___0.appledouble_filename));
                                            }
#line 2008
                                            if (tmp___0 > 0UL) {
                                              {
#line 2010
                                              snprintf((char */* __restrict  */)(hinfo->filename),
                                                       sizeof(hinfo->filename), (char const   */* __restrict  */)"%s.applemeta",
                                                       glb___0.appledouble_filename);
                                              }
                                            } else {
                                              {
#line 2012
                                              snprintf((char */* __restrict  */)(hinfo->filename),
                                                       sizeof(hinfo->filename), (char const   */* __restrict  */)"applefile");
                                              }
                                            }
                                          }
                                        } else {
#line 2016
                                          hinfo->content_type = 0;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 2019
    tmp___20 = strstr((char const   *)header_value, "x-mac-type=");
    }
#line 2019
    if (tmp___20) {
      {
#line 2019
      tmp___21 = strstr((char const   *)header_value, "x-mac-creator=");
      }
#line 2019
      if (tmp___21) {
#line 2028
        if (glb___0.debug >= 1) {
          {
#line 2028
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Located x-mac attachment",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2028);
          }
        }
        {
#line 2029
        hinfo->x_mac = 1;
#line 2030
        FNFILTER_set_mac(hinfo->x_mac);
        }
      }
    }
#line 2035
    p = header_value;
#line 2036
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2038
      c = p;
      {
#line 2041
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2041
        if (! ((int )*c == 32)) {
#line 2041
          if (! ((int )*c == 9)) {
#line 2041
            goto while_break;
          }
        }
#line 2041
        c ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2044
      PLD_strncpy(hinfo->content_type_string, (char const   *)c, (size_t )128);
#line 2047
      c = hinfo->content_type_string;
      }
      {
#line 2048
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2048
        if (*c) {
#line 2048
          if ((int )*c != 32) {
#line 2048
            if ((int )*c != 9) {
#line 2048
              if ((int )*c != 10) {
#line 2048
                if ((int )*c != 13) {
#line 2048
                  if (! ((int )*c != 59)) {
#line 2048
                    goto while_break___0;
                  }
                } else {
#line 2048
                  goto while_break___0;
                }
              } else {
#line 2048
                goto while_break___0;
              }
            } else {
#line 2048
              goto while_break___0;
            }
          } else {
#line 2048
            goto while_break___0;
          }
        } else {
#line 2048
          goto while_break___0;
        }
#line 2048
        c ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2051
      *c = (char )'\000';
    }
    {
#line 2057
    p = strpbrk((char const   *)hv, ";\t\n\r ");
    }
#line 2058
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 2060
      param = (char *)((void *)0);
#line 2061
      data_end_point = param;
#line 2063
      p ++;
#line 2064
      param = strpbrk((char const   *)p, ";\n\r\t ");
      }
      {
#line 2065
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2065
        if (! ((unsigned long )param != (unsigned long )((void *)0))) {
#line 2065
          goto while_break___1;
        }
        {
#line 2082
        param ++;
#line 2083
        param = MIMEH_absorb_whitespace(param);
        }
#line 2089
        if ((int )*param == 0) {
#line 2089
          goto while_break___1;
        }
        {
#line 2097
        return_value = MIMEH_parse_header_parameter(hinfo, param, (char *)"name",
                                                    hinfo->name, (int )sizeof(hinfo->name),
                                                    & data_end_point);
        }
#line 2103
        if ((unsigned long )data_end_point > (unsigned long )param) {
#line 2103
          param = data_end_point;
        }
#line 2106
        if (return_value == 0) {
#line 2111
          if (glb___0.debug >= 1) {
            {
#line 2111
            LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Pushing new filename to stack \'%s\'",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       2111, hinfo->name);
            }
          }
          {
#line 2116
          tmp___24 = strlen((char const   *)(hinfo->name));
#line 2116
          tmp___25 = SS_cmp(& hinfo->ss_names, hinfo->name, tmp___24);
          }
#line 2116
          if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
#line 2118
            if (glb___0.debug >= 1) {
              {
#line 2118
              LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Filtering \'%s\'",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         2118, hinfo->name);
              }
            }
            {
#line 2119
            FNFILTER_filter(hinfo->name, 128);
            }
#line 2120
            if (glb___0.debug >= 1) {
              {
#line 2120
              LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Pushing \'%s\'",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         2120, hinfo->name);
              }
            }
            {
#line 2121
            tmp___22 = strlen((char const   *)(hinfo->name));
#line 2121
            SS_push(& hinfo->ss_names, hinfo->name, tmp___22);
#line 2122
            tmp___23 = SS_count(& hinfo->ss_names);
            }
#line 2122
            if (tmp___23 > 1) {
              {
#line 2124
              MIMEH_set_defect(hinfo, 9);
              }
            }
#line 2127
            if ((int )hinfo->filename[0] == 0) {
              {
#line 2128
              snprintf((char */* __restrict  */)(hinfo->filename), sizeof(hinfo->filename),
                       (char const   */* __restrict  */)"%s", hinfo->name);
              }
            }
          }
        }
        {
#line 2142
        return_value = MIMEH_parse_header_parameter(hinfo, param, (char *)"boundary",
                                                    hinfo->boundary, (int )sizeof(hinfo->boundary),
                                                    & data_end_point);
        }
#line 2143
        if (glb___0.debug >= 1) {
          {
#line 2143
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Param<=>data_end gap = %d",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2143, data_end_point - param);
          }
        }
#line 2144
        if (glb___0.debug >= 1) {
          {
#line 2144
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: param start pos = \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2144, param);
          }
        }
#line 2145
        if ((unsigned long )data_end_point > (unsigned long )param) {
#line 2145
          param = data_end_point;
        }
#line 2146
        if (glb___0.debug >= 1) {
          {
#line 2146
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: param start pos = \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2146, param);
          }
        }
#line 2148
        if (return_value == 0) {
#line 2153
          (hinfo->boundary_located) ++;
#line 2154
          if (glb___0.debug >= 1) {
            {
#line 2154
            LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Pushed boundary to stack (%s)",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       2154, hinfo->boundary);
            }
          }
          {
#line 2155
          BS_push(hinfo->boundary);
          }
#line 2156
          if (glb___0.debug >= 1) {
            {
#line 2156
            LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: Setting hinfo->boundary_located to %d",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       2156, hinfo->boundary_located);
            }
          }
#line 2158
          if (hinfo->boundary_located > 1) {
            {
#line 2161
            MIMEH_set_defect(hinfo, 5);
#line 2164
            hinfo->boundary_located = 1;
            }
          }
        }
#line 2171
        if ((unsigned long )param != (unsigned long )((void *)0)) {
#line 2171
          if (glb___0.debug >= 1) {
            {
#line 2171
            LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: param start pos = \'%s\'",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       2171, param);
            }
          }
        }
        {
#line 2172
        param = strpbrk((char const   *)param, ";\n\r ");
        }
#line 2173
        if ((unsigned long )param != (unsigned long )((void *)0)) {
#line 2173
          if (glb___0.debug >= 1) {
            {
#line 2173
            LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: param start pos = \'%s\'",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       2173, param);
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 2179
  if ((unsigned long )hv != (unsigned long )((void *)0)) {
    {
#line 2179
    free((void *)hv);
    }
  }
#line 2181
  if (glb___0.debug >= 1) {
    {
#line 2181
    LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttype:DEBUG: end.", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               2181);
    }
  }
#line 2183
  return (0);
}
}
#line 2213 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_contentlocation(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  char *p ;
  char *q ;
  size_t tmp ;

  {
  {
#line 2221
  PLD_strlower(header_name);
#line 2222
  p = strstr((char const   *)header_name, "content-location");
  }
#line 2223
  if (p) {
#line 2226
    (hinfo->sanity) ++;
#line 2228
    if (glb___0.debug >= 1) {
      {
#line 2228
      LOGGER_log((char *)"%s:%d:MIME_parse_contentlocation:DEBUG: Content Location line found - \'%s\'\n",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2228,
                 header_value);
      }
    }
#line 2231
    q = header_value;
#line 2231
    p = q;
    {
#line 2232
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2232
      if (! q) {
#line 2232
        goto while_break;
      }
      {
#line 2234
      q = strpbrk((char const   *)p, "\\/");
      }
#line 2235
      if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2235
        p = q + 1;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2238
    if (p) {
#line 2240
      if (glb___0.debug >= 1) {
        {
#line 2240
        LOGGER_log((char *)"%s:%d:MIME_parse_contentlocation:DEBUG: filename = %s\n",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2240,
                   p);
        }
      }
      {
#line 2241
      snprintf((char */* __restrict  */)(hinfo->name), sizeof(hinfo->name), (char const   */* __restrict  */)"%s",
               p);
#line 2242
      snprintf((char */* __restrict  */)(hinfo->filename), sizeof(hinfo->filename),
               (char const   */* __restrict  */)"%s", p);
#line 2243
      FNFILTER_filter(hinfo->filename, 128);
#line 2244
      tmp = strlen((char const   *)(hinfo->filename));
#line 2244
      SS_push(& hinfo->ss_filenames, hinfo->filename, tmp);
      }
    }
  }
#line 2249
  return (0);
}
}
#line 2283 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_contenttransferencoding(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  char *p ;
  char *q ;
  char c ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *cp ;

  {
  {
#line 2286
  c = (char )'\n';
#line 2293
  p = strstr((char const   *)header_name, "content-transfer-encoding");
  }
#line 2294
  if (p) {
    {
#line 2297
    (hinfo->sanity) ++;
#line 2299
    q = strpbrk((char const   *)header_value, "\n\r;");
    }
#line 2300
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2302
      c = *q;
#line 2303
      *q = (char )'\000';
    }
    {
#line 2306
    p = header_value;
#line 2308
    PLD_strlower(p);
#line 2310
    tmp___6 = strstr((char const   *)p, "base64");
    }
#line 2310
    if (tmp___6) {
#line 2312
      hinfo->content_transfer_encoding = 100;
#line 2313
      if (glb___0.debug >= 1) {
        {
#line 2313
        LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttransferencoding: Encoding set to BASE64",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2313);
        }
      }
    } else {
      {
#line 2315
      tmp___5 = strstr((char const   *)p, "7bit");
      }
#line 2315
      if (tmp___5) {
#line 2317
        hinfo->content_transfer_encoding = 101;
#line 2318
        if (glb___0.debug >= 1) {
          {
#line 2318
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttransferencoding: Encoding set to 7-BIT ",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2318);
          }
        }
      } else {
        {
#line 2320
        tmp___4 = strstr((char const   *)p, "8bit");
        }
#line 2320
        if (tmp___4) {
#line 2322
          hinfo->content_transfer_encoding = 102;
#line 2323
          if (glb___0.debug >= 1) {
            {
#line 2323
            LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttransferencoding: Encoding set to 8-BIT",
                       "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                       2323);
            }
          }
        } else {
          {
#line 2325
          tmp___3 = strstr((char const   *)p, "quoted-printable");
          }
#line 2325
          if (tmp___3) {
#line 2327
            hinfo->content_transfer_encoding = 103;
#line 2328
            if (glb___0.debug >= 1) {
              {
#line 2328
              LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttransferencoding: Encoding set to Quoted-Printable",
                         "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                         2328);
              }
            }
          } else {
            {
#line 2330
            tmp___2 = strstr((char const   *)p, "binary");
            }
#line 2330
            if (tmp___2) {
#line 2332
              hinfo->content_transfer_encoding = 105;
#line 2333
              if (glb___0.debug >= 1) {
                {
#line 2333
                LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttransferencoding: Encoding set to Binary",
                           "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                           2333);
                }
              }
            } else {
              {
#line 2335
              tmp = strstr((char const   *)p, "uu");
              }
#line 2335
              if (tmp) {
#line 2335
                goto _L;
              } else {
                {
#line 2335
                tmp___0 = strstr((char const   *)p, "x-u");
                }
#line 2335
                if (tmp___0) {
#line 2335
                  goto _L;
                } else {
                  {
#line 2335
                  tmp___1 = strcmp((char const   *)p, "u");
                  }
#line 2335
                  if (tmp___1 == 0) {
                    _L: /* CIL Label */ 
#line 2341
                    hinfo->content_transfer_encoding = 106;
#line 2342
                    if (glb___0.debug >= 1) {
                      {
#line 2342
                      LOGGER_log((char *)"%s:%d:MIMEH_parse_contenttransferencoding: Encoding set to UUENCODE",
                                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                                 2342);
                      }
                    }
                  } else {
#line 2344
                    hinfo->content_transfer_encoding = 104;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 2348
    p = header_value;
#line 2349
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2351
      cp = p;
      {
#line 2354
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2354
        if (! ((int )*cp == 32)) {
#line 2354
          if (! ((int )*cp == 9)) {
#line 2354
            goto while_break;
          }
        }
#line 2354
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2357
      PLD_strncpy(hinfo->content_transfer_encoding_string, (char const   *)cp, (size_t )256);
#line 2360
      cp = hinfo->content_transfer_encoding_string;
      }
      {
#line 2361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2361
        if (*cp) {
#line 2361
          if ((int )*cp != 32) {
#line 2361
            if ((int )*cp != 9) {
#line 2361
              if ((int )*cp != 10) {
#line 2361
                if ((int )*cp != 13) {
#line 2361
                  if (! ((int )*cp != 59)) {
#line 2361
                    goto while_break___0;
                  }
                } else {
#line 2361
                  goto while_break___0;
                }
              } else {
#line 2361
                goto while_break___0;
              }
            } else {
#line 2361
              goto while_break___0;
            }
          } else {
#line 2361
            goto while_break___0;
          }
        } else {
#line 2361
          goto while_break___0;
        }
#line 2361
        cp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2364
      *cp = (char )'\000';
    }
#line 2370
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 2370
      *q = c;
    }
  }
#line 2373
  return (0);
}
}
#line 2394 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_contentdisposition(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  char *p ;
  char *hv ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *q ;
  char *param ;
  int parse_result ;
  char *data_end_point ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2397
  tmp = strdup((char const   *)header_value);
#line 2397
  hv = tmp;
#line 2404
  p = strstr((char const   *)header_name, "content-disposition");
  }
#line 2405
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 2408
    (hinfo->sanity) ++;
#line 2413
    p = header_value;
#line 2414
    PLD_strlower(header_value);
#line 2417
    tmp___2 = strstr((char const   *)p, "inline");
    }
#line 2417
    if (tmp___2) {
#line 2419
      hinfo->content_disposition = 100;
    } else {
      {
#line 2421
      tmp___1 = strstr((char const   *)p, "form-data");
      }
#line 2421
      if (tmp___1) {
#line 2423
        hinfo->content_disposition = 300;
      } else {
        {
#line 2425
        tmp___0 = strstr((char const   *)p, "attachment");
        }
#line 2425
        if (tmp___0) {
#line 2427
          hinfo->content_disposition = 200;
        } else {
#line 2431
          hinfo->content_disposition = 0;
        }
      }
    }
#line 2435
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2437
      q = p;
      {
#line 2440
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2440
        if (! ((int )*q == 32)) {
#line 2440
          if (! ((int )*q == 9)) {
#line 2440
            goto while_break;
          }
        }
#line 2440
        q ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2443
      PLD_strncpy(hinfo->content_disposition_string, (char const   *)q, (size_t )256);
#line 2446
      q = hinfo->content_disposition_string;
      }
      {
#line 2447
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2447
        if (*q) {
#line 2447
          if ((int )*q != 32) {
#line 2447
            if ((int )*q != 9) {
#line 2447
              if ((int )*q != 10) {
#line 2447
                if ((int )*q != 13) {
#line 2447
                  if (! ((int )*q != 59)) {
#line 2447
                    goto while_break___0;
                  }
                } else {
#line 2447
                  goto while_break___0;
                }
              } else {
#line 2447
                goto while_break___0;
              }
            } else {
#line 2447
              goto while_break___0;
            }
          } else {
#line 2447
            goto while_break___0;
          }
        } else {
#line 2447
          goto while_break___0;
        }
#line 2447
        q ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2450
      *q = (char )'\000';
    }
#line 2453
    if (glb___0.debug >= 1) {
      {
#line 2453
      LOGGER_log((char *)"%s:%d:MIMEH_parse_contentdisposition:DEBUG: Disposition string = \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2453,
                 hv);
      }
    }
    {
#line 2456
    p = strpbrk((char const   *)hv, ";\t\n\r ");
    }
#line 2457
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2462
      hinfo->name[0] = (char )'\000';
#line 2464
      p ++;
#line 2465
      param = p;
      {
#line 2466
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2466
        if (! ((unsigned long )param != (unsigned long )((void *)0))) {
#line 2466
          goto while_break___1;
        }
#line 2471
        if (glb___0.debug >= 1) {
          {
#line 2471
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contentdisposition:DEBUG: Parsing \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2471, param);
          }
        }
        {
#line 2475
        parse_result = MIMEH_parse_header_parameter(hinfo, param, (char *)"filename",
                                                    hinfo->name, (int )sizeof(hinfo->name),
                                                    & data_end_point);
        }
#line 2476
        if ((unsigned long )data_end_point > (unsigned long )param) {
#line 2476
          param = data_end_point;
        }
#line 2477
        if (parse_result == 0) {
          {
#line 2478
          FNFILTER_filter(hinfo->name, 128);
#line 2479
          tmp___3 = strlen((char const   *)(hinfo->name));
#line 2479
          SS_push(& hinfo->ss_filenames, hinfo->name, tmp___3);
#line 2480
          tmp___4 = SS_count(& hinfo->ss_filenames);
          }
#line 2480
          if (tmp___4 > 1) {
            {
#line 2482
            MIMEH_set_defect(hinfo, 10);
            }
          }
        }
        {
#line 2486
        param = strpbrk((char const   *)param, ";\n\r\t ");
        }
#line 2487
        if (param) {
#line 2487
          param ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2492
      if ((int )hinfo->filename[0] == 0) {
        {
#line 2494
        snprintf((char */* __restrict  */)(hinfo->filename), sizeof(hinfo->filename),
                 (char const   */* __restrict  */)"%s", hinfo->name);
        }
      }
#line 2498
      if (hinfo->content_type == 102) {
        {
#line 2500
        snprintf((char */* __restrict  */)(glb___0.appledouble_filename), sizeof(glb___0.appledouble_filename),
                 (char const   */* __restrict  */)"%s", hinfo->filename);
        }
#line 2501
        if (glb___0.debug >= 1) {
          {
#line 2501
          LOGGER_log((char *)"%s:%d:MIMEH_parse_contentdisposition:DEBUG: Setting appledouble filename to: \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2501, glb___0.appledouble_filename);
          }
        }
      }
    }
  }
#line 2508
  if ((unsigned long )hv != (unsigned long )((void *)0)) {
    {
#line 2508
    free((void *)hv);
    }
  }
#line 2510
  return (0);
}
}
#line 2533 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_generic(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ,
                        char *tokenstr , char *buffer , size_t bsize ) 
{ 
  int compare_result ;
  int tlen ;
  size_t tmp ;

  {
#line 2535
  compare_result = 0;
#line 2538
  if (glb___0.debug >= 1) {
    {
#line 2538
    LOGGER_log((char *)"%s:%d:MIMEH_parse_generic:DEBUG: Searching for %s in %s",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2538,
               tokenstr, header_name);
    }
  }
#line 2540
  if ((unsigned long )hinfo == (unsigned long )((void *)0)) {
#line 2540
    return (-1);
  }
#line 2541
  if ((unsigned long )tokenstr == (unsigned long )((void *)0)) {
#line 2541
    return (-1);
  }
#line 2542
  if ((unsigned long )header_name == (unsigned long )((void *)0)) {
#line 2542
    return (-1);
  }
#line 2543
  if ((unsigned long )header_value == (unsigned long )((void *)0)) {
#line 2543
    return (-1);
  }
#line 2544
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 2544
    return (-1);
  }
#line 2545
  if (bsize < 1UL) {
#line 2545
    return (-1);
  }
  {
#line 2547
  tmp = strlen((char const   *)tokenstr);
#line 2547
  tlen = (int )tmp;
#line 2548
  compare_result = strncmp((char const   *)header_name, (char const   *)tokenstr,
                           (size_t )tlen);
  }
#line 2549
  if (compare_result == 0) {
    {
#line 2556
    if ((int )*(header_name + tlen) == 0) {
#line 2556
      goto case_0;
    }
#line 2556
    if ((int )*(header_name + tlen) == 9) {
#line 2556
      goto case_0;
    }
#line 2556
    if ((int )*(header_name + tlen) == 32) {
#line 2556
      goto case_0;
    }
#line 2556
    if ((int )*(header_name + tlen) == 58) {
#line 2556
      goto case_0;
    }
#line 2552
    goto switch_break;
    case_0: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_58: /* CIL Label */ 
#line 2557
    if (glb___0.debug >= 1) {
      {
#line 2557
      LOGGER_log((char *)"%s:%d:MIMEH_parse_generic:DEBUG: Located! Sanity up +1",
                 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2557);
      }
    }
    {
#line 2558
    snprintf((char */* __restrict  */)buffer, bsize, (char const   */* __restrict  */)"%s",
             header_value);
#line 2559
    (hinfo->sanity) ++;
    }
#line 2560
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2565
  return (0);
}
}
#line 2585 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_subject(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int result ;

  {
  {
#line 2587
  result = 0;
#line 2588
  result = MIMEH_parse_generic(header_name, header_value, hinfo, (char *)"subject",
                               hinfo->subject, sizeof(hinfo->subject));
#line 2589
  snprintf((char */* __restrict  */)(glb___0.subject), sizeof(glb___0.subject), (char const   */* __restrict  */)"%s",
           hinfo->subject);
  }
#line 2591
  return (result);
}
}
#line 2614 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_date(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int tmp ;

  {
  {
#line 2616
  tmp = MIMEH_parse_generic(header_name, header_value, hinfo, (char *)"date", hinfo->date,
                            sizeof(hinfo->date));
  }
#line 2616
  return (tmp);
}
}
#line 2635 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_from(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int tmp ;

  {
  {
#line 2637
  tmp = MIMEH_parse_generic(header_name, header_value, hinfo, (char *)"from", hinfo->from,
                            sizeof(hinfo->from));
  }
#line 2637
  return (tmp);
}
}
#line 2656 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_to(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int tmp ;

  {
  {
#line 2658
  tmp = MIMEH_parse_generic(header_name, header_value, hinfo, (char *)"to", hinfo->to,
                            sizeof(hinfo->to));
  }
#line 2658
  return (tmp);
}
}
#line 2677 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_messageid(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int tmp ;

  {
  {
#line 2679
  tmp = MIMEH_parse_generic(header_name, header_value, hinfo, (char *)"message-id",
                            hinfo->messageid, sizeof(hinfo->messageid));
  }
#line 2679
  return (tmp);
}
}
#line 2698 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_received(char *header_name , char *header_value , struct MIMEH_header_info *hinfo ) 
{ 
  int tmp ;

  {
  {
#line 2700
  tmp = MIMEH_parse_generic(header_name, header_value, hinfo, (char *)"received",
                            hinfo->received, sizeof(hinfo->received));
  }
#line 2700
  return (tmp);
}
}
#line 2719 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_headers_process(struct MIMEH_header_info *hinfo , char *headers ) 
{ 
  char *h ;
  char *safehl ;
  char *current_header_position ;
  int headerlength ;
  size_t tmp ;
  void *tmp___0 ;
  char *header_name ;
  char *header_value ;
  char *header_name_end_position ;
  char *header_value_end_position ;
  char tmp___1[128] ;
  size_t tmp___2 ;

  {
#line 2727
  if (glb___0.debug >= 1) {
    {
#line 2727
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Start [hinfo=%p]\n", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               2727, hinfo);
    }
  }
  {
#line 2729
  h = headers;
#line 2734
  tmp = strlen((char const   *)h);
#line 2734
  headerlength = (int )tmp;
#line 2735
  tmp___0 = malloc(sizeof(char ) * (unsigned long )(headerlength + 1));
#line 2735
  safehl = (char *)tmp___0;
#line 2736
  PLD_strncpy(safehl, (char const   *)h, (size_t )(headerlength + 1));
  }
#line 2738
  if (glb___0.debug >= 1) {
    {
#line 2738
    LOGGER_log((char *)"%s:%d:MIME_parse_headers:DEBUG: Header length = %d\n", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               2738, headerlength);
    }
  }
  {
#line 2740
  MIMEH_strip_comments(h);
#line 2742
  current_header_position = h;
  }
  {
#line 2747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2747
    if ((unsigned long )current_header_position != (unsigned long )((void *)0)) {
#line 2747
      if (! ((unsigned long )current_header_position <= (unsigned long )(h + headerlength))) {
#line 2747
        goto while_break;
      }
    } else {
#line 2747
      goto while_break;
    }
#line 2753
    if (glb___0.debug >= 1) {
      {
#line 2753
      LOGGER_log((char *)"%s:%d:MIMEH_headers_process:DEBUG: Processing \'%s\'", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                 2753, current_header_position);
      }
    }
    {
#line 2756
    header_name = current_header_position;
#line 2757
    header_name_end_position = strpbrk((char const   *)header_name, ":\t ");
    }
#line 2758
    if ((unsigned long )header_name_end_position == (unsigned long )((void *)0)) {
#line 2769
      if (glb___0.debug >= 1) {
        {
#line 2769
        LOGGER_log((char *)"%s:%d:MIMEH_headers_process:DEBUG: Could not locate \':\' separator, using whitespace (source=\'%s\')",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2769,
                   header_name);
        }
      }
      {
#line 2770
      header_name_end_position = strpbrk((char const   *)header_name, "\t ");
      }
#line 2771
      if ((unsigned long )header_name_end_position == (unsigned long )((void *)0)) {
#line 2773
        if (glb___0.debug >= 1) {
          {
#line 2773
          LOGGER_log((char *)"%s:%d:MIMEH_headers_process:DEBUG: Cannot find a header name:value pair in \'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2773, header_name);
          }
        }
      }
    }
    {
#line 2783
    current_header_position = strpbrk((char const   *)current_header_position, "\n\r");
    }
#line 2784
    if ((unsigned long )current_header_position == (unsigned long )((void *)0)) {
#line 2794
      goto while_continue;
    } else {
      {
#line 2802
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2802
        if (! ((int )*current_header_position == 10)) {
#line 2802
          if (! ((int )*current_header_position == 13)) {
#line 2802
            goto while_break___0;
          }
        }
#line 2802
        current_header_position ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2805
    if ((unsigned long )header_name_end_position == (unsigned long )((void *)0)) {
#line 2805
      goto _L;
    } else
#line 2805
    if ((unsigned long )header_name_end_position > (unsigned long )current_header_position) {
      _L: /* CIL Label */ 
#line 2812
      if (glb___0.debug >= 1) {
        {
#line 2812
        LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: This line contains no header:value pair (%s)",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2812,
                   current_header_position);
        }
      }
#line 2813
      goto while_continue;
    } else {
      {
#line 2821
      header_value = header_name_end_position + 1;
#line 2822
      header_value_end_position = strpbrk((char const   *)header_value, "\n\r");
      }
#line 2823
      if ((unsigned long )header_value_end_position != (unsigned long )((void *)0)) {
#line 2825
        *header_name_end_position = (char )'\000';
#line 2826
        *header_value_end_position = (char )'\000';
#line 2827
        if (glb___0.debug >= 1) {
          {
#line 2829
          LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Header Name =\'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2829, header_name);
#line 2830
          LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Header Value=\'%s\'",
                     "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                     2830, header_value);
          }
        }
        {
#line 2840
        PLD_strlower(header_name);
#line 2841
        MIMEH_parse_subject(header_name, header_value, hinfo);
#line 2842
        MIMEH_parse_contenttype(header_name, header_value, hinfo);
#line 2843
        MIMEH_parse_contenttransferencoding(header_name, header_value, hinfo);
#line 2844
        MIMEH_parse_contentdisposition(header_name, header_value, hinfo);
#line 2847
        MIMEH_parse_date(header_name, header_value, hinfo);
#line 2848
        MIMEH_parse_from(header_name, header_value, hinfo);
#line 2849
        MIMEH_parse_to(header_name, header_value, hinfo);
#line 2850
        MIMEH_parse_messageid(header_name, header_value, hinfo);
#line 2851
        MIMEH_parse_received(header_name, header_value, hinfo);
        }
#line 2853
        if ((int )hinfo->filename[0] == 0) {
          {
#line 2855
          MIMEH_parse_contentlocation(header_name, header_value, hinfo);
          }
        }
      } else
#line 2859
      if (glb___0.debug >= 1) {
        {
#line 2859
        LOGGER_log((char *)"%s:%d:MIMEH_parse_headerss:DEBUG: Header value end position is NULL",
                   "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2859);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2868
  if (hinfo->content_type == 102) {
    {
#line 2871
    snprintf((char */* __restrict  */)(tmp___1), sizeof(tmp___1), (char const   */* __restrict  */)"mac-%s",
             hinfo->filename);
#line 2872
    snprintf((char */* __restrict  */)(hinfo->filename), sizeof(hinfo->filename),
             (char const   */* __restrict  */)"%s", tmp___1);
#line 2873
    snprintf((char */* __restrict  */)(hinfo->name), sizeof(hinfo->name), (char const   */* __restrict  */)"%s",
             tmp___1);
    }
  }
#line 2881
  if (hinfo->content_type == 800) {
#line 2883
    if (hinfo->content_transfer_encoding == -1) {
#line 2889
      hinfo->content_transfer_encoding = 104;
    } else
#line 2883
    if (hinfo->content_transfer_encoding == 0) {
#line 2889
      hinfo->content_transfer_encoding = 104;
    } else {
      {
#line 2883
      tmp___2 = strlen((char const   *)(hinfo->content_transfer_encoding_string));
      }
#line 2883
      if (tmp___2 < 1UL) {
#line 2889
        hinfo->content_transfer_encoding = 104;
      }
    }
  }
#line 2894
  if (safehl) {
    {
#line 2896
    free((void *)safehl);
    }
  } else {
    {
#line 2898
    LOGGER_log((char *)"%s:%d:MIME_parse_headers:WARNING: Unable to free HEADERS allocated memory\n",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 2898);
    }
  }
#line 2900
  if (glb___0.debug >= 1) {
    {
#line 2900
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: END [hinfo=%p]\n", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               2900, hinfo);
    }
  }
#line 2902
  return (0);
}
}
#line 2922 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_headers_get(struct MIMEH_header_info *hinfo , FFGET_FILE *f ) 
{ 
  int result ;

  {
  {
#line 2924
  result = 0;
#line 2927
  hinfo->filename[0] = (char )'\000';
#line 2928
  hinfo->name[0] = (char )'\000';
#line 2929
  hinfo->content_type = 0;
#line 2930
  hinfo->subject[0] = (char )'\000';
#line 2933
  hinfo->content_disposition = 0;
#line 2934
  hinfo->content_transfer_encoding = 0;
#line 2935
  hinfo->boundary_located = 0;
#line 2937
  hinfo->crlf_count = 0;
#line 2938
  hinfo->crcr_count = 0;
#line 2939
  hinfo->lf_count = 0;
#line 2940
  snprintf((char */* __restrict  */)(hinfo->delimeter), sizeof(hinfo->delimeter),
           (char const   */* __restrict  */)"\r\n");
#line 2943
  hinfo->header_defect_count = 0;
#line 2944
  memset((void *)(hinfo->defects), 0, (size_t )100);
#line 2946
  snprintf((char */* __restrict  */)(hinfo->content_type_string), (size_t )128, (char const   */* __restrict  */)"text/plain");
#line 2950
  FFGET_set_watch_SDL(1);
#line 2951
  result = MIMEH_read_headers(hinfo, f);
#line 2952
  FFGET_set_watch_SDL(0);
  }
#line 2954
  if (hinfo->lf_count > hinfo->crlf_count) {
    {
#line 2955
    snprintf((char */* __restrict  */)(hinfo->delimeter), sizeof(hinfo->delimeter),
             (char const   */* __restrict  */)"\n");
    }
  }
#line 2960
  if (result == -1) {
#line 2962
    if (glb___0.headerline) {
      {
#line 2962
      free((void *)glb___0.headerline);
      }
    }
#line 2963
    return (result);
  }
#line 2968
  if ((unsigned long )glb___0.headerline == (unsigned long )((void *)0)) {
#line 2970
    if (glb___0.debug >= 1) {
      {
#line 2970
      LOGGER_log((char *)"%s:%d:MIME_parse_headers:DEBUG: null headerline\n", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
                 2970);
      }
    }
#line 2971
    return (1);
  }
#line 2974
  return (result);
}
}
#line 2992 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_headers_cleanup(void) 
{ 


  {
#line 2994
  if ((unsigned long )glb___0.headerline != (unsigned long )((void *)0)) {
    {
#line 2996
    free((void *)glb___0.headerline);
#line 2997
    glb___0.headerline = (char *)((void *)0);
    }
  }
#line 3000
  if ((unsigned long )glb___0.headerline_original != (unsigned long )((void *)0)) {
    {
#line 3002
    free((void *)glb___0.headerline_original);
#line 3003
    glb___0.headerline_original = (char *)((void *)0);
    }
  }
#line 3006
  return (0);
}
}
#line 3027 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_parse_headers(FFGET_FILE *f , struct MIMEH_header_info *hinfo ) 
{ 
  int result ;

  {
#line 3029
  result = 0;
#line 3030
  if (glb___0.debug >= 1) {
    {
#line 3030
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Start [F=%p, hinfo=%p]\n",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 3030,
               f, hinfo);
    }
  }
#line 3033
  if (result == 0) {
#line 3033
    hinfo->sanity = 0;
  }
#line 3036
  if (glb___0.debug >= 1) {
    {
#line 3036
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Getting headers", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               3036);
    }
  }
#line 3037
  if (result == 0) {
    {
#line 3037
    result = MIMEH_headers_get(hinfo, f);
    }
  }
#line 3038
  if (glb___0.debug >= 1) {
    {
#line 3038
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Processing headers", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               3038);
    }
  }
#line 3039
  if (result == 0) {
    {
#line 3039
    result = MIMEH_headers_process(hinfo, glb___0.headerline);
    }
  }
#line 3040
  if (glb___0.debug >= 1) {
    {
#line 3040
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: Cleanup of headers", "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c",
               3040);
    }
  }
#line 3041
  if (result == 0) {
    {
#line 3041
    result = MIMEH_headers_cleanup();
    }
  }
#line 3042
  if (glb___0.debug >= 1) {
    {
#line 3042
    LOGGER_log((char *)"%s:%d:MIMEH_parse_headers:DEBUG: END [F=%p, hinfo=%p, sanity=%d]\n",
               "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c", 3042,
               f, hinfo, hinfo->sanity);
    }
  }
#line 3044
  return (result);
}
}
#line 3063 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_dump_defects(struct MIMEH_header_info *hinfo ) 
{ 
  int i ;

  {
  {
#line 3067
  MIMEH_defect_description_array[8] = strdup("Missing separators");
#line 3068
  MIMEH_defect_description_array[7] = strdup("Multiple field occurance");
#line 3069
  MIMEH_defect_description_array[6] = strdup("Unbalanced boundary quote");
#line 3070
  MIMEH_defect_description_array[5] = strdup("Multiple boundries");
#line 3071
  MIMEH_defect_description_array[4] = strdup("Multiple colon separators");
#line 3072
  MIMEH_defect_description_array[3] = strdup("Multiple equals separators");
#line 3073
  MIMEH_defect_description_array[2] = strdup("Unbalanced quotes");
#line 3074
  MIMEH_defect_description_array[1] = strdup("Multiple quotes");
#line 3075
  MIMEH_defect_description_array[9] = strdup("Multiple names");
#line 3076
  MIMEH_defect_description_array[10] = strdup("Multiple filenames");
#line 3078
  i = 0;
  }
  {
#line 3078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3078
    if (! (i < 100)) {
#line 3078
      goto while_break;
    }
#line 3080
    if (hinfo->defects[i] > 0) {
      {
#line 3082
      LOGGER_log((char *)"Header Defect: %s: %d", MIMEH_defect_description_array[i],
                 hinfo->defects[i]);
      }
    }
#line 3078
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3087
  return (0);
}
}
#line 3105 "/home/june/collector/temp/altermime-0.3.10/MIME_headers.c"
int MIMEH_get_defect_count(struct MIMEH_header_info *hinfo ) 
{ 


  {
#line 3108
  return (hinfo->header_defect_count);
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 1 "/home/june/collector/temp/altermime-0.3.10/filename-filters.h"
int FNFILTER_init(void) ;
#line 2
int FNFILTER_set_debug(int level ) ;
#line 3
int FNFILTER_set_verbose(int level ) ;
#line 4
int FNFILTER_set_paranoid(int level ) ;
#line 46 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
static struct FNFILTER_globals glb___1  ;
#line 49 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_init(void) 
{ 


  {
#line 51
  glb___1.debug = 0;
#line 52
  glb___1.verbose = 0;
#line 53
  glb___1.paranoid = 0;
#line 54
  glb___1.x_mac = 0;
#line 56
  return (0);
}
}
#line 60 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_set_debug(int level ) 
{ 


  {
#line 62
  glb___1.debug = level;
#line 64
  return (glb___1.debug);
}
}
#line 67 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_set_verbose(int level ) 
{ 


  {
#line 69
  glb___1.verbose = level;
#line 71
  return (glb___1.verbose);
}
}
#line 75 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_set_mac(int level ) 
{ 


  {
#line 77
  glb___1.x_mac = level;
#line 79
  return (glb___1.x_mac);
}
}
#line 82 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_set_paranoid(int level ) 
{ 


  {
#line 84
  glb___1.paranoid = level;
#line 86
  return (glb___1.paranoid);
}
}
#line 97 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_paranoid_filter(char *fname , int size ) 
{ 
  char tmp[1024] ;
  char *p ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 109
  if (1 == size) {
#line 109
    if (46 == (int )*fname) {
#line 111
      *fname = (char )'_';
#line 112
      return (0);
    } else {
#line 109
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 113
  if (2 == size) {
    {
#line 113
    tmp___0 = strncmp((char const   *)fname, "..", (size_t )2);
    }
#line 113
    if (0 == tmp___0) {
      {
#line 114
      snprintf((char */* __restrict  */)fname, (size_t )3, (char const   */* __restrict  */)"__");
      }
#line 115
      return (0);
    }
  }
  {
#line 121
  p = strrchr((char const   *)fname, '/');
  }
#line 122
  if (p) {
#line 125
    if ((int )*(p + 1) == 0) {
#line 125
      *p = (char )'\000';
    } else {
      {
#line 128
      p ++;
#line 129
      PLD_strncpy(tmp, (char const   *)p, sizeof(tmp));
#line 130
      PLD_strncpy(fname, (char const   *)(tmp), (size_t )size);
      }
    }
  } else {
    {
#line 133
    p = strrchr((char const   *)fname, '\\');
    }
#line 133
    if (p) {
#line 136
      if ((int )*(p + 1) == 0) {
#line 136
        *p = (char )'\000';
      } else {
        {
#line 139
        p ++;
#line 140
        PLD_strncpy(tmp, (char const   *)p, sizeof(tmp));
#line 141
        PLD_strncpy(fname, (char const   *)(tmp), (size_t )size);
        }
      }
    }
  }
#line 146
  if (glb___1.paranoid > 0) {
    {
#line 154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 154
      if (! *fname) {
#line 154
        goto while_break;
      }
      {
#line 156
      tmp___1 = __ctype_b_loc();
      }
#line 156
      if (! ((int const   )*(*tmp___1 + (int )*fname) & 8)) {
#line 156
        if ((int )*fname != 46) {
#line 156
          *fname = (char )'_';
        }
      }
#line 157
      if ((int )*fname < 32) {
#line 157
        *fname = (char )'_';
      } else
#line 157
      if ((int )*fname > 126) {
#line 157
        *fname = (char )'_';
      }
#line 158
      fname ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 162
  return (0);
}
}
#line 180 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c"
int FNFILTER_filter(char *fname , int size ) 
{ 
  int fnl ;
  char tmp[1024] ;
  char *p ;
  size_t tmp___0 ;
  char *q ;
  size_t tmp___1 ;

  {
#line 186
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 186
    return (0);
  }
  {
#line 188
  tmp___0 = strlen((char const   *)fname);
#line 188
  fnl = (int )tmp___0;
  }
#line 190
  if (glb___1.debug >= 1) {
    {
#line 190
    LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: fname[%d chars] = \'%s\'\n",
               "/home/june/collector/temp/altermime-0.3.10/filename-filters.c", 190,
               fnl, fname);
    }
  }
#line 193
  if (glb___1.x_mac == 1) {
#line 195
    q = fname;
#line 197
    if (glb___1.debug >= 1) {
      {
#line 197
      LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: Filtering x-mac filename \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c",
                 197, fname);
      }
    }
    {
#line 198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 198
      if (! *q) {
#line 198
        goto while_break;
      }
#line 200
      if ((int )*q == 47) {
#line 200
        *q = (char )'-';
      }
#line 201
      q ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 203
    if (glb___1.debug >= 1) {
      {
#line 203
      LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: x-mac filename is now \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/filename-filters.c",
                 203, fname);
      }
    }
  }
#line 210
  if (fnl > 2) {
#line 214
    if ((int )*(fname + 0) == 34) {
#line 214
      if ((int )*(fname + (fnl - 1)) == 34) {
#line 216
        if (glb___1.debug >= 1) {
          {
#line 216
          LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: Trimming quotes off filename\n",
                     "/home/june/collector/temp/altermime-0.3.10/filename-filters.c",
                     216);
          }
        }
        {
#line 219
        fnl -= 2;
#line 222
        memmove((void *)fname, (void const   *)(fname + 1), (size_t )fnl);
#line 225
        *(fname + fnl) = (char )'\000';
        }
#line 226
        if (glb___1.debug >= 1) {
          {
#line 226
          LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: Trimming filename done, fname = \'%s\'\n",
                     "/home/june/collector/temp/altermime-0.3.10/filename-filters.c",
                     226, fname);
          }
        }
      }
    }
  }
  {
#line 230
  p = strrchr((char const   *)fname, '/');
  }
#line 231
  if (p) {
    {
#line 233
    p ++;
#line 234
    PLD_strncpy(tmp, (char const   *)p, sizeof(tmp));
#line 235
    PLD_strncpy(fname, (char const   *)(tmp), (size_t )size);
    }
  } else {
    {
#line 241
    p = strrchr((char const   *)fname, '\\');
    }
#line 242
    if (p) {
#line 244
      if ((int )*(p + 1) != 34) {
        {
#line 246
        p ++;
#line 247
        PLD_strncpy(tmp, (char const   *)p, sizeof(tmp));
#line 248
        PLD_strncpy(fname, (char const   *)(tmp), (size_t )size);
        }
      }
    }
  }
  {
#line 257
  p = strchr((char const   *)fname, '?');
  }
#line 258
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 260
    if ((unsigned long )p > (unsigned long )fname) {
#line 262
      if ((int )*(p - 1) != 61) {
#line 264
        *p = (char )'\000';
      }
    } else {
#line 271
      *p = (char )'-';
    }
  }
#line 275
  if (glb___1.debug >= 1) {
    {
#line 275
    LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: Starting paranoia filter\n",
               "/home/june/collector/temp/altermime-0.3.10/filename-filters.c", 275);
    }
  }
  {
#line 277
  tmp___1 = strlen((char const   *)fname);
#line 277
  FNFILTER_paranoid_filter(fname, (int )tmp___1);
  }
#line 279
  if (glb___1.debug >= 1) {
    {
#line 279
    LOGGER_log((char *)"%s:%d:FNFILTER_filter:DEBUG: paranoia filter done. Filename=\'%s\'\n",
               "/home/june/collector/temp/altermime-0.3.10/filename-filters.c", 279,
               fname);
    }
  }
#line 281
  return (0);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 19 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
char ALTERMIMEAPP_VERSION[90]  = 
#line 19 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
  {      (char )'a',      (char )'l',      (char )'t',      (char )'e', 
        (char )'r',      (char )'M',      (char )'I',      (char )'M', 
        (char )'E',      (char )' ',      (char )'v',      (char )'0', 
        (char )'.',      (char )'3',      (char )'.',      (char )'1', 
        (char )'0',      (char )' ',      (char )'(',      (char )'N', 
        (char )'o',      (char )'v',      (char )'e',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )'-', 
        (char )'2',      (char )'0',      (char )'0',      (char )'8', 
        (char )')',      (char )' ',      (char )'b',      (char )'y', 
        (char )' ',      (char )'P',      (char )'a',      (char )'u', 
        (char )'l',      (char )' ',      (char )'L',      (char )' ', 
        (char )'D',      (char )'a',      (char )'n',      (char )'i', 
        (char )'e',      (char )'l',      (char )'s',      (char )' ', 
        (char )'-',      (char )' ',      (char )'h',      (char )'t', 
        (char )'t',      (char )'p',      (char )':',      (char )'/', 
        (char )'/',      (char )'w',      (char )'w',      (char )'w', 
        (char )'.',      (char )'p',      (char )'l',      (char )'d', 
        (char )'a',      (char )'n',      (char )'i',      (char )'e', 
        (char )'l',      (char )'s',      (char )'.',      (char )'c', 
        (char )'o',      (char )'m',      (char )'/',      (char )'a', 
        (char )'l',      (char )'t',      (char )'e',      (char )'r', 
        (char )'m',      (char )'i',      (char )'m',      (char )'e', 
        (char )'\n',      (char )'\000'};
#line 20 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
char ALTERMIMEAPP_USAGE[2592]  = 
#line 20
  {      (char )'a',      (char )'l',      (char )'t',      (char )'e', 
        (char )'r',      (char )'m',      (char )'i',      (char )'m', 
        (char )'e',      (char )' ',      (char )'-',      (char )'-', 
        (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )'=',      (char )'<',      (char )'i', 
        (char )'n',      (char )'p',      (char )'u',      (char )'t', 
        (char )' ',      (char )'m',      (char )'i',      (char )'m', 
        (char )'e',      (char )' ',      (char )'p',      (char )'a', 
        (char )'c',      (char )'k',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )'(',      (char )' ', 
        (char )'-',      (char )'-',      (char )'i',      (char )'n', 
        (char )'p',      (char )'u',      (char )'t',      (char )'=', 
        (char )'-',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'s',      (char )'t', 
        (char )'d',      (char )'i',      (char )'n',      (char )' ', 
        (char )')',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'d',      (char )'i', 
        (char )'s',      (char )'c',      (char )'l',      (char )'a', 
        (char )'i',      (char )'m',      (char )'e',      (char )'r', 
        (char )'=',      (char )'<',      (char )'d',      (char )'i', 
        (char )'s',      (char )'c',      (char )'l',      (char )'a', 
        (char )'i',      (char )'m',      (char )'e',      (char )'r', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'>',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'[',      (char )'-',      (char )'-', 
        (char )'d',      (char )'i',      (char )'s',      (char )'c', 
        (char )'l',      (char )'a',      (char )'i',      (char )'m', 
        (char )'e',      (char )'r',      (char )'-',      (char )'h', 
        (char )'t',      (char )'m',      (char )'l',      (char )'=', 
        (char )'<',      (char )'H',      (char )'T',      (char )'M', 
        (char )'L',      (char )' ',      (char )'d',      (char )'i', 
        (char )'s',      (char )'c',      (char )'l',      (char )'a', 
        (char )'i',      (char )'m',      (char )'e',      (char )'r', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'>',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'[',      (char )'-',      (char )'-', 
        (char )'d',      (char )'i',      (char )'s',      (char )'c', 
        (char )'l',      (char )'a',      (char )'i',      (char )'m', 
        (char )'e',      (char )'r',      (char )'-',      (char )'b', 
        (char )'6',      (char )'4',      (char )'=',      (char )'<', 
        (char )'B',      (char )'A',      (char )'S',      (char )'E', 
        (char )'6',      (char )'4',      (char )' ',      (char )'e', 
        (char )'n',      (char )'c',      (char )'o',      (char )'d', 
        (char )'e',      (char )'d',      (char )' ',      (char )'d', 
        (char )'i',      (char )'s',      (char )'l',      (char )'c', 
        (char )'a',      (char )'i',      (char )'m',      (char )'e', 
        (char )'r',      (char )'>',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'[',      (char )'-',      (char )'-', 
        (char )'h',      (char )'t',      (char )'m',      (char )'l', 
        (char )'t',      (char )'o',      (char )'o',      (char )']', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'[', 
        (char )'-',      (char )'-',      (char )'f',      (char )'o', 
        (char )'r',      (char )'c',      (char )'e',      (char )'-', 
        (char )'i',      (char )'n',      (char )'t',      (char )'o', 
        (char )'-',      (char )'b',      (char )'6',      (char )'4', 
        (char )']',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'f',      (char )'o', 
        (char )'r',      (char )'c',      (char )'e',      (char )'-', 
        (char )'f',      (char )'o',      (char )'r',      (char )'-', 
        (char )'b',      (char )'a',      (char )'d',      (char )'-', 
        (char )'h',      (char )'t',      (char )'m',      (char )'l', 
        (char )']',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'m',      (char )'u', 
        (char )'l',      (char )'t',      (char )'i',      (char )'p', 
        (char )'a',      (char )'r',      (char )'t',      (char )'-', 
        (char )'i',      (char )'n',      (char )'s',      (char )'e', 
        (char )'r',      (char )'t',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'[',      (char )'-',      (char )'-', 
        (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )'=',      (char )'<', 
        (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )' ',      (char )'(',      (char )'r',      (char )'e', 
        (char )'g',      (char )'e',      (char )'x',      (char )')', 
        (char )'>',      (char )']',      (char )' ',      (char )'(', 
        (char )'i',      (char )'f',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'t', 
        (char )'a',      (char )'i',      (char )'n',      (char )'s', 
        (char )' ',      (char )'a',      (char )' ',      (char )'/', 
        (char )',',      (char )' ',      (char )'m',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'e', 
        (char )'s',      (char )' ',      (char )'o',      (char )'n', 
        (char )' ',      (char )'m',      (char )'i',      (char )'m', 
        (char )'e',      (char )'-',      (char )'t',      (char )'y', 
        (char )'p',      (char )'e',      (char )' ',      (char )')', 
        (char )'\n',      (char )'\t',      (char )'[',      (char )'-', 
        (char )'-',      (char )'r',      (char )'e',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )'a', 
        (char )'l',      (char )'l',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'[',      (char )'-',      (char )'-', 
        (char )'r',      (char )'e',      (char )'p',      (char )'l', 
        (char )'a',      (char )'c',      (char )'e',      (char )'=', 
        (char )'<',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'r',      (char )'e',      (char )'p', 
        (char )'l',      (char )'a',      (char )'c',      (char )'e', 
        (char )'>',      (char )' ',      (char )'-',      (char )'-', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )'=',      (char )'<',      (char )'r',      (char )'e', 
        (char )'p',      (char )'l',      (char )'a',      (char )'c', 
        (char )'e',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )'>',      (char )']', 
        (char )'\n',      (char )'\t',      (char )'[',      (char )'-', 
        (char )'-',      (char )'x',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'e',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'.',      (char )'.', 
        (char )'.',      (char )'\"',      (char )'\n',      (char )'\t', 
        (char )'[',      (char )'-',      (char )'-',      (char )'a', 
        (char )'l',      (char )'t',      (char )'e',      (char )'r', 
        (char )'-',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'.',      (char )'.',      (char )'.', 
        (char )'\"',      (char )' ',      (char )'-',      (char )'-', 
        (char )'a',      (char )'l',      (char )'t',      (char )'e', 
        (char )'r',      (char )'-',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )'=',      (char )'\"', 
        (char )'.',      (char )'.',      (char )'.',      (char )'\"', 
        (char )' ',      (char )'-',      (char )'-',      (char )'a', 
        (char )'l',      (char )'t',      (char )'e',      (char )'r', 
        (char )'-',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )'=',      (char )'<',      (char )'p', 
        (char )'r',      (char )'e',      (char )'f',      (char )'i', 
        (char )'x',      (char )'|',      (char )'s',      (char )'u', 
        (char )'f',      (char )'f',      (char )'i',      (char )'x', 
        (char )'|',      (char )'r',      (char )'e',      (char )'p', 
        (char )'l',      (char )'a',      (char )'c',      (char )'e', 
        (char )'>',      (char )']',      (char )'\n',      (char )'\t', 
        (char )'[',      (char )'-',      (char )'-',      (char )'a', 
        (char )'l',      (char )'t',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'g',      (char )'n', 
        (char )'e',      (char )'d',      (char )']',      (char )'\n', 
        (char )'\t',      (char )'[',      (char )'-',      (char )'-', 
        (char )'n',      (char )'o',      (char )'-',      (char )'q', 
        (char )'m',      (char )'a',      (char )'i',      (char )'l', 
        (char )'-',      (char )'b',      (char )'o',      (char )'u', 
        (char )'n',      (char )'c',      (char )'e',      (char )']', 
        (char )'\n',      (char )'\t',      (char )'[',      (char )'-', 
        (char )'-',      (char )'v',      (char )'e',      (char )'r', 
        (char )'b',      (char )'o',      (char )'s',      (char )'e', 
        (char )']',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'l',      (char )'o', 
        (char )'g',      (char )'-',      (char )'s',      (char )'t', 
        (char )'d',      (char )'o',      (char )'u',      (char )'t', 
        (char )']',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'l',      (char )'o', 
        (char )'g',      (char )'-',      (char )'s',      (char )'t', 
        (char )'d',      (char )'e',      (char )'r',      (char )'r', 
        (char )']',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'l',      (char )'o', 
        (char )'g',      (char )'-',      (char )'s',      (char )'y', 
        (char )'s',      (char )'l',      (char )'o',      (char )'g', 
        (char )']',      (char )'\n',      (char )'\t',      (char )'[', 
        (char )'-',      (char )'-',      (char )'d',      (char )'e', 
        (char )'b',      (char )'u',      (char )'g',      (char )']', 
        (char )'\n',      (char )'\t',      (char )'[',      (char )'-', 
        (char )'-',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )']',      (char )'\n',      (char )'\n',      (char )'O', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'D',      (char )'e', 
        (char )'s',      (char )'c',      (char )'r',      (char )'i', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )':',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'-',      (char )'i', 
        (char )'n',      (char )'p',      (char )'u',      (char )'t', 
        (char )'=',      (char )',',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )'s',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'m',      (char )'a',      (char )'i',      (char )'l', 
        (char )'p',      (char )'a',      (char )'c',      (char )'k', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )' ',      (char )'s',      (char )'u',      (char )'p', 
        (char )'p',      (char )'l',      (char )'i',      (char )'e', 
        (char )'d',      (char )',',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'i',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'a',      (char )' ',      (char )'s',      (char )'i', 
        (char )'n',      (char )'g',      (char )'l',      (char )'e', 
        (char )' ',      (char )'\'',      (char )'-',      (char )'\'', 
        (char )' ',      (char )'(',      (char )'h',      (char )'y', 
        (char )'p',      (char )'h',      (char )'e',      (char )'n', 
        (char )')',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )'n',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'m', 
        (char )'a',      (char )'i',      (char )'l',      (char )'p', 
        (char )'a',      (char )'c',      (char )'k',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'i',      (char )'s', 
        (char )' ',      (char )'s',      (char )'o',      (char )'u', 
        (char )'r',      (char )'c',      (char )'e',      (char )'d', 
        (char )' ',      (char )'v',      (char )'i',      (char )'a', 
        (char )' ',      (char )'s',      (char )'t',      (char )'d', 
        (char )'i',      (char )'n',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'v',      (char )'i',      (char )'a', 
        (char )' ',      (char )'s',      (char )'t',      (char )'d', 
        (char )'o',      (char )'u',      (char )'t',      (char )'.', 
        (char )'\n',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'-',      (char )'d',      (char )'i',      (char )'s', 
        (char )'c',      (char )'l',      (char )'a',      (char )'i', 
        (char )'m',      (char )'e',      (char )'r',      (char )'=', 
        (char )',',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'p',      (char )'l', 
        (char )'a',      (char )'i',      (char )'n',      (char )'t', 
        (char )'e',      (char )'x',      (char )'t',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'c', 
        (char )'l',      (char )'a',      (char )'i',      (char )'m', 
        (char )'e',      (char )'r',      (char )' ',      (char )'s', 
        (char )'o',      (char )'u',      (char )'r',      (char )'c', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'.',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'-',      (char )'d', 
        (char )'i',      (char )'s',      (char )'c',      (char )'l', 
        (char )'a',      (char )'i',      (char )'m',      (char )'e', 
        (char )'r',      (char )'-',      (char )'h',      (char )'t', 
        (char )'m',      (char )'l',      (char )'=',      (char )',', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'H',      (char )'T',      (char )'M', 
        (char )'L',      (char )' ',      (char )'d',      (char )'i', 
        (char )'s',      (char )'c',      (char )'l',      (char )'a', 
        (char )'i',      (char )'m',      (char )'e',      (char )'r', 
        (char )' ',      (char )'s',      (char )'o',      (char )'u', 
        (char )'r',      (char )'c',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'.',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'-',      (char )'d',      (char )'i',      (char )'s', 
        (char )'c',      (char )'l',      (char )'a',      (char )'i', 
        (char )'m',      (char )'e',      (char )'r',      (char )'-', 
        (char )'b',      (char )'6',      (char )'4',      (char )'=', 
        (char )',',      (char )' ',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'B',      (char )'A', 
        (char )'S',      (char )'E',      (char )'6',      (char )'4', 
        (char )' ',      (char )'e',      (char )'n',      (char )'c', 
        (char )'o',      (char )'d',      (char )'e',      (char )'d', 
        (char )' ',      (char )'d',      (char )'i',      (char )'s', 
        (char )'c',      (char )'l',      (char )'a',      (char )'i', 
        (char )'m',      (char )'e',      (char )'r',      (char )' ', 
        (char )'s',      (char )'o',      (char )'u',      (char )'r', 
        (char )'c',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'(',      (char )'i',      (char )'m',      (char )'p', 
        (char )'l',      (char )'i',      (char )'e',      (char )'s', 
        (char )' ',      (char )'-',      (char )'-',      (char )'f', 
        (char )'o',      (char )'r',      (char )'c',      (char )'e', 
        (char )'-',      (char )'i',      (char )'n',      (char )'t', 
        (char )'o',      (char )'-',      (char )'b',      (char )'6', 
        (char )'4',      (char )')',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'h',      (char )'t',      (char )'m',      (char )'l', 
        (char )'t',      (char )'o',      (char )'o',      (char )',', 
        (char )' ',      (char )'S',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'a',      (char )'l', 
        (char )'t',      (char )'e',      (char )'r',      (char )'M', 
        (char )'I',      (char )'M',      (char )'E',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'i', 
        (char )'n',      (char )'s',      (char )'e',      (char )'r', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'p',      (char )'l', 
        (char )'a',      (char )'i',      (char )'n',      (char )'t', 
        (char )'e',      (char )'x',      (char )'t',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'c', 
        (char )'l',      (char )'a',      (char )'i',      (char )'m', 
        (char )'e',      (char )'r',      (char )' ',      (char )'i', 
        (char )'n',      (char )'t',      (char )'o',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'-',      (char )'f', 
        (char )'o',      (char )'r',      (char )'c',      (char )'e', 
        (char )'-',      (char )'i',      (char )'n',      (char )'t', 
        (char )'o',      (char )'-',      (char )'b',      (char )'6', 
        (char )'4',      (char )',',      (char )' ',      (char )'S', 
        (char )'e',      (char )'t',      (char )'s',      (char )' ', 
        (char )'a',      (char )'l',      (char )'t',      (char )'e', 
        (char )'r',      (char )'M',      (char )'I',      (char )'M', 
        (char )'E',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'i',      (char )'n',      (char )'s', 
        (char )'e',      (char )'r',      (char )'t',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'c', 
        (char )'l',      (char )'a',      (char )'i',      (char )'m', 
        (char )'e',      (char )'r',      (char )'s',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'o', 
        (char )' ',      (char )'B',      (char )'A',      (char )'S', 
        (char )'E',      (char )'6',      (char )'4',      (char )' ', 
        (char )'e',      (char )'n',      (char )'c',      (char )'o', 
        (char )'d',      (char )'e',      (char )'d',      (char )' ', 
        (char )'t',      (char )'e',      (char )'x',      (char )'t', 
        (char )' ',      (char )'s',      (char )'e',      (char )'g', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'s',      (char )'\n',      (char )'\t',      (char )'-', 
        (char )'-',      (char )'f',      (char )'o',      (char )'r', 
        (char )'c',      (char )'e',      (char )'-',      (char )'f', 
        (char )'o',      (char )'r',      (char )'-',      (char )'b', 
        (char )'a',      (char )'d',      (char )'-',      (char )'h', 
        (char )'t',      (char )'m',      (char )'l',      (char )',', 
        (char )' ',      (char )'F',      (char )'o',      (char )'r', 
        (char )'c',      (char )'e',      (char )' ',      (char )'a', 
        (char )'d',      (char )'d',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'H',      (char )'T',      (char )'M', 
        (char )'L',      (char )' ',      (char )'d',      (char )'i', 
        (char )'s',      (char )'c',      (char )'l',      (char )'a', 
        (char )'i',      (char )'m',      (char )'e',      (char )'r', 
        (char )' ',      (char )'e',      (char )'v',      (char )'e', 
        (char )'n',      (char )' ',      (char )'w',      (char )'h', 
        (char )'e',      (char )'n',      (char )' ',      (char )'H', 
        (char )'T',      (char )'M',      (char )'L',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'n', 
        (char )'o',      (char )'t',      (char )' ',      (char )'c', 
        (char )'o',      (char )'r',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'l',      (char )'y', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )'t', 
        (char )'e',      (char )'d',      (char )'\n',      (char )'\t', 
        (char )'\t',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'H',      (char )'T',      (char )'M', 
        (char )'L',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'e',      (char )'m',      (char )'a', 
        (char )'i',      (char )'l',      (char )' ',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'(',      (char )' ',      (char )'i',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'r',      (char )'e',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'n',      (char )'o', 
        (char )' ',      (char )'e',      (char )'x',      (char )'p', 
        (char )'l',      (char )'i',      (char )'c',      (char )'i', 
        (char )'t',      (char )'l',      (char )'y',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'d',      (char )'e', 
        (char )'f',      (char )'i',      (char )'n',      (char )'e', 
        (char )'d',      (char )' ',      (char )'H',      (char )'T', 
        (char )'M',      (char )'L',      (char )' ',      (char )'d', 
        (char )'i',      (char )'s',      (char )'l',      (char )'c', 
        (char )'a',      (char )'i',      (char )'m',      (char )'e', 
        (char )'r',      (char )',',      (char )' ',      (char )'s', 
        (char )'e',      (char )'e',      (char )' ',      (char )'-', 
        (char )'-',      (char )'d',      (char )'i',      (char )'s', 
        (char )'c',      (char )'l',      (char )'a',      (char )'i', 
        (char )'m',      (char )'e',      (char )'r',      (char )'-', 
        (char )'h',      (char )'t',      (char )'m',      (char )'l', 
        (char )' ',      (char )')',      (char )'\n',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'-',      (char )'r', 
        (char )'e',      (char )'m',      (char )'o',      (char )'v', 
        (char )'e',      (char )'=',      (char )',',      (char )' ', 
        (char )'R',      (char )'e',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )' ',      (char )'a', 
        (char )'n',      (char )'y',      (char )' ',      (char )'a', 
        (char )'t',      (char )'t',      (char )'a',      (char )'c', 
        (char )'h',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )'s',      (char )' ',      (char )'w', 
        (char )'h',      (char )'i',      (char )'c',      (char )'h', 
        (char )' ',      (char )'m',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'s',      (char )'u',      (char )'p',      (char )'p', 
        (char )'l',      (char )'i',      (char )'e',      (char )'d', 
        (char )',',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )'i',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'t',      (char )'e',      (char )'x',      (char )'t', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'t',      (char )'a',      (char )'i',      (char )'n', 
        (char )'s',      (char )' ',      (char )'a',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )'w', 
        (char )'a',      (char )'r',      (char )'d',      (char )'-', 
        (char )'s',      (char )'l',      (char )'a',      (char )'s', 
        (char )'h',      (char )' ',      (char )'\'',      (char )'/', 
        (char )'\'',      (char )',',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'m',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'o',      (char )'c',      (char )'c',      (char )'u', 
        (char )'r',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'t',      (char )'e', 
        (char )'n',      (char )'t',      (char )'-',      (char )'t', 
        (char )'y',      (char )'p',      (char )'e',      (char )' ', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'e',      (char )'r',      (char )'s',      (char )' ', 
        (char )'r',      (char )'a',      (char )'t',      (char )'h', 
        (char )'e',      (char )'r',      (char )' ',      (char )'t', 
        (char )'h',      (char )'a',      (char )'n',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'b',      (char )'y', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'-',      (char )'r',      (char )'e', 
        (char )'m',      (char )'o',      (char )'v',      (char )'e', 
        (char )'a',      (char )'l',      (char )'l',      (char )',', 
        (char )' ',      (char )'R',      (char )'e',      (char )'m', 
        (char )'o',      (char )'v',      (char )'e',      (char )' ', 
        (char )'a',      (char )'l',      (char )'l',      (char )' ', 
        (char )'a',      (char )'t',      (char )'t',      (char )'a', 
        (char )'c',      (char )'h',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'s',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'-',      (char )'r', 
        (char )'e',      (char )'p',      (char )'l',      (char )'a', 
        (char )'c',      (char )'e',      (char )'=',      (char )',', 
        (char )' ',      (char )'R',      (char )'e',      (char )'p', 
        (char )'l',      (char )'a',      (char )'c',      (char )'e', 
        (char )' ',      (char )'a',      (char )'t',      (char )'t', 
        (char )'a',      (char )'c',      (char )'h',      (char )'m', 
        (char )'e',      (char )'n',      (char )'t',      (char )'s', 
        (char )' ',      (char )'m',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'g',      (char )'i', 
        (char )'v',      (char )'e',      (char )'n',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'.',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'i',      (char )'r', 
        (char )'e',      (char )'s',      (char )' ',      (char )'t', 
        (char )'o',      (char )'\n',      (char )'\t',      (char )'\t', 
        (char )'b',      (char )'e',      (char )' ',      (char )'u', 
        (char )'s',      (char )'e',      (char )'d',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'-',      (char )'-',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )'.', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )'=',      (char )',',      (char )' ',      (char )'R', 
        (char )'e',      (char )'p',      (char )'l',      (char )'a', 
        (char )'c',      (char )'e',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'a', 
        (char )'t',      (char )'t',      (char )'a',      (char )'c', 
        (char )'h',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )'s',      (char )' ',      (char )'s', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'i',      (char )'e',      (char )'d', 
        (char )' ',      (char )'b',      (char )'y',      (char )' ', 
        (char )'-',      (char )'-',      (char )'r',      (char )'e', 
        (char )'p',      (char )'l',      (char )'a',      (char )'c', 
        (char )'e',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'\n', 
        (char )'\t',      (char )'\t',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'i',      (char )'e',      (char )'d',      (char )'.', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'x',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'r',      (char )'=', 
        (char )',',      (char )' ',      (char )'I',      (char )'n', 
        (char )'s',      (char )'e',      (char )'r',      (char )'t', 
        (char )' ',      (char )'a',      (char )' ',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'e', 
        (char )'r',      (char )' ',      (char )'l',      (char )'i', 
        (char )'n',      (char )'e',      (char )' ',      (char )'a', 
        (char )'s',      (char )' ',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'i',      (char )'f', 
        (char )'i',      (char )'e',      (char )'d',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'r', 
        (char )'s',      (char )'t',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'e',      (char )'r', 
        (char )'s',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'-',      (char )'a',      (char )'l', 
        (char )'t',      (char )'e',      (char )'r',      (char )'-', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'e',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'.',      (char )'.',      (char )'.',      (char )'\"', 
        (char )' ',      (char )'-',      (char )'-',      (char )'a', 
        (char )'l',      (char )'t',      (char )'e',      (char )'r', 
        (char )'-',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )'=',      (char )'\"',      (char )'.', 
        (char )'.',      (char )'.',      (char )'\"',      (char )' ', 
        (char )'-',      (char )'-',      (char )'a',      (char )'l', 
        (char )'t',      (char )'e',      (char )'r',      (char )'-', 
        (char )'m',      (char )'o',      (char )'d',      (char )'e', 
        (char )'=',      (char )'(',      (char )'p',      (char )'r', 
        (char )'e',      (char )'f',      (char )'i',      (char )'x', 
        (char )'|',      (char )'s',      (char )'u',      (char )'f', 
        (char )'f',      (char )'i',      (char )'x',      (char )'|', 
        (char )'r',      (char )'e',      (char )'p',      (char )'l', 
        (char )'a',      (char )'c',      (char )'e',      (char )')', 
        (char )'\n',      (char )'\t',      (char )'\t',      (char )'A', 
        (char )'l',      (char )'t',      (char )'e',      (char )'r', 
        (char )' ',      (char )'a',      (char )'n',      (char )' ', 
        (char )'e',      (char )'x',      (char )'i',      (char )'s', 
        (char )'t',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'r',      (char )' ', 
        (char )'i',      (char )'n',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'m', 
        (char )'a',      (char )'i',      (char )'l',      (char )'p', 
        (char )'a',      (char )'c',      (char )'k',      (char )'.', 
        (char )' ',      (char )' ',      (char )'T',      (char )'h', 
        (char )'i',      (char )'s',      (char )' ',      (char )'f', 
        (char )'u',      (char )'n',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'m',      (char )'o',      (char )'d',      (char )'i', 
        (char )'f',      (char )'i',      (char )'e',      (char )'s', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'\n',      (char )'\t',      (char )'\t',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'e',      (char )'r',      (char )',',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'a', 
        (char )'p',      (char )'p',      (char )'o',      (char )'s', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'e',      (char )'r', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'.',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'-',      (char )'a',      (char )'l', 
        (char )'t',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'g',      (char )'n',      (char )'e', 
        (char )'d',      (char )',',      (char )' ',      (char )'F', 
        (char )'o',      (char )'r',      (char )'c',      (char )'e', 
        (char )' ',      (char )'a',      (char )'l',      (char )'t', 
        (char )'e',      (char )'r',      (char )'M',      (char )'I', 
        (char )'M',      (char )'E',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'i',      (char )'f',      (char )'y', 
        (char )' ',      (char )'\'',      (char )'s',      (char )'i', 
        (char )'g',      (char )'n',      (char )'e',      (char )'d', 
        (char )'\'',      (char )' ',      (char )'e',      (char )'m', 
        (char )'a',      (char )'i',      (char )'l',      (char )'s', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'n',      (char )'o',      (char )'-',      (char )'q', 
        (char )'m',      (char )'a',      (char )'i',      (char )'l', 
        (char )'-',      (char )'b',      (char )'o',      (char )'u', 
        (char )'n',      (char )'c',      (char )'e',      (char )',', 
        (char )' ',      (char )' ',      (char )'D',      (char )'o', 
        (char )'n',      (char )'\'',      (char )'t',      (char )' ', 
        (char )'s',      (char )'e',      (char )'a',      (char )'r', 
        (char )'c',      (char )'h',      (char )' ',      (char )'i', 
        (char )'n',      (char )'t',      (char )'o',      (char )' ', 
        (char )'e',      (char )'m',      (char )'a',      (char )'i', 
        (char )'l',      (char )' ',      (char )'b',      (char )'o', 
        (char )'d',      (char )'i',      (char )'e',      (char )'s', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'a',      (char )'t',      (char )'t', 
        (char )'a',      (char )'c',      (char )'h',      (char )'m', 
        (char )'e',      (char )'n',      (char )'t',      (char )' ', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'e',      (char )'r',      (char )'s',      (char )'\n', 
        (char )'\t',      (char )'-',      (char )'-',      (char )'v', 
        (char )'e',      (char )'r',      (char )'b',      (char )'o', 
        (char )'s',      (char )'e',      (char )',',      (char )' ', 
        (char )'D',      (char )'e',      (char )'s',      (char )'c', 
        (char )'r',      (char )'i',      (char )'b',      (char )'e', 
        (char )' ',      (char )'d',      (char )'e',      (char )'t', 
        (char )'a',      (char )'i',      (char )'l',      (char )'s', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'s',      (char )'s',      (char )' ', 
        (char )'o',      (char )'c',      (char )'c',      (char )'u', 
        (char )'r',      (char )'i',      (char )'n',      (char )'g', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'l',      (char )'o',      (char )'g',      (char )'-', 
        (char )'s',      (char )'t',      (char )'d',      (char )'o', 
        (char )'u',      (char )'t',      (char )',',      (char )' ', 
        (char )'S',      (char )'e',      (char )'n',      (char )'d', 
        (char )' ',      (char )'a',      (char )'l',      (char )'l', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'m',      (char )'e',      (char )'s',      (char )'s', 
        (char )'a',      (char )'g',      (char )'e',      (char )'s', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'s',      (char )'t',      (char )'d',      (char )'o', 
        (char )'u',      (char )'t',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'-',      (char )'l',      (char )'o', 
        (char )'g',      (char )'-',      (char )'s',      (char )'t', 
        (char )'d',      (char )'e',      (char )'r',      (char )'r', 
        (char )',',      (char )' ',      (char )'S',      (char )'e', 
        (char )'n',      (char )'d',      (char )' ',      (char )'a', 
        (char )'l',      (char )'l',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )' ',      (char )'m',      (char )'e', 
        (char )'s',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )'s',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'s',      (char )'t', 
        (char )'d',      (char )'e',      (char )'r',      (char )'r', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'l',      (char )'o',      (char )'g',      (char )'-', 
        (char )'s',      (char )'y',      (char )'s',      (char )'l', 
        (char )'o',      (char )'g',      (char )',',      (char )' ', 
        (char )'S',      (char )'e',      (char )'n',      (char )'d', 
        (char )' ',      (char )'a',      (char )'l',      (char )'l', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'m',      (char )'e',      (char )'s',      (char )'s', 
        (char )'a',      (char )'g',      (char )'e',      (char )'s', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'s',      (char )'y',      (char )'s',      (char )'l', 
        (char )'o',      (char )'g',      (char )'\n',      (char )'\t', 
        (char )'-',      (char )'-',      (char )'d',      (char )'e', 
        (char )'b',      (char )'u',      (char )'g',      (char )',', 
        (char )' ',      (char )'P',      (char )'r',      (char )'o', 
        (char )'v',      (char )'i',      (char )'d',      (char )'e', 
        (char )' ',      (char )'g',      (char )'r',      (char )'e', 
        (char )'a',      (char )'t',      (char )'e',      (char )'r', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'b',      (char )'o',      (char )'s',      (char )'i', 
        (char )'t',      (char )'y',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'d', 
        (char )'e',      (char )'b',      (char )'u',      (char )'g', 
        (char )'g',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )'\t',      (char )'-',      (char )'-', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )',', 
        (char )' ',      (char )'d',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'a',      (char )'l',      (char )'t', 
        (char )'e',      (char )'r',      (char )'M',      (char )'I', 
        (char )'M',      (char )'E',      (char )' ',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'\n',      (char )'\n',      (char )'\000'};
#line 89 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
char ALTERMIMEAPP_default_remove_prefix[8]  = 
#line 89
  {      (char )'r',      (char )'e',      (char )'m',      (char )'o', 
        (char )'v',      (char )'e',      (char )'d',      (char )'\000'};
#line 90 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
char ALTERMIMEAPP_removeall_filename[3]  = {      (char )'.',      (char )'*',      (char )'\000'};
#line 121 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
int ALTERMIMEAPP_parse_args(struct ALTERMIMEAPP_globals *glb___4 , int argc , char **argv ) 
{ 
  int i ;
  char *p ;
  char *q ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 124
  p = (char *)((void *)0);
#line 125
  q = (char *)((void *)0);
#line 127
  i = 1;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < argc)) {
#line 127
      goto while_break;
    }
#line 128
    if ((int )*(*(argv + i) + 0) == 45) {
#line 128
      if ((int )*(*(argv + i) + 1) == 45) {
        {
#line 130
        p = *(argv + i);
#line 131
        p += 2;
#line 133
        tmp___48 = strncmp((char const   *)p, "input=", (size_t )6);
        }
#line 133
        if (tmp___48 == 0) {
          {
#line 135
          tmp = strlen("input=");
#line 135
          glb___4->input_file = p + tmp;
          }
        } else {
          {
#line 137
          tmp___47 = strncmp((char const   *)p, "htmltoo", (size_t )7);
          }
#line 137
          if (tmp___47 == 0) {
            {
#line 139
            AM_set_HTMLtoo(1);
            }
          } else {
            {
#line 141
            tmp___46 = strncmp((char const   *)p, "force-into-b64", sizeof("force-into-b64"));
            }
#line 141
            if (tmp___46 == 0) {
              {
#line 143
              AM_set_force_into_b64(1);
              }
            } else {
              {
#line 145
              tmp___45 = strncmp((char const   *)p, "force-for-bad-html", sizeof("force-for-bad-html"));
              }
#line 145
              if (tmp___45 == 0) {
                {
#line 147
                AM_set_force_for_bad_html(1);
                }
              } else {
                {
#line 149
                tmp___43 = strlen("multipart-insert");
#line 149
                tmp___44 = strncmp((char const   *)p, "multipart-insert", tmp___43);
                }
#line 149
                if (tmp___44 == 0) {
                  {
#line 151
                  AM_set_multipart_insert(1);
                  }
                } else {
                  {
#line 167
                  tmp___42 = strncmp((char const   *)p, "disclaimer=", (size_t )11);
                  }
#line 167
                  if (tmp___42 == 0) {
                    {
#line 169
                    tmp___0 = strlen("disclaimer=");
#line 169
                    glb___4->disclaimer_file = p + tmp___0;
#line 170
                    AM_set_disclaimer_plain(glb___4->disclaimer_file, 1);
                    }
                  } else {
                    {
#line 172
                    tmp___41 = strncmp((char const   *)p, "disclaimer-html=", (size_t )16);
                    }
#line 172
                    if (tmp___41 == 0) {
                      {
#line 174
                      tmp___1 = strlen("disclaimer-html=");
#line 174
                      glb___4->disclaimer_html_file = p + tmp___1;
#line 175
                      AM_set_disclaimer_HTML(glb___4->disclaimer_html_file, 1);
#line 176
                      AM_set_HTMLtoo(1);
                      }
                    } else {
                      {
#line 178
                      tmp___39 = strlen("disclaimer-b64=");
#line 178
                      tmp___40 = strncmp((char const   *)p, "disclaimer-b64=", tmp___39);
                      }
#line 178
                      if (tmp___40 == 0) {
                        {
#line 179
                        tmp___2 = strlen("disclaimer-b64=");
#line 179
                        glb___4->disclaimer_b64_file = p + tmp___2;
#line 180
                        AM_set_disclaimer_b64(glb___4->disclaimer_b64_file, 1);
#line 181
                        AM_set_force_into_b64(1);
                        }
                      } else {
                        {
#line 183
                        tmp___38 = strncmp((char const   *)p, "remove=", (size_t )7);
                        }
#line 183
                        if (tmp___38 == 0) {
                          {
#line 185
                          tmp___3 = strlen("remove=");
#line 185
                          glb___4->remove_filename = p + tmp___3;
                          }
                        } else {
                          {
#line 187
                          tmp___37 = strncmp((char const   *)p, "remove_prefix=",
                                             (size_t )13);
                          }
#line 187
                          if (tmp___37 == 0) {
                            {
#line 189
                            LOGGER_log((char *)"--remove_prefix is depricated, ignoring");
                            }
                          } else {
                            {
#line 192
                            tmp___36 = strncmp((char const   *)p, "removeall", (size_t )9);
                            }
#line 192
                            if (tmp___36 == 0) {
#line 194
                              glb___4->remove_filename = ALTERMIMEAPP_removeall_filename;
                            } else {
                              {
#line 196
                              tmp___35 = strncmp((char const   *)p, "altersigned",
                                                 (size_t )11);
                              }
#line 196
                              if (tmp___35 == 0) {
                                {
#line 198
                                AM_set_altersigned(1);
                                }
                              } else {
                                {
#line 200
                                tmp___34 = strncmp((char const   *)p, "replace", (size_t )7);
                                }
#line 200
                                if (tmp___34 == 0) {
                                  {
#line 202
                                  tmp___4 = strlen("replace=");
#line 202
                                  glb___4->replace = p + tmp___4;
                                  }
                                } else {
                                  {
#line 204
                                  tmp___33 = strncmp((char const   *)p, "with", (size_t )4);
                                  }
#line 204
                                  if (tmp___33 == 0) {
                                    {
#line 206
                                    tmp___5 = strlen("with=");
#line 206
                                    glb___4->with = p + tmp___5;
                                    }
                                  } else {
                                    {
#line 208
                                    tmp___32 = strncmp((char const   *)p, "xheader",
                                                       (size_t )7);
                                    }
#line 208
                                    if (tmp___32 == 0) {
                                      {
#line 210
                                      tmp___6 = strlen("xheader=");
#line 210
                                      glb___4->xheader = p + tmp___6;
                                      }
                                    } else {
                                      {
#line 212
                                      tmp___31 = strncmp((char const   *)p, "version",
                                                         (size_t )7);
                                      }
#line 212
                                      if (tmp___31 == 0) {
                                        {
#line 214
                                        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                                                ALTERMIMEAPP_VERSION);
#line 215
                                        exit(0);
                                        }
                                      } else {
                                        {
#line 217
                                        tmp___30 = strncmp((char const   *)p, "debug",
                                                           (size_t )5);
                                        }
#line 217
                                        if (tmp___30 == 0) {
                                          {
#line 219
                                          AM_set_debug(1);
                                          }
                                        } else {
                                          {
#line 221
                                          tmp___29 = strncmp((char const   *)p, "no-qmail-bounce",
                                                             (size_t )15);
                                          }
#line 221
                                          if (tmp___29 == 0) {
                                            {
#line 222
                                            AM_set_header_long_search(0);
                                            }
                                          } else {
                                            {
#line 224
                                            tmp___28 = strncmp((char const   *)p,
                                                               "verbose", (size_t )7);
                                            }
#line 224
                                            if (tmp___28 == 0) {
                                              {
#line 226
                                              AM_set_verbose(1);
                                              }
                                            } else {
                                              {
#line 228
                                              tmp___26 = strlen("alter-header");
#line 228
                                              tmp___27 = strncmp((char const   *)p,
                                                                 "alter-header", tmp___26);
                                              }
#line 228
                                              if (tmp___27 == 0) {
                                                {
#line 229
                                                tmp___7 = strlen("alter-header=");
#line 229
                                                glb___4->alter_header = p + tmp___7;
                                                }
#line 230
                                                if ((int )*(glb___4->alter_header) == 34) {
#line 230
                                                  (glb___4->alter_header) ++;
                                                }
                                              } else {
                                                {
#line 231
                                                tmp___24 = strlen("alter-with");
#line 231
                                                tmp___25 = strncmp((char const   *)p,
                                                                   "alter-with", tmp___24);
                                                }
#line 231
                                                if (tmp___25 == 0) {
                                                  {
#line 232
                                                  tmp___8 = strlen("alter-with=");
#line 232
                                                  glb___4->alter_with = p + tmp___8;
                                                  }
#line 233
                                                  if ((int )*(glb___4->alter_with) == 34) {
#line 233
                                                    (glb___4->alter_with) ++;
                                                  }
                                                } else {
                                                  {
#line 234
                                                  tmp___22 = strlen("alter-mode");
#line 234
                                                  tmp___23 = strncmp((char const   *)p,
                                                                     "alter-mode",
                                                                     tmp___22);
                                                  }
#line 234
                                                  if (tmp___23 == 0) {
                                                    {
#line 235
                                                    tmp___9 = strlen("alter-mode=");
#line 235
                                                    q = p + tmp___9;
                                                    }
#line 236
                                                    if ((int )*q == 34) {
#line 236
                                                      q ++;
                                                    }
                                                    {
#line 238
                                                    glb___4->alter_mode = 0;
#line 239
                                                    tmp___14 = strlen("prefix");
#line 239
                                                    tmp___15 = strncmp((char const   *)q,
                                                                       "prefix", tmp___14);
                                                    }
#line 239
                                                    if (tmp___15 == 0) {
#line 239
                                                      glb___4->alter_mode = 1;
                                                    } else {
                                                      {
#line 240
                                                      tmp___12 = strlen("suffix");
#line 240
                                                      tmp___13 = strncmp((char const   *)q,
                                                                         "suffix",
                                                                         tmp___12);
                                                      }
#line 240
                                                      if (tmp___13 == 0) {
#line 240
                                                        glb___4->alter_mode = 2;
                                                      } else {
                                                        {
#line 241
                                                        tmp___10 = strlen("replace");
#line 241
                                                        tmp___11 = strncmp((char const   *)q,
                                                                           "replace",
                                                                           tmp___10);
                                                        }
#line 241
                                                        if (tmp___11 == 0) {
#line 241
                                                          glb___4->alter_mode = 4;
                                                        } else {
                                                          {
#line 242
                                                          LOGGER_log((char *)"ERROR: Unknown header alter mode \'%s\'. Please use either of prefix, suffix or replace.",
                                                                     q);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  } else {
                                                    {
#line 244
                                                    tmp___20 = strlen("log-stdout");
#line 244
                                                    tmp___21 = strncmp((char const   *)p,
                                                                       "log-stdout",
                                                                       tmp___20);
                                                    }
#line 244
                                                    if (tmp___21 == 0) {
                                                      {
#line 244
                                                      LOGGER_set_output_mode(2);
                                                      }
                                                    } else {
                                                      {
#line 245
                                                      tmp___18 = strlen("log-stderr");
#line 245
                                                      tmp___19 = strncmp((char const   *)p,
                                                                         "log-stderr",
                                                                         tmp___18);
                                                      }
#line 245
                                                      if (tmp___19 == 0) {
                                                        {
#line 245
                                                        LOGGER_set_output_mode(1);
                                                        }
                                                      } else {
                                                        {
#line 246
                                                        tmp___16 = strlen("log-syslog");
#line 246
                                                        tmp___17 = strncmp((char const   *)p,
                                                                           "log-syslog",
                                                                           tmp___16);
                                                        }
#line 246
                                                        if (tmp___17 == 0) {
                                                          {
#line 246
                                                          LOGGER_set_output_mode(4);
#line 246
                                                          LOGGER_set_syslog_mode((2 << 3) | 6);
                                                          }
                                                        } else {
                                                          {
#line 249
                                                          LOGGER_log((char *)"Error, unknown parameter \"%s\"\n",
                                                                     p);
#line 250
                                                          LOGGER_log((char *)"%s",
                                                                     ALTERMIMEAPP_USAGE);
#line 251
                                                          exit(1);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return (0);
}
}
#line 274 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
int ALTERMIMEAPP_init(struct ALTERMIMEAPP_globals *glb___4 ) 
{ 


  {
#line 276
  glb___4->input_file = (char *)((void *)0);
#line 277
  glb___4->disclaimer_file = (char *)((void *)0);
#line 278
  glb___4->disclaimer_html_file = (char *)((void *)0);
#line 279
  glb___4->disclaimer_b64_file = (char *)((void *)0);
#line 287
  glb___4->remove_filename = (char *)((void *)0);
#line 288
  glb___4->replace = (char *)((void *)0);
#line 289
  glb___4->with = (char *)((void *)0);
#line 290
  glb___4->xheader = (char *)((void *)0);
#line 291
  glb___4->verbose = 0;
#line 293
  glb___4->alter_header = (char *)((void *)0);
#line 294
  glb___4->alter_with = (char *)((void *)0);
#line 295
  glb___4->alter_mode = 0;
#line 296
  return (0);
}
}
#line 317 "/home/june/collector/temp/altermime-0.3.10/altermime.c"
int main(int argc , char **argv ) 
{ 
  struct ALTERMIMEAPP_globals glb___4 ;
  int tmp ;

  {
  {
#line 321
  LOGGER_set_output_mode(2);
#line 323
  ALTERMIMEAPP_init(& glb___4);
#line 325
  ALTERMIMEAPP_parse_args(& glb___4, argc, argv);
  }
#line 327
  if (! glb___4.input_file) {
    {
#line 328
    LOGGER_log((char *)"Error: No input file specified\n");
#line 329
    LOGGER_log(ALTERMIMEAPP_USAGE);
#line 330
    exit(1);
    }
  }
#line 333
  if (! glb___4.replace) {
#line 333
    if (glb___4.with) {
      {
#line 335
      LOGGER_log((char *)"Error: Both --replace= and --with= must be set\n");
#line 336
      exit(1);
      }
    } else {
#line 333
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 333
  if (glb___4.replace) {
#line 333
    if (! glb___4.with) {
      {
#line 335
      LOGGER_log((char *)"Error: Both --replace= and --with= must be set\n");
#line 336
      exit(1);
      }
    }
  }
#line 339
  if (glb___4.input_file) {
#line 339
    if (! glb___4.alter_mode) {
#line 339
      if (! glb___4.replace) {
#line 339
        if (! glb___4.disclaimer_file) {
#line 339
          if (! glb___4.remove_filename) {
#line 339
            if (! glb___4.xheader) {
              {
#line 340
              LOGGER_log((char *)"Error: Must specify an action for the input file.\n");
#line 341
              LOGGER_log(ALTERMIMEAPP_USAGE);
#line 342
              exit(1);
              }
            }
          }
        }
      }
    }
  }
  {
#line 345
  tmp = strcmp((char const   *)glb___4.input_file, "-");
  }
#line 345
  if (tmp == 0) {
#line 345
    if (glb___4.replace) {
      {
#line 346
      LOGGER_log((char *)"Error: reading/writing from stdin/stdout not implemented for --xheader,--disclaimer, or --replace.\n");
#line 347
      LOGGER_log(ALTERMIMEAPP_USAGE);
#line 348
      exit(1);
      }
    } else
#line 345
    if (glb___4.xheader) {
      {
#line 346
      LOGGER_log((char *)"Error: reading/writing from stdin/stdout not implemented for --xheader,--disclaimer, or --replace.\n");
#line 347
      LOGGER_log(ALTERMIMEAPP_USAGE);
#line 348
      exit(1);
      }
    }
  }
#line 351
  if (glb___4.alter_mode != 0) {
#line 351
    if ((unsigned long )glb___4.alter_with != (unsigned long )((void *)0)) {
#line 351
      if ((unsigned long )glb___4.alter_header != (unsigned long )((void *)0)) {
        {
#line 353
        AM_alter_header(glb___4.input_file, glb___4.alter_header, glb___4.alter_with,
                        glb___4.alter_mode);
        }
      }
    }
  }
#line 356
  if (glb___4.replace) {
#line 356
    if (glb___4.with) {
      {
#line 356
      AM_attachment_replace(glb___4.input_file, glb___4.replace, glb___4.with);
      }
    }
  }
#line 357
  if (glb___4.disclaimer_file) {
    {
#line 357
    AM_add_disclaimer(glb___4.input_file);
    }
  }
#line 362
  if (glb___4.remove_filename) {
    {
#line 362
    AM_nullify_attachment(glb___4.input_file, glb___4.remove_filename);
    }
  }
#line 363
  if (glb___4.xheader) {
    {
#line 363
    AM_insert_Xheader(glb___4.input_file, glb___4.xheader);
    }
  }
  {
#line 365
  AM_done();
  }
#line 367
  return (0);
}
}
#line 3 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.h"
int BS_set_verbose(int level ) ;
#line 4
int BS_set_debug(int level ) ;
#line 5
int BS_set_boundary_detect_limit(int limit ) ;
#line 10
char *BS_pop(void) ;
#line 11
char *BS_top(void) ;
#line 13
int BS_count(void) ;
#line 42 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
static struct BS_globals glb___2  ;
#line 63 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_init(void) 
{ 


  {
#line 65
  glb___2.debug = 0;
#line 66
  glb___2.verbose = 0;
#line 67
  glb___2.syslogging = 1;
#line 68
  glb___2.errlogging = 0;
#line 69
  glb___2.count = 0;
#line 70
  glb___2.detect_limit = 4;
#line 71
  glb___2.hold_limit = 0;
#line 72
  glb___2.boundarystack = (struct BS_node *)((void *)0);
#line 73
  glb___2.smallest_length = -1;
#line 74
  glb___2.have_empty_boundary = 0;
#line 76
  return (0);
}
}
#line 94 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_set_hold_limit(int limit ) 
{ 


  {
#line 96
  glb___2.hold_limit = limit;
#line 98
  return (0);
}
}
#line 116 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_set_verbose(int level ) 
{ 


  {
#line 118
  glb___2.verbose = level;
#line 120
  return (glb___2.verbose);
}
}
#line 138 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_set_debug(int level ) 
{ 


  {
#line 140
  glb___2.debug = level;
#line 142
  return (glb___2.debug);
}
}
#line 160 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_set_boundary_detect_limit(int limit ) 
{ 


  {
#line 162
  if (limit > 0) {
#line 162
    if (limit < 1024) {
#line 164
      glb___2.detect_limit = limit;
    }
  }
#line 167
  return (glb___2.detect_limit);
}
}
#line 186 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_clear(void) 
{ 
  struct BS_node *next ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! glb___2.boundarystack) {
#line 190
      goto while_break;
    }
#line 192
    if (glb___2.debug) {
      {
#line 192
      LOGGER_log((char *)"%s:%d:BS_clear:DEBUG: Popping off %p", "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                 192, glb___2.boundarystack);
      }
    }
    {
#line 193
    next = (glb___2.boundarystack)->next;
#line 194
    free((void *)(glb___2.boundarystack)->boundary);
#line 195
    free((void *)glb___2.boundarystack);
#line 196
    glb___2.boundarystack = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  glb___2.boundarystack = (struct BS_node *)((void *)0);
#line 200
  glb___2.count = 0;
#line 201
  glb___2.smallest_length = -1;
#line 203
  return (0);
}
}
#line 223 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_non_hyphen_length(char *boundary ) 
{ 
  int count ;
  char *p ;
  unsigned short const   **tmp ;

  {
#line 225
  count = 0;
#line 226
  p = boundary;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! *p) {
#line 228
      goto while_break;
    }
    {
#line 228
    tmp = __ctype_b_loc();
    }
#line 228
    if ((int const   )*(*tmp + (int )*p) & 8) {
#line 228
      count ++;
    }
#line 228
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  return (count);
}
}
#line 248 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_push(char *boundary ) 
{ 
  struct BS_node *node ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 253
  if (glb___2.hold_limit > 0) {
#line 253
    if (glb___2.count >= glb___2.hold_limit) {
#line 255
      if (glb___2.debug) {
        {
#line 255
        LOGGER_log((char *)"%s:%d:BS_push:DEBUG: Number of boundaries to hold is at limit (limit=%d)",
                   "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                   255, glb___2.hold_limit);
        }
      }
#line 256
      return (0);
    }
  }
  {
#line 259
  tmp = malloc(sizeof(struct BS_node ));
#line 259
  node = (struct BS_node *)tmp;
  }
#line 261
  if (glb___2.debug) {
    {
#line 261
    LOGGER_log((char *)"%s:%d:BS_push:DEBUG: head = %p, nn = %p boundary = \'%s\'",
               "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c", 261,
               glb___2.boundarystack, node, boundary);
    }
  }
#line 263
  if (node) {
    {
#line 265
    node->next = glb___2.boundarystack;
#line 266
    glb___2.boundarystack = node;
#line 267
    (glb___2.boundarystack)->boundary = strdup((char const   *)boundary);
#line 268
    tmp___0 = strlen((char const   *)(glb___2.boundarystack)->boundary);
#line 268
    (glb___2.boundarystack)->boundary_length = (int )tmp___0;
    }
#line 269
    if ((glb___2.boundarystack)->boundary_length == 0) {
#line 269
      glb___2.have_empty_boundary = 1;
    }
    {
#line 270
    (glb___2.boundarystack)->boundary_nhl = BS_non_hyphen_length(boundary);
#line 271
    (glb___2.count) ++;
    }
#line 274
    if (glb___2.smallest_length == -1) {
#line 274
      glb___2.smallest_length = (glb___2.boundarystack)->boundary_length;
    } else
#line 275
    if ((glb___2.boundarystack)->boundary_length < glb___2.smallest_length) {
#line 275
      glb___2.smallest_length = (glb___2.boundarystack)->boundary_length;
    }
#line 277
    if (glb___2.debug) {
      {
#line 277
      LOGGER_log((char *)"%s:%d:DEBUGX: smallest = %d, NHL = %d,  boundary = \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c", 277,
                 glb___2.smallest_length, node->boundary_nhl, boundary);
      }
    }
  } else {
    {
#line 281
    tmp___1 = __errno_location();
#line 281
    tmp___2 = strerror(*tmp___1);
#line 281
    LOGGER_log((char *)"%s:%d:BS_push:ERROR: Cannot allocate memory for boundary stack PUSH, %s",
               "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c", 281,
               tmp___2);
    }
  }
#line 284
  return (0);
}
}
#line 303 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
char *BS_pop(void) 
{ 
  struct BS_node *node ;

  {
#line 306
  node = glb___2.boundarystack;
#line 308
  if (glb___2.boundarystack) {
    {
#line 310
    glb___2.boundarystack = (glb___2.boundarystack)->next;
#line 311
    PLD_strncpy(glb___2.boundarystacksafe, (char const   *)node->boundary, (size_t )1024);
#line 312
    free((void *)node->boundary);
#line 313
    free((void *)node);
#line 314
    (glb___2.count) --;
    }
  }
#line 317
  return (glb___2.boundarystacksafe);
}
}
#line 335 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
char *BS_top(void) 
{ 


  {
#line 338
  if (glb___2.boundarystack) {
#line 340
    return ((glb___2.boundarystack)->boundary);
  } else {
#line 342
    return ((char *)((void *)0));
  }
}
}
#line 360 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_count(void) 
{ 


  {
#line 362
  return (glb___2.count);
}
}
#line 381 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_is_long_enough(int blen ) 
{ 


  {
#line 383
  if (glb___2.smallest_length == -1) {
#line 383
    return (0);
  }
#line 384
  if (blen >= glb___2.smallest_length) {
#line 384
    return (1);
  }
#line 386
  return (0);
}
}
#line 405 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_boundary_detect(char *haystack , char *needle , int needle_length ) 
{ 
  int result ;
  int current_start ;
  char *haystack_start ;
  int tmp ;
  int tmp___0 ;

  {
#line 407
  result = 1;
#line 408
  current_start = glb___2.detect_limit;
#line 411
  if (glb___2.have_empty_boundary == 1) {
#line 411
    if (needle_length < 1) {
      {
#line 413
      result = strncmp((char const   *)haystack, "--", (size_t )2);
      }
#line 414
      if (glb___2.debug) {
        {
#line 414
        LOGGER_log((char *)"%s:%d:BS_boundary_detect:DEBUG: empty-boundary test, result = %d",
                   "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                   414, result);
        }
      }
#line 415
      return (result);
    }
  }
#line 419
  if (needle_length < 1) {
#line 419
    if (glb___2.have_empty_boundary == 0) {
#line 419
      return (1);
    }
  }
#line 422
  if (glb___2.debug) {
    {
#line 422
    LOGGER_log((char *)"%s:%d:BS_boundary_detect: needle=\'%s\', length=%d, haystack=\'%s\', shift-window=%d",
               "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c", 423,
               needle, needle_length, haystack, current_start);
    }
  }
#line 430
  haystack_start = haystack;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    tmp___0 = current_start;
#line 431
    current_start --;
#line 431
    if (tmp___0 > 0) {
#line 431
      if (! ((int )*haystack_start != 0)) {
#line 431
        goto while_break;
      }
    } else {
#line 431
      goto while_break;
    }
#line 433
    if (glb___2.debug) {
      {
#line 433
      LOGGER_log((char *)"%s:%d:BS_boundary_detect:DEBUG: CMP \'%s\' to \'%s\'", "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                 433, needle, haystack_start);
      }
    }
    {
#line 434
    tmp = strncmp((char const   *)needle, (char const   *)haystack_start, (size_t )needle_length);
    }
#line 434
    if (tmp == 0) {
#line 436
      if (glb___2.debug) {
        {
#line 436
        LOGGER_log((char *)"%s:%d:BS_boundary_detect:DEBUG: Hit on compare", "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                   436);
        }
      }
#line 437
      result = 0;
#line 438
      goto while_break;
    }
#line 440
    haystack_start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return (result);
}
}
#line 465 "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c"
int BS_cmp(char *boundary , int len ) 
{ 
  char testspace[128] ;
  int testspacelen ;
  int spin ;
  int nhl ;
  struct BS_node *node ;
  struct BS_node *nodetmp ;
  struct BS_node *nodedel ;
  int tmp ;
  int tmp___0 ;

  {
#line 469
  testspacelen = 127;
#line 470
  spin = 1;
#line 471
  nhl = 0;
#line 472
  node = glb___2.boundarystack;
#line 473
  nodetmp = (struct BS_node *)((void *)0);
#line 473
  nodedel = (struct BS_node *)((void *)0);
#line 475
  if (! boundary) {
#line 475
    return (0);
  } else
#line 475
  if (glb___2.count == 0) {
#line 475
    return (0);
  }
  {
#line 477
  tmp = BS_is_long_enough(len);
  }
#line 477
  if (tmp == 0) {
#line 477
    return (0);
  }
  {
#line 479
  nhl = BS_non_hyphen_length(boundary);
  }
#line 481
  if (glb___2.debug) {
    {
#line 481
    LOGGER_log((char *)"%s:%d:BS_cmp:DEBUG: possible-boundary=\'%s\', len=%d, smallest=%d, count=%d, NHL=%d",
               "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c", 482,
               boundary, len, glb___2.smallest_length, glb___2.count, nhl);
    }
  }
#line 492
  if (len > testspacelen) {
#line 492
    len = testspacelen;
  }
  {
#line 495
  snprintf((char */* __restrict  */)(testspace), (size_t )testspacelen, (char const   */* __restrict  */)"%s",
           boundary);
  }
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (node) {
#line 503
      if (! spin) {
#line 503
        goto while_break;
      }
    } else {
#line 503
      goto while_break;
    }
#line 506
    if (node->boundary_nhl == nhl) {
#line 508
      if (glb___2.debug) {
        {
#line 508
        LOGGER_log((char *)"%s:%d:BS_cmp:DEBUG: Comparing \'%s\' to \'%s\'", "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                   508, boundary, node->boundary);
        }
      }
#line 510
      if ((unsigned long )node->boundary != (unsigned long )((void *)0)) {
#line 510
        if (node->boundary_length >= 0) {
          {
#line 512
          tmp___0 = BS_boundary_detect(testspace, node->boundary, node->boundary_length);
          }
#line 512
          if (tmp___0 == 0) {
#line 514
            if (glb___2.debug) {
              {
#line 514
              LOGGER_log((char *)"%s:%d:BS_cmp:DEBUG: Boundary HIT", "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                         514);
              }
            }
#line 515
            spin = 0;
          }
        }
      }
    }
#line 520
    if (spin != 0) {
#line 520
      node = node->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  if (spin == 0) {
#line 532
    if (glb___2.debug) {
      {
#line 532
      LOGGER_log((char *)"%s:%d:BS_cmp:DEBUG: Boundary hit on \'%s\' == \'%s\'", "/home/june/collector/temp/altermime-0.3.10/boundary-stack.c",
                 532, boundary, node->boundary);
      }
    }
#line 541
    if ((unsigned long )node != (unsigned long )glb___2.boundarystack) {
#line 543
      nodetmp = glb___2.boundarystack;
      {
#line 544
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 544
        if (nodetmp) {
#line 544
          if (! ((unsigned long )nodetmp != (unsigned long )node)) {
#line 544
            goto while_break___0;
          }
        } else {
#line 544
          goto while_break___0;
        }
        {
#line 551
        nodedel = nodetmp;
#line 552
        nodetmp = nodetmp->next;
#line 553
        free((void *)nodedel->boundary);
#line 554
        free((void *)nodedel);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 556
      glb___2.boundarystack = node;
    }
#line 558
    return (1);
  } else {
#line 563
    return (0);
  }
#line 566
  return (0);
}
}
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 54 "/home/june/collector/temp/altermime-0.3.10/ffget.h"
char SDL_MODE_DELIMITS[3] ;
#line 55
char NORM_MODE_DELIMITS[2] ;
#line 56
char *DELIMITERS ;
#line 67
int FFGET_ungetc(FFGET_FILE *f , char c ) ;
#line 68
int FFGET_presetbuffer(FFGET_FILE *f , char *buffer , int size ) ;
#line 70
int FFGET_raw(FFGET_FILE *f , unsigned char *buffer , int max ) ;
#line 72
int FFGET_getnewblock(FFGET_FILE *f ) ;
#line 74
int FFGET_set_allow_nul(int level ) ;
#line 28 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int ffget_linesize  =    0;
#line 29 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_doubleCR  =    0;
#line 30 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_SDL_MODE  =    0;
#line 32 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_SDL_WATCH  =    0;
#line 33 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_ALLOW_NUL  =    0;
#line 35 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_debug  =    0;
#line 37 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
char SDL_MODE_DELIMITS[3]  = {      (char )'\n',      (char )'\r',      (char )'\000'};
#line 38 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
char NORM_MODE_DELIMITS[2]  = {      (char )'\n',      (char )'\000'};
#line 39 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
char *DELIMITERS  =    SDL_MODE_DELIMITS;
#line 49 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_set_watch_SDL(int level ) 
{ 


  {
#line 51
  FFGET_SDL_WATCH = level;
#line 54
  return (FFGET_SDL_WATCH);
}
}
#line 76 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_set_allow_nul(int level ) 
{ 


  {
#line 78
  FFGET_ALLOW_NUL = level;
#line 80
  return (FFGET_ALLOW_NUL);
}
}
#line 90 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_set_debug(int level ) 
{ 


  {
#line 92
  FFGET_debug = level;
#line 94
  return (FFGET_debug);
}
}
#line 106 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_getnewblock(FFGET_FILE *f ) 
{ 
  int i ;
  int bs ;
  char *p ;
  long block_pos ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 109
  bs = 0;
#line 116
  if (f->FILEEND > 0) {
#line 118
    f->endpoint = f->buffer;
#line 119
    f->startpoint = f->buffer + 1;
#line 120
    f->FFEOF = 1;
#line 121
    return (0);
  } else {
    {
#line 126
    block_pos = ftell(f->f);
#line 128
    tmp = fread((void */* __restrict  */)(f->buffer), (size_t )1, (size_t )8191, (FILE */* __restrict  */)f->f);
#line 128
    bs = (int )tmp;
    }
#line 130
    if (bs < 8191) {
      {
#line 132
      tmp___2 = feof(f->f);
      }
#line 132
      if (tmp___2) {
#line 134
        f->FILEEND = 1;
      } else {
        {
#line 138
        tmp___0 = __errno_location();
#line 138
        tmp___1 = strerror(*tmp___0);
#line 138
        LOGGER_log((char *)"%s:%d:FFGET_getnewblock:ERROR: File read failed with error:%s",
                   "/home/june/collector/temp/altermime-0.3.10/ffget.c", 138, tmp___1);
        }
#line 139
        return (0);
      }
    }
#line 143
    if (bs > 0) {
#line 154
      f->buffer[bs] = (char )'\000';
#line 155
      f->last_block_read_from = (size_t )block_pos;
#line 156
      f->startpoint = f->buffer;
#line 157
      f->endpoint = (f->startpoint + bs) - 1;
#line 158
      f->bytes += (unsigned long )bs;
#line 164
      if (FFGET_ALLOW_NUL == 0) {
#line 166
        p = f->startpoint;
#line 167
        i = 0;
        {
#line 167
        while (1) {
          while_continue: /* CIL Label */ ;
#line 167
          if (! (i < bs)) {
#line 167
            goto while_break;
          }
#line 168
          if ((int )*p == 0) {
#line 168
            *p = (char )' ';
          }
#line 169
          p ++;
#line 167
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 171
        *p = (char )'\000';
      }
#line 174
      if (FFGET_debug >= 10) {
        {
#line 174
        LOGGER_log((char *)"%s:%d:FFGET_getnewblock:DEBUG-PEDANTIC: Size: %ld bytes\n",
                   "/home/june/collector/temp/altermime-0.3.10/ffget.c", 174, f->bytes);
        }
      }
    }
  }
#line 180
  return (bs);
}
}
#line 197 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_presetbuffer(FFGET_FILE *f , char *buffer , int size ) 
{ 


  {
#line 199
  if (size > 8192) {
#line 199
    size = 8192;
  }
  {
#line 201
  memcpy((void */* __restrict  */)(f->buffer), (void const   */* __restrict  */)buffer,
         (size_t )size);
#line 202
  f->startpoint = buffer;
#line 203
  f->endpoint = buffer + size;
  }
#line 204
  return (0);
}
}
#line 216 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_setstream(FFGET_FILE *f , FILE *fi ) 
{ 


  {
  {
#line 221
  f->f = fi;
#line 222
  f->bytes = 0UL;
#line 223
  f->linecount = 0UL;
#line 224
  f->endpoint = f->buffer;
#line 225
  f->startpoint = f->endpoint + 1;
#line 226
  f->buffer_end = (f->buffer + 8192) + 1;
#line 227
  f->trueblank = 0;
#line 228
  f->ungetcset = 0;
#line 229
  f->lastchar = (char )'\000';
#line 230
  memset((void *)(f->buffer), '\000', (size_t )8193);
#line 231
  f->c = (char )'\000';
#line 232
  f->FFEOF = 0;
#line 233
  f->FILEEND = 0;
#line 234
  f->last_block_read_from = (size_t )-1;
#line 235
  f->linebreak = 0;
#line 236
  f->lastbreak[0] = (char )'\000';
  }
#line 237
  return (0);
}
}
#line 248 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_closestream(FFGET_FILE *f ) 
{ 
  char *tmp ;

  {
#line 250
  tmp = (char *)((void *)0);
#line 250
  f->endpoint = tmp;
#line 250
  f->startpoint = tmp;
#line 251
  f->f = (FILE *)((void *)0);
#line 252
  return (0);
}
}
#line 262 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_feof(FFGET_FILE *f ) 
{ 


  {
#line 264
  return (f->FFEOF);
}
}
#line 289 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_seek(FFGET_FILE *f , long offset , int whence ) 
{ 
  int result ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 291
  result = 0;
#line 294
  result = fseek(f->f, offset, whence);
  }
#line 295
  if (result == -1) {
    {
#line 296
    tmp = __errno_location();
#line 296
    tmp___0 = strerror(*tmp);
#line 296
    LOGGER_log((char *)"%s:%d:FFGET_seek:ERROR: While attempting to seek to offset %ld from %d - [%s]",
               "/home/june/collector/temp/altermime-0.3.10/ffget.c", 296, offset,
               whence, tmp___0);
    }
#line 297
    return (-1);
  }
  {
#line 301
  result = FFGET_getnewblock(f);
  }
#line 303
  return (result);
}
}
#line 326 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
long FFGET_ftell(FFGET_FILE *f ) 
{ 
  long pos ;

  {
#line 330
  pos = (long )(f->last_block_read_from + (size_t )(f->startpoint - f->buffer));
#line 332
  return (pos);
}
}
#line 347 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_ungetc(FFGET_FILE *f , char c ) 
{ 


  {
#line 349
  f->c = c;
#line 350
  f->ungetcset = 1;
#line 351
  return (0);
}
}
#line 367 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
char FFGET_fgetc(FFGET_FILE *f ) 
{ 
  int c ;

  {
#line 372
  if (f->ungetcset) {
#line 374
    f->ungetcset = 0;
#line 375
    return (f->c);
  }
#line 378
  if (! f->startpoint) {
    {
#line 380
    FFGET_getnewblock(f);
    }
  } else
#line 378
  if ((unsigned long )f->startpoint > (unsigned long )f->endpoint) {
    {
#line 380
    FFGET_getnewblock(f);
    }
  }
#line 383
  if (f->FFEOF == 0) {
#line 385
    c = (int )*(f->startpoint);
#line 386
    (f->startpoint) ++;
  } else {
#line 390
    c = -1;
  }
#line 393
  return ((char )c);
}
}
#line 412 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
char *FFGET_fgets(char *linein , int maxsize , FFGET_FILE *f ) 
{ 
  char *line ;
  char *crlfpos ;
  int charstoCRLF ;
  int chardiff ;
  int result ;
  int max_size ;
  int endpoint_tainted ;
  int extra_char_kept ;
  int c ;
  int nextchar ;
  size_t tmp ;

  {
#line 414
  line = linein;
#line 415
  crlfpos = (char *)((void *)0);
#line 416
  charstoCRLF = 0;
#line 417
  chardiff = 0;
#line 418
  result = 0;
#line 419
  max_size = maxsize;
#line 420
  endpoint_tainted = 0;
#line 421
  extra_char_kept = 0;
#line 424
  f->trueblank = 0;
#line 425
  f->linebreak = 0;
#line 426
  f->lastbreak[0] = (char )'\000';
#line 428
  if (f->FFEOF != 0) {
#line 430
    return ((char *)((void *)0));
  }
#line 433
  if (FFGET_SDL_WATCH > 0) {
#line 435
    DELIMITERS = SDL_MODE_DELIMITS;
  } else
#line 433
  if (FFGET_SDL_MODE != 0) {
#line 435
    DELIMITERS = SDL_MODE_DELIMITS;
  } else {
#line 437
    DELIMITERS = NORM_MODE_DELIMITS;
  }
#line 442
  maxsize -= 2;
#line 442
  max_size = maxsize;
#line 451
  if ((unsigned long )f->startpoint > (unsigned long )f->endpoint) {
    {
#line 453
    result = FFGET_getnewblock(f);
    }
#line 454
    if (result == 0) {
#line 456
      *linein = (char )'\000';
#line 457
      return ((char *)((void *)0));
    }
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (max_size > 0) {
#line 465
      if (! (f->FFEOF == 0)) {
#line 465
        goto while_break;
      }
    } else {
#line 465
      goto while_break;
    }
    {
#line 468
    crlfpos = strpbrk((char const   *)f->startpoint, (char const   *)DELIMITERS);
    }
#line 469
    if (crlfpos) {
#line 471
      extra_char_kept = 0;
#line 472
      endpoint_tainted = 0;
#line 473
      nextchar = -1;
#line 495
      if (0 == f->FILEEND) {
#line 495
        if (0 == f->FFEOF) {
#line 495
          if ((unsigned long )(crlfpos + 1) > (unsigned long )f->endpoint) {
            {
#line 501
            c = fgetc(f->f);
#line 501
            nextchar = c;
            }
#line 502
            if (c == -1) {
#line 505
              f->FILEEND = 1;
            } else {
#line 509
              if (c == 0) {
#line 509
                c = ' ';
              }
#line 513
              if (c > 0) {
#line 513
                if (c <= 255) {
#line 515
                  if (FFGET_debug >= 1) {
                    {
#line 515
                    LOGGER_log((char *)"%s:%d:FFGET_fgets:DEBUG: Tainting endpoint +1 (%p -> %p,  hard buffer end = %p, file read bytes = %ld)",
                               "/home/june/collector/temp/altermime-0.3.10/ffget.c",
                               515, f->endpoint, f->endpoint + 1, f->buffer_end, f->bytes);
                    }
                  }
#line 516
                  (f->endpoint) ++;
#line 517
                  *(f->endpoint) = (char )c;
#line 518
                  *(f->endpoint + 1) = (char )'\000';
#line 519
                  endpoint_tainted = 1;
                }
              }
            }
          }
        }
      }
#line 529
      if ((unsigned long )(crlfpos + 1) <= (unsigned long )f->endpoint) {
#line 534
        if ((int )*crlfpos == 10) {
          {
#line 536
          f->linebreak = 1;
#line 537
          snprintf((char */* __restrict  */)(f->lastbreak), sizeof(f->lastbreak),
                   (char const   */* __restrict  */)"\n");
          }
#line 539
          if ((int )*(crlfpos + 1) == 13) {
            {
#line 541
            f->linebreak |= 2;
#line 542
            snprintf((char */* __restrict  */)(f->lastbreak), sizeof(f->lastbreak),
                     (char const   */* __restrict  */)"\n\r");
#line 543
            crlfpos ++;
#line 544
            extra_char_kept = 1;
            }
          }
        }
#line 553
        if ((int )*crlfpos == 13) {
          {
#line 555
          f->linebreak = 2;
#line 556
          snprintf((char */* __restrict  */)(f->lastbreak), sizeof(f->lastbreak),
                   (char const   */* __restrict  */)"\r");
          }
#line 558
          if ((int )*(crlfpos + 1) == 13) {
#line 565
            f->linebreak = 2;
#line 566
            FFGET_doubleCR = 1;
#line 567
            FFGET_SDL_MODE = 1;
#line 568
            crlfpos ++;
#line 569
            extra_char_kept = 1;
          } else
#line 571
          if ((int )*(crlfpos + 1) == 10) {
            {
#line 576
            snprintf((char */* __restrict  */)(f->lastbreak), sizeof(f->lastbreak),
                     (char const   */* __restrict  */)"\r\n");
#line 577
            f->linebreak |= 1;
            }
#line 578
            if (! FFGET_SDL_MODE) {
#line 579
              crlfpos ++;
#line 580
              extra_char_kept = 1;
            }
          } else {
#line 587
            FFGET_SDL_MODE = 1;
          }
        }
      }
#line 599
      charstoCRLF = (int )(crlfpos - f->startpoint);
#line 607
      if (charstoCRLF >= 0) {
#line 607
        if (charstoCRLF < max_size) {
#line 607
          max_size = charstoCRLF;
        }
      }
#line 609
      if (extra_char_kept == 0) {
#line 609
        if (nextchar != -1) {
          {
#line 609
          ungetc(nextchar, f->f);
          }
        }
      }
    }
#line 623
    if (f->endpoint - f->startpoint >= (long )max_size) {
#line 625
      if (max_size < 0) {
        {
#line 625
        LOGGER_log((char *)"%s:%d:FFGET_fgets:ERROR: Max size < 0\n", "/home/june/collector/temp/altermime-0.3.10/ffget.c",
                   625);
        }
      }
      {
#line 626
      memcpy((void */* __restrict  */)line, (void const   */* __restrict  */)f->startpoint,
             (size_t )(max_size + 1));
#line 627
      f->startpoint += max_size + 1;
#line 628
      *((line + max_size) + 1) = (char )'\000';
#line 629
      max_size = 0;
      }
    } else {
#line 637
      chardiff = (int )(f->endpoint - f->startpoint);
#line 641
      if (chardiff >= 0) {
        {
#line 643
        memcpy((void */* __restrict  */)line, (void const   */* __restrict  */)f->startpoint,
               (size_t )(chardiff + 1));
#line 644
        *((line + chardiff) + 1) = (char )'\000';
#line 645
        line += chardiff + 1;
#line 646
        max_size -= chardiff + 1;
#line 647
        f->startpoint = f->endpoint + 1;
        }
#line 648
        if (max_size < 0) {
#line 648
          max_size = 0;
        }
      }
      {
#line 651
      FFGET_getnewblock(f);
#line 652
      endpoint_tainted = 0;
      }
    }
#line 656
    if (endpoint_tainted) {
      {
#line 657
      FFGET_getnewblock(f);
#line 658
      endpoint_tainted = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  line = linein;
#line 665
  f->trueblank = 0;
#line 667
  if ((int )f->lastchar == 10) {
#line 667
    goto _L;
  } else
#line 667
  if ((int )f->lastchar == 13) {
    _L: /* CIL Label */ 
#line 669
    if ((int )*(line + 0) == 10) {
#line 671
      f->trueblank = 1;
    } else
#line 669
    if ((int )*(line + 0) == 13) {
#line 671
      f->trueblank = 1;
    }
  }
  {
#line 675
  tmp = strlen((char const   *)line);
#line 675
  f->lastchar = *(line + (tmp - 1UL));
#line 677
  (f->linecount) ++;
  }
#line 681
  return (linein);
}
}
#line 699 "/home/june/collector/temp/altermime-0.3.10/ffget.c"
int FFGET_raw(FFGET_FILE *f , unsigned char *buffer , int max ) 
{ 
  unsigned char c ;
  int bytestogo ;
  int count ;

  {
#line 704
  bytestogo = 0;
#line 705
  count = 0;
#line 712
  if (! f->startpoint) {
    {
#line 714
    bytestogo = FFGET_getnewblock(f);
    }
  } else
#line 712
  if ((unsigned long )f->startpoint > (unsigned long )f->endpoint) {
    {
#line 714
    bytestogo = FFGET_getnewblock(f);
    }
  } else {
#line 718
    bytestogo = (int )((f->endpoint - f->startpoint) + 1L);
  }
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (count < max)) {
#line 725
      goto while_break;
    }
#line 728
    if (! bytestogo) {
      {
#line 730
      bytestogo = FFGET_getnewblock(f);
      }
    }
#line 733
    if (! f->FFEOF) {
#line 735
      c = (unsigned char )*(f->startpoint);
#line 736
      (f->startpoint) ++;
#line 737
      *buffer = c;
#line 739
      buffer ++;
#line 741
      count ++;
#line 743
      bytestogo --;
#line 753
      if ((int )c == 10) {
#line 753
        goto _L;
      } else
#line 753
      if ((int )c == 13) {
        _L: /* CIL Label */ 
#line 755
        if ((int )*(f->startpoint) != 10) {
#line 755
          if ((int )*(f->startpoint) != 13) {
#line 756
            goto while_break;
          }
        }
      }
    } else {
#line 759
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  *buffer = (unsigned char )'\000';
#line 764
  return (count);
}
}
#line 25 "/home/june/collector/temp/altermime-0.3.10/strstack.h"
int SS_set_verbose(struct SS_object *ss , int level ) ;
#line 26
int SS_set_debug(struct SS_object *ss , int level ) ;
#line 29
char *SS_pop(struct SS_object *ss ) ;
#line 30
char *SS_top(struct SS_object *ss ) ;
#line 33
int SS_dump(struct SS_object *ss ) ;
#line 35
int SS_done(struct SS_object *ss ) ;
#line 33 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_init(struct SS_object *ss ) 
{ 


  {
#line 35
  ss->debug = 0;
#line 36
  ss->verbose = 0;
#line 37
  ss->count = 0;
#line 38
  ss->stringstack = (struct SS_node *)((void *)0);
#line 40
  return (0);
}
}
#line 58 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_set_verbose(struct SS_object *ss , int level ) 
{ 


  {
#line 60
  ss->verbose = level;
#line 62
  return (ss->verbose);
}
}
#line 80 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_set_debug(struct SS_object *ss , int level ) 
{ 


  {
#line 82
  ss->debug = level;
#line 84
  return (ss->debug);
}
}
#line 102 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_done(struct SS_object *ss ) 
{ 
  struct SS_node *next ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if ((unsigned long )ss->stringstack != (unsigned long )((void *)0)) {
#line 106
      if (! (ss->count > 0)) {
#line 106
        goto while_break;
      }
    } else {
#line 106
      goto while_break;
    }
#line 108
    if (ss->debug) {
      {
#line 108
      LOGGER_log((char *)"%s:%d:SS_done: Popping off %s", "/home/june/collector/temp/altermime-0.3.10/strstack.c",
                 108, (ss->stringstack)->data);
      }
    }
    {
#line 109
    next = (ss->stringstack)->next;
#line 110
    free((void *)(ss->stringstack)->data);
#line 111
    free((void *)ss->stringstack);
#line 112
    ss->stringstack = next;
#line 113
    (ss->count) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  ss->stringstack = (struct SS_node *)((void *)0);
#line 117
  ss->count = 0;
#line 119
  return (0);
}
}
#line 139 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_dump(struct SS_object *ss ) 
{ 
  struct SS_node *n ;

  {
#line 141
  n = ss->stringstack;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 143
      goto while_break;
    }
    {
#line 145
    LOGGER_log((char *)"%s", n->data);
#line 146
    n = n->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (0);
}
}
#line 167 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_push(struct SS_object *ss , char *data , size_t data_length ) 
{ 
  struct SS_node *node ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 170
  tmp = malloc(sizeof(struct SS_node ));
#line 170
  node = (struct SS_node *)tmp;
  }
#line 173
  if (node) {
#line 175
    if (ss->debug) {
      {
#line 175
      LOGGER_log((char *)"%s:%d:SS_push: Pushing %s to %p, stack count = %d", "/home/june/collector/temp/altermime-0.3.10/strstack.c",
                 175, data, ss->stringstack, ss->count);
      }
    }
    {
#line 176
    node->next = ss->stringstack;
#line 177
    ss->stringstack = node;
#line 178
    (ss->stringstack)->data = strdup((char const   *)data);
#line 179
    (ss->stringstack)->data_length = data_length;
#line 180
    (ss->count) ++;
    }
  } else {
    {
#line 184
    tmp___0 = __errno_location();
#line 184
    tmp___1 = strerror(*tmp___0);
#line 184
    LOGGER_log((char *)"%s:%d:SS_push:ERROR: Cannot allocate memory for string stack PUSH, %s",
               "/home/june/collector/temp/altermime-0.3.10/strstack.c", 184, tmp___1);
    }
  }
#line 187
  return (0);
}
}
#line 206 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
char *SS_pop(struct SS_object *ss ) 
{ 
  struct SS_node *node ;

  {
#line 209
  node = ss->stringstack;
#line 211
  if (ss->stringstack) {
#line 211
    if (ss->count > 0) {
      {
#line 213
      ss->stringstack = (ss->stringstack)->next;
#line 214
      PLD_strncpy(ss->datastacksafe, (char const   *)node->data, (size_t )1024);
#line 215
      free((void *)node->data);
#line 216
      free((void *)node);
#line 217
      (ss->count) --;
      }
    } else {
#line 218
      return ((char *)((void *)0));
    }
  } else {
#line 218
    return ((char *)((void *)0));
  }
#line 220
  return (ss->datastacksafe);
}
}
#line 238 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
char *SS_top(struct SS_object *ss ) 
{ 


  {
#line 241
  if (ss->stringstack) {
#line 243
    return ((ss->stringstack)->data);
  } else {
#line 245
    return ((char *)((void *)0));
  }
}
}
#line 263 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
int SS_count(struct SS_object *ss ) 
{ 


  {
#line 265
  return (ss->count);
}
}
#line 284 "/home/june/collector/temp/altermime-0.3.10/strstack.c"
char *SS_cmp(struct SS_object *ss , char *find_me , size_t find_me_len ) 
{ 
  struct SS_node *n ;
  int hit ;
  int tmp ;

  {
#line 286
  n = ss->stringstack;
#line 287
  hit = 0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 289
      if (! (hit == 0)) {
#line 289
        goto while_break;
      }
    } else {
#line 289
      goto while_break;
    }
    {
#line 291
    tmp = strncmp((char const   *)find_me, (char const   *)n->data, find_me_len);
    }
#line 291
    if (tmp == 0) {
#line 291
      hit ++;
    }
#line 292
    if (hit == 0) {
#line 292
      n = n->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  if (hit == 0) {
#line 295
    return ((char *)((void *)0));
  } else {
#line 296
    return (n->data);
  }
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 30 "/home/june/collector/temp/altermime-0.3.10/pldstr.h"
char *PLD_strncat(char *dst , char const   *src , size_t len ) ;
#line 31
char *PLD_strncate(char *dst , char const   *src , size_t len , char *endpoint ) ;
#line 32
char *PLD_strtok(struct PLD_strtok *st , char *line , char *delimeters ) ;
#line 33
int PLD_strncasecmp(char *s1 , char *s2 , int n ) ;
#line 31 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strstr(char *haystack , char *needle , int insensitive ) 
{ 
  char *hs ;
  char *ne ;
  char *result ;

  {
#line 38
  if (insensitive > 0) {
    {
#line 40
    hs = strdup((char const   *)haystack);
#line 41
    PLD_strlower(hs);
#line 42
    ne = strdup((char const   *)needle);
#line 43
    PLD_strlower(ne);
    }
  } else {
#line 45
    hs = haystack;
#line 46
    ne = needle;
  }
  {
#line 49
  result = strstr((char const   *)hs, (char const   *)ne);
  }
#line 53
  if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 53
    if (insensitive > 0) {
#line 55
      result = haystack + (result - hs);
    }
  }
#line 61
  if (insensitive) {
    {
#line 62
    free((void *)hs);
#line 63
    free((void *)ne);
    }
  }
#line 66
  return (result);
}
}
#line 80 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strncpy(char *dst , char const   *src , size_t len ) 
{ 
  char *dp ;
  char *sp ;

  {
#line 89
  if (len == 0UL) {
#line 89
    return ((char *)((void *)0));
  }
#line 94
  if (dst) {
#line 96
    dp = dst;
#line 100
    if (src) {
#line 102
      sp = (char *)src;
      {
#line 103
      while (1) {
        while_continue: /* CIL Label */ ;
#line 103
        len --;
#line 103
        if (len) {
#line 103
          if (! *sp) {
#line 103
            goto while_break;
          }
        } else {
#line 103
          goto while_break;
        }
#line 103
        *dp = *sp;
#line 103
        dp ++;
#line 103
        sp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 106
    *dp = (char )'\000';
  }
#line 109
  return (dst);
}
}
#line 125 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strncat(char *dst , char const   *src , size_t len ) 
{ 
  char *dp ;
  char const   *sp ;
  size_t cc ;

  {
#line 127
  dp = dst;
#line 128
  sp = src;
#line 131
  if (len == 0UL) {
#line 131
    return (dst);
  }
#line 133
  len --;
#line 136
  cc = (size_t )0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (*dp) {
#line 137
      if (! (cc < len)) {
#line 137
        goto while_break;
      }
    } else {
#line 137
      goto while_break;
    }
#line 137
    dp ++;
#line 137
    cc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (cc >= len) {
#line 141
    return (dst);
  }
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (*sp) {
#line 145
      if (! (cc < len)) {
#line 145
        goto while_break___0;
      }
    } else {
#line 145
      goto while_break___0;
    }
#line 147
    cc ++;
#line 148
    *dp = (char )*sp;
#line 149
    dp ++;
#line 150
    sp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 155
  *dp = (char )'\000';
#line 157
  return (dst);
}
}
#line 174 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strncate(char *dst , char const   *src , size_t len , char *endpoint ) 
{ 
  char *dp ;
  char const   *sp ;
  size_t cc ;

  {
#line 176
  dp = dst;
#line 177
  sp = src;
#line 178
  cc = (size_t )0;
#line 180
  if (len == 0UL) {
#line 180
    return (dst);
  }
#line 182
  len --;
#line 187
  if (! endpoint) {
#line 187
    goto _L;
  } else
#line 187
  if ((unsigned long )endpoint == (unsigned long )dst) {
#line 187
    goto _L;
  } else
#line 187
  if ((endpoint - dst) + 1L > (long )((int )len)) {
    _L: /* CIL Label */ 
#line 190
    cc = (size_t )0;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if ((int )*dp != 0) {
#line 191
        if (! (cc < len)) {
#line 191
          goto while_break;
        }
      } else {
#line 191
        goto while_break;
      }
#line 191
      dp ++;
#line 191
      cc ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 194
    cc = (size_t )((endpoint - dst) + 1L);
#line 195
    dp = endpoint;
  }
#line 200
  if (cc >= len) {
#line 200
    return (dst);
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (*sp) {
#line 204
      if (! (cc < len)) {
#line 204
        goto while_break___0;
      }
    } else {
#line 204
      goto while_break___0;
    }
#line 206
    cc ++;
#line 207
    *dp = (char )*sp;
#line 208
    dp ++;
#line 209
    sp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  *dp = (char )'\000';
#line 216
  return (dst);
}
}
#line 232 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
int PLD_strncasecmp(char *s1 , char *s2 , int n ) 
{ 
  char *ds1 ;
  char *ds2 ;
  char c1 ;
  char c2 ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 234
  ds1 = s1;
#line 234
  ds2 = s2;
#line 236
  result = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (n > 0)) {
#line 238
      goto while_break;
    }
    {
#line 240
    tmp = tolower((int )*ds1);
#line 240
    c1 = (char )tmp;
#line 241
    tmp___0 = tolower((int )*ds2);
#line 241
    c2 = (char )tmp___0;
    }
#line 243
    if ((int )c1 == (int )c2) {
#line 245
      n --;
#line 246
      ds1 ++;
#line 247
      ds2 ++;
    } else {
#line 251
      result = (int )c2 - (int )c1;
#line 252
      n = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (result);
}
}
#line 272 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strtok(struct PLD_strtok *st , char *line , char *delimeters ) 
{ 
  char *stop ;
  char *dc ;
  char *result ;

  {
#line 276
  result = (char *)((void *)0);
#line 278
  if (line) {
#line 280
    st->start = line;
  }
#line 285
  dc = delimeters;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (st->start) {
#line 286
      if (! ((int )*dc != 0)) {
#line 286
        goto while_break;
      }
    } else {
#line 286
      goto while_break;
    }
#line 288
    if ((int )*dc == (int )*(st->start)) {
#line 290
      (st->start) ++;
#line 291
      dc = delimeters;
    } else {
#line 293
      dc ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  result = st->start;
#line 300
  if (st->start) {
#line 300
    if ((unsigned long )st->start != (unsigned long )((char *)0)) {
      {
#line 302
      stop = strpbrk((char const   *)st->start, (char const   *)delimeters);
      }
#line 308
      if (stop) {
#line 313
        st->delimeter = *stop;
#line 317
        *stop = (char )'\000';
#line 325
        stop ++;
#line 326
        dc = delimeters;
        {
#line 327
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 327
          if (! ((int )*dc != 0)) {
#line 327
            goto while_break___0;
          }
#line 329
          if ((int )*dc == (int )*stop) {
#line 331
            stop ++;
#line 332
            dc = delimeters;
          } else {
#line 334
            dc ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 337
        if ((int )*stop == 0) {
#line 337
          st->start = (char *)((void *)0);
        } else {
#line 338
          st->start = stop;
        }
      } else {
#line 342
        st->start = (char *)((void *)0);
#line 343
        st->delimeter = (char )'\000';
      }
    } else {
#line 347
      st->start = (char *)((void *)0);
#line 348
      result = (char *)((void *)0);
    }
  } else {
#line 347
    st->start = (char *)((void *)0);
#line 348
    result = (char *)((void *)0);
  }
#line 352
  return (result);
}
}
#line 369 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
int PLD_strlower(char *convertme ) 
{ 
  char *c ;
  int tmp ;

  {
#line 372
  c = convertme;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! ((int )*c != 0)) {
#line 374
      goto while_break;
    }
    {
#line 374
    tmp = tolower((int )*c);
#line 374
    *c = (char )((unsigned char )tmp);
#line 374
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return (0);
}
}
#line 402 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strreplace_general(struct PLD_strreplace *replace_details ) 
{ 
  char *new_buffer ;
  char *source_end ;
  char *segment_start ;
  char *segment_end ;
  char *segment_p ;
  char *new_p ;
  char *preexist_location ;
  char *postexist_location ;
  int replace_count ;
  int size_required ;
  int size_difference ;
  int source_length ;
  int searchfor_length ;
  int replacewith_length ;
  int segment_ok ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *p ;
  size_t tmp___4 ;
  char *p___0 ;
  char *q ;
  void *tmp___5 ;
  int pre_ok ;
  int post_ok ;
  int replacewith_count ;
  char *replacewith_p ;
  int tmp___6 ;
  int pre_ok___0 ;
  int post_ok___0 ;

  {
#line 404
  new_buffer = (char *)((void *)0);
#line 408
  preexist_location = (char *)((void *)0);
#line 409
  postexist_location = (char *)((void *)0);
#line 410
  replace_count = 0;
#line 418
  if ((unsigned long )replace_details->source == (unsigned long )((void *)0)) {
#line 418
    return ((char *)((void *)0));
  }
  {
#line 420
  tmp = strlen((char const   *)replace_details->source);
#line 420
  source_length = (int )tmp;
#line 421
  source_end = replace_details->source + source_length;
#line 422
  tmp___0 = strlen((char const   *)replace_details->searchfor);
#line 422
  searchfor_length = (int )tmp___0;
#line 423
  tmp___1 = strlen((char const   *)replace_details->replacewith);
#line 423
  replacewith_length = (int )tmp___1;
#line 424
  size_difference = replacewith_length - searchfor_length;
#line 425
  size_required = source_length;
#line 426
  replace_count = replace_details->replacenumber;
  }
#line 428
  if ((unsigned long )replace_details->preexist != (unsigned long )((void *)0)) {
    {
#line 428
    tmp___2 = strlen((char const   *)replace_details->preexist);
    }
#line 428
    if (tmp___2 < 1UL) {
#line 428
      replace_details->preexist = (char *)((void *)0);
    }
  }
#line 429
  if ((unsigned long )replace_details->postexist != (unsigned long )((void *)0)) {
    {
#line 429
    tmp___3 = strlen((char const   *)replace_details->postexist);
    }
#line 429
    if (tmp___3 < 1UL) {
#line 429
      replace_details->postexist = (char *)((void *)0);
    }
  }
#line 435
  if ((unsigned long )replace_details->preexist != (unsigned long )((void *)0)) {
    {
#line 437
    preexist_location = PLD_strstr(replace_details->source, replace_details->preexist,
                                   replace_details->insensitive);
    }
#line 438
    if ((unsigned long )preexist_location == (unsigned long )((void *)0)) {
#line 440
      return (replace_details->source);
    }
  }
#line 446
  if ((unsigned long )replace_details->postexist != (unsigned long )((void *)0)) {
#line 448
    p = replace_details->source;
#line 449
    postexist_location = (char *)((void *)0);
    {
#line 450
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 451
      p = PLD_strstr(p, replace_details->postexist, replace_details->insensitive);
      }
#line 452
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 454
        postexist_location = p;
#line 455
        tmp___4 = strlen((char const   *)replace_details->postexist);
#line 455
        p += tmp___4;
        }
      }
#line 450
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 450
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 459
    if ((unsigned long )postexist_location == (unsigned long )((void *)0)) {
#line 461
      return (replace_details->source);
    }
  }
#line 472
  if (size_difference > 0) {
#line 474
    if (replace_count == 0) {
      {
#line 478
      p___0 = replace_details->source;
#line 479
      q = PLD_strstr(p___0, replace_details->searchfor, replace_details->insensitive);
      }
      {
#line 480
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 480
        if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 480
          goto while_break___0;
        }
        {
#line 482
        replace_count ++;
#line 484
        p___0 = q + searchfor_length;
#line 485
        q = PLD_strstr(p___0, replace_details->searchfor, replace_details->insensitive);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 489
    size_required = (source_length + size_difference * replace_count) + 1;
  } else {
#line 490
    size_required = source_length + 1;
  }
  {
#line 495
  tmp___5 = malloc(sizeof(char ) * (unsigned long )size_required);
#line 495
  new_buffer = (char *)tmp___5;
  }
#line 496
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
    {
#line 498
    LOGGER_log((char *)"%s:%d:PLD_strreplace:ERROR: Cannot allocate %d bytes of memory to perform replacement operation",
               "/home/june/collector/temp/altermime-0.3.10/pldstr.c", 498, size_required);
    }
#line 499
    return (replace_details->source);
  }
  {
#line 506
  segment_start = replace_details->source;
#line 510
  segment_ok = 0;
#line 511
  segment_end = PLD_strstr(replace_details->source, replace_details->searchfor, replace_details->insensitive);
  }
  {
#line 515
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 515
    if ((unsigned long )segment_end != (unsigned long )((void *)0)) {
#line 515
      if (segment_ok == 0) {
#line 515
        if (! ((unsigned long )replace_details->preexist != (unsigned long )((void *)0))) {
#line 515
          if (! ((unsigned long )replace_details->postexist != (unsigned long )((void *)0))) {
#line 515
            goto while_break___1;
          }
        }
      } else {
#line 515
        goto while_break___1;
      }
    } else {
#line 515
      goto while_break___1;
    }
#line 518
    pre_ok = 0;
#line 519
    post_ok = 0;
#line 533
    if ((unsigned long )preexist_location == (unsigned long )((void *)0)) {
#line 533
      pre_ok = 1;
    } else
#line 534
    if ((unsigned long )preexist_location < (unsigned long )segment_end) {
#line 534
      pre_ok = 1;
    }
#line 536
    if ((unsigned long )postexist_location == (unsigned long )((void *)0)) {
#line 536
      post_ok = 1;
    } else
#line 537
    if ((unsigned long )postexist_location > (unsigned long )segment_end) {
#line 537
      post_ok = 1;
    }
#line 539
    if (pre_ok == 0) {
      {
#line 539
      segment_end = PLD_strstr(segment_end + searchfor_length, replace_details->searchfor,
                               replace_details->insensitive);
      }
    } else
#line 539
    if (post_ok == 0) {
      {
#line 539
      segment_end = PLD_strstr(segment_end + searchfor_length, replace_details->searchfor,
                               replace_details->insensitive);
      }
    } else {
#line 540
      segment_ok = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 543
  segment_p = segment_start;
#line 544
  new_p = new_buffer;
  {
#line 545
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 545
    if (! ((unsigned long )segment_start != (unsigned long )((void *)0))) {
#line 545
      goto while_break___2;
    }
#line 550
    if ((unsigned long )segment_end == (unsigned long )((void *)0)) {
#line 550
      segment_end = source_end;
    }
#line 552
    replace_count --;
#line 555
    segment_p = segment_start;
    {
#line 556
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 556
      if ((unsigned long )segment_p < (unsigned long )segment_end) {
#line 556
        if (! (size_required > 0)) {
#line 556
          goto while_break___3;
        }
      } else {
#line 556
        goto while_break___3;
      }
#line 558
      *new_p = *segment_p;
#line 559
      new_p ++;
#line 560
      segment_p ++;
#line 561
      size_required --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 565
    if ((unsigned long )segment_end < (unsigned long )source_end) {
#line 567
      replacewith_count = replacewith_length;
#line 568
      replacewith_p = replace_details->replacewith;
      {
#line 569
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 569
        tmp___6 = replacewith_count;
#line 569
        replacewith_count --;
#line 569
        if (tmp___6) {
#line 569
          if (! (size_required > 0)) {
#line 569
            goto while_break___4;
          }
        } else {
#line 569
          goto while_break___4;
        }
#line 571
        *new_p = *replacewith_p;
#line 572
        new_p ++;
#line 573
        replacewith_p ++;
#line 574
        size_required --;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 578
    if (size_required < 1) {
      {
#line 580
      LOGGER_log((char *)"%s:%d:PLD_strreplace_general: Allocated memory ran out while replacing \'%s\' with \'%s\'",
                 "/home/june/collector/temp/altermime-0.3.10/pldstr.c", 580, replace_details->searchfor,
                 replace_details->replacewith);
#line 581
      *new_p = (char )'\000';
      }
#line 582
      goto while_break___2;
    }
#line 586
    segment_start = segment_end + searchfor_length;
#line 597
    if (replace_count == 0) {
#line 599
      segment_end = (char *)((void *)0);
    } else
#line 612
    if ((unsigned long )segment_start > (unsigned long )source_end) {
#line 614
      segment_start = (char *)((void *)0);
    } else {
      {
#line 618
      segment_ok = 0;
#line 619
      segment_end = PLD_strstr(segment_end + searchfor_length, replace_details->searchfor,
                               replace_details->insensitive);
      }
      {
#line 625
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 625
        if ((unsigned long )segment_end != (unsigned long )((void *)0)) {
#line 625
          if (segment_ok == 0) {
#line 625
            if (! ((unsigned long )replace_details->preexist != (unsigned long )((void *)0))) {
#line 625
              if (! ((unsigned long )replace_details->postexist != (unsigned long )((void *)0))) {
#line 625
                goto while_break___5;
              }
            }
          } else {
#line 625
            goto while_break___5;
          }
        } else {
#line 625
          goto while_break___5;
        }
#line 628
        pre_ok___0 = 0;
#line 629
        post_ok___0 = 0;
#line 643
        if ((unsigned long )preexist_location == (unsigned long )((void *)0)) {
#line 643
          pre_ok___0 = 1;
        } else
#line 644
        if ((unsigned long )preexist_location < (unsigned long )segment_end) {
#line 644
          pre_ok___0 = 1;
        }
#line 646
        if ((unsigned long )postexist_location == (unsigned long )((void *)0)) {
#line 646
          post_ok___0 = 1;
        } else
#line 647
        if ((unsigned long )postexist_location > (unsigned long )segment_end) {
#line 647
          post_ok___0 = 1;
        }
#line 649
        if (pre_ok___0 == 0) {
          {
#line 649
          segment_end = PLD_strstr(segment_end + searchfor_length, replace_details->searchfor,
                                   replace_details->insensitive);
          }
        } else
#line 649
        if (post_ok___0 == 0) {
          {
#line 649
          segment_end = PLD_strstr(segment_end + searchfor_length, replace_details->searchfor,
                                   replace_details->insensitive);
          }
        } else {
#line 650
          segment_ok = 1;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 659
  *new_p = (char )'\000';
#line 663
  return (new_buffer);
}
}
#line 684 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_strreplace(char **source , char *searchfor , char *replacewith , int replacenumber ) 
{ 
  struct PLD_strreplace replace_details ;
  char *tmp_source ;

  {
  {
#line 689
  replace_details.source = *source;
#line 690
  replace_details.searchfor = searchfor;
#line 691
  replace_details.replacewith = replacewith;
#line 692
  replace_details.replacenumber = replacenumber;
#line 693
  replace_details.preexist = (char *)((void *)0);
#line 694
  replace_details.postexist = (char *)((void *)0);
#line 695
  replace_details.insensitive = 0;
#line 697
  tmp_source = PLD_strreplace_general(& replace_details);
  }
#line 699
  if ((unsigned long )tmp_source != (unsigned long )*source) {
#line 699
    *source = tmp_source;
  }
#line 701
  return (*source);
}
}
#line 724 "/home/june/collector/temp/altermime-0.3.10/pldstr.c"
char *PLD_dprintf(char const   *format  , ...) 
{ 
  int n ;
  int size ;
  char *p ;
  va_list ap ;
  void *tmp ;
  char *tmp_p ;
  void *tmp___0 ;

  {
  {
#line 726
  size = 1024;
#line 731
  tmp = malloc((unsigned long )size * sizeof(char ));
#line 731
  p = (char *)tmp;
  }
#line 732
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 732
    return ((char *)((void *)0));
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 737
    __builtin_va_start(ap, format);
#line 738
    n = vsnprintf((char */* __restrict  */)p, (size_t )size, (char const   */* __restrict  */)format,
                  ap);
#line 739
    __builtin_va_end(ap);
    }
#line 742
    if (n > -1) {
#line 742
      if (n < size) {
#line 742
        return (p);
      }
    }
#line 751
    if (n > -1) {
#line 751
      size = n + 1;
    } else {
#line 752
      size *= 2;
    }
    {
#line 761
    tmp___0 = realloc((void *)p, (size_t )size);
#line 761
    tmp_p = (char *)tmp___0;
    }
#line 762
    if ((unsigned long )tmp_p == (unsigned long )((void *)0)) {
#line 762
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 762
        free((void *)p);
        }
      }
#line 762
      return ((char *)((void *)0));
    } else {
#line 763
      p = tmp_p;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 17 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.h"
int MDECODE_set_debug(int level ) ;
#line 18
int MDECODE_set_verbose(int level ) ;
#line 19
int MDECODE_set_decode_qp(int level ) ;
#line 20
int MDECODE_set_decode_b64(int level ) ;
#line 21
int MDECODE_init(void) ;
#line 23
int MDECODE_decode_quoted_printable(char *line , int qpmode , char esc_char ) ;
#line 24
int MDECODE_decode_short64(char *short64 ) ;
#line 26
int MDECODE_decode_qp_text(char *line ) ;
#line 27
int MDECODE_decode_qp_ISO(char *line ) ;
#line 31 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
static unsigned char b64___0[256]  = 
#line 31 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
  {      (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)62, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)63, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)0,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)4,      (unsigned char)5,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)8,      (unsigned char)9,      (unsigned char)10, 
        (unsigned char)11,      (unsigned char)12,      (unsigned char)13,      (unsigned char)14, 
        (unsigned char)15,      (unsigned char)16,      (unsigned char)17,      (unsigned char)18, 
        (unsigned char)19,      (unsigned char)20,      (unsigned char)21,      (unsigned char)22, 
        (unsigned char)23,      (unsigned char)24,      (unsigned char)25,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)26,      (unsigned char)27,      (unsigned char)28, 
        (unsigned char)29,      (unsigned char)30,      (unsigned char)31,      (unsigned char)32, 
        (unsigned char)33,      (unsigned char)34,      (unsigned char)35,      (unsigned char)36, 
        (unsigned char)37,      (unsigned char)38,      (unsigned char)39,      (unsigned char)40, 
        (unsigned char)41,      (unsigned char)42,      (unsigned char)43,      (unsigned char)44, 
        (unsigned char)45,      (unsigned char)46,      (unsigned char)47,      (unsigned char)48, 
        (unsigned char)49,      (unsigned char)50,      (unsigned char)51,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128, 
        (unsigned char)128,      (unsigned char)128,      (unsigned char)128,      (unsigned char)128};
#line 54 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
static unsigned char hexconv[256]  = 
#line 54
  {      (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)10,      (unsigned char)11,      (unsigned char)12, 
        (unsigned char)13,      (unsigned char)14,      (unsigned char)15,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)10,      (unsigned char)11,      (unsigned char)12, 
        (unsigned char)13,      (unsigned char)14,      (unsigned char)15,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)20,      (unsigned char)20};
#line 82 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
static struct MDECODE_globals glb___3  ;
#line 87 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_init(void) 
{ 


  {
#line 89
  glb___3.debug = 0;
#line 90
  glb___3.verbose = 0;
#line 91
  glb___3.decode_qp = 1;
#line 92
  glb___3.decode_b64 = 1;
#line 94
  return (0);
}
}
#line 108 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_set_debug(int level ) 
{ 


  {
#line 110
  glb___3.debug = level;
#line 111
  return (glb___3.debug);
}
}
#line 115 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_set_verbose(int level ) 
{ 


  {
#line 117
  glb___3.verbose = level;
#line 118
  return (glb___3.verbose);
}
}
#line 121 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_set_decode_qp(int level ) 
{ 


  {
#line 123
  glb___3.decode_qp = level;
#line 124
  return (glb___3.decode_qp);
}
}
#line 127 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_set_decode_b64(int level ) 
{ 


  {
#line 129
  glb___3.decode_b64 = level;
#line 130
  return (glb___3.decode_b64);
}
}
#line 141 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_decode_short64(char *short64 ) 
{ 
  int i ;
  int realm_size ;
  size_t tmp ;
  int stopcount ;
  int c ;
  int char_count ;
  char output[3] ;
  char input[4] ;
  char *outstring ;

  {
  {
#line 144
  tmp = strlen((char const   *)short64);
#line 144
  realm_size = (int )tmp;
#line 145
  stopcount = 0;
#line 147
  char_count = 0;
#line 150
  outstring = short64;
#line 152
  char_count = 0;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (char_count < realm_size)) {
#line 153
      goto while_break;
    }
#line 157
    input[3] = (char)0;
#line 157
    input[2] = input[3];
#line 157
    input[1] = input[2];
#line 157
    input[0] = input[1];
#line 160
    i = 0;
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! (i < 4)) {
#line 160
        goto while_break___0;
      }
#line 163
      c = (int )*short64;
#line 164
      short64 ++;
#line 167
      char_count ++;
#line 170
      if (c == 61) {
#line 171
        stopcount ++;
      }
#line 175
      if ((int )b64___0[c] == 128) {
#line 176
        i --;
#line 177
        goto __Cont;
      }
#line 181
      input[i] = (char )b64___0[c];
      __Cont: /* CIL Label */ 
#line 160
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    output[0] = (char )(((int )input[0] << 2) | ((int )input[1] >> 4));
#line 187
    output[1] = (char )(((int )input[1] << 4) | ((int )input[2] >> 2));
#line 188
    output[2] = (char )(((int )input[2] << 6) | (int )input[3]);
#line 191
    if (i == 4) {
#line 192
      i = 0;
      {
#line 192
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 192
        if (! (i < 3 - stopcount)) {
#line 192
          goto while_break___1;
        }
#line 193
        *outstring = output[i];
#line 194
        outstring ++;
#line 192
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  *outstring = (char )'\000';
#line 202
  return (0);
}
}
#line 221 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_decode_quoted_printable(char *line , int qpmode , char esc_char ) 
{ 
  char c ;
  int op ;
  int ip ;
  int slen ;
  size_t tmp ;
  int original_ip ;
  char *w ;
  size_t tmp___0 ;

  {
  {
#line 226
  tmp = strlen((char const   *)line);
#line 226
  slen = (int )tmp;
  }
#line 228
  if (glb___3.debug >= 1) {
    {
#line 228
    LOGGER_log((char *)"%s:%d:MDECODE_decode_quoted_printable:DEBUG: input string = \'%s\' Input length = %d\n",
               "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c", 228,
               line, slen);
    }
  }
#line 231
  op = 0;
#line 231
  ip = op;
#line 235
  ip = 0;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! (ip < slen)) {
#line 235
      goto while_break;
    }
#line 237
    c = *(line + ip);
#line 240
    if ((int )c == (int )esc_char) {
#line 244
      if (ip + 1 < slen) {
#line 246
        original_ip = ip;
#line 264
        w = line + (ip + 1);
        {
#line 265
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 265
          if (! ((int )*w == 9)) {
#line 265
            if (! ((int )*w == 32)) {
#line 265
              goto while_break___0;
            }
          }
#line 265
          w ++;
#line 265
          ip ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 269
        if ((int )*(line + (ip + 1)) == 10) {
#line 269
          goto _L;
        } else
#line 269
        if ((int )*(line + (ip + 1)) == 13) {
          _L: /* CIL Label */ 
#line 271
          ip ++;
#line 272
          if (ip + 1 < slen) {
#line 272
            if ((int )*(line + (ip + 1)) == 10) {
#line 274
              ip ++;
            } else
#line 272
            if ((int )*(line + (ip + 1)) == 13) {
#line 274
              ip ++;
            }
          }
#line 276
          goto __Cont;
        } else {
#line 290
          ip = original_ip;
#line 294
          if (ip < slen - 1) {
#line 300
            if (! ((int )hexconv[(int )*(line + (ip + 1))] == 20)) {
#line 300
              if (! ((int )hexconv[(int )*(line + (ip + 2))] == 20)) {
#line 307
                c = (char )((int )((char )hexconv[(int )*(line + (ip + 1))]) * 16 + (int )hexconv[(int )*(line + (ip + 2))]);
#line 310
                ip += 2;
              }
            }
          } else {
            {
#line 314
            LOGGER_log((char *)"%s:%d:MIME_decode_quoted_printable:WARNING: Ran out of characters when decoding end of \'%s\'\n",
                       "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                       314, line + ip);
            }
          }
        }
      } else {
#line 327
        *(line + op) = (char )'\000';
#line 329
        goto while_break;
      }
    } else
#line 336
    if ((int )c == 95) {
#line 336
      if (qpmode == 1) {
#line 340
        c = (char )' ';
      }
    }
#line 344
    *(line + op) = c;
#line 347
    op ++;
    __Cont: /* CIL Label */ 
#line 235
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  *(line + op) = (char )'\000';
#line 356
  if (glb___3.debug >= 1) {
    {
#line 356
    tmp___0 = strlen((char const   *)line);
#line 356
    LOGGER_log((char *)"%s:%d:MDECODE_decode_quoted_printable:DEBUG: Output = \'%s\' Output length = %d\n",
               "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c", 356,
               line, tmp___0);
    }
  }
#line 359
  return (op);
}
}
#line 376 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_decode_qp_text(char *line ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 378
  if (glb___3.decode_qp == 0) {
    {
#line 378
    tmp = strlen((char const   *)line);
    }
#line 378
    return ((int )tmp);
  }
  {
#line 380
  tmp___0 = MDECODE_decode_quoted_printable(line, 0, (char )'=');
  }
#line 380
  return (tmp___0);
}
}
#line 383 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_decode_qp_ISO(char *line ) 
{ 
  int tmp ;

  {
  {
#line 386
  tmp = MDECODE_decode_quoted_printable(line, 0, (char )'=');
  }
#line 386
  return (tmp);
}
}
#line 389 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_decode_multipart(char *line ) 
{ 
  int tmp ;

  {
  {
#line 391
  tmp = MDECODE_decode_quoted_printable(line, 0, (char )'%');
  }
#line 391
  return (tmp);
}
}
#line 404 "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c"
int MDECODE_decode_ISO(char *isostring , int size ) 
{ 
  char *start_pair ;
  char *end_pair ;
  char *iso ;
  char *iso_copy ;
  char encoding_type ;
  char encoding_charset[16] ;
  char *iso_start ;
  char *iso_end ;
  int iso_decoded ;
  void *tmp ;
  size_t tmp___0 ;
  char *token_end ;
  char restore_char ;
  size_t tmp___1 ;
  char *new_end_pos ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 408
  encoding_type = (char )'-';
#line 413
  if (glb___3.debug >= 1) {
    {
#line 413
    LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: ISO-string=\'%s\'", "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
               413, isostring);
    }
  }
  {
#line 425
  iso_start = (char *)((void *)0);
#line 425
  iso_end = iso_start;
#line 427
  end_pair = (char *)((void *)0);
#line 427
  start_pair = end_pair;
#line 429
  tmp = malloc(sizeof(char ) * (unsigned long )(size + 1));
#line 429
  iso_copy = (char *)tmp;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 433
    iso_decoded = 0;
#line 435
    start_pair = strstr((char const   *)isostring, "=?");
    }
#line 438
    if ((unsigned long )start_pair != (unsigned long )((void *)0)) {
#line 440
      iso_start = start_pair;
#line 445
      if (glb___3.debug >= 1) {
        {
#line 445
        LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: ISO start = %s", "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                   445, iso_start);
        }
      }
      {
#line 447
      tmp___0 = strlen("=?");
#line 447
      iso_end = strchr((char const   *)(iso_start + tmp___0), '?');
      }
#line 448
      if (iso_end) {
        {
#line 448
        iso_end = strchr((char const   *)(iso_end + 1), '?');
        }
      }
#line 449
      if (iso_end) {
        {
#line 449
        iso_end = strpbrk((char const   *)(iso_end + 1), "?\n\r\t;");
        }
      }
#line 450
      if ((unsigned long )iso_end != (unsigned long )((void *)0)) {
#line 450
        if ((int )*iso_end == 63) {
#line 450
          iso_end += 2;
        }
      }
#line 453
      if (iso_start) {
#line 453
        if (iso_end) {
          {
#line 456
          restore_char = (char )'\000';
#line 459
          tmp___1 = strlen("=?");
#line 459
          iso = iso_start + tmp___1;
#line 461
          token_end = strchr((char const   *)iso, '?');
          }
#line 462
          if (token_end) {
#line 462
            *token_end = (char )'\000';
          }
          {
#line 463
          snprintf((char */* __restrict  */)(encoding_charset), sizeof(encoding_charset),
                   (char const   */* __restrict  */)"%s", iso);
          }
#line 464
          if (glb___3.debug >= 1) {
            {
#line 464
            LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: ISO char set = \'%s\'",
                       "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                       464, encoding_charset);
            }
          }
          {
#line 466
          iso = token_end + 1;
#line 469
          token_end = strchr((char const   *)iso, '?');
#line 470
          encoding_type = *iso;
#line 472
          iso = token_end + 1;
          }
#line 474
          if (glb___3.debug >= 1) {
            {
#line 474
            LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: ISO encoding char = \'%c\'",
                       "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                       474, (int )encoding_type);
            }
          }
          {
#line 477
          token_end = strpbrk((char const   *)iso, "?;\n\r\t");
          }
#line 478
          if ((unsigned long )token_end != (unsigned long )((void *)0)) {
#line 480
            if ((int )*token_end != 63) {
#line 480
              if ((int )*token_end != 59) {
#line 482
                restore_char = *token_end;
              }
            }
#line 484
            *token_end = (char )'\000';
          }
#line 493
          if (iso) {
#line 495
            if (glb___3.debug >= 1) {
              {
#line 495
              LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: Encoded String = \'%s\'\n",
                         "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                         495, iso);
              }
            }
            {
#line 499
            if ((int )encoding_type == 113) {
#line 499
              goto case_113;
            }
#line 499
            if ((int )encoding_type == 81) {
#line 499
              goto case_113;
            }
#line 506
            if ((int )encoding_type == 98) {
#line 506
              goto case_98;
            }
#line 506
            if ((int )encoding_type == 66) {
#line 506
              goto case_98;
            }
#line 512
            goto switch_default;
            case_113: /* CIL Label */ 
            case_81: /* CIL Label */ 
#line 500
            if (glb___3.debug >= 1) {
              {
#line 500
              LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: Decoding filename using Quoted-Printable (%s)\n",
                         "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                         500, iso);
              }
            }
            {
#line 501
            MDECODE_decode_qp_ISO(iso);
#line 502
            iso_decoded = 1;
            }
#line 503
            goto switch_break;
            case_98: /* CIL Label */ 
            case_66: /* CIL Label */ 
#line 507
            if (glb___3.debug >= 1) {
              {
#line 507
              LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: Decoding filename using BASE64 (%s)\n",
                         "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                         507, iso);
              }
            }
            {
#line 508
            MDECODE_decode_short64(iso);
#line 509
            iso_decoded = 1;
            }
#line 510
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 513
            if (glb___3.verbose) {
              {
#line 513
              LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:ERROR: The encoding character \'%c\' is not a valid type of encoding\n",
                         "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                         513, (int )encoding_type);
              }
            }
            switch_break: /* CIL Label */ ;
            }
#line 518
            if (iso_decoded == 1) {
#line 522
              if (glb___3.debug >= 1) {
                {
#line 522
                LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: Decoded String = \'%s\'\n",
                           "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                           522, iso);
                }
              }
#line 523
              *iso_start = (char )'\000';
#line 532
              if (token_end) {
#line 534
                iso_end = token_end + 1;
#line 535
                if (glb___3.debug >= 1) {
                  {
#line 535
                  LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: iso_end = \'%20s\'",
                             "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                             535, iso_end);
                  }
                }
                {
#line 536
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 536
                  if (! ((int )*iso_end == 63)) {
#line 536
                    if (! ((int )*iso_end == 61)) {
#line 536
                      goto while_break___0;
                    }
                  }
#line 536
                  iso_end ++;
                }
                while_break___0: /* CIL Label */ ;
                }
#line 537
                if (glb___3.debug >= 1) {
                  {
#line 537
                  LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: iso_end = \'%20s\'",
                             "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                             537, iso_end);
                  }
                }
#line 539
                new_end_pos = iso_end;
                {
#line 540
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 540
                  if (! ((int )*new_end_pos == 32)) {
#line 540
                    if (! ((int )*new_end_pos == 9)) {
#line 540
                      goto while_break___1;
                    }
                  }
#line 540
                  new_end_pos ++;
                }
                while_break___1: /* CIL Label */ ;
                }
                {
#line 541
                tmp___2 = strncmp((char const   *)new_end_pos, "=?", (size_t )2);
                }
#line 541
                if (tmp___2 == 0) {
#line 541
                  iso_end = new_end_pos;
                }
              } else {
#line 543
                iso_end = (char *)((void *)0);
              }
#line 546
              if (glb___3.debug >= 1) {
                {
#line 546
                LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: ISO-END = \'%20s\'",
                           "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                           546, iso_end);
                }
              }
#line 557
              if ((int )restore_char != 0) {
#line 559
                if (glb___3.debug >= 1) {
                  {
#line 559
                  LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: Recomposing string with restore-char of \'%c\'",
                             "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                             559, (int )restore_char);
                  }
                }
#line 560
                if (glb___3.debug >= 1) {
                  {
#line 560
                  LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: ISO-end (start of end of string) is \n%s",
                             "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                             560, iso_end);
                  }
                }
#line 561
                if (iso_end) {
#line 561
                  tmp___3 = (char const   *)iso_end;
                } else {
#line 561
                  tmp___3 = "";
                }
                {
#line 561
                snprintf((char */* __restrict  */)iso_copy, (size_t )size, (char const   */* __restrict  */)"%s%s%c%s",
                         isostring, iso, (int )restore_char, tmp___3);
                }
              } else {
#line 563
                if (glb___3.debug >= 1) {
                  {
#line 563
                  LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: Recomposing string with NO restore-char",
                             "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                             563, (int )restore_char);
                  }
                }
#line 564
                if (iso_end) {
#line 564
                  tmp___4 = (char const   *)iso_end;
                } else {
#line 564
                  tmp___4 = "";
                }
                {
#line 564
                snprintf((char */* __restrict  */)iso_copy, (size_t )size, (char const   */* __restrict  */)"%s%s%s",
                         isostring, iso, tmp___4);
                }
              }
              {
#line 568
              snprintf((char */* __restrict  */)isostring, (size_t )size, (char const   */* __restrict  */)"%s",
                       iso_copy);
              }
#line 569
              if (glb___3.debug >= 1) {
                {
#line 569
                LOGGER_log((char *)"%s:%d:MDECODE_decode_ISO:DEBUG: New ISO string = \n%s",
                           "/home/june/collector/temp/altermime-0.3.10/libmime-decoders.c",
                           569, isostring);
                }
              }
            }
          }
        }
      }
    }
#line 431
    if (! (iso_decoded == 1)) {
#line 431
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  if (iso_copy) {
    {
#line 581
    free((void *)iso_copy);
    }
  }
#line 583
  return (0);
}
}
#line 4 "/home/june/collector/temp/altermime-0.3.10/qpe.h"
int qp_encode_set_debug(int level ) ;
#line 6
int qp_encode_from_file(char *fname ) ;
#line 17 "/home/june/collector/temp/altermime-0.3.10/qpe.c"
int qpe_debug  =    0;
#line 19 "/home/june/collector/temp/altermime-0.3.10/qpe.c"
int qp_encode_set_debug(int level ) 
{ 


  {
#line 21
  qpe_debug = level;
#line 23
  return (0);
}
}
#line 27 "/home/june/collector/temp/altermime-0.3.10/qpe.c"
int qp_encode(char *out , size_t out_size , char *in , size_t in_size ) 
{ 
  int result ;
  size_t out_remaining ;
  char *linestart ;
  char *lineend ;
  char *p ;
  char *op ;
  char paragraph[100] ;
  char *pp ;
  size_t pp_remaining ;
  char *input_data_limit ;
  size_t current_line_length ;
  char charout[4] ;
  int charout_size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 29
  result = 0;
#line 33
  pp_remaining = (size_t )100;
#line 34
  input_data_limit = in + in_size;
#line 35
  current_line_length = (size_t )0;
#line 38
  linestart = (char *)((void *)0);
#line 39
  lineend = in;
#line 42
  op = out;
#line 43
  out_remaining = out_size;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    charout_size = 0;
#line 49
    if ((unsigned long )lineend != (unsigned long )((char *)0)) {
#line 50
      if ((unsigned long )linestart == (unsigned long )((void *)0)) {
#line 51
        linestart = in;
      } else {
#line 53
        linestart = lineend;
      }
      {
#line 56
      lineend = strstr((char const   *)linestart, "\r\n");
      }
#line 57
      if ((unsigned long )lineend == (unsigned long )((void *)0)) {
#line 58
        if (qpe_debug > 0) {
          {
#line 58
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"No CRLF found, setting line-end to end of the input\n");
          }
        }
#line 59
        lineend = in + in_size;
      } else {
#line 61
        if (qpe_debug > 0) {
          {
#line 62
          *lineend = (char )'\000';
#line 63
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"INPUT STRING: \'%s\'\n",
                  linestart);
#line 64
          *lineend = (char )'\r';
          }
        }
        {
#line 66
        tmp = strlen("\r\n");
#line 66
        lineend += tmp;
        }
      }
    }
#line 73
    paragraph[0] = (char )'\000';
#line 74
    pp = paragraph;
#line 75
    pp_remaining = sizeof(paragraph);
#line 76
    current_line_length = (size_t )0;
#line 78
    if (qpe_debug > 0) {
      {
#line 78
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Starting new line of encoding...\n");
      }
    }
#line 81
    p = linestart;
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if (! ((unsigned long )p < (unsigned long )lineend)) {
#line 82
        goto while_break___0;
      }
#line 84
      if ((int )*p < 32) {
        {
#line 86
        snprintf((char */* __restrict  */)(charout), sizeof(charout), (char const   */* __restrict  */)"=%02X",
                 (int )((unsigned char )*p));
#line 87
        charout_size = 3;
        }
      } else
#line 84
      if ((int )*p == 61) {
        {
#line 86
        snprintf((char */* __restrict  */)(charout), sizeof(charout), (char const   */* __restrict  */)"=%02X",
                 (int )((unsigned char )*p));
#line 87
        charout_size = 3;
        }
      } else
#line 84
      if ((int )*p > 126) {
        {
#line 86
        snprintf((char */* __restrict  */)(charout), sizeof(charout), (char const   */* __restrict  */)"=%02X",
                 (int )((unsigned char )*p));
#line 87
        charout_size = 3;
        }
      } else {
        {
#line 90
        snprintf((char */* __restrict  */)(charout), sizeof(charout), (char const   */* __restrict  */)"%c",
                 (int )*p);
#line 91
        charout_size = 1;
        }
      }
#line 94
      if (current_line_length + (size_t )charout_size >= 79UL) {
        {
#line 96
        snprintf((char */* __restrict  */)op, out_remaining, (char const   */* __restrict  */)"%s=\r\n",
                 paragraph);
#line 97
        tmp___0 = strlen((char const   *)(paragraph));
#line 97
        op += tmp___0;
#line 98
        tmp___1 = strlen((char const   *)(paragraph));
#line 98
        out_remaining -= tmp___1;
        }
#line 100
        if (qpe_debug > 0) {
          {
#line 100
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Soft break (%Zd + %d > 76 char) for \'%s\'\n",
                  current_line_length, charout_size, paragraph);
          }
        }
#line 103
        paragraph[0] = (char )'\000';
#line 104
        pp_remaining = sizeof(paragraph);
#line 105
        pp = paragraph;
#line 106
        current_line_length = (size_t )-1;
      }
      {
#line 110
      snprintf((char */* __restrict  */)pp, pp_remaining, (char const   */* __restrict  */)"%s",
               charout);
      }
#line 111
      if (qpe_debug > 0) {
        {
#line 111
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"charout=\'%s\', size=%d, pp_remain=%Zd result=\'%s\'\n",
                charout, charout_size, pp_remaining, paragraph);
        }
      }
#line 112
      pp += charout_size;
#line 113
      pp_remaining -= (size_t )charout_size;
#line 114
      p ++;
#line 115
      current_line_length += (size_t )charout_size;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 119
    if (qpe_debug > 0) {
      {
#line 119
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Adding paragraph \'%s\' to output\n",
              paragraph);
      }
    }
    {
#line 121
    snprintf((char */* __restrict  */)op, out_remaining, (char const   */* __restrict  */)"%s\r\n",
             paragraph);
#line 122
    tmp___2 = strlen((char const   *)(paragraph));
#line 122
    op += tmp___2 + 2UL;
#line 123
    tmp___3 = strlen((char const   *)(paragraph));
#line 123
    out_remaining -= tmp___3 + 2UL;
    }
#line 45
    if ((unsigned long )lineend < (unsigned long )input_data_limit) {
#line 45
      if (! ((int )*lineend != 0)) {
#line 45
        goto while_break;
      }
    } else {
#line 45
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (result);
}
}
#line 131 "/home/june/collector/temp/altermime-0.3.10/qpe.c"
int qp_encode_from_file(char *fname ) 
{ 
  size_t bc ;
  struct stat st ;
  int stat_result ;
  char *in_buffer ;
  char *out_buffer ;
  size_t in_size ;
  size_t out_size ;
  FILE *f ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 141
  stat_result = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& st));
  }
#line 142
  if (stat_result != 0) {
#line 143
    if (qpe_debug > 0) {
      {
#line 143
      tmp = __errno_location();
#line 143
      tmp___0 = strerror(*tmp);
#line 143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot locate file \'%s\' for loading and QP encoding (%s)\n",
              fname, tmp___0);
      }
    }
#line 144
    return (-1);
  }
  {
#line 148
  in_size = (size_t )st.st_size;
#line 149
  out_size = in_size * 3UL;
#line 150
  tmp___1 = malloc(sizeof(char ) * in_size + 1UL);
#line 150
  in_buffer = (char *)tmp___1;
  }
#line 151
  if ((unsigned long )in_buffer == (unsigned long )((void *)0)) {
#line 152
    if (qpe_debug > 0) {
      {
#line 152
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Error allocating %Zd bytes for input buffer\n",
              in_size);
      }
    }
#line 153
    return (-1);
  }
  {
#line 156
  tmp___2 = malloc((sizeof(char ) * out_size) * 3UL + 1UL);
#line 156
  out_buffer = (char *)tmp___2;
  }
#line 157
  if ((unsigned long )in_buffer == (unsigned long )((void *)0)) {
#line 158
    if (qpe_debug > 0) {
      {
#line 158
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Error allocating %Zd bytes for output buffer\n",
              out_size);
      }
    }
#line 159
    return (-1);
  }
  {
#line 163
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
#line 164
  bc = fread((void */* __restrict  */)in_buffer, (size_t )1, in_size, (FILE */* __restrict  */)f);
  }
#line 165
  if (bc != in_size) {
    {
#line 165
    LOGGER_log((char *)"%s:%d:qp_encode_from_file:ERROR: Read %d bytes but requested %d",
               "/home/june/collector/temp/altermime-0.3.10/qpe.c", 165, bc, in_size);
    }
  }
  {
#line 166
  fclose(f);
#line 170
  *(in_buffer + in_size) = (char )'\000';
  }
#line 172
  if (qpe_debug > 0) {
    {
#line 172
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"file %s is loaded, size = %Zd\n",
            fname, in_size);
    }
  }
  {
#line 174
  qp_encode(out_buffer, out_size, in_buffer, in_size);
#line 176
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          out_buffer);
#line 178
  free((void *)in_buffer);
#line 179
  free((void *)out_buffer);
  }
#line 181
  return (0);
}
}
