/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE {
   char *mStart ;
   char *mEnd ;
   char *mArgS ;
   char *mArgSep ;
   char *mArgE ;
   char *mArgRef ;
   char quotechar ;
   char *stackchar ;
   char *unstackchar ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
typedef unsigned long *CHARSET_SUBSET;
#line 106 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct COMMENT {
   char *start ;
   char *end ;
   char quote ;
   char warn ;
   int flags[3] ;
   struct COMMENT *next ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct SPECS {
   struct MODE User ;
   struct MODE Meta ;
   struct COMMENT *comments ;
   struct SPECS *stack_next ;
   int preservelf ;
   CHARSET_SUBSET op_set ;
   CHARSET_SUBSET ext_op_set ;
   CHARSET_SUBSET id_set ;
};
#line 164 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MACRO {
   char *username ;
   char *macrotext ;
   char **argnames ;
   int macrolen ;
   int nnamedargs ;
   struct SPECS *define_specs ;
   int defined_in_comment ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct OUTPUTCONTEXT {
   char *buf ;
   int len ;
   int bufsize ;
   FILE *f ;
};
#line 200 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct INPUTCONTEXT {
   char *buf ;
   char *malloced_buf ;
   int len ;
   int bufsize ;
   int lineno ;
   char *filename ;
   FILE *in ;
   int argc ;
   char **argv ;
   char **namedargs ;
   struct OUTPUTCONTEXT *out ;
   int eof ;
   int in_comment ;
   int ambience ;
   int may_have_args ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE CUser  = 
#line 86 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
     {(char *)"", (char *)"", (char *)"(", (char *)",", (char *)")", (char *)"#", (char )'\\',
    (char *)"(", (char *)")"};
#line 87 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE CMeta  = 
#line 87
     {(char *)"#", (char *)"\n", (char *)"\001", (char *)"\001", (char *)"\n", (char *)"#",
    (char )'\\', (char *)"(", (char *)")"};
#line 88 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE KUser  = 
#line 88
     {(char *)"", (char *)"", (char *)"(", (char *)",", (char *)")", (char *)"#", (char)0,
    (char *)"(", (char *)")"};
#line 89 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE KMeta  = 
#line 89
     {(char *)"\n#\002", (char *)"\n", (char *)"\001", (char *)"\001", (char *)"\n",
    (char *)"#", (char)0, (char *)"", (char *)""};
#line 90 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE Tex  = 
#line 90
     {(char *)"\\", (char *)"", (char *)"{", (char *)"}{", (char *)"}", (char *)"#",
    (char )'@', (char *)"{", (char *)"}"};
#line 91 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE Html  = 
#line 91
     {(char *)"<#", (char *)">", (char *)"\003", (char *)"|", (char *)">", (char *)"#",
    (char )'\\', (char *)"<", (char *)">"};
#line 92 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MODE XHtml  = 
#line 92
     {(char *)"<#", (char *)"/>", (char *)"\003", (char *)"|", (char *)"/>", (char *)"#",
    (char )'\\', (char *)"<", (char *)">"};
#line 104 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
CHARSET_SUBSET DefaultOp  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
CHARSET_SUBSET DefaultExtOp  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
CHARSET_SUBSET PrologOp  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
CHARSET_SUBSET DefaultId  ;
#line 162 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct SPECS *S  ;
#line 171 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct MACRO *macros  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int nmacros  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int nalloced  ;
#line 173 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *includedir[10]  ;
#line 174 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int nincludedirs  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int execallowed  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int dosmode  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int autoswitch  ;
#line 183 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *include_directive_marker  =    (char *)((void *)0);
#line 184 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
short WarningLevel  =    (short)2;
#line 188 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int NoStdInc  =    0;
#line 189 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int NoCurIncFirst  =    0;
#line 190 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int CurDirIncLast  =    0;
#line 191 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int file_and_stdout  =    0;
#line 192 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *IncludeFile  =    (char *)((void *)0);
#line 217 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct INPUTCONTEXT *C  ;
#line 219 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int commented[50]  ;
#line 219 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int iflevel  ;
#line 224
void ProcessContext(void) ;
#line 226
int findIdent(char const   *b , int l ) ;
#line 227
void delete_macro(int i ) ;
#line 230
void usage(void) ;
#line 231
void display_version(void) ;
#line 232
void bug(char const   *s ) ;
#line 233
void warning(char const   *s ) ;
#line 234
static void getDirname(char const   *fname , char *dirname ) ;
#line 235
static FILE *openInCurrentDir(char const   *incfile ) ;
#line 236
char *ArithmEval(int pos1 , int pos2 ) ;
#line 237
void replace_definition_with_blank_lines(char const   *start , char const   *end ,
                                         int skip ) ;
#line 238
void replace_directive_with_blank_line(FILE *f ) ;
#line 239
void write_include_marker(FILE *f , int lineno , char *filename , char const   *marker ) ;
#line 240
void construct_include_directive_marker(char **include_directive_marker___0 , char const   *includemarker_input ) ;
#line 242
void escape_backslashes(char const   *instr , char **outstr ) ;
#line 243
static void DoInclude(char *file_name ) ;
#line 277 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void bug(char const   *s ) 
{ 


  {
  {
#line 279
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: error: %s\n",
          C->filename, C->lineno, s);
#line 280
  exit(1);
  }
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void warning(char const   *s ) 
{ 


  {
  {
#line 285
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: warning: %s\n",
          C->filename, C->lineno, s);
  }
#line 286
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
struct SPECS *CloneSpecs(struct SPECS  const  *Q ) 
{ 
  struct SPECS *P ;
  struct COMMENT *x ;
  struct COMMENT *y ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 293
  tmp = malloc(sizeof(*P));
#line 293
  P = (struct SPECS *)tmp;
  }
#line 294
  if ((unsigned long )P == (unsigned long )((void *)0)) {
    {
#line 294
    bug("Out of memory.");
    }
  }
  {
#line 295
  memcpy((void */* __restrict  */)P, (void const   */* __restrict  */)Q, sizeof(struct SPECS ));
#line 296
  P->stack_next = (struct SPECS *)((void *)0);
  }
#line 297
  if ((unsigned long )Q->comments != (unsigned long )((void *)0)) {
    {
#line 298
    tmp___0 = malloc(sizeof(*(P->comments)));
#line 298
    P->comments = (struct COMMENT *)tmp___0;
    }
  }
#line 299
  x = (struct COMMENT *)Q->comments;
#line 299
  y = P->comments;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 299
      goto while_break;
    }
    {
#line 300
    memcpy((void */* __restrict  */)y, (void const   */* __restrict  */)x, sizeof(struct COMMENT ));
#line 301
    y->start = strdup((char const   *)x->start);
#line 302
    y->end = strdup((char const   *)x->end);
    }
#line 303
    if ((unsigned long )x->next != (unsigned long )((void *)0)) {
      {
#line 304
      tmp___1 = malloc(sizeof(*(y->next)));
#line 304
      y->next = (struct COMMENT *)tmp___1;
      }
    }
#line 299
    x = x->next;
#line 299
    y = y->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (P);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void FreeComments(struct SPECS *Q ) 
{ 
  struct COMMENT *p ;

  {
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (Q) {
#line 313
      if (! ((unsigned long )Q->comments != (unsigned long )((void *)0))) {
#line 313
        goto while_break;
      }
    } else {
#line 313
      goto while_break;
    }
    {
#line 314
    p = Q->comments;
#line 315
    Q->comments = p->next;
#line 316
    free((void *)p->start);
#line 317
    free((void *)p->end);
#line 318
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void PushSpecs(struct SPECS  const  *X ) 
{ 
  struct SPECS *P ;

  {
  {
#line 326
  P = CloneSpecs(X);
#line 327
  P->stack_next = S;
#line 328
  S = P;
  }
#line 329
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void PopSpecs(void) 
{ 
  struct SPECS *P ;

  {
  {
#line 335
  P = S;
#line 336
  S = P->stack_next;
#line 337
  FreeComments(P);
#line 338
  free((void *)P);
  }
#line 339
  if ((unsigned long )S == (unsigned long )((void *)0)) {
    {
#line 339
    bug("#mode restore without #mode save");
    }
  }
#line 340
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void display_version(void) 
{ 


  {
  {
#line 343
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GPP 2.24\n");
#line 344
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (C) 1996-2001 Denis Auroux\n");
#line 345
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (C) 2003, 2004 Tristan Miller\n");
#line 346
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void usage(void) 
{ 


  {
  {
#line 353
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage : gpp [-{o|O} outfile] [-I/include/path] [-Dname=val ...] [-z] [-x] [-m]\n");
#line 354
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"            [-n] [-C | -T | -H | -X | -P | -U ... [-M ...]] [+c<n> str1 str2]\n");
#line 355
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"            [+s<n> str1 str2 c] [long options] [infile]\n\n");
#line 356
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      default:    #define x y           macro(arg,...)\n");
#line 357
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -C : maximum cpp compatibility (includes -n, +c, +s, ...)\n");
#line 358
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -T : TeX-like    \\define{x}{y}         \\macro{arg}{...}\n");
#line 359
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -H : HTML-like   <#define x|y>         <#macro arg|...>\n");
#line 360
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -X : XHTML-like  <#define x|y/>        <#macro arg|.../>\n");
#line 361
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -P : prolog compatible cpp-like mode\n");
#line 362
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -U : user-defined syntax (specified in 9 following args; see manual)\n");
#line 363
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -M : user-defined syntax for meta-macros (specified in 7 following args)\n\n");
#line 364
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -o : output to outfile\n");
#line 365
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -O : output to outfile and stdout\n");
#line 366
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -z : line terminator is CR-LF (MS-DOS style)\n");
#line 367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -x : enable #exec built-in macro\n");
#line 368
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -m : enable automatic mode switching upon including .h/.c files\n");
#line 369
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -n : send LF characters serving as macro terminators to output\n");
#line 370
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" +c : use next 2 args as comment start and comment end sequences\n");
#line 371
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" +s : use next 3 args as string start, end and quote character\n\n");
#line 372
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Long options:\n");
#line 373
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --include file : process file before infile\n");
#line 374
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --nostdinc : don\'t search standard directories for files to include\n");
#line 375
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --nocurinc : don\'t search the current directory for files to include\n");
#line 376
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --curdirinclast : search the current directory last\n");
#line 377
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --warninglevel n : set warning level\n");
#line 378
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --includemarker formatstring : keep track of #include directives in output\n\n");
#line 379
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" --version : display version information and exit\n");
#line 380
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -h, --help : display this message and exit\n\n");
  }
#line 381
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int isdelim(unsigned char c ) 
{ 


  {
#line 385
  if ((int )c >= 128) {
#line 385
    return (0);
  }
#line 386
  if ((int )c >= 48) {
#line 386
    if ((int )c <= 57) {
#line 386
      return (0);
    }
  }
#line 387
  if ((int )c >= 65) {
#line 387
    if ((int )c <= 90) {
#line 387
      return (0);
    }
  }
#line 388
  if ((int )c >= 97) {
#line 388
    if ((int )c <= 122) {
#line 388
      return (0);
    }
  }
#line 389
  if ((int )c == 95) {
#line 389
    return (0);
  }
#line 390
  return (1);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int iswhite(char c ) 
{ 


  {
#line 395
  if ((int )c == 32) {
#line 395
    return (1);
  }
#line 396
  if ((int )c == 9) {
#line 396
    return (1);
  }
#line 397
  if ((int )c == 10) {
#line 397
    return (1);
  }
#line 398
  return (0);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void newmacro(char const   *s , int len , int hasspecs ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 403
  if (nmacros == nalloced) {
    {
#line 404
    nalloced = 2 * nalloced + 1;
#line 405
    tmp = realloc((void *)macros, (unsigned long )nalloced * sizeof(*macros));
#line 405
    macros = (struct MACRO *)tmp;
    }
#line 406
    if ((unsigned long )macros == (unsigned long )((void *)0)) {
      {
#line 407
      bug("Out of memory");
      }
    }
  }
  {
#line 409
  tmp___0 = malloc((size_t )(len + 1));
#line 409
  (macros + nmacros)->username = (char *)tmp___0;
#line 410
  strncpy((char */* __restrict  */)(macros + nmacros)->username, (char const   */* __restrict  */)s,
          (size_t )len);
#line 411
  *((macros + nmacros)->username + len) = (char)0;
#line 412
  (macros + nmacros)->argnames = (char **)((void *)0);
#line 413
  (macros + nmacros)->nnamedargs = 0;
#line 414
  (macros + nmacros)->defined_in_comment = 0;
  }
#line 415
  if (hasspecs) {
    {
#line 416
    (macros + nmacros)->define_specs = CloneSpecs((struct SPECS  const  *)S);
    }
  } else {
#line 418
    (macros + nmacros)->define_specs = (struct SPECS *)((void *)0);
  }
#line 419
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void lookupArgRefs(int n ) 
{ 
  int i ;
  int l ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 426
  if ((unsigned long )(macros + n)->argnames != (unsigned long )((void *)0)) {
#line 426
    return;
  }
  {
#line 427
  (macros + n)->nnamedargs = -1;
#line 428
  tmp = strlen((char const   *)S->User.mArgRef);
#line 428
  l = (int )tmp;
#line 429
  i = 0;
#line 429
  p = (macros + n)->macrotext;
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < (macros + n)->macrolen)) {
#line 429
      goto while_break;
    }
#line 430
    if ((int )*p != 0) {
#line 430
      if ((int )*p == (int )S->User.quotechar) {
#line 430
        i ++;
#line 430
        p ++;
      } else {
#line 430
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 431
      tmp___0 = strncmp((char const   *)p, (char const   *)S->User.mArgRef, (size_t )l);
      }
#line 431
      if (! tmp___0) {
#line 432
        if ((int )*(p + l) >= 49) {
#line 432
          if ((int )*(p + l) <= 57) {
#line 433
            (macros + n)->nnamedargs = 0;
#line 433
            return;
          }
        }
      }
    }
#line 429
    i ++;
#line 429
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *strnl0(char const   *s ) 
{ 
  char *t ;
  char *u ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 440
  tmp = strlen(s);
#line 440
  tmp___0 = malloc(tmp + 1UL);
#line 440
  t = (char *)tmp___0;
#line 441
  u = t;
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! ((int const   )*s != 0)) {
#line 442
      goto while_break;
    }
#line 443
    if ((int const   )*s == 92) {
#line 443
      if ((int const   )*(s + 1) == 110) {
#line 443
        *u = (char )'\n';
#line 443
        s ++;
      } else {
#line 444
        *u = (char )*s;
      }
    } else {
#line 444
      *u = (char )*s;
    }
#line 445
    s ++;
#line 445
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  *u = (char)0;
#line 448
  return (t);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *strnl(char const   *s ) 
{ 
  char *t ;
  char *u ;
  int neg ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 455
  tmp = strlen(s);
#line 455
  tmp___0 = malloc(tmp + 1UL);
#line 455
  t = (char *)tmp___0;
#line 456
  u = t;
#line 457
  tmp___1 = isdelim((unsigned char )*s);
  }
#line 457
  if (! tmp___1) {
    {
#line 457
    bug("character not allowed to start a syntax specifier");
    }
  }
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! ((int const   )*s != 0)) {
#line 458
      goto while_break;
    }
#line 459
    if (((int const   )*s & 96) == 0) {
#line 459
      if ((int const   )*s != 10) {
#line 459
        if ((int const   )*s != 9) {
          {
#line 460
          bug("character not allowed in syntax specifier");
          }
        }
      }
    }
#line 461
    if ((int const   )*s == 92) {
#line 462
      neg = (int const   )*(s + 1) == 33;
      {
#line 464
      if ((int const   )*(s + (neg + 1)) == 114) {
#line 464
        goto case_114;
      }
#line 464
      if ((int const   )*(s + (neg + 1)) == 110) {
#line 464
        goto case_114;
      }
#line 465
      if ((int const   )*(s + (neg + 1)) == 116) {
#line 465
        goto case_116;
      }
#line 466
      if ((int const   )*(s + (neg + 1)) == 98) {
#line 466
        goto case_98;
      }
#line 467
      if ((int const   )*(s + (neg + 1)) == 119) {
#line 467
        goto case_119;
      }
#line 469
      if ((int const   )*(s + (neg + 1)) == 66) {
#line 469
        goto case_66;
      }
#line 470
      if ((int const   )*(s + (neg + 1)) == 87) {
#line 470
        goto case_87;
      }
#line 472
      if ((int const   )*(s + (neg + 1)) == 97) {
#line 472
        goto case_97;
      }
#line 473
      if ((int const   )*(s + (neg + 1)) == 65) {
#line 473
        goto case_65;
      }
#line 474
      if ((int const   )*(s + (neg + 1)) == 35) {
#line 474
        goto case_35;
      }
#line 475
      if ((int const   )*(s + (neg + 1)) == 105) {
#line 475
        goto case_105;
      }
#line 476
      if ((int const   )*(s + (neg + 1)) == 111) {
#line 476
        goto case_111;
      }
#line 477
      if ((int const   )*(s + (neg + 1)) == 79) {
#line 477
        goto case_79;
      }
#line 478
      goto switch_default;
      case_114: /* CIL Label */ 
      case_110: /* CIL Label */ 
#line 464
      *u = (char )'\n';
#line 464
      goto switch_break;
      case_116: /* CIL Label */ 
#line 465
      *u = (char )'\t';
#line 465
      goto switch_break;
      case_98: /* CIL Label */ 
#line 466
      *u = (char )'\001';
#line 466
      goto switch_break;
      case_119: /* CIL Label */ 
#line 467
      if (neg) {
        {
#line 467
        bug("\\w and \\W cannot be negated");
        }
      }
#line 468
      *u = (char )'\002';
#line 468
      goto switch_break;
      case_66: /* CIL Label */ 
#line 469
      *u = (char )'\003';
#line 469
      goto switch_break;
      case_87: /* CIL Label */ 
#line 470
      if (neg) {
        {
#line 470
        bug("\\w and \\W cannot be negated");
        }
      }
#line 471
      *u = (char )'\004';
#line 471
      goto switch_break;
      case_97: /* CIL Label */ 
#line 472
      *u = (char )'\005';
#line 472
      goto switch_break;
      case_65: /* CIL Label */ 
#line 473
      *u = (char )'\006';
#line 473
      goto switch_break;
      case_35: /* CIL Label */ 
#line 474
      *u = (char )'\a';
#line 474
      goto switch_break;
      case_105: /* CIL Label */ 
#line 475
      *u = (char )'\b';
#line 475
      goto switch_break;
      case_111: /* CIL Label */ 
#line 476
      *u = (char )'\v';
#line 476
      goto switch_break;
      case_79: /* CIL Label */ 
#line 477
      *u = (char )'\f';
#line 477
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 478
      *u = (char )'\\';
#line 478
      neg = -1;
      switch_break: /* CIL Label */ ;
      }
#line 480
      if (neg > 0) {
#line 480
        *u = (char )((int )*u + -128);
      }
#line 481
      s += neg + 1;
    } else
#line 483
    if ((int const   )*s == 32) {
#line 483
      *u = (char )'\001';
    } else {
#line 484
      *u = (char )*s;
    }
#line 485
    s ++;
#line 485
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  *u = (char)0;
#line 488
  return (t);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *strnl2(char *s , int check_delim ) 
{ 
  char *u ;
  int neg ;
  int tmp ;

  {
#line 496
  u = s;
#line 497
  if (check_delim) {
    {
#line 497
    tmp = isdelim((unsigned char )*s);
    }
#line 497
    if (! tmp) {
      {
#line 498
      bug("character not allowed to start a syntax specifier");
      }
    }
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! ((int )*s != 34)) {
#line 499
      goto while_break;
    }
#line 500
    if (((int )*s & 96) == 0) {
#line 500
      if ((int )*s != 10) {
#line 500
        if ((int )*s != 9) {
          {
#line 501
          bug("character not allowed in syntax specifier");
          }
        }
      }
    }
#line 502
    if ((int )*s == 92) {
#line 503
      neg = (int )*(s + 1) == 33;
      {
#line 505
      if ((int )*(s + (neg + 1)) == 114) {
#line 505
        goto case_114;
      }
#line 505
      if ((int )*(s + (neg + 1)) == 110) {
#line 505
        goto case_114;
      }
#line 506
      if ((int )*(s + (neg + 1)) == 116) {
#line 506
        goto case_116;
      }
#line 507
      if ((int )*(s + (neg + 1)) == 98) {
#line 507
        goto case_98;
      }
#line 508
      if ((int )*(s + (neg + 1)) == 119) {
#line 508
        goto case_119;
      }
#line 510
      if ((int )*(s + (neg + 1)) == 66) {
#line 510
        goto case_66;
      }
#line 511
      if ((int )*(s + (neg + 1)) == 87) {
#line 511
        goto case_87;
      }
#line 513
      if ((int )*(s + (neg + 1)) == 97) {
#line 513
        goto case_97;
      }
#line 514
      if ((int )*(s + (neg + 1)) == 65) {
#line 514
        goto case_65;
      }
#line 515
      if ((int )*(s + (neg + 1)) == 35) {
#line 515
        goto case_35;
      }
#line 516
      if ((int )*(s + (neg + 1)) == 105) {
#line 516
        goto case_105;
      }
#line 517
      if ((int )*(s + (neg + 1)) == 111) {
#line 517
        goto case_111;
      }
#line 518
      if ((int )*(s + (neg + 1)) == 79) {
#line 518
        goto case_79;
      }
#line 519
      if ((int )*(s + (neg + 1)) == 92) {
#line 519
        goto case_92;
      }
#line 519
      if ((int )*(s + (neg + 1)) == 34) {
#line 519
        goto case_92;
      }
#line 520
      goto switch_default;
      case_114: /* CIL Label */ 
      case_110: /* CIL Label */ 
#line 505
      *u = (char )'\n';
#line 505
      goto switch_break;
      case_116: /* CIL Label */ 
#line 506
      *u = (char )'\t';
#line 506
      goto switch_break;
      case_98: /* CIL Label */ 
#line 507
      *u = (char )'\001';
#line 507
      goto switch_break;
      case_119: /* CIL Label */ 
#line 508
      if (neg) {
        {
#line 508
        bug("\\w and \\W cannot be negated");
        }
      }
#line 509
      *u = (char )'\002';
#line 509
      goto switch_break;
      case_66: /* CIL Label */ 
#line 510
      *u = (char )'\003';
#line 510
      goto switch_break;
      case_87: /* CIL Label */ 
#line 511
      if (neg) {
        {
#line 511
        bug("\\w and \\W cannot be negated");
        }
      }
#line 512
      *u = (char )'\004';
#line 512
      goto switch_break;
      case_97: /* CIL Label */ 
#line 513
      *u = (char )'\005';
#line 513
      goto switch_break;
      case_65: /* CIL Label */ 
#line 514
      *u = (char )'\006';
#line 514
      goto switch_break;
      case_35: /* CIL Label */ 
#line 515
      *u = (char )'\a';
#line 515
      goto switch_break;
      case_105: /* CIL Label */ 
#line 516
      *u = (char )'\b';
#line 516
      goto switch_break;
      case_111: /* CIL Label */ 
#line 517
      *u = (char )'\v';
#line 517
      goto switch_break;
      case_79: /* CIL Label */ 
#line 518
      *u = (char )'\f';
#line 518
      goto switch_break;
      case_92: /* CIL Label */ 
      case_34: /* CIL Label */ 
#line 519
      if (! neg) {
#line 519
        *u = *(s + 1);
#line 519
        goto switch_break;
      }
      switch_default: /* CIL Label */ 
      {
#line 520
      bug("unknown escape sequence in syntax specifier");
      }
      switch_break: /* CIL Label */ ;
      }
#line 522
      if (neg > 0) {
#line 522
        *u = (char )((int )*u + -128);
      }
#line 523
      s += neg + 1;
    } else
#line 525
    if ((int )*s == 32) {
#line 525
      *u = (char )'\001';
    } else {
#line 526
      *u = *s;
    }
#line 527
    if ((int )*s == 0) {
      {
#line 527
      bug("unterminated string in #mode command");
      }
    }
#line 528
    s ++;
#line 528
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  *u = (char)0;
#line 531
  return (s + 1);
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int iswhitesep(char const   *s ) 
{ 
  int tmp ;

  {
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 536
    tmp = iswhite((char )*s);
    }
#line 536
    if (! tmp) {
#line 536
      if (! ((int const   )*s == 1)) {
#line 536
        if (! ((int const   )*s == 2)) {
#line 536
          if (! ((int const   )*s == 3)) {
#line 536
            if (! ((int const   )*s == 4)) {
#line 536
              goto while_break;
            }
          }
        }
      }
    }
#line 537
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  return ((int const   )*s == 0);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int nowhite_strcmp(char *s , char *t ) 
{ 
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 545
    tmp = iswhite(*s);
    }
#line 545
    if (! tmp) {
#line 545
      goto while_break;
    }
#line 545
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 546
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 546
    tmp___0 = iswhite(*t);
    }
#line 546
    if (! tmp___0) {
#line 546
      goto while_break___0;
    }
#line 546
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 547
  if ((int )*s == 0) {
    {
#line 547
    tmp___1 = strcmp((char const   *)s, (char const   *)t);
    }
#line 547
    return (tmp___1);
  } else
#line 547
  if ((int )*t == 0) {
    {
#line 547
    tmp___1 = strcmp((char const   *)s, (char const   *)t);
    }
#line 547
    return (tmp___1);
  }
  {
#line 548
  tmp___2 = strlen((char const   *)s);
#line 548
  p = (s + tmp___2) - 1;
  }
  {
#line 549
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 549
    tmp___4 = iswhite(*p);
    }
#line 549
    if (! tmp___4) {
#line 549
      goto while_break___1;
    }
#line 549
    tmp___3 = p;
#line 549
    p --;
#line 549
    *tmp___3 = (char)0;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 550
  tmp___5 = strlen((char const   *)t);
#line 550
  p = (t + tmp___5) - 1;
  }
  {
#line 551
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 551
    tmp___7 = iswhite(*p);
    }
#line 551
    if (! tmp___7) {
#line 551
      goto while_break___2;
    }
#line 551
    tmp___6 = p;
#line 551
    p --;
#line 551
    *tmp___6 = (char)0;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 552
  tmp___8 = strcmp((char const   *)s, (char const   *)t);
  }
#line 552
  return (tmp___8);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void parseCmdlineDefine(char const   *s ) 
{ 
  int l ;
  int i ;
  int argc ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 559
  l = 0;
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (*(s + l)) {
#line 559
      if ((int const   )*(s + l) != 61) {
#line 559
        if (! ((int const   )*(s + l) != 40)) {
#line 559
          goto while_break;
        }
      } else {
#line 559
        goto while_break;
      }
    } else {
#line 559
      goto while_break;
    }
#line 559
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  i = findIdent(s, l);
  }
#line 561
  if (i >= 0) {
    {
#line 561
    delete_macro(i);
    }
  }
  {
#line 562
  newmacro(s, l, 0);
  }
#line 565
  if ((int const   )*(s + l) == 40) {
#line 566
    argc = 0;
    {
#line 567
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      l ++;
#line 568
      i = l;
      {
#line 569
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 569
        tmp = isdelim((unsigned char )*(s + i));
        }
#line 569
        if (tmp) {
#line 569
          goto while_break___1;
        }
#line 569
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 570
      if ((int const   )*(s + i) != 44) {
#line 570
        if ((int const   )*(s + i) != 41) {
          {
#line 570
          bug("invalid syntax in -D declaration");
          }
        }
      }
#line 571
      if (i > l) {
#line 571
        argc ++;
      }
      {
#line 572
      tmp___0 = realloc((void *)(macros + nmacros)->argnames, (unsigned long )(argc + 1) * sizeof(char *));
#line 572
      (macros + nmacros)->argnames = (char **)tmp___0;
      }
#line 574
      if (i > l) {
        {
#line 575
        tmp___1 = malloc((size_t )((i - l) + 1));
#line 575
        *((macros + nmacros)->argnames + (argc - 1)) = (char *)tmp___1;
#line 576
        memcpy((void */* __restrict  */)*((macros + nmacros)->argnames + (argc - 1)),
               (void const   */* __restrict  */)(s + l), (size_t )(i - l));
#line 577
        *(*((macros + nmacros)->argnames + (argc - 1)) + (i - l)) = (char)0;
        }
      }
#line 579
      l = i;
#line 567
      if (! ((int const   )*(s + l) != 41)) {
#line 567
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 581
    l ++;
#line 582
    (macros + nmacros)->nnamedargs = argc;
#line 583
    *((macros + nmacros)->argnames + argc) = (char *)((void *)0);
  }
#line 587
  if ((int const   )*(s + l) == 61) {
#line 587
    l ++;
  } else
#line 588
  if ((int const   )*(s + l) != 0) {
    {
#line 588
    bug("invalid syntax in -D declaration");
    }
  }
  {
#line 589
  tmp___2 = strlen(s + l);
#line 589
  (macros + nmacros)->macrolen = (int )tmp___2;
#line 590
  tmp___3 = nmacros;
#line 590
  nmacros ++;
#line 590
  (macros + tmp___3)->macrotext = strdup(s + l);
  }
#line 591
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int readModeDescription(char **args , struct MODE *mode , int ismeta ) 
{ 


  {
#line 595
  args ++;
#line 595
  if (! *args) {
#line 595
    return (0);
  }
  {
#line 596
  mode->mStart = strnl((char const   *)*args);
#line 597
  args ++;
  }
#line 597
  if (! *args) {
#line 597
    return (0);
  }
  {
#line 598
  mode->mEnd = strnl((char const   *)*args);
#line 599
  args ++;
  }
#line 599
  if (! *args) {
#line 599
    return (0);
  }
  {
#line 600
  mode->mArgS = strnl((char const   *)*args);
#line 601
  args ++;
  }
#line 601
  if (! *args) {
#line 601
    return (0);
  }
  {
#line 602
  mode->mArgSep = strnl((char const   *)*args);
#line 603
  args ++;
  }
#line 603
  if (! *args) {
#line 603
    return (0);
  }
  {
#line 604
  mode->mArgE = strnl((char const   *)*args);
#line 605
  args ++;
  }
#line 605
  if (! *args) {
#line 605
    return (0);
  }
  {
#line 606
  mode->stackchar = strnl((char const   *)*args);
#line 607
  args ++;
  }
#line 607
  if (! *args) {
#line 607
    return (0);
  }
  {
#line 608
  mode->unstackchar = strnl((char const   *)*args);
  }
#line 609
  if (ismeta) {
#line 609
    return (1);
  }
#line 610
  args ++;
#line 610
  if (! *args) {
#line 610
    return (0);
  }
  {
#line 611
  mode->mArgRef = strnl((char const   *)*args);
#line 612
  args ++;
  }
#line 612
  if (! *args) {
#line 612
    return (0);
  }
#line 613
  mode->quotechar = *(*args);
#line 614
  return (1);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int parse_comment_specif(char c ) 
{ 


  {
  {
#line 620
  if ((int )c == 105) {
#line 620
    goto case_105;
  }
#line 620
  if ((int )c == 73) {
#line 620
    goto case_105;
  }
#line 621
  if ((int )c == 99) {
#line 621
    goto case_99;
  }
#line 622
  if ((int )c == 115) {
#line 622
    goto case_115;
  }
#line 623
  if ((int )c == 113) {
#line 623
    goto case_113;
  }
#line 624
  if ((int )c == 83) {
#line 624
    goto case_83;
  }
#line 625
  if ((int )c == 81) {
#line 625
    goto case_81;
  }
#line 626
  if ((int )c == 67) {
#line 626
    goto case_67;
  }
#line 627
  goto switch_default;
  case_105: /* CIL Label */ 
  case_73: /* CIL Label */ 
#line 620
  return (64);
  case_99: /* CIL Label */ 
#line 621
  return (0);
  case_115: /* CIL Label */ 
#line 622
  return (3);
  case_113: /* CIL Label */ 
#line 623
  return (1);
  case_83: /* CIL Label */ 
#line 624
  return (7);
  case_81: /* CIL Label */ 
#line 625
  return (5);
  case_67: /* CIL Label */ 
#line 626
  return (4);
  switch_default: /* CIL Label */ 
  {
#line 627
  bug("Invalid comment/string modifier");
  }
#line 627
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void add_comment(struct SPECS *S___0 , char const   *specif , char *start , char *end ,
                 char quote , char warn ) 
{ 
  struct COMMENT *p ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 635
  if ((int )*start == 0) {
    {
#line 635
    bug("Comment/string start delimiter must be non-empty");
    }
  }
#line 636
  p = S___0->comments;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 636
      goto while_break;
    }
    {
#line 637
    tmp___0 = strcmp((char const   *)p->start, (char const   *)start);
    }
#line 637
    if (! tmp___0) {
      {
#line 638
      tmp = strcmp((char const   *)p->end, (char const   *)end);
      }
#line 638
      if (tmp) {
        {
#line 639
        bug("Conflicting comment/string delimiter specifications");
        }
      }
      {
#line 640
      free((void *)p->start);
#line 641
      free((void *)p->end);
      }
#line 642
      goto while_break;
    }
#line 636
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 646
    tmp___1 = malloc(sizeof(*p));
#line 646
    p = (struct COMMENT *)tmp___1;
#line 647
    p->next = S___0->comments;
#line 648
    S___0->comments = p;
    }
  }
  {
#line 650
  p->start = start;
#line 651
  p->end = end;
#line 652
  p->quote = quote;
#line 653
  p->warn = warn;
#line 654
  tmp___2 = strlen(specif);
  }
#line 654
  if (tmp___2 != 3UL) {
    {
#line 654
    bug("Invalid comment/string modifier");
    }
  }
  {
#line 655
  p->flags[0] = parse_comment_specif((char )*(specif + 0));
#line 656
  p->flags[1] = parse_comment_specif((char )*(specif + 1));
#line 657
  p->flags[2] = parse_comment_specif((char )*(specif + 2));
  }
#line 658
  return;
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void delete_comment(struct SPECS *S___0 , char *start ) 
{ 
  struct COMMENT *p ;
  struct COMMENT *q ;
  int tmp ;

  {
#line 664
  q = (struct COMMENT *)((void *)0);
#line 665
  p = S___0->comments;
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 665
      goto while_break;
    }
    {
#line 666
    tmp = strcmp((char const   *)p->start, (char const   *)start);
    }
#line 666
    if (tmp) {
#line 675
      q = p;
    } else {
#line 667
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 667
        S___0->comments = p->next;
      } else {
#line 668
        q->next = p->next;
      }
      {
#line 669
      free((void *)p->start);
#line 670
      free((void *)p->end);
#line 671
      free((void *)p);
#line 672
      free((void *)start);
      }
#line 673
      return;
    }
#line 665
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  free((void *)start);
  }
#line 678
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void outchar(char c ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 682
  if ((C->out)->bufsize) {
#line 683
    if ((C->out)->len + 1 == (C->out)->bufsize) {
      {
#line 684
      (C->out)->bufsize *= 2;
#line 685
      tmp = realloc((void *)(C->out)->buf, (size_t )(C->out)->bufsize);
#line 685
      (C->out)->buf = (char *)tmp;
      }
#line 686
      if ((unsigned long )(C->out)->buf == (unsigned long )((void *)0)) {
        {
#line 686
        bug("Out of memory");
        }
      }
    }
#line 688
    tmp___0 = (C->out)->len;
#line 688
    ((C->out)->len) ++;
#line 688
    *((C->out)->buf + tmp___0) = c;
  } else {
#line 691
    if (dosmode) {
#line 691
      if ((int )c == 10) {
        {
#line 692
        fputc(13, (C->out)->f);
        }
#line 693
        if (file_and_stdout) {
          {
#line 694
          fputc(13, stdout);
          }
        }
      }
    }
#line 696
    if ((int )c != 13) {
      {
#line 697
      fputc((int )c, (C->out)->f);
      }
#line 698
      if (file_and_stdout) {
        {
#line 699
        fputc((int )c, stdout);
        }
      }
    }
  }
#line 702
  return;
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void sendout(char const   *s , int l , int proc ) 
{ 
  int i ;

  {
#line 708
  if (! commented[iflevel]) {
#line 709
    i = 0;
    {
#line 709
    while (1) {
      while_continue: /* CIL Label */ ;
#line 709
      if (! (i < l)) {
#line 709
        goto while_break;
      }
#line 710
      if (proc) {
#line 710
        if ((int const   )*(s + i) != 0) {
#line 710
          if ((int const   )*(s + i) == (int const   )S->User.quotechar) {
#line 711
            i ++;
#line 711
            if (i == l) {
#line 711
              return;
            }
          }
        }
      }
#line 712
      if ((int const   )*(s + i) != 0) {
        {
#line 712
        outchar((char )*(s + i));
        }
      }
#line 709
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 715
    replace_definition_with_blank_lines(s, (s + l) - 1, 0);
    }
  }
#line 716
  return;
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void extendBuf(int pos ) 
{ 
  char *p ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 721
  if (C->bufsize <= pos) {
    {
#line 722
    C->bufsize += pos;
#line 723
    tmp = malloc((size_t )C->bufsize);
#line 723
    p = (char *)tmp;
#line 724
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)C->buf, (size_t )C->len);
#line 725
    free((void *)C->malloced_buf);
#line 726
    tmp___0 = p;
#line 726
    C->buf = tmp___0;
#line 726
    C->malloced_buf = tmp___0;
    }
#line 727
    if ((unsigned long )C->buf == (unsigned long )((void *)0)) {
      {
#line 727
      bug("Out of memory");
      }
    }
  }
#line 729
  return;
}
}
#line 733
char getChar(int pos ) ;
#line 733 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
static int lastchar  =    -666;
#line 731 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char getChar(int pos ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 736
  if (lastchar == -666) {
    {
#line 736
    tmp = strcmp((char const   *)S->Meta.mEnd, "\n");
    }
#line 736
    if (! tmp) {
#line 736
      lastchar = '\n';
    }
  }
#line 738
  if ((unsigned long )C->in == (unsigned long )((void *)0)) {
#line 739
    if (pos >= C->len) {
#line 739
      return ((char)0);
    } else {
#line 740
      return (*(C->buf + pos));
    }
  }
  {
#line 742
  extendBuf(pos);
  }
  {
#line 743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 743
    if (! (pos >= C->len)) {
#line 743
      goto while_break;
    }
    {
#line 744
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 744
      c = fgetc(C->in);
      }
#line 744
      if (! (c == 13)) {
#line 744
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 745
    if (lastchar == 10) {
#line 745
      (C->lineno) ++;
    }
#line 746
    lastchar = c;
#line 747
    if (c == -1) {
#line 747
      c = 0;
    }
#line 748
    tmp___0 = C->len;
#line 748
    (C->len) ++;
#line 748
    *(C->buf + tmp___0) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  return (*(C->buf + pos));
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int whiteout(int *pos1 , int *pos2 ) 
{ 
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (*pos1 < *pos2) {
      {
#line 755
      tmp = getChar(*pos1);
#line 755
      tmp___0 = iswhite(tmp);
      }
#line 755
      if (! tmp___0) {
#line 755
        goto while_break;
      }
    } else {
#line 755
      goto while_break;
    }
#line 755
    (*pos1) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 756
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 756
    if (*pos1 < *pos2) {
      {
#line 756
      tmp___1 = getChar(*pos2 - 1);
#line 756
      tmp___2 = iswhite(tmp___1);
      }
#line 756
      if (! tmp___2) {
#line 756
        goto while_break___0;
      }
    } else {
#line 756
      goto while_break___0;
    }
#line 756
    (*pos2) --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 757
  return (*pos1 < *pos2);
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int identifierEnd(int start ) 
{ 
  char c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 764
  c = getChar(start);
  }
#line 765
  if ((int )c == 0) {
#line 765
    return (start);
  }
#line 766
  if ((int )c == (int )S->User.quotechar) {
    {
#line 767
    c = getChar(start + 1);
    }
#line 768
    if ((int )c == 0) {
#line 768
      return (start + 1);
    }
    {
#line 769
    tmp = isdelim((unsigned char )c);
    }
#line 769
    if (tmp) {
#line 769
      return (start + 2);
    }
    {
#line 770
    start += 2;
#line 771
    c = getChar(start);
    }
  }
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 773
    tmp___0 = isdelim((unsigned char )c);
    }
#line 773
    if (tmp___0) {
#line 773
      goto while_break;
    }
    {
#line 773
    start ++;
#line 773
    c = getChar(start);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 774
  return (start);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int iterIdentifierEnd(int start ) 
{ 
  int x ;

  {
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 781
    x = identifierEnd(start);
    }
#line 782
    if (x == start) {
#line 782
      return (x);
    }
#line 783
    start = x;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int IsInCharset(CHARSET_SUBSET x , int c ) 
{ 


  {
#line 789
  return ((*(x + (c >> 5)) & (unsigned long )(1L << (c & ((1 << 5) - 1)))) != 0UL);
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int matchSequence(char const   *s , int *pos ) 
{ 
  int i ;
  int match ;
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char tmp___16 ;

  {
#line 794
  i = *pos;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! ((int const   )*s != 0)) {
#line 798
      goto while_break;
    }
#line 799
    if (! ((int const   )*s & 96)) {
#line 800
      match = 1;
      {
#line 802
      if (((int const   )*s & 31) == 1) {
#line 802
        goto case_1;
      }
#line 806
      if (((int const   )*s & 31) == 2) {
#line 806
        goto case_2;
      }
#line 810
      if (((int const   )*s & 31) == 3) {
#line 810
        goto case_3;
      }
#line 814
      if (((int const   )*s & 31) == 4) {
#line 814
        goto case_4;
      }
#line 818
      if (((int const   )*s & 31) == 6) {
#line 818
        goto case_6;
      }
#line 823
      if (((int const   )*s & 31) == 5) {
#line 823
        goto case_5;
      }
#line 826
      if (((int const   )*s & 31) == 7) {
#line 826
        goto case_7;
      }
#line 829
      if (((int const   )*s & 31) == 8) {
#line 829
        goto case_8;
      }
#line 832
      if (((int const   )*s & 31) == 9) {
#line 832
        goto case_9;
      }
#line 835
      if (((int const   )*s & 31) == 10) {
#line 835
        goto case_10;
      }
#line 838
      if (((int const   )*s & 31) == 11) {
#line 838
        goto case_11;
      }
#line 841
      if (((int const   )*s & 31) == 12) {
#line 841
        goto case_12;
      }
#line 801
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 803
      tmp = i;
#line 803
      i ++;
#line 803
      c = getChar(tmp);
      }
#line 804
      if ((int )c != 32) {
#line 804
        if ((int )c != 9) {
#line 805
          match = 0;
#line 805
          goto switch_break;
        }
      }
      case_2: /* CIL Label */ 
#line 807
      i --;
      {
#line 808
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 808
        i ++;
#line 808
        c = getChar(i);
        }
#line 808
        if (! ((int )c == 32)) {
#line 808
          if (! ((int )c == 9)) {
#line 808
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 809
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 811
      tmp___0 = i;
#line 811
      i ++;
#line 811
      c = getChar(tmp___0);
      }
#line 812
      if ((int )c != 32) {
#line 812
        if ((int )c != 9) {
#line 812
          if ((int )c != 10) {
#line 813
            match = 0;
#line 813
            goto switch_break;
          }
        }
      }
      case_4: /* CIL Label */ 
#line 815
      i --;
      {
#line 816
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 816
        i ++;
#line 816
        c = getChar(i);
        }
#line 816
        if (! ((int )c == 32)) {
#line 816
          if (! ((int )c == 9)) {
#line 816
            if (! ((int )c == 10)) {
#line 816
              goto while_break___1;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 817
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 819
      tmp___1 = i;
#line 819
      i ++;
#line 819
      c = getChar(tmp___1);
      }
#line 820
      if ((int )c >= 97) {
#line 820
        if ((int )c <= 122) {
#line 820
          tmp___2 = 1;
        } else {
#line 820
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 820
      if ((int )c >= 65) {
#line 820
        if ((int )c <= 90) {
#line 820
          tmp___2 = 1;
        } else {
#line 820
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 820
      if ((int )c == 32) {
#line 820
        tmp___2 = 1;
      } else
#line 820
      if ((int )c == 9) {
#line 820
        tmp___2 = 1;
      } else
#line 820
      if ((int )c == 10) {
#line 820
        tmp___2 = 1;
      } else {
#line 820
        tmp___2 = 0;
      }
#line 820
      match = tmp___2;
#line 822
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 824
      tmp___3 = i;
#line 824
      i ++;
#line 824
      c = getChar(tmp___3);
      }
#line 825
      if ((int )c >= 97) {
#line 825
        if ((int )c <= 122) {
#line 825
          tmp___4 = 1;
        } else {
#line 825
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 825
      if ((int )c >= 65) {
#line 825
        if ((int )c <= 90) {
#line 825
          tmp___4 = 1;
        } else {
#line 825
          tmp___4 = 0;
        }
      } else {
#line 825
        tmp___4 = 0;
      }
#line 825
      match = tmp___4;
#line 825
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 827
      tmp___5 = i;
#line 827
      i ++;
#line 827
      c = getChar(tmp___5);
      }
#line 828
      if ((int )c >= 48) {
#line 828
        if ((int )c <= 57) {
#line 828
          tmp___6 = 1;
        } else {
#line 828
          tmp___6 = 0;
        }
      } else {
#line 828
        tmp___6 = 0;
      }
#line 828
      match = tmp___6;
#line 828
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 830
      tmp___7 = i;
#line 830
      i ++;
#line 830
      c = getChar(tmp___7);
#line 831
      match = IsInCharset(S->id_set, (int )c);
      }
#line 831
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 833
      tmp___8 = i;
#line 833
      i ++;
#line 833
      c = getChar(tmp___8);
#line 834
      match = (int )c == 9;
      }
#line 834
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 836
      tmp___9 = i;
#line 836
      i ++;
#line 836
      c = getChar(tmp___9);
#line 837
      match = (int )c == 10;
      }
#line 837
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 839
      tmp___10 = i;
#line 839
      i ++;
#line 839
      c = getChar(tmp___10);
#line 840
      match = IsInCharset(S->op_set, (int )c);
      }
#line 840
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 842
      tmp___11 = i;
#line 842
      i ++;
#line 842
      c = getChar(tmp___11);
#line 843
      tmp___12 = IsInCharset(S->ext_op_set, (int )c);
      }
#line 843
      if (tmp___12) {
#line 843
        tmp___14 = 1;
      } else {
        {
#line 843
        tmp___13 = IsInCharset(S->op_set, (int )c);
        }
#line 843
        if (tmp___13) {
#line 843
          tmp___14 = 1;
        } else {
#line 843
          tmp___14 = 0;
        }
      }
#line 843
      match = tmp___14;
#line 844
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 846
      if ((int const   )*s & 128) {
#line 846
        match = ! match;
      }
#line 847
      if (! match) {
#line 847
        return (0);
      }
    } else {
      {
#line 849
      tmp___15 = i;
#line 849
      i ++;
#line 849
      tmp___16 = getChar(tmp___15);
      }
#line 849
      if ((int )tmp___16 != (int )*s) {
#line 849
        return (0);
      }
    }
#line 850
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  *pos = i;
#line 853
  return (1);
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int matchEndSequence(char const   *s , int *pos ) 
{ 
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 858
  if ((int const   )*s == 0) {
#line 858
    return (1);
  }
  {
#line 860
  tmp = getChar(*pos);
  }
#line 860
  if ((int )tmp == 0) {
#line 860
    if ((int const   )*(s + 0) == 10) {
#line 860
      if ((int const   )*(s + 1) == 0) {
#line 860
        return (1);
      }
    }
  }
  {
#line 861
  tmp___0 = matchSequence(s, pos);
  }
#line 861
  if (! tmp___0) {
#line 861
    return (0);
  }
#line 862
  if (S->preservelf) {
    {
#line 862
    tmp___1 = getChar(*pos - 1);
#line 862
    tmp___2 = iswhite(tmp___1);
    }
#line 862
    if (tmp___2) {
#line 862
      (*pos) --;
    }
  }
#line 863
  return (1);
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int matchStartSequence(char const   *s , int *pos ) 
{ 
  char c ;
  int match ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 871
  if (! ((int const   )*s & 96)) {
    {
#line 872
    c = getChar(*pos - 1);
#line 873
    match = 1;
    }
#line 874
    if ((int const   )*s == 0) {
#line 874
      return (1);
    }
    {
#line 876
    if (((int const   )*s & 31) == 1) {
#line 876
      goto case_1;
    }
#line 881
    if (((int const   )*s & 31) == 2) {
#line 881
      goto case_2;
    }
#line 883
    if (((int const   )*s & 31) == 3) {
#line 883
      goto case_3;
    }
#line 888
    if (((int const   )*s & 31) == 4) {
#line 888
      goto case_4;
    }
#line 890
    if (((int const   )*s & 31) == 6) {
#line 890
      goto case_6;
    }
#line 893
    if (((int const   )*s & 31) == 5) {
#line 893
      goto case_5;
    }
#line 896
    if (((int const   )*s & 31) == 7) {
#line 896
      goto case_7;
    }
#line 899
    if (((int const   )*s & 31) == 8) {
#line 899
      goto case_8;
    }
#line 902
    if (((int const   )*s & 31) == 9) {
#line 902
      goto case_9;
    }
#line 905
    if (((int const   )*s & 31) == 10) {
#line 905
      goto case_10;
    }
#line 908
    if (((int const   )*s & 31) == 11) {
#line 908
      goto case_11;
    }
#line 911
    if (((int const   )*s & 31) == 12) {
#line 911
      goto case_12;
    }
#line 875
    goto switch_break;
    case_1: /* CIL Label */ 
#line 877
    if ((int )c != 32) {
#line 877
      if ((int )c != 9) {
#line 878
        match = 0;
#line 879
        goto switch_break;
      }
    }
    case_2: /* CIL Label */ 
#line 882
    goto switch_break;
    case_3: /* CIL Label */ 
#line 884
    if ((int )c != 32) {
#line 884
      if ((int )c != 9) {
#line 884
        if ((int )c != 10) {
#line 885
          match = 0;
#line 886
          goto switch_break;
        }
      }
    }
    case_4: /* CIL Label */ 
#line 889
    goto switch_break;
    case_6: /* CIL Label */ 
#line 891
    if ((int )c == 32) {
#line 892
      goto switch_break;
    } else
#line 891
    if ((int )c == 9) {
#line 892
      goto switch_break;
    } else
#line 891
    if ((int )c == 10) {
#line 892
      goto switch_break;
    }
    case_5: /* CIL Label */ 
#line 894
    if ((int )c >= 97) {
#line 894
      if ((int )c <= 122) {
#line 894
        tmp = 1;
      } else {
#line 894
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 894
    if ((int )c >= 65) {
#line 894
      if ((int )c <= 90) {
#line 894
        tmp = 1;
      } else {
#line 894
        tmp = 0;
      }
    } else {
#line 894
      tmp = 0;
    }
#line 894
    match = tmp;
#line 895
    goto switch_break;
    case_7: /* CIL Label */ 
#line 897
    if ((int )c >= 48) {
#line 897
      if ((int )c <= 57) {
#line 897
        tmp___0 = 1;
      } else {
#line 897
        tmp___0 = 0;
      }
    } else {
#line 897
      tmp___0 = 0;
    }
#line 897
    match = tmp___0;
#line 898
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 900
    match = IsInCharset(S->id_set, (int )c);
    }
#line 901
    goto switch_break;
    case_9: /* CIL Label */ 
#line 903
    match = (int )c == 9;
#line 904
    goto switch_break;
    case_10: /* CIL Label */ 
#line 906
    match = (int )c == 10;
#line 907
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 909
    match = IsInCharset(S->op_set, (int )c);
    }
#line 910
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 912
    tmp___1 = IsInCharset(S->ext_op_set, (int )c);
    }
#line 912
    if (tmp___1) {
#line 912
      tmp___3 = 1;
    } else {
      {
#line 912
      tmp___2 = IsInCharset(S->op_set, (int )c);
      }
#line 912
      if (tmp___2) {
#line 912
        tmp___3 = 1;
      } else {
#line 912
        tmp___3 = 0;
      }
    }
#line 912
    match = tmp___3;
#line 913
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 915
    if ((int const   )*s & 128) {
#line 915
      match = ! match;
    }
#line 916
    if (! match) {
#line 916
      return (0);
    }
#line 917
    s ++;
  }
  {
#line 919
  tmp___4 = matchSequence(s, pos);
  }
#line 919
  return (tmp___4);
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void AddToCharset(CHARSET_SUBSET x , int c ) 
{ 


  {
#line 924
  *(x + (c >> 5)) |= (unsigned long )(1L << (c & ((1 << 5) - 1)));
#line 925
  return;
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
CHARSET_SUBSET MakeCharsetSubset(unsigned char *s ) 
{ 
  CHARSET_SUBSET x ;
  int i ;
  unsigned char c ;
  void *tmp ;

  {
  {
#line 933
  tmp = malloc((unsigned long )(256 >> 5) * sizeof(unsigned long ));
#line 933
  x = (CHARSET_SUBSET )tmp;
#line 934
  i = 0;
  }
  {
#line 934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 934
    if (! (i < 256 >> 5)) {
#line 934
      goto while_break;
    }
#line 934
    *(x + i) = 0UL;
#line 934
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 935
    if (! ((int )*s != 0)) {
#line 935
      goto while_break___0;
    }
#line 936
    if (! ((int )*s & 96)) {
#line 937
      if ((int )*s & 128) {
        {
#line 937
        bug("negated special sequences not allowed in charset specifications");
        }
      }
      {
#line 943
      if (((int )*s & 31) == 12) {
#line 943
        goto case_12;
      }
#line 943
      if (((int )*s & 31) == 11) {
#line 943
        goto case_12;
      }
#line 943
      if (((int )*s & 31) == 8) {
#line 943
        goto case_12;
      }
#line 943
      if (((int )*s & 31) == 4) {
#line 943
        goto case_12;
      }
#line 943
      if (((int )*s & 31) == 2) {
#line 943
        goto case_12;
      }
#line 945
      if (((int )*s & 31) == 3) {
#line 945
        goto case_3;
      }
#line 947
      if (((int )*s & 31) == 1) {
#line 947
        goto case_1;
      }
#line 949
      if (((int )*s & 31) == 9) {
#line 949
        goto case_9;
      }
#line 952
      if (((int )*s & 31) == 6) {
#line 952
        goto case_6;
      }
#line 956
      if (((int )*s & 31) == 5) {
#line 956
        goto case_5;
      }
#line 960
      if (((int )*s & 31) == 7) {
#line 960
        goto case_7;
      }
#line 963
      if (((int )*s & 31) == 10) {
#line 963
        goto case_10;
      }
#line 938
      goto switch_break;
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 944
      bug("special sequence not allowed in charset specification");
      }
      case_3: /* CIL Label */ 
      {
#line 946
      AddToCharset(x, '\n');
      }
      case_1: /* CIL Label */ 
      {
#line 948
      AddToCharset(x, ' ');
      }
      case_9: /* CIL Label */ 
      {
#line 950
      AddToCharset(x, '\t');
      }
#line 951
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 953
      AddToCharset(x, '\n');
#line 954
      AddToCharset(x, ' ');
#line 955
      AddToCharset(x, '\t');
      }
      case_5: /* CIL Label */ 
#line 957
      c = (unsigned char )'A';
      {
#line 957
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 957
        if (! ((int )c <= 90)) {
#line 957
          goto while_break___1;
        }
        {
#line 957
        AddToCharset(x, (int )c);
#line 957
        c = (unsigned char )((int )c + 1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 958
      c = (unsigned char )'a';
      {
#line 958
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 958
        if (! ((int )c <= 122)) {
#line 958
          goto while_break___2;
        }
        {
#line 958
        AddToCharset(x, (int )c);
#line 958
        c = (unsigned char )((int )c + 1);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 959
      goto switch_break;
      case_7: /* CIL Label */ 
#line 961
      c = (unsigned char )'0';
      {
#line 961
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 961
        if (! ((int )c <= 57)) {
#line 961
          goto while_break___3;
        }
        {
#line 961
        AddToCharset(x, (int )c);
#line 961
        c = (unsigned char )((int )c + 1);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 962
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 964
      AddToCharset(x, '\n');
      }
#line 965
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 968
    if ((int )*(s + 1) == 45) {
#line 968
      if (((int )*(s + 2) & 96) != 0) {
#line 968
        if ((int )*(s + 2) >= (int )*s) {
#line 969
          c = *s;
          {
#line 969
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 969
            if (! ((int )c <= (int )*(s + 2))) {
#line 969
              goto while_break___4;
            }
            {
#line 969
            AddToCharset(x, (int )c);
#line 969
            c = (unsigned char )((int )c + 1);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 970
          s += 2;
        } else {
          {
#line 972
          AddToCharset(x, (int )*s);
          }
        }
      } else {
        {
#line 972
        AddToCharset(x, (int )*s);
        }
      }
    } else {
      {
#line 972
      AddToCharset(x, (int )*s);
      }
    }
#line 973
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 975
  return (x);
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int idequal(char const   *b , int l , char const   *s ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 983
  tmp = strlen(s);
  }
#line 983
  if ((int )tmp != l) {
#line 983
    return (0);
  }
#line 984
  i = 0;
  {
#line 984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 984
    if (! (i < l)) {
#line 984
      goto while_break;
    }
#line 984
    if ((int const   )*(b + i) != (int const   )*(s + i)) {
#line 984
      return (0);
    }
#line 984
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 985
  return (1);
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int findIdent(char const   *b , int l ) 
{ 
  int i ;
  int tmp ;

  {
#line 992
  i = 0;
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 992
    if (! (i < nmacros)) {
#line 992
      goto while_break;
    }
    {
#line 993
    tmp = idequal(b, l, (char const   *)(macros + i)->username);
    }
#line 993
    if (tmp) {
#line 993
      return (i);
    }
#line 992
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 994
  return (-1);
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int findNamedArg(char const   *b , int l ) 
{ 
  char *s ;
  int i ;
  int tmp ;

  {
#line 1002
  i = 0;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    s = *(C->namedargs + i);
#line 1004
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1004
      return (-1);
    }
    {
#line 1005
    tmp = idequal(b, l, (char const   *)s);
    }
#line 1005
    if (tmp) {
#line 1005
      return (i);
    }
#line 1002
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void shiftIn(int l ) 
{ 
  int i ;

  {
#line 1013
  if (l <= 1) {
#line 1013
    return;
  }
#line 1014
  l --;
#line 1015
  if (l >= C->len) {
#line 1015
    C->len = 0;
  } else {
#line 1017
    if (C->len - l > 100) {
#line 1018
      C->buf += l;
#line 1018
      C->bufsize -= l;
    } else {
#line 1020
      i = l;
      {
#line 1020
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1020
        if (! (i < C->len)) {
#line 1020
          goto while_break;
        }
#line 1020
        *(C->buf + (i - l)) = *(C->buf + i);
#line 1020
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1021
    C->len -= l;
#line 1022
    C->eof = (int )*(C->buf + 0) == 0;
  }
#line 1024
  if (C->len <= 1) {
#line 1025
    if ((unsigned long )C->in == (unsigned long )((void *)0)) {
#line 1025
      C->eof = 1;
    } else {
      {
#line 1026
      C->eof = feof(C->in);
      }
    }
  }
#line 1028
  return;
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void initthings(int argc , char **argv ) 
{ 
  char **arg ;
  char *s ;
  int i ;
  int isinput ;
  int isoutput ;
  int ishelp ;
  int ismode ;
  int hasmeta ;
  int usrmode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  struct MODE tmp___47 ;
  struct MODE tmp___48 ;
  struct MODE tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;

  {
  {
#line 1035
  DefaultOp = MakeCharsetSubset((unsigned char *)"+-*/\\^<>=`~:.?@#&!%|");
#line 1036
  PrologOp = MakeCharsetSubset((unsigned char *)"+-*/\\^<>=`~:.?@#&");
#line 1037
  DefaultExtOp = MakeCharsetSubset((unsigned char *)"()[]{}");
#line 1038
  DefaultId = MakeCharsetSubset((unsigned char *)"\005\a_");
#line 1040
  nmacros = 0;
#line 1041
  nalloced = 31;
#line 1042
  tmp = malloc((unsigned long )nalloced * sizeof(*macros));
#line 1042
  macros = (struct MACRO *)tmp;
#line 1044
  tmp___0 = malloc(sizeof(*S));
#line 1044
  S = (struct SPECS *)tmp___0;
#line 1045
  S->User = CUser;
#line 1046
  S->Meta = CMeta;
#line 1047
  S->comments = (struct COMMENT *)((void *)0);
#line 1048
  S->stack_next = (struct SPECS *)((void *)0);
#line 1049
  S->preservelf = 0;
#line 1050
  S->op_set = DefaultOp;
#line 1051
  S->ext_op_set = DefaultExtOp;
#line 1052
  S->id_set = DefaultId;
#line 1054
  tmp___1 = malloc(sizeof(*C));
#line 1054
  C = (struct INPUTCONTEXT *)tmp___1;
#line 1055
  C->in = stdin;
#line 1056
  C->argc = 0;
#line 1057
  C->argv = (char **)((void *)0);
#line 1058
  C->filename = strdup("stdin");
#line 1059
  tmp___2 = malloc(sizeof(*(C->out)));
#line 1059
  C->out = (struct OUTPUTCONTEXT *)tmp___2;
#line 1060
  (C->out)->f = stdout;
#line 1061
  (C->out)->bufsize = 0;
#line 1062
  C->lineno = 1;
#line 1063
  usrmode = 0;
#line 1063
  hasmeta = usrmode;
#line 1063
  ishelp = hasmeta;
#line 1063
  ismode = ishelp;
#line 1063
  isoutput = ismode;
#line 1063
  isinput = isoutput;
#line 1064
  nincludedirs = 0;
#line 1065
  C->bufsize = 80;
#line 1066
  C->len = 0;
#line 1067
  tmp___4 = malloc((size_t )C->bufsize);
#line 1067
  tmp___3 = (char *)tmp___4;
#line 1067
  C->malloced_buf = tmp___3;
#line 1067
  C->buf = tmp___3;
#line 1068
  C->eof = 0;
#line 1069
  C->namedargs = (char **)((void *)0);
#line 1070
  C->in_comment = 0;
#line 1071
  C->ambience = 2;
#line 1072
  C->may_have_args = 0;
#line 1073
  commented[0] = 0;
#line 1074
  iflevel = 0;
#line 1075
  execallowed = 0;
#line 1076
  autoswitch = 0;
#line 1077
  dosmode = 0;
#line 1079
  arg = argv + 1;
  }
  {
#line 1079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1079
    if (! *arg) {
#line 1079
      goto while_break;
    }
    {
#line 1080
    tmp___5 = strcmp((char const   *)*arg, "--help");
    }
#line 1080
    if (tmp___5 == 0) {
      {
#line 1081
      usage();
#line 1082
      exit(0);
      }
    } else {
      {
#line 1080
      tmp___6 = strcmp((char const   *)*arg, "-h");
      }
#line 1080
      if (tmp___6 == 0) {
        {
#line 1081
        usage();
#line 1082
        exit(0);
        }
      }
    }
    {
#line 1084
    tmp___7 = strcmp((char const   *)*arg, "--version");
    }
#line 1084
    if (tmp___7 == 0) {
      {
#line 1085
      display_version();
#line 1086
      exit(0);
      }
    }
    {
#line 1089
    tmp___8 = strcmp((char const   *)*arg, "-nostdinc");
    }
#line 1089
    if (tmp___8 == 0) {
      {
#line 1090
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpp: warning: deprecated option `%s\'; use `-%s\' instead\n",
              *arg, *arg);
#line 1091
      NoStdInc = 1;
      }
#line 1092
      goto __Cont;
    }
    {
#line 1094
    tmp___9 = strcmp((char const   *)*arg, "-nocurinc");
    }
#line 1094
    if (tmp___9 == 0) {
      {
#line 1095
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpp: warning: deprecated option `%s\'; use `-%s\' instead\n",
              *arg, *arg);
#line 1096
      NoCurIncFirst = 1;
      }
#line 1097
      goto __Cont;
    }
    {
#line 1099
    tmp___10 = strcmp((char const   *)*arg, "-curdirinclast");
    }
#line 1099
    if (tmp___10 == 0) {
      {
#line 1100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpp: warning: deprecated option `%s\'; use `-%s\' instead\n",
              *arg, *arg);
#line 1101
      CurDirIncLast = 1;
#line 1102
      NoCurIncFirst = 1;
      }
#line 1103
      goto __Cont;
    }
    {
#line 1105
    tmp___11 = strcmp((char const   *)*arg, "-includemarker");
    }
#line 1105
    if (tmp___11 == 0) {
      {
#line 1106
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpp: warning: deprecated option `%s\'; use `-%s\' instead\n",
              *arg, *arg);
#line 1107
      arg ++;
      }
#line 1107
      if (! *arg) {
        {
#line 1108
        usage();
#line 1109
        exit(1);
        }
      }
      {
#line 1111
      construct_include_directive_marker(& include_directive_marker, (char const   *)*arg);
      }
#line 1112
      goto __Cont;
    }
    {
#line 1114
    tmp___12 = strcmp((char const   *)*arg, "--include");
    }
#line 1114
    if (tmp___12 == 0) {
#line 1115
      arg ++;
#line 1115
      if (! *arg) {
        {
#line 1116
        usage();
#line 1117
        exit(1);
        }
      }
#line 1119
      IncludeFile = *arg;
#line 1120
      goto __Cont;
    }
    {
#line 1122
    tmp___14 = strcmp((char const   *)*arg, "-warninglevel");
    }
#line 1122
    if (tmp___14 == 0) {
      {
#line 1123
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gpp: warning: deprecated option `%s\'; use `-%s\' instead\n",
              *arg, *arg);
#line 1124
      arg ++;
      }
#line 1124
      if (! *arg) {
        {
#line 1124
        usage();
#line 1124
        exit(1);
        }
      }
      {
#line 1125
      tmp___13 = atoi((char const   *)*arg);
#line 1125
      WarningLevel = (short )tmp___13;
      }
#line 1126
      goto __Cont;
    }
    {
#line 1128
    tmp___15 = strcmp((char const   *)*arg, "--nostdinc");
    }
#line 1128
    if (tmp___15 == 0) {
#line 1129
      NoStdInc = 1;
#line 1130
      goto __Cont;
    }
    {
#line 1132
    tmp___16 = strcmp((char const   *)*arg, "--nocurinc");
    }
#line 1132
    if (tmp___16 == 0) {
#line 1133
      NoCurIncFirst = 1;
#line 1134
      goto __Cont;
    }
    {
#line 1136
    tmp___17 = strcmp((char const   *)*arg, "--curdirinclast");
    }
#line 1136
    if (tmp___17 == 0) {
#line 1137
      CurDirIncLast = 1;
#line 1138
      NoCurIncFirst = 1;
#line 1139
      goto __Cont;
    }
    {
#line 1141
    tmp___18 = strcmp((char const   *)*arg, "--includemarker");
    }
#line 1141
    if (tmp___18 == 0) {
#line 1142
      arg ++;
#line 1142
      if (! *arg) {
        {
#line 1143
        usage();
#line 1144
        exit(1);
        }
      }
      {
#line 1146
      construct_include_directive_marker(& include_directive_marker, (char const   *)*arg);
      }
#line 1147
      goto __Cont;
    }
    {
#line 1149
    tmp___20 = strcmp((char const   *)*arg, "--warninglevel");
    }
#line 1149
    if (tmp___20 == 0) {
#line 1150
      arg ++;
#line 1150
      if (! *arg) {
        {
#line 1150
        usage();
#line 1150
        exit(1);
        }
      }
      {
#line 1151
      tmp___19 = atoi((char const   *)*arg);
#line 1151
      WarningLevel = (short )tmp___19;
      }
#line 1152
      goto __Cont;
    }
#line 1155
    if ((int )*(*arg) == 43) {
      {
#line 1157
      if ((int )*(*arg + 1) == 99) {
#line 1157
        goto case_99;
      }
#line 1164
      if ((int )*(*arg + 1) == 115) {
#line 1164
        goto case_115;
      }
#line 1172
      if ((int )*(*arg + 1) == 122) {
#line 1172
        goto case_122;
      }
#line 1175
      if ((int )*(*arg + 1) == 110) {
#line 1175
        goto case_110;
      }
#line 1178
      goto switch_default;
      case_99: /* CIL Label */ 
#line 1158
      s = *arg + 2;
#line 1159
      if ((int )*s == 0) {
#line 1159
        s = (char *)"ccc";
      }
#line 1160
      arg ++;
#line 1160
      if (! *arg) {
        {
#line 1160
        usage();
#line 1160
        exit(1);
        }
      }
#line 1161
      arg ++;
#line 1161
      if (! *arg) {
        {
#line 1161
        usage();
#line 1161
        exit(1);
        }
      }
      {
#line 1162
      tmp___21 = strnl((char const   *)*arg);
#line 1162
      tmp___22 = strnl((char const   *)*(arg - 1));
#line 1162
      add_comment(S, (char const   *)s, tmp___22, tmp___21, (char)0, (char)0);
      }
#line 1163
      goto switch_break;
      case_115: /* CIL Label */ 
#line 1165
      s = *arg + 2;
#line 1166
      if ((int )*s == 0) {
#line 1166
        s = (char *)"sss";
      }
#line 1167
      arg ++;
#line 1167
      if (! *arg) {
        {
#line 1167
        usage();
#line 1167
        exit(1);
        }
      }
#line 1168
      arg ++;
#line 1168
      if (! *arg) {
        {
#line 1168
        usage();
#line 1168
        exit(1);
        }
      }
#line 1169
      arg ++;
#line 1169
      if (! *arg) {
        {
#line 1169
        usage();
#line 1169
        exit(1);
        }
      }
      {
#line 1170
      tmp___23 = strnl((char const   *)*(arg - 1));
#line 1170
      tmp___24 = strnl((char const   *)*(arg - 2));
#line 1170
      add_comment(S, (char const   *)s, tmp___24, tmp___23, *(*arg), (char)0);
      }
#line 1171
      goto switch_break;
      case_122: /* CIL Label */ 
#line 1173
      dosmode = 0;
#line 1174
      goto switch_break;
      case_110: /* CIL Label */ 
#line 1176
      S->preservelf = 0;
#line 1177
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1178
      ishelp = 1;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 1181
    if ((int )*(*arg) != 45) {
      {
#line 1182
      ishelp |= isinput;
#line 1182
      isinput = 1;
#line 1183
      C->in = fopen((char const   */* __restrict  */)*arg, (char const   */* __restrict  */)"r");
#line 1184
      free((void *)C->filename);
#line 1184
      C->filename = strdup((char const   *)*arg);
      }
#line 1185
      if ((unsigned long )C->in == (unsigned long )((void *)0)) {
        {
#line 1185
        bug("Cannot open input file");
        }
      }
    } else {
      {
#line 1188
      if ((int )*(*arg + 1) == 73) {
#line 1188
        goto case_73;
      }
#line 1197
      if ((int )*(*arg + 1) == 67) {
#line 1197
        goto case_67;
      }
#line 1207
      if ((int )*(*arg + 1) == 80) {
#line 1207
        goto case_80;
      }
#line 1218
      if ((int )*(*arg + 1) == 84) {
#line 1218
        goto case_84;
      }
#line 1222
      if ((int )*(*arg + 1) == 72) {
#line 1222
        goto case_72;
      }
#line 1226
      if ((int )*(*arg + 1) == 88) {
#line 1226
        goto case_88;
      }
#line 1230
      if ((int )*(*arg + 1) == 85) {
#line 1230
        goto case_85;
      }
#line 1237
      if ((int )*(*arg + 1) == 77) {
#line 1237
        goto case_77;
      }
#line 1243
      if ((int )*(*arg + 1) == 79) {
#line 1243
        goto case_79;
      }
#line 1245
      if ((int )*(*arg + 1) == 111) {
#line 1245
        goto case_111;
      }
#line 1252
      if ((int )*(*arg + 1) == 68) {
#line 1252
        goto case_68;
      }
#line 1260
      if ((int )*(*arg + 1) == 120) {
#line 1260
        goto case_120;
      }
#line 1263
      if ((int )*(*arg + 1) == 110) {
#line 1263
        goto case_110___0;
      }
#line 1266
      if ((int )*(*arg + 1) == 122) {
#line 1266
        goto case_122___0;
      }
#line 1270
      if ((int )*(*arg + 1) == 115) {
#line 1270
        goto case_115___0;
      }
#line 1270
      if ((int )*(*arg + 1) == 99) {
#line 1270
        goto case_115___0;
      }
#line 1275
      if ((int )*(*arg + 1) == 109) {
#line 1275
        goto case_109;
      }
#line 1277
      goto switch_default___0;
      case_73: /* CIL Label */ 
#line 1189
      if (nincludedirs == 10) {
        {
#line 1190
        bug("too many include directories");
        }
      }
#line 1191
      if ((int )*(*arg + 2) == 0) {
#line 1192
        arg ++;
#line 1192
        if (! *arg) {
          {
#line 1192
          usage();
#line 1192
          exit(1);
          }
        }
        {
#line 1193
        tmp___25 = nincludedirs;
#line 1193
        nincludedirs ++;
#line 1193
        includedir[tmp___25] = strdup((char const   *)*arg);
        }
      } else {
        {
#line 1195
        tmp___26 = nincludedirs;
#line 1195
        nincludedirs ++;
#line 1195
        includedir[tmp___26] = strdup((char const   *)(*arg + 2));
        }
      }
#line 1196
      goto switch_break___0;
      case_67: /* CIL Label */ 
      {
#line 1198
      ishelp |= (ismode | hasmeta) | usrmode;
#line 1198
      ismode = 1;
#line 1199
      S->User = KUser;
#line 1199
      S->Meta = KMeta;
#line 1200
      S->preservelf = 1;
#line 1201
      tmp___27 = strdup("*/");
#line 1201
      tmp___28 = strdup("/*");
#line 1201
      add_comment(S, "ccc", tmp___28, tmp___27, (char)0, (char)0);
#line 1202
      tmp___29 = strdup("\n");
#line 1202
      tmp___30 = strdup("//");
#line 1202
      add_comment(S, "ccc", tmp___30, tmp___29, (char)0, (char)0);
#line 1203
      tmp___31 = strdup("");
#line 1203
      tmp___32 = strdup("\\\n");
#line 1203
      add_comment(S, "ccc", tmp___32, tmp___31, (char)0, (char)0);
#line 1204
      tmp___33 = strdup("\"");
#line 1204
      tmp___34 = strdup("\"");
#line 1204
      add_comment(S, "sss", tmp___34, tmp___33, (char )'\\', (char )'\n');
#line 1205
      tmp___35 = strdup("\'");
#line 1205
      tmp___36 = strdup("\'");
#line 1205
      add_comment(S, "sss", tmp___36, tmp___35, (char )'\\', (char )'\n');
      }
#line 1206
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 1208
      ishelp |= (ismode | hasmeta) | usrmode;
#line 1208
      ismode = 1;
#line 1209
      S->User = KUser;
#line 1209
      S->Meta = KMeta;
#line 1210
      S->preservelf = 1;
#line 1211
      S->op_set = PrologOp;
#line 1212
      tmp___37 = strdup("*/");
#line 1212
      tmp___38 = strdup("\213/*");
#line 1212
      add_comment(S, "css", tmp___38, tmp___37, (char)0, (char)0);
#line 1213
      tmp___39 = strdup("");
#line 1213
      tmp___40 = strdup("\\\n");
#line 1213
      add_comment(S, "cii", tmp___40, tmp___39, (char)0, (char)0);
#line 1214
      tmp___41 = strdup("\n");
#line 1214
      tmp___42 = strdup("%");
#line 1214
      add_comment(S, "css", tmp___42, tmp___41, (char)0, (char)0);
#line 1215
      tmp___43 = strdup("\"");
#line 1215
      tmp___44 = strdup("\"");
#line 1215
      add_comment(S, "sss", tmp___44, tmp___43, (char)0, (char )'\n');
#line 1216
      tmp___45 = strdup("\'");
#line 1216
      tmp___46 = strdup("\207\'");
#line 1216
      add_comment(S, "sss", tmp___46, tmp___45, (char)0, (char )'\n');
      }
#line 1217
      goto switch_break___0;
      case_84: /* CIL Label */ 
#line 1219
      ishelp |= (ismode | hasmeta) | usrmode;
#line 1219
      ismode = 1;
#line 1220
      tmp___47 = Tex;
#line 1220
      S->Meta = tmp___47;
#line 1220
      S->User = tmp___47;
#line 1221
      goto switch_break___0;
      case_72: /* CIL Label */ 
#line 1223
      ishelp |= (ismode | hasmeta) | usrmode;
#line 1223
      ismode = 1;
#line 1224
      tmp___48 = Html;
#line 1224
      S->Meta = tmp___48;
#line 1224
      S->User = tmp___48;
#line 1225
      goto switch_break___0;
      case_88: /* CIL Label */ 
#line 1227
      ishelp |= (ismode | hasmeta) | usrmode;
#line 1227
      ismode = 1;
#line 1228
      tmp___49 = XHtml;
#line 1228
      S->Meta = tmp___49;
#line 1228
      S->User = tmp___49;
#line 1229
      goto switch_break___0;
      case_85: /* CIL Label */ 
      {
#line 1231
      ishelp |= ismode | usrmode;
#line 1231
      usrmode = 1;
#line 1232
      tmp___50 = readModeDescription(arg, & S->User, 0);
      }
#line 1232
      if (! tmp___50) {
        {
#line 1233
        usage();
#line 1233
        exit(1);
        }
      }
#line 1234
      arg += 9;
#line 1235
      if (! hasmeta) {
#line 1235
        S->Meta = S->User;
      }
#line 1236
      goto switch_break___0;
      case_77: /* CIL Label */ 
      {
#line 1238
      ishelp |= ismode | hasmeta;
#line 1238
      hasmeta = 1;
#line 1239
      tmp___51 = readModeDescription(arg, & S->Meta, 1);
      }
#line 1239
      if (! tmp___51) {
        {
#line 1240
        usage();
#line 1240
        exit(1);
        }
      }
#line 1241
      arg += 7;
#line 1242
      goto switch_break___0;
      case_79: /* CIL Label */ 
#line 1244
      file_and_stdout = 1;
      case_111: /* CIL Label */ 
#line 1246
      arg ++;
#line 1246
      if (! *arg) {
        {
#line 1247
        usage();
#line 1247
        exit(1);
        }
      }
      {
#line 1248
      ishelp |= isoutput;
#line 1248
      isoutput = 1;
#line 1249
      (C->out)->f = fopen((char const   */* __restrict  */)*arg, (char const   */* __restrict  */)"w");
      }
#line 1250
      if ((unsigned long )(C->out)->f == (unsigned long )((void *)0)) {
        {
#line 1250
        bug("Cannot create output file");
        }
      }
#line 1251
      goto switch_break___0;
      case_68: /* CIL Label */ 
#line 1253
      if ((int )*(*arg + 2) == 0) {
#line 1254
        arg ++;
#line 1254
        if (! *arg) {
          {
#line 1255
          usage();
#line 1255
          exit(1);
          }
        }
        {
#line 1256
        s = strnl0((char const   *)*arg);
        }
      } else {
        {
#line 1258
        s = strnl0((char const   *)(*arg + 2));
        }
      }
      {
#line 1259
      parseCmdlineDefine((char const   *)s);
#line 1259
      free((void *)s);
      }
#line 1259
      goto switch_break___0;
      case_120: /* CIL Label */ 
#line 1261
      execallowed = 1;
#line 1262
      goto switch_break___0;
      case_110___0: /* CIL Label */ 
#line 1264
      S->preservelf = 1;
#line 1265
      goto switch_break___0;
      case_122___0: /* CIL Label */ 
#line 1267
      dosmode = 1;
#line 1268
      goto switch_break___0;
      case_115___0: /* CIL Label */ 
      case_99___0: /* CIL Label */ 
#line 1271
      arg ++;
#line 1271
      if (! *arg) {
        {
#line 1272
        usage();
#line 1272
        exit(1);
        }
      }
      {
#line 1273
      tmp___52 = strnl((char const   *)*arg);
#line 1273
      delete_comment(S, tmp___52);
      }
#line 1274
      goto switch_break___0;
      case_109: /* CIL Label */ 
#line 1276
      autoswitch = 1;
#line 1276
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1278
      ishelp = 1;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1280
    if (hasmeta) {
#line 1280
      if (! usrmode) {
        {
#line 1280
        usage();
#line 1280
        exit(1);
        }
      }
    }
#line 1281
    if (ishelp) {
      {
#line 1281
      usage();
#line 1281
      exit(1);
      }
    }
    __Cont: /* CIL Label */ 
#line 1079
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1285
  if (nincludedirs == 0) {
#line 1285
    if (! NoStdInc) {
      {
#line 1286
      includedir[0] = strdup("/usr/include");
#line 1287
      nincludedirs = 1;
      }
    }
  }
#line 1291
  i = 0;
  {
#line 1291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1291
    if (! (i < nmacros)) {
#line 1291
      goto while_break___0;
    }
#line 1292
    if ((unsigned long )(macros + i)->define_specs == (unsigned long )((void *)0)) {
      {
#line 1293
      (macros + i)->define_specs = CloneSpecs((struct SPECS  const  *)S);
      }
    }
    {
#line 1294
    lookupArgRefs(i);
#line 1291
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1296
  return;
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int findCommentEnd(char const   *endseq , char quote , char warn , int pos , int flags ) 
{ 
  int i ;
  char c ;
  int tmp ;

  {
  {
#line 1303
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1304
    c = getChar(pos);
#line 1305
    i = pos;
#line 1306
    tmp = matchEndSequence(endseq, & i);
    }
#line 1306
    if (tmp) {
#line 1306
      return (pos);
    }
#line 1307
    if ((int )c == 0) {
      {
#line 1307
      bug("Input ended while scanning a comment/string");
      }
    }
#line 1308
    if ((int )c == (int )warn) {
#line 1309
      warn = (char)0;
#line 1310
      if ((int )WarningLevel > 1) {
        {
#line 1311
        warning("possible comment/string termination problem");
        }
      }
    }
#line 1313
    if ((int )c == (int )quote) {
#line 1313
      pos += 2;
    } else
#line 1314
    if (flags & 4) {
#line 1314
      if ((int )c == (int )S->User.quotechar) {
#line 1314
        pos += 2;
      } else {
#line 1315
        pos ++;
      }
    } else {
#line 1315
      pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1319 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void SkipPossibleComments(int *pos , int cmtmode , int silentonly ) 
{ 
  int found ;
  struct COMMENT *c ;
  char tmp ;
  int tmp___0 ;

  {
#line 1324
  if (C->in_comment) {
#line 1324
    return;
  }
  {
#line 1325
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1326
    found = 0;
#line 1327
    tmp = getChar(*pos);
    }
#line 1327
    if ((int )tmp == 0) {
#line 1327
      return;
    }
#line 1328
    c = S->comments;
    {
#line 1328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1328
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1328
        goto while_break___0;
      }
#line 1329
      if (! (c->flags[cmtmode] & 64)) {
#line 1330
        if (! silentonly) {
#line 1330
          goto _L;
        } else
#line 1330
        if (c->flags[cmtmode] == 0) {
          _L: /* CIL Label */ 
          {
#line 1331
          tmp___0 = matchStartSequence((char const   *)c->start, pos);
          }
#line 1331
          if (tmp___0) {
            {
#line 1332
            *pos = findCommentEnd((char const   *)c->end, c->quote, c->warn, *pos,
                                  c->flags[cmtmode]);
#line 1333
            matchEndSequence((char const   *)c->end, pos);
#line 1334
            found = 1;
            }
#line 1335
            goto while_break___0;
          }
        }
      }
#line 1328
      c = c->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1325
    if (! found) {
#line 1325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  return;
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int SplicePossibleUser(int *idstart , int *idend , int *sh_end , int *lg_end , int *argb ,
                       int *arge , int *argc , int idcheck , int *id , int cmtmode ) 
{ 
  int match ;
  int k ;
  int pos ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char *tmp___4 ;
  char tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1357
  tmp = matchStartSequence((char const   *)S->User.mStart, idstart);
  }
#line 1357
  if (! tmp) {
#line 1357
    return (0);
  }
  {
#line 1358
  *idend = identifierEnd(*idstart);
  }
#line 1359
  if (*idend) {
    {
#line 1359
    tmp___0 = getChar(*idend - 1);
    }
#line 1359
    if (! tmp___0) {
#line 1359
      return (0);
    }
  }
  {
#line 1362
  *sh_end = *idend;
#line 1363
  tmp___1 = matchEndSequence((char const   *)S->User.mEnd, sh_end);
  }
#line 1363
  if (! tmp___1) {
#line 1363
    *sh_end = -1;
  }
  {
#line 1364
  pos = *idend;
#line 1365
  match = matchSequence((char const   *)S->User.mArgS, & pos);
  }
#line 1367
  if (idcheck) {
    {
#line 1368
    *id = findIdent((char const   *)(C->buf + *idstart), *idend - *idstart);
    }
#line 1369
    if (*id < 0) {
#line 1369
      match = 0;
    }
  }
#line 1371
  *lg_end = -1;
#line 1373
  if (match) {
#line 1374
    *argc = 0;
    {
#line 1375
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1376
      if (*argc >= 100) {
        {
#line 1376
        bug("too many macro parameters");
        }
      }
#line 1377
      *(argb + *argc) = pos;
#line 1378
      k = 0;
      {
#line 1379
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1380
        pos = iterIdentifierEnd(pos);
#line 1381
        SkipPossibleComments(& pos, cmtmode, 0);
#line 1382
        tmp___2 = getChar(pos);
        }
#line 1382
        if ((int )tmp___2 == 0) {
#line 1382
          return (*sh_end >= 0);
        }
        {
#line 1383
        tmp___3 = getChar(pos);
#line 1383
        tmp___4 = strchr((char const   *)S->User.stackchar, (int )tmp___3);
        }
#line 1383
        if (tmp___4) {
#line 1383
          k ++;
        }
#line 1384
        if (k) {
          {
#line 1384
          tmp___5 = getChar(pos);
#line 1384
          tmp___6 = strchr((char const   *)S->User.unstackchar, (int )tmp___5);
          }
#line 1384
          if (tmp___6) {
#line 1384
            k --;
          }
        } else {
          {
#line 1386
          *(arge + *argc) = pos;
#line 1387
          tmp___7 = matchSequence((char const   *)S->User.mArgSep, & pos);
          }
#line 1387
          if (tmp___7) {
#line 1387
            match = 0;
#line 1387
            goto while_break___0;
          }
          {
#line 1388
          tmp___8 = matchEndSequence((char const   *)S->User.mArgE, & pos);
          }
#line 1388
          if (tmp___8) {
#line 1389
            match = 1;
#line 1389
            goto while_break___0;
          }
        }
#line 1391
        pos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1393
      (*argc) ++;
#line 1394
      if (match) {
#line 1395
        *lg_end = pos;
#line 1396
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1400
  if (*lg_end >= 0) {
#line 1400
    tmp___9 = 1;
  } else
#line 1400
  if (*sh_end >= 0) {
#line 1400
    tmp___9 = 1;
  } else {
#line 1400
    tmp___9 = 0;
  }
#line 1400
  return (tmp___9);
}
}
#line 1403 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int findMetaArgs(int start , int *p1b , int *p1e , int *p2b , int *p2e , int *endm ,
                 int *argc , int *argb , int *arge ) 
{ 
  int pos ;
  int k ;
  int hyp_end1 ;
  int hyp_end2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  char tmp___6 ;
  char tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char tmp___11 ;
  int tmp___12 ;
  char tmp___13 ;
  char tmp___14 ;
  char *tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char tmp___20 ;

  {
  {
#line 1409
  pos = start;
#line 1410
  tmp___0 = matchSequence((char const   *)S->Meta.mArgS, & pos);
  }
#line 1410
  if (! tmp___0) {
    {
#line 1411
    tmp = matchEndSequence((char const   *)S->Meta.mEnd, & pos);
    }
#line 1411
    if (! tmp) {
#line 1411
      return (-1);
    }
#line 1412
    *endm = pos;
#line 1413
    return (0);
  }
#line 1415
  *p1b = pos;
#line 1418
  if (*argc) {
    {
#line 1418
    tmp___12 = SplicePossibleUser(& pos, p1e, & hyp_end1, & hyp_end2, argb, arge,
                                  argc, 0, (int *)((void *)0), 0);
    }
#line 1418
    if (tmp___12) {
#line 1420
      *p1b = pos;
#line 1421
      if (hyp_end2 >= 0) {
#line 1421
        pos = hyp_end2;
      } else {
#line 1421
        pos = hyp_end1;
#line 1421
        *argc = 0;
      }
      {
#line 1422
      tmp___2 = matchSequence((char const   *)S->Meta.mArgSep, & pos);
      }
#line 1422
      if (! tmp___2) {
        {
#line 1423
        tmp___1 = matchEndSequence((char const   *)S->Meta.mArgE, & pos);
        }
#line 1423
        if (! tmp___1) {
          {
#line 1424
          bug("#define/#defeval requires an identifier or a single macro call");
          }
        }
#line 1425
        *endm = pos;
#line 1426
        return (1);
      }
    } else {
#line 1418
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1429
    *argc = 0;
#line 1430
    k = 0;
    {
#line 1431
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1432
      pos = iterIdentifierEnd(pos);
#line 1433
      SkipPossibleComments(& pos, 0, 0);
#line 1434
      tmp___3 = getChar(pos);
      }
#line 1434
      if ((int )tmp___3 != 0) {
        {
#line 1434
        tmp___4 = getChar(pos);
#line 1434
        tmp___5 = strchr((char const   *)S->Meta.stackchar, (int )tmp___4);
        }
#line 1434
        if (tmp___5) {
#line 1434
          k ++;
        }
      }
#line 1435
      if (k) {
        {
#line 1436
        tmp___6 = getChar(pos);
        }
#line 1436
        if ((int )tmp___6 != 0) {
          {
#line 1436
          tmp___7 = getChar(pos);
#line 1436
          tmp___8 = strchr((char const   *)S->Meta.unstackchar, (int )tmp___7);
          }
#line 1436
          if (tmp___8) {
#line 1437
            k --;
          }
        }
      } else {
        {
#line 1439
        *p1e = pos;
#line 1440
        tmp___9 = matchSequence((char const   *)S->Meta.mArgSep, & pos);
        }
#line 1440
        if (tmp___9) {
#line 1440
          goto while_break;
        }
        {
#line 1441
        tmp___10 = matchEndSequence((char const   *)S->Meta.mArgE, & pos);
        }
#line 1441
        if (tmp___10) {
#line 1442
          *endm = pos;
#line 1443
          return (1);
        }
      }
      {
#line 1446
      tmp___11 = getChar(pos);
      }
#line 1446
      if ((int )tmp___11 == 0) {
        {
#line 1446
        bug("unfinished macro argument");
        }
      }
#line 1447
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1451
  *p2b = pos;
#line 1452
  k = 0;
  {
#line 1453
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1454
    pos = iterIdentifierEnd(pos);
#line 1455
    SkipPossibleComments(& pos, 0, 0);
#line 1456
    tmp___13 = getChar(pos);
    }
#line 1456
    if ((int )tmp___13 != 0) {
      {
#line 1456
      tmp___14 = getChar(pos);
#line 1456
      tmp___15 = strchr((char const   *)S->Meta.stackchar, (int )tmp___14);
      }
#line 1456
      if (tmp___15) {
#line 1456
        k ++;
      }
    }
#line 1457
    if (k) {
      {
#line 1458
      tmp___16 = getChar(pos);
      }
#line 1458
      if ((int )tmp___16 != 0) {
        {
#line 1458
        tmp___17 = getChar(pos);
#line 1458
        tmp___18 = strchr((char const   *)S->Meta.unstackchar, (int )tmp___17);
        }
#line 1458
        if (tmp___18) {
#line 1459
          k --;
        }
      }
    } else {
      {
#line 1461
      *p2e = pos;
#line 1462
      tmp___19 = matchEndSequence((char const   *)S->Meta.mArgE, & pos);
      }
#line 1462
      if (tmp___19) {
#line 1462
        goto while_break___0;
      }
    }
    {
#line 1464
    tmp___20 = getChar(pos);
    }
#line 1464
    if ((int )tmp___20 == 0) {
      {
#line 1464
      bug("unfinished macro");
      }
    }
#line 1465
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1467
  *endm = pos;
#line 1468
  return (2);
}
}
#line 1471 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *ProcessText(char const   *buf , int l , int ambience ) 
{ 
  char *s ;
  struct INPUTCONTEXT *T ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 1476
  if (l == 0) {
    {
#line 1476
    tmp = malloc((size_t )1);
#line 1476
    s = (char *)tmp;
#line 1476
    *(s + 0) = (char)0;
    }
#line 1476
    return (s);
  }
  {
#line 1477
  tmp___0 = malloc((size_t )(l + 2));
#line 1477
  s = (char *)tmp___0;
#line 1478
  *(s + 0) = (char )'\n';
#line 1479
  memcpy((void */* __restrict  */)(s + 1), (void const   */* __restrict  */)buf, (size_t )l);
#line 1480
  *(s + (l + 1)) = (char)0;
#line 1481
  T = C;
#line 1482
  tmp___1 = malloc(sizeof(*C));
#line 1482
  C = (struct INPUTCONTEXT *)tmp___1;
#line 1483
  tmp___2 = malloc(sizeof(*(C->out)));
#line 1483
  C->out = (struct OUTPUTCONTEXT *)tmp___2;
#line 1484
  C->in = (FILE *)((void *)0);
#line 1485
  C->argc = T->argc;
#line 1486
  C->argv = T->argv;
#line 1487
  C->filename = T->filename;
#line 1488
  tmp___3 = malloc((size_t )80);
#line 1488
  (C->out)->buf = (char *)tmp___3;
#line 1489
  (C->out)->len = 0;
#line 1490
  (C->out)->bufsize = 80;
#line 1491
  (C->out)->f = (FILE *)((void *)0);
#line 1492
  C->lineno = T->lineno;
#line 1493
  C->bufsize = l + 2;
#line 1494
  C->len = l + 1;
#line 1495
  tmp___4 = s;
#line 1495
  C->malloced_buf = tmp___4;
#line 1495
  C->buf = tmp___4;
#line 1496
  C->eof = 0;
#line 1497
  C->namedargs = T->namedargs;
#line 1498
  C->in_comment = T->in_comment;
#line 1499
  C->ambience = ambience;
#line 1500
  C->may_have_args = T->may_have_args;
#line 1502
  ProcessContext();
#line 1503
  outchar((char)0);
#line 1504
  s = (C->out)->buf;
#line 1505
  free((void *)C->out);
#line 1506
  free((void *)C);
#line 1507
  C = T;
  }
#line 1508
  return (s);
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int SpliceInfix(char const   *buf , int pos1 , int pos2 , char *sep , int *spl1 ,
                int *spl2 ) 
{ 
  int pos ;
  int numpar ;
  int l ;
  char const   *p ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1516
  numpar = 0;
#line 1516
  tmp = strlen((char const   *)sep);
#line 1516
  l = (int )tmp;
#line 1517
  pos = pos2 - 1;
#line 1517
  p = buf + pos;
  }
  {
#line 1517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1517
    if (! (pos >= pos1)) {
#line 1517
      goto while_break;
    }
#line 1518
    if ((int const   )*p == 41) {
#line 1518
      numpar ++;
    }
#line 1519
    if ((int const   )*p == 40) {
#line 1519
      numpar --;
    }
#line 1520
    if (numpar < 0) {
#line 1520
      return (0);
    }
#line 1521
    if (numpar == 0) {
#line 1521
      if (pos2 - pos >= l) {
        {
#line 1521
        tmp___0 = strncmp(p, (char const   *)sep, (size_t )l);
        }
#line 1521
        if (! tmp___0) {
#line 1522
          *spl1 = pos;
#line 1522
          *spl2 = pos + l;
#line 1522
          return (1);
        }
      }
    }
#line 1517
    pos --;
#line 1517
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1524
  return (0);
}
}
#line 1527 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int DoArithmEval(char *buf , int pos1 , int pos2 , int *result ) 
{ 
  int spl1 ;
  int spl2 ;
  int result1 ;
  int result2 ;
  int l ;
  char c ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *str1 ;
  char *str2 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  size_t tmp___78 ;
  size_t tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  long tmp___82 ;

  {
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (pos1 < pos2) {
      {
#line 1532
      tmp = iswhite(*(buf + pos1));
      }
#line 1532
      if (! tmp) {
#line 1532
        goto while_break;
      }
    } else {
#line 1532
      goto while_break;
    }
#line 1532
    pos1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1533
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1533
    if (pos1 < pos2) {
      {
#line 1533
      tmp___0 = iswhite(*(buf + (pos2 - 1)));
      }
#line 1533
      if (! tmp___0) {
#line 1533
        goto while_break___0;
      }
    } else {
#line 1533
      goto while_break___0;
    }
#line 1533
    pos2 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1534
  if (pos1 == pos2) {
#line 1534
    return (0);
  }
  {
#line 1538
  tmp___4 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"||", & spl1, & spl2);
  }
#line 1538
  if (tmp___4) {
    {
#line 1539
    tmp___1 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1539
    if (tmp___1) {
      {
#line 1539
      tmp___2 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1539
      if (! tmp___2) {
#line 1540
        return (0);
      }
    } else {
#line 1540
      return (0);
    }
#line 1541
    if (result1) {
#line 1541
      tmp___3 = 1;
    } else
#line 1541
    if (result2) {
#line 1541
      tmp___3 = 1;
    } else {
#line 1541
      tmp___3 = 0;
    }
#line 1541
    *result = tmp___3;
#line 1542
    return (1);
  }
  {
#line 1545
  tmp___8 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"&&", & spl1, & spl2);
  }
#line 1545
  if (tmp___8) {
    {
#line 1546
    tmp___5 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1546
    if (tmp___5) {
      {
#line 1546
      tmp___6 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1546
      if (! tmp___6) {
#line 1547
        return (0);
      }
    } else {
#line 1547
      return (0);
    }
#line 1548
    if (result1) {
#line 1548
      if (result2) {
#line 1548
        tmp___7 = 1;
      } else {
#line 1548
        tmp___7 = 0;
      }
    } else {
#line 1548
      tmp___7 = 0;
    }
#line 1548
    *result = tmp___7;
#line 1549
    return (1);
  }
  {
#line 1552
  tmp___11 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"|", & spl1, & spl2);
  }
#line 1552
  if (tmp___11) {
    {
#line 1553
    tmp___9 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1553
    if (tmp___9) {
      {
#line 1553
      tmp___10 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1553
      if (! tmp___10) {
#line 1554
        return (0);
      }
    } else {
#line 1554
      return (0);
    }
#line 1555
    *result = result1 | result2;
#line 1556
    return (1);
  }
  {
#line 1559
  tmp___14 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"^", & spl1, & spl2);
  }
#line 1559
  if (tmp___14) {
    {
#line 1560
    tmp___12 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1560
    if (tmp___12) {
      {
#line 1560
      tmp___13 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1560
      if (! tmp___13) {
#line 1561
        return (0);
      }
    } else {
#line 1561
      return (0);
    }
#line 1562
    *result = result1 ^ result2;
#line 1563
    return (1);
  }
  {
#line 1566
  tmp___17 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"&", & spl1, & spl2);
  }
#line 1566
  if (tmp___17) {
    {
#line 1567
    tmp___15 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1567
    if (tmp___15) {
      {
#line 1567
      tmp___16 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1567
      if (! tmp___16) {
#line 1568
        return (0);
      }
    } else {
#line 1568
      return (0);
    }
#line 1569
    *result = result1 & result2;
#line 1570
    return (1);
  }
  {
#line 1573
  tmp___23 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"!=", & spl1, & spl2);
  }
#line 1573
  if (tmp___23) {
    {
#line 1574
    tmp___21 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1574
    if (tmp___21) {
      {
#line 1574
      tmp___22 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1574
      if (tmp___22) {
#line 1582
        *result = result1 != result2;
      } else {
        _L: /* CIL Label */ 
        {
#line 1577
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1577
          if (pos1 < spl1) {
            {
#line 1577
            tmp___18 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1577
            if (! tmp___18) {
#line 1577
              goto while_break___1;
            }
          } else {
#line 1577
            goto while_break___1;
          }
#line 1577
          spl1 --;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1578
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1578
          if (pos2 > spl2) {
            {
#line 1578
            tmp___19 = iswhite(*(buf + spl2));
            }
#line 1578
            if (! tmp___19) {
#line 1578
              goto while_break___2;
            }
          } else {
#line 1578
            goto while_break___2;
          }
#line 1578
          spl2 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1579
        if (spl1 - pos1 != pos2 - spl2) {
#line 1579
          *result = 1;
        } else {
          {
#line 1580
          tmp___20 = strncmp((char const   *)(buf + pos1), (char const   *)(buf + spl2),
                             (size_t )(spl1 - pos1));
#line 1580
          *result = tmp___20 != 0;
          }
        }
      }
    } else {
#line 1574
      goto _L;
    }
#line 1583
    return (1);
  }
  {
#line 1586
  tmp___29 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"==", & spl1, & spl2);
  }
#line 1586
  if (tmp___29) {
    {
#line 1587
    tmp___27 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1587
    if (tmp___27) {
      {
#line 1587
      tmp___28 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1587
      if (tmp___28) {
#line 1595
        *result = result1 == result2;
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1590
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1590
          if (pos1 < spl1) {
            {
#line 1590
            tmp___24 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1590
            if (! tmp___24) {
#line 1590
              goto while_break___3;
            }
          } else {
#line 1590
            goto while_break___3;
          }
#line 1590
          spl1 --;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1591
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1591
          if (pos2 > spl2) {
            {
#line 1591
            tmp___25 = iswhite(*(buf + spl2));
            }
#line 1591
            if (! tmp___25) {
#line 1591
              goto while_break___4;
            }
          } else {
#line 1591
            goto while_break___4;
          }
#line 1591
          spl2 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1592
        if (spl1 - pos1 != pos2 - spl2) {
#line 1592
          *result = 0;
        } else {
          {
#line 1593
          tmp___26 = strncmp((char const   *)(buf + pos1), (char const   *)(buf + spl2),
                             (size_t )(spl1 - pos1));
#line 1593
          *result = tmp___26 == 0;
          }
        }
      }
    } else {
#line 1587
      goto _L___0;
    }
#line 1596
    return (1);
  }
  {
#line 1599
  tmp___35 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"=~", & spl1, & spl2);
  }
#line 1599
  if (tmp___35) {
    {
#line 1603
    tmp___33 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1603
    if (tmp___33) {
      {
#line 1603
      tmp___34 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1603
      if (tmp___34) {
#line 1618
        *result = result1 == result2;
      } else {
        _L___1: /* CIL Label */ 
        {
#line 1608
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1608
          if (pos1 < spl1) {
            {
#line 1608
            tmp___30 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1608
            if (! tmp___30) {
#line 1608
              goto while_break___5;
            }
          } else {
#line 1608
            goto while_break___5;
          }
#line 1608
          spl1 --;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1609
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1609
          if (pos2 > spl2) {
            {
#line 1609
            tmp___31 = iswhite(*(buf + spl2));
            }
#line 1609
            if (! tmp___31) {
#line 1609
              goto while_break___6;
            }
          } else {
#line 1609
            goto while_break___6;
          }
#line 1609
          spl2 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1610
        str1 = strdup((char const   *)(buf + pos1));
#line 1611
        *(str1 + (spl1 - pos1)) = (char )'\000';
#line 1612
        str2 = strdup((char const   *)(buf + spl2));
#line 1613
        *(str2 + (pos2 - spl2)) = (char )'\000';
#line 1614
        tmp___32 = fnmatch((char const   *)str2, (char const   *)str1, 0);
#line 1614
        *result = tmp___32 == 0;
#line 1615
        free((void *)str1);
#line 1616
        free((void *)str2);
        }
      }
    } else {
#line 1603
      goto _L___1;
    }
#line 1619
    return (1);
  }
  {
#line 1622
  tmp___41 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)">=", & spl1, & spl2);
  }
#line 1622
  if (tmp___41) {
    {
#line 1623
    tmp___39 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1623
    if (tmp___39) {
      {
#line 1623
      tmp___40 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1623
      if (tmp___40) {
#line 1632
        *result = result1 >= result2;
      } else {
        _L___2: /* CIL Label */ 
        {
#line 1626
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1626
          if (pos1 < spl1) {
            {
#line 1626
            tmp___36 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1626
            if (! tmp___36) {
#line 1626
              goto while_break___7;
            }
          } else {
#line 1626
            goto while_break___7;
          }
#line 1626
          spl1 --;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1627
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1627
          if (pos2 > spl2) {
            {
#line 1627
            tmp___37 = iswhite(*(buf + spl2));
            }
#line 1627
            if (! tmp___37) {
#line 1627
              goto while_break___8;
            }
          } else {
#line 1627
            goto while_break___8;
          }
#line 1627
          spl2 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1628
        l = spl1 - pos1;
#line 1628
        if (l > pos2 - spl2) {
#line 1628
          l = pos2 - spl2;
        }
        {
#line 1629
        result1 = strncmp((char const   *)(buf + pos1), (char const   *)(buf + spl2),
                          (size_t )l);
        }
#line 1630
        if (result1 > 0) {
#line 1630
          tmp___38 = 1;
        } else
#line 1630
        if (result1 == 0) {
#line 1630
          if (spl1 - pos1 >= pos2 - spl2) {
#line 1630
            tmp___38 = 1;
          } else {
#line 1630
            tmp___38 = 0;
          }
        } else {
#line 1630
          tmp___38 = 0;
        }
#line 1630
        *result = tmp___38;
      }
    } else {
#line 1623
      goto _L___2;
    }
#line 1633
    return (1);
  }
  {
#line 1636
  tmp___47 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)">", & spl1, & spl2);
  }
#line 1636
  if (tmp___47) {
    {
#line 1637
    tmp___45 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1637
    if (tmp___45) {
      {
#line 1637
      tmp___46 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1637
      if (tmp___46) {
#line 1646
        *result = result1 > result2;
      } else {
        _L___3: /* CIL Label */ 
        {
#line 1640
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1640
          if (pos1 < spl1) {
            {
#line 1640
            tmp___42 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1640
            if (! tmp___42) {
#line 1640
              goto while_break___9;
            }
          } else {
#line 1640
            goto while_break___9;
          }
#line 1640
          spl1 --;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 1641
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1641
          if (pos2 > spl2) {
            {
#line 1641
            tmp___43 = iswhite(*(buf + spl2));
            }
#line 1641
            if (! tmp___43) {
#line 1641
              goto while_break___10;
            }
          } else {
#line 1641
            goto while_break___10;
          }
#line 1641
          spl2 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1642
        l = spl1 - pos1;
#line 1642
        if (l > pos2 - spl2) {
#line 1642
          l = pos2 - spl2;
        }
        {
#line 1643
        result1 = strncmp((char const   *)(buf + pos1), (char const   *)(buf + spl2),
                          (size_t )l);
        }
#line 1644
        if (result1 > 0) {
#line 1644
          tmp___44 = 1;
        } else
#line 1644
        if (result1 == 0) {
#line 1644
          if (spl1 - pos1 > pos2 - spl2) {
#line 1644
            tmp___44 = 1;
          } else {
#line 1644
            tmp___44 = 0;
          }
        } else {
#line 1644
          tmp___44 = 0;
        }
#line 1644
        *result = tmp___44;
      }
    } else {
#line 1637
      goto _L___3;
    }
#line 1647
    return (1);
  }
  {
#line 1650
  tmp___53 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"<=", & spl1, & spl2);
  }
#line 1650
  if (tmp___53) {
    {
#line 1651
    tmp___51 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1651
    if (tmp___51) {
      {
#line 1651
      tmp___52 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1651
      if (tmp___52) {
#line 1660
        *result = result1 <= result2;
      } else {
        _L___4: /* CIL Label */ 
        {
#line 1654
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1654
          if (pos1 < spl1) {
            {
#line 1654
            tmp___48 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1654
            if (! tmp___48) {
#line 1654
              goto while_break___11;
            }
          } else {
#line 1654
            goto while_break___11;
          }
#line 1654
          spl1 --;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 1655
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1655
          if (pos2 > spl2) {
            {
#line 1655
            tmp___49 = iswhite(*(buf + spl2));
            }
#line 1655
            if (! tmp___49) {
#line 1655
              goto while_break___12;
            }
          } else {
#line 1655
            goto while_break___12;
          }
#line 1655
          spl2 ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1656
        l = spl1 - pos1;
#line 1656
        if (l > pos2 - spl2) {
#line 1656
          l = pos2 - spl2;
        }
        {
#line 1657
        result1 = strncmp((char const   *)(buf + pos1), (char const   *)(buf + spl2),
                          (size_t )l);
        }
#line 1658
        if (result1 < 0) {
#line 1658
          tmp___50 = 1;
        } else
#line 1658
        if (result1 == 0) {
#line 1658
          if (spl1 - pos1 <= pos2 - spl2) {
#line 1658
            tmp___50 = 1;
          } else {
#line 1658
            tmp___50 = 0;
          }
        } else {
#line 1658
          tmp___50 = 0;
        }
#line 1658
        *result = tmp___50;
      }
    } else {
#line 1651
      goto _L___4;
    }
#line 1661
    return (1);
  }
  {
#line 1664
  tmp___59 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"<", & spl1, & spl2);
  }
#line 1664
  if (tmp___59) {
    {
#line 1665
    tmp___57 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1665
    if (tmp___57) {
      {
#line 1665
      tmp___58 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1665
      if (tmp___58) {
#line 1674
        *result = result1 < result2;
      } else {
        _L___5: /* CIL Label */ 
        {
#line 1668
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1668
          if (pos1 < spl1) {
            {
#line 1668
            tmp___54 = iswhite(*(buf + (spl1 - 1)));
            }
#line 1668
            if (! tmp___54) {
#line 1668
              goto while_break___13;
            }
          } else {
#line 1668
            goto while_break___13;
          }
#line 1668
          spl1 --;
        }
        while_break___13: /* CIL Label */ ;
        }
        {
#line 1669
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1669
          if (pos2 > spl2) {
            {
#line 1669
            tmp___55 = iswhite(*(buf + spl2));
            }
#line 1669
            if (! tmp___55) {
#line 1669
              goto while_break___14;
            }
          } else {
#line 1669
            goto while_break___14;
          }
#line 1669
          spl2 ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 1670
        l = spl1 - pos1;
#line 1670
        if (l > pos2 - spl2) {
#line 1670
          l = pos2 - spl2;
        }
        {
#line 1671
        result1 = strncmp((char const   *)(buf + pos1), (char const   *)(buf + spl2),
                          (size_t )l);
        }
#line 1672
        if (result1 < 0) {
#line 1672
          tmp___56 = 1;
        } else
#line 1672
        if (result1 == 0) {
#line 1672
          if (spl1 - pos1 < pos2 - spl2) {
#line 1672
            tmp___56 = 1;
          } else {
#line 1672
            tmp___56 = 0;
          }
        } else {
#line 1672
          tmp___56 = 0;
        }
#line 1672
        *result = tmp___56;
      }
    } else {
#line 1665
      goto _L___5;
    }
#line 1675
    return (1);
  }
  {
#line 1678
  tmp___62 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"+", & spl1, & spl2);
  }
#line 1678
  if (tmp___62) {
    {
#line 1679
    tmp___60 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1679
    if (tmp___60) {
      {
#line 1679
      tmp___61 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1679
      if (! tmp___61) {
#line 1680
        return (0);
      }
    } else {
#line 1680
      return (0);
    }
#line 1681
    *result = result1 + result2;
#line 1682
    return (1);
  }
  {
#line 1685
  tmp___65 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"-", & spl1, & spl2);
  }
#line 1685
  if (tmp___65) {
#line 1686
    if (spl1 != pos1) {
      {
#line 1687
      tmp___63 = DoArithmEval(buf, pos1, spl1, & result1);
      }
#line 1687
      if (tmp___63) {
        {
#line 1687
        tmp___64 = DoArithmEval(buf, spl2, pos2, & result2);
        }
#line 1687
        if (! tmp___64) {
#line 1688
          return (0);
        }
      } else {
#line 1688
        return (0);
      }
#line 1689
      *result = result1 - result2;
#line 1690
      return (1);
    }
  }
  {
#line 1693
  tmp___68 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"*", & spl1, & spl2);
  }
#line 1693
  if (tmp___68) {
    {
#line 1694
    tmp___66 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1694
    if (tmp___66) {
      {
#line 1694
      tmp___67 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1694
      if (! tmp___67) {
#line 1695
        return (0);
      }
    } else {
#line 1695
      return (0);
    }
#line 1696
    *result = result1 * result2;
#line 1697
    return (1);
  }
  {
#line 1700
  tmp___71 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"/", & spl1, & spl2);
  }
#line 1700
  if (tmp___71) {
    {
#line 1701
    tmp___69 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1701
    if (tmp___69) {
      {
#line 1701
      tmp___70 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1701
      if (! tmp___70) {
#line 1702
        return (0);
      }
    } else {
#line 1702
      return (0);
    }
#line 1703
    if (result2 == 0) {
      {
#line 1703
      bug("Division by zero in expression");
      }
    }
#line 1704
    *result = result1 / result2;
#line 1705
    return (1);
  }
  {
#line 1708
  tmp___74 = SpliceInfix((char const   *)buf, pos1, pos2, (char *)"%", & spl1, & spl2);
  }
#line 1708
  if (tmp___74) {
    {
#line 1709
    tmp___72 = DoArithmEval(buf, pos1, spl1, & result1);
    }
#line 1709
    if (tmp___72) {
      {
#line 1709
      tmp___73 = DoArithmEval(buf, spl2, pos2, & result2);
      }
#line 1709
      if (! tmp___73) {
#line 1710
        return (0);
      }
    } else {
#line 1710
      return (0);
    }
#line 1711
    if (result2 == 0) {
      {
#line 1711
      bug("Division by zero in expression");
      }
    }
#line 1712
    *result = result1 % result2;
#line 1713
    return (1);
  }
#line 1716
  if ((int )*(buf + pos1) == 126) {
    {
#line 1717
    tmp___75 = DoArithmEval(buf, pos1 + 1, pos2, & result1);
    }
#line 1717
    if (! tmp___75) {
#line 1717
      return (0);
    }
#line 1718
    *result = ~ result1;
#line 1719
    return (1);
  }
#line 1722
  if ((int )*(buf + pos1) == 33) {
    {
#line 1723
    tmp___76 = DoArithmEval(buf, pos1 + 1, pos2, & result1);
    }
#line 1723
    if (! tmp___76) {
#line 1723
      return (0);
    }
#line 1724
    *result = ! result1;
#line 1725
    return (1);
  }
#line 1728
  if ((int )*(buf + pos1) == 45) {
    {
#line 1729
    tmp___77 = DoArithmEval(buf, pos1 + 1, pos2, & result1);
    }
#line 1729
    if (! tmp___77) {
#line 1729
      return (0);
    }
#line 1730
    *result = - result1;
#line 1731
    return (1);
  }
  {
#line 1735
  tmp___79 = strlen("length(");
#line 1735
  tmp___80 = strncmp((char const   *)(buf + pos1), "length(", tmp___79);
  }
#line 1735
  if (tmp___80 == 0) {
#line 1736
    if ((int )*(buf + (pos2 - 1)) != 41) {
#line 1736
      return (0);
    }
    {
#line 1737
    tmp___78 = strlen("length()");
#line 1737
    *result = (int )((size_t )(pos2 - pos1) - tmp___78);
    }
#line 1738
    return (1);
  }
#line 1741
  if ((int )*(buf + pos1) == 40) {
#line 1742
    if ((int )*(buf + (pos2 - 1)) != 41) {
#line 1742
      return (0);
    }
    {
#line 1743
    tmp___81 = DoArithmEval(buf, pos1 + 1, pos2 - 1, result);
    }
#line 1743
    return (tmp___81);
  }
  {
#line 1746
  c = *(buf + pos2);
#line 1746
  *(buf + pos2) = (char)0;
#line 1747
  tmp___82 = strtol((char const   */* __restrict  */)(buf + pos1), (char **/* __restrict  */)(& p),
                    0);
#line 1747
  *result = (int )tmp___82;
#line 1748
  *(buf + pos2) = c;
  }
#line 1749
  return ((unsigned long )p == (unsigned long )(buf + pos2));
}
}
#line 1752 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void delete_macro(int i ) 
{ 
  int j ;

  {
  {
#line 1755
  nmacros --;
#line 1756
  free((void *)(macros + i)->username);
#line 1757
  free((void *)(macros + i)->macrotext);
  }
#line 1758
  if ((unsigned long )(macros + i)->argnames != (unsigned long )((void *)0)) {
#line 1759
    j = 0;
    {
#line 1759
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1759
      if (! (j < (macros + i)->nnamedargs)) {
#line 1759
        goto while_break;
      }
      {
#line 1759
      free((void *)*((macros + i)->argnames + j));
#line 1759
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1760
    free((void *)(macros + i)->argnames);
#line 1761
    (macros + i)->argnames = (char **)((void *)0);
    }
  }
  {
#line 1763
  FreeComments((macros + i)->define_specs);
#line 1764
  free((void *)(macros + i)->define_specs);
#line 1765
  memcpy((void */* __restrict  */)(macros + i), (void const   */* __restrict  */)(macros + nmacros),
         sizeof(struct MACRO ));
  }
#line 1766
  return;
}
}
#line 1768 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *ArithmEval(int pos1 , int pos2 ) 
{ 
  char *s ;
  char *t ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 1774
  tmp = strlen("defined");
#line 1774
  i = findIdent("defined", (int )tmp);
  }
#line 1775
  if (i >= 0) {
    {
#line 1775
    warning("the defined(...) macro is already defined");
    }
  } else {
    {
#line 1777
    tmp___0 = strlen("defined");
#line 1777
    newmacro("defined", (int )tmp___0, 1);
#line 1778
    (macros + nmacros)->macrolen = 0;
#line 1779
    tmp___1 = malloc((size_t )1);
#line 1779
    (macros + nmacros)->macrotext = (char *)tmp___1;
#line 1780
    *((macros + nmacros)->macrotext + 0) = (char)0;
#line 1781
    (macros + nmacros)->nnamedargs = -2;
#line 1782
    nmacros ++;
    }
  }
  {
#line 1785
  s = ProcessText((char const   *)(C->buf + pos1), pos2 - pos1, 0);
  }
#line 1787
  if (i < 0) {
    {
#line 1788
    tmp___2 = strlen("defined");
#line 1788
    i = findIdent("defined", (int )tmp___2);
    }
#line 1789
    if (i < 0) {
      {
#line 1790
      warning("the defined(...) macro was redefined in expression");
      }
    } else
#line 1789
    if ((macros + i)->nnamedargs != -2) {
      {
#line 1790
      warning("the defined(...) macro was redefined in expression");
      }
    } else {
      {
#line 1791
      delete_macro(i);
      }
    }
  }
  {
#line 1794
  tmp___3 = strlen((char const   *)s);
#line 1794
  tmp___4 = DoArithmEval(s, 0, (int )tmp___3, & i);
  }
#line 1794
  if (! tmp___4) {
#line 1794
    return (s);
  }
  {
#line 1795
  tmp___5 = malloc((size_t )15);
#line 1795
  t = (char *)tmp___5;
#line 1796
  sprintf((char */* __restrict  */)t, (char const   */* __restrict  */)"%d", i);
#line 1797
  free((void *)s);
  }
#line 1798
  return (t);
}
}
#line 1801 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int comment_or_white(int start , int end , int cmtmode ) 
{ 
  char c ;
  int tmp ;

  {
  {
#line 1805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1805
    if (! (start < end)) {
#line 1805
      goto while_break;
    }
    {
#line 1806
    SkipPossibleComments(& start, cmtmode, 1);
    }
#line 1807
    if (start < end) {
      {
#line 1808
      tmp = start;
#line 1808
      start ++;
#line 1808
      c = getChar(tmp);
      }
#line 1809
      if ((int )c != 32) {
#line 1809
        if ((int )c != 10) {
#line 1809
          if ((int )c != 9) {
#line 1809
            return (0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1812
  return (1);
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
char *remove_comments(int start , int end , int cmtmode ) 
{ 
  char *s ;
  char *t ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1819
  tmp = malloc((size_t )((end - start) + 1));
#line 1819
  s = (char *)tmp;
#line 1819
  t = s;
  }
  {
#line 1820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1820
    if (! (start < end)) {
#line 1820
      goto while_break;
    }
    {
#line 1821
    SkipPossibleComments(& start, cmtmode, 1);
    }
#line 1822
    if (start < end) {
      {
#line 1823
      tmp___0 = start;
#line 1823
      start ++;
#line 1823
      *t = getChar(tmp___0);
      }
#line 1824
      if ((int )*t == (int )S->User.quotechar) {
#line 1824
        if (start < end) {
          {
#line 1824
          t ++;
#line 1824
          tmp___1 = start;
#line 1824
          start ++;
#line 1824
          *t = getChar(tmp___1);
          }
        }
      }
#line 1825
      t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1828
  *t = (char)0;
#line 1829
  return (s);
}
}
#line 1832 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void SetStandardMode(struct SPECS *P , char const   *opt ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
  {
#line 1834
  P->op_set = DefaultOp;
#line 1835
  P->ext_op_set = DefaultExtOp;
#line 1836
  P->id_set = DefaultId;
#line 1837
  FreeComments(P);
#line 1838
  tmp___28 = strcmp(opt, "C");
  }
#line 1838
  if (tmp___28) {
    {
#line 1838
    tmp___29 = strcmp(opt, "cpp");
    }
#line 1838
    if (tmp___29) {
      {
#line 1847
      tmp___26 = strcmp(opt, "TeX");
      }
#line 1847
      if (tmp___26) {
        {
#line 1847
        tmp___27 = strcmp(opt, "tex");
        }
#line 1847
        if (tmp___27) {
          {
#line 1851
          tmp___24 = strcmp(opt, "HTML");
          }
#line 1851
          if (tmp___24) {
            {
#line 1851
            tmp___25 = strcmp(opt, "html");
            }
#line 1851
            if (tmp___25) {
              {
#line 1855
              tmp___22 = strcmp(opt, "XHTML");
              }
#line 1855
              if (tmp___22) {
                {
#line 1855
                tmp___23 = strcmp(opt, "xhtml");
                }
#line 1855
                if (tmp___23) {
                  {
#line 1859
                  tmp___21 = strcmp(opt, "default");
                  }
#line 1859
                  if (tmp___21) {
                    {
#line 1863
                    tmp___19 = strcmp(opt, "Prolog");
                    }
#line 1863
                    if (tmp___19) {
                      {
#line 1863
                      tmp___20 = strcmp(opt, "prolog");
                      }
#line 1863
                      if (tmp___20) {
                        {
#line 1873
                        bug("unknown standard mode");
                        }
                      } else {
                        _L: /* CIL Label */ 
                        {
#line 1864
                        P->User = KUser;
#line 1864
                        P->Meta = KMeta;
#line 1865
                        P->preservelf = 1;
#line 1866
                        P->op_set = PrologOp;
#line 1867
                        tmp___9 = strdup("*/");
#line 1867
                        tmp___10 = strdup("\213/*");
#line 1867
                        add_comment(P, "css", tmp___10, tmp___9, (char)0, (char)0);
#line 1868
                        tmp___11 = strdup("");
#line 1868
                        tmp___12 = strdup("\\\n");
#line 1868
                        add_comment(P, "cii", tmp___12, tmp___11, (char)0, (char)0);
#line 1869
                        tmp___13 = strdup("\n");
#line 1869
                        tmp___14 = strdup("%");
#line 1869
                        add_comment(P, "css", tmp___14, tmp___13, (char)0, (char)0);
#line 1870
                        tmp___15 = strdup("\"");
#line 1870
                        tmp___16 = strdup("\"");
#line 1870
                        add_comment(P, "sss", tmp___16, tmp___15, (char)0, (char )'\n');
#line 1871
                        tmp___17 = strdup("\'");
#line 1871
                        tmp___18 = strdup("\207\'");
#line 1871
                        add_comment(P, "sss", tmp___18, tmp___17, (char)0, (char )'\n');
                        }
                      }
                    } else {
#line 1863
                      goto _L;
                    }
                  } else {
#line 1860
                    P->User = CUser;
#line 1860
                    P->Meta = CMeta;
#line 1861
                    P->preservelf = 0;
                  }
                } else {
#line 1856
                  P->User = XHtml;
#line 1856
                  P->Meta = XHtml;
#line 1857
                  P->preservelf = 0;
                }
              } else {
#line 1856
                P->User = XHtml;
#line 1856
                P->Meta = XHtml;
#line 1857
                P->preservelf = 0;
              }
            } else {
#line 1852
              P->User = Html;
#line 1852
              P->Meta = Html;
#line 1853
              P->preservelf = 0;
            }
          } else {
#line 1852
            P->User = Html;
#line 1852
            P->Meta = Html;
#line 1853
            P->preservelf = 0;
          }
        } else {
#line 1848
          P->User = Tex;
#line 1848
          P->Meta = Tex;
#line 1849
          P->preservelf = 0;
        }
      } else {
#line 1848
        P->User = Tex;
#line 1848
        P->Meta = Tex;
#line 1849
        P->preservelf = 0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1839
      P->User = KUser;
#line 1839
      P->Meta = KMeta;
#line 1840
      P->preservelf = 1;
#line 1841
      tmp = strdup("*/");
#line 1841
      tmp___0 = strdup("/*");
#line 1841
      add_comment(P, "ccc", tmp___0, tmp, (char)0, (char)0);
#line 1842
      tmp___1 = strdup("\n");
#line 1842
      tmp___2 = strdup("//");
#line 1842
      add_comment(P, "ccc", tmp___2, tmp___1, (char)0, (char)0);
#line 1843
      tmp___3 = strdup("");
#line 1843
      tmp___4 = strdup("\\\n");
#line 1843
      add_comment(P, "ccc", tmp___4, tmp___3, (char)0, (char)0);
#line 1844
      tmp___5 = strdup("\"");
#line 1844
      tmp___6 = strdup("\"");
#line 1844
      add_comment(P, "sss", tmp___6, tmp___5, (char )'\\', (char )'\n');
#line 1845
      tmp___7 = strdup("\'");
#line 1845
      tmp___8 = strdup("\'");
#line 1845
      add_comment(P, "sss", tmp___8, tmp___7, (char )'\\', (char )'\n');
      }
    }
  } else {
#line 1838
    goto _L___0;
  }
#line 1874
  return;
}
}
#line 1876 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void ProcessModeCommand(int p1start , int p1end , int p2start , int p2end ) 
{ 
  struct SPECS *P ;
  char *s ;
  char *p ;
  char *opt ;
  int nargs ;
  int check_isdelim ;
  char *args[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  {
#line 1883
  whiteout(& p1start, & p1end);
  }
#line 1884
  if (p1start == p1end) {
    {
#line 1885
    bug("invalid #mode syntax");
    }
  } else {
    {
#line 1884
    tmp = identifierEnd(p1start);
    }
#line 1884
    if (tmp != p1end) {
      {
#line 1885
      bug("invalid #mode syntax");
      }
    }
  }
#line 1886
  if (p2start < 0) {
    {
#line 1886
    s = strdup("");
    }
  } else {
    {
#line 1887
    s = ProcessText((char const   *)(C->buf + p2start), p2end - p2start, 0);
    }
  }
#line 1890
  p = s;
#line 1890
  opt = (char *)((void *)0);
  {
#line 1891
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1891
    tmp___0 = iswhite(*p);
    }
#line 1891
    if (! tmp___0) {
#line 1891
      goto while_break;
    }
#line 1891
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1892
  if ((int )*p != 34) {
#line 1892
    if ((int )*p != 0) {
#line 1893
      opt = p;
      {
#line 1894
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1894
        if ((int )*p != 0) {
          {
#line 1894
          tmp___1 = iswhite(*p);
          }
#line 1894
          if (tmp___1) {
#line 1894
            goto while_break___0;
          }
        } else {
#line 1894
          goto while_break___0;
        }
#line 1894
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1895
      if ((int )*p != 0) {
#line 1896
        tmp___2 = p;
#line 1896
        p ++;
#line 1896
        *tmp___2 = (char)0;
        {
#line 1897
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1897
          tmp___3 = iswhite(*p);
          }
#line 1897
          if (! tmp___3) {
#line 1897
            goto while_break___1;
          }
#line 1897
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 1900
  nargs = 0;
#line 1901
  tmp___4 = idequal((char const   *)(C->buf + p1start), p1end - p1start, "charset");
  }
#line 1901
  if (tmp___4) {
#line 1901
    tmp___5 = 0;
  } else {
#line 1901
    tmp___5 = 1;
  }
#line 1901
  check_isdelim = tmp___5;
  {
#line 1902
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1902
    if (! ((int )*p != 0)) {
#line 1902
      goto while_break___2;
    }
#line 1903
    if (nargs == 10) {
      {
#line 1903
      bug("too many arguments in #mode command");
      }
    }
#line 1904
    tmp___6 = p;
#line 1904
    p ++;
#line 1904
    if ((int )*tmp___6 != 34) {
      {
#line 1904
      bug("syntax error in #mode command (missing \" or trailing data)");
      }
    }
    {
#line 1905
    tmp___7 = nargs;
#line 1905
    nargs ++;
#line 1905
    args[tmp___7] = p;
#line 1906
    p = strnl2(p, check_isdelim);
    }
    {
#line 1907
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1907
      tmp___8 = iswhite(*p);
      }
#line 1907
      if (! tmp___8) {
#line 1907
        goto while_break___3;
      }
#line 1907
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1910
  tmp___35 = idequal((char const   *)(C->buf + p1start), p1end - p1start, "quote");
  }
#line 1910
  if (tmp___35) {
#line 1911
    if (opt) {
      {
#line 1911
      bug("syntax error in #mode quote command");
      }
    } else
#line 1911
    if (nargs > 1) {
      {
#line 1911
      bug("syntax error in #mode quote command");
      }
    }
#line 1912
    if (nargs == 0) {
#line 1912
      args[0] = (char *)"";
    }
#line 1913
    (S->stack_next)->User.quotechar = *(args[0] + 0);
  } else {
    {
#line 1915
    tmp___34 = idequal((char const   *)(C->buf + p1start), p1end - p1start, "comment");
    }
#line 1915
    if (tmp___34) {
#line 1916
      if (nargs < 2) {
        {
#line 1916
        bug("syntax error in #mode comment command");
        }
      } else
#line 1916
      if (nargs > 4) {
        {
#line 1916
        bug("syntax error in #mode comment command");
        }
      }
#line 1917
      if (! opt) {
#line 1917
        opt = (char *)"ccc";
      }
#line 1918
      if (nargs < 3) {
#line 1918
        args[2] = (char *)"";
      }
#line 1919
      if (nargs < 4) {
#line 1919
        args[3] = (char *)"";
      }
      {
#line 1920
      tmp___9 = strdup((char const   *)args[1]);
#line 1920
      tmp___10 = strdup((char const   *)args[0]);
#line 1920
      add_comment(S->stack_next, (char const   *)opt, tmp___10, tmp___9, *(args[2] + 0),
                  *(args[3] + 0));
      }
    } else {
      {
#line 1922
      tmp___33 = idequal((char const   *)(C->buf + p1start), p1end - p1start, "string");
      }
#line 1922
      if (tmp___33) {
#line 1923
        if (nargs < 2) {
          {
#line 1923
          bug("syntax error in #mode string command");
          }
        } else
#line 1923
        if (nargs > 4) {
          {
#line 1923
          bug("syntax error in #mode string command");
          }
        }
#line 1924
        if (! opt) {
#line 1924
          opt = (char *)"sss";
        }
#line 1925
        if (nargs < 3) {
#line 1925
          args[2] = (char *)"";
        }
#line 1926
        if (nargs < 4) {
#line 1926
          args[3] = (char *)"";
        }
        {
#line 1927
        tmp___11 = strdup((char const   *)args[1]);
#line 1927
        tmp___12 = strdup((char const   *)args[0]);
#line 1927
        add_comment(S->stack_next, (char const   *)opt, tmp___12, tmp___11, *(args[2] + 0),
                    *(args[3] + 0));
        }
      } else {
        {
#line 1929
        tmp___31 = idequal((char const   *)(C->buf + p1start), p1end - p1start, "save");
        }
#line 1929
        if (tmp___31) {
#line 1929
          goto _L___3;
        } else {
          {
#line 1929
          tmp___32 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                             "push");
          }
#line 1929
          if (tmp___32) {
            _L___3: /* CIL Label */ 
#line 1931
            if ((unsigned long )opt != (unsigned long )((void *)0)) {
              {
#line 1931
              bug("too many arguments to #mode save");
              }
            } else
#line 1931
            if (nargs) {
              {
#line 1931
              bug("too many arguments to #mode save");
              }
            }
            {
#line 1932
            P = CloneSpecs((struct SPECS  const  *)S->stack_next);
#line 1933
            P->stack_next = S->stack_next;
#line 1934
            S->stack_next = P;
            }
          } else {
            {
#line 1936
            tmp___29 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                               "restore");
            }
#line 1936
            if (tmp___29) {
#line 1936
              goto _L___2;
            } else {
              {
#line 1936
              tmp___30 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                 "pop");
              }
#line 1936
              if (tmp___30) {
                _L___2: /* CIL Label */ 
#line 1938
                if ((unsigned long )opt != (unsigned long )((void *)0)) {
                  {
#line 1938
                  bug("too many arguments to #mode restore");
                  }
                } else
#line 1938
                if (nargs) {
                  {
#line 1938
                  bug("too many arguments to #mode restore");
                  }
                }
#line 1939
                P = (S->stack_next)->stack_next;
#line 1940
                if ((unsigned long )P == (unsigned long )((void *)0)) {
                  {
#line 1940
                  bug("#mode restore without #mode save");
                  }
                }
                {
#line 1941
                FreeComments(S->stack_next);
#line 1942
                free((void *)S->stack_next);
#line 1943
                S->stack_next = P;
                }
              } else {
                {
#line 1945
                tmp___28 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                   "standard");
                }
#line 1945
                if (tmp___28) {
#line 1946
                  if ((unsigned long )opt == (unsigned long )((void *)0)) {
                    {
#line 1946
                    bug("syntax error in #mode standard");
                    }
                  } else
#line 1946
                  if (nargs) {
                    {
#line 1946
                    bug("syntax error in #mode standard");
                    }
                  }
                  {
#line 1947
                  SetStandardMode(S->stack_next, (char const   *)opt);
                  }
                } else {
                  {
#line 1949
                  tmp___27 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                     "user");
                  }
#line 1949
                  if (tmp___27) {
#line 1950
                    if ((unsigned long )opt != (unsigned long )((void *)0)) {
                      {
#line 1950
                      bug("#mode user requires 9 arguments");
                      }
                    } else
#line 1950
                    if (nargs != 9) {
                      {
#line 1950
                      bug("#mode user requires 9 arguments");
                      }
                    }
                    {
#line 1951
                    (S->stack_next)->User.mStart = strdup((char const   *)args[0]);
#line 1952
                    (S->stack_next)->User.mEnd = strdup((char const   *)args[1]);
#line 1953
                    (S->stack_next)->User.mArgS = strdup((char const   *)args[2]);
#line 1954
                    (S->stack_next)->User.mArgSep = strdup((char const   *)args[3]);
#line 1955
                    (S->stack_next)->User.mArgE = strdup((char const   *)args[4]);
#line 1956
                    (S->stack_next)->User.stackchar = strdup((char const   *)args[5]);
#line 1957
                    (S->stack_next)->User.unstackchar = strdup((char const   *)args[6]);
#line 1958
                    (S->stack_next)->User.mArgRef = strdup((char const   *)args[7]);
#line 1959
                    (S->stack_next)->User.quotechar = *(args[8] + 0);
                    }
                  } else {
                    {
#line 1961
                    tmp___26 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                       "meta");
                    }
#line 1961
                    if (tmp___26) {
#line 1962
                      if ((unsigned long )opt != (unsigned long )((void *)0)) {
#line 1962
                        if (! nargs) {
                          {
#line 1962
                          tmp___13 = strcmp((char const   *)opt, "user");
                          }
#line 1962
                          if (tmp___13) {
#line 1962
                            goto _L___0;
                          } else {
#line 1963
                            (S->stack_next)->Meta = (S->stack_next)->User;
                          }
                        } else {
#line 1962
                          goto _L___0;
                        }
                      } else {
                        _L___0: /* CIL Label */ 
#line 1965
                        if ((unsigned long )opt != (unsigned long )((void *)0)) {
                          {
#line 1965
                          bug("#mode meta requires 7 arguments");
                          }
                        } else
#line 1965
                        if (nargs != 7) {
                          {
#line 1965
                          bug("#mode meta requires 7 arguments");
                          }
                        }
                        {
#line 1966
                        (S->stack_next)->Meta.mStart = strdup((char const   *)args[0]);
#line 1967
                        (S->stack_next)->Meta.mEnd = strdup((char const   *)args[1]);
#line 1968
                        (S->stack_next)->Meta.mArgS = strdup((char const   *)args[2]);
#line 1969
                        (S->stack_next)->Meta.mArgSep = strdup((char const   *)args[3]);
#line 1970
                        (S->stack_next)->Meta.mArgE = strdup((char const   *)args[4]);
#line 1971
                        (S->stack_next)->Meta.stackchar = strdup((char const   *)args[5]);
#line 1972
                        (S->stack_next)->Meta.unstackchar = strdup((char const   *)args[6]);
                        }
                      }
                    } else {
                      {
#line 1975
                      tmp___25 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                         "preservelf");
                      }
#line 1975
                      if (tmp___25) {
#line 1976
                        if ((unsigned long )opt == (unsigned long )((void *)0)) {
                          {
#line 1976
                          bug("syntax error in #mode preservelf");
                          }
                        } else
#line 1976
                        if (nargs) {
                          {
#line 1976
                          bug("syntax error in #mode preservelf");
                          }
                        }
                        {
#line 1977
                        tmp___16 = strcmp((char const   *)opt, "1");
                        }
#line 1977
                        if (tmp___16) {
                          {
#line 1977
                          tmp___17 = strcasecmp((char const   *)opt, "on");
                          }
#line 1977
                          if (tmp___17) {
                            {
#line 1978
                            tmp___14 = strcmp((char const   *)opt, "0");
                            }
#line 1978
                            if (tmp___14) {
                              {
#line 1978
                              tmp___15 = strcasecmp((char const   *)opt, "off");
                              }
#line 1978
                              if (tmp___15) {
                                {
#line 1979
                                bug("#mode preservelf requires on/off argument");
                                }
                              } else {
#line 1978
                                (S->stack_next)->preservelf = 0;
                              }
                            } else {
#line 1978
                              (S->stack_next)->preservelf = 0;
                            }
                          } else {
#line 1977
                            (S->stack_next)->preservelf = 1;
                          }
                        } else {
#line 1977
                          (S->stack_next)->preservelf = 1;
                        }
                      } else {
                        {
#line 1981
                        tmp___23 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                           "nocomment");
                        }
#line 1981
                        if (tmp___23) {
#line 1981
                          goto _L___1;
                        } else {
                          {
#line 1981
                          tmp___24 = idequal((char const   *)(C->buf + p1start), p1end - p1start,
                                             "nostring");
                          }
#line 1981
                          if (tmp___24) {
                            _L___1: /* CIL Label */ 
#line 1983
                            if ((unsigned long )opt != (unsigned long )((void *)0)) {
                              {
#line 1984
                              bug("syntax error in #mode nocomment/nostring");
                              }
                            } else
#line 1983
                            if (nargs > 1) {
                              {
#line 1984
                              bug("syntax error in #mode nocomment/nostring");
                              }
                            }
#line 1985
                            if (nargs == 0) {
                              {
#line 1985
                              FreeComments(S->stack_next);
                              }
                            } else {
                              {
#line 1986
                              tmp___18 = strdup((char const   *)args[0]);
#line 1986
                              delete_comment(S->stack_next, tmp___18);
                              }
                            }
                          } else {
                            {
#line 1988
                            tmp___22 = idequal((char const   *)(C->buf + p1start),
                                               p1end - p1start, "charset");
                            }
#line 1988
                            if (tmp___22) {
#line 1989
                              if ((unsigned long )opt == (unsigned long )((void *)0)) {
                                {
#line 1989
                                bug("syntax error in #mode charset");
                                }
                              } else
#line 1989
                              if (nargs != 1) {
                                {
#line 1989
                                bug("syntax error in #mode charset");
                                }
                              }
                              {
#line 1990
                              tmp___21 = strcasecmp((char const   *)opt, "op");
                              }
#line 1990
                              if (tmp___21) {
                                {
#line 1992
                                tmp___20 = strcasecmp((char const   *)opt, "par");
                                }
#line 1992
                                if (tmp___20) {
                                  {
#line 1994
                                  tmp___19 = strcasecmp((char const   *)opt, "id");
                                  }
#line 1994
                                  if (tmp___19) {
                                    {
#line 1996
                                    bug("unknown charset subset name in #mode charset");
                                    }
                                  } else {
                                    {
#line 1995
                                    (S->stack_next)->id_set = MakeCharsetSubset((unsigned char *)args[0]);
                                    }
                                  }
                                } else {
                                  {
#line 1993
                                  (S->stack_next)->ext_op_set = MakeCharsetSubset((unsigned char *)args[0]);
                                  }
                                }
                              } else {
                                {
#line 1991
                                (S->stack_next)->op_set = MakeCharsetSubset((unsigned char *)args[0]);
                                }
                              }
                            } else {
                              {
#line 1998
                              bug("unrecognized #mode command");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 2000
  free((void *)s);
  }
#line 2001
  return;
}
}
#line 2003 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
static void DoInclude(char *file_name ) 
{ 
  struct INPUTCONTEXT *N ;
  char *incfile_name ;
  FILE *f ;
  int j ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2006
  incfile_name = (char *)((void *)0);
#line 2007
  f = (FILE *)((void *)0);
#line 2009
  tmp = strlen((char const   *)file_name);
#line 2009
  len = (int )tmp;
  }
#line 2012
  if ((int )*(file_name + 0) == 47) {
    {
#line 2017
    f = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
    }
  } else
#line 2019
  if (! NoCurIncFirst) {
    {
#line 2020
    f = openInCurrentDir((char const   *)file_name);
    }
  }
#line 2023
  j = 0;
  {
#line 2023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2023
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 2023
      if (! (j < nincludedirs)) {
#line 2023
        goto while_break;
      }
    } else {
#line 2023
      goto while_break;
    }
    {
#line 2024
    tmp___0 = strlen((char const   *)includedir[j]);
#line 2024
    tmp___1 = realloc((void *)incfile_name, ((size_t )len + tmp___0) + 2UL);
#line 2024
    incfile_name = (char *)tmp___1;
#line 2026
    strcpy((char */* __restrict  */)incfile_name, (char const   */* __restrict  */)includedir[j]);
#line 2027
    tmp___2 = strlen((char const   *)includedir[j]);
#line 2027
    *(incfile_name + tmp___2) = (char )'/';
#line 2029
    tmp___3 = strlen((char const   *)includedir[j]);
#line 2029
    strcpy((char */* __restrict  */)((incfile_name + tmp___3) + 1), (char const   */* __restrict  */)file_name);
#line 2030
    f = fopen((char const   */* __restrict  */)incfile_name, (char const   */* __restrict  */)"r");
#line 2023
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2032
  if ((unsigned long )incfile_name != (unsigned long )((void *)0)) {
    {
#line 2033
    free((void *)incfile_name);
    }
  }
#line 2036
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 2036
    if (CurDirIncLast) {
      {
#line 2037
      f = openInCurrentDir((char const   *)file_name);
      }
    }
  }
#line 2040
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 2041
    bug("Requested include file not found");
    }
  }
  {
#line 2043
  N = C;
#line 2044
  tmp___4 = malloc(sizeof(*C));
#line 2044
  C = (struct INPUTCONTEXT *)tmp___4;
#line 2045
  C->in = f;
#line 2046
  C->argc = 0;
#line 2047
  C->argv = (char **)((void *)0);
#line 2048
  C->filename = file_name;
#line 2049
  C->out = N->out;
#line 2050
  C->lineno = 1;
#line 2051
  C->bufsize = 80;
#line 2052
  C->len = 0;
#line 2053
  tmp___6 = malloc((size_t )C->bufsize);
#line 2053
  tmp___5 = (char *)tmp___6;
#line 2053
  C->malloced_buf = tmp___5;
#line 2053
  C->buf = tmp___5;
#line 2054
  C->eof = 0;
#line 2055
  C->namedargs = (char **)((void *)0);
#line 2056
  C->in_comment = 0;
#line 2057
  C->ambience = 2;
#line 2058
  C->may_have_args = 0;
#line 2059
  PushSpecs((struct SPECS  const  *)S);
  }
#line 2060
  if (autoswitch) {
    {
#line 2061
    tmp___7 = strlen((char const   *)file_name);
#line 2061
    tmp___8 = strcmp((char const   *)((file_name + tmp___7) - 2), ".h");
    }
#line 2061
    if (tmp___8) {
      {
#line 2061
      tmp___9 = strlen((char const   *)file_name);
#line 2061
      tmp___10 = strcmp((char const   *)((file_name + tmp___9) - 2), ".c");
      }
#line 2061
      if (! tmp___10) {
        {
#line 2063
        SetStandardMode(S, "C");
        }
      }
    } else {
      {
#line 2063
      SetStandardMode(S, "C");
      }
    }
  }
  {
#line 2067
  write_include_marker((N->out)->f, 1, C->filename, "1");
#line 2068
  ProcessContext();
#line 2070
  write_include_marker((N->out)->f, N->lineno, N->filename, "2");
#line 2072
  replace_directive_with_blank_line((N->out)->f);
#line 2073
  free((void *)C);
#line 2074
  PopSpecs();
#line 2075
  C = N;
  }
#line 2076
  return;
}
}
#line 2078 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int ParsePossibleMeta(void) 
{ 
  int cklen ;
  int nameend ;
  int id ;
  int expparams ;
  int nparam ;
  int i ;
  int j ;
  int p1start ;
  int p1end ;
  int p2start ;
  int p2end ;
  int macend ;
  int argc ;
  int argb[100] ;
  int arge[100] ;
  char *tmpbuf ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  void *tmp___30 ;
  int tmp___31 ;
  void *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *incfile_name ;
  int tmp___37 ;
  char tmp___38 ;
  char tmp___39 ;
  char tmp___40 ;
  char tmp___41 ;
  void *tmp___42 ;
  char *s ;
  char *t ;
  int c ;
  FILE *f ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  void *tmp___45 ;
  int tmp___46 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  int tmp___49 ;
  void *tmp___50 ;
  int tmp___51 ;
  char *s___0 ;
  char *t___0 ;
  int tmp___52 ;
  char *s___1 ;
  char *t___1 ;
  int tmp___53 ;
  char *s___2 ;
  char *t___2 ;
  char *s___3 ;
  int tmp___54 ;
  char buf[15] ;
  size_t tmp___55 ;
  size_t tmp___56 ;
  char *s___4 ;
  int tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  char *s___5 ;
  int tmp___60 ;
  char buf___0[1024] ;
  char *fmt ;
  time_t now ;
  time_t tmp___61 ;
  int tmp___62 ;
  struct tm *tmp___63 ;
  size_t tmp___64 ;
  size_t tmp___65 ;

  {
  {
#line 2086
  cklen = 1;
#line 2087
  tmp = matchStartSequence((char const   *)S->Meta.mStart, & cklen);
  }
#line 2087
  if (! tmp) {
#line 2087
    return (-1);
  }
  {
#line 2088
  nameend = identifierEnd(cklen);
  }
#line 2089
  if (nameend) {
    {
#line 2089
    tmp___0 = getChar(nameend - 1);
    }
#line 2089
    if (! tmp___0) {
#line 2089
      return (-1);
    }
  }
  {
#line 2090
  id = 0;
#line 2091
  argc = 0;
#line 2092
  tmp___20 = idequal((char const   *)(C->buf + cklen), nameend - cklen, "define");
  }
#line 2092
  if (tmp___20) {
#line 2093
    id = 1;
#line 2093
    expparams = 2;
#line 2093
    argc = 1;
  } else {
    {
#line 2094
    tmp___19 = idequal((char const   *)(C->buf + cklen), nameend - cklen, "undef");
    }
#line 2094
    if (tmp___19) {
#line 2095
      id = 2;
#line 2095
      expparams = 1;
    } else {
      {
#line 2096
      tmp___18 = idequal((char const   *)(C->buf + cklen), nameend - cklen, "ifdef");
      }
#line 2096
      if (tmp___18) {
#line 2097
        id = 3;
#line 2097
        expparams = 1;
      } else {
        {
#line 2098
        tmp___17 = idequal((char const   *)(C->buf + cklen), nameend - cklen, "ifndef");
        }
#line 2098
        if (tmp___17) {
#line 2099
          id = 4;
#line 2099
          expparams = 1;
        } else {
          {
#line 2100
          tmp___16 = idequal((char const   *)(C->buf + cklen), nameend - cklen, "else");
          }
#line 2100
          if (tmp___16) {
#line 2101
            id = 5;
#line 2101
            expparams = 0;
          } else {
            {
#line 2102
            tmp___15 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                               "endif");
            }
#line 2102
            if (tmp___15) {
#line 2103
              id = 6;
#line 2103
              expparams = 0;
            } else {
              {
#line 2104
              tmp___14 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                 "include");
              }
#line 2104
              if (tmp___14) {
#line 2105
                id = 7;
#line 2105
                expparams = 1;
              } else {
                {
#line 2106
                tmp___13 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                   "exec");
                }
#line 2106
                if (tmp___13) {
#line 2107
                  id = 8;
#line 2107
                  expparams = 1;
                } else {
                  {
#line 2108
                  tmp___12 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                     "defeval");
                  }
#line 2108
                  if (tmp___12) {
#line 2109
                    id = 9;
#line 2109
                    expparams = 2;
#line 2109
                    argc = 1;
                  } else {
                    {
#line 2110
                    tmp___11 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                       "ifeq");
                    }
#line 2110
                    if (tmp___11) {
#line 2111
                      id = 10;
#line 2111
                      expparams = 2;
                    } else {
                      {
#line 2112
                      tmp___10 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                         "ifneq");
                      }
#line 2112
                      if (tmp___10) {
#line 2113
                        id = 11;
#line 2113
                        expparams = 2;
                      } else {
                        {
#line 2114
                        tmp___9 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                          "eval");
                        }
#line 2114
                        if (tmp___9) {
#line 2115
                          id = 12;
#line 2115
                          expparams = 1;
                        } else {
                          {
#line 2116
                          tmp___8 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                            "if");
                          }
#line 2116
                          if (tmp___8) {
#line 2117
                            id = 13;
#line 2117
                            expparams = 1;
                          } else {
                            {
#line 2118
                            tmp___7 = idequal((char const   *)(C->buf + cklen), nameend - cklen,
                                              "mode");
                            }
#line 2118
                            if (tmp___7) {
#line 2119
                              id = 14;
#line 2119
                              expparams = 2;
                            } else {
                              {
#line 2120
                              tmp___6 = idequal((char const   *)(C->buf + cklen),
                                                nameend - cklen, "line");
                              }
#line 2120
                              if (tmp___6) {
#line 2121
                                id = 15;
#line 2121
                                expparams = 0;
                              } else {
                                {
#line 2122
                                tmp___5 = idequal((char const   *)(C->buf + cklen),
                                                  nameend - cklen, "file");
                                }
#line 2122
                                if (tmp___5) {
#line 2123
                                  id = 16;
#line 2123
                                  expparams = 0;
                                } else {
                                  {
#line 2124
                                  tmp___4 = idequal((char const   *)(C->buf + cklen),
                                                    nameend - cklen, "elif");
                                  }
#line 2124
                                  if (tmp___4) {
#line 2125
                                    id = 17;
#line 2125
                                    expparams = 1;
                                  } else {
                                    {
#line 2126
                                    tmp___3 = idequal((char const   *)(C->buf + cklen),
                                                      nameend - cklen, "error");
                                    }
#line 2126
                                    if (tmp___3) {
#line 2127
                                      id = 18;
#line 2127
                                      expparams = 1;
                                    } else {
                                      {
#line 2128
                                      tmp___2 = idequal((char const   *)(C->buf + cklen),
                                                        nameend - cklen, "warning");
                                      }
#line 2128
                                      if (tmp___2) {
#line 2129
                                        id = 19;
#line 2129
                                        expparams = 1;
                                      } else {
                                        {
#line 2130
                                        tmp___1 = idequal((char const   *)(C->buf + cklen),
                                                          nameend - cklen, "date");
                                        }
#line 2130
                                        if (tmp___1) {
#line 2131
                                          id = 20;
#line 2131
                                          expparams = 1;
                                        } else {
#line 2132
                                          return (-1);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2135
  if (id == 14) {
    {
#line 2136
    PushSpecs((struct SPECS  const  *)S);
#line 2137
    S->preservelf = 1;
#line 2138
    tmp___21 = strdup("\"");
#line 2138
    delete_comment(S, tmp___21);
#line 2139
    tmp___22 = strdup("\"");
#line 2139
    tmp___23 = strdup("\"");
#line 2139
    add_comment(S, "sss", tmp___23, tmp___22, (char )'\\', (char )'\n');
    }
  }
  {
#line 2142
  nparam = findMetaArgs(nameend, & p1start, & p1end, & p2start, & p2end, & macend,
                        & argc, argb, arge);
  }
#line 2143
  if (nparam == -1) {
#line 2143
    return (-1);
  }
#line 2145
  if (nparam == 2) {
    {
#line 2145
    tmp___25 = iswhitesep((char const   *)S->Meta.mArgSep);
    }
#line 2145
    if (tmp___25) {
      {
#line 2146
      tmp___24 = comment_or_white(p2start, p2end, 0);
      }
#line 2146
      if (tmp___24) {
#line 2146
        nparam = 1;
      }
    }
  }
#line 2147
  if (nparam == 1) {
    {
#line 2147
    tmp___27 = iswhitesep((char const   *)S->Meta.mArgS);
    }
#line 2147
    if (tmp___27) {
      {
#line 2148
      tmp___26 = comment_or_white(p1start, p1end, 0);
      }
#line 2148
      if (tmp___26) {
#line 2148
        nparam = 0;
      }
    }
  }
#line 2149
  if (expparams) {
#line 2149
    if (! nparam) {
      {
#line 2149
      bug("Missing argument in meta-macro");
      }
    }
  }
  {
#line 2152
  if (id == 1) {
#line 2152
    goto case_1;
  }
#line 2187
  if (id == 2) {
#line 2187
    goto case_2;
  }
#line 2200
  if (id == 3) {
#line 2200
    goto case_3;
  }
#line 2217
  if (id == 4) {
#line 2217
    goto case_4;
  }
#line 2233
  if (id == 5) {
#line 2233
    goto case_5;
  }
#line 2242
  if (id == 6) {
#line 2242
    goto case_6;
  }
#line 2250
  if (id == 7) {
#line 2250
    goto case_7;
  }
#line 2273
  if (id == 8) {
#line 2273
    goto case_8;
  }
#line 2301
  if (id == 9) {
#line 2301
    goto case_9;
  }
#line 2336
  if (id == 10) {
#line 2336
    goto case_10;
  }
#line 2351
  if (id == 11) {
#line 2351
    goto case_11;
  }
#line 2366
  if (id == 12) {
#line 2366
    goto case_12;
  }
#line 2376
  if (id == 13) {
#line 2376
    goto case_13;
  }
#line 2390
  if (id == 14) {
#line 2390
    goto case_14;
  }
#line 2398
  if (id == 15) {
#line 2398
    goto case_15;
  }
#line 2406
  if (id == 16) {
#line 2406
    goto case_16;
  }
#line 2411
  if (id == 17) {
#line 2411
    goto case_17;
  }
#line 2427
  if (id == 18) {
#line 2427
    goto case_18;
  }
#line 2435
  if (id == 19) {
#line 2435
    goto case_19;
  }
#line 2447
  if (id == 20) {
#line 2447
    goto case_20;
  }
#line 2462
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2153
  if (! commented[iflevel]) {
    {
#line 2154
    whiteout(& p1start, & p1end);
    }
#line 2155
    if (p1start == p1end) {
      {
#line 2156
      bug("#define requires an identifier (A-Z,a-z,0-9,_ only)");
      }
    } else {
      {
#line 2155
      tmp___28 = identifierEnd(p1start);
      }
#line 2155
      if (tmp___28 != p1end) {
        {
#line 2156
        bug("#define requires an identifier (A-Z,a-z,0-9,_ only)");
        }
      }
    }
    {
#line 2158
    i = findIdent((char const   *)(C->buf + p1start), p1end - p1start);
    }
#line 2159
    if (i >= 0) {
      {
#line 2159
      delete_macro(i);
      }
    }
    {
#line 2160
    newmacro((char const   *)(C->buf + p1start), p1end - p1start, 1);
    }
#line 2161
    if (nparam == 1) {
#line 2161
      p2start = p1end;
#line 2161
      p2end = p2start;
    }
    {
#line 2162
    replace_definition_with_blank_lines((char const   *)(C->buf + 1), (char const   *)(C->buf + p2end),
                                        S->preservelf);
#line 2163
    (macros + nmacros)->macrotext = remove_comments(p2start, p2end, 0);
#line 2164
    tmp___29 = strlen((char const   *)(macros + nmacros)->macrotext);
#line 2164
    (macros + nmacros)->macrolen = (int )tmp___29;
#line 2165
    (macros + nmacros)->defined_in_comment = C->in_comment;
    }
#line 2167
    if (argc) {
#line 2168
      j = 0;
      {
#line 2168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2168
        if (! (j < argc)) {
#line 2168
          goto while_break;
        }
        {
#line 2168
        whiteout(argb + j, arge + j);
#line 2168
        j ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2170
      if (argc == 1) {
#line 2170
        if (arge[0] == argb[0]) {
#line 2170
          argc = 0;
        }
      }
      {
#line 2171
      tmp___30 = malloc((unsigned long )(argc + 1) * sizeof(char *));
#line 2171
      (macros + nmacros)->argnames = (char **)tmp___30;
#line 2172
      *((macros + nmacros)->argnames + argc) = (char *)((void *)0);
      }
    }
#line 2174
    (macros + nmacros)->nnamedargs = argc;
#line 2175
    j = 0;
    {
#line 2175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2175
      if (! (j < argc)) {
#line 2175
        goto while_break___0;
      }
#line 2176
      if (argb[j] == arge[j]) {
        {
#line 2177
        bug("#define with named args needs identifiers as arg names");
        }
      } else {
        {
#line 2176
        tmp___31 = identifierEnd(argb[j]);
        }
#line 2176
        if (tmp___31 != arge[j]) {
          {
#line 2177
          bug("#define with named args needs identifiers as arg names");
          }
        }
      }
      {
#line 2178
      tmp___32 = malloc((size_t )((arge[j] - argb[j]) + 1));
#line 2178
      *((macros + nmacros)->argnames + j) = (char *)tmp___32;
#line 2179
      memcpy((void */* __restrict  */)*((macros + nmacros)->argnames + j), (void const   */* __restrict  */)(C->buf + argb[j]),
             (size_t )(arge[j] - argb[j]));
#line 2180
      *(*((macros + nmacros)->argnames + j) + (arge[j] - argb[j])) = (char)0;
#line 2175
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2182
    tmp___33 = nmacros;
#line 2182
    nmacros ++;
#line 2182
    lookupArgRefs(tmp___33);
    }
  } else {
    {
#line 2184
    replace_directive_with_blank_line((C->out)->f);
    }
  }
#line 2185
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2188
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2189
  if (! commented[iflevel]) {
#line 2190
    if (nparam == 2) {
#line 2190
      if ((int )WarningLevel > 0) {
        {
#line 2191
        warning("Extra argument to #undef ignored");
        }
      }
    }
    {
#line 2192
    whiteout(& p1start, & p1end);
    }
#line 2193
    if (p1start == p1end) {
      {
#line 2194
      bug("#undef requires an identifier (A-Z,a-z,0-9,_ only)");
      }
    } else {
      {
#line 2193
      tmp___34 = identifierEnd(p1start);
      }
#line 2193
      if (tmp___34 != p1end) {
        {
#line 2194
        bug("#undef requires an identifier (A-Z,a-z,0-9,_ only)");
        }
      }
    }
    {
#line 2195
    i = findIdent((char const   *)(C->buf + p1start), p1end - p1start);
    }
#line 2196
    if (i >= 0) {
      {
#line 2196
      delete_macro(i);
      }
    }
  }
#line 2198
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2201
  replace_directive_with_blank_line((C->out)->f);
#line 2202
  iflevel ++;
  }
#line 2203
  if (iflevel == 50) {
    {
#line 2203
    bug("Too many nested #ifdefs");
    }
  }
#line 2204
  commented[iflevel] = commented[iflevel - 1];
#line 2206
  if (! commented[iflevel]) {
#line 2207
    if (nparam == 2) {
#line 2207
      if ((int )WarningLevel > 0) {
        {
#line 2208
        warning("Extra argument to #ifdef ignored");
        }
      }
    }
    {
#line 2209
    whiteout(& p1start, & p1end);
    }
#line 2210
    if (p1start == p1end) {
      {
#line 2211
      bug("#ifdef requires an identifier (A-Z,a-z,0-9,_ only)");
      }
    } else {
      {
#line 2210
      tmp___35 = identifierEnd(p1start);
      }
#line 2210
      if (tmp___35 != p1end) {
        {
#line 2211
        bug("#ifdef requires an identifier (A-Z,a-z,0-9,_ only)");
        }
      }
    }
    {
#line 2212
    i = findIdent((char const   *)(C->buf + p1start), p1end - p1start);
#line 2213
    commented[iflevel] = i == -1;
    }
  }
#line 2215
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2218
  replace_directive_with_blank_line((C->out)->f);
#line 2219
  iflevel ++;
  }
#line 2220
  if (iflevel == 50) {
    {
#line 2220
    bug("Too many nested #ifdefs");
    }
  }
#line 2221
  commented[iflevel] = commented[iflevel - 1];
#line 2222
  if (! commented[iflevel]) {
#line 2223
    if (nparam == 2) {
#line 2223
      if ((int )WarningLevel > 0) {
        {
#line 2224
        warning("Extra argument to #ifndef ignored");
        }
      }
    }
    {
#line 2225
    whiteout(& p1start, & p1end);
    }
#line 2226
    if (p1start == p1end) {
      {
#line 2227
      bug("#ifndef requires an identifier (A-Z,a-z,0-9,_ only)");
      }
    } else {
      {
#line 2226
      tmp___36 = identifierEnd(p1start);
      }
#line 2226
      if (tmp___36 != p1end) {
        {
#line 2227
        bug("#ifndef requires an identifier (A-Z,a-z,0-9,_ only)");
        }
      }
    }
    {
#line 2228
    i = findIdent((char const   *)(C->buf + p1start), p1end - p1start);
#line 2229
    commented[iflevel] = i != -1;
    }
  }
#line 2231
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2234
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2235
  if (! commented[iflevel]) {
#line 2235
    if (nparam > 0) {
#line 2235
      if ((int )WarningLevel > 0) {
        {
#line 2236
        warning("Extra argument to #else ignored");
        }
      }
    }
  }
#line 2237
  if (iflevel == 0) {
    {
#line 2237
    bug("#else without #if");
    }
  }
#line 2238
  if (! commented[iflevel - 1]) {
#line 2238
    if (commented[iflevel] != 2) {
#line 2239
      commented[iflevel] = ! commented[iflevel];
    }
  }
#line 2240
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2243
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2244
  if (! commented[iflevel]) {
#line 2244
    if (nparam > 0) {
#line 2244
      if ((int )WarningLevel > 0) {
        {
#line 2245
        warning("Extra argument to #endif ignored");
        }
      }
    }
  }
#line 2246
  if (iflevel == 0) {
    {
#line 2246
    bug("#endif without #if");
    }
  }
#line 2247
  iflevel --;
#line 2248
  goto switch_break;
  case_7: /* CIL Label */ 
#line 2251
  if (! commented[iflevel]) {
#line 2254
    if (nparam == 2) {
#line 2254
      if ((int )WarningLevel > 0) {
        {
#line 2255
        warning("Extra argument to #include ignored");
        }
      }
    }
    {
#line 2256
    tmp___37 = whiteout(& p1start, & p1end);
    }
#line 2256
    if (! tmp___37) {
      {
#line 2256
      bug("Missing file name in #include");
      }
    }
    {
#line 2258
    tmp___38 = getChar(p1start);
    }
#line 2258
    if ((int )tmp___38 == 34) {
      {
#line 2258
      tmp___39 = getChar(p1end - 1);
      }
#line 2258
      if ((int )tmp___39 == 34) {
#line 2260
        p1start ++;
#line 2260
        p1end --;
      } else {
#line 2258
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2258
      tmp___40 = getChar(p1start);
      }
#line 2258
      if ((int )tmp___40 == 60) {
        {
#line 2258
        tmp___41 = getChar(p1end - 1);
        }
#line 2258
        if ((int )tmp___41 == 62) {
#line 2260
          p1start ++;
#line 2260
          p1end --;
        }
      }
    }
#line 2261
    if (p1start >= p1end) {
      {
#line 2261
      bug("Missing file name in #include");
      }
    }
    {
#line 2262
    tmp___42 = malloc((size_t )((p1end - p1start) + 1));
#line 2262
    incfile_name = (char *)tmp___42;
#line 2264
    i = 0;
    }
    {
#line 2264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2264
      if (! (i < p1end - p1start)) {
#line 2264
        goto while_break___1;
      }
      {
#line 2265
      *(incfile_name + i) = getChar(p1start + i);
#line 2264
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2266
    *(incfile_name + (p1end - p1start)) = (char)0;
#line 2268
    DoInclude(incfile_name);
    }
  } else {
    {
#line 2270
    replace_directive_with_blank_line((C->out)->f);
    }
  }
#line 2271
  goto switch_break;
  case_8: /* CIL Label */ 
#line 2274
  if (! commented[iflevel]) {
#line 2275
    if (! execallowed) {
      {
#line 2276
      warning("Not allowed to #exec. Command output will be left blank");
      }
    } else {
      {
#line 2281
      s = ProcessText((char const   *)(C->buf + p1start), p1end - p1start, 0);
      }
#line 2282
      if (nparam == 2) {
        {
#line 2283
        t = ProcessText((char const   *)(C->buf + p2start), p2end - p2start, 0);
#line 2284
        tmp___43 = strlen((char const   *)s);
#line 2284
        i = (int )tmp___43;
#line 2285
        tmp___44 = strlen((char const   *)t);
#line 2285
        tmp___45 = realloc((void *)s, ((size_t )i + tmp___44) + 2UL);
#line 2285
        s = (char *)tmp___45;
#line 2286
        *(s + i) = (char )' ';
#line 2287
        strcpy((char */* __restrict  */)((s + i) + 1), (char const   */* __restrict  */)t);
#line 2288
        free((void *)t);
        }
      }
      {
#line 2290
      f = popen((char const   *)s, "r");
#line 2291
      free((void *)s);
      }
#line 2292
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 2292
        warning("Cannot #exec. Command not found(?)");
        }
      } else {
        {
#line 2294
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 2294
          c = fgetc(f);
          }
#line 2294
          if (! (c != -1)) {
#line 2294
            goto while_break___2;
          }
          {
#line 2294
          outchar((char )c);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2295
        pclose(f);
        }
      }
    }
  }
#line 2299
  goto switch_break;
  case_9: /* CIL Label */ 
#line 2302
  if (! commented[iflevel]) {
    {
#line 2303
    whiteout(& p1start, & p1end);
    }
#line 2304
    if (p1start == p1end) {
      {
#line 2305
      bug("#defeval requires an identifier (A-Z,a-z,0-9,_ only)");
      }
    } else {
      {
#line 2304
      tmp___46 = identifierEnd(p1start);
      }
#line 2304
      if (tmp___46 != p1end) {
        {
#line 2305
        bug("#defeval requires an identifier (A-Z,a-z,0-9,_ only)");
        }
      }
    }
    {
#line 2306
    tmpbuf = ProcessText((char const   *)(C->buf + p2start), p2end - p2start, 0);
#line 2307
    i = findIdent((char const   *)(C->buf + p1start), p1end - p1start);
    }
#line 2308
    if (i >= 0) {
      {
#line 2308
      delete_macro(i);
      }
    }
    {
#line 2309
    newmacro((char const   *)(C->buf + p1start), p1end - p1start, 1);
    }
#line 2310
    if (nparam == 1) {
#line 2310
      p2start = p1end;
#line 2310
      p2end = p2start;
    }
    {
#line 2311
    replace_definition_with_blank_lines((char const   *)(C->buf + 1), (char const   *)(C->buf + p2end),
                                        S->preservelf);
#line 2312
    (macros + nmacros)->macrotext = tmpbuf;
#line 2313
    tmp___47 = strlen((char const   *)(macros + nmacros)->macrotext);
#line 2313
    (macros + nmacros)->macrolen = (int )tmp___47;
#line 2314
    (macros + nmacros)->defined_in_comment = C->in_comment;
    }
#line 2316
    if (argc) {
#line 2317
      j = 0;
      {
#line 2317
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2317
        if (! (j < argc)) {
#line 2317
          goto while_break___3;
        }
        {
#line 2317
        whiteout(argb + j, arge + j);
#line 2317
        j ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2319
      if (argc == 1) {
#line 2319
        if (arge[0] == argb[0]) {
#line 2319
          argc = 0;
        }
      }
      {
#line 2320
      tmp___48 = malloc((unsigned long )(argc + 1) * sizeof(char *));
#line 2320
      (macros + nmacros)->argnames = (char **)tmp___48;
#line 2321
      *((macros + nmacros)->argnames + argc) = (char *)((void *)0);
      }
    }
#line 2323
    (macros + nmacros)->nnamedargs = argc;
#line 2324
    j = 0;
    {
#line 2324
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2324
      if (! (j < argc)) {
#line 2324
        goto while_break___4;
      }
#line 2325
      if (argb[j] == arge[j]) {
        {
#line 2326
        bug("#defeval with named args needs identifiers as arg names");
        }
      } else {
        {
#line 2325
        tmp___49 = identifierEnd(argb[j]);
        }
#line 2325
        if (tmp___49 != arge[j]) {
          {
#line 2326
          bug("#defeval with named args needs identifiers as arg names");
          }
        }
      }
      {
#line 2327
      tmp___50 = malloc((size_t )((arge[j] - argb[j]) + 1));
#line 2327
      *((macros + nmacros)->argnames + j) = (char *)tmp___50;
#line 2328
      memcpy((void */* __restrict  */)*((macros + nmacros)->argnames + j), (void const   */* __restrict  */)(C->buf + argb[j]),
             (size_t )(arge[j] - argb[j]));
#line 2329
      *(*((macros + nmacros)->argnames + j) + (arge[j] - argb[j])) = (char)0;
#line 2324
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2331
    tmp___51 = nmacros;
#line 2331
    nmacros ++;
#line 2331
    lookupArgRefs(tmp___51);
    }
  } else {
    {
#line 2333
    replace_directive_with_blank_line((C->out)->f);
    }
  }
#line 2334
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 2337
  replace_directive_with_blank_line((C->out)->f);
#line 2338
  iflevel ++;
  }
#line 2339
  if (iflevel == 50) {
    {
#line 2339
    bug("Too many nested #ifeqs");
    }
  }
#line 2340
  commented[iflevel] = commented[iflevel - 1];
#line 2341
  if (! commented[iflevel]) {
#line 2343
    if (nparam != 2) {
      {
#line 2343
      bug("#ifeq requires two arguments");
      }
    }
    {
#line 2344
    s___0 = ProcessText((char const   *)(C->buf + p1start), p1end - p1start, 0);
#line 2345
    t___0 = ProcessText((char const   *)(C->buf + p2start), p2end - p2start, 0);
#line 2346
    tmp___52 = nowhite_strcmp(s___0, t___0);
#line 2346
    commented[iflevel] = tmp___52 != 0;
#line 2347
    free((void *)s___0);
#line 2347
    free((void *)t___0);
    }
  }
#line 2349
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2352
  replace_directive_with_blank_line((C->out)->f);
#line 2353
  iflevel ++;
  }
#line 2354
  if (iflevel == 50) {
    {
#line 2354
    bug("Too many nested #ifeqs");
    }
  }
#line 2355
  commented[iflevel] = commented[iflevel - 1];
#line 2356
  if (! commented[iflevel]) {
#line 2358
    if (nparam != 2) {
      {
#line 2358
      bug("#ifneq requires two arguments");
      }
    }
    {
#line 2359
    s___1 = ProcessText((char const   *)(C->buf + p1start), p1end - p1start, 0);
#line 2360
    t___1 = ProcessText((char const   *)(C->buf + p2start), p2end - p2start, 0);
#line 2361
    tmp___53 = nowhite_strcmp(s___1, t___1);
#line 2361
    commented[iflevel] = tmp___53 == 0;
#line 2362
    free((void *)s___1);
#line 2362
    free((void *)t___1);
    }
  }
#line 2364
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2367
  if (! commented[iflevel]) {
#line 2369
    if (nparam == 2) {
#line 2369
      p1end = p2end;
    }
    {
#line 2370
    s___2 = ArithmEval(p1start, p1end);
#line 2371
    t___2 = s___2;
    }
    {
#line 2371
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2371
      if (! *t___2) {
#line 2371
        goto while_break___5;
      }
      {
#line 2371
      outchar(*t___2);
#line 2371
      t___2 ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 2372
    free((void *)s___2);
    }
  }
#line 2374
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 2377
  replace_directive_with_blank_line((C->out)->f);
#line 2378
  iflevel ++;
  }
#line 2379
  if (iflevel == 50) {
    {
#line 2379
    bug("Too many nested #ifs");
    }
  }
#line 2380
  commented[iflevel] = commented[iflevel - 1];
#line 2381
  if (! commented[iflevel]) {
#line 2383
    if (nparam == 2) {
#line 2383
      p1end = p2end;
    }
    {
#line 2384
    s___3 = ArithmEval(p1start, p1end);
    }
#line 2385
    if ((int )*(s___3 + 0) == 48) {
#line 2385
      if ((int )*(s___3 + 1) == 0) {
#line 2385
        tmp___54 = 1;
      } else {
#line 2385
        tmp___54 = 0;
      }
    } else {
#line 2385
      tmp___54 = 0;
    }
    {
#line 2385
    commented[iflevel] = tmp___54;
#line 2386
    free((void *)s___3);
    }
  }
#line 2388
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 2391
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2392
  if (nparam == 1) {
#line 2392
    p2start = -1;
  }
#line 2393
  if (! commented[iflevel]) {
    {
#line 2394
    ProcessModeCommand(p1start, p1end, p2start, p2end);
    }
  }
  {
#line 2395
  PopSpecs();
  }
#line 2396
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 2400
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d", C->lineno);
#line 2401
  replace_directive_with_blank_line((C->out)->f);
#line 2402
  tmp___55 = strlen((char const   *)(buf));
#line 2402
  sendout((char const   *)(buf), (int )tmp___55, 0);
  }
#line 2404
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 2407
  replace_directive_with_blank_line((C->out)->f);
#line 2408
  tmp___56 = strlen((char const   *)C->filename);
#line 2408
  sendout((char const   *)C->filename, (int )tmp___56, 0);
  }
#line 2409
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 2412
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2413
  if (iflevel == 0) {
    {
#line 2413
    bug("#elif without #if");
    }
  }
#line 2414
  if (! commented[iflevel - 1]) {
#line 2415
    if (commented[iflevel] != 1) {
#line 2415
      commented[iflevel] = 2;
    } else {
#line 2418
      commented[iflevel] = 0;
#line 2419
      if (nparam == 2) {
#line 2419
        p1end = p2end;
      }
      {
#line 2420
      s___4 = ArithmEval(p1start, p1end);
      }
#line 2421
      if ((int )*(s___4 + 0) == 48) {
#line 2421
        if ((int )*(s___4 + 1) == 0) {
#line 2421
          tmp___57 = 1;
        } else {
#line 2421
          tmp___57 = 0;
        }
      } else {
#line 2421
        tmp___57 = 0;
      }
      {
#line 2421
      commented[iflevel] = tmp___57;
#line 2422
      free((void *)s___4);
      }
    }
  }
#line 2425
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 2428
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2429
  if (! commented[iflevel]) {
#line 2430
    if (nparam == 2) {
#line 2430
      tmp___58 = p2end;
    } else {
#line 2430
      tmp___58 = p1end;
    }
    {
#line 2430
    tmp___59 = ProcessText((char const   *)(C->buf + p1start), tmp___58 - p1start,
                           0);
#line 2430
    bug((char const   *)tmp___59);
    }
  }
#line 2433
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 2436
  replace_directive_with_blank_line((C->out)->f);
  }
#line 2437
  if (! commented[iflevel]) {
#line 2439
    if (nparam == 2) {
#line 2439
      tmp___60 = p2end;
    } else {
#line 2439
      tmp___60 = p1end;
    }
    {
#line 2439
    s___5 = ProcessText((char const   *)(C->buf + p1start), tmp___60 - p1start, 0);
#line 2442
    warning((char const   *)s___5);
#line 2443
    free((void *)s___5);
    }
  }
#line 2445
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2450
  tmp___61 = time((time_t *)((void *)0));
#line 2450
  now = tmp___61;
  }
#line 2451
  if (nparam == 2) {
#line 2451
    tmp___62 = p2end;
  } else {
#line 2451
    tmp___62 = p1end;
  }
  {
#line 2451
  fmt = ProcessText((char const   *)(C->buf + p1start), tmp___62 - p1start, 0);
#line 2454
  tmp___63 = localtime((time_t const   *)(& now));
#line 2454
  tmp___64 = strftime((char */* __restrict  */)(buf___0), (size_t )1024, (char const   */* __restrict  */)fmt,
                      (struct tm  const  */* __restrict  */)tmp___63);
  }
#line 2454
  if (! tmp___64) {
    {
#line 2455
    bug("date buffer exceeded");
    }
  }
  {
#line 2456
  replace_directive_with_blank_line((C->out)->f);
#line 2457
  tmp___65 = strlen((char const   *)(buf___0));
#line 2457
  sendout((char const   *)(buf___0), (int )tmp___65, 0);
#line 2458
  free((void *)fmt);
  }
#line 2460
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2462
  bug("Internal meta-macro identification error");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 2464
  shiftIn(macend);
  }
#line 2465
  return (0);
}
}
#line 2468 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int ParsePossibleUser(void) 
{ 
  int idstart ;
  int idend ;
  int sh_end ;
  int lg_end ;
  int macend ;
  int argc ;
  int id ;
  int i ;
  int l ;
  char *argv[100] ;
  int argb[100] ;
  int arge[100] ;
  struct INPUTCONTEXT *T ;
  int tmp ;
  size_t tmp___0 ;
  char *s ;
  char *t ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;

  {
  {
#line 2476
  idstart = 1;
#line 2477
  id = 0;
#line 2478
  tmp = SplicePossibleUser(& idstart, & idend, & sh_end, & lg_end, argb, arge, & argc,
                           1, & id, 1);
  }
#line 2478
  if (! tmp) {
#line 2480
    return (-1);
  }
#line 2481
  if (sh_end >= 0) {
#line 2481
    if ((unsigned long )C->namedargs != (unsigned long )((void *)0)) {
      {
#line 2482
      i = findNamedArg((char const   *)(C->buf + idstart), idend - idstart);
      }
#line 2483
      if (i >= 0) {
#line 2484
        if (i < C->argc) {
          {
#line 2484
          tmp___0 = strlen((char const   *)*(C->argv + i));
#line 2484
          sendout((char const   *)*(C->argv + i), (int )tmp___0, 0);
          }
        }
        {
#line 2485
        shiftIn(sh_end);
        }
#line 2486
        return (0);
      }
    }
  }
#line 2490
  if (id < 0) {
#line 2490
    return (-1);
  }
#line 2491
  if (lg_end >= 0) {
#line 2491
    macend = lg_end;
  } else {
#line 2491
    macend = sh_end;
#line 2491
    argc = 0;
  }
#line 2493
  if ((macros + id)->nnamedargs == -2) {
#line 2495
    if (argc != 1) {
#line 2495
      return (-1);
    }
    {
#line 2496
    s = remove_comments(argb[0], arge[0], 1);
#line 2497
    tmp___1 = strlen((char const   *)s);
#line 2497
    t = (s + tmp___1) - 1;
    }
#line 2498
    if ((int )*s != 0) {
      {
#line 2498
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2498
        if ((unsigned long )t != (unsigned long )s) {
          {
#line 2498
          tmp___3 = iswhite(*t);
          }
#line 2498
          if (! tmp___3) {
#line 2498
            goto while_break;
          }
        } else {
#line 2498
          goto while_break;
        }
#line 2498
        tmp___2 = t;
#line 2498
        t --;
#line 2498
        *tmp___2 = (char)0;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2499
    t = s;
    {
#line 2499
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2499
      tmp___4 = iswhite(*t);
      }
#line 2499
      if (! tmp___4) {
#line 2499
        goto while_break___0;
      }
#line 2499
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2500
    tmp___5 = strlen((char const   *)t);
#line 2500
    tmp___6 = findIdent((char const   *)t, (int )tmp___5);
    }
#line 2500
    if (tmp___6 >= 0) {
      {
#line 2500
      outchar((char )'1');
      }
    } else {
      {
#line 2501
      outchar((char )'0');
      }
    }
    {
#line 2502
    free((void *)s);
#line 2503
    shiftIn(macend);
    }
#line 2504
    return (0);
  }
#line 2506
  if (! *((macros + id)->macrotext + 0)) {
    {
#line 2507
    shiftIn(macend);
    }
#line 2508
    return (0);
  }
#line 2511
  i = 0;
  {
#line 2511
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2511
    if (! (i < argc)) {
#line 2511
      goto while_break___1;
    }
    {
#line 2512
    argv[i] = ProcessText((char const   *)(C->buf + argb[i]), arge[i] - argb[i], 1);
#line 2511
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2514
  T = C;
#line 2515
  tmp___7 = malloc(sizeof(*C));
#line 2515
  C = (struct INPUTCONTEXT *)tmp___7;
#line 2516
  C->out = T->out;
#line 2517
  C->in = (FILE *)((void *)0);
#line 2518
  C->argc = argc;
#line 2519
  C->argv = argv;
#line 2520
  C->filename = T->filename;
#line 2521
  C->lineno = T->lineno;
#line 2522
  C->may_have_args = 1;
  }
#line 2523
  if ((macros + id)->nnamedargs == -1) {
#line 2523
    if (lg_end >= 0) {
#line 2523
      if ((int )*(((macros + id)->define_specs)->User.mEnd + 0) == 0) {
        {
#line 2526
        tmp___8 = strlen((char const   *)(macros + id)->macrotext);
#line 2526
        tmp___9 = strlen((char const   *)((macros + id)->define_specs)->User.mArgS);
#line 2526
        tmp___10 = strlen((char const   *)((macros + id)->define_specs)->User.mArgE);
#line 2526
        tmp___11 = strlen((char const   *)((macros + id)->define_specs)->User.mArgSep);
#line 2526
        l = (int )((((tmp___8 + 2UL) + tmp___9) + tmp___10) + (size_t )(argc - 1) * tmp___11);
#line 2530
        i = 0;
        }
        {
#line 2530
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2530
          if (! (i < argc)) {
#line 2530
            goto while_break___2;
          }
          {
#line 2530
          tmp___12 = strlen((char const   *)argv[i]);
#line 2530
          l = (int )((size_t )l + tmp___12);
#line 2530
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2531
        tmp___14 = malloc((size_t )l);
#line 2531
        tmp___13 = (char *)tmp___14;
#line 2531
        C->malloced_buf = tmp___13;
#line 2531
        C->buf = tmp___13;
#line 2532
        tmp___15 = strlen((char const   *)(macros + id)->macrotext);
#line 2532
        l = (int )(tmp___15 + 1UL);
#line 2533
        *(C->buf + 0) = (char )'\n';
#line 2534
        strcpy((char */* __restrict  */)(C->buf + 1), (char const   */* __restrict  */)(macros + id)->macrotext);
        }
        {
#line 2535
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2535
          if (l > 1) {
            {
#line 2535
            tmp___16 = iswhite(*(C->buf + (l - 1)));
            }
#line 2535
            if (! tmp___16) {
#line 2535
              goto while_break___3;
            }
          } else {
#line 2535
            goto while_break___3;
          }
#line 2535
          l --;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 2536
        strcpy((char */* __restrict  */)(C->buf + l), (char const   */* __restrict  */)((macros + id)->define_specs)->User.mArgS);
#line 2537
        i = 0;
        }
        {
#line 2537
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2537
          if (! (i < argc)) {
#line 2537
            goto while_break___4;
          }
#line 2538
          if (i > 0) {
            {
#line 2538
            strcat((char */* __restrict  */)C->buf, (char const   */* __restrict  */)((macros + id)->define_specs)->User.mArgSep);
            }
          }
          {
#line 2539
          strcat((char */* __restrict  */)C->buf, (char const   */* __restrict  */)argv[i]);
#line 2537
          i ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2541
        strcat((char */* __restrict  */)C->buf, (char const   */* __restrict  */)((macros + id)->define_specs)->User.mArgE);
#line 2542
        C->may_have_args = 0;
        }
      } else {
#line 2523
        goto _L___0;
      }
    } else {
#line 2523
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 2545
    tmp___18 = strlen((char const   *)(macros + id)->macrotext);
#line 2545
    tmp___19 = malloc(tmp___18 + 2UL);
#line 2545
    tmp___17 = (char *)tmp___19;
#line 2545
    C->malloced_buf = tmp___17;
#line 2545
    C->buf = tmp___17;
#line 2546
    *(C->buf + 0) = (char )'\n';
#line 2547
    strcpy((char */* __restrict  */)(C->buf + 1), (char const   */* __restrict  */)(macros + id)->macrotext);
    }
  }
  {
#line 2549
  tmp___20 = strlen((char const   *)C->buf);
#line 2549
  C->len = (int )tmp___20;
#line 2550
  C->bufsize = C->len + 1;
#line 2551
  C->eof = 0;
#line 2552
  C->namedargs = (macros + id)->argnames;
#line 2553
  C->in_comment = (macros + id)->defined_in_comment;
#line 2554
  C->ambience = 0;
#line 2555
  PushSpecs((struct SPECS  const  *)(macros + id)->define_specs);
#line 2556
  ProcessContext();
#line 2557
  PopSpecs();
#line 2558
  free((void *)C);
#line 2559
  C = T;
#line 2561
  i = 0;
  }
  {
#line 2561
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2561
    if (! (i < argc)) {
#line 2561
      goto while_break___5;
    }
    {
#line 2561
    free((void *)argv[i]);
#line 2561
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 2562
  shiftIn(macend);
  }
#line 2563
  return (0);
}
}
#line 2566 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void ParseText(void) 
{ 
  int l ;
  int cs ;
  int ce ;
  char c ;
  char *s ;
  struct COMMENT *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 2573
  if (! C->in_comment) {
#line 2574
    cs = 1;
#line 2575
    p = S->comments;
    {
#line 2575
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2575
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 2575
        goto while_break;
      }
#line 2576
      if (! (p->flags[C->ambience] & 64)) {
        {
#line 2577
        tmp___0 = matchStartSequence((char const   *)p->start, & cs);
        }
#line 2577
        if (tmp___0) {
          {
#line 2578
          ce = findCommentEnd((char const   *)p->end, p->quote, p->warn, cs, p->flags[C->ambience]);
#line 2578
          l = ce;
#line 2579
          matchEndSequence((char const   *)p->end, & l);
          }
#line 2580
          if (p->flags[C->ambience] & 2) {
            {
#line 2581
            sendout((char const   *)(C->buf + 1), cs - 1, 0);
            }
          }
#line 2582
          if (! (p->flags[C->ambience] & 1)) {
            {
#line 2583
            replace_definition_with_blank_lines((char const   *)(C->buf + 1), (char const   *)((C->buf + ce) - 1),
                                                0);
            }
          }
#line 2584
          if (p->flags[C->ambience] & 4) {
            {
#line 2585
            C->in_comment = 1;
#line 2586
            s = ProcessText((char const   *)(C->buf + cs), ce - cs, C->ambience);
            }
#line 2587
            if (p->flags[C->ambience] & 1) {
              {
#line 2587
              tmp = strlen((char const   *)s);
#line 2587
              sendout((char const   *)s, (int )tmp, 0);
              }
            }
            {
#line 2588
            C->in_comment = 0;
#line 2589
            free((void *)s);
            }
          } else
#line 2591
          if (p->flags[C->ambience] & 1) {
            {
#line 2592
            sendout((char const   *)(C->buf + cs), ce - cs, 0);
            }
          }
#line 2593
          if (p->flags[C->ambience] & 2) {
            {
#line 2594
            sendout((char const   *)(C->buf + ce), l - ce, 0);
            }
          }
          {
#line 2595
          shiftIn(l);
          }
#line 2596
          return;
        }
      }
#line 2575
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2600
  tmp___1 = ParsePossibleMeta();
  }
#line 2600
  if (tmp___1 >= 0) {
#line 2600
    return;
  }
  {
#line 2601
  tmp___2 = ParsePossibleUser();
  }
#line 2601
  if (tmp___2 >= 0) {
#line 2601
    return;
  }
  {
#line 2603
  l = 1;
#line 2605
  tmp___4 = matchSequence((char const   *)S->User.mArgRef, & l);
  }
#line 2605
  if (tmp___4) {
#line 2605
    if (C->may_have_args) {
      {
#line 2607
      c = getChar(l);
      }
#line 2608
      if ((int )c >= 49) {
#line 2608
        if ((int )c <= 57) {
#line 2609
          c = (char )((int )c - 49);
#line 2610
          if ((int )c < C->argc) {
            {
#line 2611
            tmp___3 = strlen((char const   *)*(C->argv + (int )c));
#line 2611
            sendout((char const   *)*(C->argv + (int )c), (int )tmp___3, 0);
            }
          }
          {
#line 2612
          shiftIn(l + 1);
          }
#line 2613
          return;
        }
      }
    }
  }
  {
#line 2617
  l = identifierEnd(1);
  }
#line 2618
  if (l == 1) {
#line 2618
    l = 2;
  }
  {
#line 2619
  sendout((char const   *)(C->buf + 1), l - 1, 1);
#line 2620
  shiftIn(l);
  }
#line 2621
  return;
}
}
#line 2623 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void ProcessContext(void) 
{ 


  {
#line 2625
  if (C->len == 0) {
#line 2625
    *(C->buf + 0) = (char )'\n';
#line 2625
    (C->len) ++;
  }
  {
#line 2626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2626
    if (! (! C->eof)) {
#line 2626
      goto while_break;
    }
    {
#line 2626
    ParseText();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2627
  if ((unsigned long )C->in != (unsigned long )((void *)0)) {
    {
#line 2627
    fclose(C->in);
    }
  }
  {
#line 2628
  free((void *)C->malloced_buf);
  }
#line 2629
  return;
}
}
#line 2634 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
static void getDirname(char const   *fname , char *dirname ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 2638
  tmp = strlen(fname);
#line 2638
  i = (int )(tmp - 1UL);
  }
  {
#line 2638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2638
    if (! (i >= 0)) {
#line 2638
      goto while_break;
    }
#line 2639
    if ((int const   )*(fname + i) == 47) {
#line 2640
      goto while_break;
    }
#line 2638
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 2642
  if (i >= 0) {
    {
#line 2643
    strncpy((char */* __restrict  */)dirname, (char const   */* __restrict  */)fname,
            (size_t )i);
#line 2644
    *(dirname + i) = (char )'/';
    }
  } else {
#line 2647
    i = -1;
  }
#line 2649
  *(dirname + (i + 1)) = (char )'\000';
#line 2650
  return;
}
}
#line 2652 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
static FILE *openInCurrentDir(char const   *incfile ) 
{ 
  char *absfile ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  FILE *f ;

  {
  {
#line 2654
  tmp = strlen((char const   *)C->filename);
#line 2654
  tmp___0 = strlen(incfile);
#line 2654
  tmp___1 = calloc((tmp + tmp___0) + 1UL, (size_t )1);
#line 2654
  absfile = (char *)tmp___1;
#line 2657
  getDirname((char const   *)C->filename, absfile);
#line 2658
  strcat((char */* __restrict  */)absfile, (char const   */* __restrict  */)incfile);
#line 2659
  f = fopen((char const   */* __restrict  */)absfile, (char const   */* __restrict  */)"r");
#line 2660
  free((void *)absfile);
  }
#line 2661
  return (f);
}
}
#line 2665 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void replace_definition_with_blank_lines(char const   *start , char const   *end ,
                                         int skip ) 
{ 


  {
#line 2667
  if ((unsigned long )include_directive_marker != (unsigned long )((void *)0)) {
#line 2667
    if ((unsigned long )(C->out)->f != (unsigned long )((void *)0)) {
      {
#line 2668
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2668
        if (! ((unsigned long )start <= (unsigned long )end)) {
#line 2668
          goto while_break;
        }
#line 2669
        if ((int const   )*start == 10) {
#line 2670
          if (skip) {
#line 2670
            skip --;
          } else {
            {
#line 2670
            fprintf((FILE */* __restrict  */)(C->out)->f, (char const   */* __restrict  */)"\n");
            }
          }
        }
#line 2672
        start ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2675
  return;
}
}
#line 2680 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void replace_directive_with_blank_line(FILE *f ) 
{ 


  {
#line 2682
  if ((unsigned long )include_directive_marker != (unsigned long )((void *)0)) {
#line 2682
    if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 2682
      if (! S->preservelf) {
#line 2682
        if ((int )*(S->Meta.mArgE + 0) == 10) {
          {
#line 2684
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
          }
        }
      }
    }
  }
#line 2686
  return;
}
}
#line 2692 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
static char lineno_buf[15]  ;
#line 2693
void write_include_marker(FILE *f , int lineno , char *filename , char const   *marker ) ;
#line 2693 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
static char *escapedfilename  =    (char *)((void *)0);
#line 2690 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void write_include_marker(FILE *f , int lineno , char *filename , char const   *marker ) 
{ 


  {
#line 2695
  if ((unsigned long )include_directive_marker != (unsigned long )((void *)0)) {
#line 2695
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 2699
      escapedfilename = filename;
#line 2701
      sprintf((char */* __restrict  */)(lineno_buf), (char const   */* __restrict  */)"%d",
              lineno);
#line 2702
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)include_directive_marker,
              lineno_buf, escapedfilename, marker);
      }
    }
  }
#line 2704
  return;
}
}
#line 2710 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void escape_backslashes(char const   *instr , char **outstr ) 
{ 
  int out_idx ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 2712
  out_idx = 0;
#line 2714
  if ((unsigned long )*outstr != (unsigned long )((void *)0)) {
    {
#line 2714
    free((void *)*outstr);
    }
  }
  {
#line 2715
  tmp = strlen(instr);
#line 2715
  tmp___0 = malloc(2UL * tmp);
#line 2715
  *outstr = (char *)tmp___0;
  }
  {
#line 2717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2717
    if (! ((int const   )*instr != 0)) {
#line 2717
      goto while_break;
    }
#line 2718
    if ((int const   )*instr == 92) {
#line 2719
      *(*outstr + out_idx) = (char )'\\';
#line 2720
      out_idx ++;
    }
#line 2722
    *(*outstr + out_idx) = (char )*instr;
#line 2723
    out_idx ++;
#line 2724
    instr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2726
  *(*outstr + out_idx) = (char )'\000';
#line 2727
  return;
}
}
#line 2734 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
void construct_include_directive_marker(char **include_directive_marker___0 , char const   *includemarker_input ) 
{ 
  int len ;
  size_t tmp ;
  char ch ;
  int in_idx ;
  int out_idx ;
  int quoted ;
  int num_repl ;
  void *tmp___0 ;

  {
  {
#line 2737
  tmp = strlen(includemarker_input);
#line 2737
  len = (int )tmp;
#line 2739
  in_idx = 0;
#line 2739
  out_idx = 0;
#line 2740
  quoted = 0;
#line 2740
  num_repl = 0;
#line 2743
  tmp___0 = malloc((size_t )(len + 18));
#line 2743
  *include_directive_marker___0 = (char *)tmp___0;
#line 2745
  ch = (char )*includemarker_input;
  }
  {
#line 2746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2746
    if ((int )ch != 0) {
#line 2746
      if (! (in_idx < len)) {
#line 2746
        goto while_break;
      }
    } else {
#line 2746
      goto while_break;
    }
#line 2747
    if (quoted) {
#line 2748
      *(*include_directive_marker___0 + out_idx) = ch;
#line 2749
      out_idx ++;
#line 2750
      quoted = 0;
    } else {
      {
#line 2753
      if ((int )ch == 92) {
#line 2753
        goto case_92;
      }
#line 2756
      if ((int )ch == 64) {
#line 2756
        goto case_64;
      }
#line 2761
      if ((int )ch == 63) {
#line 2761
        goto case_63;
      }
#line 2761
      if ((int )ch == 37) {
#line 2761
        goto case_63;
      }
#line 2768
      goto switch_default;
      case_92: /* CIL Label */ 
#line 2754
      quoted = 1;
#line 2755
      goto switch_break;
      case_64: /* CIL Label */ 
#line 2757
      *(*include_directive_marker___0 + out_idx) = (char )' ';
#line 2758
      out_idx ++;
#line 2759
      goto switch_break;
      case_63: /* CIL Label */ 
      case_37: /* CIL Label */ 
#line 2762
      *(*include_directive_marker___0 + out_idx) = (char )'%';
#line 2763
      out_idx ++;
#line 2764
      *(*include_directive_marker___0 + out_idx) = (char )'s';
#line 2765
      out_idx ++;
#line 2766
      num_repl ++;
#line 2766
      if (num_repl > 3) {
        {
#line 2766
        bug("only 3 substitutions allowed in -includemarker");
        }
      }
#line 2767
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2769
      *(*include_directive_marker___0 + out_idx) = ch;
#line 2770
      out_idx ++;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2774
    in_idx ++;
#line 2775
    ch = (char )*(includemarker_input + in_idx);
  }
  while_break: /* CIL Label */ ;
  }
#line 2778
  *(*include_directive_marker___0 + out_idx) = (char )'\n';
#line 2779
  out_idx ++;
#line 2780
  *(*include_directive_marker___0 + out_idx) = (char )'\000';
#line 2781
  return;
}
}
#line 2784 "/home/june/repo/benchmarks/collector/temp/gpp-2.24/src/gpp.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 2786
  initthings(argc, argv);
  }
#line 2788
  if (IncludeFile) {
    {
#line 2789
    DoInclude(IncludeFile);
    }
  }
  {
#line 2790
  write_include_marker((C->out)->f, 1, C->filename, "");
#line 2791
  ProcessContext();
#line 2792
  fclose((C->out)->f);
  }
#line 2793
  return (0);
}
}
