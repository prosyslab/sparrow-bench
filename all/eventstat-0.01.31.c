/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 53 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct link {
   void *data ;
   struct link *next ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct link link_t;
#line 58 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct __anonstruct_list_t_54 {
   link_t *head ;
   link_t *tail ;
   size_t length ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct __anonstruct_list_t_54 list_t;
#line 66 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct timer_info {
   pid_t pid ;
   char *task ;
   char *cmdline ;
   char *func ;
   char *callback ;
   char *ident ;
   _Bool kernel_thread ;
   unsigned long total ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct timer_info timer_info_t;
#line 77 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct timer_stat {
   unsigned long count ;
   unsigned long delta ;
   timer_info_t *info ;
   struct timer_stat *next ;
   struct timer_stat *sorted_freq_next ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct timer_stat timer_stat_t;
#line 86 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct sample_delta_item {
   unsigned long delta ;
   timer_info_t *info ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct sample_delta_item sample_delta_item_t;
#line 92 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct sample_delta_list {
   struct timeval whence ;
   list_t list ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct sample_delta_list sample_delta_list_t;
#line 97 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
struct __anonstruct_kernel_task_info_55 {
   char *task ;
   size_t len ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
typedef struct __anonstruct_kernel_task_info_55 kernel_task_info;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static list_t timer_info_list  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static list_t sample_list  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static char *csv_results  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static _Bool volatile   stop_eventstat  =    (_Bool volatile   )0;
#line 108 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static double opt_threshold  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static unsigned int opt_flags  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static _Bool sane_procs  ;
#line 121
static _Bool sane_proc_pid_info(void) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static char const   pattern[11]  = 
#line 121
  {      (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'i',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'=',      (char const   )'\000'};
#line 118 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static _Bool sane_proc_pid_info(void) 
{ 
  FILE *fp ;
  char const   *ptr ;
  _Bool ret ;
  int ch ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 122
  ptr = pattern;
#line 123
  ret = (_Bool)1;
#line 125
  fp = fopen((char const   */* __restrict  */)"/proc/1/environ", (char const   */* __restrict  */)"r");
  }
#line 126
  if (! fp) {
#line 127
    return ((_Bool)0);
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___0 = feof(fp);
    }
#line 129
    if (tmp___0) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp = _IO_getc(fp);
#line 130
    ch = tmp;
    }
#line 132
    if ((int const   )*ptr == (int const   )ch) {
#line 133
      ptr ++;
#line 135
      if ((int const   )*ptr == 0) {
#line 136
        ret = (_Bool)0;
#line 137
        goto while_break;
      }
    } else {
      {
#line 141
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 142
        ch = _IO_getc(fp);
        }
#line 141
        if (ch != -1) {
#line 141
          if (! (ch != 0)) {
#line 141
            goto while_break___0;
          }
        } else {
#line 141
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 144
      ptr = pattern;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  fclose(fp);
  }
#line 150
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static struct timeval timeval_sub(struct timeval  const  *a , struct timeval  const  *b ) 
{ 
  struct timeval ret ;
  struct timeval _b ;
  int nsec ;
  int nsec___0 ;

  {
#line 161
  _b.tv_sec = (__time_t )b->tv_sec;
#line 162
  _b.tv_usec = (__suseconds_t )b->tv_usec;
#line 164
  if (a->tv_usec < (__suseconds_t const   )_b.tv_usec) {
#line 165
    nsec = (int )((_b.tv_usec - (__suseconds_t )a->tv_usec) / 1000000L + 1L);
#line 166
    _b.tv_sec += (__time_t )nsec;
#line 167
    _b.tv_usec -= (__suseconds_t )(1000000 * nsec);
  }
#line 169
  if (a->tv_usec - (__suseconds_t const   )_b.tv_usec > 1000000L) {
#line 170
    nsec___0 = (int )((a->tv_usec - (__suseconds_t const   )_b.tv_usec) / 1000000L);
#line 171
    _b.tv_sec -= (__time_t )nsec___0;
#line 172
    _b.tv_usec += (__suseconds_t )(1000000 * nsec___0);
  }
#line 175
  ret.tv_sec = (__time_t )(a->tv_sec - (__time_t const   )_b.tv_sec);
#line 176
  ret.tv_usec = (__suseconds_t )(a->tv_usec - (__suseconds_t const   )_b.tv_usec);
#line 178
  return (ret);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static struct timeval timeval_add(struct timeval  const  *a , struct timeval  const  *b ) 
{ 
  struct timeval ret ;
  int nsec ;

  {
#line 189
  ret.tv_sec = (__time_t )(a->tv_sec + b->tv_sec);
#line 190
  ret.tv_usec = (__suseconds_t )(a->tv_usec + b->tv_usec);
#line 191
  if (ret.tv_usec > 1000000L) {
#line 192
    nsec = (int )(ret.tv_usec / 1000000L);
#line 193
    ret.tv_sec += (__time_t )nsec;
#line 194
    ret.tv_usec -= (__suseconds_t )(1000000 * nsec);
  }
#line 197
  return (ret);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
__inline static double timeval_double(struct timeval  const  *tv ) 
{ 


  {
#line 206
  return ((double )tv->tv_sec + (double )tv->tv_usec / 1000000.0);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void set_timer_stat(char const   *str , _Bool const   carp ) 
{ 
  FILE *fp ;

  {
  {
#line 217
  fp = fopen((char const   */* __restrict  */)"/proc/timer_stats", (char const   */* __restrict  */)"w");
  }
#line 217
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 218
    if (carp) {
      {
#line 219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot write to %s\n",
              "/proc/timer_stats");
#line 220
      exit(1);
      }
    } else {
#line 222
      return;
    }
  }
  {
#line 225
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n", str);
#line 226
  fclose(fp);
  }
#line 227
  return;
}
}
#line 232
static  __attribute__((__noreturn__)) void eventstat_exit(int const   status ) ;
#line 238
static  __attribute__((__noreturn__)) void eventstat_exit(int const   status ) ;
#line 238 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void eventstat_exit(int const   status ) 
{ 


  {
  {
#line 240
  set_timer_stat("0", (_Bool const   )0);
#line 242
  exit((int )status);
  }
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
__inline static void list_init(list_t *list ) 
{ 


  {
#line 251
  list->head = (link_t *)((void *)0);
#line 252
  list->tail = (link_t *)((void *)0);
#line 253
  list->length = (size_t )0;
#line 254
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static link_t *list_append(list_t *list , void *data ) 
{ 
  link_t *link___0 ;
  void *tmp ;

  {
  {
#line 264
  tmp = calloc((size_t )1, sizeof(link_t ));
#line 264
  link___0 = (link_t *)tmp;
  }
#line 264
  if ((unsigned long )link___0 == (unsigned long )((void *)0)) {
    {
#line 265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate list link\n");
#line 266
    eventstat_exit((int const   )1);
    }
  }
#line 268
  link___0->data = data;
#line 270
  if ((unsigned long )list->head == (unsigned long )((void *)0)) {
#line 271
    list->head = link___0;
  } else {
#line 273
    (list->tail)->next = link___0;
  }
#line 275
  list->tail = link___0;
#line 276
  (list->length) ++;
#line 278
  return (link___0);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void list_free(list_t *list , void (* const  freefunc)(void * ) ) 
{ 
  link_t *link___0 ;
  link_t *next ;

  {
#line 289
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 290
    return;
  }
#line 292
  link___0 = list->head;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! link___0) {
#line 292
      goto while_break;
    }
#line 293
    next = link___0->next;
#line 294
    if (link___0->data) {
#line 294
      if (freefunc) {
        {
#line 295
        (*freefunc)(link___0->data);
        }
      }
    }
    {
#line 296
    free((void *)link___0);
#line 292
    link___0 = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void handle_sigint(int dummy ) 
{ 


  {
#line 308
  stop_eventstat = (_Bool volatile   )1;
#line 309
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void sample_delta_free(void *data ) 
{ 
  sample_delta_list_t *sdl ;

  {
  {
#line 317
  sdl = (sample_delta_list_t *)data;
#line 319
  list_free(& sdl->list, (void (*/* const  */)(void * ))(& free));
#line 320
  free((void *)sdl);
  }
#line 321
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void samples_free(void) 
{ 


  {
  {
#line 329
  list_free(& sample_list, (void (*/* const  */)(void * ))(& sample_delta_free));
  }
#line 330
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void sample_add(timer_stat_t *timer_stat , struct timeval *whence ) 
{ 
  link_t *link___0 ;
  _Bool found ;
  sample_delta_list_t *sdl ;
  sample_delta_item_t *sdi ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 339
  found = (_Bool)0;
#line 340
  sdl = (sample_delta_list_t *)((void *)0);
#line 343
  if ((unsigned long )csv_results == (unsigned long )((void *)0)) {
#line 344
    return;
  }
#line 346
  link___0 = sample_list.head;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! link___0) {
#line 346
      goto while_break;
    }
#line 347
    sdl = (sample_delta_list_t *)link___0->data;
#line 348
    if (sdl->whence.tv_sec == whence->tv_sec) {
#line 348
      if (sdl->whence.tv_usec == whence->tv_usec) {
#line 350
        found = (_Bool)1;
#line 351
        goto while_break;
      }
    }
#line 346
    link___0 = link___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if (! found) {
    {
#line 360
    tmp = calloc((size_t )1, sizeof(sample_delta_list_t ));
#line 360
    sdl = (sample_delta_list_t *)tmp;
    }
#line 360
    if ((unsigned long )sdl == (unsigned long )((void *)0)) {
      {
#line 361
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate sample delta list\n");
#line 362
      eventstat_exit((int const   )1);
      }
    }
    {
#line 364
    sdl->whence = *whence;
#line 365
    list_append(& sample_list, (void *)sdl);
    }
  }
  {
#line 369
  tmp___0 = calloc((size_t )1, sizeof(sample_delta_item_t ));
#line 369
  sdi = (sample_delta_item_t *)tmp___0;
  }
#line 369
  if ((unsigned long )sdi == (unsigned long )((void *)0)) {
    {
#line 370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate sample delta item\n");
#line 371
    eventstat_exit((int const   )1);
    }
  }
  {
#line 373
  sdi->delta = timer_stat->delta;
#line 374
  sdi->info = timer_stat->info;
#line 376
  list_append(& sdl->list, (void *)sdi);
  }
#line 377
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
__inline static sample_delta_item_t *sample_find(sample_delta_list_t *sdl , timer_info_t const   *info ) 
{ 
  link_t *link___0 ;
  sample_delta_item_t *sdi ;

  {
#line 387
  link___0 = sdl->list.head;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! link___0) {
#line 387
      goto while_break;
    }
#line 388
    sdi = (sample_delta_item_t *)link___0->data;
#line 389
    if ((unsigned long )sdi->info == (unsigned long )info) {
#line 390
      return (sdi);
    }
#line 387
    link___0 = link___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return ((sample_delta_item_t *)((void *)0));
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static int info_compare_total(void const   *item1 , void const   *item2 ) 
{ 
  timer_info_t **info1 ;
  timer_info_t **info2 ;

  {
#line 401
  info1 = (timer_info_t **)item1;
#line 402
  info2 = (timer_info_t **)item2;
#line 404
  return ((int )((*info2)->total - (*info1)->total));
}
}
#line 430
static _Bool pid_a_kernel_thread(char const   *task , pid_t const   id ) ;
#line 430 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static kernel_task_info kernel_tasks[23]  = 
#line 430
  {      {(char *)"swapper/", sizeof("swapper/") - 1UL}, 
        {(char *)"kworker/", sizeof("kworker/") - 1UL}, 
        {(char *)"ksoftirqd/", sizeof("ksoftirqd/") - 1UL}, 
        {(char *)"watchdog/", sizeof("watchdog/") - 1UL}, 
        {(char *)"migration/", sizeof("migration/") - 1UL}, 
        {(char *)"irq/", sizeof("irq/") - 1UL}, 
        {(char *)"mmcqd/", sizeof("mmcqd/") - 1UL}, 
        {(char *)"jbd2/", sizeof("jbd2/") - 1UL}, 
        {(char *)"kthreadd", sizeof("kthreadd") - 1UL}, 
        {(char *)"kthrotld", sizeof("kthrotld") - 1UL}, 
        {(char *)"kswapd", sizeof("kswapd") - 1UL}, 
        {(char *)"ecryptfs-kthrea", sizeof("ecryptfs-kthrea") - 1UL}, 
        {(char *)"kauditd", sizeof("kauditd") - 1UL}, 
        {(char *)"kblockd", sizeof("kblockd") - 1UL}, 
        {(char *)"kcryptd", sizeof("kcryptd") - 1UL}, 
        {(char *)"kdevtmpfs", sizeof("kdevtmpfs") - 1UL}, 
        {(char *)"khelper", sizeof("khelper") - 1UL}, 
        {(char *)"khubd", sizeof("khubd") - 1UL}, 
        {(char *)"khugepaged", sizeof("khugepaged") - 1UL}, 
        {(char *)"khungtaskd", sizeof("khungtaskd") - 1UL}, 
        {(char *)"flush-", sizeof("flush-") - 1UL}, 
        {(char *)"bdi-default-", sizeof("bdi-default-") - 1UL}, 
        {(char *)((void *)0), (size_t )0}};
#line 411 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static _Bool pid_a_kernel_thread(char const   *task , pid_t const   id ) 
{ 
  __pid_t tmp ;
  int i ;
  pid_t pgid ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
#line 413
  if (sane_procs) {
    {
#line 414
    tmp = getpgid((__pid_t )id);
    }
#line 414
    return ((_Bool )(tmp == 0));
  } else {
    {
#line 418
    tmp___0 = getpgid((__pid_t )id);
#line 418
    pgid = tmp___0;
    }
#line 421
    if (pgid >= 0) {
#line 422
      return ((_Bool )(pgid == 0));
    }
#line 456
    i = 0;
    {
#line 456
    while (1) {
      while_continue: /* CIL Label */ ;
#line 456
      if (! ((unsigned long )kernel_tasks[i].task != (unsigned long )((void *)0))) {
#line 456
        goto while_break;
      }
      {
#line 457
      tmp___1 = strncmp(task, (char const   *)kernel_tasks[i].task, kernel_tasks[i].len);
      }
#line 457
      if (tmp___1 == 0) {
#line 458
        return ((_Bool)1);
      }
#line 456
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 462
  return ((_Bool)0);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static char *get_pid_cmdline(pid_t const   id ) 
{ 
  char buffer[4096] ;
  char *ptr ;
  int fd ;
  ssize_t ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 476
  snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"/proc/%d/cmdline",
           id);
#line 478
  fd = open((char const   *)(buffer), 0);
  }
#line 478
  if (fd < 0) {
#line 479
    return ((char *)((void *)0));
  }
  {
#line 481
  ret = read(fd, (void *)(buffer), sizeof(buffer));
  }
#line 481
  if (ret <= 0L) {
    {
#line 482
    close(fd);
    }
#line 483
    return ((char *)((void *)0));
  }
  {
#line 485
  close(fd);
#line 487
  buffer[sizeof(buffer) - 1UL] = (char )'\000';
  }
#line 492
  if (opt_flags & 8U) {
#line 493
    ptr = buffer;
    {
#line 493
    while (1) {
      while_continue: /* CIL Label */ ;
#line 493
      if (! ((unsigned long )ptr < (unsigned long )((buffer + ret) - 1))) {
#line 493
        goto while_break;
      }
#line 494
      if ((int )*ptr == 0) {
#line 495
        *ptr = (char )' ';
      }
#line 493
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 497
    *ptr = (char )'\000';
  }
#line 502
  if (opt_flags & 4U) {
#line 503
    ptr = buffer;
    {
#line 503
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 503
      if (*ptr) {
#line 503
        if (! ((unsigned long )ptr < (unsigned long )(buffer + ret))) {
#line 503
          goto while_break___0;
        }
      } else {
#line 503
        goto while_break___0;
      }
#line 504
      if ((int )*ptr == 32) {
#line 505
        *ptr = (char )'\000';
      }
#line 503
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 509
  if (opt_flags & 16U) {
    {
#line 510
    tmp = __xpg_basename(buffer);
#line 510
    tmp___0 = strdup((char const   *)tmp);
    }
#line 510
    return (tmp___0);
  }
  {
#line 512
  tmp___1 = strdup((char const   *)(buffer));
  }
#line 512
  return (tmp___1);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void samples_dump(char const   *filename , struct timeval  const  *duration ) 
{ 
  sample_delta_list_t *sdl ;
  timer_info_t **sorted_timer_infos ;
  link_t *link___0 ;
  size_t i ;
  size_t n ;
  FILE *fp ;
  unsigned long count ;
  double dur ;
  _Bool dur_zero ;
  void *tmp ;
  timer_info_t *info ;
  size_t tmp___0 ;
  char *task ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  sample_delta_item_t *sdi ;
  sample_delta_item_t *tmp___4 ;
  double tmp___5 ;
  unsigned long min ;
  sample_delta_item_t *sdi___0 ;
  sample_delta_item_t *tmp___6 ;
  double tmp___7 ;
  unsigned long max ;
  sample_delta_item_t *sdi___1 ;
  sample_delta_item_t *tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double average ;
  double sum ;
  sample_delta_item_t *sdi___2 ;
  sample_delta_item_t *tmp___11 ;
  double diff ;
  double tmp___12 ;
  double tmp___13 ;

  {
#line 524
  i = (size_t )0;
#line 525
  n = timer_info_list.length;
#line 527
  count = 0UL;
#line 531
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 532
    return;
  }
  {
#line 534
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 534
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot write to file %s\n",
            filename);
    }
#line 536
    return;
  }
  {
#line 539
  tmp = calloc(n, sizeof(timer_info_t *));
#line 539
  sorted_timer_infos = (timer_info_t **)tmp;
  }
#line 539
  if ((unsigned long )sorted_timer_infos == (unsigned long )((void *)0)) {
    {
#line 540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate buffer for sorting timer_infos\n");
#line 541
    eventstat_exit((int const   )1);
    }
  }
#line 545
  n = (size_t )0;
#line 545
  link___0 = timer_info_list.head;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! link___0) {
#line 545
      goto while_break;
    }
#line 546
    info = (timer_info_t *)link___0->data;
#line 547
    if (info->total > 0UL) {
#line 548
      tmp___0 = n;
#line 548
      n ++;
#line 548
      *(sorted_timer_infos + tmp___0) = info;
    }
#line 545
    link___0 = link___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 551
  qsort((void *)sorted_timer_infos, n, sizeof(timer_info_t *), & info_compare_total);
#line 553
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Task:");
#line 554
  i = (size_t )0;
  }
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 554
    if (! (i < n)) {
#line 554
      goto while_break___0;
    }
#line 557
    if (opt_flags & 12U) {
#line 557
      if ((unsigned long )(*(sorted_timer_infos + i))->cmdline != (unsigned long )((void *)0)) {
#line 558
        task = (*(sorted_timer_infos + i))->cmdline;
      } else {
#line 560
        task = (*(sorted_timer_infos + i))->task;
      }
    } else {
#line 560
      task = (*(sorted_timer_infos + i))->task;
    }
    {
#line 562
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%s", task);
#line 554
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 564
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 566
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Init Function:");
#line 567
  i = (size_t )0;
  }
  {
#line 567
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 567
    if (! (i < n)) {
#line 567
      goto while_break___1;
    }
    {
#line 568
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%s", (*(sorted_timer_infos + i))->func);
#line 567
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 569
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 571
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Callback:");
#line 572
  i = (size_t )0;
  }
  {
#line 572
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 572
    if (! (i < n)) {
#line 572
      goto while_break___2;
    }
    {
#line 573
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%s", (*(sorted_timer_infos + i))->callback);
#line 572
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 574
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 576
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Total:");
#line 577
  i = (size_t )0;
  }
  {
#line 577
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 577
    if (! (i < n)) {
#line 577
      goto while_break___3;
    }
    {
#line 578
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%lu",
            (*(sorted_timer_infos + i))->total);
#line 577
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 579
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 586
  if (opt_flags & 32U) {
#line 586
    dur = 1.0;
  } else {
    {
#line 586
    tmp___1 = timeval_double(duration);
#line 586
    dur = tmp___1;
    }
  }
#line 587
  if (duration->tv_sec == 0L) {
#line 587
    if (duration->tv_usec == 0L) {
#line 587
      tmp___2 = 1;
    } else {
#line 587
      tmp___2 = 0;
    }
  } else {
#line 587
    tmp___2 = 0;
  }
#line 587
  dur_zero = (_Bool )tmp___2;
#line 589
  link___0 = sample_list.head;
  {
#line 589
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 589
    if (! link___0) {
#line 589
      goto while_break___4;
    }
    {
#line 590
    count ++;
#line 591
    sdl = (sample_delta_list_t *)link___0->data;
#line 592
    tmp___3 = timeval_double((struct timeval  const  *)(& sdl->whence));
#line 592
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f", tmp___3);
#line 595
    i = (size_t )0;
    }
    {
#line 595
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 595
      if (! (i < n)) {
#line 595
        goto while_break___5;
      }
      {
#line 596
      tmp___4 = sample_find(sdl, (timer_info_t const   *)*(sorted_timer_infos + i));
#line 596
      sdi = tmp___4;
      }
#line 597
      if (sdi) {
#line 598
        if (dur_zero) {
#line 598
          tmp___5 = 0.0;
        } else {
#line 598
          tmp___5 = (double )sdi->delta / dur;
        }
        {
#line 598
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%f",
                tmp___5);
        }
      } else {
        {
#line 600
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%f",
                0.0);
        }
      }
#line 595
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 602
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 589
    link___0 = link___0->next;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 608
  if (opt_flags & 64U) {
    {
#line 609
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Min:");
#line 610
    i = (size_t )0;
    }
    {
#line 610
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 610
      if (! (i < n)) {
#line 610
        goto while_break___6;
      }
#line 611
      min = (unsigned long )(~ 0);
#line 613
      link___0 = sample_list.head;
      {
#line 613
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 613
        if (! link___0) {
#line 613
          goto while_break___7;
        }
        {
#line 614
        sdl = (sample_delta_list_t *)link___0->data;
#line 615
        tmp___6 = sample_find(sdl, (timer_info_t const   *)*(sorted_timer_infos + i));
#line 615
        sdi___0 = tmp___6;
        }
#line 616
        if (sdi___0) {
#line 616
          if (min > sdi___0->delta) {
#line 617
            min = sdi___0->delta;
          }
        }
#line 613
        link___0 = link___0->next;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 619
      if (dur_zero) {
#line 619
        tmp___7 = 0.0;
      } else {
#line 619
        tmp___7 = (double )min / dur;
      }
      {
#line 619
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%f",
              tmp___7);
#line 610
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 621
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 623
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Max:");
#line 624
    i = (size_t )0;
    }
    {
#line 624
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 624
      if (! (i < n)) {
#line 624
        goto while_break___8;
      }
#line 625
      max = 0UL;
#line 627
      link___0 = sample_list.head;
      {
#line 627
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 627
        if (! link___0) {
#line 627
          goto while_break___9;
        }
        {
#line 628
        sdl = (sample_delta_list_t *)link___0->data;
#line 629
        tmp___8 = sample_find(sdl, (timer_info_t const   *)*(sorted_timer_infos + i));
#line 629
        sdi___1 = tmp___8;
        }
#line 630
        if (sdi___1) {
#line 630
          if (max < sdi___1->delta) {
#line 631
            max = sdi___1->delta;
          }
        }
#line 627
        link___0 = link___0->next;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 633
      if (dur_zero) {
#line 633
        tmp___9 = 0.0;
      } else {
#line 633
        tmp___9 = (double )max / dur;
      }
      {
#line 633
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%f",
              tmp___9);
#line 624
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 635
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 637
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Average:");
#line 638
    i = (size_t )0;
    }
    {
#line 638
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 638
      if (! (i < n)) {
#line 638
        goto while_break___10;
      }
#line 639
      if (dur_zero) {
#line 639
        tmp___10 = 0.0;
      } else {
#line 639
        tmp___10 = ((double )(*(sorted_timer_infos + i))->total / dur) / (double )count;
      }
      {
#line 639
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%f",
              tmp___10);
#line 638
      i ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 640
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 645
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Std.Dev.:");
#line 646
    i = (size_t )0;
    }
    {
#line 646
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 646
      if (! (i < n)) {
#line 646
        goto while_break___11;
      }
#line 647
      average = (double )(*(sorted_timer_infos + i))->total / (double )count;
#line 648
      sum = 0.0;
#line 650
      link___0 = sample_list.head;
      {
#line 650
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 650
        if (! link___0) {
#line 650
          goto while_break___12;
        }
        {
#line 651
        sdl = (sample_delta_list_t *)link___0->data;
#line 652
        tmp___11 = sample_find(sdl, (timer_info_t const   *)*(sorted_timer_infos + i));
#line 652
        sdi___2 = tmp___11;
        }
#line 653
        if (sdi___2) {
#line 654
          if (dur_zero) {
#line 654
            tmp___12 = 0.0;
          } else {
#line 654
            tmp___12 = ((double )sdi___2->delta - average) / dur;
          }
#line 654
          diff = tmp___12;
#line 655
          diff *= diff;
#line 656
          sum += diff;
        }
#line 650
        link___0 = link___0->next;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 659
      sum /= (double )count;
#line 660
      tmp___13 = sqrt(sum);
#line 660
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)",%f",
              tmp___13);
#line 646
      i ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 662
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 665
  free((void *)sorted_timer_infos);
#line 666
  fclose(fp);
  }
#line 667
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static timer_info_t *timer_info_find(timer_info_t const   *new_info ) 
{ 
  link_t *link___0 ;
  timer_info_t *info ;
  int tmp ;
  void *tmp___0 ;

  {
#line 679
  link___0 = timer_info_list.head;
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    if (! link___0) {
#line 679
      goto while_break;
    }
    {
#line 680
    info = (timer_info_t *)link___0->data;
#line 681
    tmp = strcmp((char const   *)new_info->ident, (char const   *)info->ident);
    }
#line 681
    if (tmp == 0) {
#line 682
      return (info);
    }
#line 679
    link___0 = link___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  tmp___0 = calloc((size_t )1, sizeof(timer_info_t ));
#line 685
  info = (timer_info_t *)tmp___0;
  }
#line 685
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    {
#line 686
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate timer info\n");
#line 687
    eventstat_exit((int const   )1);
    }
  }
  {
#line 690
  info->pid = (pid_t )new_info->pid;
#line 691
  info->task = strdup((char const   *)new_info->task);
  }
#line 692
  if (opt_flags & 12U) {
    {
#line 693
    info->cmdline = get_pid_cmdline(new_info->pid);
    }
  }
  {
#line 695
  info->func = strdup((char const   *)new_info->func);
#line 696
  info->callback = strdup((char const   *)new_info->callback);
#line 697
  info->ident = strdup((char const   *)new_info->ident);
#line 698
  info->kernel_thread = (_Bool )new_info->kernel_thread;
#line 699
  info->total = (unsigned long )new_info->total;
  }
#line 701
  if ((unsigned long )info->task == (unsigned long )((void *)0)) {
    {
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory allocating a timer stat fields\n");
#line 706
    eventstat_exit((int const   )1);
    }
  } else
#line 701
  if ((unsigned long )info->func == (unsigned long )((void *)0)) {
    {
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory allocating a timer stat fields\n");
#line 706
    eventstat_exit((int const   )1);
    }
  } else
#line 701
  if ((unsigned long )info->callback == (unsigned long )((void *)0)) {
    {
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory allocating a timer stat fields\n");
#line 706
    eventstat_exit((int const   )1);
    }
  } else
#line 701
  if ((unsigned long )info->ident == (unsigned long )((void *)0)) {
    {
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory allocating a timer stat fields\n");
#line 706
    eventstat_exit((int const   )1);
    }
  }
  {
#line 711
  list_append(& timer_info_list, (void *)info);
  }
#line 713
  return (info);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void timer_info_free(void *data ) 
{ 
  timer_info_t *info ;

  {
  {
#line 722
  info = (timer_info_t *)data;
#line 724
  free((void *)info->task);
#line 725
  free((void *)info->cmdline);
#line 726
  free((void *)info->func);
#line 727
  free((void *)info->callback);
#line 728
  free((void *)info->ident);
#line 729
  free((void *)info);
  }
#line 730
  return;
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void timer_info_list_free(void) 
{ 


  {
  {
#line 738
  list_free(& timer_info_list, (void (*/* const  */)(void * ))(& timer_info_free));
  }
#line 739
  return;
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static unsigned long hash_pjw(char const   *str ) 
{ 
  unsigned long h ;
  unsigned long g ;

  {
#line 747
  h = 0UL;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! *str) {
#line 749
      goto while_break;
    }
#line 751
    h = (h << 4) + (unsigned long )*str;
#line 752
    g = h & 4026531840UL;
#line 752
    if (0UL != g) {
#line 753
      h ^= g >> 24;
#line 754
      h ^= g;
    }
#line 756
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  return (h % 32771UL);
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void timer_stat_free_contents(timer_stat_t **timer_stats ) 
{ 
  int i ;
  timer_stat_t *ts ;
  timer_stat_t *next ;

  {
#line 771
  i = 0;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i < 32771)) {
#line 771
      goto while_break;
    }
#line 772
    ts = *(timer_stats + i);
    {
#line 774
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 774
      if (! ts) {
#line 774
        goto while_break___0;
      }
      {
#line 775
      next = ts->next;
#line 776
      free((void *)ts);
#line 778
      ts = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 780
    *(timer_stats + i) = (timer_stat_t *)((void *)0);
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 782
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void timer_stat_add(timer_stat_t **timer_stats , unsigned long const   count ,
                           pid_t const   pid , char *task , char *func , char *callback ,
                           _Bool const   kernel_thread ) 
{ 
  char buf[4096] ;
  timer_stat_t *ts ;
  timer_stat_t *ts_new ;
  timer_info_t info ;
  unsigned long h ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 804
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d:%s:%s:%s",
           pid, task, func, callback);
#line 805
  h = hash_pjw((char const   *)(buf));
#line 806
  ts = *(timer_stats + h);
#line 808
  ts = *(timer_stats + h);
  }
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! ts) {
#line 808
      goto while_break;
    }
    {
#line 809
    tmp = strcmp((char const   *)(ts->info)->ident, (char const   *)(buf));
    }
#line 809
    if (tmp == 0) {
#line 810
      ts->count += (unsigned long )count;
#line 811
      return;
    }
#line 808
    ts = ts->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 816
  tmp___0 = malloc(sizeof(timer_stat_t ));
#line 816
  ts_new = (timer_stat_t *)tmp___0;
  }
#line 816
  if ((unsigned long )ts_new == (unsigned long )((void *)0)) {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory allocating a timer stat\n");
#line 818
    eventstat_exit((int const   )1);
    }
  }
  {
#line 821
  info.pid = (pid_t )pid;
#line 822
  info.task = task;
#line 823
  info.func = func;
#line 824
  info.callback = callback;
#line 825
  info.ident = buf;
#line 826
  info.kernel_thread = (_Bool )kernel_thread;
#line 827
  info.total = (unsigned long )count;
#line 829
  ts_new->count = (unsigned long )count;
#line 830
  ts_new->info = timer_info_find((timer_info_t const   *)(& info));
#line 831
  ts_new->next = *(timer_stats + h);
#line 832
  ts_new->sorted_freq_next = (struct timer_stat *)((void *)0);
#line 834
  *(timer_stats + h) = ts_new;
  }
#line 835
  return;
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static timer_stat_t *timer_stat_find(timer_stat_t **haystack , timer_stat_t *needle ) 
{ 
  timer_stat_t *ts ;
  char buf[4096] ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 848
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d:%s:%s:%s",
           (needle->info)->pid, (needle->info)->task, (needle->info)->func, (needle->info)->callback);
#line 852
  tmp = hash_pjw((char const   *)(buf));
#line 852
  ts = *(haystack + tmp);
  }
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! ts) {
#line 852
      goto while_break;
    }
    {
#line 853
    tmp___0 = strcmp((char const   *)(ts->info)->ident, (char const   *)(buf));
    }
#line 853
    if (tmp___0 == 0) {
#line 854
      return (ts);
    }
#line 852
    ts = ts->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  return ((timer_stat_t *)((void *)0));
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void timer_stat_sort_freq_add(timer_stat_t **sorted , timer_stat_t *new ) 
{ 


  {
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 868
    if (! *sorted) {
#line 868
      goto while_break;
    }
#line 869
    if (opt_flags & 2U) {
#line 870
      if ((*sorted)->count < new->count) {
#line 871
        new->sorted_freq_next = *sorted;
#line 872
        goto while_break;
      }
    } else
#line 875
    if ((*sorted)->delta < new->delta) {
#line 876
      new->sorted_freq_next = *sorted;
#line 877
      goto while_break;
    }
#line 880
    sorted = & (*sorted)->sorted_freq_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  *sorted = new;
#line 883
  return;
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void timer_stat_diff(struct timeval *duration , int const   n_lines , struct timeval *whence ,
                            timer_stat_t **timer_stats_old , timer_stat_t **timer_stats_new ) 
{ 
  int i ;
  double dur ;
  double tmp ;
  timer_stat_t *sorted ;
  timer_stat_t *ts ;
  timer_stat_t *found ;
  timer_stat_t *tmp___0 ;
  unsigned long total ;
  unsigned long kt_total ;
  int j ;
  char const   *tmp___1 ;
  char *cmd ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 899
  tmp = timeval_double((struct timeval  const  *)duration);
#line 899
  dur = tmp;
#line 901
  sorted = (timer_stat_t *)((void *)0);
#line 903
  i = 0;
  }
  {
#line 903
  while (1) {
    while_continue: /* CIL Label */ ;
#line 903
    if (! (i < 32771)) {
#line 903
      goto while_break;
    }
#line 906
    ts = *(timer_stats_new + i);
    {
#line 906
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 906
      if (! ts) {
#line 906
        goto while_break___0;
      }
      {
#line 907
      tmp___0 = timer_stat_find(timer_stats_old, ts);
#line 907
      found = tmp___0;
      }
#line 909
      if (found) {
#line 910
        ts->delta = ts->count - found->count;
#line 911
        if ((double )ts->delta >= opt_threshold) {
          {
#line 912
          timer_stat_sort_freq_add(& sorted, ts);
#line 913
          sample_add(ts, whence);
#line 914
          (found->info)->total += ts->delta;
          }
        }
      } else {
#line 917
        ts->delta = ts->count;
#line 918
        if ((double )ts->delta >= opt_threshold) {
          {
#line 919
          timer_stat_sort_freq_add(& sorted, ts);
#line 920
          sample_add(ts, whence);
          }
        }
      }
#line 906
      ts = ts->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 903
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  if (! (opt_flags & 1U)) {
#line 927
    total = 0UL;
#line 927
    kt_total = 0UL;
#line 928
    j = 0;
#line 930
    if (opt_flags & 2U) {
#line 930
      tmp___1 = "Events";
    } else {
#line 930
      tmp___1 = "Event/s";
    }
    {
#line 930
    printf((char const   */* __restrict  */)"%8s %-5s %-15s", tmp___1, "PID", "Task");
    }
#line 932
    if (! (opt_flags & 128U)) {
      {
#line 933
      printf((char const   */* __restrict  */)" %-25s %-s\n", "Init Function", "Callback");
      }
    } else {
      {
#line 936
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 938
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 938
      if (! sorted) {
#line 938
        goto while_break___1;
      }
#line 939
      if (n_lines == -1) {
#line 939
        goto _L;
      } else
#line 939
      if (j < (int )n_lines) {
        _L: /* CIL Label */ 
#line 939
        if (sorted->delta != 0UL) {
#line 940
          j ++;
#line 941
          if (opt_flags & 2U) {
            {
#line 942
            printf((char const   */* __restrict  */)"%8lu ", sorted->count);
            }
          } else {
            {
#line 944
            printf((char const   */* __restrict  */)"%8.2f ", (double )sorted->delta / dur);
            }
          }
#line 946
          if (opt_flags & 128U) {
#line 947
            if ((sorted->info)->cmdline) {
#line 947
              tmp___2 = (sorted->info)->cmdline;
            } else {
#line 947
              tmp___2 = (sorted->info)->task;
            }
#line 947
            cmd = tmp___2;
#line 950
            if (opt_flags & 12U) {
#line 950
              tmp___3 = cmd;
            } else {
#line 950
              tmp___3 = (sorted->info)->task;
            }
            {
#line 950
            printf((char const   */* __restrict  */)"%5d %s\n", (sorted->info)->pid,
                   tmp___3);
            }
          } else {
            {
#line 955
            printf((char const   */* __restrict  */)"%5d %-15s %-25s %-s\n", (sorted->info)->pid,
                   (sorted->info)->task, (sorted->info)->func, (sorted->info)->callback);
            }
          }
        }
      }
#line 960
      total += sorted->delta;
#line 961
      if ((sorted->info)->kernel_thread) {
#line 962
        kt_total += sorted->delta;
      }
#line 964
      sorted = sorted->sorted_freq_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 966
    printf((char const   */* __restrict  */)"%lu Total events, %5.2f events/sec (kernel: %5.2f, userspace: %5.2f)\n",
           total, (double )total / dur, (double )kt_total / dur, (double )(total - kt_total) / dur);
    }
#line 970
    if (! sane_procs) {
      {
#line 971
      printf((char const   */* __restrict  */)"Note: this was run inside a container, kernel tasks were guessed.\n");
      }
    }
    {
#line 972
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 974
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void get_events(timer_stat_t **timer_stats ) 
{ 
  FILE *fp ;
  char buf[4096] ;
  char *ptr ;
  unsigned long count ;
  pid_t pid ;
  char task[64] ;
  char func[128] ;
  char timer[128] ;
  _Bool kernel_thread ;
  int mask ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char tmp___4[64] ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 986
  fp = fopen((char const   */* __restrict  */)"/proc/timer_stats", (char const   */* __restrict  */)"r");
  }
#line 986
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 987
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s\n",
            "/proc/timer_stats");
    }
#line 988
    return;
  }
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 992
    tmp___10 = feof(fp);
    }
#line 992
    if (tmp___10) {
#line 992
      goto while_break;
    }
    {
#line 993
    ptr = buf;
#line 994
    count = 0xffffffffffffffffUL;
#line 995
    pid = -1;
#line 1002
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 1002
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    tmp___0 = strstr((char const   *)(buf), "total events");
    }
#line 1005
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1006
      goto while_break;
    }
    {
#line 1008
    tmp___1 = strstr((char const   *)(buf), ",");
    }
#line 1008
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1009
      goto while_continue;
    }
    {
#line 1013
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1013
      if (*ptr) {
#line 1013
        if (! ((int )*ptr != 44)) {
#line 1013
          goto while_break___0;
        }
      } else {
#line 1013
        goto while_break___0;
      }
#line 1014
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1016
    if ((int )*ptr != 44) {
#line 1017
      goto while_continue;
    }
#line 1019
    if ((unsigned long )ptr > (unsigned long )(buf)) {
#line 1019
      if ((int )*(ptr - 1) == 68) {
#line 1020
        goto while_continue;
      }
    }
    {
#line 1022
    ptr ++;
#line 1023
    sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%21lu",
           & count);
#line 1024
    memset((void *)(task), 0, sizeof(task));
#line 1025
    memset((void *)(func), 0, sizeof(func));
#line 1026
    memset((void *)(timer), 0, sizeof(timer));
#line 1027
    tmp___2 = sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"%10d %63s %127s (%127[^)])",
                     & pid, task, func, timer);
    }
#line 1027
    if (tmp___2 != 4) {
#line 1028
      goto while_continue;
    }
    {
#line 1030
    kernel_thread = pid_a_kernel_thread((char const   *)(task), (pid_t const   )pid);
#line 1033
    tmp___3 = strncmp((char const   *)(task), "swapper", (size_t )6);
    }
#line 1033
    if (tmp___3 == 0) {
#line 1034
      kernel_thread = (_Bool)1;
    }
#line 1036
    if (kernel_thread) {
#line 1036
      mask = 256;
    } else {
#line 1036
      mask = 512;
    }
#line 1038
    if (! (opt_flags & (unsigned int )mask)) {
#line 1039
      goto while_continue;
    }
#line 1041
    if (kernel_thread) {
      {
#line 1043
      task[13] = (char )'\000';
#line 1044
      snprintf((char */* __restrict  */)(tmp___4), sizeof(tmp___4), (char const   */* __restrict  */)"[%s]",
               task);
#line 1045
      strcpy((char */* __restrict  */)(task), (char const   */* __restrict  */)(tmp___4));
      }
    }
    {
#line 1048
    tmp___5 = strcmp((char const   *)(task), "insmod");
    }
#line 1048
    if (tmp___5 == 0) {
      {
#line 1049
      strcpy((char */* __restrict  */)(task), (char const   */* __restrict  */)"[kern mod]");
      }
    }
    {
#line 1050
    tmp___6 = strcmp((char const   *)(task), "modprobe");
    }
#line 1050
    if (tmp___6 == 0) {
      {
#line 1051
      strcpy((char */* __restrict  */)(task), (char const   */* __restrict  */)"[kern mod]");
      }
    }
    {
#line 1053
    tmp___7 = strncmp((char const   *)(func), "tick_nohz_", (size_t )10);
    }
#line 1053
    if (tmp___7 == 0) {
#line 1056
      goto while_continue;
    } else {
      {
#line 1053
      tmp___8 = strncmp((char const   *)(func), "tick_setup_sched_timer", (size_t )20);
      }
#line 1053
      if (tmp___8 == 0) {
#line 1056
        goto while_continue;
      } else {
        {
#line 1053
        tmp___9 = strcmp((char const   *)(task), "eventstat");
        }
#line 1053
        if (tmp___9 == 0) {
#line 1056
          goto while_continue;
        }
      }
    }
    {
#line 1058
    timer_stat_add(timer_stats, (unsigned long const   )count, (pid_t const   )pid,
                   task, func, timer, (_Bool const   )kernel_thread);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1061
  fclose(fp);
  }
#line 1062
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
static void show_usage(void) 
{ 


  {
  {
#line 1070
  printf((char const   */* __restrict  */)"%s, version %s\n\n", "eventstat", "0.01.31");
#line 1071
  printf((char const   */* __restrict  */)"Usage: %s [options] [duration] [count]\n",
         "eventstat");
#line 1072
  printf((char const   */* __restrict  */)"Options are:\n");
#line 1073
  printf((char const   */* __restrict  */)"  -c\t\treport cumulative events rather than events per second.\n");
#line 1074
  printf((char const   */* __restrict  */)"  -C\t\treport event count rather than event per second in CSV output.\n");
#line 1075
  printf((char const   */* __restrict  */)"  -d\t\tremove pathname from long process name in CSV output.\n");
#line 1076
  printf((char const   */* __restrict  */)"  -h\t\tprint this help.\n");
#line 1077
  printf((char const   */* __restrict  */)"  -l\t\tuse long cmdline text from /proc/pid/cmdline in CSV output.\n");
#line 1078
  printf((char const   */* __restrict  */)"  -n events\tspecifies number of events to display.\n");
#line 1079
  printf((char const   */* __restrict  */)"  -q\t\trun quietly, useful with option -r.\n");
#line 1080
  printf((char const   */* __restrict  */)"  -r filename\tspecifies a comma separated values (CSV) output file to dump samples into.\n");
#line 1081
  printf((char const   */* __restrict  */)"  -s\t\tuse short process name from /proc/pid/cmdline in CSV output.\n");
#line 1082
  printf((char const   */* __restrict  */)"  -S\t\tcalculate min, max, average and standard deviation in CSV output.\n");
#line 1083
  printf((char const   */* __restrict  */)"  -t threshold\tsamples less than the specified threshold are ignored.\n");
  }
#line 1084
  return;
}
}
#line 1086 "/home/june/repo/benchmarks/collector/temp/eventstat-0.01.31/eventstat.c"
int main(int argc , char **argv ) 
{ 
  timer_stat_t **timer_stats_old ;
  timer_stat_t **timer_stats_new ;
  timer_stat_t **tmp ;
  double duration_secs ;
  int count ;
  int n_lines ;
  _Bool forever ;
  struct timeval tv1 ;
  struct timeval tv2 ;
  struct timeval duration ;
  struct timeval whence ;
  int c ;
  int tmp___0 ;
  unsigned long long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  struct timeval tv ;
  int ret ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1089
  duration_secs = 1.0;
#line 1090
  count = 1;
#line 1091
  n_lines = -1;
#line 1092
  forever = (_Bool)1;
#line 1095
  list_init(& timer_info_list);
#line 1096
  list_init(& sample_list);
  }
  {
#line 1098
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1099
    tmp___0 = getopt(argc, (char * const  *)argv, "bcCdksSlhn:qr:t:u");
#line 1099
    c = tmp___0;
    }
#line 1100
    if (c == -1) {
#line 1101
      goto while_break;
    }
    {
#line 1103
    if (c == 98) {
#line 1103
      goto case_98;
    }
#line 1106
    if (c == 99) {
#line 1106
      goto case_99;
    }
#line 1109
    if (c == 67) {
#line 1109
      goto case_67;
    }
#line 1112
    if (c == 100) {
#line 1112
      goto case_100;
    }
#line 1115
    if (c == 104) {
#line 1115
      goto case_104;
    }
#line 1118
    if (c == 110) {
#line 1118
      goto case_110;
    }
#line 1125
    if (c == 116) {
#line 1125
      goto case_116;
    }
#line 1132
    if (c == 113) {
#line 1132
      goto case_113;
    }
#line 1135
    if (c == 114) {
#line 1135
      goto case_114;
    }
#line 1138
    if (c == 115) {
#line 1138
      goto case_115;
    }
#line 1141
    if (c == 83) {
#line 1141
      goto case_83;
    }
#line 1144
    if (c == 108) {
#line 1144
      goto case_108;
    }
#line 1147
    if (c == 107) {
#line 1147
      goto case_107;
    }
#line 1150
    if (c == 117) {
#line 1150
      goto case_117;
    }
#line 1102
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1104
    opt_flags |= 128U;
#line 1105
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1107
    opt_flags |= 2U;
#line 1108
    goto switch_break;
    case_67: /* CIL Label */ 
#line 1110
    opt_flags |= 32U;
#line 1111
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1113
    opt_flags |= 16U;
#line 1114
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1116
    show_usage();
#line 1117
    eventstat_exit((int const   )0);
    }
    case_110: /* CIL Label */ 
    {
#line 1119
    n_lines = atoi((char const   *)optarg);
    }
#line 1120
    if (n_lines < 1) {
      {
#line 1121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-n option must be greater than 0\n");
#line 1122
      eventstat_exit((int const   )1);
      }
    }
#line 1124
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1126
    tmp___1 = strtoull((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       10);
#line 1126
    opt_threshold = (double )tmp___1;
    }
#line 1127
    if (opt_threshold < (double )1) {
      {
#line 1128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-t threshold must be 1 or more.\n");
#line 1129
      eventstat_exit((int const   )1);
      }
    }
#line 1131
    goto switch_break;
    case_113: /* CIL Label */ 
#line 1133
    opt_flags |= 1U;
#line 1134
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1136
    csv_results = optarg;
#line 1137
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1139
    opt_flags |= 4U;
#line 1140
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1142
    opt_flags |= 64U;
#line 1143
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1145
    opt_flags |= 8U;
#line 1146
    goto switch_break;
    case_107: /* CIL Label */ 
#line 1148
    opt_flags |= 256U;
#line 1149
    goto switch_break;
    case_117: /* CIL Label */ 
#line 1151
    opt_flags |= 512U;
#line 1152
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1156
  if (! (opt_flags & 768U)) {
#line 1157
    opt_flags |= 768U;
  }
#line 1159
  if (optind < argc) {
    {
#line 1160
    tmp___2 = optind;
#line 1160
    optind ++;
#line 1160
    duration_secs = atof((char const   *)*(argv + tmp___2));
    }
#line 1161
    if (duration_secs < 0.5) {
      {
#line 1162
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Duration must 0.5 or more.\n");
#line 1163
      eventstat_exit((int const   )1);
      }
    }
  }
#line 1167
  if (optind < argc) {
    {
#line 1168
    forever = (_Bool)0;
#line 1169
    tmp___3 = optind;
#line 1169
    optind ++;
#line 1169
    count = atoi((char const   *)*(argv + tmp___3));
    }
#line 1170
    if (count < 1) {
      {
#line 1171
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Count must be > 0\n");
#line 1172
      eventstat_exit((int const   )1);
      }
    }
  }
  {
#line 1176
  duration.tv_sec = (time_t )duration_secs;
#line 1177
  duration.tv_usec = (suseconds_t )(duration_secs * 1000000.0) - duration.tv_sec * 1000000L;
#line 1178
  opt_threshold *= duration_secs;
#line 1180
  tmp___4 = geteuid();
  }
#line 1180
  if (tmp___4 != 0U) {
    {
#line 1181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s requires root privileges to write to %s\n",
            "eventstat", "/proc/timer_stats");
#line 1183
    eventstat_exit((int const   )1);
    }
  }
  {
#line 1186
  sane_procs = sane_proc_pid_info();
  }
#line 1187
  if (! sane_procs) {
#line 1188
    opt_flags &= 4294967283U;
  }
  {
#line 1190
  signal(2, & handle_sigint);
#line 1192
  tmp___5 = calloc((size_t )32771, sizeof(timer_stat_t *));
#line 1192
  timer_stats_old = (timer_stat_t **)tmp___5;
  }
#line 1192
  if ((unsigned long )timer_stats_old == (unsigned long )((void *)0)) {
    {
#line 1193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate old timer stats table\n");
#line 1194
    eventstat_exit((int const   )1);
    }
  }
  {
#line 1196
  tmp___6 = calloc((size_t )32771, sizeof(timer_stat_t *));
#line 1196
  timer_stats_new = (timer_stat_t **)tmp___6;
  }
#line 1196
  if ((unsigned long )timer_stats_new == (unsigned long )((void *)0)) {
    {
#line 1197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate old timer stats table\n");
#line 1198
    eventstat_exit((int const   )1);
    }
  }
  {
#line 1202
  set_timer_stat("1", (_Bool const   )1);
#line 1203
  gettimeofday((struct timeval */* __restrict  */)(& tv1), (__timezone_ptr_t )((void *)0));
#line 1204
  get_events(timer_stats_old);
#line 1206
  whence.tv_sec = (__time_t )0;
#line 1207
  whence.tv_usec = (__suseconds_t )0;
  }
  {
#line 1209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1209
    if (! stop_eventstat) {
#line 1209
      if (! forever) {
#line 1209
        tmp___10 = count;
#line 1209
        count --;
#line 1209
        if (! tmp___10) {
#line 1209
          goto while_break___0;
        }
      }
    } else {
#line 1209
      goto while_break___0;
    }
    {
#line 1213
    gettimeofday((struct timeval */* __restrict  */)(& tv2), (__timezone_ptr_t )((void *)0));
#line 1215
    tv = timeval_add((struct timeval  const  *)(& duration), (struct timeval  const  *)(& whence));
#line 1216
    tv = timeval_add((struct timeval  const  *)(& tv), (struct timeval  const  *)(& tv1));
#line 1217
    tv = timeval_sub((struct timeval  const  *)(& tv), (struct timeval  const  *)(& tv2));
#line 1217
    tv2 = tv;
    }
#line 1220
    if (tv.tv_sec < 0L) {
#line 1221
      tv.tv_sec = (__time_t )0;
#line 1222
      tv.tv_usec = (__suseconds_t )0;
#line 1223
      tv2 = tv;
    }
    {
#line 1226
    ret = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv2));
    }
#line 1227
    if (ret < 0) {
      {
#line 1228
      tmp___9 = __errno_location();
      }
#line 1228
      if (*tmp___9 == 4) {
        {
#line 1229
        duration = timeval_sub((struct timeval  const  *)(& tv), (struct timeval  const  *)(& tv2));
#line 1230
        stop_eventstat = (_Bool volatile   )1;
        }
      } else {
        {
#line 1232
        tmp___7 = __errno_location();
#line 1232
        tmp___8 = strerror(*tmp___7);
#line 1232
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Select failed: %s\n",
                tmp___8);
        }
#line 1233
        goto while_break___0;
      }
    }
    {
#line 1237
    get_events(timer_stats_new);
#line 1238
    timer_stat_diff(& duration, (int const   )n_lines, & whence, timer_stats_old,
                    timer_stats_new);
#line 1240
    timer_stat_free_contents(timer_stats_old);
#line 1242
    tmp = timer_stats_old;
#line 1243
    timer_stats_old = timer_stats_new;
#line 1244
    timer_stats_new = tmp;
#line 1246
    whence = timeval_add((struct timeval  const  *)(& duration), (struct timeval  const  *)(& whence));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1249
  samples_dump((char const   *)csv_results, (struct timeval  const  *)(& duration));
#line 1251
  timer_stat_free_contents(timer_stats_old);
#line 1252
  timer_stat_free_contents(timer_stats_new);
#line 1253
  free((void *)timer_stats_old);
#line 1254
  free((void *)timer_stats_new);
#line 1255
  samples_free();
#line 1256
  timer_info_list_free();
#line 1258
  eventstat_exit((int const   )0);
  }
}
}
