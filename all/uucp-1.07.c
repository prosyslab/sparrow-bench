/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 106 "../uucp.h"
typedef void *pointer;
#line 33 "../uudefs.h"
enum tlog {
    LOG_NORMAL = 0,
    LOG_ERROR = 1,
    LOG_FATAL = 2,
    LOG_DEBUG = 3,
    LOG_DEBUG_START = 4,
    LOG_DEBUG_CONTINUE = 5,
    LOG_DEBUG_END = 6
} ;
#line 258 "../uucp.h"
typedef int boolean;
#line 105 "../uudefs.h"
struct scmd {
   char bcmd ;
   char bgrade ;
   pointer pseq ;
   char const   *zfrom ;
   char const   *zto ;
   char const   *zuser ;
   char const   *zoptions ;
   char const   *ztemp ;
   unsigned int imode ;
   char const   *znotify ;
   long cbytes ;
   char const   *zcmd ;
   long ipos ;
};
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 84 "../getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 114 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
enum __anonenum_ordering_42 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/buffer.c"
union __anonunion_u_42 {
   char ab[4] ;
   char bdummy ;
};
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/buffer.c"
struct sbuf {
   struct sbuf *qnext ;
   size_t c ;
   union __anonunion_u_42 u ;
};
#line 48 "../uuconf.h"
typedef void *UUCONF_POINTER;
#line 76 "../uuconf.h"
struct uuconf_chat {
   char **uuconf_pzchat ;
   char **uuconf_pzprogram ;
   int uuconf_ctimeout ;
   char **uuconf_pzfail ;
   int uuconf_fstrip ;
};
#line 129 "../uuconf.h"
struct uuconf_timespan {
   struct uuconf_timespan *uuconf_qnext ;
   int uuconf_istart ;
   int uuconf_iend ;
   long uuconf_ival ;
   int uuconf_cretry ;
};
#line 148
struct uuconf_proto_param_entry;
#line 148 "../uuconf.h"
struct uuconf_proto_param {
   int uuconf_bproto ;
   struct uuconf_proto_param_entry *uuconf_qentries ;
};
#line 161 "../uuconf.h"
struct uuconf_proto_param_entry {
   int uuconf_cargs ;
   char **uuconf_pzargs ;
};
#line 177
struct uuconf_port;
#line 177 "../uuconf.h"
struct uuconf_system {
   char *uuconf_zname ;
   char **uuconf_pzalias ;
   struct uuconf_system *uuconf_qalternate ;
   char *uuconf_zalternate ;
   int uuconf_fcall ;
   int uuconf_fcalled ;
   struct uuconf_timespan *uuconf_qtimegrade ;
   struct uuconf_timespan *uuconf_qcalltimegrade ;
   struct uuconf_timespan *uuconf_qcalledtimegrade ;
   int uuconf_cmax_retries ;
   int uuconf_csuccess_wait ;
   struct uuconf_timespan *uuconf_qcall_local_size ;
   struct uuconf_timespan *uuconf_qcall_remote_size ;
   struct uuconf_timespan *uuconf_qcalled_local_size ;
   struct uuconf_timespan *uuconf_qcalled_remote_size ;
   long uuconf_ibaud ;
   long uuconf_ihighbaud ;
   char *uuconf_zport ;
   struct uuconf_port *uuconf_qport ;
   char *uuconf_zphone ;
   struct uuconf_chat uuconf_schat ;
   char *uuconf_zcall_login ;
   char *uuconf_zcall_password ;
   char *uuconf_zcalled_login ;
   int uuconf_fcallback ;
   int uuconf_fsequence ;
   char *uuconf_zprotocols ;
   struct uuconf_proto_param *uuconf_qproto_params ;
   struct uuconf_chat uuconf_scalled_chat ;
   char *uuconf_zdebug ;
   char *uuconf_zmax_remote_debug ;
   int uuconf_fsend_request ;
   int uuconf_frec_request ;
   int uuconf_fcall_transfer ;
   int uuconf_fcalled_transfer ;
   char **uuconf_pzlocal_send ;
   char **uuconf_pzremote_send ;
   char **uuconf_pzlocal_receive ;
   char **uuconf_pzremote_receive ;
   char **uuconf_pzpath ;
   char **uuconf_pzcmds ;
   long uuconf_cfree_space ;
   char **uuconf_pzforward_from ;
   char **uuconf_pzforward_to ;
   char const   *uuconf_zpubdir ;
   char *uuconf_zlocalname ;
   long uuconf_cmax_file_time ;
   UUCONF_POINTER uuconf_palloc ;
};
#line 345
enum uuconf_porttype {
    UUCONF_PORTTYPE_UNKNOWN = 0,
    UUCONF_PORTTYPE_STDIN = 1,
    UUCONF_PORTTYPE_MODEM = 2,
    UUCONF_PORTTYPE_DIRECT = 3,
    UUCONF_PORTTYPE_TCP = 4,
    UUCONF_PORTTYPE_TLI = 5,
    UUCONF_PORTTYPE_PIPE = 6
} ;
#line 367 "../uuconf.h"
struct uuconf_stdin_port {
   int uuconf_idummy ;
};
#line 374
struct uuconf_dialer;
#line 374 "../uuconf.h"
struct uuconf_modem_port {
   char *uuconf_zdevice ;
   char *uuconf_zdial_device ;
   long uuconf_ibaud ;
   long uuconf_ilowbaud ;
   long uuconf_ihighbaud ;
   int uuconf_fcarrier ;
   int uuconf_fhardflow ;
   char **uuconf_pzdialer ;
   struct uuconf_dialer *uuconf_qdialer ;
};
#line 403 "../uuconf.h"
struct uuconf_direct_port {
   char *uuconf_zdevice ;
   long uuconf_ibaud ;
   int uuconf_fcarrier ;
   int uuconf_fhardflow ;
};
#line 418 "../uuconf.h"
struct uuconf_tcp_port {
   char *uuconf_zport ;
   int uuconf_iversion ;
   char **uuconf_pzdialer ;
};
#line 433 "../uuconf.h"
struct uuconf_tli_port {
   char *uuconf_zdevice ;
   int uuconf_fstream ;
   char **uuconf_pzpush ;
   char **uuconf_pzdialer ;
   char *uuconf_zservaddr ;
};
#line 459 "../uuconf.h"
struct uuconf_pipe_port {
   char **uuconf_pzcmd ;
};
#line 467 "../uuconf.h"
union __anonunion_uuconf_u_42 {
   struct uuconf_stdin_port uuconf_sstdin ;
   struct uuconf_modem_port uuconf_smodem ;
   struct uuconf_direct_port uuconf_sdirect ;
   struct uuconf_tcp_port uuconf_stcp ;
   struct uuconf_tli_port uuconf_stli ;
   struct uuconf_pipe_port uuconf_spipe ;
};
#line 467 "../uuconf.h"
struct uuconf_port {
   char *uuconf_zname ;
   enum uuconf_porttype uuconf_ttype ;
   char *uuconf_zprotocols ;
   struct uuconf_proto_param *uuconf_qproto_params ;
   int uuconf_ireliable ;
   char *uuconf_zlockname ;
   UUCONF_POINTER uuconf_palloc ;
   union __anonunion_uuconf_u_42 uuconf_u ;
};
#line 500 "../uuconf.h"
struct uuconf_dialer {
   char *uuconf_zname ;
   struct uuconf_chat uuconf_schat ;
   char *uuconf_zdialtone ;
   char *uuconf_zpause ;
   int uuconf_fcarrier ;
   int uuconf_ccarrier_wait ;
   int uuconf_fdtr_toggle ;
   int uuconf_fdtr_toggle_wait ;
   struct uuconf_chat uuconf_scomplete ;
   struct uuconf_chat uuconf_sabort ;
   struct uuconf_proto_param *uuconf_qproto_params ;
   int uuconf_ireliable ;
   UUCONF_POINTER uuconf_palloc ;
};
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct sprocess;
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct sglobal {
   struct sprocess *qprocess ;
   pointer pblock ;
   int ierrno ;
   char const   *zfilename ;
   int ilineno ;
};
#line 61
struct sunknown;
#line 61
struct stsysloc;
#line 61
struct svalidate;
#line 61
struct shpermissions;
#line 61 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct sprocess {
   char const   *zlocalname ;
   char const   *zspooldir ;
   char const   *zpubdir ;
   char const   *zlockdir ;
   char const   *zlogfile ;
   char const   *zstatsfile ;
   char const   *zdebugfile ;
   char const   *zdebug ;
   boolean fstrip_login ;
   boolean fstrip_proto ;
   int cmaxuuxqts ;
   char const   *zrunuuxqt ;
   boolean fv2 ;
   boolean fhdb ;
   char **pzdialcodefiles ;
   char **pztimetables ;
   char *zconfigfile ;
   char **pzsysfiles ;
   char **pzportfiles ;
   char **pzdialfiles ;
   char **pzpwdfiles ;
   char **pzcallfiles ;
   struct sunknown *qunknown ;
   boolean fread_syslocs ;
   struct stsysloc *qsyslocs ;
   struct svalidate *qvalidate ;
   boolean fuses_myname ;
   char *zv2systems ;
   char *zv2devices ;
   char *zv2userfile ;
   char *zv2cmds ;
   char **pzhdb_systems ;
   char **pzhdb_devices ;
   char **pzhdb_dialers ;
   boolean fhdb_read_permissions ;
   struct shpermissions *qhdb_permissions ;
};
#line 146 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct sunknown {
   struct sunknown *qnext ;
   int ilineno ;
   int cargs ;
   char **pzargs ;
};
#line 161 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct stsysloc {
   struct stsysloc *qnext ;
   char const   *zname ;
   boolean falias ;
   char const   *zfile ;
   FILE *e ;
   long iloc ;
   int ilineno ;
};
#line 188 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct svalidate {
   struct svalidate *qnext ;
   char const   *zlogname ;
   char **pzmachines ;
};
#line 201 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct shpermissions {
   struct shpermissions *qnext ;
   char **pzlogname ;
   char **pzmachine ;
   int frequest ;
   int fsendfiles ;
   char **pzread ;
   char **pzwrite ;
   int fcallback ;
   char **pzcommands ;
   char **pzvalidate ;
   char *zmyname ;
   char const   *zpubdir ;
   char **pzalias ;
};
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 50 "../uuconf.h"
typedef size_t UUCONF_SIZE_T;
#line 1463 "../uuconf.h"
struct uuconf_cmdtab {
   char const   *uuconf_zcmd ;
   int uuconf_itype ;
   UUCONF_POINTER uuconf_pvar ;
   int (*uuconf_pifn)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                      void *uuconf_pvar , void *uuconf_pinfo ) ;
};
#line 237 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
struct cmdtab_offset {
   char const   *zcmd ;
   int itype ;
   size_t ioff ;
   int (*pifn)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ) ;
};
#line 71 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
struct sinfo {
   struct uuconf_system *qsys ;
   boolean falternates ;
   struct uuconf_system salternate ;
   int fdefault_alternates ;
};
#line 106 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
struct sinfo___0 {
   char const   *zname ;
   struct uuconf_cmdtab *qcmds ;
};
#line 46 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
struct __anonstruct_asTdays_44 {
   char const   *zname ;
   int imin ;
   int imax ;
};
#line 63 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
struct sinfo___1 {
   char const   *zname ;
   FILE *e ;
   struct stsysloc *qlocs ;
   struct svalidate *qvals ;
};
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.h"
struct sadded;
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.h"
union __anonunion_u_43 {
   char ab[1008] ;
   double l ;
};
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.h"
struct sblock {
   struct sblock *qnext ;
   size_t ifree ;
   pointer plast ;
   struct sadded *qadded ;
   union __anonunion_u_43 u ;
};
#line 64 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.h"
struct sadded {
   struct sadded *qnext ;
   pointer padded ;
};
#line 539 "../uuconf.h"
struct uuconf_config_file_names {
   char const   *uuconf_ztaylor_config ;
   char const   * const  *uuconf_pztaylor_sys ;
   char const   * const  *uuconf_pztaylor_port ;
   char const   * const  *uuconf_pztaylor_dial ;
   char const   * const  *uuconf_pzdialcode ;
   char const   * const  *uuconf_pztaylor_pwd ;
   char const   * const  *uuconf_pztaylor_call ;
   char const   *uuconf_zv2_systems ;
   char const   *uuconf_zv2_device ;
   char const   *uuconf_zv2_userfile ;
   char const   *uuconf_zv2_cmds ;
   char const   * const  *uuconf_pzhdb_systems ;
   char const   * const  *uuconf_pzhdb_devices ;
   char const   * const  *uuconf_pzhdb_dialers ;
   char const   *uuconf_zhdb_permissions ;
};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/callin.c"
struct sinfo___2 {
   int (*pcmpfn)(int  , pointer  , char const   * ) ;
   pointer pinfo ;
   boolean ffound ;
   boolean fmatched ;
};
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 62 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 107 "../uucp.h"
typedef void const   *constpointer;
#line 62 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
struct ssfilename {
   char *zfile ;
   char bgrade ;
   char bdummy ;
};
#line 79
struct ssfile;
#line 79 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
struct ssline {
   char *zline ;
   struct ssfile *qfile ;
   char *ztemp ;
};
#line 86 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
struct ssfile {
   char *zfile ;
   char bgrade ;
   char bdummy ;
   int clines ;
   int cdid ;
   struct ssline aslines[10] ;
};
#line 90 "/usr/include/glob.h"
struct __anonstruct_glob_t_46 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   void *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , void * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , void * __restrict   ) ;
};
#line 90 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_46 glob_t;
#line 68 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 268 "../uucp.h"
typedef FILE *openfile_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 24 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 33 "../sysdep.h"
struct sconnection;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 200 "../sysdep.h"
typedef struct termios sterminal;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 354 "../sysdep.h"
struct ssysdep_conn {
   int o ;
   int ord ;
   int owr ;
   char *zdevice ;
   int iflags ;
   int iwr_flags ;
   int ohold ;
   boolean fterminal ;
   boolean ftli ;
   long ibaud ;
   sterminal sorig ;
   sterminal snew ;
   pid_t ipid ;
};
#line 39 "../conn.h"
struct sconncmds;
#line 39 "../conn.h"
struct sconnection {
   struct sconncmds  const  *qcmds ;
   pointer psysdep ;
   struct uuconf_port *qport ;
};
#line 51
enum tdialerfound {
    DIALERFOUND_FALSE = 0,
    DIALERFOUND_TRUE = 1,
    DIALERFOUND_FREE = 2
} ;
#line 63
enum tparitysetting {
    PARITYSETTING_DEFAULT = 0,
    PARITYSETTING_NONE = 1,
    PARITYSETTING_EVEN = 2,
    PARITYSETTING_ODD = 3,
    PARITYSETTING_MARK = 4,
    PARITYSETTING_SPACE = 5
} ;
#line 81
enum tstripsetting {
    STRIPSETTING_DEFAULT = 0,
    STRIPSETTING_EIGHTBITS = 1,
    STRIPSETTING_SEVENBITS = 2
} ;
#line 93
enum txonxoffsetting {
    XONXOFF_DEFAULT = 0,
    XONXOFF_OFF = 1,
    XONXOFF_ON = 2
} ;
#line 106 "../conn.h"
struct sconncmds {
   void (*pufree)(struct sconnection *qconn ) ;
   boolean (*pflock)(struct sconnection *qconn , boolean fin , boolean fuser ) ;
   boolean (*pfunlock)(struct sconnection *qconn ) ;
   boolean (*pfopen)(struct sconnection *qconn , long ibaud , boolean fwait , boolean fuser ) ;
   boolean (*pfclose)(struct sconnection *qconn , pointer puuconf , struct uuconf_dialer *qdialer ,
                      boolean fsuccess ) ;
   boolean (*pfdial)(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys ,
                     char const   *zphone , struct uuconf_dialer *qdialer , enum tdialerfound *ptdialerfound ) ;
   boolean (*pfread)(struct sconnection *qconn , char *zbuf , size_t *pclen , size_t cmin ,
                     int ctimeout , boolean freport ) ;
   boolean (*pfwrite)(struct sconnection *qconn , char const   *zbuf , size_t clen ) ;
   boolean (*pfio)(struct sconnection *qconn , char const   *zwrite , size_t *pcwrite ,
                   char *zread , size_t *pcread ) ;
   boolean (*pfbreak)(struct sconnection *qconn ) ;
   boolean (*pfset)(struct sconnection *qconn , enum tparitysetting tparity , enum tstripsetting tstrip ,
                    enum txonxoffsetting txonxoff ) ;
   boolean (*pfcarrier)(struct sconnection *qconn , boolean fcarrier ) ;
   boolean (*pfchat)(struct sconnection *qconn , char **pzprog ) ;
   long (*pibaud)(struct sconnection *qconn ) ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 187 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 543 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 62 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
typedef struct sockaddr_storage sockaddr_storage;
#line 57 "../uudefs.h"
enum tstatus_type {
    STATUS_COMPLETE = 0,
    STATUS_PORT_FAILED = 1,
    STATUS_DIAL_FAILED = 2,
    STATUS_LOGIN_FAILED = 3,
    STATUS_HANDSHAKE_FAILED = 4,
    STATUS_FAILED = 5,
    STATUS_TALKING = 6,
    STATUS_WRONG_TIME = 7,
    STATUS_VALUES = 8
} ;
#line 84 "../uudefs.h"
struct sstatus {
   enum tstatus_type ttype ;
   int cretries ;
   long ilast ;
   int cwait ;
   char *zstring ;
};
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/srmdir.c"
struct sdirlist {
   struct sdirlist *qnext ;
   char *zdir ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 50 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_8 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_9 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_10 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_11 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_12 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_13 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_7 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_8 _kill ;
   struct __anonstruct__timer_9 _timer ;
   struct __anonstruct__rt_10 _rt ;
   struct __anonstruct__sigchld_11 _sigchld ;
   struct __anonstruct__sigfault_12 _sigfault ;
   struct __anonstruct__sigpoll_13 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_7 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_25 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_25 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_41 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_41 fd_set;
#line 226 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
enum tclocal_setting {
    SET_CLOCAL = 0,
    CLEAR_CLOCAL = 1,
    IGNORE_CLOCAL = 2
} ;
#line 908 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
typedef speed_t baud_code;
#line 913 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
struct sbaud_table {
   baud_code icode ;
   long ibaud ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 42 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
typedef union wait wait_status;
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_49 {
   wait_status __in ;
   int __i ;
};
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_50 {
   wait_status __in ;
   int __i ;
};
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_51 {
   wait_status __in ;
   int __i ;
};
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_52 {
   wait_status __in ;
   int __i ;
};
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_53 {
   wait_status __in ;
   int __i ;
};
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_54 {
   wait_status __in ;
   int __i ;
};
#line 142 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_55 {
   wait_status __in ;
   int __i ;
};
#line 142 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_56 {
   wait_status __in ;
   int __i ;
};
#line 148 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_57 {
   wait_status __in ;
   int __i ;
};
#line 150 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_58 {
   wait_status __in ;
   int __i ;
};
#line 147 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_59 {
   wait_status __in ;
   int __i ;
};
#line 155 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_60 {
   wait_status __in ;
   int __i ;
};
#line 154 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
union __anonunion_61 {
   wait_status __in ;
   int __i ;
};
#line 173 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 177 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 22 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/fsusg.h"
struct fs_usage {
   long fsu_blocks ;
   long fsu_bfree ;
   long fsu_bavail ;
   long fsu_files ;
   long fsu_ffree ;
};
#line 29 "/usr/include/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsfilcnt_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 160 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 946 "../system.h"
enum tshell_cmd {
    SHELL_NORMAL = 0,
    SHELL_STDOUT_TO_PORT = 1,
    SHELL_STDIN_FROM_PORT = 2,
    SHELL_STDIO_ON_PORT = 3
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 1125 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
struct sjob {
   struct sjob *qnext ;
   struct uuconf_system  const  *qsys ;
   int ccmds ;
   struct scmd *pascmds ;
   char const   **pazlogs ;
};
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 301 "../uudefs.h"
void ( /* format attribute */  ulog)(enum tlog ttype , char const   *zmsg  , ...) ;
#line 388
pointer xmalloc(size_t c ) ;
#line 391
pointer xrealloc(pointer p , size_t c ) ;
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/xreall.c"
pointer xrealloc(pointer p , size_t c ) 
{ 
  pointer pret ;
  pointer tmp ;
  char *__cil_tmp5 ;

  {
#line 17
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = xmalloc(c);
    }
#line 18
    return (tmp);
  }
  {
#line 19
  pret = realloc(p, c);
  }
#line 20
  if ((unsigned long )pret == (unsigned long )((void *)0)) {
#line 20
    if (c != 0UL) {
      {
#line 21
      ulog((enum tlog )2, "Out of memory");
      }
    }
  }
#line 22
  return (pret);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 8 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/xmall.c"
pointer xmalloc(size_t c ) 
{ 
  pointer pret ;
  char *__cil_tmp3 ;

  {
  {
#line 14
  pret = malloc(c);
  }
#line 15
  if ((unsigned long )pret == (unsigned long )((void *)0)) {
#line 15
    if (c != 0UL) {
      {
#line 16
      ulog((enum tlog )2, "Out of memory");
      }
    }
  }
#line 17
  return (pret);
}
}
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 395 "../uudefs.h"
void xfree(pointer p ) ;
#line 9 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/xfree.c"
void xfree(pointer p ) 
{ 


  {
#line 13
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 14
    free(p);
    }
  }
#line 15
  return;
}
}
#line 81 "../uudefs.h"
char const   *azStatus[8] ;
#line 26 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/status.c"
char const   *azStatus[8]  = 
#line 26 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/status.c"
  {      "Conversation complete",      "Port unavailable",      "Dial failed",      "Login failed", 
        "Handshake failed",      "Call failed",      "Talking",      "Wrong time to call"};
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 234 "../uudefs.h"
boolean fspool_file(char const   *zfile ) ;
#line 16 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/spool.c"
boolean fspool_file(char const   *zfile ) 
{ 
  char const   *z ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 22
  if ((int const   )*zfile != 67) {
#line 22
    if ((int const   )*zfile != 68) {
#line 22
      if ((int const   )*zfile != 88) {
#line 23
        return (0);
      }
    }
  }
#line 24
  if ((int const   )*(zfile + 1) != 46) {
#line 25
    return (0);
  }
#line 26
  z = zfile + 2;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! ((int const   )*z != 0)) {
#line 26
      goto while_break;
    }
#line 27
    if ((int const   )*z == 47) {
#line 28
      return (0);
    } else {
      {
#line 27
      tmp = __ctype_b_loc();
      }
#line 27
      if ((int const   )*(*tmp + (int )((unsigned char )*z)) & 16384) {
        {
#line 27
        tmp___0 = __ctype_b_loc();
        }
#line 27
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*z)) & 8192) {
#line 28
          return (0);
        }
      } else {
#line 28
        return (0);
      }
    }
#line 26
    z ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return (1);
}
}
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quotes.c"
char const   quotes_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quotes.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'q',      (char const   )'u',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 291 "../uudefs.h"
char *zquote_cmd_string(char const   *zorig , boolean fbackslashonly ) ;
#line 379
char *zbufalc(size_t c ) ;
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quotes.c"
char *zquote_cmd_string(char const   *zorig , boolean fbackslashonly ) 
{ 
  char const   *z ;
  char *zret ;
  char *zto ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *__cil_tmp12 ;

  {
#line 46
  if ((unsigned long )zorig == (unsigned long )((void *)0)) {
#line 47
    return ((char *)((void *)0));
  }
  {
#line 49
  tmp = strlen(zorig);
#line 49
  zret = zbufalc(tmp * 4UL + 1UL);
#line 50
  zto = zret;
#line 51
  z = zorig;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((int const   )*z != 0)) {
#line 51
      goto while_break;
    }
#line 53
    if ((int const   )*z == 92) {
#line 55
      tmp___0 = zto;
#line 55
      zto ++;
#line 55
      *tmp___0 = (char )'\\';
#line 56
      tmp___1 = zto;
#line 56
      zto ++;
#line 56
      *tmp___1 = (char )'\\';
    } else
#line 58
    if (fbackslashonly) {
#line 59
      tmp___2 = zto;
#line 59
      zto ++;
#line 59
      *tmp___2 = (char )*z;
    } else {
      {
#line 58
      tmp___4 = __ctype_b_loc();
      }
#line 58
      if ((int const   )*(*tmp___4 + (int )((unsigned char )*z)) & 32768) {
#line 59
        tmp___2 = zto;
#line 59
        zto ++;
#line 59
        *tmp___2 = (char )*z;
      } else {
        {
#line 62
        sprintf((char */* __restrict  */)zto, (char const   */* __restrict  */)"\\%03o",
                (unsigned int )((unsigned char )*z));
#line 63
        tmp___3 = strlen((char const   *)zto);
#line 63
        zto += tmp___3;
        }
      }
    }
#line 51
    z ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  *zto = (char )'\000';
#line 69
  return (zret);
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
char const   quote_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'q',      (char const   )'u',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'2',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 280 "../uudefs.h"
boolean fcmd_needs_quotes(struct scmd  const  *qcmd ) ;
#line 283
void uquote_cmd(struct scmd  const  *qorig , struct scmd *qnew ) ;
#line 286
void ufree_quoted_cmd(struct scmd *qcmd ) ;
#line 382
char *zbufcpy(char const   *z ) ;
#line 385
void ubuffree(char *z ) ;
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
__inline static boolean fneeds_quotes(char const   *z ) ;
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
__inline static boolean fneeds_quotes(char const   *z ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 46
  if ((unsigned long )z != (unsigned long )((void *)0)) {
    {
#line 46
    tmp = strcspn(z, " \t\n");
    }
#line 46
    if ((int const   )*(z + tmp) != 0) {
#line 46
      tmp___0 = 1;
    } else {
#line 46
      tmp___0 = 0;
    }
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  return (tmp___0);
}
}
#line 51 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
boolean fcmd_needs_quotes(struct scmd  const  *qcmd ) 
{ 
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;

  {
  {
#line 55
  tmp = fneeds_quotes((char const   *)qcmd->zfrom);
  }
#line 55
  if (tmp) {
#line 59
    return (1);
  } else {
    {
#line 55
    tmp___0 = fneeds_quotes((char const   *)qcmd->zto);
    }
#line 55
    if (tmp___0) {
#line 59
      return (1);
    } else {
      {
#line 55
      tmp___1 = fneeds_quotes((char const   *)qcmd->zuser);
      }
#line 55
      if (tmp___1) {
#line 59
        return (1);
      } else {
        {
#line 55
        tmp___2 = fneeds_quotes((char const   *)qcmd->znotify);
        }
#line 55
        if (tmp___2) {
#line 59
          return (1);
        }
      }
    }
  }
#line 65
  return (0);
}
}
#line 72 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
void uquote_cmd(struct scmd  const  *qorig , struct scmd *qnew ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t clen ;
  char *z ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 77
  qnew->bcmd = (char )qorig->bcmd;
#line 78
  qnew->bgrade = (char )qorig->bgrade;
#line 79
  qnew->pseq = (pointer )qorig->pseq;
#line 80
  tmp = zquote_cmd_string((char const   *)qorig->zfrom, 0);
#line 80
  qnew->zfrom = (char const   *)tmp;
#line 81
  tmp___0 = zquote_cmd_string((char const   *)qorig->zto, 0);
#line 81
  qnew->zto = (char const   *)tmp___0;
#line 82
  tmp___1 = zquote_cmd_string((char const   *)qorig->zuser, 0);
#line 82
  qnew->zuser = (char const   *)tmp___1;
#line 84
  tmp___3 = strchr((char const   *)qorig->zoptions, 'q');
  }
#line 84
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
    {
#line 85
    tmp___2 = zbufcpy((char const   *)qorig->zoptions);
#line 85
    qnew->zoptions = (char const   *)tmp___2;
    }
  } else {
    {
#line 91
    clen = strlen((char const   *)qorig->zoptions);
#line 92
    z = zbufalc(clen + 2UL);
#line 93
    memcpy((void */* __restrict  */)z, (void const   */* __restrict  */)qorig->zoptions,
           clen);
#line 94
    *(z + clen) = (char )'q';
#line 95
    *(z + (clen + 1UL)) = (char )'\000';
#line 96
    qnew->zoptions = (char const   *)z;
    }
  }
  {
#line 99
  tmp___4 = zbufcpy((char const   *)qorig->ztemp);
#line 99
  qnew->ztemp = (char const   *)tmp___4;
#line 100
  qnew->imode = (unsigned int )qorig->imode;
#line 101
  tmp___5 = zquote_cmd_string((char const   *)qorig->znotify, 0);
#line 101
  qnew->znotify = (char const   *)tmp___5;
#line 102
  qnew->cbytes = (long )qorig->cbytes;
#line 105
  tmp___6 = zbufcpy((char const   *)qorig->zcmd);
#line 105
  qnew->zcmd = (char const   *)tmp___6;
#line 107
  qnew->ipos = (long )qorig->ipos;
  }
#line 108
  return;
}
}
#line 112 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/quote.c"
void ufree_quoted_cmd(struct scmd *qcmd ) 
{ 


  {
  {
#line 116
  ubuffree((char *)qcmd->zfrom);
#line 117
  ubuffree((char *)qcmd->zto);
#line 118
  ubuffree((char *)qcmd->zuser);
#line 119
  ubuffree((char *)qcmd->ztemp);
#line 120
  ubuffree((char *)qcmd->znotify);
#line 121
  ubuffree((char *)qcmd->zcmd);
#line 122
  ubuffree((char *)qcmd->zoptions);
  }
#line 123
  return;
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 346
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/parse.c"
char const   parse_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/parse.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'r', 
        (char const   )'s',      (char const   )'e',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'1',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 277 "../uudefs.h"
boolean fparse_cmd(char *zcmd , struct scmd *qcmd ) ;
#line 375
size_t cescape(char *z ) ;
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/parse.c"
static void ulunquote_cmd(struct scmd *qcmd ) ;
#line 46 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/parse.c"
boolean fparse_cmd(char *zcmd , struct scmd *qcmd ) 
{ 
  char *z ;
  char *zend ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 53
  z = strtok((char */* __restrict  */)zcmd, (char const   */* __restrict  */)" \t\n");
  }
#line 54
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 55
    return (0);
  }
#line 57
  qcmd->bcmd = *z;
#line 58
  if ((int )qcmd->bcmd != 83) {
#line 58
    if ((int )qcmd->bcmd != 82) {
#line 58
      if ((int )qcmd->bcmd != 88) {
#line 58
        if ((int )qcmd->bcmd != 69) {
#line 58
          if ((int )qcmd->bcmd != 72) {
#line 58
            if ((int )qcmd->bcmd != 80) {
#line 64
              return (0);
            }
          }
        }
      }
    }
  }
#line 66
  qcmd->bgrade = (char )'\000';
#line 67
  qcmd->pseq = (void *)0;
#line 68
  qcmd->zfrom = (char const   *)((void *)0);
#line 69
  qcmd->zto = (char const   *)((void *)0);
#line 70
  qcmd->zuser = (char const   *)((void *)0);
#line 71
  qcmd->zoptions = (char const   *)((void *)0);
#line 72
  qcmd->ztemp = (char const   *)((void *)0);
#line 73
  qcmd->imode = 438U;
#line 74
  qcmd->znotify = (char const   *)((void *)0);
#line 75
  qcmd->cbytes = -1L;
#line 76
  qcmd->zcmd = (char const   *)((void *)0);
#line 77
  qcmd->ipos = 0L;
#line 82
  if ((int )qcmd->bcmd == 72) {
#line 84
    if ((int )*(z + 1) != 0) {
#line 86
      if ((int )*(z + 1) == 89) {
#line 87
        qcmd->bcmd = (char )'Y';
      } else
#line 88
      if ((int )*(z + 1) == 78) {
#line 89
        qcmd->bcmd = (char )'N';
      } else {
#line 91
        return (0);
      }
    }
#line 94
    return (1);
  }
#line 96
  if ((int )qcmd->bcmd == 80) {
#line 97
    return (1);
  }
#line 99
  if ((int )*(z + 1) != 0) {
#line 100
    return (0);
  }
  {
#line 102
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 103
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 104
    return (0);
  }
  {
#line 105
  qcmd->zfrom = (char const   *)z;
#line 107
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 108
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 109
    return (0);
  }
  {
#line 110
  qcmd->zto = (char const   *)z;
#line 112
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 113
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 114
    return (0);
  }
  {
#line 115
  qcmd->zuser = (char const   *)z;
#line 117
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 118
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 119
    return (0);
  } else
#line 118
  if ((int )*z != 45) {
#line 119
    return (0);
  }
#line 120
  qcmd->zoptions = (char const   *)(z + 1);
#line 122
  if ((int )qcmd->bcmd == 88) {
    {
#line 124
    ulunquote_cmd(qcmd);
    }
#line 125
    return (1);
  }
#line 128
  if ((int )qcmd->bcmd == 82) {
    {
#line 130
    z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
    }
#line 131
    if ((unsigned long )z != (unsigned long )((void *)0)) {
      {
#line 133
      tmp___2 = strcmp((char const   *)z, "dummy");
      }
#line 133
      if (tmp___2 != 0) {
        {
#line 138
        qcmd->cbytes = strtol((char const   */* __restrict  */)z, (char **/* __restrict  */)(& zend),
                              0);
        }
#line 139
        if ((int )*zend != 0) {
#line 140
          qcmd->cbytes = -1L;
        }
      } else {
        {
#line 149
        tmp = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
        }
#line 149
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
#line 149
          tmp___0 = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
          }
#line 149
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
            {
#line 149
            tmp___1 = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
            }
#line 149
            if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
              {
#line 153
              z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
              }
#line 154
              if ((unsigned long )z != (unsigned long )((void *)0)) {
                {
#line 156
                qcmd->ipos = strtol((char const   */* __restrict  */)z, (char **/* __restrict  */)(& zend),
                                    0);
                }
#line 157
                if ((int )*zend != 0) {
#line 158
                  qcmd->ipos = 0L;
                }
              }
            }
          }
        }
      }
    }
    {
#line 164
    ulunquote_cmd(qcmd);
    }
#line 165
    return (1);
  }
  {
#line 168
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 169
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 170
    return (0);
  }
  {
#line 171
  qcmd->ztemp = (char const   *)z;
#line 173
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 174
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 175
    return (0);
  }
  {
#line 176
  tmp___3 = strtol((char const   */* __restrict  */)z, (char **/* __restrict  */)(& zend),
                   0);
#line 176
  qcmd->imode = (unsigned int )((int )tmp___3);
  }
#line 177
  if ((int )*zend != 0) {
#line 178
    return (0);
  }
#line 186
  if (qcmd->imode == 666U) {
#line 187
    qcmd->imode = 438U;
  } else
#line 188
  if (qcmd->imode == 777U) {
#line 189
    qcmd->imode = 511U;
  }
  {
#line 191
  z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
  }
#line 192
  if ((int )qcmd->bcmd == 69) {
#line 192
    if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 193
      return (0);
    }
  }
#line 194
  qcmd->znotify = (char const   *)z;
#line 200
  if ((unsigned long )z != (unsigned long )((void *)0)) {
    {
#line 200
    tmp___4 = strcmp((char const   *)z, "dummy");
    }
#line 200
    if (tmp___4 == 0) {
      {
#line 201
      z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
      }
    }
  }
#line 203
  if ((unsigned long )z != (unsigned long )((void *)0)) {
    {
#line 205
    z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t\n");
    }
#line 206
    if ((unsigned long )z != (unsigned long )((void *)0)) {
      {
#line 208
      qcmd->cbytes = strtol((char const   */* __restrict  */)z, (char **/* __restrict  */)(& zend),
                            0);
      }
#line 209
      if ((int )*zend != 0) {
#line 210
        qcmd->cbytes = -1L;
      }
    } else
#line 212
    if ((int )qcmd->bcmd == 69) {
#line 213
      return (0);
    }
#line 215
    if ((unsigned long )z != (unsigned long )((void *)0)) {
      {
#line 217
      z = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)"");
      }
#line 218
      if ((unsigned long )z != (unsigned long )((void *)0)) {
        {
#line 219
        tmp___5 = strcspn((char const   *)z, "\n");
#line 219
        *(z + tmp___5) = (char )'\000';
        }
      }
#line 220
      if ((int )qcmd->bcmd == 69) {
#line 220
        if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 221
          return (0);
        }
      }
#line 222
      qcmd->zcmd = (char const   *)z;
    }
  }
  {
#line 226
  ulunquote_cmd(qcmd);
  }
#line 228
  return (1);
}
}
#line 234 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/parse.c"
static void ulunquote_cmd(struct scmd *qcmd ) 
{ 
  char *tmp ;

  {
#line 238
  if ((unsigned long )qcmd->zoptions == (unsigned long )((void *)0)) {
#line 239
    return;
  } else {
    {
#line 238
    tmp = strchr(qcmd->zoptions, 'q');
    }
#line 238
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 239
      return;
    }
  }
#line 241
  if ((unsigned long )qcmd->zfrom != (unsigned long )((void *)0)) {
    {
#line 242
    cescape((char *)qcmd->zfrom);
    }
  }
#line 243
  if ((unsigned long )qcmd->zto != (unsigned long )((void *)0)) {
    {
#line 244
    cescape((char *)qcmd->zto);
    }
  }
#line 245
  if ((unsigned long )qcmd->zuser != (unsigned long )((void *)0)) {
    {
#line 246
    cescape((char *)qcmd->zuser);
    }
  }
#line 247
  if ((unsigned long )qcmd->znotify != (unsigned long )((void *)0)) {
    {
#line 248
    cescape((char *)qcmd->znotify);
    }
  }
#line 249
  if ((unsigned long )qcmd->zcmd != (unsigned long )((void *)0)) {
    {
#line 250
    cescape((char *)qcmd->zcmd);
    }
  }
#line 251
  return;
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 42 "../getopt.h"
char *gnu_optarg ;
#line 56
int gnu_optind ;
#line 61
int gnu_opterr ;
#line 111
int gnu_getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 119
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) ;
#line 55 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
char *gnu_optarg  =    (char *)0;
#line 69 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
int gnu_optind  =    0;
#line 78 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
static char *nextchar  ;
#line 83 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
int gnu_opterr  =    1;
#line 114 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
static enum __anonenum_ordering_42 ordering  ;
#line 128 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
static int first_nonopt  ;
#line 129 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
static int last_nonopt  ;
#line 140 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
static void exchange(char **argv ) 
{ 
  size_t nonopts_size ;
  char **temp ;
  void *tmp ;

  {
  {
#line 144
  nonopts_size = (unsigned long )(last_nonopt - first_nonopt) * sizeof(char *);
#line 145
  tmp = malloc(nonopts_size);
#line 145
  temp = (char **)tmp;
  }
#line 147
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 148
    abort();
    }
  }
  {
#line 152
  memcpy((void */* __restrict  */)((char *)temp), (void const   */* __restrict  */)((char *)(argv + first_nonopt)),
         nonopts_size);
#line 153
  memcpy((void */* __restrict  */)((char *)(argv + first_nonopt)), (void const   */* __restrict  */)((char *)(argv + last_nonopt)),
         (unsigned long )(gnu_optind - last_nonopt) * sizeof(char *));
#line 155
  memcpy((void */* __restrict  */)((char *)(argv + ((first_nonopt + gnu_optind) - last_nonopt))),
         (void const   */* __restrict  */)((char *)temp), nonopts_size);
#line 159
  xfree((pointer )temp);
#line 163
  first_nonopt += gnu_optind - last_nonopt;
#line 164
  last_nonopt = gnu_optind;
  }
#line 165
  return;
}
}
#line 223 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) 
{ 
  int option_index ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct option  const  *p ;
  char *s ;
  int exact ;
  int ambig ;
  struct option  const  *pfound ;
  int indfound ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char c ;
  char *tmp___11 ;
  char *temp ;
  char *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 234
  gnu_optarg = (char *)0;
#line 241
  if (gnu_optind == 0) {
#line 243
    gnu_optind = 1;
#line 243
    last_nonopt = gnu_optind;
#line 243
    first_nonopt = last_nonopt;
#line 245
    nextchar = (char *)((void *)0);
#line 249
    if ((int const   )*(optstring + 0) == 45) {
#line 251
      ordering = (enum __anonenum_ordering_42 )2;
#line 252
      optstring ++;
    } else
#line 254
    if ((int const   )*(optstring + 0) == 43) {
#line 256
      ordering = (enum __anonenum_ordering_42 )0;
#line 257
      optstring ++;
    } else {
      {
#line 259
      tmp = getenv("POSIXLY_CORRECT");
      }
#line 259
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 260
        ordering = (enum __anonenum_ordering_42 )0;
      } else {
#line 262
        ordering = (enum __anonenum_ordering_42 )1;
      }
    }
  }
#line 265
  if ((unsigned long )nextchar == (unsigned long )((void *)0)) {
#line 265
    goto _L___2;
  } else
#line 265
  if ((int )*nextchar == 0) {
    _L___2: /* CIL Label */ 
#line 267
    if ((unsigned int )ordering == 1U) {
#line 272
      if (first_nonopt != last_nonopt) {
#line 272
        if (last_nonopt != gnu_optind) {
          {
#line 273
          exchange((char **)argv);
          }
        } else {
#line 272
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 274
      if (last_nonopt != gnu_optind) {
#line 275
        first_nonopt = gnu_optind;
      }
      {
#line 280
      while (1) {
        while_continue: /* CIL Label */ ;
#line 280
        if (gnu_optind < argc) {
#line 280
          if (! ((int )*(*(argv + gnu_optind) + 0) != 45)) {
#line 280
            if (! ((int )*(*(argv + gnu_optind) + 1) == 0)) {
#line 280
              goto while_break;
            }
          }
        } else {
#line 280
          goto while_break;
        }
#line 287
        gnu_optind ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 288
      last_nonopt = gnu_optind;
    }
#line 296
    if (gnu_optind != argc) {
      {
#line 296
      tmp___0 = strcmp((char const   *)*(argv + gnu_optind), "--");
      }
#line 296
      if (! tmp___0) {
#line 298
        gnu_optind ++;
#line 300
        if (first_nonopt != last_nonopt) {
#line 300
          if (last_nonopt != gnu_optind) {
            {
#line 301
            exchange((char **)argv);
            }
          } else {
#line 300
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 302
        if (first_nonopt == last_nonopt) {
#line 303
          first_nonopt = gnu_optind;
        }
#line 304
        last_nonopt = argc;
#line 306
        gnu_optind = argc;
      }
    }
#line 312
    if (gnu_optind == argc) {
#line 316
      if (first_nonopt != last_nonopt) {
#line 317
        gnu_optind = first_nonopt;
      }
#line 318
      return (-1);
    }
#line 324
    if ((int )*(*(argv + gnu_optind) + 0) != 45) {
#line 324
      goto _L___1;
    } else
#line 324
    if ((int )*(*(argv + gnu_optind) + 1) == 0) {
      _L___1: /* CIL Label */ 
#line 331
      if ((unsigned int )ordering == 0U) {
#line 332
        return (-1);
      }
#line 333
      tmp___1 = gnu_optind;
#line 333
      gnu_optind ++;
#line 333
      gnu_optarg = (char *)*(argv + tmp___1);
#line 334
      return (1);
    }
#line 340
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 340
      if ((int )*(*(argv + gnu_optind) + 1) == 45) {
#line 340
        tmp___2 = 1;
      } else {
#line 340
        tmp___2 = 0;
      }
    } else {
#line 340
      tmp___2 = 0;
    }
#line 340
    nextchar = (char *)((*(argv + gnu_optind) + 1) + tmp___2);
  }
#line 344
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 344
    if ((int )*(*(argv + gnu_optind) + 0) == 45) {
#line 344
      if ((int )*(*(argv + gnu_optind) + 1) == 45) {
#line 344
        goto _L___4;
      } else
#line 344
      if (long_only) {
        _L___4: /* CIL Label */ 
#line 353
        s = nextchar;
#line 354
        exact = 0;
#line 355
        ambig = 0;
#line 356
        pfound = (struct option  const  *)((void *)0);
#line 357
        indfound = 0;
        {
#line 359
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 359
          if (*s) {
#line 359
            if (! ((int )*s != 61)) {
#line 359
              goto while_break___0;
            }
          } else {
#line 359
            goto while_break___0;
          }
#line 360
          s ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 363
        p = longopts;
#line 363
        option_index = 0;
        {
#line 363
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 363
          if (! p->name) {
#line 363
            goto while_break___1;
          }
          {
#line 365
          tmp___4 = strncmp((char const   *)p->name, (char const   *)nextchar, (size_t )(s - nextchar));
          }
#line 365
          if (! tmp___4) {
            {
#line 367
            tmp___3 = strlen((char const   *)p->name);
            }
#line 367
            if ((size_t )(s - nextchar) == tmp___3) {
#line 370
              pfound = p;
#line 371
              indfound = option_index;
#line 372
              exact = 1;
#line 373
              goto while_break___1;
            } else
#line 375
            if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 378
              pfound = p;
#line 379
              indfound = option_index;
            } else {
#line 383
              ambig = 1;
            }
          }
#line 363
          p ++;
#line 363
          option_index ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 386
        if (ambig) {
#line 386
          if (! exact) {
#line 388
            if (gnu_opterr) {
              {
#line 389
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' is ambiguous\n",
                      *(argv + 0), *(argv + gnu_optind));
              }
            }
            {
#line 391
            tmp___5 = strlen((char const   *)nextchar);
#line 391
            nextchar += tmp___5;
#line 392
            gnu_optind ++;
            }
#line 393
            return ('?');
          }
        }
#line 396
        if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 398
          option_index = indfound;
#line 399
          gnu_optind ++;
#line 400
          if (*s) {
#line 404
            if (pfound->has_arg) {
#line 405
              gnu_optarg = s + 1;
            } else {
#line 408
              if (gnu_opterr) {
#line 410
                if ((int )*(*(argv + (gnu_optind - 1)) + 1) == 45) {
                  {
#line 412
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `--%s\' doesn\'t allow an argument\n",
                          *(argv + 0), pfound->name);
                  }
                } else {
                  {
#line 417
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%c%s\' doesn\'t allow an argument\n",
                          *(argv + 0), (int )*(*(argv + (gnu_optind - 1)) + 0), pfound->name);
                  }
                }
              }
              {
#line 421
              tmp___6 = strlen((char const   *)nextchar);
#line 421
              nextchar += tmp___6;
              }
#line 422
              return ('?');
            }
          } else
#line 425
          if (pfound->has_arg == 1) {
#line 427
            if (gnu_optind < argc) {
#line 428
              tmp___7 = gnu_optind;
#line 428
              gnu_optind ++;
#line 428
              gnu_optarg = (char *)*(argv + tmp___7);
            } else {
#line 431
              if (gnu_opterr) {
                {
#line 432
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' requires an argument\n",
                        *(argv + 0), *(argv + (gnu_optind - 1)));
                }
              }
              {
#line 434
              tmp___8 = strlen((char const   *)nextchar);
#line 434
              nextchar += tmp___8;
              }
#line 435
              return ('?');
            }
          }
          {
#line 438
          tmp___9 = strlen((char const   *)nextchar);
#line 438
          nextchar += tmp___9;
          }
#line 439
          if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 440
            *longind = option_index;
          }
#line 441
          if (pfound->flag) {
#line 443
            *(pfound->flag) = (int )pfound->val;
#line 444
            return (0);
          }
#line 446
          return ((int )pfound->val);
        }
#line 452
        if (! long_only) {
#line 452
          goto _L___3;
        } else
#line 452
        if ((int )*(*(argv + gnu_optind) + 1) == 45) {
#line 452
          goto _L___3;
        } else {
          {
#line 452
          tmp___10 = strchr(optstring, (int )*nextchar);
          }
#line 452
          if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 458
            if (gnu_opterr) {
#line 460
              if ((int )*(*(argv + gnu_optind) + 1) == 45) {
                {
#line 462
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `--%s\'\n",
                        *(argv + 0), nextchar);
                }
              } else {
                {
#line 466
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `%c%s\'\n",
                        *(argv + 0), (int )*(*(argv + gnu_optind) + 0), nextchar);
                }
              }
            }
#line 469
            nextchar = (char *)"";
#line 470
            gnu_optind ++;
#line 471
            return ('?');
          }
        }
      }
    }
  }
  {
#line 478
  tmp___11 = nextchar;
#line 478
  nextchar ++;
#line 478
  c = *tmp___11;
#line 479
  tmp___12 = strchr(optstring, (int )c);
#line 479
  temp = tmp___12;
  }
#line 482
  if ((int )*nextchar == 0) {
#line 483
    gnu_optind ++;
  }
#line 485
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 485
    goto _L___5;
  } else
#line 485
  if ((int )c == 58) {
    _L___5: /* CIL Label */ 
#line 487
    if (gnu_opterr) {
#line 489
      if ((int )c < 32) {
        {
#line 490
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option, character code 0%o\n",
                *(argv + 0), (int )((unsigned char )c));
        }
      } else
#line 489
      if ((int )c >= 127) {
        {
#line 490
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option, character code 0%o\n",
                *(argv + 0), (int )((unsigned char )c));
        }
      } else {
        {
#line 493
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `-%c\'\n",
                *(argv + 0), (int )c);
        }
      }
    }
#line 495
    return ('?');
  }
#line 497
  if ((int )*(temp + 1) == 58) {
#line 499
    if ((int )*(temp + 2) == 58) {
#line 502
      if ((int )*nextchar != 0) {
#line 504
        gnu_optarg = nextchar;
#line 505
        gnu_optind ++;
      } else {
#line 508
        gnu_optarg = (char *)0;
      }
#line 509
      nextchar = (char *)((void *)0);
    } else {
#line 514
      if ((int )*nextchar != 0) {
#line 516
        gnu_optarg = nextchar;
#line 519
        gnu_optind ++;
      } else
#line 521
      if (gnu_optind == argc) {
#line 523
        if (gnu_opterr) {
          {
#line 524
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `-%c\' requires an argument\n",
                  *(argv + 0), (int )c);
          }
        }
#line 526
        c = (char )'?';
      } else {
#line 531
        tmp___13 = gnu_optind;
#line 531
        gnu_optind ++;
#line 531
        gnu_optarg = (char *)*(argv + tmp___13);
      }
#line 532
      nextchar = (char *)((void *)0);
    }
  }
#line 535
  return ((int )c);
}
}
#line 539 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getopt.c"
int gnu_getopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 545
  tmp = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                         0);
  }
#line 545
  return (tmp);
}
}
#line 112 "../getopt.h"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) ;
#line 114
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) ;
#line 25 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getop1.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 0);
  }
#line 33
  return (tmp);
}
}
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/getop1.c"
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 1);
  }
#line 49
  return (tmp);
}
}
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/escape.c"
size_t cescape(char *z ) 
{ 
  char *zto ;
  char *zfrom ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int i ;
  char *tmp___9 ;
  int i___0 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *__cil_tmp22 ;

  {
#line 16
  zto = z;
#line 17
  zfrom = z;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((int )*zfrom != 0)) {
#line 18
      goto while_break;
    }
#line 20
    if ((int )*zfrom != 92) {
#line 22
      tmp = zto;
#line 22
      zto ++;
#line 22
      tmp___0 = zfrom;
#line 22
      zfrom ++;
#line 22
      *tmp = *tmp___0;
#line 23
      goto while_continue;
    }
#line 25
    zfrom ++;
    {
#line 28
    if ((int )*zfrom == 45) {
#line 28
      goto case_45;
    }
#line 31
    if ((int )*zfrom == 98) {
#line 31
      goto case_98;
    }
#line 34
    if ((int )*zfrom == 110) {
#line 34
      goto case_110;
    }
#line 37
    if ((int )*zfrom == 78) {
#line 37
      goto case_78;
    }
#line 40
    if ((int )*zfrom == 114) {
#line 40
      goto case_114;
    }
#line 43
    if ((int )*zfrom == 115) {
#line 43
      goto case_115;
    }
#line 46
    if ((int )*zfrom == 116) {
#line 46
      goto case_116;
    }
#line 49
    if ((int )*zfrom == 0) {
#line 49
      goto case_0;
    }
#line 52
    if ((int )*zfrom == 92) {
#line 52
      goto case_92;
    }
#line 56
    if ((int )*zfrom == 57) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 56) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 55) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 54) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 53) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 52) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 51) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 50) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 49) {
#line 56
      goto case_57;
    }
#line 56
    if ((int )*zfrom == 48) {
#line 56
      goto case_57;
    }
#line 68
    if ((int )*zfrom == 120) {
#line 68
      goto case_120;
    }
#line 85
    goto switch_default;
    case_45: /* CIL Label */ 
#line 29
    tmp___1 = zto;
#line 29
    zto ++;
#line 29
    *tmp___1 = (char )'-';
#line 30
    goto switch_break;
    case_98: /* CIL Label */ 
#line 32
    tmp___2 = zto;
#line 32
    zto ++;
#line 32
    *tmp___2 = (char )'\b';
#line 33
    goto switch_break;
    case_110: /* CIL Label */ 
#line 35
    tmp___3 = zto;
#line 35
    zto ++;
#line 35
    *tmp___3 = (char )'\n';
#line 36
    goto switch_break;
    case_78: /* CIL Label */ 
#line 38
    tmp___4 = zto;
#line 38
    zto ++;
#line 38
    *tmp___4 = (char )'\000';
#line 39
    goto switch_break;
    case_114: /* CIL Label */ 
#line 41
    tmp___5 = zto;
#line 41
    zto ++;
#line 41
    *tmp___5 = (char )'\r';
#line 42
    goto switch_break;
    case_115: /* CIL Label */ 
#line 44
    tmp___6 = zto;
#line 44
    zto ++;
#line 44
    *tmp___6 = (char )' ';
#line 45
    goto switch_break;
    case_116: /* CIL Label */ 
#line 47
    tmp___7 = zto;
#line 47
    zto ++;
#line 47
    *tmp___7 = (char )'\t';
#line 48
    goto switch_break;
    case_0: /* CIL Label */ 
#line 50
    zfrom --;
    case_92: /* CIL Label */ 
#line 53
    tmp___8 = zto;
#line 53
    zto ++;
#line 53
    *tmp___8 = (char )'\\';
#line 54
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 60
    i = (int )*zfrom - 48;
#line 61
    if ((int )*(zfrom + 1) >= 48) {
#line 61
      if ((int )*(zfrom + 1) <= 55) {
#line 62
        zfrom ++;
#line 62
        i = (8 * i + (int )*zfrom) - 48;
      }
    }
#line 63
    if ((int )*(zfrom + 1) >= 48) {
#line 63
      if ((int )*(zfrom + 1) <= 55) {
#line 64
        zfrom ++;
#line 64
        i = (8 * i + (int )*zfrom) - 48;
      }
    }
#line 65
    tmp___9 = zto;
#line 65
    zto ++;
#line 65
    *tmp___9 = (char )i;
#line 67
    goto switch_break;
    case_120: /* CIL Label */ 
#line 72
    i___0 = 0;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 73
      tmp___12 = __ctype_b_loc();
      }
#line 73
      if (! ((int const   )*(*tmp___12 + (int )((unsigned char )*(zfrom + 1))) & 4096)) {
#line 73
        goto while_break___0;
      }
      {
#line 75
      tmp___11 = __ctype_b_loc();
      }
#line 75
      if ((int const   )*(*tmp___11 + (int )((unsigned char )*(zfrom + 1))) & 2048) {
#line 76
        zfrom ++;
#line 76
        i___0 = (16 * i___0 + (int )*zfrom) - 48;
      } else {
        {
#line 77
        tmp___10 = __ctype_b_loc();
        }
#line 77
        if ((int const   )*(*tmp___10 + (int )((unsigned char )*(zfrom + 1))) & 256) {
#line 78
          zfrom ++;
#line 78
          i___0 = ((16 * i___0 + (int )*zfrom) - 65) + 10;
        } else {
#line 80
          zfrom ++;
#line 80
          i___0 = ((16 * i___0 + (int )*zfrom) - 97) + 10;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 82
    tmp___13 = zto;
#line 82
    zto ++;
#line 82
    *tmp___13 = (char )i___0;
#line 84
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 86
    ulog((enum tlog )1, "Unrecognized escape sequence \\%c", (int )*zfrom);
#line 88
    tmp___14 = zto;
#line 88
    zto ++;
#line 88
    *tmp___14 = *zfrom;
    }
#line 89
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 92
    zfrom ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  *zto = (char )'\000';
#line 97
  return ((size_t )(zto - z));
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 144 "../uudefs.h"
int iDebug  ;
#line 348
void udebug_buffer(char const   *zhdr , char const   *zbuf___0 , size_t clen ) ;
#line 354
size_t cdebug_char(char *z , int ichar ) ;
#line 359
int idebug_parse(char const   *z ) ;
#line 40 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/debug.c"
static char const   * const  azDebug_names[12]  = 
#line 40 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/debug.c"
  {      (char const   */* const  */)"a",      (char const   */* const  */)"ch",      (char const   */* const  */)"h",      (char const   */* const  */)"u", 
        (char const   */* const  */)"pr",      (char const   */* const  */)"po",      (char const   */* const  */)"co",      (char const   */* const  */)"s", 
        (char const   */* const  */)"e",      (char const   */* const  */)"i",      (char const   */* const  */)"o",      (char const   */* const  */)((void *)0)};
#line 42 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/debug.c"
int idebug_parse(char const   *z ) 
{ 
  char *zend ;
  int i ;
  int iret ;
  char *zcopy ;
  char *ztok ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 50
  tmp = strncasecmp(z, "n", sizeof("n") - 1UL);
  }
#line 50
  if (tmp == 0) {
#line 51
    return (0);
  }
  {
#line 53
  tmp___0 = strtol((char const   */* __restrict  */)((char *)z), (char **/* __restrict  */)(& zend),
                   0);
#line 53
  i = (int )tmp___0;
  }
#line 54
  if ((int )*zend == 0) {
#line 56
    if (i > 15) {
#line 57
      i = 15;
    } else
#line 58
    if (i < 0) {
#line 59
      i = 0;
    }
#line 60
    return ((1 << i) - 1);
  }
  {
#line 63
  zcopy = zbufcpy(z);
#line 65
  iret = 0;
#line 67
  ztok = strtok((char */* __restrict  */)zcopy, (char const   */* __restrict  */)", \t");
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )ztok != (unsigned long )((void *)0))) {
#line 67
      goto while_break;
    }
    {
#line 71
    tmp___1 = strcasecmp((char const   *)ztok, "all");
    }
#line 71
    if (tmp___1 == 0) {
#line 73
      iret = 2047;
#line 74
      goto while_break;
    }
#line 76
    i = 0;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (! ((unsigned long )azDebug_names[i] != (unsigned long )((void *)0))) {
#line 76
        goto while_break___0;
      }
      {
#line 78
      tmp___2 = strlen((char const   *)azDebug_names[i]);
#line 78
      tmp___3 = strncasecmp((char const   *)ztok, (char const   *)azDebug_names[i],
                            tmp___2);
      }
#line 78
      if (tmp___3 == 0) {
#line 81
        iret |= 1 << i;
#line 82
        goto while_break___0;
      }
#line 76
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 85
    if ((unsigned long )azDebug_names[i] == (unsigned long )((void *)0)) {
      {
#line 86
      ulog((enum tlog )1, "Unrecognized debugging option \"%s\"", ztok);
      }
    }
    {
#line 67
    ztok = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)", \t");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  ubuffree(zcopy);
  }
#line 92
  return (iret);
}
}
#line 99 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/debug.c"
size_t cdebug_char(char *z , int ichar ) 
{ 
  char b ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 106
  tmp___0 = __ctype_b_loc();
  }
#line 106
  if ((int const   )*(*tmp___0 + (int )((unsigned char )ichar)) & 16384) {
#line 106
    if (ichar != 34) {
#line 106
      if (ichar != 92) {
#line 110
        tmp = z;
#line 110
        z ++;
#line 110
        *tmp = (char )ichar;
#line 111
        *z = (char )'\000';
#line 112
        return ((size_t )1);
      }
    }
  }
#line 115
  tmp___1 = z;
#line 115
  z ++;
#line 115
  *tmp___1 = (char )'\\';
  {
#line 119
  if (ichar == 10) {
#line 119
    goto case_10;
  }
#line 122
  if (ichar == 13) {
#line 122
    goto case_13;
  }
#line 125
  if (ichar == 34) {
#line 125
    goto case_34;
  }
#line 128
  if (ichar == 92) {
#line 128
    goto case_92;
  }
#line 131
  goto switch_default;
  case_10: /* CIL Label */ 
#line 120
  b = (char )'n';
#line 121
  goto switch_break;
  case_13: /* CIL Label */ 
#line 123
  b = (char )'r';
#line 124
  goto switch_break;
  case_34: /* CIL Label */ 
#line 126
  b = (char )'\"';
#line 127
  goto switch_break;
  case_92: /* CIL Label */ 
#line 129
  b = (char )'\\';
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 132
  sprintf((char */* __restrict  */)z, (char const   */* __restrict  */)"%03o", (unsigned int )((unsigned char )ichar));
#line 133
  tmp___2 = strlen((char const   *)z);
  }
#line 133
  return (tmp___2 + 1UL);
  switch_break: /* CIL Label */ ;
  }
#line 136
  tmp___3 = z;
#line 136
  z ++;
#line 136
  *tmp___3 = b;
#line 137
  *z = (char )'\000';
#line 138
  return ((size_t )2);
}
}
#line 145 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/debug.c"
void udebug_buffer(char const   *zhdr , char const   *zbuf___0 , size_t clen ) 
{ 
  char *z ;
  char *zalc ;
  size_t i ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;

  {
  {
#line 154
  zalc = zbufalc(clen * 4UL + 1UL);
#line 156
  z = zalc;
#line 157
  i = (size_t )0;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (i < clen) {
#line 157
      if (! (i < 80UL)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = cdebug_char(z, (int )*(zbuf___0 + i));
#line 158
    z += tmp;
#line 157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  if (i < clen) {
#line 161
    tmp___0 = z;
#line 161
    z ++;
#line 161
    *tmp___0 = (char )'.';
#line 162
    tmp___1 = z;
#line 162
    z ++;
#line 162
    *tmp___1 = (char )'.';
#line 163
    tmp___2 = z;
#line 163
    z ++;
#line 163
    *tmp___2 = (char )'.';
  }
  {
#line 165
  *z = (char )'\000';
#line 167
  ulog((enum tlog )3, "%s %lu \"%s\"", zhdr, clen, zalc);
#line 169
  ubuffree(zalc);
  }
#line 170
  return;
}
}
#line 114 "../prot.h"
unsigned long icrc(char const   *z , size_t c , unsigned long ick ) ;
#line 45 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/crc.c"
static unsigned long const   aicrc32tab[256]  = 
#line 45 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/crc.c"
  {      (unsigned long const   )0L,      (unsigned long const   )1996959894L,      (unsigned long const   )3993919788L,      (unsigned long const   )2567524794L, 
        (unsigned long const   )124634137L,      (unsigned long const   )1886057615L,      (unsigned long const   )3915621685L,      (unsigned long const   )2657392035L, 
        (unsigned long const   )249268274L,      (unsigned long const   )2044508324L,      (unsigned long const   )3772115230L,      (unsigned long const   )2547177864L, 
        (unsigned long const   )162941995L,      (unsigned long const   )2125561021L,      (unsigned long const   )3887607047L,      (unsigned long const   )2428444049L, 
        (unsigned long const   )498536548L,      (unsigned long const   )1789927666L,      (unsigned long const   )4089016648L,      (unsigned long const   )2227061214L, 
        (unsigned long const   )450548861L,      (unsigned long const   )1843258603L,      (unsigned long const   )4107580753L,      (unsigned long const   )2211677639L, 
        (unsigned long const   )325883990L,      (unsigned long const   )1684777152L,      (unsigned long const   )4251122042L,      (unsigned long const   )2321926636L, 
        (unsigned long const   )335633487L,      (unsigned long const   )1661365465L,      (unsigned long const   )4195302755L,      (unsigned long const   )2366115317L, 
        (unsigned long const   )997073096L,      (unsigned long const   )1281953886L,      (unsigned long const   )3579855332L,      (unsigned long const   )2724688242L, 
        (unsigned long const   )1006888145L,      (unsigned long const   )1258607687L,      (unsigned long const   )3524101629L,      (unsigned long const   )2768942443L, 
        (unsigned long const   )901097722L,      (unsigned long const   )1119000684L,      (unsigned long const   )3686517206L,      (unsigned long const   )2898065728L, 
        (unsigned long const   )853044451L,      (unsigned long const   )1172266101L,      (unsigned long const   )3705015759L,      (unsigned long const   )2882616665L, 
        (unsigned long const   )651767980L,      (unsigned long const   )1373503546L,      (unsigned long const   )3369554304L,      (unsigned long const   )3218104598L, 
        (unsigned long const   )565507253L,      (unsigned long const   )1454621731L,      (unsigned long const   )3485111705L,      (unsigned long const   )3099436303L, 
        (unsigned long const   )671266974L,      (unsigned long const   )1594198024L,      (unsigned long const   )3322730930L,      (unsigned long const   )2970347812L, 
        (unsigned long const   )795835527L,      (unsigned long const   )1483230225L,      (unsigned long const   )3244367275L,      (unsigned long const   )3060149565L, 
        (unsigned long const   )1994146192L,      (unsigned long const   )31158534L,      (unsigned long const   )2563907772L,      (unsigned long const   )4023717930L, 
        (unsigned long const   )1907459465L,      (unsigned long const   )112637215L,      (unsigned long const   )2680153253L,      (unsigned long const   )3904427059L, 
        (unsigned long const   )2013776290L,      (unsigned long const   )251722036L,      (unsigned long const   )2517215374L,      (unsigned long const   )3775830040L, 
        (unsigned long const   )2137656763L,      (unsigned long const   )141376813L,      (unsigned long const   )2439277719L,      (unsigned long const   )3865271297L, 
        (unsigned long const   )1802195444L,      (unsigned long const   )476864866L,      (unsigned long const   )2238001368L,      (unsigned long const   )4066508878L, 
        (unsigned long const   )1812370925L,      (unsigned long const   )453092731L,      (unsigned long const   )2181625025L,      (unsigned long const   )4111451223L, 
        (unsigned long const   )1706088902L,      (unsigned long const   )314042704L,      (unsigned long const   )2344532202L,      (unsigned long const   )4240017532L, 
        (unsigned long const   )1658658271L,      (unsigned long const   )366619977L,      (unsigned long const   )2362670323L,      (unsigned long const   )4224994405L, 
        (unsigned long const   )1303535960L,      (unsigned long const   )984961486L,      (unsigned long const   )2747007092L,      (unsigned long const   )3569037538L, 
        (unsigned long const   )1256170817L,      (unsigned long const   )1037604311L,      (unsigned long const   )2765210733L,      (unsigned long const   )3554079995L, 
        (unsigned long const   )1131014506L,      (unsigned long const   )879679996L,      (unsigned long const   )2909243462L,      (unsigned long const   )3663771856L, 
        (unsigned long const   )1141124467L,      (unsigned long const   )855842277L,      (unsigned long const   )2852801631L,      (unsigned long const   )3708648649L, 
        (unsigned long const   )1342533948L,      (unsigned long const   )654459306L,      (unsigned long const   )3188396048L,      (unsigned long const   )3373015174L, 
        (unsigned long const   )1466479909L,      (unsigned long const   )544179635L,      (unsigned long const   )3110523913L,      (unsigned long const   )3462522015L, 
        (unsigned long const   )1591671054L,      (unsigned long const   )702138776L,      (unsigned long const   )2966460450L,      (unsigned long const   )3352799412L, 
        (unsigned long const   )1504918807L,      (unsigned long const   )783551873L,      (unsigned long const   )3082640443L,      (unsigned long const   )3233442989L, 
        (unsigned long const   )3988292384L,      (unsigned long const   )2596254646L,      (unsigned long const   )62317068L,      (unsigned long const   )1957810842L, 
        (unsigned long const   )3939845945L,      (unsigned long const   )2647816111L,      (unsigned long const   )81470997L,      (unsigned long const   )1943803523L, 
        (unsigned long const   )3814918930L,      (unsigned long const   )2489596804L,      (unsigned long const   )225274430L,      (unsigned long const   )2053790376L, 
        (unsigned long const   )3826175755L,      (unsigned long const   )2466906013L,      (unsigned long const   )167816743L,      (unsigned long const   )2097651377L, 
        (unsigned long const   )4027552580L,      (unsigned long const   )2265490386L,      (unsigned long const   )503444072L,      (unsigned long const   )1762050814L, 
        (unsigned long const   )4150417245L,      (unsigned long const   )2154129355L,      (unsigned long const   )426522225L,      (unsigned long const   )1852507879L, 
        (unsigned long const   )4275313526L,      (unsigned long const   )2312317920L,      (unsigned long const   )282753626L,      (unsigned long const   )1742555852L, 
        (unsigned long const   )4189708143L,      (unsigned long const   )2394877945L,      (unsigned long const   )397917763L,      (unsigned long const   )1622183637L, 
        (unsigned long const   )3604390888L,      (unsigned long const   )2714866558L,      (unsigned long const   )953729732L,      (unsigned long const   )1340076626L, 
        (unsigned long const   )3518719985L,      (unsigned long const   )2797360999L,      (unsigned long const   )1068828381L,      (unsigned long const   )1219638859L, 
        (unsigned long const   )3624741850L,      (unsigned long const   )2936675148L,      (unsigned long const   )906185462L,      (unsigned long const   )1090812512L, 
        (unsigned long const   )3747672003L,      (unsigned long const   )2825379669L,      (unsigned long const   )829329135L,      (unsigned long const   )1181335161L, 
        (unsigned long const   )3412177804L,      (unsigned long const   )3160834842L,      (unsigned long const   )628085408L,      (unsigned long const   )1382605366L, 
        (unsigned long const   )3423369109L,      (unsigned long const   )3138078467L,      (unsigned long const   )570562233L,      (unsigned long const   )1426400815L, 
        (unsigned long const   )3317316542L,      (unsigned long const   )2998733608L,      (unsigned long const   )733239954L,      (unsigned long const   )1555261956L, 
        (unsigned long const   )3268935591L,      (unsigned long const   )3050360625L,      (unsigned long const   )752459403L,      (unsigned long const   )1541320221L, 
        (unsigned long const   )2607071920L,      (unsigned long const   )3965973030L,      (unsigned long const   )1969922972L,      (unsigned long const   )40735498L, 
        (unsigned long const   )2617837225L,      (unsigned long const   )3943577151L,      (unsigned long const   )1913087877L,      (unsigned long const   )83908371L, 
        (unsigned long const   )2512341634L,      (unsigned long const   )3803740692L,      (unsigned long const   )2075208622L,      (unsigned long const   )213261112L, 
        (unsigned long const   )2463272603L,      (unsigned long const   )3855990285L,      (unsigned long const   )2094854071L,      (unsigned long const   )198958881L, 
        (unsigned long const   )2262029012L,      (unsigned long const   )4057260610L,      (unsigned long const   )1759359992L,      (unsigned long const   )534414190L, 
        (unsigned long const   )2176718541L,      (unsigned long const   )4139329115L,      (unsigned long const   )1873836001L,      (unsigned long const   )414664567L, 
        (unsigned long const   )2282248934L,      (unsigned long const   )4279200368L,      (unsigned long const   )1711684554L,      (unsigned long const   )285281116L, 
        (unsigned long const   )2405801727L,      (unsigned long const   )4167216745L,      (unsigned long const   )1634467795L,      (unsigned long const   )376229701L, 
        (unsigned long const   )2685067896L,      (unsigned long const   )3608007406L,      (unsigned long const   )1308918612L,      (unsigned long const   )956543938L, 
        (unsigned long const   )2808555105L,      (unsigned long const   )3495958263L,      (unsigned long const   )1231636301L,      (unsigned long const   )1047427035L, 
        (unsigned long const   )2932959818L,      (unsigned long const   )3654703836L,      (unsigned long const   )1088359270L,      (unsigned long const   )936918000L, 
        (unsigned long const   )2847714899L,      (unsigned long const   )3736837829L,      (unsigned long const   )1202900863L,      (unsigned long const   )817233897L, 
        (unsigned long const   )3183342108L,      (unsigned long const   )3401237130L,      (unsigned long const   )1404277552L,      (unsigned long const   )615818150L, 
        (unsigned long const   )3134207493L,      (unsigned long const   )3453421203L,      (unsigned long const   )1423857449L,      (unsigned long const   )601450431L, 
        (unsigned long const   )3009837614L,      (unsigned long const   )3294710456L,      (unsigned long const   )1567103746L,      (unsigned long const   )711928724L, 
        (unsigned long const   )3020668471L,      (unsigned long const   )3272380065L,      (unsigned long const   )1510334235L,      (unsigned long const   )755167117L};
#line 95 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/crc.c"
unsigned long icrc(char const   *z , size_t c , unsigned long ick ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (c > 4UL)) {
#line 101
      goto while_break;
    }
#line 103
    tmp = z;
#line 103
    z ++;
#line 103
    ick = (unsigned long )(aicrc32tab[((int )ick ^ (int )*tmp) & 255] ^ (unsigned long const   )((ick >> 8) & 16777215UL));
#line 104
    tmp___0 = z;
#line 104
    z ++;
#line 104
    ick = (unsigned long )(aicrc32tab[((int )ick ^ (int )*tmp___0) & 255] ^ (unsigned long const   )((ick >> 8) & 16777215UL));
#line 105
    tmp___1 = z;
#line 105
    z ++;
#line 105
    ick = (unsigned long )(aicrc32tab[((int )ick ^ (int )*tmp___1) & 255] ^ (unsigned long const   )((ick >> 8) & 16777215UL));
#line 106
    tmp___2 = z;
#line 106
    z ++;
#line 106
    ick = (unsigned long )(aicrc32tab[((int )ick ^ (int )*tmp___2) & 255] ^ (unsigned long const   )((ick >> 8) & 16777215UL));
#line 107
    c -= 4UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    tmp___4 = c;
#line 109
    c --;
#line 109
    if (! (tmp___4 != 0UL)) {
#line 109
      goto while_break___0;
    }
#line 110
    tmp___3 = z;
#line 110
    z ++;
#line 110
    ick = (unsigned long )(aicrc32tab[((int )ick ^ (int )*tmp___3) & 255] ^ (unsigned long const   )((ick >> 8) & 16777215UL));
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  return (ick);
}
}
#line 51 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/buffer.c"
static struct sbuf *qBlist  ;
#line 56 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/buffer.c"
char *zbufalc(size_t c ) 
{ 
  register struct sbuf *q ;
  pointer tmp ;
  pointer tmp___0 ;

  {
#line 62
  if ((unsigned long )qBlist == (unsigned long )((void *)0)) {
    {
#line 64
    tmp = xmalloc((sizeof(struct sbuf ) + c) - 4UL);
#line 64
    q = (struct sbuf *)tmp;
#line 65
    q->c = c;
    }
  } else {
#line 69
    q = qBlist;
#line 70
    qBlist = q->qnext;
#line 71
    if (q->c < c) {
      {
#line 73
      tmp___0 = xrealloc((pointer )q, (sizeof(struct sbuf ) + c) - 4UL);
#line 73
      q = (struct sbuf *)tmp___0;
#line 75
      q->c = c;
      }
    }
  }
#line 78
  return (q->u.ab);
}
}
#line 83 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/buffer.c"
void ubuffree(char *z ) 
{ 
  struct sbuf *q ;
  int ioff ;

  {
#line 92
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 93
    return;
  }
#line 94
  ioff = (int )((unsigned long )(& ((struct sbuf *)0)->u));
#line 95
  q = (struct sbuf *)((pointer )(z - ioff));
#line 112
  q->qnext = qBlist;
#line 113
  qBlist = q;
#line 114
  return;
}
}
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/lib/buffer.c"
char *zbufcpy(char const   *z ) 
{ 
  size_t csize ;
  char *zret ;
  size_t tmp ;

  {
#line 145
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 146
    return ((char *)((void *)0));
  }
  {
#line 147
  tmp = strlen(z);
#line 147
  csize = tmp + 1UL;
#line 148
  zret = zbufalc(csize);
#line 149
  memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)z, csize);
  }
#line 150
  return (zret);
}
}
#line 1182 "../uuconf.h"
int uuconf_v2_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) ;
#line 293 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_iv2_system_internal(struct sglobal *qglobal , char const   *zsystem ,
                                struct uuconf_system *qsys ) ;
#line 319
int _uuconf_isystem_basic_default(struct sglobal *qglobal , struct uuconf_system *q ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsys.c"
char const   _uuconf_vsys_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsys.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'s',      (char const   )'y', 
        (char const   )'s',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'6',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'3',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsys.c"
int uuconf_v2_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  int tmp ;

  {
  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 44
  iret = _uuconf_iv2_system_internal(qglobal, zsystem, qsys);
  }
#line 45
  if (iret != 0) {
#line 46
    return (iret);
  }
  {
#line 47
  tmp = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 47
  return (tmp);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 286 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 1176 "../uuconf.h"
int uuconf_v2_system_names(void *pglobal , char ***ppzsystems , int falias  __attribute__((__unused__)) ) ;
#line 349 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_iadd_string(struct sglobal *qglobal , char *zadd , boolean fcopy , boolean fcheck ,
                        char ***ppzstrings , pointer pblock ) ;
#line 374
int _uuconf_getline(struct sglobal *qglobal , char **pzline , size_t *pcline , FILE *e ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsnams.c"
char const   _uuconf_vsnams_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsnams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'s',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'1', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'3', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsnams.c"
int uuconf_v2_system_names(void *pglobal , char ***ppzsystems , int falias  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  FILE *e ;
  int iret ;
  char *zline ;
  size_t cline ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *zname ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 44
  qglobal = (struct sglobal *)pglobal;
#line 50
  *ppzsystems = (char **)((void *)0);
#line 52
  e = fopen((char const   */* __restrict  */)(qglobal->qprocess)->zv2systems, (char const   */* __restrict  */)"r");
  }
#line 53
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 55
    tmp___0 = __errno_location();
    }
#line 55
    if (*tmp___0 == 2) {
      {
#line 56
      tmp = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzsystems, (void *)0);
      }
#line 56
      return (tmp);
    }
    {
#line 58
    tmp___1 = __errno_location();
#line 58
    qglobal->ierrno = *tmp___1;
#line 59
    qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2systems;
    }
#line 60
    return (770);
  }
#line 65
  qglobal->ilineno = 0;
#line 66
  iret = 0;
#line 68
  zline = (char *)((void *)0);
#line 69
  cline = (size_t )0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    tmp___4 = _uuconf_getline(qglobal, & zline, & cline, e);
    }
#line 70
    if (! (tmp___4 > 0)) {
#line 70
      goto while_break;
    }
    {
#line 74
    (qglobal->ilineno) ++;
#line 79
    tmp___2 = strspn((char const   *)zline, " \t");
#line 79
    zname = zline + tmp___2;
#line 80
    tmp___3 = strcspn((char const   *)zname, " \t#\n");
#line 80
    *(zname + tmp___3) = (char )'\000';
    }
#line 81
    if ((int )*zname == 0) {
#line 82
      goto while_continue;
    }
    {
#line 84
    iret = _uuconf_iadd_string(qglobal, zname, 1, 1, ppzsystems, (void *)0);
    }
#line 86
    if (iret != 0) {
#line 87
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  fclose(e);
  }
#line 91
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 92
    free((pointer )zline);
    }
  }
#line 94
  if (iret != 0) {
#line 96
    qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2systems;
#line 97
    return ((iret | 512) | 1024);
  }
#line 100
  if ((unsigned long )*ppzsystems == (unsigned long )((void *)0)) {
    {
#line 101
    iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzsystems, (void *)0);
    }
  }
#line 104
  return (iret);
}
}
#line 651 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 1574 "../uuconf.h"
void *uuconf_malloc_block(void) ;
#line 1578
void *uuconf_malloc(void *pblock , unsigned long c ) ;
#line 1585
int uuconf_add_block(void *pblock , void *padd ) ;
#line 247 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
char *_uuconf_unset ;
#line 271
int _uuconf_ichat_cmd(struct sglobal *qglobal , int argc , char **argv , struct uuconf_chat *qchat ,
                      pointer pblock ) ;
#line 310
void _uuconf_uclear_system(struct uuconf_system *q ) ;
#line 323
void _uuconf_uclear_port(struct uuconf_port *qport ) ;
#line 333
int _uuconf_itime_parse(struct sglobal *qglobal , char *ztime , long ival , int cretry ,
                        int (*picmp)(long  , long  ) , struct uuconf_timespan **pqspan ,
                        pointer pblock ) ;
#line 340
int _uuconf_itime_grade_cmp(long i1 , long i2 ) ;
#line 378
int _uuconf_istrsplit(char *zline , int bsep , char ***ppzsplit , size_t *pcsplit ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsinfo.c"
char const   _uuconf_vsinfo_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsinfo.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'s',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'7', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'3', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vsinfo.c"
int _uuconf_iv2_system_internal(struct sglobal *qglobal , char const   *zsystem ,
                                struct uuconf_system *qsys ) 
{ 
  char *zline ;
  size_t cline ;
  char **pzsplit ;
  size_t csplit ;
  char **pzcomma ;
  size_t ccomma ;
  FILE *e ;
  int cchars ;
  pointer pblock ;
  int iret ;
  int *tmp ;
  int *tmp___0 ;
  int ctoks ;
  int ctimes ;
  int i ;
  struct uuconf_system *qset ;
  char *z ;
  char *zretry ;
  int cretry ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  struct uuconf_system **pq ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int *tmp___10 ;
  char *zslash ;
  char bgrade ;
  unsigned short const   **tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  char **pzlocal ;
  char **pzremote ;
  boolean fdefault_callback ;
  char *zdefault_login ;
  struct uuconf_system *q ;
  int ctoks___0 ;
  char *zcomma ;
  boolean fcallback ;
  char **pzlist ;
  char **pznew ;
  size_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  __ssize_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  __ssize_t tmp___26 ;
  int ctoks___1 ;
  char **pznew___0 ;
  int *tmp___27 ;
  void *tmp___28 ;
  __ssize_t tmp___29 ;
  int tmp___30 ;
  __ssize_t tmp___31 ;
  size_t tmp___32 ;
  __ssize_t tmp___33 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
  {
#line 55
  e = fopen((char const   */* __restrict  */)(qglobal->qprocess)->zv2systems, (char const   */* __restrict  */)"r");
  }
#line 56
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 58
    tmp = __errno_location();
    }
#line 58
    if (*tmp == 2) {
#line 59
      return (1);
    }
    {
#line 60
    tmp___0 = __errno_location();
#line 60
    qglobal->ierrno = *tmp___0;
#line 61
    qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2systems;
    }
#line 62
    return (770);
  }
#line 67
  zline = (char *)((void *)0);
#line 68
  cline = (size_t )0;
#line 69
  pzsplit = (char **)((void *)0);
#line 70
  csplit = (size_t )0;
#line 71
  pzcomma = (char **)((void *)0);
#line 72
  ccomma = (size_t )0;
#line 74
  pblock = (void *)0;
#line 75
  iret = 0;
#line 77
  qglobal->ilineno = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    cchars = _uuconf_getline(qglobal, & zline, & cline, e);
    }
#line 79
    if (! (cchars > 0)) {
#line 79
      goto while_break;
    }
#line 86
    (qglobal->ilineno) ++;
#line 88
    cchars --;
#line 89
    if ((int )*(zline + cchars) == 10) {
#line 90
      *(zline + cchars) = (char )'\000';
    }
    {
#line 91
    tmp___1 = strcspn((char const   *)zline, "#");
#line 91
    *(zline + tmp___1) = (char )'\000';
#line 93
    ctoks = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
    }
#line 94
    if (ctoks < 0) {
      {
#line 96
      tmp___2 = __errno_location();
#line 96
      qglobal->ierrno = *tmp___2;
#line 97
      iret = 260;
      }
#line 98
      goto while_break;
    }
#line 103
    if (ctoks < 1) {
#line 105
      goto while_continue;
    } else {
      {
#line 103
      tmp___3 = strcmp(zsystem, (char const   *)*(pzsplit + 0));
      }
#line 103
      if (tmp___3 != 0) {
#line 105
        goto while_continue;
      }
    }
#line 110
    if ((unsigned long )pblock == (unsigned long )((void *)0)) {
      {
#line 112
      pblock = uuconf_malloc_block();
      }
#line 113
      if ((unsigned long )pblock == (unsigned long )((void *)0)) {
        {
#line 115
        tmp___4 = __errno_location();
#line 115
        qglobal->ierrno = *tmp___4;
#line 116
        iret = 260;
        }
#line 117
        goto while_break;
      }
      {
#line 119
      _uuconf_uclear_system(qsys);
#line 120
      qsys->uuconf_palloc = pblock;
#line 121
      qset = qsys;
      }
    } else {
      {
#line 127
      tmp___5 = uuconf_malloc(pblock, sizeof(struct uuconf_system ));
#line 127
      qset = (struct uuconf_system *)tmp___5;
      }
#line 129
      if ((unsigned long )qset == (unsigned long )((void *)0)) {
        {
#line 131
        tmp___6 = __errno_location();
#line 131
        qglobal->ierrno = *tmp___6;
#line 132
        iret = 260;
        }
#line 133
        goto while_break;
      }
      {
#line 135
      _uuconf_uclear_system(qset);
#line 136
      pq = & qsys->uuconf_qalternate;
      }
      {
#line 136
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 136
        if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 136
          goto while_break___0;
        }
#line 136
        pq = & (*pq)->uuconf_qalternate;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 140
      *pq = qset;
    }
    {
#line 145
    tmp___8 = uuconf_add_block(pblock, (void *)zline);
    }
#line 145
    if (tmp___8 != 0) {
      {
#line 147
      tmp___7 = __errno_location();
#line 147
      qglobal->ierrno = *tmp___7;
#line 148
      iret = 260;
      }
#line 149
      goto while_break;
    }
#line 152
    zline = (char *)((void *)0);
#line 153
    cline = (size_t )0;
#line 163
    qset->uuconf_zname = *(pzsplit + 0);
#line 164
    qset->uuconf_fcall = 1;
#line 165
    qset->uuconf_fcalled = 1;
#line 167
    if (ctoks < 2) {
#line 168
      goto while_continue;
    }
    {
#line 174
    zretry = strchr((char const   *)*(pzsplit + 1), ';');
    }
#line 175
    if ((unsigned long )zretry == (unsigned long )((void *)0)) {
#line 176
      cretry = 55;
    } else {
      {
#line 179
      *zretry = (char )'\000';
#line 180
      tmp___9 = strtol((char const   */* __restrict  */)(zretry + 1), (char **/* __restrict  */)((char **)((void *)0)),
                       10);
#line 180
      cretry = (int )tmp___9;
      }
    }
    {
#line 183
    ctimes = _uuconf_istrsplit(*(pzsplit + 1), ',', & pzcomma, & ccomma);
    }
#line 184
    if (ctimes < 0) {
      {
#line 186
      tmp___10 = __errno_location();
#line 186
      qglobal->ierrno = *tmp___10;
#line 187
      iret = 260;
      }
#line 188
      goto while_break;
    }
#line 191
    i = 0;
    {
#line 191
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 191
      if (! (i < ctimes)) {
#line 191
        goto while_break___1;
      }
      {
#line 196
      z = *(pzcomma + i);
#line 197
      zslash = strchr((char const   *)z, '/');
      }
#line 198
      if ((unsigned long )zslash == (unsigned long )((void *)0)) {
#line 199
        bgrade = (char )'z';
      } else {
        {
#line 202
        *zslash = (char )'\000';
#line 203
        bgrade = *(zslash + 1);
#line 204
        tmp___11 = __ctype_b_loc();
        }
#line 204
        if (! ((int const   )*(*tmp___11 + (int )((unsigned char )bgrade)) & 8)) {
#line 205
          bgrade = (char )'z';
        }
      }
      {
#line 208
      iret = _uuconf_itime_parse(qglobal, z, (long )bgrade, cretry, & _uuconf_itime_grade_cmp,
                                 & qset->uuconf_qtimegrade, pblock);
      }
#line 216
      if (iret == 5) {
#line 217
        iret = 0;
      }
#line 219
      if (iret != 0) {
#line 220
        goto while_break___1;
      }
#line 224
      if ((int )bgrade != 122) {
#line 225
        qset->uuconf_qcalltimegrade = qset->uuconf_qtimegrade;
      }
#line 191
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 228
    if (iret != 0) {
#line 229
      goto while_break;
    }
#line 231
    if (ctoks < 3) {
#line 232
      goto while_continue;
    }
    {
#line 237
    qset->uuconf_zport = *(pzsplit + 2);
#line 238
    z = strchr((char const   *)*(pzsplit + 2), ',');
    }
#line 239
    if ((unsigned long )z != (unsigned long )((void *)0)) {
#line 241
      qset->uuconf_zprotocols = z + 1;
#line 242
      *z = (char )'\000';
    }
    {
#line 248
    tmp___14 = strcmp((char const   *)qset->uuconf_zport, "TCP");
    }
#line 248
    if (tmp___14 == 0) {
      {
#line 250
      qset->uuconf_zport = (char *)((void *)0);
#line 251
      tmp___12 = uuconf_malloc(pblock, sizeof(struct uuconf_port ));
#line 251
      qset->uuconf_qport = (struct uuconf_port *)tmp___12;
      }
#line 254
      if ((unsigned long )qset->uuconf_qport == (unsigned long )((void *)0)) {
        {
#line 256
        tmp___13 = __errno_location();
#line 256
        qglobal->ierrno = *tmp___13;
#line 257
        iret = 260;
        }
#line 258
        goto while_break;
      }
      {
#line 260
      _uuconf_uclear_port(qset->uuconf_qport);
#line 261
      (qset->uuconf_qport)->uuconf_zname = (char *)"TCP";
#line 262
      (qset->uuconf_qport)->uuconf_ttype = (enum uuconf_porttype )4;
#line 263
      (qset->uuconf_qport)->uuconf_ireliable = 31;
      }
#line 267
      if (ctoks < 4) {
#line 268
        (qset->uuconf_qport)->uuconf_u.uuconf_stcp.uuconf_zport = (char *)"uucp";
      } else {
#line 271
        (qset->uuconf_qport)->uuconf_u.uuconf_stcp.uuconf_zport = *(pzsplit + 3);
      }
#line 273
      (qset->uuconf_qport)->uuconf_u.uuconf_stcp.uuconf_iversion = 0;
#line 274
      (qset->uuconf_qport)->uuconf_u.uuconf_stcp.uuconf_pzdialer = (char **)((void *)0);
    }
#line 277
    if (ctoks < 4) {
#line 278
      goto while_continue;
    }
    {
#line 280
    qset->uuconf_ibaud = strtol((char const   */* __restrict  */)*(pzsplit + 3), (char **/* __restrict  */)((char **)((void *)0)),
                                10);
    }
#line 282
    if (ctoks < 5) {
#line 283
      goto while_continue;
    }
#line 286
    qset->uuconf_zphone = *(pzsplit + 4);
#line 288
    if (ctoks < 6) {
#line 289
      goto while_continue;
    }
    {
#line 294
    *(pzsplit + 4) = (char *)"chat";
#line 295
    iret = _uuconf_ichat_cmd(qglobal, ctoks - 4, pzsplit + 4, & qset->uuconf_schat,
                             pblock);
#line 297
    iret &= -2049;
    }
#line 298
    if (iret != 0) {
#line 299
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  fclose(e);
  }
#line 304
  if ((unsigned long )pzcomma != (unsigned long )((void *)0)) {
    {
#line 305
    free((pointer )pzcomma);
    }
  }
#line 307
  if (iret != 0) {
#line 309
    if ((unsigned long )zline != (unsigned long )((void *)0)) {
      {
#line 310
      free((pointer )zline);
      }
    }
#line 311
    if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
      {
#line 312
      free((pointer )pzsplit);
      }
    }
#line 313
    qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2systems;
#line 314
    return ((iret | 512) | 1024);
  }
#line 317
  if ((unsigned long )pblock == (unsigned long )((void *)0)) {
#line 319
    if ((unsigned long )zline != (unsigned long )((void *)0)) {
      {
#line 320
      free((pointer )zline);
      }
    }
#line 321
    if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
      {
#line 322
      free((pointer )pzsplit);
      }
    }
#line 323
    return (1);
  }
  {
#line 330
  e = fopen((char const   */* __restrict  */)(qglobal->qprocess)->zv2userfile, (char const   */* __restrict  */)"r");
  }
#line 331
  if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 338
    pzlocal = (char **)((void *)0);
#line 339
    pzremote = (char **)((void *)0);
#line 340
    fdefault_callback = 0;
#line 341
    zdefault_login = (char *)((void *)0);
#line 343
    qglobal->ilineno = 0;
    {
#line 345
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 345
      tmp___23 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                         (FILE */* __restrict  */)e);
#line 345
      cchars = (int )tmp___23;
      }
#line 345
      if (! (cchars > 0)) {
#line 345
        goto while_break___2;
      }
#line 352
      (qglobal->ilineno) ++;
#line 354
      cchars --;
#line 355
      if ((int )*(zline + cchars) == 10) {
#line 356
        *(zline + cchars) = (char )'\000';
      }
      {
#line 357
      tmp___15 = strcspn((char const   *)zline, "#");
#line 357
      *(zline + tmp___15) = (char )'\000';
#line 359
      ctoks___0 = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
      }
#line 360
      if (ctoks___0 < 0) {
        {
#line 362
        tmp___16 = __errno_location();
#line 362
        qglobal->ierrno = *tmp___16;
#line 363
        iret = 260;
        }
#line 364
        goto while_break___2;
      }
#line 367
      if (ctoks___0 == 0) {
#line 368
        goto while_continue___2;
      }
      {
#line 371
      zcomma = strchr((char const   *)*(pzsplit + 0), ',');
      }
#line 372
      if ((unsigned long )zcomma == (unsigned long )((void *)0)) {
#line 373
        goto while_continue___2;
      }
#line 375
      tmp___17 = zcomma;
#line 375
      zcomma ++;
#line 375
      *tmp___17 = (char )'\000';
#line 380
      fcallback = 0;
#line 381
      pzlist = pzsplit + 1;
#line 382
      ctoks___0 --;
#line 383
      if (ctoks___0 > 0) {
#line 383
        if ((int )*(*(pzsplit + 1) + 0) == 99) {
#line 383
          if ((int )*(*(pzsplit + 1) + 1) == 0) {
#line 387
            fcallback = 1;
#line 388
            pzlist = pzsplit + 2;
#line 389
            ctoks___0 --;
          }
        }
      }
#line 404
      if ((int )*(*(pzsplit + 0) + 0) != 0) {
#line 404
        goto _L___0;
      } else
#line 404
      if ((unsigned long )pzlocal != (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 404
        if ((int )*(zcomma + 0) != 0) {
#line 404
          goto _L;
        } else
#line 404
        if ((unsigned long )pzremote != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 404
          tmp___18 = strcmp((char const   *)zcomma, zsystem);
          }
#line 404
          if (tmp___18 != 0) {
#line 407
            goto while_continue___2;
          }
        }
      }
      {
#line 410
      tmp___19 = uuconf_malloc(pblock, (unsigned long )(ctoks___0 + 1) * sizeof(char *));
#line 410
      pznew = (char **)tmp___19;
      }
#line 412
      if ((unsigned long )pznew == (unsigned long )((void *)0)) {
        {
#line 414
        tmp___20 = __errno_location();
#line 414
        qglobal->ierrno = *tmp___20;
#line 415
        iret = 260;
        }
#line 416
        goto while_break___2;
      }
      {
#line 418
      memcpy((void */* __restrict  */)((pointer )pznew), (void const   */* __restrict  */)((pointer )pzlist),
             (unsigned long )ctoks___0 * sizeof(char *));
#line 420
      *(pznew + ctoks___0) = (char *)((void *)0);
#line 422
      tmp___22 = uuconf_add_block(pblock, (void *)zline);
      }
#line 422
      if (tmp___22 != 0) {
        {
#line 424
        tmp___21 = __errno_location();
#line 424
        qglobal->ierrno = *tmp___21;
#line 425
        iret = 260;
        }
#line 426
        goto while_break___2;
      }
#line 428
      zline = (char *)((void *)0);
#line 429
      cline = (size_t )0;
#line 431
      if ((int )*(*(pzsplit + 0) + 0) == 0) {
#line 433
        pzlocal = pznew;
#line 434
        fdefault_callback = fcallback;
      } else
#line 436
      if ((int )*(zcomma + 0) == 0) {
#line 438
        pzremote = pznew;
#line 439
        zdefault_login = *(pzsplit + 0);
      } else {
#line 448
        q = qsys;
        {
#line 448
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 448
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 448
            goto while_break___3;
          }
#line 450
          q->uuconf_zcalled_login = *(pzsplit + 0);
#line 451
          q->uuconf_fcallback = fcallback;
#line 452
          q->uuconf_pzlocal_send = pznew;
#line 453
          q->uuconf_pzlocal_receive = pznew;
#line 454
          q->uuconf_pzremote_send = pznew;
#line 455
          q->uuconf_pzremote_receive = pznew;
#line 448
          q = q->uuconf_qalternate;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 458
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 462
    fclose(e);
    }
#line 464
    if (iret != 0) {
#line 466
      if ((unsigned long )zline != (unsigned long )((void *)0)) {
        {
#line 467
        free((pointer )zline);
        }
      }
#line 468
      if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
        {
#line 469
        free((pointer )pzsplit);
        }
      }
#line 470
      qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2userfile;
#line 471
      return ((iret | 512) | 1024);
    }
#line 474
    if ((unsigned long )qsys->uuconf_pzlocal_send == (unsigned long )(& _uuconf_unset)) {
#line 474
      if ((unsigned long )pzlocal != (unsigned long )((void *)0)) {
#line 477
        q = qsys;
        {
#line 477
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 477
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 477
            goto while_break___4;
          }
#line 479
          q->uuconf_fcallback = fdefault_callback;
#line 480
          q->uuconf_pzlocal_send = pzlocal;
#line 481
          q->uuconf_pzlocal_receive = pzlocal;
#line 477
          q = q->uuconf_qalternate;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 485
    if ((unsigned long )qsys->uuconf_pzremote_send == (unsigned long )(& _uuconf_unset)) {
#line 485
      if ((unsigned long )pzremote != (unsigned long )((void *)0)) {
#line 488
        q = qsys;
        {
#line 488
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 488
          if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 488
            goto while_break___5;
          }
#line 490
          q->uuconf_zcalled_login = zdefault_login;
#line 491
          q->uuconf_pzremote_send = pzremote;
#line 492
          q->uuconf_pzremote_receive = pzremote;
#line 488
          q = q->uuconf_qalternate;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 501
  e = fopen((char const   */* __restrict  */)(qglobal->qprocess)->zv2cmds, (char const   */* __restrict  */)"r");
  }
#line 502
  if ((unsigned long )e != (unsigned long )((void *)0)) {
    {
#line 504
    qglobal->ilineno = 0;
#line 506
    tmp___31 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                       (FILE */* __restrict  */)e);
    }
#line 506
    if (tmp___31 > 0L) {
      {
#line 508
      (qglobal->ilineno) ++;
#line 510
      tmp___24 = strcspn((char const   *)zline, "#\n");
#line 510
      *(zline + tmp___24) = (char )'\000';
      }
      {
#line 512
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 512
        if (! ((int )*zline == 0)) {
#line 512
          goto while_break___6;
        }
        {
#line 514
        tmp___26 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                           (FILE */* __restrict  */)e);
        }
#line 514
        if (tmp___26 <= 0L) {
#line 516
          if ((unsigned long )zline != (unsigned long )((void *)0)) {
            {
#line 518
            free((pointer )zline);
#line 519
            zline = (char *)((void *)0);
            }
          }
        } else {
          {
#line 524
          (qglobal->ilineno) ++;
#line 525
          tmp___25 = strcspn((char const   *)zline, "#\n");
#line 525
          *(zline + tmp___25) = (char )'\000';
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 529
      if ((unsigned long )zline != (unsigned long )((void *)0)) {
        {
#line 529
        tmp___30 = strncmp((char const   *)zline, "PATH=", sizeof("PATH=") - 1UL);
        }
#line 529
        if (tmp___30 == 0) {
          {
#line 535
          zline += sizeof("PATH=") - 1UL;
#line 536
          ctoks___1 = _uuconf_istrsplit(zline, ':', & pzsplit, & csplit);
          }
#line 537
          if (ctoks___1 < 0) {
            {
#line 539
            tmp___27 = __errno_location();
#line 539
            qglobal->ierrno = *tmp___27;
#line 540
            iret = 260;
            }
          }
#line 543
          pznew___0 = (char **)((void *)0);
#line 544
          if (iret == 0) {
            {
#line 546
            tmp___28 = uuconf_malloc(pblock, (unsigned long )(ctoks___1 + 1) * sizeof(char *));
#line 546
            pznew___0 = (char **)tmp___28;
            }
#line 549
            if ((unsigned long )pznew___0 == (unsigned long )((void *)0)) {
#line 550
              iret = 260;
            }
          }
#line 552
          if (iret == 0) {
            {
#line 554
            memcpy((void */* __restrict  */)((pointer )pznew___0), (void const   */* __restrict  */)((pointer )pzsplit),
                   (unsigned long )ctoks___1 * sizeof(char *));
#line 556
            *(pznew___0 + ctoks___1) = (char *)((void *)0);
#line 557
            qsys->uuconf_pzpath = pznew___0;
#line 558
            zline = (char *)((void *)0);
#line 559
            cline = (size_t )0;
            }
          }
          {
#line 562
          tmp___29 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                             (FILE */* __restrict  */)e);
          }
#line 562
          if (tmp___29 < 0L) {
#line 564
            if ((unsigned long )zline != (unsigned long )((void *)0)) {
              {
#line 566
              free((pointer )zline);
#line 567
              zline = (char *)((void *)0);
              }
            }
          } else {
#line 571
            (qglobal->ilineno) ++;
          }
        }
      }
    }
#line 575
    if (iret == 0) {
#line 575
      if ((unsigned long )zline != (unsigned long )((void *)0)) {
        {
#line 577
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 579
          tmp___32 = strcspn((char const   *)zline, "#,\n");
#line 579
          *(zline + tmp___32) = (char )'\000';
          }
#line 580
          if ((int )*zline != 0) {
            {
#line 582
            iret = _uuconf_iadd_string(qglobal, zline, 1, 0, & qsys->uuconf_pzcmds,
                                       pblock);
            }
#line 585
            if (iret != 0) {
#line 586
              goto while_break___7;
            }
          }
          {
#line 588
          tmp___33 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                             (FILE */* __restrict  */)e);
          }
#line 588
          if (tmp___33 < 0L) {
#line 589
            goto while_break___7;
          }
#line 590
          (qglobal->ilineno) ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
    {
#line 594
    fclose(e);
    }
#line 596
    if (iret != 0) {
#line 598
      qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2cmds;
#line 599
      iret |= 1536;
    }
  }
#line 604
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 605
    free((pointer )zline);
    }
  }
#line 606
  if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
    {
#line 607
    free((pointer )pzsplit);
    }
  }
#line 609
  return (iret);
}
}
#line 1188 "../uuconf.h"
int uuconf_v2_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud  __attribute__((__unused__)) ,
                        int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) ,
                        void *pinfo , struct uuconf_port *qport ) ;
#line 1595
void uuconf_free_block(void *pblock ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vport.c"
char const   _uuconf_vport_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vport.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vport.c"
int uuconf_v2_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud  __attribute__((__unused__)) ,
                        int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) ,
                        void *pinfo , struct uuconf_port *qport ) 
{ 
  struct sglobal *qglobal ;
  FILE *e ;
  char *zline ;
  size_t cline ;
  char **pzsplit ;
  size_t csplit ;
  int iret ;
  int cchars ;
  int *tmp ;
  int *tmp___0 ;
  int ctoks ;
  char *zend ;
  long ilow ;
  long ihigh ;
  pointer pblock ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t c ;
  char **pzd ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  __ssize_t tmp___12 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 47
  qglobal = (struct sglobal *)pglobal;
#line 56
  e = fopen((char const   */* __restrict  */)(qglobal->qprocess)->zv2devices, (char const   */* __restrict  */)"r");
  }
#line 57
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 59
    tmp = __errno_location();
    }
#line 59
    if (*tmp == 2) {
#line 60
      return (1);
    }
    {
#line 61
    tmp___0 = __errno_location();
#line 61
    qglobal->ierrno = *tmp___0;
#line 62
    qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2devices;
    }
#line 63
    return (770);
  }
#line 68
  zline = (char *)((void *)0);
#line 69
  cline = (size_t )0;
#line 70
  pzsplit = (char **)((void *)0);
#line 71
  csplit = (size_t )0;
#line 73
  iret = 1;
#line 75
  qglobal->ilineno = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    tmp___12 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                       (FILE */* __restrict  */)e);
#line 77
    cchars = (int )tmp___12;
    }
#line 77
    if (! (cchars > 0)) {
#line 77
      goto while_break;
    }
#line 84
    (qglobal->ilineno) ++;
#line 86
    iret = 1;
#line 88
    cchars --;
#line 89
    if ((int )*(zline + cchars) == 10) {
#line 90
      *(zline + cchars) = (char )'\000';
    }
    {
#line 91
    tmp___1 = strcspn((char const   *)zline, "#");
#line 91
    *(zline + tmp___1) = (char )'\000';
#line 93
    ctoks = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
    }
#line 94
    if (ctoks < 0) {
      {
#line 96
      tmp___2 = __errno_location();
#line 96
      qglobal->ierrno = *tmp___2;
#line 97
      iret = 260;
      }
#line 98
      goto while_break;
    }
#line 109
    if (ctoks < 4) {
#line 110
      goto while_continue;
    }
#line 113
    if ((unsigned long )zname != (unsigned long )((void *)0)) {
      {
#line 113
      tmp___3 = strcmp((char const   *)*(pzsplit + 0), zname);
      }
#line 113
      if (tmp___3 != 0) {
#line 115
        goto while_continue;
      }
    }
    {
#line 118
    ilow = strtol((char const   */* __restrict  */)*(pzsplit + 3), (char **/* __restrict  */)(& zend),
                  10);
    }
#line 119
    if ((int )*zend == 45) {
      {
#line 120
      ihigh = strtol((char const   */* __restrict  */)(zend + 1), (char **/* __restrict  */)((char **)((void *)0)),
                     10);
      }
    } else {
#line 122
      ihigh = ilow;
    }
#line 125
    if (ibaud != 0L) {
#line 125
      if (ilow != 0L) {
#line 125
        if (ilow > ibaud) {
#line 128
          goto while_continue;
        } else
#line 125
        if (ihigh < ibaud) {
#line 128
          goto while_continue;
        }
      }
    }
    {
#line 134
    pblock = (void *)0;
#line 135
    _uuconf_uclear_port(qport);
#line 136
    qport->uuconf_zname = *(pzsplit + 0);
#line 137
    tmp___8 = strcmp((char const   *)*(pzsplit + 0), "DIR");
    }
#line 137
    if (tmp___8 == 0) {
#line 139
      qport->uuconf_ttype = (enum uuconf_porttype )3;
#line 140
      qport->uuconf_u.uuconf_sdirect.uuconf_zdevice = *(pzsplit + 1);
#line 141
      qport->uuconf_u.uuconf_sdirect.uuconf_ibaud = ilow;
#line 142
      qport->uuconf_u.uuconf_sdirect.uuconf_fcarrier = 0;
#line 143
      qport->uuconf_u.uuconf_sdirect.uuconf_fhardflow = 1;
    } else {
      {
#line 147
      qport->uuconf_ttype = (enum uuconf_porttype )2;
#line 148
      qport->uuconf_u.uuconf_smodem.uuconf_zdevice = *(pzsplit + 1);
#line 149
      tmp___4 = strcmp((char const   *)*(pzsplit + 2), "-");
      }
#line 149
      if (tmp___4 != 0) {
#line 150
        qport->uuconf_u.uuconf_smodem.uuconf_zdial_device = *(pzsplit + 2);
      } else {
#line 152
        qport->uuconf_u.uuconf_smodem.uuconf_zdial_device = (char *)((void *)0);
      }
#line 153
      if (ilow == ihigh) {
#line 155
        qport->uuconf_u.uuconf_smodem.uuconf_ibaud = ilow;
#line 156
        qport->uuconf_u.uuconf_smodem.uuconf_ilowbaud = 0L;
#line 157
        qport->uuconf_u.uuconf_smodem.uuconf_ihighbaud = 0L;
      } else {
#line 161
        qport->uuconf_u.uuconf_smodem.uuconf_ibaud = 0L;
#line 162
        qport->uuconf_u.uuconf_smodem.uuconf_ilowbaud = ilow;
#line 163
        qport->uuconf_u.uuconf_smodem.uuconf_ihighbaud = ihigh;
      }
#line 165
      qport->uuconf_u.uuconf_smodem.uuconf_fcarrier = 1;
#line 166
      qport->uuconf_u.uuconf_smodem.uuconf_fhardflow = 1;
#line 167
      if (ctoks < 5) {
#line 168
        qport->uuconf_u.uuconf_smodem.uuconf_pzdialer = (char **)((void *)0);
      } else {
        {
#line 176
        pblock = uuconf_malloc_block();
        }
#line 177
        if ((unsigned long )pblock == (unsigned long )((void *)0)) {
          {
#line 179
          tmp___5 = __errno_location();
#line 179
          qglobal->ierrno = *tmp___5;
#line 180
          iret = 260;
          }
#line 181
          goto while_break;
        }
        {
#line 183
        c = (unsigned long )(ctoks - 4) * sizeof(char *);
#line 184
        tmp___6 = uuconf_malloc(pblock, c + sizeof(char *));
#line 184
        pzd = (char **)tmp___6;
        }
#line 185
        if ((unsigned long )pzd == (unsigned long )((void *)0)) {
          {
#line 187
          tmp___7 = __errno_location();
#line 187
          qglobal->ierrno = *tmp___7;
#line 188
          uuconf_free_block(pblock);
#line 189
          iret = 260;
          }
#line 190
          goto while_break;
        }
        {
#line 192
        memcpy((void */* __restrict  */)((pointer )pzd), (void const   */* __restrict  */)((pointer )(pzsplit + 4)),
               c);
#line 193
        *(pzd + (ctoks - 4)) = (char *)((void *)0);
#line 195
        qport->uuconf_u.uuconf_smodem.uuconf_pzdialer = pzd;
        }
      }
#line 197
      qport->uuconf_u.uuconf_smodem.uuconf_qdialer = (struct uuconf_dialer *)((void *)0);
    }
#line 200
    if ((unsigned long )pifn != (unsigned long )((void *)0)) {
      {
#line 202
      iret = (*pifn)(qport, pinfo);
      }
#line 203
      if (iret != 0) {
#line 205
        if ((unsigned long )pblock != (unsigned long )((void *)0)) {
          {
#line 206
          uuconf_free_block(pblock);
          }
        }
#line 207
        if (iret != 1) {
#line 208
          goto while_break;
        }
#line 209
        goto while_continue;
      }
    }
#line 214
    if ((unsigned long )pblock == (unsigned long )((void *)0)) {
      {
#line 216
      pblock = uuconf_malloc_block();
      }
#line 217
      if ((unsigned long )pblock == (unsigned long )((void *)0)) {
        {
#line 219
        tmp___9 = __errno_location();
#line 219
        qglobal->ierrno = *tmp___9;
#line 220
        iret = 260;
        }
#line 221
        goto while_break;
      }
    }
    {
#line 225
    tmp___11 = uuconf_add_block(pblock, (void *)zline);
    }
#line 225
    if (tmp___11 != 0) {
      {
#line 227
      tmp___10 = __errno_location();
#line 227
      qglobal->ierrno = *tmp___10;
#line 228
      uuconf_free_block(pblock);
#line 229
      iret = 260;
      }
#line 230
      goto while_break;
    }
#line 232
    zline = (char *)((void *)0);
#line 234
    qport->uuconf_palloc = pblock;
#line 236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  fclose(e);
  }
#line 241
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 242
    free((pointer )zline);
    }
  }
#line 243
  if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
    {
#line 244
    free((pointer )pzsplit);
    }
  }
#line 246
  if (iret != 0) {
#line 246
    if (iret != 1) {
#line 248
      qglobal->zfilename = (char const   *)(qglobal->qprocess)->zv2devices;
#line 249
      iret |= 1536;
    }
  }
#line 252
  return (iret);
}
}
#line 1169 "../uuconf.h"
int uuconf_v2_init(void **ppglobal ) ;
#line 307 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_iinit_global(struct sglobal **pqglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vinit.c"
char const   _uuconf_vinit_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vinit.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'i',      (char const   )'n', 
        (char const   )'i',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'3',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33
static int ivinlib(struct sglobal *qglobal , char const   *z , size_t c , char **pz ) ;
#line 40 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vinit.c"
static int ivinlib(struct sglobal *qglobal , char const   *z , size_t c , char **pz ) 
{ 
  char *zalc ;
  void *tmp ;
  int *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 49
  tmp = uuconf_malloc(qglobal->pblock, (sizeof("/usr/lib/uucp") - 1UL) + c);
#line 49
  zalc = (char *)tmp;
  }
#line 50
  if ((unsigned long )zalc == (unsigned long )((void *)0)) {
    {
#line 52
    tmp___0 = __errno_location();
#line 52
    qglobal->ierrno = *tmp___0;
    }
#line 53
    return (260);
  }
  {
#line 56
  memcpy((void */* __restrict  */)((pointer )zalc), (void const   */* __restrict  */)((pointer )"/usr/lib/uucp"),
         sizeof("/usr/lib/uucp") - 1UL);
#line 58
  memcpy((void */* __restrict  */)((pointer )((zalc + sizeof("/usr/lib/uucp")) - 1)),
         (void const   */* __restrict  */)((pointer )z), c);
#line 60
  *pz = zalc;
  }
#line 62
  return (0);
}
}
#line 68 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/vinit.c"
int uuconf_v2_init(void **ppglobal ) 
{ 
  struct sglobal **pqglobal ;
  int iret ;
  struct sglobal *qglobal ;
  char *zdialcodes ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 72
  pqglobal = (struct sglobal **)ppglobal;
#line 77
  if ((unsigned long )*pqglobal == (unsigned long )((void *)0)) {
    {
#line 79
    iret = _uuconf_iinit_global(pqglobal);
    }
#line 80
    if (iret != 0) {
#line 81
      return (iret);
    }
  }
  {
#line 84
  qglobal = *pqglobal;
#line 86
  iret = ivinlib(qglobal, "/L.sys", sizeof("/L.sys"), & (qglobal->qprocess)->zv2systems);
  }
#line 88
  if (iret != 0) {
#line 89
    return (iret);
  }
  {
#line 90
  iret = ivinlib(qglobal, "/L-devices", sizeof("/L-devices"), & (qglobal->qprocess)->zv2devices);
  }
#line 92
  if (iret != 0) {
#line 93
    return (iret);
  }
  {
#line 94
  iret = ivinlib(qglobal, "/USERFILE", sizeof("/USERFILE"), & (qglobal->qprocess)->zv2userfile);
  }
#line 96
  if (iret != 0) {
#line 97
    return (iret);
  }
  {
#line 98
  iret = ivinlib(qglobal, "/L.cmds", sizeof("/L.cmds"), & (qglobal->qprocess)->zv2cmds);
  }
#line 100
  if (iret != 0) {
#line 101
    return (iret);
  }
  {
#line 103
  iret = ivinlib(qglobal, "/L-dialcodes", sizeof("/L-dialcodes"), & zdialcodes);
  }
#line 105
  if (iret != 0) {
#line 106
    return (iret);
  }
  {
#line 108
  tmp = _uuconf_iadd_string(qglobal, zdialcodes, 0, 0, & (qglobal->qprocess)->pzdialcodefiles,
                            qglobal->pblock);
  }
#line 108
  return (tmp);
}
}
#line 980 "../uuconf.h"
int uuconf_validate(void *pglobal , struct uuconf_system  const  *qsys , char const   *zlogin ) ;
#line 1142
int uuconf_taylor_validate(void *pglobal , struct uuconf_system  const  *qsys , char const   *zlogin ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/val.c"
char const   _uuconf_val_rcsid[47]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/val.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'6', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'3', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 34 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/val.c"
int uuconf_validate(void *pglobal , struct uuconf_system  const  *qsys , char const   *zlogin ) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = uuconf_taylor_validate(pglobal, qsys, zlogin);
  }
#line 41
  return (tmp);
}
}
#line 769 "../uuconf.h"
int uuconf_system_unknown(void *pglobal , struct uuconf_system *qsys ) ;
#line 1091
int uuconf_taylor_system_unknown(void *pglobal , struct uuconf_system *qsys ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/unk.c"
char const   _uuconf_unk_rcsid[47]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/unk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'k', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'6', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'3', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 42 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/unk.c"
int uuconf_system_unknown(void *pglobal , struct uuconf_system *qsys ) 
{ 
  int tmp ;

  {
  {
#line 48
  tmp = uuconf_taylor_system_unknown(pglobal, qsys);
  }
#line 48
  return (tmp);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/ugtlin.c"
char const   _uuconf_ugtlin_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/ugtlin.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'u',      (char const   )'g',      (char const   )'t', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 34 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/ugtlin.c"
int _uuconf_getline(struct sglobal *qglobal , char **pzline , size_t *pcline , FILE *e ) 
{ 
  int ctot ;
  char *zline ;
  size_t cline ;
  int cchars ;
  __ssize_t tmp ;
  __ssize_t tmp___0 ;
  char *znew ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 45
  ctot = -1;
#line 47
  zline = (char *)((void *)0);
#line 48
  cline = (size_t )0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (ctot < 0) {
      {
#line 55
      tmp = getline((char **/* __restrict  */)pzline, (size_t */* __restrict  */)pcline,
                    (FILE */* __restrict  */)e);
#line 55
      cchars = (int )tmp;
      }
    } else {
      {
#line 57
      tmp___0 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                        (FILE */* __restrict  */)e);
#line 57
      cchars = (int )tmp___0;
      }
    }
#line 58
    if (cchars < 0) {
#line 60
      if ((unsigned long )zline != (unsigned long )((void *)0)) {
        {
#line 61
        free((pointer )zline);
        }
      }
#line 62
      if (ctot >= 0) {
#line 63
        return (ctot);
      } else {
#line 65
        return (cchars);
      }
    }
#line 68
    if (ctot < 0) {
#line 69
      ctot = cchars;
    } else {
#line 72
      if (*pcline <= (size_t )(ctot + cchars)) {
#line 76
        if (*pcline > 0UL) {
          {
#line 77
          tmp___1 = realloc((pointer )*pzline, (size_t )((ctot + cchars) + 1));
#line 77
          znew = (char *)tmp___1;
          }
        } else {
          {
#line 80
          tmp___2 = malloc((size_t )((ctot + cchars) + 1));
#line 80
          znew = (char *)tmp___2;
          }
        }
#line 81
        if ((unsigned long )znew == (unsigned long )((void *)0)) {
          {
#line 83
          free((pointer )zline);
          }
#line 84
          return (-1);
        }
#line 86
        *pzline = znew;
#line 87
        *pcline = (size_t )((ctot + cchars) + 1);
      }
      {
#line 90
      memcpy((void */* __restrict  */)((pointer )(*pzline + ctot)), (void const   */* __restrict  */)((pointer )zline),
             (size_t )(cchars + 1));
#line 92
      ctot += cchars;
      }
    }
#line 95
    if (ctot < 2) {
#line 95
      goto _L;
    } else
#line 95
    if ((int )*(*pzline + (ctot - 1)) != 10) {
#line 95
      goto _L;
    } else
#line 95
    if ((int )*(*pzline + (ctot - 2)) != 92) {
      _L: /* CIL Label */ 
#line 99
      if ((unsigned long )zline != (unsigned long )((void *)0)) {
        {
#line 100
        free((pointer )zline);
        }
      }
#line 101
      return (ctot);
    }
#line 104
    (qglobal->ilineno) ++;
#line 106
    ctot -= 2;
#line 107
    *(*pzline + ctot) = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 258 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_iread_locations(struct sglobal *qglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tval.c"
char const   _uuconf_tval_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tval.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'6',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'3',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tval.c"
int uuconf_taylor_validate(void *pglobal , struct uuconf_system  const  *qsys , char const   *zlogin ) 
{ 
  struct sglobal *qglobal ;
  struct svalidate *q ;
  int iret ;
  char **pz ;
  int tmp ;
  int tmp___0 ;

  {
#line 43
  qglobal = (struct sglobal *)pglobal;
#line 46
  if (! (qglobal->qprocess)->fread_syslocs) {
    {
#line 50
    iret = _uuconf_iread_locations(qglobal);
    }
#line 51
    if (iret != 0) {
#line 52
      return (iret);
    }
  }
#line 55
  q = (qglobal->qprocess)->qvalidate;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 57
    tmp___0 = strcmp(q->zlogname, zlogin);
    }
#line 57
    if (tmp___0 == 0) {
#line 61
      pz = q->pzmachines;
      {
#line 61
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 61
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 61
          goto while_break___0;
        }
        {
#line 62
        tmp = strcmp((char const   *)*pz, (char const   *)qsys->uuconf_zname);
        }
#line 62
        if (tmp == 0) {
#line 63
          return (0);
        }
#line 61
        pz ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 65
      return (1);
    }
#line 55
    q = q->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (0);
}
}
#line 1083 "../uuconf.h"
int uuconf_taylor_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) ;
#line 251 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_itaylor_system_internal(struct sglobal *qglobal , char const   *zsystem ,
                                    struct uuconf_system *qsys ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsys.c"
char const   _uuconf_tsys_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsys.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'s',      (char const   )'y', 
        (char const   )'s',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'6',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'3',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsys.c"
int uuconf_taylor_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  int tmp ;

  {
  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 44
  iret = _uuconf_itaylor_system_internal(qglobal, zsystem, qsys);
  }
#line 45
  if (iret != 0) {
#line 46
    return (iret);
  }
  {
#line 47
  tmp = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 47
  return (tmp);
}
}
#line 1077 "../uuconf.h"
int uuconf_taylor_system_names(void *pglobal , char ***ppzsystems , int falias ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsnams.c"
char const   _uuconf_tsnams_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsnams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'s',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsnams.c"
int uuconf_taylor_system_names(void *pglobal , char ***ppzsystems , int falias ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  register struct stsysloc *q ;
  char **pz ;
  int c ;
  int i ;
  char *zhold ;

  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 47
  if (! (qglobal->qprocess)->fread_syslocs) {
    {
#line 49
    iret = _uuconf_iread_locations(qglobal);
    }
#line 50
    if (iret != 0) {
#line 51
      return (iret);
    }
  }
#line 54
  *ppzsystems = (char **)((void *)0);
#line 55
  c = 0;
#line 57
  q = (qglobal->qprocess)->qsyslocs;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 57
      goto while_break;
    }
#line 59
    if (! falias) {
#line 59
      if (q->falias) {
#line 60
        goto __Cont;
      }
    }
    {
#line 62
    iret = _uuconf_iadd_string(qglobal, (char *)q->zname, 1, 0, ppzsystems, (void *)0);
    }
#line 64
    if (iret != 0) {
#line 65
      return (iret);
    }
#line 66
    c ++;
    __Cont: /* CIL Label */ 
#line 57
    q = q->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  pz = *ppzsystems;
#line 73
  i = c / 2 - 1;
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (i >= 0)) {
#line 73
      goto while_break___0;
    }
#line 77
    zhold = *(pz + i);
#line 78
    *(pz + i) = *(pz + ((c - i) - 1));
#line 79
    *(pz + ((c - i) - 1)) = zhold;
#line 73
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  return (0);
}
}
#line 722 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 732
extern void rewind(FILE *__stream ) ;
#line 1521 "../uuconf.h"
int uuconf_cmd_file(void *pglobal , FILE *e , struct uuconf_cmdtab  const  *qtab ,
                    void *pinfo , int (*pfiunknown)(void *uuconf_pglobal , int uuconf_argc ,
                                                    char **uuconf_argv , void *uuconf_pvar ,
                                                    void *uuconf_pinfo ) , int iflags ,
                    void *pblock ) ;
#line 1546
int uuconf_cmd_args(void *pglobal , int cargs , char **pzargs , struct uuconf_cmdtab  const  *qtab ,
                    void *pinfo , int (*pfiunknown)(void *uuconf_pglobal , int uuconf_argc ,
                                                    char **uuconf_argv , void *uuconf_pvar ,
                                                    void *uuconf_pinfo ) , int iflags ,
                    void *pblock ) ;
#line 261 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_iport_cmd(struct sglobal *qglobal , int argc , char **argv , struct uuconf_port *qport ) ;
#line 276
int _uuconf_iadd_proto_param(struct sglobal *qglobal , int argc , char **argv , struct uuconf_proto_param **pqparam ,
                             pointer pblock ) ;
#line 313
int _uuconf_isystem_default(struct sglobal *qglobal , struct uuconf_system *qset ,
                            struct uuconf_system *qdefault , boolean faddalternates ) ;
#line 329
int _uuconf_itimetable(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                       pointer pvar  __attribute__((__unused__)) , pointer pinfo  __attribute__((__unused__)) ) ;
#line 344
int _uuconf_idebug_cmd(struct sglobal *qglobal , char **pzdebug , int argc , char **argv ,
                       pointer pblock ) ;
#line 355
int _uuconf_iboolean(struct sglobal *qglobal  __attribute__((__unused__)) , char const   *zval ,
                     int *pi ) ;
#line 360
int _uuconf_iint(struct sglobal *qglobal  __attribute__((__unused__)) , char const   *zval ,
                 pointer p , boolean fint ) ;
#line 364
void _uuconf_ucmdtab_base(struct cmdtab_offset  const  *qoff , size_t celes , char *pbase ,
                          struct uuconf_cmdtab *qset ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
char const   _uuconf_tsinfo_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'s',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'1', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'3', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 38
static void uiset_call(struct uuconf_system *qsys ) ;
#line 39
static int iisizecmp(long i1 , long i2 ) ;
#line 46
static int iisystem(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                    char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                    pointer pinfo  __attribute__((__unused__)) ) ;
#line 47
static int iialias(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                   pointer pvar  __attribute__((__unused__)) , pointer pinfo ) ;
#line 48
static int iialternate(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                       pointer pinfo ) ;
#line 49
static int iidefault_alternates(pointer pglobal , int argc  __attribute__((__unused__)) ,
                                char **argv , pointer pvar  __attribute__((__unused__)) ,
                                pointer pinfo ) ;
#line 50
static int iitime(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 51
static int iitimegrade(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 52
static int iisize(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                  pointer pvar , pointer pinfo ) ;
#line 53
static int iibaud_range(pointer pglobal , int argc  __attribute__((__unused__)) ,
                        char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 54
static int iiport(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                  pointer pinfo ) ;
#line 55
static int iichat(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 56
static int iidebug(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 57
static int iicalled_login(pointer pglobal  __attribute__((__unused__)) , int argc ,
                          char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 58
static int iiproto_param(pointer pglobal , int argc , char **argv , pointer pvar ,
                         pointer pinfo ) ;
#line 59
static int iirequest(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                     pointer pvar  __attribute__((__unused__)) , pointer pinfo ) ;
#line 60
static int iitransfer(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                      pointer pvar  __attribute__((__unused__)) , pointer pinfo ) ;
#line 61
static int iiforward(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) ;
#line 62
static int iiunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                     char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo  __attribute__((__unused__)) ) ;
#line 84 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static struct cmdtab_offset  const  asIcmds[53]  = 
#line 84
  {      {"system", 98, (size_t )-1, & iisystem}, 
        {"alias", 98, (size_t )-1, & iialias}, 
        {"alternate", 96, (size_t )-1, & iialternate}, 
        {"default-alternates", 98, (size_t )-1, & iidefault_alternates}, 
        {"time", 96, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qtimegrade),
      & iitime}, 
        {"timegrade", 96, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qtimegrade),
      & iitimegrade}, 
        {"max-retries", 34, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_cmax_retries),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"success-wait", 34, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_csuccess_wait),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"call-timegrade", 99, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qcalltimegrade),
      & iitimegrade}, 
        {"called-timegrade", 99, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qcalledtimegrade),
      & iitimegrade}, 
        {"call-local-size", 99, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qcall_local_size),
      & iisize}, 
        {"call-remote-size", 99, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qcall_remote_size),
      & iisize}, 
        {"called-local-size", 99, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qcalled_local_size),
      & iisize}, 
        {"called-remote-size", 99, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qcalled_remote_size),
      & iisize}, 
        {"timetable", 99, (size_t )-1, & _uuconf_itimetable}, 
        {"baud", 50, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_ibaud), (int (*)(void *uuconf_pglobal ,
                                                                                          int uuconf_argc ,
                                                                                          char **uuconf_argv ,
                                                                                          void *uuconf_pvar ,
                                                                                          void *uuconf_pinfo ))((void *)0)}, 
        {"speed",
      50, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_ibaud), (int (*)(void *uuconf_pglobal ,
                                                                                  int uuconf_argc ,
                                                                                  char **uuconf_argv ,
                                                                                  void *uuconf_pvar ,
                                                                                  void *uuconf_pinfo ))((void *)0)}, 
        {"baud-range",
      99, (size_t )0, & iibaud_range}, 
        {"speed-range", 99, (size_t )0, & iibaud_range}, 
        {"port", 96, (size_t )-1, & iiport}, 
        {"phone", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zphone),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"address", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zphone),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"chat", 112, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_schat),
      & iichat}, 
        {"call-login", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zcall_login),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"call-password", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zcall_password),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"called-login", 96, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zcalled_login),
      & iicalled_login}, 
        {"callback", 18, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_fcallback),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"sequence", 18, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_fsequence),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"protocol", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zprotocols),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"protocol-parameter", 96, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_qproto_params),
      & iiproto_param}, 
        {"called-chat", 112, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_scalled_chat),
      & iichat}, 
        {"debug", 96, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zdebug),
      & iidebug}, 
        {"max-remote-debug", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zmax_remote_debug),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"send-request", 18, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_fsend_request),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"receive-request", 18, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_frec_request),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"request", 98, (size_t )-1, & iirequest}, 
        {"call-transfer", 18, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_fcall_transfer),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"called-transfer", 18, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_fcalled_transfer),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"transfer", 98, (size_t )-1, & iitransfer}, 
        {"local-send", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzlocal_send),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"remote-send", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzremote_send),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"local-receive", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzlocal_receive),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"remote-receive", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzremote_receive),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"command-path", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzpath),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"commands", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzcmds),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"free-space", 50, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_cfree_space),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"forward-from", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzforward_from),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"forward-to", 80, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_pzforward_to),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"forward", 96, (size_t )-1, & iiforward}, 
        {"pubdir", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zpubdir),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"myname", 64, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_zlocalname),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"max-file-time", 50, (unsigned long )(& ((struct uuconf_system *)0)->uuconf_cmax_file_time),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 189 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
int _uuconf_itaylor_system_internal(struct sglobal *qglobal , char const   *zsystem ,
                                    struct uuconf_system *qsys ) 
{ 
  int iret ;
  struct stsysloc *qloc ;
  struct uuconf_cmdtab as[sizeof(asIcmds) / sizeof(asIcmds[0])] ;
  struct sinfo si ;
  struct uuconf_system sdefaults ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
#line 201
  if (! (qglobal->qprocess)->fread_syslocs) {
    {
#line 203
    iret = _uuconf_iread_locations(qglobal);
    }
#line 204
    if (iret != 0) {
#line 205
      return (iret);
    }
  }
#line 209
  qloc = (qglobal->qprocess)->qsyslocs;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! ((unsigned long )qloc != (unsigned long )((void *)0))) {
#line 209
      goto while_break;
    }
#line 210
    if ((int const   )*(qloc->zname + 0) == (int const   )*(zsystem + 0)) {
      {
#line 210
      tmp = strcmp(qloc->zname, zsystem);
      }
#line 210
      if (tmp == 0) {
#line 212
        goto while_break;
      }
    }
#line 209
    qloc = qloc->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if ((unsigned long )qloc == (unsigned long )((void *)0)) {
#line 214
    return (1);
  }
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    if (! qloc->falias) {
#line 218
      goto while_break___0;
    }
#line 220
    qloc = qloc->qnext;
#line 221
    if ((unsigned long )qloc == (unsigned long )((void *)0)) {
#line 222
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 225
  _uuconf_ucmdtab_base(asIcmds, sizeof(asIcmds) / sizeof(asIcmds[0]), (char *)qsys,
                       as);
#line 227
  rewind(qloc->e);
#line 230
  _uuconf_uclear_system(qsys);
#line 232
  si.qsys = qsys;
#line 233
  si.falternates = 0;
#line 234
  si.fdefault_alternates = 1;
#line 235
  qsys->uuconf_palloc = uuconf_malloc_block();
  }
#line 236
  if ((unsigned long )qsys->uuconf_palloc == (unsigned long )((void *)0)) {
    {
#line 238
    tmp___0 = __errno_location();
#line 238
    qglobal->ierrno = *tmp___0;
    }
#line 239
    return (260);
  }
  {
#line 242
  iret = uuconf_cmd_file((pointer )qglobal, qloc->e, (struct uuconf_cmdtab  const  *)(as),
                         (pointer )(& si), & iiunknown, 2, qsys->uuconf_palloc);
  }
#line 245
  if (iret != 0) {
#line 247
    qglobal->zfilename = qloc->zfile;
#line 248
    return (iret | 512);
  }
#line 251
  if (! si.falternates) {
    {
#line 252
    uiset_call(qsys);
    }
  } else {
    {
#line 256
    iret = iialternate((pointer )qglobal, 0, (char **)((void *)0), (void *)0, (pointer )(& si));
    }
#line 258
    if (iret != 0) {
#line 259
      return (iret);
    }
  }
  {
#line 263
  sdefaults = *qsys;
#line 266
  tmp___2 = fseek(qloc->e, qloc->iloc, 0);
  }
#line 266
  if (tmp___2 != 0) {
    {
#line 268
    tmp___1 = __errno_location();
#line 268
    qglobal->ierrno = *tmp___1;
#line 269
    qglobal->zfilename = qloc->zfile;
    }
#line 270
    return (771);
  }
  {
#line 276
  _uuconf_uclear_system(qsys);
#line 277
  qsys->uuconf_zname = (char *)qloc->zname;
#line 278
  qsys->uuconf_palloc = sdefaults.uuconf_palloc;
#line 280
  si.falternates = 0;
#line 282
  iret = uuconf_cmd_file((void *)qglobal, qloc->e, (struct uuconf_cmdtab  const  *)(as),
                         (pointer )(& si), & iiunknown, 2, qsys->uuconf_palloc);
#line 284
  qglobal->ilineno += qloc->ilineno;
  }
#line 286
  if (iret == 0) {
#line 288
    if (! si.falternates) {
      {
#line 289
      uiset_call(qsys);
      }
    } else {
      {
#line 291
      iret = iialternate((pointer )qglobal, 0, (char **)((void *)0), (void *)0, (pointer )(& si));
      }
    }
  }
#line 296
  if (iret == 0) {
    {
#line 297
    iret = _uuconf_isystem_default(qglobal, qsys, & sdefaults, si.fdefault_alternates);
    }
  }
#line 304
  if (iret == 0) {
#line 306
    qsys->uuconf_fcalled = 1;
#line 307
    if ((unsigned long )qsys->uuconf_zport != (unsigned long )((char *)(& _uuconf_unset))) {
#line 311
      qsys->uuconf_fcall = 1;
    } else
#line 307
    if ((unsigned long )qsys->uuconf_qport != (unsigned long )((struct uuconf_port *)(& _uuconf_unset))) {
#line 311
      qsys->uuconf_fcall = 1;
    } else
#line 307
    if (qsys->uuconf_ibaud >= 0L) {
#line 311
      qsys->uuconf_fcall = 1;
    } else
#line 307
    if ((unsigned long )qsys->uuconf_zphone != (unsigned long )((char *)(& _uuconf_unset))) {
#line 311
      qsys->uuconf_fcall = 1;
    }
  }
#line 314
  if (iret != 0) {
#line 316
    qglobal->zfilename = qloc->zfile;
#line 317
    iret |= 512;
  }
#line 320
  return (iret);
}
}
#line 330 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static void uiset_call(struct uuconf_system *qsys ) 
{ 
  int tmp ;

  {
#line 334
  if ((unsigned long )qsys->uuconf_qtimegrade != (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 334
    tmp = 1;
  } else
#line 334
  if ((unsigned long )qsys->uuconf_zport != (unsigned long )((char *)(& _uuconf_unset))) {
#line 334
    tmp = 1;
  } else
#line 334
  if ((unsigned long )qsys->uuconf_qport != (unsigned long )((struct uuconf_port *)(& _uuconf_unset))) {
#line 334
    tmp = 1;
  } else
#line 334
  if (qsys->uuconf_ibaud >= 0L) {
#line 334
    tmp = 1;
  } else
#line 334
  if ((unsigned long )qsys->uuconf_zphone != (unsigned long )((char *)(& _uuconf_unset))) {
#line 334
    tmp = 1;
  } else
#line 334
  if ((unsigned long )qsys->uuconf_schat.uuconf_pzchat != (unsigned long )(& _uuconf_unset)) {
#line 334
    tmp = 1;
  } else
#line 334
  if ((unsigned long )qsys->uuconf_schat.uuconf_pzprogram != (unsigned long )(& _uuconf_unset)) {
#line 334
    tmp = 1;
  } else {
#line 334
    tmp = 0;
  }
#line 334
  qsys->uuconf_fcall = tmp;
#line 343
  qsys->uuconf_fcalled = (unsigned long )qsys->uuconf_zcalled_login != (unsigned long )((char *)(& _uuconf_unset));
#line 345
  return;
}
}
#line 351 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iisystem(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                    char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                    pointer pinfo  __attribute__((__unused__)) ) 
{ 


  {
#line 359
  return (4096);
}
}
#line 365 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iialias(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                   pointer pvar  __attribute__((__unused__)) , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  int iret ;

  {
  {
#line 373
  qglobal = (struct sglobal *)pglobal;
#line 374
  qinfo = (struct sinfo *)pinfo;
#line 377
  iret = _uuconf_iadd_string(qglobal, *(argv + 1), 1, 0, & (qinfo->qsys)->uuconf_pzalias,
                             (qinfo->qsys)->uuconf_palloc);
  }
#line 380
  if (iret != 0) {
#line 381
    iret |= 4096;
  }
#line 382
  return (iret);
}
}
#line 391 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iialternate(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                       pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  int iret ;
  struct uuconf_system *qnew ;
  struct uuconf_system **pq ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 399
  qglobal = (struct sglobal *)pglobal;
#line 400
  qinfo = (struct sinfo *)pinfo;
#line 402
  uiset_call(qinfo->qsys);
  }
#line 404
  if (! qinfo->falternates) {
#line 406
    qinfo->salternate = *(qinfo->qsys);
#line 407
    qinfo->falternates = 1;
  } else {
    {
#line 414
    iret = _uuconf_isystem_default(qglobal, qinfo->qsys, & qinfo->salternate, 0);
    }
#line 416
    if (iret != 0) {
#line 417
      return (iret | 4096);
    }
    {
#line 418
    tmp = uuconf_malloc((qinfo->qsys)->uuconf_palloc, sizeof(struct uuconf_system ));
#line 418
    qnew = (struct uuconf_system *)tmp;
    }
#line 421
    if ((unsigned long )qnew == (unsigned long )((void *)0)) {
      {
#line 423
      tmp___0 = __errno_location();
#line 423
      qglobal->ierrno = *tmp___0;
      }
#line 424
      return (4356);
    }
#line 428
    *qnew = *(qinfo->qsys);
#line 429
    pq = & qinfo->salternate.uuconf_qalternate;
    {
#line 429
    while (1) {
      while_continue: /* CIL Label */ ;
#line 429
      if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 429
        goto while_break;
      }
#line 429
      pq = & (*pq)->uuconf_qalternate;
    }
    while_break: /* CIL Label */ ;
    }
#line 433
    *pq = qnew;
  }
#line 438
  if (argc == 0) {
#line 439
    *(qinfo->qsys) = qinfo->salternate;
  } else {
    {
#line 442
    _uuconf_uclear_system(qinfo->qsys);
#line 443
    (qinfo->qsys)->uuconf_zname = qinfo->salternate.uuconf_zname;
#line 444
    (qinfo->qsys)->uuconf_palloc = qinfo->salternate.uuconf_palloc;
    }
#line 445
    if (argc > 1) {
#line 447
      (qinfo->qsys)->uuconf_zalternate = *(argv + 1);
#line 448
      return (2048);
    }
  }
#line 452
  return (0);
}
}
#line 460 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iidefault_alternates(pointer pglobal , int argc  __attribute__((__unused__)) ,
                                char **argv , pointer pvar  __attribute__((__unused__)) ,
                                pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  int tmp ;

  {
  {
#line 468
  qglobal = (struct sglobal *)pglobal;
#line 469
  qinfo = (struct sinfo *)pinfo;
#line 471
  tmp = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & qinfo->fdefault_alternates);
  }
#line 471
  return (tmp);
}
}
#line 480 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iitime(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  char *aznew[4] ;
  char ab___0[2] ;
  int tmp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 491
  if (argc != 2) {
#line 491
    if (argc != 3) {
#line 492
      return (4101);
    }
  }
#line 494
  aznew[0] = *(argv + 0);
#line 495
  ab___0[0] = (char )'z';
#line 496
  ab___0[1] = (char )'\000';
#line 497
  aznew[1] = ab___0;
#line 498
  aznew[2] = *(argv + 1);
#line 499
  if (argc > 2) {
#line 500
    aznew[3] = *(argv + 2);
  }
  {
#line 502
  tmp = iitimegrade(pglobal, argc + 1, aznew, pvar, pinfo);
  }
#line 502
  return (tmp);
}
}
#line 509 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iitimegrade(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_timespan **pqspan ;
  struct sinfo *qinfo ;
  int cretry ;
  int iret ;
  unsigned short const   **tmp ;

  {
#line 517
  qglobal = (struct sglobal *)pglobal;
#line 518
  pqspan = (struct uuconf_timespan **)pvar;
#line 519
  qinfo = (struct sinfo *)pinfo;
#line 523
  if (argc < 3) {
#line 524
    return (4101);
  } else
#line 523
  if (argc > 4) {
#line 524
    return (4101);
  }
#line 526
  if ((int )*(*(argv + 1) + 1) != 0) {
#line 527
    return (4101);
  } else {
    {
#line 526
    tmp = __ctype_b_loc();
    }
#line 526
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(*(argv + 1) + 0))) & 8)) {
#line 527
      return (4101);
    }
  }
#line 529
  if (argc == 3) {
#line 530
    cretry = 0;
  } else {
    {
#line 533
    iret = _uuconf_iint(qglobal, (char const   *)*(argv + 3), (pointer )(& cretry),
                        1);
    }
#line 534
    if (iret != 0) {
#line 535
      return (iret);
    }
  }
  {
#line 538
  iret = _uuconf_itime_parse(qglobal, *(argv + 2), (long )*(*(argv + 1) + 0), cretry,
                             & _uuconf_itime_grade_cmp, pqspan, (qinfo->qsys)->uuconf_palloc);
  }
#line 541
  if (iret != 0) {
#line 542
    iret |= 4096;
  }
#line 543
  return (iret);
}
}
#line 548 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iibaud_range(pointer pglobal , int argc  __attribute__((__unused__)) ,
                        char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_system *qsys ;
  int iret ;
  int tmp ;

  {
  {
#line 556
  qglobal = (struct sglobal *)pglobal;
#line 557
  qsys = (struct uuconf_system *)pvar;
#line 560
  iret = _uuconf_iint(qglobal, (char const   *)*(argv + 1), (pointer )(& qsys->uuconf_ibaud),
                      0);
  }
#line 562
  if (iret != 0) {
#line 563
    return (iret);
  }
  {
#line 564
  tmp = _uuconf_iint(qglobal, (char const   *)*(argv + 2), (pointer )(& qsys->uuconf_ihighbaud),
                     0);
  }
#line 564
  return (tmp);
}
}
#line 574 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iisize(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                  pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_timespan **pqspan ;
  struct sinfo *qinfo ;
  long ival ;
  int iret ;

  {
  {
#line 582
  qglobal = (struct sglobal *)pglobal;
#line 583
  pqspan = (struct uuconf_timespan **)pvar;
#line 584
  qinfo = (struct sinfo *)pinfo;
#line 588
  iret = _uuconf_iint(qglobal, (char const   *)*(argv + 1), (pointer )(& ival), 0);
  }
#line 589
  if (iret != 0) {
#line 590
    return (iret);
  }
  {
#line 592
  iret = _uuconf_itime_parse(qglobal, *(argv + 2), ival, 0, & iisizecmp, pqspan, (qinfo->qsys)->uuconf_palloc);
  }
#line 594
  if (iret != 0) {
#line 595
    iret |= 4096;
  }
#line 596
  return (iret);
}
}
#line 601 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iisizecmp(long i1 , long i2 ) 
{ 


  {
#line 607
  if (i1 < i2) {
#line 608
    return (-1);
  } else
#line 609
  if (i1 == i2) {
#line 610
    return (0);
  } else {
#line 612
    return (1);
  }
}
}
#line 620 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iiport(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                  pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  int iret ;
  struct uuconf_port *qnew ;
  void *tmp ;
  int *tmp___0 ;
  char *zname ;
  size_t clen ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 628
  qglobal = (struct sglobal *)pglobal;
#line 629
  qinfo = (struct sinfo *)pinfo;
#line 631
  if (argc < 2) {
#line 632
    return (4101);
  } else
#line 633
  if (argc == 2) {
#line 635
    (qinfo->qsys)->uuconf_zport = *(argv + 1);
#line 636
    return (2048);
  } else {
#line 642
    if ((unsigned long )(qinfo->qsys)->uuconf_qport == (unsigned long )((struct uuconf_port *)(& _uuconf_unset))) {
      {
#line 647
      tmp = uuconf_malloc((qinfo->qsys)->uuconf_palloc, sizeof(struct uuconf_port ));
#line 647
      qnew = (struct uuconf_port *)tmp;
      }
#line 650
      if ((unsigned long )qnew == (unsigned long )((void *)0)) {
        {
#line 652
        tmp___0 = __errno_location();
#line 652
        qglobal->ierrno = *tmp___0;
        }
#line 653
        return (4356);
      }
      {
#line 658
      _uuconf_uclear_port(qnew);
      }
#line 660
      if ((unsigned long )(qinfo->qsys)->uuconf_zname == (unsigned long )((void *)0)) {
#line 661
        qnew->uuconf_zname = (char *)"default system file port";
      } else {
        {
#line 667
        clen = strlen((char const   *)(qinfo->qsys)->uuconf_zname);
#line 668
        tmp___1 = uuconf_malloc((qinfo->qsys)->uuconf_palloc, clen + sizeof("system  port"));
#line 668
        zname = (char *)tmp___1;
        }
#line 670
        if ((unsigned long )zname == (unsigned long )((void *)0)) {
          {
#line 672
          tmp___2 = __errno_location();
#line 672
          qglobal->ierrno = *tmp___2;
          }
#line 673
          return (4356);
        }
        {
#line 678
        memcpy((void */* __restrict  */)((pointer )zname), (void const   */* __restrict  */)((pointer )"system "),
               sizeof("system ") - 1UL);
#line 680
        memcpy((void */* __restrict  */)((pointer )((zname + sizeof("system ")) - 1)),
               (void const   */* __restrict  */)((pointer )(qinfo->qsys)->uuconf_zname),
               clen);
#line 683
        memcpy((void */* __restrict  */)((pointer )(((zname + sizeof("system ")) - 1) + clen)),
               (void const   */* __restrict  */)((pointer )" port"), sizeof(" port"));
#line 686
        qnew->uuconf_zname = zname;
        }
      }
#line 689
      qnew->uuconf_palloc = (qinfo->qsys)->uuconf_palloc;
#line 691
      (qinfo->qsys)->uuconf_qport = qnew;
    }
    {
#line 694
    iret = _uuconf_iport_cmd(qglobal, argc - 1, argv + 1, (qinfo->qsys)->uuconf_qport);
    }
#line 696
    if ((iret & 255) != 0) {
#line 697
      iret |= 4096;
    }
#line 698
    return (iret);
  }
}
}
#line 705 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iichat(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  struct uuconf_chat *qchat ;
  int iret ;

  {
  {
#line 713
  qglobal = (struct sglobal *)pglobal;
#line 714
  qinfo = (struct sinfo *)pinfo;
#line 715
  qchat = (struct uuconf_chat *)pvar;
#line 718
  iret = _uuconf_ichat_cmd(qglobal, argc, argv, qchat, (qinfo->qsys)->uuconf_palloc);
  }
#line 720
  if ((iret & 255) != 0) {
#line 721
    iret |= 4096;
  }
#line 722
  return (iret);
}
}
#line 728 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iidebug(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  char **pzdebug ;
  int tmp ;

  {
  {
#line 736
  qglobal = (struct sglobal *)pglobal;
#line 737
  qinfo = (struct sinfo *)pinfo;
#line 738
  pzdebug = (char **)pvar;
#line 740
  tmp = _uuconf_idebug_cmd(qglobal, pzdebug, argc, argv, (qinfo->qsys)->uuconf_palloc);
  }
#line 740
  return (tmp);
}
}
#line 752 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iicalled_login(pointer pglobal  __attribute__((__unused__)) , int argc ,
                          char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  char **pz ;

  {
#line 760
  pz = (char **)pvar;
#line 762
  if (argc < 2) {
#line 763
    return (4101);
  }
#line 764
  *pz = *(argv + 1);
#line 765
  return (2048);
}
}
#line 771 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iiproto_param(pointer pglobal , int argc , char **argv , pointer pvar ,
                         pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_proto_param **pqparam ;
  struct sinfo *qinfo ;
  int tmp ;

  {
#line 779
  qglobal = (struct sglobal *)pglobal;
#line 780
  pqparam = (struct uuconf_proto_param **)pvar;
#line 781
  qinfo = (struct sinfo *)pinfo;
#line 783
  if ((unsigned long )*pqparam == (unsigned long )((struct uuconf_proto_param *)(& _uuconf_unset))) {
#line 784
    *pqparam = (struct uuconf_proto_param *)((void *)0);
  }
  {
#line 785
  tmp = _uuconf_iadd_proto_param(qglobal, argc - 1, argv + 1, pqparam, (qinfo->qsys)->uuconf_palloc);
  }
#line 785
  return (tmp);
}
}
#line 793 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iirequest(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                     pointer pvar  __attribute__((__unused__)) , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  int iret ;

  {
  {
#line 801
  qglobal = (struct sglobal *)pglobal;
#line 802
  qinfo = (struct sinfo *)pinfo;
#line 805
  iret = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & (qinfo->qsys)->uuconf_fsend_request);
  }
#line 807
  if ((iret & 255) == 0) {
#line 808
    (qinfo->qsys)->uuconf_frec_request = (qinfo->qsys)->uuconf_fsend_request;
  }
#line 810
  return (iret);
}
}
#line 817 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iitransfer(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                      pointer pvar  __attribute__((__unused__)) , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  int iret ;

  {
  {
#line 825
  qglobal = (struct sglobal *)pglobal;
#line 826
  qinfo = (struct sinfo *)pinfo;
#line 829
  iret = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & (qinfo->qsys)->uuconf_fcall_transfer);
  }
#line 831
  if ((iret & 255) == 0) {
#line 832
    (qinfo->qsys)->uuconf_fcalled_transfer = (qinfo->qsys)->uuconf_fcall_transfer;
  }
#line 834
  return (iret);
}
}
#line 841 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iiforward(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo *qinfo ;
  struct uuconf_system *qsys ;
  int i ;
  int iret ;

  {
#line 849
  qglobal = (struct sglobal *)pglobal;
#line 850
  qinfo = (struct sinfo *)pinfo;
#line 855
  qsys = qinfo->qsys;
#line 856
  qsys->uuconf_pzforward_from = (char **)((void *)0);
#line 857
  qsys->uuconf_pzforward_to = (char **)((void *)0);
#line 858
  i = 1;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! (i < argc)) {
#line 858
      goto while_break;
    }
    {
#line 860
    iret = _uuconf_iadd_string(qglobal, *(argv + i), 0, 0, & qsys->uuconf_pzforward_to,
                               qsys->uuconf_palloc);
    }
#line 863
    if (iret != 0) {
#line 864
      return ((iret | 2048) | 4096);
    }
    {
#line 865
    iret = _uuconf_iadd_string(qglobal, *(argv + i), 0, 0, & qsys->uuconf_pzforward_from,
                               qsys->uuconf_palloc);
    }
#line 868
    if (iret != 0) {
#line 869
      return ((iret | 2048) | 4096);
    }
#line 858
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  return (2048);
}
}
#line 879 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
static int iiunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                     char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo  __attribute__((__unused__)) ) 
{ 


  {
#line 887
  return (4101);
}
}
#line 894 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tsinfo.c"
int uuconf_taylor_system_unknown(void *pglobal , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_cmdtab as[sizeof(asIcmds) / sizeof(asIcmds[0])] ;
  struct sinfo si ;
  struct sunknown *q ;
  int iret ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 899
  qglobal = (struct sglobal *)pglobal;
#line 905
  if ((unsigned long )(qglobal->qprocess)->qunknown == (unsigned long )((void *)0)) {
#line 906
    return (1);
  }
  {
#line 908
  _uuconf_ucmdtab_base(asIcmds, sizeof(asIcmds) / sizeof(asIcmds[0]), (char *)qsys,
                       as);
#line 910
  _uuconf_uclear_system(qsys);
#line 912
  si.qsys = qsys;
#line 913
  si.falternates = 0;
#line 914
  si.fdefault_alternates = 1;
#line 915
  qsys->uuconf_palloc = uuconf_malloc_block();
  }
#line 916
  if ((unsigned long )qsys->uuconf_palloc == (unsigned long )((void *)0)) {
    {
#line 918
    tmp = __errno_location();
#line 918
    qglobal->ierrno = *tmp;
    }
#line 919
    return (260);
  }
#line 922
  q = (qglobal->qprocess)->qunknown;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 922
      goto while_break;
    }
    {
#line 924
    iret = uuconf_cmd_args(pglobal, q->cargs, q->pzargs, (struct uuconf_cmdtab  const  *)(as),
                           (pointer )(& si), & iiunknown, 2, qsys->uuconf_palloc);
#line 928
    iret &= -2049;
    }
#line 929
    if ((iret & 255) != 0) {
#line 931
      qglobal->zfilename = (char const   *)(qglobal->qprocess)->zconfigfile;
#line 932
      qglobal->ilineno = q->ilineno;
#line 933
      return (((iret & -4097) | 512) | 1024);
    }
#line 937
    if ((iret & 4096) != 0) {
#line 938
      goto while_break;
    }
#line 922
    q = q->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 941
  if (! si.falternates) {
    {
#line 942
    uiset_call(qsys);
    }
  } else {
    {
#line 945
    iret = iialternate(pglobal, 0, (char **)((void *)0), (void *)0, (pointer )(& si));
    }
#line 947
    if (iret != 0) {
#line 948
      return (iret);
    }
  }
  {
#line 952
  qsys->uuconf_fcalled = 1;
#line 954
  tmp___0 = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 954
  return (tmp___0);
}
}
#line 265 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_idialer_cmd(struct sglobal *qglobal , int argc , char **argv , struct uuconf_dialer *qdialer ) ;
#line 284
int _uuconf_iseven_bit(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                       pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 286
int _uuconf_ireliable(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                      pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 288
int _uuconf_ihalf_duplex(pointer pglobal , int argc  __attribute__((__unused__)) ,
                         char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 326
void _uuconf_uclear_dialer(struct uuconf_dialer *qdialer ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
char const   _uuconf_tportc_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )'c',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'8', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'3', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 33
static int ipproto_param(pointer pglobal , int argc , char **argv , pointer pvar ,
                         pointer pinfo ) ;
#line 35
static int ipbaud_range(pointer pglobal , int argc  __attribute__((__unused__)) ,
                        char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 37
static int ipdialer(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 39
static int ipcunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                      char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                      pointer pinfo  __attribute__((__unused__)) ) ;
#line 45 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static char const   * const  azPtype_names[7]  = {      (char const   */* const  */)((void *)0),      (char const   */* const  */)"stdin",      (char const   */* const  */)"modem",      (char const   */* const  */)"direct", 
        (char const   */* const  */)"tcp",      (char const   */* const  */)"tli",      (char const   */* const  */)"pipe"};
#line 60 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPort_cmds[7]  = {      {"protocol", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_zprotocols),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"protocol-parameter", 96, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_qproto_params),
      & ipproto_param}, 
        {"seven-bit", 98, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_ireliable),
      & _uuconf_iseven_bit}, 
        {"reliable", 98, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_ireliable),
      & _uuconf_ireliable}, 
        {"half-duplex", 98, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_ireliable),
      & _uuconf_ihalf_duplex}, 
        {"lockname", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_zlockname),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 81 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPstdin_cmds[1]  = {      {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 89 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPmodem_cmds[11]  = 
#line 89
  {      {"device", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_zdevice),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"baud", 50, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_ibaud),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"speed", 50, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_ibaud),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"baud-range", 99, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem),
      & ipbaud_range}, 
        {"speed-range", 99, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem),
      & ipbaud_range}, 
        {"carrier", 18, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_fcarrier),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"hardflow", 18, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_fhardflow),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"dial-device", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_zdial_device),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"dialer", 96, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem),
      & ipdialer}, 
        {"dialer-sequence", 80, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_smodem.uuconf_pzdialer),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 125 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPdirect_cmds[6]  = {      {"device", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_sdirect.uuconf_zdevice),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"baud", 50, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_sdirect.uuconf_ibaud),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"speed", 50, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_sdirect.uuconf_ibaud),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"carrier", 18, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_sdirect.uuconf_fcarrier),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"hardflow", 18, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_sdirect.uuconf_fhardflow),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 148 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPtcp_cmds[4]  = {      {"service", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stcp.uuconf_zport),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"version", 34, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stcp.uuconf_iversion),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"dialer-sequence", 80, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stcp.uuconf_pzdialer),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 165 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPtli_cmds[6]  = {      {"device", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stli.uuconf_zdevice),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"stream", 18, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stli.uuconf_fstream),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"push", 80, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stli.uuconf_pzpush),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"dialer-sequence", 80, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stli.uuconf_pzdialer),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"server-address", 64, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_stli.uuconf_zservaddr),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 188 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static struct cmdtab_offset  const  asPpipe_cmds[2]  = {      {"command", 80, (unsigned long )(& ((struct uuconf_port *)0)->uuconf_u.uuconf_spipe.uuconf_pzcmd),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 212 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
int _uuconf_iport_cmd(struct sglobal *qglobal , int argc , char **argv , struct uuconf_port *qport ) 
{ 
  boolean fgottype ;
  struct cmdtab_offset  const  *qcmds ;
  size_t ccmds ;
  struct uuconf_cmdtab as[sizeof(asPmodem_cmds) / sizeof(asPmodem_cmds[0])] ;
  size_t i ;
  int iret ;
  int tmp ;
  enum uuconf_porttype ttype ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 226
  tmp = strcasecmp((char const   *)*(argv + 0), "type");
#line 226
  fgottype = tmp == 0;
  }
#line 228
  if (fgottype) {
#line 228
    goto _L;
  } else
#line 228
  if ((unsigned int )qport->uuconf_ttype == 0U) {
    _L: /* CIL Label */ 
#line 240
    if (! fgottype) {
#line 241
      ttype = (enum uuconf_porttype )2;
    } else {
#line 244
      if (argc != 2) {
#line 245
        return (5);
      }
#line 247
      i = (size_t )0;
      {
#line 247
      while (1) {
        while_continue: /* CIL Label */ ;
#line 247
        if (! (i < sizeof(azPtype_names) / sizeof(azPtype_names[0]))) {
#line 247
          goto while_break;
        }
#line 248
        if ((unsigned long )azPtype_names[i] != (unsigned long )((void *)0)) {
          {
#line 248
          tmp___0 = strcasecmp((char const   *)*(argv + 1), (char const   *)azPtype_names[i]);
          }
#line 248
          if (tmp___0 == 0) {
#line 250
            goto while_break;
          }
        }
#line 247
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 252
      if (i >= sizeof(azPtype_names) / sizeof(azPtype_names[0])) {
#line 253
        return (5);
      }
#line 255
      ttype = (enum uuconf_porttype )i;
    }
#line 258
    qport->uuconf_ttype = ttype;
    {
#line 265
    if ((unsigned int )ttype == 2U) {
#line 265
      goto case_2;
    }
#line 276
    if ((unsigned int )ttype == 3U) {
#line 276
      goto case_3;
    }
#line 282
    if ((unsigned int )ttype == 4U) {
#line 282
      goto case_4;
    }
#line 292
    if ((unsigned int )ttype == 5U) {
#line 292
      goto case_5;
    }
#line 304
    if ((unsigned int )ttype == 6U) {
#line 304
      goto case_6;
    }
#line 262
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 264
    goto switch_break;
    case_2: /* CIL Label */ 
#line 266
    qport->uuconf_u.uuconf_smodem.uuconf_zdevice = (char *)((void *)0);
#line 267
    qport->uuconf_u.uuconf_smodem.uuconf_zdial_device = (char *)((void *)0);
#line 268
    qport->uuconf_u.uuconf_smodem.uuconf_ibaud = 0L;
#line 269
    qport->uuconf_u.uuconf_smodem.uuconf_ilowbaud = 0L;
#line 270
    qport->uuconf_u.uuconf_smodem.uuconf_ihighbaud = 0L;
#line 271
    qport->uuconf_u.uuconf_smodem.uuconf_fcarrier = 1;
#line 272
    qport->uuconf_u.uuconf_smodem.uuconf_fhardflow = 1;
#line 273
    qport->uuconf_u.uuconf_smodem.uuconf_pzdialer = (char **)((void *)0);
#line 274
    qport->uuconf_u.uuconf_smodem.uuconf_qdialer = (struct uuconf_dialer *)((void *)0);
#line 275
    goto switch_break;
    case_3: /* CIL Label */ 
#line 277
    qport->uuconf_u.uuconf_sdirect.uuconf_zdevice = (char *)((void *)0);
#line 278
    qport->uuconf_u.uuconf_sdirect.uuconf_ibaud = -1L;
#line 279
    qport->uuconf_u.uuconf_sdirect.uuconf_fcarrier = 0;
#line 280
    qport->uuconf_u.uuconf_sdirect.uuconf_fhardflow = 1;
#line 281
    goto switch_break;
    case_4: /* CIL Label */ 
#line 283
    qport->uuconf_u.uuconf_stcp.uuconf_zport = (char *)"uucp";
#line 284
    qport->uuconf_u.uuconf_stcp.uuconf_iversion = 0;
#line 285
    qport->uuconf_u.uuconf_stcp.uuconf_pzdialer = (char **)((void *)0);
#line 286
    qport->uuconf_ireliable = 31;
#line 291
    goto switch_break;
    case_5: /* CIL Label */ 
#line 293
    qport->uuconf_u.uuconf_stli.uuconf_zdevice = (char *)((void *)0);
#line 294
    qport->uuconf_u.uuconf_stli.uuconf_fstream = 0;
#line 295
    qport->uuconf_u.uuconf_stli.uuconf_pzpush = (char **)((void *)0);
#line 296
    qport->uuconf_u.uuconf_stli.uuconf_pzdialer = (char **)((void *)0);
#line 297
    qport->uuconf_u.uuconf_stli.uuconf_zservaddr = (char *)((void *)0);
#line 298
    qport->uuconf_ireliable = 31;
#line 303
    goto switch_break;
    case_6: /* CIL Label */ 
#line 305
    qport->uuconf_u.uuconf_spipe.uuconf_pzcmd = (char **)((void *)0);
#line 306
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 309
    if (fgottype) {
#line 310
      return (0);
    }
  }
#line 314
  qcmds = asPort_cmds;
#line 315
  ccmds = sizeof(asPort_cmds) / sizeof(asPort_cmds[0]);
#line 317
  i = (size_t )0;
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (i < sizeof(asPort_cmds) / sizeof(asPort_cmds[0]) - 1UL)) {
#line 317
      goto while_break___0;
    }
    {
#line 318
    tmp___1 = strcasecmp((char const   *)*(argv + 0), (char const   *)asPort_cmds[i].zcmd);
    }
#line 318
    if (tmp___1 == 0) {
#line 319
      goto while_break___0;
    }
#line 317
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 321
  if (i >= sizeof(asPort_cmds) / sizeof(asPort_cmds[0]) - 1UL) {
    {
#line 327
    if ((unsigned int )qport->uuconf_ttype == 1U) {
#line 327
      goto case_1;
    }
#line 331
    if ((unsigned int )qport->uuconf_ttype == 2U) {
#line 331
      goto case_2___0;
    }
#line 335
    if ((unsigned int )qport->uuconf_ttype == 3U) {
#line 335
      goto case_3___0;
    }
#line 339
    if ((unsigned int )qport->uuconf_ttype == 4U) {
#line 339
      goto case_4___0;
    }
#line 343
    if ((unsigned int )qport->uuconf_ttype == 5U) {
#line 343
      goto case_5___0;
    }
#line 347
    if ((unsigned int )qport->uuconf_ttype == 6U) {
#line 347
      goto case_6___0;
    }
#line 351
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 328
    qcmds = asPstdin_cmds;
#line 329
    ccmds = sizeof(asPstdin_cmds) / sizeof(asPstdin_cmds[0]);
#line 330
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 332
    qcmds = asPmodem_cmds;
#line 333
    ccmds = sizeof(asPmodem_cmds) / sizeof(asPmodem_cmds[0]);
#line 334
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 336
    qcmds = asPdirect_cmds;
#line 337
    ccmds = sizeof(asPdirect_cmds) / sizeof(asPdirect_cmds[0]);
#line 338
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 340
    qcmds = asPtcp_cmds;
#line 341
    ccmds = sizeof(asPtcp_cmds) / sizeof(asPtcp_cmds[0]);
#line 342
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 344
    qcmds = asPtli_cmds;
#line 345
    ccmds = sizeof(asPtli_cmds) / sizeof(asPtli_cmds[0]);
#line 346
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 348
    qcmds = asPpipe_cmds;
#line 349
    ccmds = sizeof(asPpipe_cmds) / sizeof(asPpipe_cmds[0]);
#line 350
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 352
    return (5);
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 358
  _uuconf_ucmdtab_base(qcmds, ccmds, (char *)qport, as);
#line 360
  iret = uuconf_cmd_args((pointer )qglobal, argc, argv, (struct uuconf_cmdtab  const  *)(as),
                         (pointer )qport, & ipcunknown, 0, qport->uuconf_palloc);
  }
#line 364
  return (iret & -4097);
}
}
#line 369 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static int ipproto_param(pointer pglobal , int argc , char **argv , pointer pvar ,
                         pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_proto_param **pqparam ;
  struct uuconf_port *qport ;
  int tmp ;

  {
  {
#line 377
  qglobal = (struct sglobal *)pglobal;
#line 378
  pqparam = (struct uuconf_proto_param **)pvar;
#line 379
  qport = (struct uuconf_port *)pinfo;
#line 381
  tmp = _uuconf_iadd_proto_param(qglobal, argc - 1, argv + 1, pqparam, qport->uuconf_palloc);
  }
#line 381
  return (tmp);
}
}
#line 388 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static int ipbaud_range(pointer pglobal , int argc  __attribute__((__unused__)) ,
                        char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_modem_port *qmodem ;
  int iret ;
  int tmp ;

  {
  {
#line 396
  qglobal = (struct sglobal *)pglobal;
#line 397
  qmodem = (struct uuconf_modem_port *)pvar;
#line 400
  iret = _uuconf_iint(qglobal, (char const   *)*(argv + 1), (pointer )(& qmodem->uuconf_ilowbaud),
                      0);
  }
#line 402
  if ((iret & -2049) != 0) {
#line 403
    return (iret);
  }
  {
#line 405
  tmp = _uuconf_iint(qglobal, (char const   *)*(argv + 2), (pointer )(& qmodem->uuconf_ihighbaud),
                     0);
#line 405
  iret |= tmp;
  }
#line 408
  return (iret);
}
}
#line 415 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static int ipdialer(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_modem_port *qmodem ;
  struct uuconf_port *qport ;
  int iret ;
  struct uuconf_dialer *qnew ;
  size_t clen ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 423
  qglobal = (struct sglobal *)pglobal;
#line 424
  qmodem = (struct uuconf_modem_port *)pvar;
#line 425
  qport = (struct uuconf_port *)pinfo;
#line 428
  if (argc < 2) {
#line 429
    return (4101);
  }
#line 431
  if (argc > 2) {
#line 433
    if ((unsigned long )qmodem->uuconf_qdialer == (unsigned long )((void *)0)) {
      {
#line 438
      tmp = uuconf_malloc(qport->uuconf_palloc, sizeof(struct uuconf_dialer ));
#line 438
      qnew = (struct uuconf_dialer *)tmp;
      }
#line 441
      if ((unsigned long )qnew == (unsigned long )((void *)0)) {
        {
#line 443
        tmp___0 = __errno_location();
#line 443
        qglobal->ierrno = *tmp___0;
        }
#line 444
        return (4356);
      }
      {
#line 449
      _uuconf_uclear_dialer(qnew);
      }
#line 451
      if ((unsigned long )qport->uuconf_zname == (unsigned long )((void *)0)) {
#line 452
        qnew->uuconf_zname = (char *)"default port file dialer";
      } else {
        {
#line 455
        clen = strlen((char const   *)qport->uuconf_zname);
#line 456
        tmp___1 = uuconf_malloc(qport->uuconf_palloc, clen + sizeof(" dialer"));
#line 456
        qnew->uuconf_zname = (char *)tmp___1;
        }
#line 459
        if ((unsigned long )qnew->uuconf_zname == (unsigned long )((void *)0)) {
          {
#line 461
          tmp___2 = __errno_location();
#line 461
          qglobal->ierrno = *tmp___2;
          }
#line 462
          return (4356);
        }
        {
#line 467
        memcpy((void */* __restrict  */)((pointer )qnew->uuconf_zname), (void const   */* __restrict  */)((pointer )qport->uuconf_zname),
               clen);
#line 469
        memcpy((void */* __restrict  */)((pointer )(qnew->uuconf_zname + clen)), (void const   */* __restrict  */)((pointer )" dialer"),
               sizeof(" dialer"));
        }
      }
#line 473
      qnew->uuconf_palloc = qport->uuconf_palloc;
#line 475
      qmodem->uuconf_qdialer = qnew;
    }
    {
#line 478
    iret = _uuconf_idialer_cmd(qglobal, argc - 1, argv + 1, qmodem->uuconf_qdialer);
    }
#line 480
    if ((iret & -2049) != 0) {
#line 481
      iret |= 4096;
    }
#line 482
    return (iret);
  } else {
    {
#line 486
    qmodem->uuconf_pzdialer = (char **)((void *)0);
#line 487
    iret = _uuconf_iadd_string(qglobal, *(argv + 1), 1, 0, & qmodem->uuconf_pzdialer,
                               qport->uuconf_palloc);
    }
#line 490
    if (iret != 0) {
#line 491
      iret |= 4096;
    }
#line 492
    return (iret);
  }
}
}
#line 499 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tportc.c"
static int ipcunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                      char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                      pointer pinfo  __attribute__((__unused__)) ) 
{ 


  {
#line 507
  return (4101);
}
}
#line 1097 "../uuconf.h"
int uuconf_taylor_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud ,
                            int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) ,
                            void *pinfo , struct uuconf_port *qport ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tport.c"
char const   _uuconf_tport_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tport.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33
static int ipport(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                  pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 35
static int ipunknown(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) ;
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tport.c"
int uuconf_taylor_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud ,
                            int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) ,
                            void *pinfo , struct uuconf_port *qport ) 
{ 
  struct sglobal *qglobal ;
  FILE *e ;
  pointer pblock ;
  char *zfree ;
  int iret ;
  char **pz ;
  struct uuconf_cmdtab as[2] ;
  char *zport ;
  struct uuconf_port sdefault ;
  int ilineno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int (*piunknown)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
                   void *uuconf_pinfo ) ;
  boolean fmatch ;
  int tmp___2 ;
  long imbaud ;
  long imhigh ;
  long imlow ;
  long idbaud ;
  int *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 52
  qglobal = (struct sglobal *)pglobal;
#line 59
  if (ihighbaud == 0L) {
#line 60
    ihighbaud = ibaud;
  }
#line 62
  e = (FILE *)((void *)0);
#line 63
  pblock = (void *)0;
#line 64
  zfree = (char *)((void *)0);
#line 65
  iret = 1;
#line 67
  pz = (qglobal->qprocess)->pzportfiles;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 67
      goto while_break;
    }
    {
#line 74
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 75
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 77
      tmp = __errno_location();
      }
#line 77
      if (*tmp == 2) {
#line 78
        goto __Cont;
      }
      {
#line 79
      tmp___0 = __errno_location();
#line 79
      qglobal->ierrno = *tmp___0;
#line 80
      iret = 258;
      }
#line 81
      goto while_break;
    }
    {
#line 84
    qglobal->ilineno = 0;
#line 90
    as[0].uuconf_zcmd = "port";
#line 91
    as[0].uuconf_itype = 98;
#line 92
    as[0].uuconf_pvar = (pointer )(& zport);
#line 93
    as[0].uuconf_pifn = & ipport;
#line 95
    as[1].uuconf_zcmd = (char const   *)((void *)0);
#line 97
    pblock = uuconf_malloc_block();
    }
#line 98
    if ((unsigned long )pblock == (unsigned long )((void *)0)) {
      {
#line 100
      tmp___1 = __errno_location();
#line 100
      qglobal->ierrno = *tmp___1;
#line 101
      iret = 260;
      }
#line 102
      goto while_break;
    }
    {
#line 105
    _uuconf_uclear_port(& sdefault);
#line 106
    sdefault.uuconf_palloc = pblock;
#line 107
    zport = (char *)((void *)0);
#line 108
    iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (pointer )(& sdefault),
                           & ipunknown, 2, pblock);
    }
#line 111
    if (iret != 0) {
#line 113
      zfree = zport;
#line 114
      goto while_break;
    }
#line 119
    iret = 1;
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 120
      if (! ((unsigned long )zport != (unsigned long )((void *)0))) {
#line 120
        goto while_break___0;
      }
#line 125
      if ((unsigned long )zname == (unsigned long )((void *)0)) {
#line 127
        piunknown = & ipunknown;
#line 128
        *qport = sdefault;
#line 129
        qport->uuconf_zname = zport;
#line 130
        zfree = zport;
#line 131
        fmatch = 1;
      } else {
        {
#line 125
        tmp___2 = strcmp(zname, (char const   *)zport);
        }
#line 125
        if (tmp___2 == 0) {
#line 127
          piunknown = & ipunknown;
#line 128
          *qport = sdefault;
#line 129
          qport->uuconf_zname = zport;
#line 130
          zfree = zport;
#line 131
          fmatch = 1;
        } else {
          {
#line 135
          piunknown = (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                               void *uuconf_pvar , void *uuconf_pinfo ))((void *)0);
#line 136
          free((pointer )zport);
#line 137
          fmatch = 0;
          }
        }
      }
      {
#line 140
      zport = (char *)((void *)0);
#line 141
      ilineno = qglobal->ilineno;
#line 142
      iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (pointer )qport,
                             piunknown, 2, pblock);
#line 145
      qglobal->ilineno += ilineno;
      }
#line 146
      if (iret != 0) {
#line 147
        goto while_break___0;
      }
#line 148
      iret = 1;
#line 153
      if (fmatch) {
#line 155
        if (ibaud != 0L) {
#line 157
          if ((unsigned int )qport->uuconf_ttype == 2U) {
#line 161
            imbaud = qport->uuconf_u.uuconf_smodem.uuconf_ibaud;
#line 162
            imhigh = qport->uuconf_u.uuconf_smodem.uuconf_ihighbaud;
#line 163
            imlow = qport->uuconf_u.uuconf_smodem.uuconf_ilowbaud;
#line 165
            if (imbaud == 0L) {
#line 165
              if (! (imlow == 0L)) {
#line 165
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 167
            if (ibaud <= imbaud) {
#line 167
              if (! (imbaud <= ihighbaud)) {
#line 167
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 169
            if (imlow != 0L) {
#line 169
              if (imlow <= ihighbaud) {
#line 169
                if (! (imhigh >= ibaud)) {
#line 174
                  fmatch = 0;
                }
              } else {
#line 174
                fmatch = 0;
              }
            } else {
#line 174
              fmatch = 0;
            }
          } else
#line 176
          if ((unsigned int )qport->uuconf_ttype == 3U) {
#line 180
            idbaud = qport->uuconf_u.uuconf_sdirect.uuconf_ibaud;
#line 181
            if (idbaud != 0L) {
#line 181
              if (idbaud != ibaud) {
#line 182
                fmatch = 0;
              }
            }
          }
        }
      }
#line 187
      if (fmatch) {
#line 189
        if ((unsigned long )pifn != (unsigned long )((void *)0)) {
          {
#line 191
          iret = (*pifn)(qport, pinfo);
          }
#line 192
          if (iret == 1) {
#line 193
            fmatch = 0;
          } else
#line 194
          if (iret != 0) {
#line 195
            goto while_break___0;
          }
        }
      }
#line 199
      if (fmatch) {
        {
#line 201
        tmp___4 = uuconf_add_block(pblock, (void *)zfree);
        }
#line 201
        if (tmp___4 == 0) {
#line 203
          zfree = (char *)((void *)0);
#line 204
          iret = 0;
        } else {
          {
#line 208
          tmp___3 = __errno_location();
#line 208
          qglobal->ierrno = *tmp___3;
#line 209
          iret = 260;
          }
        }
#line 211
        goto while_break___0;
      }
#line 214
      if ((unsigned long )zfree != (unsigned long )((void *)0)) {
        {
#line 216
        free((pointer )zfree);
#line 217
        zfree = (char *)((void *)0);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 221
    fclose(e);
#line 222
    e = (FILE *)((void *)0);
    }
#line 224
    if (iret != 1) {
#line 225
      goto while_break;
    }
    {
#line 227
    uuconf_free_block(pblock);
#line 228
    pblock = (void *)0;
    }
    __Cont: /* CIL Label */ 
#line 67
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if ((unsigned long )e != (unsigned long )((void *)0)) {
    {
#line 232
    fclose(e);
    }
  }
#line 233
  if ((unsigned long )zfree != (unsigned long )((void *)0)) {
    {
#line 234
    free((pointer )zfree);
    }
  }
#line 235
  if (iret != 0) {
#line 235
    if ((unsigned long )pblock != (unsigned long )((void *)0)) {
      {
#line 236
      uuconf_free_block(pblock);
      }
    }
  }
#line 238
  if (iret != 0) {
#line 238
    if (iret != 1) {
#line 240
      qglobal->zfilename = (char const   *)*pz;
#line 241
      iret |= 512;
    }
  }
#line 244
  return (iret);
}
}
#line 253 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tport.c"
static int ipport(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                  pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char **pz ;
  size_t csize ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 261
  qglobal = (struct sglobal *)pglobal;
#line 262
  pz = (char **)pvar;
#line 265
  tmp = strlen((char const   *)*(argv + 1));
#line 265
  csize = tmp + 1UL;
#line 266
  tmp___0 = malloc(csize);
#line 266
  *pz = (char *)tmp___0;
  }
#line 267
  if ((unsigned long )*pz == (unsigned long )((void *)0)) {
    {
#line 269
    tmp___1 = __errno_location();
#line 269
    qglobal->ierrno = *tmp___1;
    }
#line 270
    return (4356);
  }
  {
#line 274
  memcpy((void */* __restrict  */)((pointer )*pz), (void const   */* __restrict  */)((pointer )*(argv + 1)),
         csize);
  }
#line 275
  return (4096);
}
}
#line 282 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tport.c"
static int ipunknown(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_port *qport ;
  int iret ;

  {
  {
#line 290
  qglobal = (struct sglobal *)pglobal;
#line 291
  qport = (struct uuconf_port *)pinfo;
#line 294
  iret = _uuconf_iport_cmd(qglobal, argc, argv, qport);
  }
#line 295
  if ((iret & 255) != 0) {
#line 296
    iret |= 4096;
  }
#line 297
  return (iret);
}
}
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 760 "../uuconf.h"
int uuconf_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) ;
#line 785
int uuconf_system_free(void *pglobal  __attribute__((__unused__)) , struct uuconf_system *qsys ) ;
#line 1123
int uuconf_taylor_login_localname(void *pglobal , char const   *zlogin , char **pzname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tlocnm.c"
char const   _uuconf_tlocnm_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tlocnm.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'n',      (char const   )'m',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tlocnm.c"
int uuconf_taylor_login_localname(void *pglobal , char const   *zlogin , char **pzname ) 
{ 
  struct sglobal *qglobal ;
  char **pznames ;
  char **pz ;
  int iret ;
  struct uuconf_system ssys ;
  struct uuconf_system *qsys ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 44
  qglobal = (struct sglobal *)pglobal;
#line 48
  if (! (qglobal->qprocess)->fread_syslocs) {
    {
#line 50
    iret = _uuconf_iread_locations(qglobal);
    }
#line 51
    if (iret != 0) {
#line 52
      return (iret);
    }
  }
#line 57
  if (! (qglobal->qprocess)->fuses_myname) {
#line 59
    *pzname = (char *)((void *)0);
#line 60
    return (1);
  }
  {
#line 63
  iret = uuconf_taylor_system_names(pglobal, & pznames, 0);
  }
#line 64
  if (iret != 0) {
#line 65
    return (iret);
  }
#line 67
  *pzname = (char *)((void *)0);
#line 68
  iret = 1;
#line 70
  pz = pznames;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 70
      goto while_break;
    }
    {
#line 75
    iret = uuconf_system_info(pglobal, (char const   *)*pz, & ssys);
    }
#line 76
    if (iret != 0) {
#line 77
      goto while_break;
    }
#line 79
    qsys = & ssys;
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 79
      if (! ((unsigned long )qsys != (unsigned long )((void *)0))) {
#line 79
        goto while_break___0;
      }
#line 81
      if ((unsigned long )qsys->uuconf_zlocalname != (unsigned long )((void *)0)) {
#line 81
        if (qsys->uuconf_fcalled) {
#line 81
          if ((unsigned long )qsys->uuconf_zcalled_login != (unsigned long )((void *)0)) {
            {
#line 81
            tmp___0 = strcmp((char const   *)qsys->uuconf_zcalled_login, zlogin);
            }
#line 81
            if (tmp___0 == 0) {
              {
#line 86
              *pzname = strdup((char const   *)qsys->uuconf_zlocalname);
              }
#line 87
              if ((unsigned long )*pzname != (unsigned long )((void *)0)) {
#line 88
                iret = 0;
              } else {
                {
#line 91
                tmp = __errno_location();
#line 91
                qglobal->ierrno = *tmp;
#line 92
                iret = 260;
                }
              }
#line 94
              goto while_break___0;
            }
          }
        }
      }
#line 79
      qsys = qsys->uuconf_qalternate;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    uuconf_system_free(pglobal, & ssys);
    }
#line 100
    if ((unsigned long )qsys != (unsigned long )((void *)0)) {
#line 101
      goto while_break;
    }
#line 103
    iret = 1;
#line 70
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  pz = pznames;
  {
#line 106
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 106
      goto while_break___1;
    }
    {
#line 107
    free((pointer )*pz);
#line 106
    pz ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 108
  free((pointer )pznames);
  }
#line 110
  return (iret);
}
}
#line 1067 "../uuconf.h"
int uuconf_taylor_init(void **ppglobal , char const   *zprogram , char const   *zname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
char const   _uuconf_tinit_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'i',      (char const   )'n', 
        (char const   )'i',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 35
static int itset_default(struct sglobal *qglobal , char ***ppzvar , char const   *zfile ) ;
#line 37
static int itdebug(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 39
static int itaddfile(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 41
static int itunknown(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 43
static int itprogram(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) ;
#line 46 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
static struct cmdtab_offset  const  asCmds[26]  = 
#line 46
  {      {"nodename", 64, (unsigned long )(& ((struct sprocess *)0)->zlocalname), (int (*)(void *uuconf_pglobal ,
                                                                                       int uuconf_argc ,
                                                                                       char **uuconf_argv ,
                                                                                       void *uuconf_pvar ,
                                                                                       void *uuconf_pinfo ))((void *)0)}, 
        {"hostname",
      64, (unsigned long )(& ((struct sprocess *)0)->zlocalname), (int (*)(void *uuconf_pglobal ,
                                                                           int uuconf_argc ,
                                                                           char **uuconf_argv ,
                                                                           void *uuconf_pvar ,
                                                                           void *uuconf_pinfo ))((void *)0)}, 
        {"uuname",
      64, (unsigned long )(& ((struct sprocess *)0)->zlocalname), (int (*)(void *uuconf_pglobal ,
                                                                           int uuconf_argc ,
                                                                           char **uuconf_argv ,
                                                                           void *uuconf_pvar ,
                                                                           void *uuconf_pinfo ))((void *)0)}, 
        {"spool",
      64, (unsigned long )(& ((struct sprocess *)0)->zspooldir), (int (*)(void *uuconf_pglobal ,
                                                                          int uuconf_argc ,
                                                                          char **uuconf_argv ,
                                                                          void *uuconf_pvar ,
                                                                          void *uuconf_pinfo ))((void *)0)}, 
        {"pubdir",
      64, (unsigned long )(& ((struct sprocess *)0)->zpubdir), (int (*)(void *uuconf_pglobal ,
                                                                        int uuconf_argc ,
                                                                        char **uuconf_argv ,
                                                                        void *uuconf_pvar ,
                                                                        void *uuconf_pinfo ))((void *)0)}, 
        {"lockdir",
      64, (unsigned long )(& ((struct sprocess *)0)->zlockdir), (int (*)(void *uuconf_pglobal ,
                                                                         int uuconf_argc ,
                                                                         char **uuconf_argv ,
                                                                         void *uuconf_pvar ,
                                                                         void *uuconf_pinfo ))((void *)0)}, 
        {"logfile",
      64, (unsigned long )(& ((struct sprocess *)0)->zlogfile), (int (*)(void *uuconf_pglobal ,
                                                                         int uuconf_argc ,
                                                                         char **uuconf_argv ,
                                                                         void *uuconf_pvar ,
                                                                         void *uuconf_pinfo ))((void *)0)}, 
        {"statfile",
      64, (unsigned long )(& ((struct sprocess *)0)->zstatsfile), (int (*)(void *uuconf_pglobal ,
                                                                           int uuconf_argc ,
                                                                           char **uuconf_argv ,
                                                                           void *uuconf_pvar ,
                                                                           void *uuconf_pinfo ))((void *)0)}, 
        {"debugfile",
      64, (unsigned long )(& ((struct sprocess *)0)->zdebugfile), (int (*)(void *uuconf_pglobal ,
                                                                           int uuconf_argc ,
                                                                           char **uuconf_argv ,
                                                                           void *uuconf_pvar ,
                                                                           void *uuconf_pinfo ))((void *)0)}, 
        {"debug",
      96, (unsigned long )(& ((struct sprocess *)0)->zdebug), & itdebug}, 
        {"strip-login", 18, (unsigned long )(& ((struct sprocess *)0)->fstrip_login),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"strip-proto", 18, (unsigned long )(& ((struct sprocess *)0)->fstrip_proto),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"max-uuxqts", 34, (unsigned long )(& ((struct sprocess *)0)->cmaxuuxqts), (int (*)(void *uuconf_pglobal ,
                                                                                         int uuconf_argc ,
                                                                                         char **uuconf_argv ,
                                                                                         void *uuconf_pvar ,
                                                                                         void *uuconf_pinfo ))((void *)0)}, 
        {"run-uuxqt",
      64, (unsigned long )(& ((struct sprocess *)0)->zrunuuxqt), (int (*)(void *uuconf_pglobal ,
                                                                          int uuconf_argc ,
                                                                          char **uuconf_argv ,
                                                                          void *uuconf_pvar ,
                                                                          void *uuconf_pinfo ))((void *)0)}, 
        {"sysfile",
      96, (unsigned long )(& ((struct sprocess *)0)->pzsysfiles), & itaddfile}, 
        {"portfile", 96, (unsigned long )(& ((struct sprocess *)0)->pzportfiles), & itaddfile}, 
        {"dialfile",
      96, (unsigned long )(& ((struct sprocess *)0)->pzdialfiles), & itaddfile}, 
        {"dialcodefile", 96, (unsigned long )(& ((struct sprocess *)0)->pzdialcodefiles),
      & itaddfile}, 
        {"callfile", 96, (unsigned long )(& ((struct sprocess *)0)->pzcallfiles), & itaddfile}, 
        {"passwdfile",
      96, (unsigned long )(& ((struct sprocess *)0)->pzpwdfiles), & itaddfile}, 
        {"unknown", 96, (unsigned long )(& ((struct sprocess *)0)->qunknown), & itunknown}, 
        {"v2-files",
      18, (unsigned long )(& ((struct sprocess *)0)->fv2), (int (*)(void *uuconf_pglobal ,
                                                                    int uuconf_argc ,
                                                                    char **uuconf_argv ,
                                                                    void *uuconf_pvar ,
                                                                    void *uuconf_pinfo ))((void *)0)}, 
        {"hdb-files",
      18, (unsigned long )(& ((struct sprocess *)0)->fhdb), (int (*)(void *uuconf_pglobal ,
                                                                     int uuconf_argc ,
                                                                     char **uuconf_argv ,
                                                                     void *uuconf_pvar ,
                                                                     void *uuconf_pinfo ))((void *)0)}, 
        {"bnu-files",
      18, (unsigned long )(& ((struct sprocess *)0)->fhdb), (int (*)(void *uuconf_pglobal ,
                                                                     int uuconf_argc ,
                                                                     char **uuconf_argv ,
                                                                     void *uuconf_pvar ,
                                                                     void *uuconf_pinfo ))((void *)0)}, 
        {"timetable",
      99, (unsigned long )(& ((struct sprocess *)0)->pztimetables), & _uuconf_itimetable}, 
        {(char const   *)((void *)0),
      0, (size_t )0, (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                              void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 118 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
int uuconf_taylor_init(void **ppglobal , char const   *zprogram , char const   *zname ) 
{ 
  struct sglobal **pqglobal ;
  int iret ;
  char *zcopy ;
  struct sglobal *qglobal ;
  boolean fdefault ;
  FILE *e ;
  struct sinfo___0 si ;
  size_t csize ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  struct uuconf_cmdtab as[sizeof(asCmds) / sizeof(asCmds[0])] ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 124
  pqglobal = (struct sglobal **)ppglobal;
#line 132
  if ((unsigned long )*pqglobal == (unsigned long )((void *)0)) {
    {
#line 134
    iret = _uuconf_iinit_global(pqglobal);
    }
#line 135
    if (iret != 0) {
#line 136
      return (iret);
    }
  }
#line 139
  qglobal = *pqglobal;
#line 141
  if ((unsigned long )zname != (unsigned long )((void *)0)) {
    {
#line 145
    tmp = strlen(zname);
#line 145
    csize = tmp + 1UL;
#line 146
    tmp___0 = uuconf_malloc(qglobal->pblock, csize);
#line 146
    zcopy = (char *)tmp___0;
    }
#line 147
    if ((unsigned long )zcopy == (unsigned long )((void *)0)) {
      {
#line 149
      tmp___1 = __errno_location();
#line 149
      qglobal->ierrno = *tmp___1;
      }
#line 150
      return (260);
    }
    {
#line 152
    memcpy((void */* __restrict  */)((pointer )zcopy), (void const   */* __restrict  */)((pointer )zname),
           csize);
#line 153
    fdefault = 0;
    }
  } else {
    {
#line 157
    tmp___2 = uuconf_malloc(qglobal->pblock, (sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp") + sizeof("/config")) - 1UL);
#line 157
    zcopy = (char *)tmp___2;
    }
#line 159
    if ((unsigned long )zcopy == (unsigned long )((void *)0)) {
      {
#line 161
      tmp___3 = __errno_location();
#line 161
      qglobal->ierrno = *tmp___3;
      }
#line 162
      return (260);
    }
    {
#line 164
    memcpy((void */* __restrict  */)((pointer )zcopy), (void const   */* __restrict  */)((pointer )"/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp"),
           sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp") - 1UL);
#line 166
    memcpy((void */* __restrict  */)((pointer )((zcopy + sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp")) - 1)),
           (void const   */* __restrict  */)((pointer )"/config"), sizeof("/config"));
#line 168
    fdefault = 1;
    }
  }
  {
#line 171
  (qglobal->qprocess)->zconfigfile = zcopy;
#line 173
  e = fopen((char const   */* __restrict  */)zcopy, (char const   */* __restrict  */)"r");
  }
#line 174
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 176
    if (! fdefault) {
      {
#line 178
      tmp___4 = __errno_location();
#line 178
      qglobal->ierrno = *tmp___4;
#line 179
      qglobal->zfilename = (char const   *)zcopy;
      }
#line 180
      return (770);
    }
  } else {
    {
#line 191
    _uuconf_ucmdtab_base(asCmds, sizeof(asCmds) / sizeof(asCmds[0]), (char *)qglobal->qprocess,
                         as);
    }
#line 194
    if ((unsigned long )zprogram == (unsigned long )((void *)0)) {
#line 195
      zprogram = "uucp";
    }
    {
#line 197
    si.zname = zprogram;
#line 198
    si.qcmds = as;
#line 199
    iret = uuconf_cmd_file((void *)qglobal, e, (struct uuconf_cmdtab  const  *)(as),
                           (pointer )(& si), & itprogram, 2, qglobal->pblock);
#line 203
    fclose(e);
    }
#line 205
    if (iret != 0) {
#line 207
      qglobal->zfilename = (char const   *)zcopy;
#line 208
      return (iret | 512);
    }
  }
  {
#line 214
  iret = itset_default(qglobal, & (qglobal->qprocess)->pzsysfiles, "/sys");
  }
#line 215
  if (iret != 0) {
#line 216
    return (iret);
  }
  {
#line 217
  iret = itset_default(qglobal, & (qglobal->qprocess)->pzportfiles, "/port");
  }
#line 218
  if (iret != 0) {
#line 219
    return (iret);
  }
  {
#line 220
  iret = itset_default(qglobal, & (qglobal->qprocess)->pzdialfiles, "/dial");
  }
#line 221
  if (iret != 0) {
#line 222
    return (iret);
  }
  {
#line 223
  iret = itset_default(qglobal, & (qglobal->qprocess)->pzdialcodefiles, "/dialcode");
  }
#line 225
  if (iret != 0) {
#line 226
    return (iret);
  }
  {
#line 227
  iret = itset_default(qglobal, & (qglobal->qprocess)->pzpwdfiles, "/passwd");
  }
#line 228
  if (iret != 0) {
#line 229
    return (iret);
  }
  {
#line 230
  iret = itset_default(qglobal, & (qglobal->qprocess)->pzcallfiles, "/call");
  }
#line 231
  if (iret != 0) {
#line 232
    return (iret);
  }
#line 234
  return (0);
}
}
#line 240 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
static int itdebug(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char **pzdebug ;
  int tmp ;

  {
  {
#line 248
  qglobal = (struct sglobal *)pglobal;
#line 249
  pzdebug = (char **)pvar;
#line 251
  tmp = _uuconf_idebug_cmd(qglobal, pzdebug, argc, argv, qglobal->pblock);
  }
#line 251
  return (tmp);
}
}
#line 258 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
static int itaddfile(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char ***ppz ;
  int i ;
  int iret ;
  char *z ;
  boolean fallocated ;
  size_t abs_cdir ;
  size_t abs_cfile ;
  char *abs_zret ;
  void *tmp ;
  int *tmp___0 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 266
  qglobal = (struct sglobal *)pglobal;
#line 267
  ppz = (char ***)pvar;
#line 271
  if (argc == 1) {
    {
#line 273
    iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppz, qglobal->pblock);
    }
#line 275
    if (iret != 0) {
#line 276
      return (iret);
    }
  } else {
#line 280
    i = 1;
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 280
      if (! (i < argc)) {
#line 280
        goto while_break;
      }
      {
#line 285
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 285
        if ((int )*(*(argv + i)) == 47) {
#line 285
          z = *(argv + i);
#line 285
          fallocated = 0;
        } else {
          {
#line 285
          abs_cdir = strlen("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp");
#line 285
          abs_cfile = strlen((char const   *)*(argv + i));
#line 285
          tmp = uuconf_malloc(qglobal->pblock, (abs_cdir + abs_cfile) + 2UL);
#line 285
          abs_zret = (char *)tmp;
#line 285
          z = abs_zret;
#line 285
          fallocated = 1;
          }
#line 285
          if ((unsigned long )abs_zret != (unsigned long )((void *)0)) {
            {
#line 285
            memcpy((void */* __restrict  */)((pointer )abs_zret), (void const   */* __restrict  */)((pointer )"/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp"),
                   abs_cdir);
#line 285
            *(abs_zret + abs_cdir) = (char )'/';
#line 285
            memcpy((void */* __restrict  */)((pointer )((abs_zret + abs_cdir) + 1)),
                   (void const   */* __restrict  */)((pointer )*(argv + i)), abs_cfile + 1UL);
            }
          }
        }
#line 285
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 287
      if ((unsigned long )z == (unsigned long )((void *)0)) {
        {
#line 289
        tmp___0 = __errno_location();
#line 289
        qglobal->ierrno = *tmp___0;
        }
#line 290
        return (4356);
      }
      {
#line 294
      iret = _uuconf_iadd_string(qglobal, z, ! fallocated, 0, ppz, qglobal->pblock);
      }
#line 296
      if (iret != 0) {
#line 297
        return (iret);
      }
#line 280
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 301
  return (0);
}
}
#line 308 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
static int itunknown(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  struct sunknown **pq ;
  struct sunknown *q ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 316
  qglobal = (struct sglobal *)pglobal;
#line 317
  pq = (struct sunknown **)pvar;
#line 320
  tmp = uuconf_malloc(qglobal->pblock, sizeof(struct sunknown ));
#line 320
  q = (struct sunknown *)tmp;
  }
#line 322
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 324
    tmp___0 = __errno_location();
#line 324
    qglobal->ierrno = *tmp___0;
    }
#line 325
    return (4356);
  }
  {
#line 329
  q->qnext = (struct sunknown *)((void *)0);
#line 330
  q->ilineno = qglobal->ilineno;
#line 331
  q->cargs = argc - 1;
#line 332
  tmp___1 = uuconf_malloc(qglobal->pblock, (unsigned long )(argc - 1) * sizeof(char *));
#line 332
  q->pzargs = (char **)tmp___1;
  }
#line 334
  if ((unsigned long )q->pzargs == (unsigned long )((void *)0)) {
    {
#line 336
    tmp___2 = __errno_location();
#line 336
    qglobal->ierrno = *tmp___2;
    }
#line 337
    return (4356);
  }
  {
#line 341
  memcpy((void */* __restrict  */)((pointer )q->pzargs), (void const   */* __restrict  */)((pointer )(argv + 1)),
         (unsigned long )(argc - 1) * sizeof(char *));
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 344
      goto while_break;
    }
#line 345
    pq = & (*pq)->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  *pq = q;
#line 349
  return (2048);
}
}
#line 357 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
static int itprogram(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo___0 *qinfo ;
  int tmp ;
  int tmp___0 ;

  {
#line 365
  qglobal = (struct sglobal *)pglobal;
#line 366
  qinfo = (struct sinfo___0 *)pinfo;
#line 368
  if (argc <= 1) {
#line 370
    return (0);
  } else {
    {
#line 368
    tmp = strcasecmp(qinfo->zname, (char const   *)*(argv + 0));
    }
#line 368
    if (tmp != 0) {
#line 370
      return (0);
    }
  }
  {
#line 372
  tmp___0 = uuconf_cmd_args(pglobal, argc - 1, argv + 1, (struct uuconf_cmdtab  const  *)qinfo->qcmds,
                            (void *)0, (int (*)(void *uuconf_pglobal , int uuconf_argc ,
                                                char **uuconf_argv , void *uuconf_pvar ,
                                                void *uuconf_pinfo ))((void *)0),
                            0, qglobal->pblock);
  }
#line 372
  return (tmp___0);
}
}
#line 380 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
static int itset_default(struct sglobal *qglobal , char ***ppzvar , char const   *zfile ) 
{ 
  size_t clen ;
  char *zadd ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 389
  if ((unsigned long )*ppzvar != (unsigned long )((void *)0)) {
#line 390
    return (0);
  }
  {
#line 392
  clen = strlen(zfile);
#line 393
  tmp = uuconf_malloc(qglobal->pblock, sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp") + clen);
#line 393
  zadd = (char *)tmp;
  }
#line 395
  if ((unsigned long )zadd == (unsigned long )((void *)0)) {
    {
#line 397
    tmp___0 = __errno_location();
#line 397
    qglobal->ierrno = *tmp___0;
    }
#line 398
    return (260);
  }
  {
#line 401
  memcpy((void */* __restrict  */)((pointer )zadd), (void const   */* __restrict  */)((pointer )"/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp"),
         sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp") - 1UL);
#line 402
  memcpy((void */* __restrict  */)((pointer )((zadd + sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp")) - 1)),
         (void const   */* __restrict  */)((pointer )zfile), clen + 1UL);
#line 405
  tmp___1 = _uuconf_iadd_string(qglobal, zadd, 0, 0, ppzvar, qglobal->pblock);
  }
#line 405
  return (tmp___1);
}
}
#line 415 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tinit.c"
int _uuconf_idebug_cmd(struct sglobal *qglobal , char **pzdebug , int argc , char **argv ,
                       pointer pblock ) 
{ 
  size_t cdebug ;
  int i ;
  char *zdebug ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  size_t clen ;

  {
#line 423
  if (argc == 1) {
#line 425
    *pzdebug = (char *)((void *)0);
#line 426
    return (0);
  } else
#line 428
  if (argc == 2) {
#line 430
    *pzdebug = *(argv + 1);
#line 431
    return (2048);
  } else {
#line 439
    cdebug = (size_t )0;
#line 440
    i = 1;
    {
#line 440
    while (1) {
      while_continue: /* CIL Label */ ;
#line 440
      if (! (i < argc)) {
#line 440
        goto while_break;
      }
      {
#line 441
      tmp = strlen((char const   *)*(argv + i));
#line 441
      cdebug += tmp + 1UL;
#line 440
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 442
    tmp___0 = uuconf_malloc(pblock, cdebug);
#line 442
    zdebug = (char *)tmp___0;
    }
#line 443
    if ((unsigned long )zdebug == (unsigned long )((void *)0)) {
      {
#line 445
      tmp___1 = __errno_location();
#line 445
      qglobal->ierrno = *tmp___1;
      }
#line 446
      return (4356);
    }
#line 450
    cdebug = (size_t )0;
#line 451
    i = 1;
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! (i < argc)) {
#line 451
        goto while_break___0;
      }
      {
#line 455
      clen = strlen((char const   *)*(argv + i));
#line 456
      memcpy((void */* __restrict  */)(zdebug + cdebug), (void const   */* __restrict  */)*(argv + i),
             clen);
#line 457
      *(zdebug + (cdebug + clen)) = (char )' ';
#line 458
      cdebug += clen + 1UL;
#line 451
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    *(zdebug + (cdebug - 1UL)) = (char )'\000';
#line 461
    *pzdebug = zdebug;
#line 462
    return (0);
  }
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
char const   _uuconf_time_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'i',      (char const   )'m', 
        (char const   )'e',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'1',      (char const   )'4',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'3',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 34 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
static int itadd_span(struct sglobal *qglobal , int istart , int iend , long ival ,
                      int cretry , int (*picmp)(long  , long  ) , struct uuconf_timespan **pqspan ,
                      pointer pblock ) ;
#line 39
static int itnew(struct sglobal *qglobal , struct uuconf_timespan **pqset , struct uuconf_timespan *qnext ,
                 int istart , int iend , long ival , int cretry , pointer pblock ) ;
#line 46 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
static struct __anonstruct_asTdays_44  const  asTdays[12]  = 
#line 46
  {      {"any", 0, 6}, 
        {"wk", 1, 5}, 
        {"su", 0, 0}, 
        {"mo", 1, 1}, 
        {"tu", 2, 2}, 
        {"we", 3, 3}, 
        {"th", 4, 4}, 
        {"fr", 5, 5}, 
        {"sa", 6, 6}, 
        {"never", -1, -2}, 
        {"none", -1, -2}, 
        {(char const   *)((void *)0), 0, 0}};
#line 71 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
int _uuconf_itime_parse(struct sglobal *qglobal , char *ztime , long ival , int cretry ,
                        int (*picmp)(long  , long  ) , struct uuconf_timespan **pqspan ,
                        pointer pblock ) 
{ 
  struct uuconf_timespan *qlist ;
  char bfirst ;
  char const   *z ;
  char **pz ;
  char *zfound ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int iday ;
  boolean afday[7] ;
  int istart ;
  int iend ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t clen ;
  int iset ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *zendnum ;
  long tmp___8 ;
  unsigned short const   **tmp___9 ;
  long tmp___10 ;
  unsigned short const   **tmp___11 ;
  int iminute ;
  int iret ;
  void *__cil_tmp35 ;

  {
#line 85
  qlist = *pqspan;
#line 86
  if ((unsigned long )qlist == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 87
    qlist = (struct uuconf_timespan *)((void *)0);
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    bfirst = *ztime;
#line 97
    tmp___0 = __ctype_b_loc();
    }
#line 97
    if ((int const   )*(*tmp___0 + (int )((unsigned char )bfirst)) & 256) {
      {
#line 98
      tmp = tolower((int )((unsigned char )bfirst));
#line 98
      bfirst = (char )tmp;
      }
    }
#line 100
    zfound = (char *)((void *)0);
#line 101
    pz = (qglobal->qprocess)->pztimetables;
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 105
        goto while_break___0;
      }
#line 107
      if ((int )bfirst == (int )*(*pz + 0)) {
#line 107
        goto _L;
      } else {
        {
#line 107
        tmp___1 = __ctype_b_loc();
        }
#line 107
        if ((int const   )*(*tmp___1 + (int )((unsigned char )*(*pz + 0))) & 256) {
          {
#line 107
          tmp___2 = tolower((int )((unsigned char )*(*pz + 0)));
          }
#line 107
          if ((int )bfirst == tmp___2) {
            _L: /* CIL Label */ 
            {
#line 107
            tmp___3 = strcasecmp((char const   *)ztime, (char const   *)*pz);
            }
#line 107
            if (tmp___3 == 0) {
#line 111
              zfound = *(pz + 1);
            }
          }
        }
      }
#line 112
      pz += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    if ((unsigned long )zfound == (unsigned long )((void *)0)) {
#line 115
      goto while_break;
    }
#line 116
    ztime = zfound;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  z = (char const   *)ztime;
  {
#line 121
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 121
    if (! ((int const   )*z != 0)) {
#line 121
      goto while_break___1;
    }
#line 127
    if ((int const   )*z == 44) {
#line 128
      z ++;
    } else
#line 127
    if ((int const   )*z == 124) {
#line 128
      z ++;
    }
#line 129
    if ((int const   )*z == 0) {
#line 130
      goto while_break___1;
    } else
#line 129
    if ((int const   )*z == 59) {
#line 130
      goto while_break___1;
    }
#line 132
    iday = 0;
    {
#line 132
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 132
      if (! (iday < 7)) {
#line 132
        goto while_break___2;
      }
#line 133
      afday[iday] = 0;
#line 132
      iday ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 136
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 138
      bfirst = (char )*z;
#line 139
      tmp___5 = __ctype_b_loc();
      }
#line 139
      if ((int const   )*(*tmp___5 + (int )((unsigned char )bfirst)) & 256) {
        {
#line 140
        tmp___4 = tolower((int )((unsigned char )bfirst));
#line 140
        bfirst = (char )tmp___4;
        }
      }
#line 141
      iday = 0;
      {
#line 141
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 141
        if (! ((unsigned long )asTdays[iday].zname != (unsigned long )((void *)0))) {
#line 141
          goto while_break___4;
        }
#line 145
        if ((int )bfirst != (int )*(asTdays[iday].zname + 0)) {
#line 146
          goto __Cont;
        }
        {
#line 148
        clen = strlen((char const   *)asTdays[iday].zname);
#line 149
        tmp___6 = strncasecmp(z, (char const   *)asTdays[iday].zname, clen);
        }
#line 149
        if (tmp___6 == 0) {
#line 153
          iset = (int )asTdays[iday].imin;
          {
#line 153
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 153
            if (! (iset <= (int )asTdays[iday].imax)) {
#line 153
              goto while_break___5;
            }
#line 156
            afday[iset] = 1;
#line 153
            iset ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 157
          z += clen;
#line 158
          goto while_break___4;
        }
        __Cont: /* CIL Label */ 
#line 141
        iday ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 161
      if ((unsigned long )asTdays[iday].zname == (unsigned long )((void *)0)) {
#line 162
        return (5);
      }
      {
#line 136
      tmp___7 = __ctype_b_loc();
      }
#line 136
      if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*z)) & 1024)) {
#line 136
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 167
    tmp___11 = __ctype_b_loc();
    }
#line 167
    if ((int const   )*(*tmp___11 + (int )((unsigned char )*z)) & 2048) {
      {
#line 176
      tmp___8 = strtol((char const   */* __restrict  */)((char *)z), (char **/* __restrict  */)(& zendnum),
                       10);
#line 176
      istart = (int )tmp___8;
      }
#line 177
      if ((int )*zendnum != 45) {
#line 178
        return (5);
      } else {
        {
#line 177
        tmp___9 = __ctype_b_loc();
        }
#line 177
        if (! ((int const   )*(*tmp___9 + (int )((unsigned char )*(zendnum + 1))) & 2048)) {
#line 178
          return (5);
        }
      }
      {
#line 179
      z = (char const   *)(zendnum + 1);
#line 180
      tmp___10 = strtol((char const   */* __restrict  */)((char *)z), (char **/* __restrict  */)(& zendnum),
                        10);
#line 180
      iend = (int )tmp___10;
#line 181
      z = (char const   *)zendnum;
#line 183
      istart = (istart / 100) * 60 + istart % 100;
#line 184
      iend = (iend / 100) * 60 + iend % 100;
      }
    } else {
#line 169
      istart = 0;
#line 170
      iend = 1440;
    }
#line 188
    iday = 0;
    {
#line 188
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 188
      if (! (iday < 7)) {
#line 188
        goto while_break___6;
      }
#line 190
      if (afday[iday]) {
#line 194
        iminute = (iday * 24) * 60;
#line 195
        if (istart < iend) {
          {
#line 196
          iret = itadd_span(qglobal, iminute + istart, iminute + iend, ival, cretry,
                            picmp, & qlist, pblock);
          }
        } else {
          {
#line 202
          iret = itadd_span(qglobal, iminute, iminute + iend, ival, cretry, picmp,
                            & qlist, pblock);
          }
#line 204
          if (iret == 0) {
            {
#line 205
            iret = itadd_span(qglobal, iminute + istart, iminute + 1440, ival, cretry,
                              picmp, & qlist, pblock);
            }
          }
        }
#line 210
        if (iret != 0) {
#line 211
          return (iret);
        }
      }
#line 188
      iday ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 216
  *pqspan = qlist;
#line 218
  return (0);
}
}
#line 229 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
static int itadd_span(struct sglobal *qglobal , int istart , int iend , long ival ,
                      int cretry , int (*picmp)(long  , long  ) , struct uuconf_timespan **pqspan ,
                      pointer pblock ) 
{ 
  struct uuconf_timespan **pq ;
  int iret ;
  int icmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 244
  pq = pqspan;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 244
      goto while_break;
    }
#line 251
    if (iend <= (*pq)->uuconf_istart) {
#line 256
      if (iend == (*pq)->uuconf_istart) {
#line 256
        if (cretry == (*pq)->uuconf_cretry) {
          {
#line 256
          tmp = (*picmp)(ival, (*pq)->uuconf_ival);
          }
#line 256
          if (tmp == 0) {
#line 260
            (*pq)->uuconf_istart = istart;
#line 261
            return (0);
          }
        }
      }
#line 264
      goto while_break;
    }
#line 267
    if ((*pq)->uuconf_iend <= istart) {
#line 271
      if ((*pq)->uuconf_iend == istart) {
#line 271
        if ((*pq)->uuconf_cretry == cretry) {
#line 271
          if ((unsigned long )(*pq)->uuconf_qnext == (unsigned long )((void *)0)) {
#line 271
            goto _L;
          } else
#line 271
          if (iend <= ((*pq)->uuconf_qnext)->uuconf_istart) {
            _L: /* CIL Label */ 
            {
#line 271
            tmp___0 = (*picmp)(ival, (*pq)->uuconf_ival);
            }
#line 271
            if (tmp___0 == 0) {
#line 277
              (*pq)->uuconf_iend = iend;
#line 278
              return (0);
            }
          }
        }
      }
#line 283
      goto __Cont;
    }
    {
#line 292
    icmp = (*picmp)(ival, (*pq)->uuconf_ival);
    }
#line 294
    if (icmp == 0) {
#line 297
      if (istart < (*pq)->uuconf_istart) {
#line 298
        (*pq)->uuconf_istart = istart;
      }
#line 299
      if ((*pq)->uuconf_iend >= iend) {
#line 300
        return (0);
      }
#line 301
      if ((unsigned long )(*pq)->uuconf_qnext == (unsigned long )((void *)0)) {
#line 304
        (*pq)->uuconf_iend = iend;
#line 305
        return (0);
      } else
#line 301
      if (iend <= ((*pq)->uuconf_qnext)->uuconf_istart) {
#line 304
        (*pq)->uuconf_iend = iend;
#line 305
        return (0);
      }
#line 310
      (*pq)->uuconf_iend = ((*pq)->uuconf_qnext)->uuconf_istart;
#line 311
      istart = (*pq)->uuconf_iend;
    } else
#line 313
    if (icmp < 0) {
#line 316
      if ((*pq)->uuconf_istart < istart) {
        {
#line 319
        iret = itnew(qglobal, pq, *pq, (*pq)->uuconf_istart, istart, (*pq)->uuconf_ival,
                     (*pq)->uuconf_cretry, pblock);
        }
#line 322
        if (iret != 0) {
#line 323
          return (iret);
        }
#line 324
        pq = & (*pq)->uuconf_qnext;
      }
#line 326
      if (iend < (*pq)->uuconf_iend) {
        {
#line 329
        iret = itnew(qglobal, & (*pq)->uuconf_qnext, (*pq)->uuconf_qnext, iend, (*pq)->uuconf_iend,
                     (*pq)->uuconf_ival, (*pq)->uuconf_cretry, pblock);
        }
#line 333
        if (iret != 0) {
#line 334
          return (iret);
        }
      }
#line 336
      (*pq)->uuconf_ival = ival;
#line 337
      (*pq)->uuconf_istart = istart;
#line 338
      (*pq)->uuconf_cretry = cretry;
#line 339
      if ((unsigned long )(*pq)->uuconf_qnext == (unsigned long )((void *)0)) {
#line 342
        (*pq)->uuconf_iend = iend;
#line 343
        return (0);
      } else
#line 339
      if (iend <= ((*pq)->uuconf_qnext)->uuconf_istart) {
#line 342
        (*pq)->uuconf_iend = iend;
#line 343
        return (0);
      }
#line 347
      (*pq)->uuconf_iend = ((*pq)->uuconf_qnext)->uuconf_istart;
#line 348
      istart = (*pq)->uuconf_iend;
    } else {
#line 353
      if (istart < (*pq)->uuconf_istart) {
        {
#line 356
        iret = itnew(qglobal, pq, *pq, istart, (*pq)->uuconf_istart, ival, cretry,
                     pblock);
        }
#line 358
        if (iret != 0) {
#line 359
          return (iret);
        }
#line 360
        pq = & (*pq)->uuconf_qnext;
      }
#line 362
      if (iend <= (*pq)->uuconf_iend) {
#line 363
        return (0);
      }
#line 365
      istart = (*pq)->uuconf_iend;
    }
    __Cont: /* CIL Label */ 
#line 244
    pq = & (*pq)->uuconf_qnext;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  tmp___1 = itnew(qglobal, pq, *pq, istart, iend, ival, cretry, pblock);
  }
#line 371
  return (tmp___1);
}
}
#line 376 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/time.c"
static int itnew(struct sglobal *qglobal , struct uuconf_timespan **pqset , struct uuconf_timespan *qnext ,
                 int istart , int iend , long ival , int cretry , pointer pblock ) 
{ 
  register struct uuconf_timespan *qnew ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 389
  tmp = uuconf_malloc(pblock, sizeof(struct uuconf_timespan ));
#line 389
  qnew = (struct uuconf_timespan *)tmp;
  }
#line 391
  if ((unsigned long )qnew == (unsigned long )((void *)0)) {
    {
#line 393
    tmp___0 = __errno_location();
#line 393
    qglobal->ierrno = *tmp___0;
    }
#line 394
    return (260);
  }
#line 397
  qnew->uuconf_qnext = qnext;
#line 398
  qnew->uuconf_istart = istart;
#line 399
  qnew->uuconf_iend = iend;
#line 400
  qnew->uuconf_ival = ival;
#line 401
  qnew->uuconf_cretry = cretry;
#line 403
  *pqset = qnew;
#line 405
  return (0);
}
}
#line 745 "../uuconf.h"
int uuconf_init_thread(void **ppglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/thread.c"
char const   _uuconf_thread_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/thread.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'r', 
        (char const   )'e',      (char const   )'a',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/thread.c"
int uuconf_init_thread(void **ppglobal ) 
{ 
  struct sglobal **pqglob ;
  pointer pblock ;
  struct sglobal *qnew ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 40
  pqglob = (struct sglobal **)ppglobal;
#line 44
  pblock = uuconf_malloc_block();
  }
#line 45
  if ((unsigned long )pblock == (unsigned long )((void *)0)) {
    {
#line 47
    tmp = __errno_location();
#line 47
    (*pqglob)->ierrno = *tmp;
    }
#line 48
    return (260);
  }
  {
#line 51
  tmp___0 = uuconf_malloc(pblock, sizeof(struct sglobal ));
#line 51
  qnew = (struct sglobal *)tmp___0;
  }
#line 53
  if ((unsigned long )qnew == (unsigned long )((void *)0)) {
    {
#line 55
    tmp___1 = __errno_location();
#line 55
    (*pqglob)->ierrno = *tmp___1;
#line 56
    uuconf_free_block(pblock);
    }
#line 57
    return (260);
  }
#line 60
  qnew->pblock = pblock;
#line 61
  qnew->ierrno = 0;
#line 62
  qnew->ilineno = 0;
#line 63
  qnew->zfilename = (char const   *)((void *)0);
#line 64
  qnew->qprocess = (*pqglob)->qprocess;
#line 66
  *pqglob = qnew;
#line 68
  return (0);
}
}
#line 1004 "../uuconf.h"
int uuconf_grade_cmp(int barg1 , int barg2 ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tgcmp.c"
char const   _uuconf_tgcmp_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tgcmp.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'g',      (char const   )'c', 
        (char const   )'m',      (char const   )'p',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'3',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tgcmp.c"
int _uuconf_itime_grade_cmp(long i1 , long i2 ) 
{ 
  int tmp ;

  {
  {
#line 40
  tmp = uuconf_grade_cmp((int )i1, (int )i2);
  }
#line 40
  return (tmp);
}
}
#line 1110 "../uuconf.h"
int uuconf_taylor_dialer_names(void *pglobal , char ***ppzdialers ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdnams.c"
char const   _uuconf_tdnams_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdnams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'d',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33
static int indialer(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                    pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdnams.c"
int uuconf_taylor_dialer_names(void *pglobal , char ***ppzdialers ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_cmdtab as[2] ;
  char **pz ;
  int iret ;
  FILE *e ;
  int *tmp ;
  int *tmp___0 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 44
  qglobal = (struct sglobal *)pglobal;
#line 49
  *ppzdialers = (char **)((void *)0);
#line 51
  as[0].uuconf_zcmd = "dialer";
#line 52
  as[0].uuconf_itype = 98;
#line 53
  as[0].uuconf_pvar = (pointer )ppzdialers;
#line 54
  as[0].uuconf_pifn = & indialer;
#line 56
  as[1].uuconf_zcmd = (char const   *)((void *)0);
#line 58
  iret = 0;
#line 60
  pz = (qglobal->qprocess)->pzdialfiles;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 60
      goto while_break;
    }
    {
#line 64
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 65
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 67
      tmp = __errno_location();
      }
#line 67
      if (*tmp == 2) {
#line 68
        goto __Cont;
      }
      {
#line 69
      tmp___0 = __errno_location();
#line 69
      qglobal->ierrno = *tmp___0;
#line 70
      iret = 258;
      }
#line 71
      goto while_break;
    }
    {
#line 74
    iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (void *)0,
                           (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                                    void *uuconf_pvar , void *uuconf_pinfo ))((void *)0),
                           2, (void *)0);
#line 79
    fclose(e);
    }
#line 81
    if (iret != 0) {
#line 82
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 60
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (iret != 0) {
#line 87
    qglobal->zfilename = (char const   *)*pz;
#line 88
    return (iret | 512);
  }
#line 91
  if ((unsigned long )*ppzdialers == (unsigned long )((void *)0)) {
    {
#line 92
    iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzdialers, (void *)0);
    }
  }
#line 95
  return (0);
}
}
#line 101 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdnams.c"
static int indialer(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                    pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char ***ppzdialers ;
  int iret ;

  {
  {
#line 109
  qglobal = (struct sglobal *)pglobal;
#line 110
  ppzdialers = (char ***)pvar;
#line 113
  iret = _uuconf_iadd_string(qglobal, *(argv + 1), 1, 1, ppzdialers, (void *)0);
  }
#line 115
  if (iret != 0) {
#line 116
    iret |= 4096;
  }
#line 117
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
char const   _uuconf_tdialc_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'d',      (char const   )'i', 
        (char const   )'a',      (char const   )'l',      (char const   )'c',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'3',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 31
static int idchat(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 33
static int iddtr_toggle(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                        pointer pinfo ) ;
#line 35
static int idcomplete(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                      pointer pvar , pointer pinfo ) ;
#line 37
static int idproto_param(pointer pglobal , int argc , char **argv , pointer pvar ,
                         pointer pinfo ) ;
#line 39
static int idcunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                      char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                      pointer pinfo  __attribute__((__unused__)) ) ;
#line 44 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
static struct cmdtab_offset  const  asDialer_cmds[15]  = 
#line 44
  {      {"chat", 112, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_schat),
      & idchat}, 
        {"dialtone", 64, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_zdialtone),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"pause", 64, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_zpause),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"carrier", 18, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_fcarrier),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"carrier-wait", 34, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_ccarrier_wait),
      (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv , void *uuconf_pvar ,
               void *uuconf_pinfo ))((void *)0)}, 
        {"dtr-toggle", 96, (size_t )-1, & iddtr_toggle}, 
        {"complete", 98, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_scomplete),
      & idcomplete}, 
        {"complete-chat", 112, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_scomplete),
      & idchat}, 
        {"abort", 98, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_sabort),
      & idcomplete}, 
        {"abort-chat", 112, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_sabort),
      & idchat}, 
        {"protocol-parameter", 96, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_qproto_params),
      & idproto_param}, 
        {"seven-bit", 98, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_ireliable),
      & _uuconf_iseven_bit}, 
        {"reliable", 98, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_ireliable),
      & _uuconf_ireliable}, 
        {"half-duplex", 98, (unsigned long )(& ((struct uuconf_dialer *)0)->uuconf_ireliable),
      & _uuconf_ihalf_duplex}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 87 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
int _uuconf_idialer_cmd(struct sglobal *qglobal , int argc , char **argv , struct uuconf_dialer *qdialer ) 
{ 
  struct uuconf_cmdtab as[sizeof(asDialer_cmds) / sizeof(asDialer_cmds[0])] ;
  int iret ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 97
  _uuconf_ucmdtab_base(asDialer_cmds, sizeof(asDialer_cmds) / sizeof(asDialer_cmds[0]),
                       (char *)qdialer, as);
#line 99
  iret = uuconf_cmd_args((pointer )qglobal, argc, argv, (struct uuconf_cmdtab  const  *)(as),
                         (pointer )qdialer, & idcunknown, 0, qdialer->uuconf_palloc);
  }
#line 103
  return (iret & -4097);
}
}
#line 108 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
static int idchat(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_chat *qchat ;
  struct uuconf_dialer *qdialer ;
  int tmp ;

  {
  {
#line 116
  qglobal = (struct sglobal *)pglobal;
#line 117
  qchat = (struct uuconf_chat *)pvar;
#line 118
  qdialer = (struct uuconf_dialer *)pinfo;
#line 120
  tmp = _uuconf_ichat_cmd(qglobal, argc, argv, qchat, qdialer->uuconf_palloc);
  }
#line 120
  return (tmp);
}
}
#line 127 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
static int iddtr_toggle(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                        pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_dialer *qdialer ;
  int iret ;
  int tmp ;

  {
#line 135
  qglobal = (struct sglobal *)pglobal;
#line 136
  qdialer = (struct uuconf_dialer *)pinfo;
#line 139
  if (argc < 2) {
#line 140
    return (4101);
  } else
#line 139
  if (argc > 3) {
#line 140
    return (4101);
  }
  {
#line 142
  iret = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & qdialer->uuconf_fdtr_toggle);
  }
#line 143
  if ((iret & -2049) != 0) {
#line 144
    return (iret);
  }
#line 146
  if (argc < 3) {
#line 147
    return (iret);
  }
  {
#line 149
  tmp = _uuconf_iboolean(qglobal, (char const   *)*(argv + 2), & qdialer->uuconf_fdtr_toggle_wait);
#line 149
  iret |= tmp;
  }
#line 152
  return (iret);
}
}
#line 159 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
static int idcomplete(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                      pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_chat *qchat ;
  struct uuconf_dialer *qdialer ;
  char *azargs[3] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 167
  qglobal = (struct sglobal *)pglobal;
#line 168
  qchat = (struct uuconf_chat *)pvar;
#line 169
  qdialer = (struct uuconf_dialer *)pinfo;
#line 172
  azargs[0] = (char *)"complete-chat";
#line 173
  azargs[1] = (char *)"\"\"";
#line 174
  azargs[2] = *(argv + 1);
#line 176
  tmp = _uuconf_ichat_cmd(qglobal, 3, azargs, qchat, qdialer->uuconf_palloc);
  }
#line 176
  return (tmp);
}
}
#line 182 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
static int idproto_param(pointer pglobal , int argc , char **argv , pointer pvar ,
                         pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_proto_param **pqparam ;
  struct uuconf_dialer *qdialer ;
  int tmp ;

  {
  {
#line 190
  qglobal = (struct sglobal *)pglobal;
#line 191
  pqparam = (struct uuconf_proto_param **)pvar;
#line 192
  qdialer = (struct uuconf_dialer *)pinfo;
#line 194
  tmp = _uuconf_iadd_proto_param(qglobal, argc - 1, argv + 1, pqparam, qdialer->uuconf_palloc);
  }
#line 194
  return (tmp);
}
}
#line 201 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdialc.c"
static int idcunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                      char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                      pointer pinfo  __attribute__((__unused__)) ) 
{ 


  {
#line 209
  return (4101);
}
}
#line 1115 "../uuconf.h"
int uuconf_taylor_dialer_info(void *pglobal , char const   *zname , struct uuconf_dialer *qdialer ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdial.c"
char const   _uuconf_tdial_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdial.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'d',      (char const   )'i', 
        (char const   )'a',      (char const   )'l',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'9',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'3',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33
static int iddialer(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                    pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 35
static int idunknown(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) ;
#line 40 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdial.c"
int uuconf_taylor_dialer_info(void *pglobal , char const   *zname , struct uuconf_dialer *qdialer ) 
{ 
  struct sglobal *qglobal ;
  FILE *e ;
  pointer pblock ;
  int iret ;
  char **pz ;
  struct uuconf_cmdtab as[2] ;
  char *zdialer ;
  struct uuconf_dialer sdefault ;
  int ilineno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  size_t csize ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 46
  qglobal = (struct sglobal *)pglobal;
#line 52
  e = (FILE *)((void *)0);
#line 53
  pblock = (void *)0;
#line 54
  iret = 1;
#line 56
  pz = (qglobal->qprocess)->pzdialfiles;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 56
      goto while_break;
    }
    {
#line 63
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 64
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 66
      tmp = __errno_location();
      }
#line 66
      if (*tmp == 2) {
#line 67
        goto __Cont;
      }
      {
#line 68
      tmp___0 = __errno_location();
#line 68
      qglobal->ierrno = *tmp___0;
#line 69
      iret = 258;
      }
#line 70
      goto while_break;
    }
    {
#line 73
    qglobal->ilineno = 0;
#line 79
    as[0].uuconf_zcmd = "dialer";
#line 80
    as[0].uuconf_itype = 98;
#line 81
    as[0].uuconf_pvar = (pointer )(& zdialer);
#line 82
    as[0].uuconf_pifn = & iddialer;
#line 84
    as[1].uuconf_zcmd = (char const   *)((void *)0);
#line 86
    pblock = uuconf_malloc_block();
    }
#line 87
    if ((unsigned long )pblock == (unsigned long )((void *)0)) {
      {
#line 89
      tmp___1 = __errno_location();
#line 89
      qglobal->ierrno = *tmp___1;
#line 90
      iret = 260;
      }
#line 91
      goto while_break;
    }
    {
#line 94
    _uuconf_uclear_dialer(& sdefault);
#line 95
    sdefault.uuconf_palloc = pblock;
#line 96
    zdialer = (char *)((void *)0);
#line 97
    iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (pointer )(& sdefault),
                           & idunknown, 2, pblock);
    }
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if (iret == 0) {
#line 102
        if ((unsigned long )zdialer != (unsigned long )((void *)0)) {
          {
#line 102
          tmp___2 = strcmp(zname, (char const   *)zdialer);
          }
#line 102
          if (! (tmp___2 != 0)) {
#line 102
            goto while_break___0;
          }
        } else {
#line 102
          goto while_break___0;
        }
      } else {
#line 102
        goto while_break___0;
      }
      {
#line 106
      free((pointer )zdialer);
#line 107
      zdialer = (char *)((void *)0);
#line 108
      ilineno = qglobal->ilineno;
#line 109
      iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (void *)0,
                             (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                                      void *uuconf_pvar , void *uuconf_pinfo ))((void *)0),
                             2, pblock);
#line 113
      qglobal->ilineno += ilineno;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    if (iret != 0) {
#line 118
      if ((unsigned long )zdialer != (unsigned long )((void *)0)) {
        {
#line 119
        free((pointer )zdialer);
        }
      }
#line 120
      goto while_break;
    }
#line 123
    if ((unsigned long )zdialer != (unsigned long )((void *)0)) {
      {
#line 129
      as[0].uuconf_pvar = (void *)0;
#line 131
      *qdialer = sdefault;
#line 132
      tmp___3 = strlen((char const   *)zdialer);
#line 132
      csize = tmp___3 + 1UL;
#line 133
      tmp___4 = uuconf_malloc(pblock, csize);
#line 133
      qdialer->uuconf_zname = (char *)tmp___4;
      }
#line 134
      if ((unsigned long )qdialer->uuconf_zname == (unsigned long )((void *)0)) {
        {
#line 136
        tmp___5 = __errno_location();
#line 136
        qglobal->ierrno = *tmp___5;
#line 137
        free((pointer )zdialer);
#line 138
        iret = 260;
        }
#line 139
        goto while_break;
      }
      {
#line 141
      memcpy((void */* __restrict  */)((pointer )qdialer->uuconf_zname), (void const   */* __restrict  */)((pointer )zdialer),
             csize);
#line 143
      free((pointer )zdialer);
#line 145
      ilineno = qglobal->ilineno;
#line 146
      iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (void *)qdialer,
                             & idunknown, 2, pblock);
#line 148
      qglobal->ilineno += ilineno;
      }
#line 149
      goto while_break;
    }
    {
#line 152
    fclose(e);
#line 153
    e = (FILE *)((void *)0);
#line 154
    uuconf_free_block(pblock);
#line 155
    pblock = (void *)0;
#line 157
    iret = 1;
    }
    __Cont: /* CIL Label */ 
#line 56
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )e != (unsigned long )((void *)0)) {
    {
#line 161
    fclose(e);
    }
  }
#line 162
  if (iret != 0) {
#line 162
    if ((unsigned long )pblock != (unsigned long )((void *)0)) {
      {
#line 163
      uuconf_free_block(pblock);
      }
    }
  }
#line 165
  if (iret != 0) {
#line 165
    if (iret != 1) {
#line 167
      qglobal->zfilename = (char const   *)*pz;
#line 168
      iret |= 512;
    }
  }
#line 171
  return (iret);
}
}
#line 181 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdial.c"
static int iddialer(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                    pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char **pz ;
  size_t csize ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 189
  qglobal = (struct sglobal *)pglobal;
#line 190
  pz = (char **)pvar;
#line 192
  if ((unsigned long )pz != (unsigned long )((void *)0)) {
    {
#line 196
    tmp = strlen((char const   *)*(argv + 1));
#line 196
    csize = tmp + 1UL;
#line 197
    tmp___0 = malloc(csize);
#line 197
    *pz = (char *)tmp___0;
    }
#line 198
    if ((unsigned long )*pz == (unsigned long )((void *)0)) {
      {
#line 200
      tmp___1 = __errno_location();
#line 200
      qglobal->ierrno = *tmp___1;
      }
#line 201
      return (4356);
    }
    {
#line 205
    memcpy((void */* __restrict  */)((pointer )*pz), (void const   */* __restrict  */)((pointer )*(argv + 1)),
           csize);
    }
  }
#line 207
  return (4096);
}
}
#line 214 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tdial.c"
static int idunknown(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_dialer *qdialer ;
  int tmp ;

  {
  {
#line 222
  qglobal = (struct sglobal *)pglobal;
#line 223
  qdialer = (struct uuconf_dialer *)pinfo;
#line 225
  tmp = _uuconf_idialer_cmd(qglobal, argc, argv, qdialer);
  }
#line 225
  return (tmp);
}
}
#line 1132 "../uuconf.h"
int uuconf_taylor_callout(void *pglobal , struct uuconf_system  const  *qsys , char **pzlog ,
                          char **pzpass ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tcalou.c"
char const   _uuconf_tcalou_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tcalou.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'c',      (char const   )'a', 
        (char const   )'l',      (char const   )'o',      (char const   )'u',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33
static int icsys(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tcalou.c"
int uuconf_taylor_callout(void *pglobal , struct uuconf_system  const  *qsys , char **pzlog ,
                          char **pzpass ) 
{ 
  struct sglobal *qglobal ;
  boolean flookup ;
  struct uuconf_cmdtab as[2] ;
  char **pz ;
  int iret ;
  pointer pinfo ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  FILE *e ;
  int *tmp___3 ;
  int *tmp___4 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 46
  qglobal = (struct sglobal *)pglobal;
#line 53
  *pzlog = (char *)((void *)0);
#line 54
  *pzpass = (char *)((void *)0);
#line 56
  flookup = 0;
#line 58
  if ((unsigned long )qsys->uuconf_zcall_login != (unsigned long )((void *)0)) {
    {
#line 60
    tmp___0 = strcmp((char const   *)qsys->uuconf_zcall_login, "*");
    }
#line 60
    if (tmp___0 == 0) {
#line 61
      flookup = 1;
    } else {
      {
#line 64
      *pzlog = strdup((char const   *)qsys->uuconf_zcall_login);
      }
#line 65
      if ((unsigned long )*pzlog == (unsigned long )((void *)0)) {
        {
#line 67
        tmp = __errno_location();
#line 67
        qglobal->ierrno = *tmp;
        }
#line 68
        return (260);
      }
    }
  }
#line 73
  if ((unsigned long )qsys->uuconf_zcall_password != (unsigned long )((void *)0)) {
    {
#line 75
    tmp___2 = strcmp((char const   *)qsys->uuconf_zcall_password, "*");
    }
#line 75
    if (tmp___2 == 0) {
#line 76
      flookup = 1;
    } else {
      {
#line 79
      *pzpass = strdup((char const   *)qsys->uuconf_zcall_password);
      }
#line 80
      if ((unsigned long )*pzpass == (unsigned long )((void *)0)) {
        {
#line 82
        tmp___1 = __errno_location();
#line 82
        qglobal->ierrno = *tmp___1;
        }
#line 83
        if ((unsigned long )*pzlog != (unsigned long )((void *)0)) {
          {
#line 85
          free((pointer )*pzlog);
#line 86
          *pzlog = (char *)((void *)0);
          }
        }
#line 88
        return (260);
      }
    }
  }
#line 93
  if (! flookup) {
#line 95
    if ((unsigned long )*pzlog == (unsigned long )((void *)0)) {
#line 95
      if ((unsigned long )*pzpass == (unsigned long )((void *)0)) {
#line 96
        return (1);
      }
    }
#line 97
    return (0);
  }
#line 100
  as[0].uuconf_zcmd = (char const   *)qsys->uuconf_zname;
#line 101
  as[0].uuconf_itype = 96;
#line 102
  if ((unsigned long )*pzlog == (unsigned long )((void *)0)) {
#line 103
    as[0].uuconf_pvar = (pointer )pzlog;
  } else {
#line 105
    as[0].uuconf_pvar = (void *)0;
  }
#line 106
  as[0].uuconf_pifn = & icsys;
#line 108
  as[1].uuconf_zcmd = (char const   *)((void *)0);
#line 110
  if ((unsigned long )*pzpass == (unsigned long )((void *)0)) {
#line 111
    pinfo = (pointer )pzpass;
  } else {
#line 113
    pinfo = (void *)0;
  }
#line 115
  iret = 0;
#line 117
  pz = (qglobal->qprocess)->pzcallfiles;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
    {
#line 121
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 122
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 124
      tmp___3 = __errno_location();
      }
#line 124
      if (*tmp___3 == 2) {
#line 125
        goto __Cont;
      }
      {
#line 126
      tmp___4 = __errno_location();
#line 126
      qglobal->ierrno = *tmp___4;
#line 127
      iret = 258;
      }
#line 128
      goto while_break;
    }
    {
#line 131
    iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), pinfo,
                           (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                                    void *uuconf_pvar , void *uuconf_pinfo ))((void *)0),
                           0, (void *)qsys->uuconf_palloc);
#line 134
    fclose(e);
    }
#line 136
    if (iret != 0) {
#line 137
      goto while_break;
    }
#line 138
    if ((unsigned long )*pzlog != (unsigned long )((void *)0)) {
#line 139
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 117
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (iret != 0) {
#line 144
    qglobal->zfilename = (char const   *)*pz;
#line 145
    return (iret | 512);
  }
#line 148
  if ((unsigned long )*pzlog == (unsigned long )((void *)0)) {
#line 148
    if ((unsigned long )*pzpass == (unsigned long )((void *)0)) {
#line 149
      return (1);
    }
  }
#line 151
  return (0);
}
}
#line 158 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/tcalou.c"
static int icsys(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  char **pzlog ;
  char **pzpass ;
  int *tmp ;
  int *tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 166
  qglobal = (struct sglobal *)pglobal;
#line 167
  pzlog = (char **)pvar;
#line 168
  pzpass = (char **)pinfo;
#line 170
  if (argc < 2) {
#line 171
    return (4101);
  } else
#line 170
  if (argc > 3) {
#line 171
    return (4101);
  }
#line 173
  if ((unsigned long )pzlog != (unsigned long )((void *)0)) {
    {
#line 175
    *pzlog = strdup((char const   *)*(argv + 1));
    }
#line 176
    if ((unsigned long )*pzlog == (unsigned long )((void *)0)) {
      {
#line 178
      tmp = __errno_location();
#line 178
      qglobal->ierrno = *tmp;
      }
#line 179
      return (4356);
    }
  }
#line 185
  if ((unsigned long )pzpass != (unsigned long )((void *)0)) {
#line 187
    if (argc < 3) {
      {
#line 188
      *pzpass = strdup("");
      }
    } else {
      {
#line 190
      *pzpass = strdup((char const   *)*(argv + 2));
      }
    }
#line 191
    if ((unsigned long )*pzpass == (unsigned long )((void *)0)) {
      {
#line 193
      tmp___0 = __errno_location();
#line 193
      qglobal->ierrno = *tmp___0;
      }
#line 194
      if ((unsigned long )pzlog != (unsigned long )((void *)0)) {
        {
#line 196
        free((pointer )*pzlog);
#line 197
        *pzlog = (char *)((void *)0);
        }
      }
#line 199
      return (4356);
    }
  }
#line 205
  return (4096);
}
}
#line 1590 "../uuconf.h"
void uuconf_free(void *pblock , void *pbuf ) ;
#line 369 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
pointer _uuconf_pmalloc_block_merge(pointer p1 , pointer p2 ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/syssub.c"
char const   _uuconf_syssub_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/syssub.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'y',      (char const   )'s', 
        (char const   )'s',      (char const   )'u',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'7', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 129 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/syssub.c"
void _uuconf_uclear_system(struct uuconf_system *q ) 
{ 


  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    q->uuconf_zname = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zalternate = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zdebug = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zmax_remote_debug = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zphone = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zcall_login = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zcall_password = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zcalled_login = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zprotocols = (char *)(& _uuconf_unset);
#line 134
    q->uuconf_zpubdir = (char const   *)((char *)(& _uuconf_unset));
#line 134
    q->uuconf_zlocalname = (char *)(& _uuconf_unset);
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    q->uuconf_pzalias = & _uuconf_unset;
#line 137
    q->uuconf_pzlocal_send = & _uuconf_unset;
#line 137
    q->uuconf_pzremote_send = & _uuconf_unset;
#line 137
    q->uuconf_pzlocal_receive = & _uuconf_unset;
#line 137
    q->uuconf_pzremote_receive = & _uuconf_unset;
#line 137
    q->uuconf_pzpath = & _uuconf_unset;
#line 137
    q->uuconf_pzcmds = & _uuconf_unset;
#line 137
    q->uuconf_pzforward_from = & _uuconf_unset;
#line 137
    q->uuconf_pzforward_to = & _uuconf_unset;
#line 137
    q->uuconf_schat.uuconf_pzchat = & _uuconf_unset;
#line 137
    q->uuconf_schat.uuconf_pzprogram = & _uuconf_unset;
#line 137
    q->uuconf_schat.uuconf_pzfail = & _uuconf_unset;
#line 137
    q->uuconf_scalled_chat.uuconf_pzchat = & _uuconf_unset;
#line 137
    q->uuconf_scalled_chat.uuconf_pzprogram = & _uuconf_unset;
#line 137
    q->uuconf_scalled_chat.uuconf_pzfail = & _uuconf_unset;
#line 137
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    q->uuconf_qtimegrade = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    q->uuconf_qcalltimegrade = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    q->uuconf_qcalledtimegrade = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    q->uuconf_qcall_local_size = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    q->uuconf_qcall_remote_size = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    q->uuconf_qcalled_local_size = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    q->uuconf_qcalled_remote_size = (struct uuconf_timespan *)(& _uuconf_unset);
#line 140
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 143
    q->uuconf_fcall = -1;
#line 143
    q->uuconf_fcalled = -1;
#line 143
    q->uuconf_fcallback = -1;
#line 143
    q->uuconf_fsequence = -1;
#line 143
    q->uuconf_fsend_request = -1;
#line 143
    q->uuconf_frec_request = -1;
#line 143
    q->uuconf_fcall_transfer = -1;
#line 143
    q->uuconf_fcalled_transfer = -1;
#line 143
    q->uuconf_schat.uuconf_fstrip = -1;
#line 143
    q->uuconf_scalled_chat.uuconf_fstrip = -1;
#line 143
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 144
    q->uuconf_cmax_retries = -1;
#line 144
    q->uuconf_csuccess_wait = -1;
#line 144
    q->uuconf_ibaud = -1L;
#line 144
    q->uuconf_ihighbaud = -1L;
#line 144
    q->uuconf_cfree_space = -1L;
#line 144
    q->uuconf_schat.uuconf_ctimeout = -1;
#line 144
    q->uuconf_scalled_chat.uuconf_ctimeout = -1;
#line 144
    q->uuconf_cmax_file_time = -1L;
#line 144
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 146
  q->uuconf_qalternate = (struct uuconf_system *)((void *)0);
#line 147
  q->uuconf_zport = (char *)(& _uuconf_unset);
#line 148
  q->uuconf_qport = (struct uuconf_port *)(& _uuconf_unset);
#line 149
  q->uuconf_qproto_params = (struct uuconf_proto_param *)(& _uuconf_unset);
#line 150
  q->uuconf_palloc = (void *)0;
#line 151
  return;
}
}
#line 161 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/syssub.c"
int _uuconf_isystem_default(struct sglobal *qglobal , struct uuconf_system *qset ,
                            struct uuconf_system *qdefault , boolean faddalternates ) 
{ 
  struct uuconf_system *qalt ;
  struct uuconf_system **pq ;
  struct uuconf_system *qdef ;
  void *tmp ;
  int *tmp___0 ;
  int cnew ;
  int ca ;
  struct uuconf_proto_param *qd ;
  struct uuconf_proto_param *qa ;
  int c ;
  struct uuconf_proto_param *qnew ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
#line 170
  if ((unsigned long )qset->uuconf_palloc != (unsigned long )qdefault->uuconf_palloc) {
    {
#line 171
    qset->uuconf_palloc = _uuconf_pmalloc_block_merge(qset->uuconf_palloc, qdefault->uuconf_palloc);
    }
  }
#line 179
  if (faddalternates) {
#line 183
    qdef = qdefault;
#line 183
    pq = & qset;
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 183
      if (! ((unsigned long )qdef != (unsigned long )((void *)0))) {
#line 183
        goto while_break;
      }
#line 187
      if ((unsigned long )*pq == (unsigned long )((void *)0)) {
        {
#line 189
        tmp = uuconf_malloc(qset->uuconf_palloc, sizeof(struct uuconf_system ));
#line 189
        *pq = (struct uuconf_system *)tmp;
        }
#line 192
        if ((unsigned long )*pq == (unsigned long )((void *)0)) {
          {
#line 194
          tmp___0 = __errno_location();
#line 194
          qglobal->ierrno = *tmp___0;
          }
#line 195
          return (260);
        }
#line 197
        *(*pq) = *qset;
#line 198
        (*pq)->uuconf_qalternate = (struct uuconf_system *)((void *)0);
      }
#line 183
      qdef = qdef->uuconf_qalternate;
#line 183
      pq = & (*pq)->uuconf_qalternate;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 203
  qalt = qset;
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! ((unsigned long )qalt != (unsigned long )((void *)0))) {
#line 203
      goto while_break___0;
    }
    {
#line 207
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 207
      if ((unsigned long )qalt->uuconf_zname == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zname = qdefault->uuconf_zname;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zalternate == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zalternate = qdefault->uuconf_zalternate;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zdebug == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zdebug = qdefault->uuconf_zdebug;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zmax_remote_debug == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zmax_remote_debug = qdefault->uuconf_zmax_remote_debug;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zphone == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zphone = qdefault->uuconf_zphone;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zcall_login == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zcall_login = qdefault->uuconf_zcall_login;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zcall_password == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zcall_password = qdefault->uuconf_zcall_password;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zcalled_login == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zcalled_login = qdefault->uuconf_zcalled_login;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zprotocols == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zprotocols = qdefault->uuconf_zprotocols;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zpubdir == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zpubdir = qdefault->uuconf_zpubdir;
      }
#line 207
      if ((unsigned long )qalt->uuconf_zlocalname == (unsigned long )((char *)(& _uuconf_unset))) {
#line 207
        qalt->uuconf_zlocalname = qdefault->uuconf_zlocalname;
      }
#line 207
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 211
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 211
      if ((unsigned long )qalt->uuconf_pzalias == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzalias = qdefault->uuconf_pzalias;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzlocal_send == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzlocal_send = qdefault->uuconf_pzlocal_send;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzremote_send == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzremote_send = qdefault->uuconf_pzremote_send;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzlocal_receive == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzlocal_receive = qdefault->uuconf_pzlocal_receive;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzremote_receive == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzremote_receive = qdefault->uuconf_pzremote_receive;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzpath == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzpath = qdefault->uuconf_pzpath;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzcmds == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzcmds = qdefault->uuconf_pzcmds;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzforward_from == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzforward_from = qdefault->uuconf_pzforward_from;
      }
#line 211
      if ((unsigned long )qalt->uuconf_pzforward_to == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_pzforward_to = qdefault->uuconf_pzforward_to;
      }
#line 211
      if ((unsigned long )qalt->uuconf_schat.uuconf_pzchat == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_schat.uuconf_pzchat = qdefault->uuconf_schat.uuconf_pzchat;
      }
#line 211
      if ((unsigned long )qalt->uuconf_schat.uuconf_pzprogram == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_schat.uuconf_pzprogram = qdefault->uuconf_schat.uuconf_pzprogram;
      }
#line 211
      if ((unsigned long )qalt->uuconf_schat.uuconf_pzfail == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_schat.uuconf_pzfail = qdefault->uuconf_schat.uuconf_pzfail;
      }
#line 211
      if ((unsigned long )qalt->uuconf_scalled_chat.uuconf_pzchat == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_scalled_chat.uuconf_pzchat = qdefault->uuconf_scalled_chat.uuconf_pzchat;
      }
#line 211
      if ((unsigned long )qalt->uuconf_scalled_chat.uuconf_pzprogram == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_scalled_chat.uuconf_pzprogram = qdefault->uuconf_scalled_chat.uuconf_pzprogram;
      }
#line 211
      if ((unsigned long )qalt->uuconf_scalled_chat.uuconf_pzfail == (unsigned long )(& _uuconf_unset)) {
#line 211
        qalt->uuconf_scalled_chat.uuconf_pzfail = qdefault->uuconf_scalled_chat.uuconf_pzfail;
      }
#line 211
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 216
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 216
      if ((unsigned long )qalt->uuconf_qtimegrade == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qtimegrade = qdefault->uuconf_qtimegrade;
      }
#line 216
      if ((unsigned long )qalt->uuconf_qcalltimegrade == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qcalltimegrade = qdefault->uuconf_qcalltimegrade;
      }
#line 216
      if ((unsigned long )qalt->uuconf_qcalledtimegrade == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qcalledtimegrade = qdefault->uuconf_qcalledtimegrade;
      }
#line 216
      if ((unsigned long )qalt->uuconf_qcall_local_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qcall_local_size = qdefault->uuconf_qcall_local_size;
      }
#line 216
      if ((unsigned long )qalt->uuconf_qcall_remote_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qcall_remote_size = qdefault->uuconf_qcall_remote_size;
      }
#line 216
      if ((unsigned long )qalt->uuconf_qcalled_local_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qcalled_local_size = qdefault->uuconf_qcalled_local_size;
      }
#line 216
      if ((unsigned long )qalt->uuconf_qcalled_remote_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 216
        qalt->uuconf_qcalled_remote_size = qdefault->uuconf_qcalled_remote_size;
      }
#line 216
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 219
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 219
      if (qalt->uuconf_fcall < 0) {
#line 219
        qalt->uuconf_fcall = qdefault->uuconf_fcall;
      }
#line 219
      if (qalt->uuconf_fcalled < 0) {
#line 219
        qalt->uuconf_fcalled = qdefault->uuconf_fcalled;
      }
#line 219
      if (qalt->uuconf_fcallback < 0) {
#line 219
        qalt->uuconf_fcallback = qdefault->uuconf_fcallback;
      }
#line 219
      if (qalt->uuconf_fsequence < 0) {
#line 219
        qalt->uuconf_fsequence = qdefault->uuconf_fsequence;
      }
#line 219
      if (qalt->uuconf_fsend_request < 0) {
#line 219
        qalt->uuconf_fsend_request = qdefault->uuconf_fsend_request;
      }
#line 219
      if (qalt->uuconf_frec_request < 0) {
#line 219
        qalt->uuconf_frec_request = qdefault->uuconf_frec_request;
      }
#line 219
      if (qalt->uuconf_fcall_transfer < 0) {
#line 219
        qalt->uuconf_fcall_transfer = qdefault->uuconf_fcall_transfer;
      }
#line 219
      if (qalt->uuconf_fcalled_transfer < 0) {
#line 219
        qalt->uuconf_fcalled_transfer = qdefault->uuconf_fcalled_transfer;
      }
#line 219
      if (qalt->uuconf_schat.uuconf_fstrip < 0) {
#line 219
        qalt->uuconf_schat.uuconf_fstrip = qdefault->uuconf_schat.uuconf_fstrip;
      }
#line 219
      if (qalt->uuconf_scalled_chat.uuconf_fstrip < 0) {
#line 219
        qalt->uuconf_scalled_chat.uuconf_fstrip = qdefault->uuconf_scalled_chat.uuconf_fstrip;
      }
#line 219
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 220
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 220
      if (qalt->uuconf_cmax_retries < 0) {
#line 220
        qalt->uuconf_cmax_retries = qdefault->uuconf_cmax_retries;
      }
#line 220
      if (qalt->uuconf_csuccess_wait < 0) {
#line 220
        qalt->uuconf_csuccess_wait = qdefault->uuconf_csuccess_wait;
      }
#line 220
      if (qalt->uuconf_ibaud < 0L) {
#line 220
        qalt->uuconf_ibaud = qdefault->uuconf_ibaud;
      }
#line 220
      if (qalt->uuconf_ihighbaud < 0L) {
#line 220
        qalt->uuconf_ihighbaud = qdefault->uuconf_ihighbaud;
      }
#line 220
      if (qalt->uuconf_cfree_space < 0L) {
#line 220
        qalt->uuconf_cfree_space = qdefault->uuconf_cfree_space;
      }
#line 220
      if (qalt->uuconf_schat.uuconf_ctimeout < 0) {
#line 220
        qalt->uuconf_schat.uuconf_ctimeout = qdefault->uuconf_schat.uuconf_ctimeout;
      }
#line 220
      if (qalt->uuconf_scalled_chat.uuconf_ctimeout < 0) {
#line 220
        qalt->uuconf_scalled_chat.uuconf_ctimeout = qdefault->uuconf_scalled_chat.uuconf_ctimeout;
      }
#line 220
      if (qalt->uuconf_cmax_file_time < 0L) {
#line 220
        qalt->uuconf_cmax_file_time = qdefault->uuconf_cmax_file_time;
      }
#line 220
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 226
    if ((unsigned long )qalt->uuconf_zport == (unsigned long )((char *)(& _uuconf_unset))) {
#line 226
      if ((unsigned long )qalt->uuconf_qport == (unsigned long )((struct uuconf_port *)(& _uuconf_unset))) {
#line 228
        qalt->uuconf_zport = qdefault->uuconf_zport;
      }
    }
#line 229
    if ((unsigned long )qalt->uuconf_qport == (unsigned long )((struct uuconf_port *)(& _uuconf_unset))) {
#line 230
      qalt->uuconf_qport = qdefault->uuconf_qport;
    }
#line 232
    if ((unsigned long )qalt->uuconf_qproto_params == (unsigned long )((struct uuconf_proto_param *)(& _uuconf_unset))) {
#line 234
      qalt->uuconf_qproto_params = qdefault->uuconf_qproto_params;
    } else
#line 235
    if ((unsigned long )qdefault->uuconf_qproto_params != (unsigned long )((void *)0)) {
#line 243
      ca = 0;
#line 244
      cnew = 0;
#line 245
      qd = qdefault->uuconf_qproto_params;
      {
#line 245
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 245
        if (! (qd->uuconf_bproto != 0)) {
#line 245
          goto while_break___6;
        }
#line 251
        c = 0;
#line 252
        qa = qalt->uuconf_qproto_params;
        {
#line 252
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 252
          if (qa->uuconf_bproto != 0) {
#line 252
            if (! (qa->uuconf_bproto != qd->uuconf_bproto)) {
#line 252
              goto while_break___7;
            }
          } else {
#line 252
            goto while_break___7;
          }
#line 256
          c ++;
#line 252
          qa ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 257
        if (qa->uuconf_bproto == 0) {
#line 259
          cnew ++;
#line 260
          ca = c;
        }
#line 245
        qd ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 264
      if (cnew > 0) {
        {
#line 268
        tmp___1 = uuconf_malloc(qset->uuconf_palloc, (unsigned long )((ca + cnew) + 1) * sizeof(struct uuconf_proto_param ));
#line 268
        qnew = (struct uuconf_proto_param *)tmp___1;
        }
#line 272
        if ((unsigned long )qnew == (unsigned long )((void *)0)) {
          {
#line 274
          tmp___2 = __errno_location();
#line 274
          qglobal->ierrno = *tmp___2;
          }
#line 275
          return (260);
        }
        {
#line 277
        memcpy((void */* __restrict  */)((pointer )qnew), (void const   */* __restrict  */)((pointer )qalt->uuconf_qproto_params),
               (unsigned long )ca * sizeof(struct uuconf_proto_param ));
#line 279
        cnew = 0;
#line 280
        qd = qdefault->uuconf_qproto_params;
        }
        {
#line 280
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 280
          if (! (qd->uuconf_bproto != 0)) {
#line 280
            goto while_break___8;
          }
#line 284
          qa = qalt->uuconf_qproto_params;
          {
#line 284
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 284
            if (qa->uuconf_bproto != 0) {
#line 284
              if (! (qa->uuconf_bproto != qd->uuconf_bproto)) {
#line 284
                goto while_break___9;
              }
            } else {
#line 284
              goto while_break___9;
            }
#line 284
            qa ++;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 289
          if (qa->uuconf_bproto == 0) {
#line 291
            *(qnew + (ca + cnew)) = *qd;
#line 292
            cnew ++;
          }
#line 280
          qd ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 295
        (qnew + (ca + cnew))->uuconf_bproto = '\000';
#line 296
        uuconf_free(qset->uuconf_palloc, (void *)qalt->uuconf_qproto_params);
#line 297
        qalt->uuconf_qproto_params = qnew;
        }
      }
    }
#line 301
    if ((unsigned long )qdefault->uuconf_qalternate != (unsigned long )((void *)0)) {
#line 302
      qdefault = qdefault->uuconf_qalternate;
    }
#line 203
    qalt = qalt->uuconf_qalternate;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  return (0);
}
}
#line 311 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/syssub.c"
int _uuconf_isystem_basic_default(struct sglobal *qglobal , struct uuconf_system *q ) 
{ 
  int iret ;
  char *zdup ;
  char **pz ;
  size_t csplit ;
  int c ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 318
  iret = 0;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 320
      if (! (iret == 0)) {
#line 320
        goto while_break;
      }
    } else {
#line 320
      goto while_break;
    }
#line 323
    if (q->uuconf_cmax_retries < 0) {
#line 324
      q->uuconf_cmax_retries = 26;
    }
#line 325
    if ((unsigned long )q->uuconf_schat.uuconf_pzchat == (unsigned long )(& _uuconf_unset)) {
      {
#line 327
      q->uuconf_schat.uuconf_pzchat = (char **)((void *)0);
#line 328
      iret = _uuconf_iadd_string(qglobal, (char *)"\"\"", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 332
      if (iret != 0) {
#line 333
        return (iret);
      }
      {
#line 334
      iret = _uuconf_iadd_string(qglobal, (char *)"\\r\\c", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 338
      if (iret != 0) {
#line 339
        return (iret);
      }
      {
#line 340
      iret = _uuconf_iadd_string(qglobal, (char *)"ogin:", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 344
      if (iret != 0) {
#line 345
        return (iret);
      }
      {
#line 346
      iret = _uuconf_iadd_string(qglobal, (char *)"-BREAK", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 350
      if (iret != 0) {
#line 351
        return (iret);
      }
      {
#line 352
      iret = _uuconf_iadd_string(qglobal, (char *)"-ogin:", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 356
      if (iret != 0) {
#line 357
        return (iret);
      }
      {
#line 358
      iret = _uuconf_iadd_string(qglobal, (char *)"-BREAK", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 362
      if (iret != 0) {
#line 363
        return (iret);
      }
      {
#line 364
      iret = _uuconf_iadd_string(qglobal, (char *)"-ogin:", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 368
      if (iret != 0) {
#line 369
        return (iret);
      }
      {
#line 370
      iret = _uuconf_iadd_string(qglobal, (char *)"\\L", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 374
      if (iret != 0) {
#line 375
        return (iret);
      }
      {
#line 376
      iret = _uuconf_iadd_string(qglobal, (char *)"word:", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 380
      if (iret != 0) {
#line 381
        return (iret);
      }
      {
#line 382
      iret = _uuconf_iadd_string(qglobal, (char *)"\\P", 0, 0, & q->uuconf_schat.uuconf_pzchat,
                                 q->uuconf_palloc);
      }
#line 386
      if (iret != 0) {
#line 387
        return (iret);
      }
    }
#line 389
    if (q->uuconf_schat.uuconf_ctimeout < 0) {
#line 390
      q->uuconf_schat.uuconf_ctimeout = 10;
    }
#line 391
    if (q->uuconf_schat.uuconf_fstrip < 0) {
#line 392
      q->uuconf_schat.uuconf_fstrip = 1;
    }
#line 393
    if (q->uuconf_scalled_chat.uuconf_ctimeout < 0) {
#line 394
      q->uuconf_scalled_chat.uuconf_ctimeout = 60;
    }
#line 395
    if (q->uuconf_scalled_chat.uuconf_fstrip < 0) {
#line 396
      q->uuconf_scalled_chat.uuconf_fstrip = 1;
    }
#line 397
    if (q->uuconf_fsend_request < 0) {
#line 398
      q->uuconf_fsend_request = 1;
    }
#line 399
    if (q->uuconf_frec_request < 0) {
#line 400
      q->uuconf_frec_request = 1;
    }
#line 401
    if (q->uuconf_fcall_transfer < 0) {
#line 402
      q->uuconf_fcall_transfer = 1;
    }
#line 403
    if (q->uuconf_fcalled_transfer < 0) {
#line 404
      q->uuconf_fcalled_transfer = 1;
    }
#line 405
    if ((unsigned long )q->uuconf_pzlocal_send == (unsigned long )(& _uuconf_unset)) {
      {
#line 407
      q->uuconf_pzlocal_send = (char **)((void *)0);
#line 408
      iret = _uuconf_iadd_string(qglobal, (char *)"/", 0, 0, & q->uuconf_pzlocal_send,
                                 q->uuconf_palloc);
      }
#line 411
      if (iret != 0) {
#line 412
        return (iret);
      }
    }
#line 414
    if ((unsigned long )q->uuconf_pzremote_send == (unsigned long )(& _uuconf_unset)) {
      {
#line 416
      q->uuconf_pzremote_send = (char **)((void *)0);
#line 417
      iret = _uuconf_iadd_string(qglobal, (char *)"~", 0, 0, & q->uuconf_pzremote_send,
                                 q->uuconf_palloc);
      }
#line 420
      if (iret != 0) {
#line 421
        return (iret);
      }
    }
#line 423
    if ((unsigned long )q->uuconf_pzlocal_receive == (unsigned long )(& _uuconf_unset)) {
      {
#line 425
      q->uuconf_pzlocal_receive = (char **)((void *)0);
#line 426
      iret = _uuconf_iadd_string(qglobal, (char *)"~", 0, 0, & q->uuconf_pzlocal_receive,
                                 q->uuconf_palloc);
      }
#line 429
      if (iret != 0) {
#line 430
        return (iret);
      }
    }
#line 432
    if ((unsigned long )q->uuconf_pzremote_receive == (unsigned long )(& _uuconf_unset)) {
      {
#line 434
      q->uuconf_pzremote_receive = (char **)((void *)0);
#line 435
      iret = _uuconf_iadd_string(qglobal, (char *)"~", 0, 0, & q->uuconf_pzremote_receive,
                                 q->uuconf_palloc);
      }
#line 438
      if (iret != 0) {
#line 439
        return (iret);
      }
    }
#line 442
    if ((unsigned long )q->uuconf_pzpath == (unsigned long )(& _uuconf_unset)) {
      {
#line 449
      tmp = uuconf_malloc(q->uuconf_palloc, sizeof("/bin /usr/bin /usr/local/bin"));
#line 449
      zdup = (char *)tmp;
      }
#line 450
      if ((unsigned long )zdup == (unsigned long )((void *)0)) {
        {
#line 452
        tmp___0 = __errno_location();
#line 452
        qglobal->ierrno = *tmp___0;
        }
#line 453
        return (260);
      }
      {
#line 456
      memcpy((void */* __restrict  */)((pointer )zdup), (void const   */* __restrict  */)((pointer )"/bin /usr/bin /usr/local/bin"),
             sizeof("/bin /usr/bin /usr/local/bin"));
#line 457
      pz = (char **)((void *)0);
#line 458
      csplit = (size_t )0;
#line 459
      c = _uuconf_istrsplit(zdup, '\000', & pz, & csplit);
      }
#line 459
      if (c < 0) {
        {
#line 461
        tmp___1 = __errno_location();
#line 461
        qglobal->ierrno = *tmp___1;
        }
#line 462
        return (260);
      }
      {
#line 464
      tmp___2 = uuconf_malloc(q->uuconf_palloc, (unsigned long )(c + 1) * sizeof(char *));
#line 464
      q->uuconf_pzpath = (char **)tmp___2;
      }
#line 467
      if ((unsigned long )q->uuconf_pzpath == (unsigned long )((void *)0)) {
        {
#line 469
        tmp___3 = __errno_location();
#line 469
        qglobal->ierrno = *tmp___3;
        }
#line 470
        return (260);
      }
      {
#line 472
      memcpy((void */* __restrict  */)((pointer )q->uuconf_pzpath), (void const   */* __restrict  */)((pointer )pz),
             (unsigned long )c * sizeof(char *));
#line 474
      *(q->uuconf_pzpath + c) = (char *)((void *)0);
#line 475
      free((pointer )pz);
      }
    }
#line 478
    if ((unsigned long )q->uuconf_pzcmds == (unsigned long )(& _uuconf_unset)) {
      {
#line 480
      tmp___4 = uuconf_malloc(q->uuconf_palloc, 3UL * sizeof(char const   *));
#line 480
      q->uuconf_pzcmds = (char **)tmp___4;
      }
#line 483
      if ((unsigned long )q->uuconf_pzcmds == (unsigned long )((void *)0)) {
        {
#line 485
        tmp___5 = __errno_location();
#line 485
        qglobal->ierrno = *tmp___5;
        }
#line 486
        return (260);
      }
#line 488
      *(q->uuconf_pzcmds + 0) = (char *)"rnews";
#line 489
      *(q->uuconf_pzcmds + 1) = (char *)"rmail";
#line 490
      *(q->uuconf_pzcmds + 2) = (char *)((void *)0);
    }
#line 493
    if (q->uuconf_cfree_space < 0L) {
#line 494
      q->uuconf_cfree_space = 50000L;
    }
#line 496
    if ((unsigned long )q->uuconf_zpubdir == (unsigned long )((char const   *)(& _uuconf_unset))) {
#line 497
      q->uuconf_zpubdir = (qglobal->qprocess)->zpubdir;
    }
    {
#line 500
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 500
      if ((unsigned long )q->uuconf_zname == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zname = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zalternate == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zalternate = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zdebug == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zdebug = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zmax_remote_debug == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zmax_remote_debug = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zphone == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zphone = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zcall_login == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zcall_login = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zcall_password == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zcall_password = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zcalled_login == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zcalled_login = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zprotocols == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zprotocols = (char *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zpubdir == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zpubdir = (char const   *)((void *)0);
      }
#line 500
      if ((unsigned long )q->uuconf_zlocalname == (unsigned long )((char *)(& _uuconf_unset))) {
#line 500
        q->uuconf_zlocalname = (char *)((void *)0);
      }
#line 500
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 503
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 503
      if ((unsigned long )q->uuconf_pzalias == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzalias = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzlocal_send == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzlocal_send = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzremote_send == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzremote_send = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzlocal_receive == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzlocal_receive = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzremote_receive == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzremote_receive = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzpath == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzpath = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzcmds == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzcmds = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzforward_from == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzforward_from = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_pzforward_to == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_pzforward_to = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_schat.uuconf_pzchat == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_schat.uuconf_pzchat = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_schat.uuconf_pzprogram == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_schat.uuconf_pzprogram = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_schat.uuconf_pzfail == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_schat.uuconf_pzfail = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_scalled_chat.uuconf_pzchat == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_scalled_chat.uuconf_pzchat = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_scalled_chat.uuconf_pzprogram == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_scalled_chat.uuconf_pzprogram = (char **)((void *)0);
      }
#line 503
      if ((unsigned long )q->uuconf_scalled_chat.uuconf_pzfail == (unsigned long )(& _uuconf_unset)) {
#line 503
        q->uuconf_scalled_chat.uuconf_pzfail = (char **)((void *)0);
      }
#line 503
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 507
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 507
      if ((unsigned long )q->uuconf_qtimegrade == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qtimegrade = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      if ((unsigned long )q->uuconf_qcalltimegrade == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qcalltimegrade = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      if ((unsigned long )q->uuconf_qcalledtimegrade == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qcalledtimegrade = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      if ((unsigned long )q->uuconf_qcall_local_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qcall_local_size = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      if ((unsigned long )q->uuconf_qcall_remote_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qcall_remote_size = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      if ((unsigned long )q->uuconf_qcalled_local_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qcalled_local_size = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      if ((unsigned long )q->uuconf_qcalled_remote_size == (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 507
        q->uuconf_qcalled_remote_size = (struct uuconf_timespan *)((void *)0);
      }
#line 507
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 510
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 510
      if (q->uuconf_fcall < 0) {
#line 510
        q->uuconf_fcall = 0;
      }
#line 510
      if (q->uuconf_fcalled < 0) {
#line 510
        q->uuconf_fcalled = 0;
      }
#line 510
      if (q->uuconf_fcallback < 0) {
#line 510
        q->uuconf_fcallback = 0;
      }
#line 510
      if (q->uuconf_fsequence < 0) {
#line 510
        q->uuconf_fsequence = 0;
      }
#line 510
      if (q->uuconf_fsend_request < 0) {
#line 510
        q->uuconf_fsend_request = 0;
      }
#line 510
      if (q->uuconf_frec_request < 0) {
#line 510
        q->uuconf_frec_request = 0;
      }
#line 510
      if (q->uuconf_fcall_transfer < 0) {
#line 510
        q->uuconf_fcall_transfer = 0;
      }
#line 510
      if (q->uuconf_fcalled_transfer < 0) {
#line 510
        q->uuconf_fcalled_transfer = 0;
      }
#line 510
      if (q->uuconf_schat.uuconf_fstrip < 0) {
#line 510
        q->uuconf_schat.uuconf_fstrip = 0;
      }
#line 510
      if (q->uuconf_scalled_chat.uuconf_fstrip < 0) {
#line 510
        q->uuconf_scalled_chat.uuconf_fstrip = 0;
      }
#line 510
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 511
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 511
      if (q->uuconf_cmax_retries < 0) {
#line 511
        q->uuconf_cmax_retries = 0;
      }
#line 511
      if (q->uuconf_csuccess_wait < 0) {
#line 511
        q->uuconf_csuccess_wait = 0;
      }
#line 511
      if (q->uuconf_ibaud < 0L) {
#line 511
        q->uuconf_ibaud = 0L;
      }
#line 511
      if (q->uuconf_ihighbaud < 0L) {
#line 511
        q->uuconf_ihighbaud = 0L;
      }
#line 511
      if (q->uuconf_cfree_space < 0L) {
#line 511
        q->uuconf_cfree_space = 0L;
      }
#line 511
      if (q->uuconf_schat.uuconf_ctimeout < 0) {
#line 511
        q->uuconf_schat.uuconf_ctimeout = 0;
      }
#line 511
      if (q->uuconf_scalled_chat.uuconf_ctimeout < 0) {
#line 511
        q->uuconf_scalled_chat.uuconf_ctimeout = 0;
      }
#line 511
      if (q->uuconf_cmax_file_time < 0L) {
#line 511
        q->uuconf_cmax_file_time = 0L;
      }
#line 511
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 514
    if ((unsigned long )q->uuconf_zport == (unsigned long )((char *)(& _uuconf_unset))) {
#line 515
      q->uuconf_zport = (char *)((void *)0);
    }
#line 516
    if ((unsigned long )q->uuconf_qport == (unsigned long )((struct uuconf_port *)(& _uuconf_unset))) {
#line 517
      q->uuconf_qport = (struct uuconf_port *)((void *)0);
    }
#line 518
    if ((unsigned long )q->uuconf_qproto_params == (unsigned long )((struct uuconf_proto_param *)(& _uuconf_unset))) {
#line 520
      q->uuconf_qproto_params = (struct uuconf_proto_param *)((void *)0);
    }
#line 320
    q = q->uuconf_qalternate;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  return (iret);
}
}
#line 935 "../uuconf.h"
int uuconf_strip(void *pglobal , int *pistrip ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/strip.c"
char const   _uuconf_strip_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/strip.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'r', 
        (char const   )'i',      (char const   )'p',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/strip.c"
int uuconf_strip(void *pglobal , int *pistrip ) 
{ 
  struct sglobal *qglobal ;

  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 43
  *pistrip = 0;
#line 44
  if ((qglobal->qprocess)->fstrip_login) {
#line 45
    *pistrip |= 1;
  }
#line 46
  if ((qglobal->qprocess)->fstrip_proto) {
#line 47
    *pistrip |= 2;
  }
#line 48
  return (0);
}
}
#line 918 "../uuconf.h"
int uuconf_statsfile(void *pglobal , char const   **pzstats ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/stafil.c"
char const   _uuconf_stafil_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/stafil.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/stafil.c"
int uuconf_statsfile(void *pglobal , char const   **pzstats ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzstats = (qglobal->qprocess)->zstatsfile;
#line 41
  return (0);
}
}
#line 897 "../uuconf.h"
int uuconf_spooldir(void *pglobal , char const   **pzspool ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/spool.c"
char const   _uuconf_spool_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/spool.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'7',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/spool.c"
int uuconf_spooldir(void *pglobal , char const   **pzspool ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzspool = (qglobal->qprocess)->zspooldir;
#line 41
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/split.c"
char const   _uuconf_split_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/split.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'l', 
        (char const   )'i',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/split.c"
int _uuconf_istrsplit(char *zline , int bsep , char ***ppzsplit , size_t *pcsplit ) 
{ 
  size_t i ;
  unsigned short const   **tmp ;
  char **pznew ;
  size_t cnew ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;

  {
#line 50
  i = (size_t )0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (bsep == 0) {
      {
#line 56
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 56
        tmp = __ctype_b_loc();
        }
#line 56
        if (! ((int const   )*(*tmp + (int )((unsigned char )*zline)) & 8192)) {
#line 56
          goto while_break___0;
        }
#line 57
        zline ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 58
      if ((int )*zline == 0) {
#line 59
        goto while_break;
      }
    }
#line 62
    if (i >= *pcsplit) {
#line 67
      if (*pcsplit == 0UL) {
        {
#line 69
        cnew = (size_t )8;
#line 70
        tmp___0 = malloc(cnew * sizeof(char *));
#line 70
        pznew = (char **)tmp___0;
        }
      } else {
        {
#line 74
        cnew = *pcsplit * 2UL;
#line 75
        tmp___1 = realloc((pointer )*ppzsplit, cnew * sizeof(char *));
#line 75
        pznew = (char **)tmp___1;
        }
      }
#line 78
      if ((unsigned long )pznew == (unsigned long )((void *)0)) {
#line 79
        return (-1);
      }
#line 80
      *ppzsplit = pznew;
#line 81
      *pcsplit = cnew;
    }
#line 84
    *(*ppzsplit + i) = zline;
#line 85
    i ++;
#line 87
    if (bsep == 0) {
      {
#line 89
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 89
        if ((int )*zline != 0) {
          {
#line 89
          tmp___2 = __ctype_b_loc();
          }
#line 89
          if ((int const   )*(*tmp___2 + (int )((unsigned char )*zline)) & 8192) {
#line 89
            goto while_break___1;
          }
        } else {
#line 89
          goto while_break___1;
        }
#line 90
        zline ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 94
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 94
        if ((int )*zline != 0) {
#line 94
          if (! ((int )*zline != bsep)) {
#line 94
            goto while_break___2;
          }
        } else {
#line 94
          goto while_break___2;
        }
#line 95
        zline ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 98
    if ((int )*zline == 0) {
#line 99
      goto while_break;
    }
#line 101
    tmp___3 = zline;
#line 101
    zline ++;
#line 101
    *tmp___3 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return ((int )i);
}
}
#line 753 "../uuconf.h"
int uuconf_system_names(void *pglobal , char ***ppzsystems , int falias ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/snams.c"
char const   _uuconf_snams_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/snams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'n',      (char const   )'a', 
        (char const   )'m',      (char const   )'s',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/snams.c"
int uuconf_system_names(void *pglobal , char ***ppzsystems , int falias ) 
{ 
  struct sglobal *qglobal ;
  char **pztaylor ;
  char **pzv2 ;
  char **pzhdb ;
  int iret ;
  char **pz ;

  {
  {
#line 39
  qglobal = (struct sglobal *)pglobal;
#line 45
  *ppzsystems = (char **)((void *)0);
#line 46
  pztaylor = (char **)((void *)0);
#line 47
  pzv2 = (char **)((void *)0);
#line 48
  pzhdb = (char **)((void *)0);
#line 51
  iret = uuconf_taylor_system_names(pglobal, & pztaylor, falias);
  }
#line 52
  if (iret != 0) {
#line 53
    return (iret);
  }
#line 74
  if ((unsigned long )pzv2 == (unsigned long )((void *)0)) {
#line 74
    if ((unsigned long )pzhdb == (unsigned long )((void *)0)) {
#line 75
      *ppzsystems = pztaylor;
    } else {
#line 74
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 76
  if ((unsigned long )pztaylor == (unsigned long )((void *)0)) {
#line 76
    if ((unsigned long )pzhdb == (unsigned long )((void *)0)) {
#line 77
      *ppzsystems = pzv2;
    } else {
#line 76
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 78
  if ((unsigned long )pztaylor == (unsigned long )((void *)0)) {
#line 78
    if ((unsigned long )pzv2 == (unsigned long )((void *)0)) {
#line 79
      *ppzsystems = pzhdb;
    } else {
#line 78
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 84
    iret = 0;
#line 86
    if ((unsigned long )pztaylor != (unsigned long )((void *)0)) {
#line 88
      pz = pztaylor;
      {
#line 88
      while (1) {
        while_continue: /* CIL Label */ ;
#line 88
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 88
          goto while_break;
        }
        {
#line 90
        iret = _uuconf_iadd_string(qglobal, *pz, 0, 1, ppzsystems, (void *)0);
        }
#line 92
        if (iret != 0) {
#line 93
          goto while_break;
        }
#line 88
        pz ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 97
    if ((unsigned long )pzv2 != (unsigned long )((void *)0)) {
#line 97
      if (iret == 0) {
#line 99
        pz = pzv2;
        {
#line 99
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 99
          if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 99
            goto while_break___0;
          }
          {
#line 101
          iret = _uuconf_iadd_string(qglobal, *pz, 0, 1, ppzsystems, (void *)0);
          }
#line 103
          if (iret != 0) {
#line 104
            goto while_break___0;
          }
#line 99
          pz ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 108
    if ((unsigned long )pzhdb != (unsigned long )((void *)0)) {
#line 108
      if (iret == 0) {
#line 110
        pz = pzhdb;
        {
#line 110
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 110
          if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 110
            goto while_break___1;
          }
          {
#line 112
          iret = _uuconf_iadd_string(qglobal, *pz, 0, 1, ppzsystems, (void *)0);
          }
#line 114
          if (iret != 0) {
#line 115
            goto while_break___1;
          }
#line 110
          pz ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 119
    if ((unsigned long )pztaylor != (unsigned long )((void *)0)) {
      {
#line 120
      free((pointer )pztaylor);
      }
    }
#line 121
    if ((unsigned long )pzv2 != (unsigned long )((void *)0)) {
      {
#line 122
      free((pointer )pzv2);
      }
    }
#line 123
    if ((unsigned long )pzhdb != (unsigned long )((void *)0)) {
      {
#line 124
      free((pointer )pzhdb);
      }
    }
  }
#line 127
  if (iret == 0) {
#line 127
    if ((unsigned long )*ppzsystems == (unsigned long )((void *)0)) {
      {
#line 128
      iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzsystems, (void *)0);
      }
    }
  }
#line 131
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/sinfo.c"
char const   _uuconf_sinfo_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/sinfo.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'f',      (char const   )'o',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/sinfo.c"
int uuconf_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  boolean fgot ;
  int tmp ;

  {
  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 45
  fgot = 0;
#line 48
  iret = _uuconf_itaylor_system_internal(qglobal, zsystem, qsys);
  }
#line 49
  if (iret == 0) {
#line 50
    fgot = 1;
  } else
#line 51
  if (iret != 1) {
#line 52
    return (iret);
  }
#line 107
  if (! fgot) {
#line 108
    return (1);
  }
  {
#line 110
  tmp = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 110
  return (tmp);
}
}
#line 947 "../uuconf.h"
int uuconf_runuuxqt(void *pglobal , int *pirunuuxqt ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/runuxq.c"
char const   _uuconf_runuxq_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/runuxq.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'u',      (char const   )'n', 
        (char const   )'u',      (char const   )'x',      (char const   )'q',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/runuxq.c"
int uuconf_runuuxqt(void *pglobal , int *pirunuuxqt ) 
{ 
  struct sglobal *qglobal ;
  char const   *zrun ;
  char *zend ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 46
  qglobal = (struct sglobal *)pglobal;
#line 49
  zrun = (qglobal->qprocess)->zrunuuxqt;
#line 50
  if ((unsigned long )zrun == (unsigned long )((void *)0)) {
#line 52
    *pirunuuxqt = -1;
  } else {
    {
#line 50
    tmp___2 = strcasecmp(zrun, "once");
    }
#line 50
    if (tmp___2 == 0) {
#line 52
      *pirunuuxqt = -1;
    } else {
      {
#line 53
      tmp___1 = strcasecmp(zrun, "never");
      }
#line 53
      if (tmp___1 == 0) {
#line 54
        *pirunuuxqt = 0;
      } else {
        {
#line 55
        tmp___0 = strcasecmp(zrun, "percall");
        }
#line 55
        if (tmp___0 == 0) {
#line 56
          *pirunuuxqt = -2;
        } else {
          {
#line 61
          tmp = strtol((char const   */* __restrict  */)((char *)(qglobal->qprocess)->zrunuuxqt),
                       (char **/* __restrict  */)(& zend), 10);
#line 61
          *pirunuuxqt = (int )tmp;
          }
#line 63
          if ((int )*zend != 0) {
#line 64
            *pirunuuxqt = -1;
          } else
#line 63
          if (*pirunuuxqt <= 0) {
#line 64
            *pirunuuxqt = -1;
          }
        }
      }
    }
  }
#line 75
  return (0);
}
}
#line 989 "../uuconf.h"
int uuconf_remote_unknown(void *pglobal  __attribute__((__unused__)) , char **pzname  __attribute__((__unused__)) ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/remunk.c"
char const   _uuconf_remunk_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/remunk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'u',      (char const   )'n',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 34 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/remunk.c"
int uuconf_remote_unknown(void *pglobal  __attribute__((__unused__)) , char **pzname  __attribute__((__unused__)) ) 
{ 


  {
#line 40
  return (1);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/reliab.c"
char const   _uuconf_reliab_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/reliab.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'l', 
        (char const   )'i',      (char const   )'a',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/reliab.c"
int _uuconf_iseven_bit(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                       pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  int *pi ;
  int fval ;
  int iret ;

  {
  {
#line 44
  qglobal = (struct sglobal *)pglobal;
#line 45
  pi = (int *)pvar;
#line 49
  iret = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & fval);
  }
#line 50
  if ((iret & -2049) != 0) {
#line 51
    return (iret);
  }
#line 53
  *pi |= 1;
#line 54
  if (fval) {
#line 55
    *pi &= -3;
  } else {
#line 57
    *pi |= 2;
  }
#line 59
  return (iret);
}
}
#line 67 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/reliab.c"
int _uuconf_ireliable(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                      pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  int *pi ;
  int fval ;
  int iret ;

  {
  {
#line 75
  qglobal = (struct sglobal *)pglobal;
#line 76
  pi = (int *)pvar;
#line 80
  iret = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & fval);
  }
#line 81
  if ((iret & -2049) != 0) {
#line 82
    return (iret);
  }
#line 84
  *pi |= 1;
#line 85
  if (fval) {
#line 86
    *pi |= 4;
  } else {
#line 88
    *pi &= -5;
  }
#line 90
  return (iret);
}
}
#line 98 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/reliab.c"
int _uuconf_ihalf_duplex(pointer pglobal , int argc  __attribute__((__unused__)) ,
                         char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  int *pi ;
  int fval ;
  int iret ;

  {
  {
#line 106
  qglobal = (struct sglobal *)pglobal;
#line 107
  pi = (int *)pvar;
#line 111
  iret = _uuconf_iboolean(qglobal, (char const   *)*(argv + 1), & fval);
  }
#line 112
  if ((iret & -2049) != 0) {
#line 113
    return (iret);
  }
#line 115
  *pi |= 1;
#line 116
  if (fval) {
#line 117
    *pi &= -17;
  } else {
#line 119
    *pi |= 16;
  }
#line 121
  return (iret);
}
}
#line 304 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_ihread_permissions(struct sglobal *qglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
char const   _uuconf_rdperm_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'d',      (char const   )'p', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'2', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 34
static int ihcolon(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                   pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 36
static int ihsendfiles(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                       char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 38
static int ihunknownperm(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                         char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                         pointer pinfo  __attribute__((__unused__)) ) ;
#line 40
static int ihadd_norw(struct sglobal *qglobal , char ***ppz , char **pzno ) ;
#line 62 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
static struct cmdtab_offset  const  asHperm_cmds[15]  = 
#line 62
  {      {"NOREAD", 98, (size_t )-1, & ihcolon}, 
        {"NOWRITE", 98, (size_t )-1, & ihcolon}, 
        {"LOGNAME", 98, (unsigned long )(& ((struct shpermissions *)0)->pzlogname), & ihcolon}, 
        {"MACHINE",
      98, (unsigned long )(& ((struct shpermissions *)0)->pzmachine), & ihcolon}, 
        {"REQUEST", 18, (unsigned long )(& ((struct shpermissions *)0)->frequest), (int (*)(void *uuconf_pglobal ,
                                                                                         int uuconf_argc ,
                                                                                         char **uuconf_argv ,
                                                                                         void *uuconf_pvar ,
                                                                                         void *uuconf_pinfo ))((void *)0)}, 
        {"SENDFILES",
      98, (unsigned long )(& ((struct shpermissions *)0)->fsendfiles), & ihsendfiles}, 
        {"READ",
      98, (unsigned long )(& ((struct shpermissions *)0)->pzread), & ihcolon}, 
        {"WRITE", 98, (unsigned long )(& ((struct shpermissions *)0)->pzwrite), & ihcolon}, 
        {"CALLBACK",
      18, (unsigned long )(& ((struct shpermissions *)0)->fcallback), (int (*)(void *uuconf_pglobal ,
                                                                               int uuconf_argc ,
                                                                               char **uuconf_argv ,
                                                                               void *uuconf_pvar ,
                                                                               void *uuconf_pinfo ))((void *)0)}, 
        {"COMMANDS",
      98, (unsigned long )(& ((struct shpermissions *)0)->pzcommands), & ihcolon}, 
        {"VALIDATE",
      98, (unsigned long )(& ((struct shpermissions *)0)->pzvalidate), & ihcolon}, 
        {"MYNAME",
      64, (unsigned long )(& ((struct shpermissions *)0)->zmyname), (int (*)(void *uuconf_pglobal ,
                                                                             int uuconf_argc ,
                                                                             char **uuconf_argv ,
                                                                             void *uuconf_pvar ,
                                                                             void *uuconf_pinfo ))((void *)0)}, 
        {"PUBDIR",
      64, (unsigned long )(& ((struct shpermissions *)0)->zpubdir), (int (*)(void *uuconf_pglobal ,
                                                                             int uuconf_argc ,
                                                                             char **uuconf_argv ,
                                                                             void *uuconf_pvar ,
                                                                             void *uuconf_pinfo ))((void *)0)}, 
        {"ALIAS",
      98, (unsigned long )(& ((struct shpermissions *)0)->pzalias), & ihcolon}, 
        {(char const   *)((void *)0), 0, (size_t )0, (int (*)(void *uuconf_pglobal ,
                                                           int uuconf_argc , char **uuconf_argv ,
                                                           void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 98 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
int _uuconf_ihread_permissions(struct sglobal *qglobal ) 
{ 
  char *zperm ;
  FILE *e ;
  int iret ;
  struct uuconf_cmdtab as[sizeof(asHperm_cmds) / sizeof(asHperm_cmds[0])] ;
  char **pznoread ;
  char **pznowrite ;
  struct shpermissions shperm ;
  char *zline ;
  size_t cline ;
  char **pzsplit ;
  size_t csplit ;
  int cchars ;
  struct shpermissions *qlist ;
  struct shpermissions **pq ;
  void *tmp ;
  int *tmp___0 ;
  int centries ;
  struct shpermissions *qnew ;
  int i ;
  int *tmp___1 ;
  char *zeq ;
  char *azargs[2] ;
  int *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 115
  if ((qglobal->qprocess)->fhdb_read_permissions) {
#line 116
    return (0);
  }
  {
#line 118
  tmp = uuconf_malloc(qglobal->pblock, (sizeof("/usr/lib/uucp") + sizeof("/Permissions")) - 1UL);
#line 118
  zperm = (char *)tmp;
  }
#line 121
  if ((unsigned long )zperm == (unsigned long )((void *)0)) {
    {
#line 123
    tmp___0 = __errno_location();
#line 123
    qglobal->ierrno = *tmp___0;
    }
#line 124
    return (260);
  }
  {
#line 127
  memcpy((void */* __restrict  */)((pointer )zperm), (void const   */* __restrict  */)((pointer )"/usr/lib/uucp"),
         sizeof("/usr/lib/uucp") - 1UL);
#line 129
  memcpy((void */* __restrict  */)((pointer )((zperm + sizeof("/usr/lib/uucp")) - 1)),
         (void const   */* __restrict  */)((pointer )"/Permissions"), sizeof("/Permissions"));
#line 132
  e = fopen((char const   */* __restrict  */)zperm, (char const   */* __restrict  */)"r");
  }
#line 133
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 135
    uuconf_free(qglobal->pblock, (void *)zperm);
#line 136
    (qglobal->qprocess)->fhdb_read_permissions = 1;
    }
#line 137
    return (0);
  }
  {
#line 140
  _uuconf_ucmdtab_base(asHperm_cmds, sizeof(asHperm_cmds) / sizeof(asHperm_cmds[0]),
                       (char *)(& shperm), as);
#line 141
  as[0].uuconf_pvar = (pointer )(& pznoread);
#line 142
  as[1].uuconf_pvar = (pointer )(& pznowrite);
#line 144
  zline = (char *)((void *)0);
#line 145
  cline = (size_t )0;
#line 146
  pzsplit = (char **)((void *)0);
#line 147
  csplit = (size_t )0;
#line 149
  qlist = (struct shpermissions *)((void *)0);
#line 150
  pq = & qlist;
#line 152
  qglobal->ilineno = 0;
#line 154
  iret = 0;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    cchars = _uuconf_getline(qglobal, & zline, & cline, e);
    }
#line 156
    if (! (cchars > 0)) {
#line 156
      goto while_break;
    }
#line 162
    (qglobal->ilineno) ++;
#line 164
    cchars --;
#line 165
    if ((int )*(zline + cchars) == 10) {
#line 166
      *(zline + cchars) = (char )'\000';
    }
#line 167
    if ((int )*(zline + 0) == 35) {
#line 168
      goto while_continue;
    }
    {
#line 170
    centries = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
    }
#line 171
    if (centries < 0) {
      {
#line 173
      tmp___1 = __errno_location();
#line 173
      qglobal->ierrno = *tmp___1;
#line 174
      iret = 260;
      }
#line 175
      goto while_break;
    }
#line 178
    if (centries == 0) {
#line 179
      goto while_continue;
    }
#line 181
    shperm.pzlogname = & _uuconf_unset;
#line 182
    shperm.pzmachine = & _uuconf_unset;
#line 183
    shperm.frequest = -1;
#line 184
    shperm.fsendfiles = -1;
#line 185
    shperm.pzread = & _uuconf_unset;
#line 186
    shperm.pzwrite = & _uuconf_unset;
#line 187
    shperm.fcallback = -1;
#line 188
    shperm.pzcommands = & _uuconf_unset;
#line 189
    shperm.pzvalidate = & _uuconf_unset;
#line 190
    shperm.zmyname = (char *)(& _uuconf_unset);
#line 191
    shperm.zpubdir = (char const   *)((char *)(& _uuconf_unset));
#line 192
    shperm.pzalias = & _uuconf_unset;
#line 193
    pznoread = & _uuconf_unset;
#line 194
    pznowrite = & _uuconf_unset;
#line 196
    i = 0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 196
      if (! (i < centries)) {
#line 196
        goto while_break___0;
      }
      {
#line 201
      zeq = strchr((char const   *)*(pzsplit + i), '=');
      }
#line 202
      if ((unsigned long )zeq == (unsigned long )((void *)0)) {
#line 204
        iret = 5;
#line 205
        (qglobal->qprocess)->fhdb_read_permissions = 1;
#line 206
        goto while_break___0;
      }
      {
#line 208
      *zeq = (char )'\000';
#line 210
      azargs[0] = *(pzsplit + i);
#line 211
      azargs[1] = zeq + 1;
#line 213
      iret = uuconf_cmd_args((void *)qglobal, 2, azargs, (struct uuconf_cmdtab  const  *)(as),
                             (void *)0, & ihunknownperm, 0, qglobal->pblock);
      }
#line 215
      if ((iret & 2048) != 0) {
        {
#line 217
        iret &= -2049;
#line 219
        tmp___3 = uuconf_add_block(qglobal->pblock, (void *)zline);
        }
#line 219
        if (tmp___3 != 0) {
          {
#line 221
          tmp___2 = __errno_location();
#line 221
          qglobal->ierrno = *tmp___2;
#line 222
          iret = 260;
          }
#line 223
          goto while_break___0;
        }
#line 226
        zline = (char *)((void *)0);
#line 227
        cline = (size_t )0;
      }
#line 229
      if ((iret & 4096) != 0) {
#line 231
        iret &= -4097;
#line 232
        goto while_break___0;
      }
#line 196
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    if (iret != 0) {
#line 237
      goto while_break;
    }
#line 239
    if ((unsigned long )shperm.pzmachine == (unsigned long )(& _uuconf_unset)) {
#line 239
      if ((unsigned long )shperm.pzlogname == (unsigned long )(& _uuconf_unset)) {
#line 242
        iret = 5;
#line 243
        (qglobal->qprocess)->fhdb_read_permissions = 1;
#line 244
        goto while_break;
      }
    }
#line 250
    if ((unsigned long )pznoread != (unsigned long )((void *)0)) {
      {
#line 252
      iret = ihadd_norw(qglobal, & shperm.pzread, pznoread);
      }
#line 253
      if (iret != 0) {
#line 254
        goto while_break;
      }
      {
#line 255
      uuconf_free(qglobal->pblock, (void *)pznoread);
      }
    }
#line 258
    if ((unsigned long )pznowrite != (unsigned long )((void *)0)) {
      {
#line 260
      iret = ihadd_norw(qglobal, & shperm.pzwrite, pznowrite);
      }
#line 261
      if (iret != 0) {
#line 262
        goto while_break;
      }
      {
#line 263
      uuconf_free(qglobal->pblock, (void *)pznowrite);
      }
    }
    {
#line 266
    tmp___4 = uuconf_malloc(qglobal->pblock, sizeof(struct shpermissions ));
#line 266
    qnew = (struct shpermissions *)tmp___4;
    }
#line 269
    if ((unsigned long )qnew == (unsigned long )((void *)0)) {
      {
#line 271
      tmp___5 = __errno_location();
#line 271
      qglobal->ierrno = *tmp___5;
#line 272
      iret = 260;
      }
#line 273
      goto while_break;
    }
#line 276
    *qnew = shperm;
#line 277
    *pq = qnew;
#line 278
    pq = & qnew->qnext;
#line 279
    *pq = (struct shpermissions *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  fclose(e);
  }
#line 284
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 285
    free((pointer )zline);
    }
  }
#line 286
  if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
    {
#line 287
    free((pointer )pzsplit);
    }
  }
#line 289
  if (iret == 0) {
#line 291
    (qglobal->qprocess)->qhdb_permissions = qlist;
#line 292
    (qglobal->qprocess)->fhdb_read_permissions = 1;
  } else {
#line 296
    qglobal->zfilename = (char const   *)zperm;
#line 297
    iret |= 1536;
  }
#line 300
  return (iret);
}
}
#line 307 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
static int ihcolon(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                   pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char ***ppz ;
  char **pzsplit ;
  size_t csplit ;
  int centries ;
  int i ;
  int iret ;
  int *tmp ;

  {
  {
#line 315
  qglobal = (struct sglobal *)pglobal;
#line 316
  ppz = (char ***)pvar;
#line 323
  *ppz = (char **)((void *)0);
#line 325
  pzsplit = (char **)((void *)0);
#line 326
  csplit = (size_t )0;
#line 328
  centries = _uuconf_istrsplit(*(argv + 1), ':', & pzsplit, & csplit);
  }
#line 329
  if (centries < 0) {
    {
#line 331
    tmp = __errno_location();
#line 331
    qglobal->ierrno = *tmp;
    }
#line 332
    return (4356);
  }
#line 337
  if (centries == 0) {
#line 339
    if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
      {
#line 340
      free((pointer )pzsplit);
      }
    }
#line 341
    return (0);
  }
#line 344
  iret = 0;
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (i < centries)) {
#line 346
      goto while_break;
    }
    {
#line 348
    iret = _uuconf_iadd_string(qglobal, *(pzsplit + i), 0, 0, ppz, qglobal->pblock);
    }
#line 350
    if (iret != 0) {
#line 352
      iret |= 4096;
#line 353
      goto while_break;
    }
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 357
  free((pointer )pzsplit);
  }
#line 359
  return (2048);
}
}
#line 366 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
static int ihsendfiles(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                       char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  int *pi ;

  {
#line 374
  pi = (int *)pvar;
  {
#line 381
  if ((int )*(*(argv + 1) + 0) == 110) {
#line 381
    goto case_110;
  }
#line 381
  if ((int )*(*(argv + 1) + 0) == 78) {
#line 381
    goto case_110;
  }
#line 381
  if ((int )*(*(argv + 1) + 0) == 99) {
#line 381
    goto case_110;
  }
#line 381
  if ((int )*(*(argv + 1) + 0) == 67) {
#line 381
    goto case_110;
  }
#line 385
  if ((int )*(*(argv + 1) + 0) == 121) {
#line 385
    goto case_121;
  }
#line 385
  if ((int )*(*(argv + 1) + 0) == 89) {
#line 385
    goto case_121;
  }
#line 388
  goto switch_default;
  case_110: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 382
  *pi = 0;
#line 383
  goto switch_break;
  case_121: /* CIL Label */ 
  case_89: /* CIL Label */ 
#line 386
  *pi = 1;
#line 387
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 389
  return (4101);
  switch_break: /* CIL Label */ ;
  }
#line 392
  return (0);
}
}
#line 399 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
static int ihunknownperm(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                         char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                         pointer pinfo  __attribute__((__unused__)) ) 
{ 


  {
#line 407
  return (4101);
}
}
#line 412 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdperm.c"
static int ihadd_norw(struct sglobal *qglobal , char ***ppz , char **pzno ) 
{ 
  register char **pz ;
  size_t csize ;
  char *znew ;
  int iret ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 420
  if ((unsigned long )pzno == (unsigned long )(& _uuconf_unset)) {
#line 421
    return (0);
  }
#line 423
  pz = pzno;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 423
      goto while_break;
    }
#line 432
    if ((int )*(*pz) != 0) {
      {
#line 434
      tmp = strlen((char const   *)*pz);
#line 434
      csize = tmp + 1UL;
#line 435
      tmp___0 = uuconf_malloc(qglobal->pblock, csize + 1UL);
#line 435
      znew = (char *)tmp___0;
      }
#line 436
      if ((unsigned long )znew == (unsigned long )((void *)0)) {
        {
#line 438
        tmp___1 = __errno_location();
#line 438
        qglobal->ierrno = *tmp___1;
        }
#line 439
        return (260);
      }
      {
#line 441
      *(znew + 0) = (char )'!';
#line 442
      memcpy((void */* __restrict  */)((pointer )(znew + 1)), (void const   */* __restrict  */)((pointer )*pz),
             csize);
#line 443
      iret = _uuconf_iadd_string(qglobal, znew, 0, 0, ppz, qglobal->pblock);
      }
#line 445
      if (iret != 0) {
#line 446
        return (iret);
      }
    }
#line 423
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  return (0);
}
}
#line 727 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 1536 "../uuconf.h"
int uuconf_cmd_line(void *pglobal , char *zline , struct uuconf_cmdtab  const  *qtab ,
                    void *pinfo , int (*pfiunknown)(void *uuconf_pglobal , int uuconf_argc ,
                                                    char **uuconf_argv , void *uuconf_pvar ,
                                                    void *uuconf_pinfo ) , int iflags ,
                    void *pblock ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
char const   _uuconf_rdlocs_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'r',      (char const   )'d',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'0', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 33
static int itsystem(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                    pointer pvar , pointer pinfo ) ;
#line 35
static int itcalled_login(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                          pointer pinfo ) ;
#line 37
static int itmyname(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                    pointer pvar  __attribute__((__unused__)) , pointer pinfo  __attribute__((__unused__)) ) ;
#line 51 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
static struct uuconf_cmdtab  const  asTcmds[5]  = {      {"system", 98, (void *)0, & itsystem}, 
        {"alias", 98, (pointer )(asTcmds), & itsystem}, 
        {"called-login", 96, (void *)0, & itcalled_login}, 
        {"myname", 98, (void *)0, & itmyname}, 
        {(char const   *)((void *)0), 0, (void *)0, (int (*)(void *uuconf_pglobal , int uuconf_argc ,
                                                          char **uuconf_argv , void *uuconf_pvar ,
                                                          void *uuconf_pinfo ))((void *)0)}};
#line 82 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
int _uuconf_iread_locations(struct sglobal *qglobal ) 
{ 
  char *zline ;
  size_t cline ;
  struct sinfo___1 si ;
  int iret ;
  char **pz ;
  FILE *e ;
  int cchars ;
  int *tmp ;
  int *tmp___0 ;
  int cle_i ;
  int tmp___1 ;
  int tmp___2 ;
  char *zcmd ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 92
  if ((qglobal->qprocess)->fread_syslocs) {
#line 93
    return (0);
  }
#line 95
  zline = (char *)((void *)0);
#line 96
  cline = (size_t )0;
#line 98
  si.qlocs = (struct stsysloc *)((void *)0);
#line 99
  si.qvals = (struct svalidate *)((void *)0);
#line 101
  iret = 0;
#line 103
  pz = (qglobal->qprocess)->pzsysfiles;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 103
      goto while_break;
    }
    {
#line 108
    qglobal->ilineno = 0;
#line 110
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 111
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 113
      tmp = __errno_location();
      }
#line 113
      if (*tmp == 2) {
#line 114
        goto __Cont;
      }
      {
#line 115
      tmp___0 = __errno_location();
#line 115
      qglobal->ierrno = *tmp___0;
#line 116
      iret = 258;
      }
#line 117
      goto while_break;
    }
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 121
      tmp___1 = fileno(e);
#line 121
      cle_i = tmp___1;
#line 121
      tmp___2 = fcntl(cle_i, 1, 0);
#line 121
      fcntl(cle_i, 2, tmp___2 | 1);
      }
#line 121
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    si.zname = (char const   *)*pz;
#line 125
    si.e = e;
    {
#line 127
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 127
      cchars = _uuconf_getline(qglobal, & zline, & cline, e);
      }
#line 127
      if (! (cchars > 0)) {
#line 127
        goto while_break___1;
      }
      {
#line 131
      (qglobal->ilineno) ++;
#line 133
      tmp___3 = strspn((char const   *)zline, " \t");
#line 133
      zcmd = zline + tmp___3;
#line 134
      tmp___4 = strncasecmp((char const   *)zcmd, "system", sizeof("system") - 1UL);
      }
#line 134
      if (tmp___4 == 0) {
#line 134
        goto _L;
      } else {
        {
#line 134
        tmp___5 = strncasecmp((char const   *)zcmd, "alias", sizeof("alias") - 1UL);
        }
#line 134
        if (tmp___5 == 0) {
#line 134
          goto _L;
        } else {
          {
#line 134
          tmp___6 = strncasecmp((char const   *)zcmd, "called-login", sizeof("called-login") - 1UL);
          }
#line 134
          if (tmp___6 == 0) {
#line 134
            goto _L;
          } else {
            {
#line 134
            tmp___7 = strncasecmp((char const   *)zcmd, "myname", sizeof("myname") - 1UL);
            }
#line 134
            if (tmp___7 == 0) {
              _L: /* CIL Label */ 
              {
#line 140
              iret = uuconf_cmd_line((pointer )qglobal, zline, asTcmds, (pointer )(& si),
                                     (int (*)(void *uuconf_pglobal , int uuconf_argc ,
                                              char **uuconf_argv , void *uuconf_pvar ,
                                              void *uuconf_pinfo ))((void *)0), 0,
                                     qglobal->pblock);
              }
#line 143
              if ((iret & 2048) != 0) {
#line 145
                iret &= -2049;
#line 146
                zline = (char *)((void *)0);
#line 147
                cline = (size_t )0;
              }
#line 149
              if (iret != 0) {
#line 151
                iret &= -4097;
#line 152
                goto while_break___1;
              }
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 157
    if (iret != 0) {
#line 158
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 103
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 162
    free((pointer )zline);
    }
  }
#line 164
  if (iret != 0) {
#line 166
    qglobal->zfilename = (char const   *)*pz;
#line 167
    iret |= 1536;
#line 168
    if ((iret & 255) != 4) {
#line 169
      (qglobal->qprocess)->fread_syslocs = 1;
    }
  } else {
#line 173
    (qglobal->qprocess)->qsyslocs = si.qlocs;
#line 174
    (qglobal->qprocess)->qvalidate = si.qvals;
#line 175
    (qglobal->qprocess)->fread_syslocs = 1;
  }
#line 178
  return (iret);
}
}
#line 185 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
static int itsystem(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                    pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo___1 *qinfo ;
  struct stsysloc *q ;
  size_t csize ;
  void *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 193
  qglobal = (struct sglobal *)pglobal;
#line 194
  qinfo = (struct sinfo___1 *)pinfo;
#line 198
  tmp = uuconf_malloc(qglobal->pblock, sizeof(struct stsysloc ));
#line 198
  q = (struct stsysloc *)tmp;
  }
#line 200
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 202
    tmp___0 = __errno_location();
#line 202
    qglobal->ierrno = *tmp___0;
    }
#line 203
    return (4356);
  }
  {
#line 208
  tmp___1 = strlen((char const   *)*(argv + 1));
#line 208
  csize = tmp___1 + 1UL;
#line 209
  tmp___2 = uuconf_malloc(qglobal->pblock, csize);
#line 209
  q->zname = (char const   *)tmp___2;
  }
#line 210
  if ((unsigned long )q->zname == (unsigned long )((void *)0)) {
    {
#line 212
    tmp___3 = __errno_location();
#line 212
    qglobal->ierrno = *tmp___3;
    }
#line 213
    return (4356);
  }
  {
#line 218
  q->qnext = qinfo->qlocs;
#line 219
  memcpy((void */* __restrict  */)((pointer )q->zname), (void const   */* __restrict  */)((pointer )*(argv + 1)),
         csize);
#line 220
  q->falias = (unsigned long )pvar != (unsigned long )((void *)0);
#line 221
  q->zfile = qinfo->zname;
#line 222
  q->e = qinfo->e;
#line 223
  q->iloc = ftell(qinfo->e);
#line 224
  q->ilineno = qglobal->ilineno;
#line 226
  qinfo->qlocs = q;
  }
#line 228
  return (0);
}
}
#line 236 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
static int itcalled_login(pointer pglobal , int argc , char **argv , pointer pvar  __attribute__((__unused__)) ,
                          pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  struct sinfo___1 *qinfo ;
  register struct svalidate *qval ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int iret ;

  {
#line 244
  qglobal = (struct sglobal *)pglobal;
#line 245
  qinfo = (struct sinfo___1 *)pinfo;
#line 249
  if (argc <= 2) {
#line 250
    return (0);
  }
#line 252
  qval = qinfo->qvals;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! ((unsigned long )qval != (unsigned long )((void *)0))) {
#line 252
      goto while_break;
    }
    {
#line 253
    tmp = strcmp((char const   *)*(argv + 1), qval->zlogname);
    }
#line 253
    if (tmp == 0) {
#line 254
      goto while_break;
    }
#line 252
    qval = qval->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if ((unsigned long )qval == (unsigned long )((void *)0)) {
    {
#line 258
    tmp___0 = uuconf_malloc(qglobal->pblock, sizeof(struct svalidate ));
#line 258
    qval = (struct svalidate *)tmp___0;
    }
#line 260
    if ((unsigned long )qval == (unsigned long )((void *)0)) {
      {
#line 262
      tmp___1 = __errno_location();
#line 262
      qglobal->ierrno = *tmp___1;
      }
#line 263
      return (4356);
    }
#line 268
    qval->qnext = qinfo->qvals;
#line 269
    qval->zlogname = (char const   *)*(argv + 1);
#line 270
    qval->pzmachines = (char **)((void *)0);
#line 272
    qinfo->qvals = qval;
  }
#line 275
  i = 2;
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 275
    if (! (i < argc)) {
#line 275
      goto while_break___0;
    }
    {
#line 279
    iret = _uuconf_iadd_string(qglobal, *(argv + i), 0, 1, & qval->pzmachines, qglobal->pblock);
    }
#line 281
    if (iret != 0) {
#line 282
      return (iret | 4096);
    }
#line 275
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 285
  return (2048);
}
}
#line 292 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/rdlocs.c"
static int itmyname(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                    pointer pvar  __attribute__((__unused__)) , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;

  {
#line 300
  qglobal = (struct sglobal *)pglobal;
#line 302
  (qglobal->qprocess)->fuses_myname = 1;
#line 303
  return (0);
}
}
#line 903 "../uuconf.h"
int uuconf_pubdir(void *pglobal , char const   **pzpub ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/pubdir.c"
char const   _uuconf_pubdir_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/pubdir.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'u',      (char const   )'b', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/pubdir.c"
int uuconf_pubdir(void *pglobal , char const   **pzpub ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzpub = (qglobal->qprocess)->zpubdir;
#line 41
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/prtsub.c"
char const   _uuconf_prtsub_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/prtsub.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'t', 
        (char const   )'s',      (char const   )'u',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/prtsub.c"
void _uuconf_uclear_port(struct uuconf_port *qport ) 
{ 


  {
#line 39
  qport->uuconf_zname = (char *)((void *)0);
#line 40
  qport->uuconf_ttype = (enum uuconf_porttype )0;
#line 41
  qport->uuconf_zprotocols = (char *)((void *)0);
#line 42
  qport->uuconf_qproto_params = (struct uuconf_proto_param *)((void *)0);
#line 47
  qport->uuconf_ireliable = 22;
#line 51
  qport->uuconf_zlockname = (char *)((void *)0);
#line 52
  qport->uuconf_palloc = (void *)0;
#line 53
  return;
}
}
#line 821 "../uuconf.h"
int uuconf_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud ,
                     int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) , void *pinfo ,
                     struct uuconf_port *qport ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/port.c"
char const   _uuconf_port_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/port.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'7',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/port.c"
int uuconf_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud ,
                     int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) , void *pinfo ,
                     struct uuconf_port *qport ) 
{ 
  int iret ;

  {
  {
#line 49
  iret = uuconf_taylor_find_port(pglobal, zname, ibaud, ihighbaud, pifn, pinfo, qport);
  }
#line 51
  if (iret != 1) {
#line 52
    return (iret);
  }
#line 75
  return (1);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/paramc.c"
char const   _uuconf_paramc_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/paramc.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'m',      (char const   )'c',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/paramc.c"
int _uuconf_iadd_proto_param(struct sglobal *qglobal , int argc , char **argv , struct uuconf_proto_param **pqparam ,
                             pointer pblock ) 
{ 
  struct uuconf_proto_param *q ;
  size_t c ;
  struct uuconf_proto_param_entry *qentry ;
  void *tmp ;
  int *tmp___0 ;
  struct uuconf_proto_param *qnew ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  struct uuconf_proto_param_entry *qnewent ;
  void *tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;

  {
#line 49
  if (argc < 2) {
#line 50
    return (4101);
  }
#line 53
  if ((int )*(*(argv + 0) + 1) != 0) {
#line 54
    return (4101);
  }
#line 56
  if ((unsigned long )*pqparam == (unsigned long )((void *)0)) {
    {
#line 58
    tmp = uuconf_malloc(pblock, 2UL * sizeof(struct uuconf_proto_param ));
#line 58
    *pqparam = (struct uuconf_proto_param *)tmp;
    }
#line 61
    if ((unsigned long )*pqparam == (unsigned long )((void *)0)) {
      {
#line 63
      tmp___0 = __errno_location();
#line 63
      qglobal->ierrno = *tmp___0;
      }
#line 64
      return (4356);
    }
#line 68
    (*pqparam + 1)->uuconf_bproto = '\000';
#line 69
    q = *pqparam;
#line 70
    q->uuconf_bproto = (int )*(*(argv + 0) + 0);
#line 71
    q->uuconf_qentries = (struct uuconf_proto_param_entry *)((void *)0);
  } else {
#line 75
    c = (size_t )0;
#line 76
    q = *pqparam;
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
#line 76
      if (! (q->uuconf_bproto != 0)) {
#line 76
        goto while_break;
      }
#line 78
      if (q->uuconf_bproto == (int )*(*(argv + 0) + 0)) {
#line 79
        goto while_break;
      }
#line 80
      c ++;
#line 76
      q ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    if (q->uuconf_bproto == 0) {
      {
#line 87
      tmp___1 = uuconf_malloc(pblock, (c + 2UL) * sizeof(struct uuconf_proto_param ));
#line 87
      qnew = (struct uuconf_proto_param *)tmp___1;
      }
#line 91
      if ((unsigned long )qnew == (unsigned long )((void *)0)) {
        {
#line 93
        tmp___2 = __errno_location();
#line 93
        qglobal->ierrno = *tmp___2;
        }
#line 94
        return (4356);
      }
      {
#line 99
      memcpy((void */* __restrict  */)((pointer )qnew), (void const   */* __restrict  */)((pointer )*pqparam),
             c * sizeof(struct uuconf_proto_param ));
#line 101
      (qnew + (c + 1UL))->uuconf_bproto = '\000';
#line 103
      uuconf_free(pblock, (void *)*pqparam);
#line 104
      *pqparam = qnew;
#line 106
      q = qnew + c;
#line 107
      q->uuconf_bproto = (int )*(*(argv + 0) + 0);
#line 108
      q->uuconf_qentries = (struct uuconf_proto_param_entry *)((void *)0);
      }
    }
  }
#line 112
  if ((unsigned long )q->uuconf_qentries == (unsigned long )((void *)0)) {
    {
#line 114
    tmp___3 = uuconf_malloc(pblock, 2UL * sizeof(struct uuconf_proto_param_entry ));
#line 114
    qentry = (struct uuconf_proto_param_entry *)tmp___3;
    }
#line 117
    if ((unsigned long )qentry == (unsigned long )((void *)0)) {
      {
#line 119
      tmp___4 = __errno_location();
#line 119
      qglobal->ierrno = *tmp___4;
      }
#line 120
      return (4356);
    }
#line 125
    (qentry + 1)->uuconf_cargs = 0;
#line 126
    q->uuconf_qentries = qentry;
  } else {
#line 132
    c = (size_t )0;
#line 133
    qentry = q->uuconf_qentries;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      if (! (qentry->uuconf_cargs != 0)) {
#line 133
        goto while_break___0;
      }
#line 134
      c ++;
#line 133
      qentry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 136
    tmp___5 = uuconf_malloc(pblock, (c + 2UL) * sizeof(struct uuconf_proto_param_entry ));
#line 136
    qnewent = (struct uuconf_proto_param_entry *)tmp___5;
    }
#line 140
    if ((unsigned long )qnewent == (unsigned long )((void *)0)) {
      {
#line 142
      tmp___6 = __errno_location();
#line 142
      qglobal->ierrno = *tmp___6;
      }
#line 143
      return (4356);
    }
    {
#line 148
    memcpy((void */* __restrict  */)((pointer )qnewent), (void const   */* __restrict  */)((pointer )q->uuconf_qentries),
           c * sizeof(struct uuconf_proto_param_entry ));
#line 150
    (qnewent + (c + 1UL))->uuconf_cargs = 0;
#line 152
    uuconf_free(pblock, (void *)q->uuconf_qentries);
#line 153
    q->uuconf_qentries = qnewent;
#line 155
    qentry = qnewent + c;
    }
  }
  {
#line 158
  qentry->uuconf_cargs = argc - 1;
#line 159
  tmp___7 = uuconf_malloc(pblock, (unsigned long )(argc - 1) * sizeof(char *));
#line 159
  qentry->uuconf_pzargs = (char **)tmp___7;
  }
#line 162
  if ((unsigned long )qentry->uuconf_pzargs == (unsigned long )((void *)0)) {
    {
#line 164
    tmp___8 = __errno_location();
#line 164
    qglobal->ierrno = *tmp___8;
#line 165
    qentry->uuconf_cargs = 0;
    }
#line 166
    return (4356);
  }
  {
#line 170
  memcpy((void */* __restrict  */)((pointer )qentry->uuconf_pzargs), (void const   */* __restrict  */)((pointer )(argv + 1)),
         (unsigned long )(argc - 1) * sizeof(char *));
  }
#line 173
  return (2048);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/mrgblk.c"
char const   _uuconf_mrgblk_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/mrgblk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'r',      (char const   )'g', 
        (char const   )'b',      (char const   )'l',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/mrgblk.c"
pointer _uuconf_pmalloc_block_merge(pointer p1 , pointer p2 ) 
{ 
  struct sblock *q1 ;
  struct sblock *q2 ;
  struct sblock **pq ;

  {
#line 41
  q1 = (struct sblock *)p1;
#line 42
  q2 = (struct sblock *)p2;
#line 45
  pq = & q1;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 45
      goto while_break;
    }
#line 45
    pq = & (*pq)->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  *pq = q2;
#line 48
  return ((pointer )q1);
}
}
#line 940 "../uuconf.h"
int uuconf_maxuuxqts(void *pglobal , int *pcmax ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/maxuxq.c"
char const   _uuconf_maxuxq_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/maxuxq.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'u',      (char const   )'x',      (char const   )'q',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/maxuxq.c"
int uuconf_maxuuxqts(void *pglobal , int *pcmax ) 
{ 
  struct sglobal *qglobal ;

  {
#line 43
  qglobal = (struct sglobal *)pglobal;
#line 45
  *pcmax = (qglobal->qprocess)->cmaxuuxqts;
#line 46
  return (0);
}
}
#line 913 "../uuconf.h"
int uuconf_logfile(void *pglobal , char const   **pzlog ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/logfil.c"
char const   _uuconf_logfil_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/logfil.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'g', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/logfil.c"
int uuconf_logfile(void *pglobal , char const   **pzlog ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzlog = (qglobal->qprocess)->zlogfile;
#line 41
  return (0);
}
}
#line 878 "../uuconf.h"
int uuconf_localname(void *pglobal , char const   **pzname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/locnm.c"
char const   _uuconf_locnm_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/locnm.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'n',      (char const   )'m',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'7',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/locnm.c"
int uuconf_localname(void *pglobal , char const   **pzname ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzname = (qglobal->qprocess)->zlocalname;
#line 41
  if ((unsigned long )*pzname != (unsigned long )((void *)0)) {
#line 42
    return (0);
  } else {
#line 44
    return (1);
  }
}
}
#line 777 "../uuconf.h"
int uuconf_system_local(void *pglobal , struct uuconf_system *qsys ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/local.c"
char const   _uuconf_local_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/local.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'7',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/local.c"
int uuconf_system_local(void *pglobal , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 40
  qglobal = (struct sglobal *)pglobal;
#line 43
  _uuconf_uclear_system(qsys);
#line 44
  qsys->uuconf_palloc = uuconf_malloc_block();
  }
#line 45
  if ((unsigned long )qsys->uuconf_palloc == (unsigned long )((void *)0)) {
    {
#line 47
    tmp = __errno_location();
#line 47
    qglobal->ierrno = *tmp;
    }
#line 48
    return (260);
  }
  {
#line 51
  qsys->uuconf_zname = (char *)(qglobal->qprocess)->zlocalname;
#line 55
  iret = _uuconf_iadd_string(qglobal, (char *)"ANY", 0, 0, & qsys->uuconf_pzforward_from,
                             qsys->uuconf_palloc);
  }
#line 58
  if (iret == 0) {
    {
#line 59
    iret = _uuconf_iadd_string(qglobal, (char *)"ANY", 0, 0, & qsys->uuconf_pzforward_to,
                               qsys->uuconf_palloc);
    }
  }
#line 62
  if (iret != 0) {
    {
#line 64
    uuconf_free_block(qsys->uuconf_palloc);
    }
#line 65
    return (iret);
  }
  {
#line 68
  tmp___0 = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 68
  return (tmp___0);
}
}
#line 891 "../uuconf.h"
int uuconf_login_localname(void *pglobal , char const   *zlogin , char **pzname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/llocnm.c"
char const   _uuconf_llocnm_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/llocnm.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'n',      (char const   )'m',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'9',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/llocnm.c"
int uuconf_login_localname(void *pglobal , char const   *zlogin , char **pzname ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  int *tmp ;

  {
  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 45
  iret = uuconf_taylor_login_localname(pglobal, zlogin, pzname);
  }
#line 46
  if (iret != 1) {
#line 47
    return (iret);
  }
#line 59
  if ((unsigned long )(qglobal->qprocess)->zlocalname != (unsigned long )((void *)0)) {
    {
#line 61
    *pzname = strdup((char const   *)((char *)(qglobal->qprocess)->zlocalname));
    }
#line 62
    if ((unsigned long )*pzname == (unsigned long )((void *)0)) {
      {
#line 64
      tmp = __errno_location();
#line 64
      qglobal->ierrno = *tmp;
      }
#line 65
      return (260);
    }
#line 67
    return (0);
  }
#line 70
  *pzname = (char *)((void *)0);
#line 71
  return (1);
}
}
#line 1327 "../uuconf.h"
int uuconf_error_lineno(void *pglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/lineno.c"
char const   _uuconf_lineno_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/lineno.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'n',      (char const   )'o',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/lineno.c"
int uuconf_error_lineno(void *pglobal ) 
{ 
  struct sglobal *qglobal ;

  {
#line 37
  qglobal = (struct sglobal *)pglobal;
#line 39
  if ((unsigned long )qglobal == (unsigned long )((void *)0)) {
#line 40
    return (0);
  } else {
#line 42
    return (qglobal->ilineno);
  }
}
}
#line 908 "../uuconf.h"
int uuconf_lockdir(void *pglobal , char const   **pzlock ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/lckdir.c"
char const   _uuconf_lckdir_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/lckdir.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'c',      (char const   )'k', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/lckdir.c"
int uuconf_lockdir(void *pglobal , char const   **pzlock ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzlock = (qglobal->qprocess)->zlockdir;
#line 41
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/int.c"
char const   _uuconf_int_rcsid[47]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/int.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'9', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/int.c"
int _uuconf_iint(struct sglobal *qglobal  __attribute__((__unused__)) , char const   *zval ,
                 pointer p , boolean fint ) 
{ 
  long i ;
  char *zend ;

  {
  {
#line 48
  i = strtol((char const   */* __restrict  */)((char *)zval), (char **/* __restrict  */)(& zend),
             10);
  }
#line 49
  if ((int )*zend != 0) {
#line 50
    return (4101);
  }
#line 52
  if (fint) {
#line 53
    *((int *)p) = (int )i;
  } else {
#line 55
    *((long *)p) = i;
  }
#line 57
  return (0);
}
}
#line 733 "../uuconf.h"
int uuconf_init(void **ppglobal , char const   *zprogram , char const   *zname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/init.c"
char const   _uuconf_init_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/init.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'i', 
        (char const   )'t',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'8',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/init.c"
int uuconf_init(void **ppglobal , char const   *zprogram , char const   *zname ) 
{ 
  struct sglobal **pqglob ;
  int iret ;

  {
  {
#line 41
  pqglob = (struct sglobal **)ppglobal;
#line 44
  iret = 1;
#line 46
  *pqglob = (struct sglobal *)((void *)0);
#line 49
  iret = uuconf_taylor_init(ppglobal, zprogram, zname);
  }
#line 50
  if (iret != 0) {
#line 51
    return (iret);
  }
#line 72
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/iniglb.c"
char const   _uuconf_iniglb_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/iniglb.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'i', 
        (char const   )'g',      (char const   )'l',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'4', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/iniglb.c"
int _uuconf_iinit_global(struct sglobal **pqglobal ) 
{ 
  pointer pblock ;
  register struct sprocess *qprocess ;
  char *azargs[3] ;
  int iret ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 44
  pblock = uuconf_malloc_block();
  }
#line 45
  if ((unsigned long )pblock == (unsigned long )((void *)0)) {
#line 46
    return (4);
  }
  {
#line 48
  tmp = uuconf_malloc(pblock, sizeof(struct sglobal ));
#line 48
  *pqglobal = (struct sglobal *)tmp;
  }
#line 50
  if ((unsigned long )*pqglobal == (unsigned long )((void *)0)) {
    {
#line 52
    uuconf_free_block(pblock);
    }
#line 53
    return (4);
  }
  {
#line 56
  tmp___0 = uuconf_malloc(pblock, sizeof(struct sprocess ));
#line 56
  (*pqglobal)->qprocess = (struct sprocess *)tmp___0;
  }
#line 59
  if ((unsigned long )(*pqglobal)->qprocess == (unsigned long )((void *)0)) {
    {
#line 61
    uuconf_free_block(pblock);
#line 62
    *pqglobal = (struct sglobal *)((void *)0);
    }
#line 63
    return (4);
  }
  {
#line 66
  (*pqglobal)->pblock = pblock;
#line 67
  (*pqglobal)->ierrno = 0;
#line 68
  (*pqglobal)->ilineno = 0;
#line 69
  (*pqglobal)->zfilename = (char const   *)((void *)0);
#line 71
  qprocess = (*pqglobal)->qprocess;
#line 73
  qprocess->zlocalname = (char const   *)((void *)0);
#line 74
  qprocess->zspooldir = "/usr/spool/uucp";
#line 75
  qprocess->zpubdir = "/usr/spool/uucppublic";
#line 79
  qprocess->zlockdir = "/usr/spool/uucp";
#line 81
  qprocess->zlogfile = "/usr/spool/uucp/Log";
#line 82
  qprocess->zstatsfile = "/usr/spool/uucp/Stats";
#line 83
  qprocess->zdebugfile = "/usr/spool/uucp/Debug";
#line 84
  qprocess->zdebug = "";
#line 85
  qprocess->fstrip_login = 1;
#line 86
  qprocess->fstrip_proto = 1;
#line 87
  qprocess->cmaxuuxqts = 0;
#line 88
  qprocess->zrunuuxqt = (char const   *)((void *)0);
#line 89
  qprocess->fv2 = 1;
#line 90
  qprocess->fhdb = 1;
#line 91
  qprocess->pzdialcodefiles = (char **)((void *)0);
#line 92
  qprocess->pztimetables = (char **)((void *)0);
#line 93
  qprocess->zconfigfile = (char *)((void *)0);
#line 94
  qprocess->pzsysfiles = (char **)((void *)0);
#line 95
  qprocess->pzportfiles = (char **)((void *)0);
#line 96
  qprocess->pzdialfiles = (char **)((void *)0);
#line 97
  qprocess->pzpwdfiles = (char **)((void *)0);
#line 98
  qprocess->pzcallfiles = (char **)((void *)0);
#line 99
  qprocess->qunknown = (struct sunknown *)((void *)0);
#line 100
  qprocess->fread_syslocs = 0;
#line 101
  qprocess->qsyslocs = (struct stsysloc *)((void *)0);
#line 102
  qprocess->qvalidate = (struct svalidate *)((void *)0);
#line 103
  qprocess->fuses_myname = 0;
#line 104
  qprocess->zv2systems = (char *)((void *)0);
#line 105
  qprocess->zv2devices = (char *)((void *)0);
#line 106
  qprocess->zv2userfile = (char *)((void *)0);
#line 107
  qprocess->zv2cmds = (char *)((void *)0);
#line 108
  qprocess->pzhdb_systems = (char **)((void *)0);
#line 109
  qprocess->pzhdb_devices = (char **)((void *)0);
#line 110
  qprocess->pzhdb_dialers = (char **)((void *)0);
#line 111
  qprocess->fhdb_read_permissions = 0;
#line 112
  qprocess->qhdb_permissions = (struct shpermissions *)((void *)0);
#line 114
  azargs[0] = (char *)((void *)0);
#line 115
  azargs[1] = (char *)"Evening";
#line 116
  azargs[2] = (char *)"Wk1705-0755,Sa,Su";
#line 117
  iret = _uuconf_itimetable((pointer )*pqglobal, 3, azargs, (void *)0, (void *)0);
  }
#line 119
  if ((iret & 255) == 0) {
    {
#line 121
    azargs[1] = (char *)"Night";
#line 122
    azargs[2] = (char *)"Wk2305-0755,Sa,Su2305-1655";
#line 123
    iret = _uuconf_itimetable((pointer )*pqglobal, 3, azargs, (void *)0, (void *)0);
    }
  }
#line 126
  if ((iret & 255) == 0) {
    {
#line 128
    azargs[1] = (char *)"NonPeak";
#line 129
    azargs[2] = (char *)"Wk1805-0655,Sa,Su";
#line 130
    iret = _uuconf_itimetable((pointer )*pqglobal, 3, azargs, (void *)0, (void *)0);
    }
  }
#line 133
  if ((iret & 255) != 0) {
    {
#line 135
    uuconf_free_block(pblock);
#line 136
    *pqglobal = (struct sglobal *)((void *)0);
    }
#line 140
    return (iret & 255);
  }
#line 143
  return (0);
}
}
#line 155 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/iniglb.c"
int _uuconf_itimetable(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                       pointer pvar  __attribute__((__unused__)) , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  int iret ;

  {
  {
#line 163
  qglobal = (struct sglobal *)pglobal;
#line 166
  iret = _uuconf_iadd_string(qglobal, *(argv + 1), 0, 0, & (qglobal->qprocess)->pztimetables,
                             qglobal->pblock);
  }
#line 169
  if (iret != 0) {
#line 170
    return (iret | 4096);
  }
  {
#line 172
  iret = _uuconf_iadd_string(qglobal, *(argv + 2), 0, 0, & (qglobal->qprocess)->pztimetables,
                             qglobal->pblock);
  }
#line 175
  if (iret != 0) {
#line 176
    return (iret | 4096);
  }
#line 178
  return (2048);
}
}
#line 1241 "../uuconf.h"
int uuconf_hdb_system_unknown(void *pglobal , struct uuconf_system *qsys ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hunk.c"
char const   _uuconf_hunk_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hunk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'u',      (char const   )'n', 
        (char const   )'k',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'7',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hunk.c"
int uuconf_hdb_system_unknown(void *pglobal , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  boolean ffirst ;
  struct shpermissions *qperm ;
  struct uuconf_system *qalt ;
  int *tmp ;
  char **pz ;
  struct uuconf_system **pq ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 42
  qglobal = (struct sglobal *)pglobal;
#line 48
  if (! (qglobal->qprocess)->fhdb_read_permissions) {
    {
#line 50
    iret = _uuconf_ihread_permissions(qglobal);
    }
#line 51
    if (iret != 0) {
#line 52
      return (iret);
    }
  }
  {
#line 55
  _uuconf_uclear_system(qsys);
#line 56
  qsys->uuconf_palloc = uuconf_malloc_block();
  }
#line 57
  if ((unsigned long )qsys->uuconf_palloc == (unsigned long )((void *)0)) {
    {
#line 59
    tmp = __errno_location();
#line 59
    qglobal->ierrno = *tmp;
    }
#line 60
    return (260);
  }
#line 63
  ffirst = 1;
#line 65
  qperm = (qglobal->qprocess)->qhdb_permissions;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )qperm != (unsigned long )((void *)0))) {
#line 65
      goto while_break;
    }
#line 71
    if ((unsigned long )qperm->pzlogname == (unsigned long )((void *)0)) {
#line 73
      goto __Cont;
    } else
#line 71
    if ((unsigned long )qperm->pzlogname == (unsigned long )(& _uuconf_unset)) {
#line 73
      goto __Cont;
    }
#line 75
    pz = qperm->pzlogname;
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 75
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 75
        goto while_break___0;
      }
#line 77
      if (ffirst) {
#line 79
        qalt = qsys;
#line 80
        ffirst = 0;
      } else {
        {
#line 86
        tmp___0 = uuconf_malloc(qsys->uuconf_palloc, sizeof(struct uuconf_system ));
#line 86
        qalt = (struct uuconf_system *)tmp___0;
        }
#line 89
        if ((unsigned long )qalt == (unsigned long )((void *)0)) {
          {
#line 91
          tmp___1 = __errno_location();
#line 91
          qglobal->ierrno = *tmp___1;
          }
#line 92
          return (260);
        }
        {
#line 95
        _uuconf_uclear_system(qalt);
#line 96
        pq = & qsys->uuconf_qalternate;
        }
        {
#line 96
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 96
          if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 96
            goto while_break___1;
          }
#line 96
          pq = & (*pq)->uuconf_qalternate;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 100
        *pq = qalt;
      }
      {
#line 105
      tmp___2 = strcmp((char const   *)*pz, "OTHER");
      }
#line 105
      if (tmp___2 == 0) {
#line 106
        qalt->uuconf_zcalled_login = (char *)"ANY";
      } else {
#line 108
        qalt->uuconf_zcalled_login = *pz;
      }
#line 109
      qalt->uuconf_fcall = 0;
#line 110
      qsys->uuconf_fcalled = 1;
#line 111
      if (qperm->frequest >= 0) {
#line 112
        qsys->uuconf_fsend_request = qperm->frequest;
      } else {
#line 114
        qsys->uuconf_fsend_request = 0;
      }
#line 115
      qsys->uuconf_fcalled_transfer = qperm->fsendfiles;
#line 116
      qsys->uuconf_pzremote_send = qperm->pzread;
#line 117
      qsys->uuconf_pzremote_receive = qperm->pzwrite;
#line 118
      qsys->uuconf_fcallback = qperm->fcallback;
#line 119
      qsys->uuconf_zlocalname = qperm->zmyname;
#line 120
      qsys->uuconf_zpubdir = qperm->zpubdir;
#line 75
      pz ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 65
    qperm = qperm->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (ffirst) {
#line 125
    return (1);
  }
#line 130
  qalt = qsys;
  {
#line 130
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )qalt != (unsigned long )((void *)0))) {
#line 130
      goto while_break___2;
    }
    {
#line 132
    iret = _uuconf_iadd_string(qglobal, (char *)"/", 0, 0, & qalt->uuconf_pzlocal_receive,
                               qsys->uuconf_palloc);
    }
#line 136
    if (iret != 0) {
#line 137
      return (iret);
    }
#line 130
    qalt = qalt->uuconf_qalternate;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 140
  tmp___3 = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 140
  return (tmp___3);
}
}
#line 1232 "../uuconf.h"
int uuconf_hdb_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) ;
#line 299 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
int _uuconf_ihdb_system_internal(struct sglobal *qglobal , char const   *zsystem ,
                                 struct uuconf_system *qsys ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsys.c"
char const   _uuconf_hsys_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsys.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'s',      (char const   )'y', 
        (char const   )'s',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'6',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsys.c"
int uuconf_hdb_system_info(void *pglobal , char const   *zsystem , struct uuconf_system *qsys ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  int tmp ;

  {
  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 44
  iret = _uuconf_ihdb_system_internal(qglobal, zsystem, qsys);
  }
#line 45
  if (iret != 0) {
#line 46
    return (iret);
  }
  {
#line 47
  tmp = _uuconf_isystem_basic_default(qglobal, qsys);
  }
#line 47
  return (tmp);
}
}
#line 1226 "../uuconf.h"
int uuconf_hdb_system_names(void *pglobal , char ***ppzsystems , int falias ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsnams.c"
char const   _uuconf_hsnams_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsnams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'s',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsnams.c"
int uuconf_hdb_system_names(void *pglobal , char ***ppzsystems , int falias ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  char *zline ;
  size_t cline ;
  char **pz ;
  FILE *e ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  struct shpermissions *q ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 43
  qglobal = (struct sglobal *)pglobal;
#line 49
  *ppzsystems = (char **)((void *)0);
#line 51
  iret = 0;
#line 53
  zline = (char *)((void *)0);
#line 54
  cline = (size_t )0;
#line 56
  pz = (qglobal->qprocess)->pzhdb_systems;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 56
      goto while_break;
    }
    {
#line 60
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 61
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 63
      tmp = __errno_location();
      }
#line 63
      if (*tmp == 2) {
#line 64
        goto __Cont;
      }
      {
#line 65
      tmp___0 = __errno_location();
#line 65
      qglobal->ierrno = *tmp___0;
#line 66
      iret = 258;
      }
#line 67
      goto while_break;
    }
#line 70
    qglobal->ilineno = 0;
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 72
      tmp___2 = _uuconf_getline(qglobal, & zline, & cline, e);
      }
#line 72
      if (! (tmp___2 > 0)) {
#line 72
        goto while_break___0;
      }
      {
#line 74
      (qglobal->ilineno) ++;
#line 80
      tmp___1 = strcspn((char const   *)zline, " \t#\n");
#line 80
      *(zline + tmp___1) = (char )'\000';
      }
#line 81
      if ((int )*zline == 0) {
#line 82
        goto while_continue___0;
      }
      {
#line 84
      iret = _uuconf_iadd_string(qglobal, zline, 1, 1, ppzsystems, (void *)0);
      }
#line 86
      if (iret != 0) {
#line 88
        iret |= 1024;
#line 89
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 93
    fclose(e);
    }
    __Cont: /* CIL Label */ 
#line 56
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 97
    free((pointer )zline);
    }
  }
#line 99
  if (iret != 0) {
#line 101
    qglobal->zfilename = (char const   *)*pz;
#line 102
    return (iret | 512);
  }
#line 107
  if (falias) {
#line 111
    if (! (qglobal->qprocess)->fhdb_read_permissions) {
      {
#line 113
      iret = _uuconf_ihread_permissions(qglobal);
      }
#line 114
      if (iret != 0) {
#line 115
        return (iret);
      }
    }
#line 118
    q = (qglobal->qprocess)->qhdb_permissions;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 118
        goto while_break___1;
      }
#line 122
      pz = q->pzalias;
#line 123
      if ((unsigned long )pz == (unsigned long )((void *)0)) {
#line 124
        goto __Cont___0;
      } else
#line 123
      if ((unsigned long )pz == (unsigned long )(& _uuconf_unset)) {
#line 124
        goto __Cont___0;
      }
      {
#line 126
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 126
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 126
          goto while_break___2;
        }
        {
#line 128
        iret = _uuconf_iadd_string(qglobal, *pz, 1, 1, ppzsystems, (void *)0);
        }
#line 130
        if (iret != 0) {
#line 131
          return (iret);
        }
#line 126
        pz ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 118
      q = q->qnext;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 136
  if ((unsigned long )*ppzsystems == (unsigned long )((void *)0)) {
    {
#line 137
    iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzsystems, (void *)0);
    }
  }
#line 140
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsinfo.c"
char const   _uuconf_hsinfo_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsinfo.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'s',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'7', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 34
static int ihadd_machine_perm(struct sglobal *qglobal  __attribute__((__unused__)) ,
                              struct uuconf_system *qsys , struct shpermissions *qperm ) ;
#line 37
static int ihadd_logname_perm(struct sglobal *qglobal  __attribute__((__unused__)) ,
                              struct uuconf_system *qsys , struct shpermissions *qperm ) ;
#line 45 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsinfo.c"
int _uuconf_ihdb_system_internal(struct sglobal *qglobal , char const   *zsystem ,
                                 struct uuconf_system *qsys ) 
{ 
  int iret ;
  struct shpermissions *qperm ;
  char *zline ;
  size_t cline ;
  char **pzsplit ;
  size_t csplit ;
  char **pzcomma ;
  size_t ccomma ;
  pointer pblock ;
  char **pz ;
  boolean ffound_machine ;
  boolean ffound_login ;
  struct shpermissions *qother_machine ;
  struct uuconf_system *qalt ;
  int tmp ;
  FILE *e ;
  int cchars ;
  int *tmp___0 ;
  int *tmp___1 ;
  int ctoks ;
  int ctimes ;
  int i ;
  struct uuconf_system *qset ;
  char *z ;
  char *zretry ;
  int cretry ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  struct uuconf_system **pq ;
  void *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int *tmp___11 ;
  char *zslash ;
  char bgrade ;
  unsigned short const   **tmp___12 ;
  char *zend ;
  unsigned short const   **tmp___13 ;
  size_t cport ;
  size_t cclass ;
  void *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  boolean fmachine ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct uuconf_system *qnew ;
  struct uuconf_system **pq___0 ;
  void *tmp___21 ;
  int *tmp___22 ;
  struct uuconf_system *qnew___0 ;
  struct uuconf_system **pq___1 ;
  void *tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
#line 65
  if (! (qglobal->qprocess)->fhdb_read_permissions) {
    {
#line 67
    iret = _uuconf_ihread_permissions(qglobal);
    }
#line 68
    if (iret != 0) {
#line 69
      return (iret);
    }
  }
#line 76
  qperm = (qglobal->qprocess)->qhdb_permissions;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )qperm != (unsigned long )((void *)0))) {
#line 76
      goto while_break;
    }
#line 80
    if ((unsigned long )qperm->pzalias == (unsigned long )((void *)0)) {
#line 84
      goto __Cont;
    } else
#line 80
    if ((unsigned long )qperm->pzmachine == (unsigned long )((void *)0)) {
#line 84
      goto __Cont;
    } else
#line 80
    if ((unsigned long )qperm->pzalias == (unsigned long )(& _uuconf_unset)) {
#line 84
      goto __Cont;
    } else
#line 80
    if ((unsigned long )qperm->pzmachine == (unsigned long )(& _uuconf_unset)) {
#line 84
      goto __Cont;
    }
#line 86
    pz = qperm->pzalias;
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 86
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 86
        goto while_break___0;
      }
      {
#line 88
      tmp = strcmp((char const   *)*pz, zsystem);
      }
#line 88
      if (tmp == 0) {
#line 90
        zsystem = (char const   *)*(qperm->pzmachine + 0);
#line 91
        goto while_break___0;
      }
#line 86
      pz ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if ((unsigned long )*pz != (unsigned long )((void *)0)) {
#line 95
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 76
    qperm = qperm->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  zline = (char *)((void *)0);
#line 99
  cline = (size_t )0;
#line 100
  pzsplit = (char **)((void *)0);
#line 101
  csplit = (size_t )0;
#line 102
  pzcomma = (char **)((void *)0);
#line 103
  ccomma = (size_t )0;
#line 105
  pblock = (void *)0;
#line 107
  iret = 0;
#line 109
  pz = (qglobal->qprocess)->pzhdb_systems;
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 109
      goto while_break___1;
    }
    {
#line 114
    qglobal->ilineno = 0;
#line 116
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 117
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 2) {
#line 120
        goto __Cont___0;
      }
      {
#line 121
      tmp___1 = __errno_location();
#line 121
      qglobal->ierrno = *tmp___1;
#line 122
      iret = 258;
      }
#line 123
      goto while_break___1;
    }
    {
#line 126
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 126
      cchars = _uuconf_getline(qglobal, & zline, & cline, e);
      }
#line 126
      if (! (cchars > 0)) {
#line 126
        goto while_break___2;
      }
#line 133
      (qglobal->ilineno) ++;
#line 135
      cchars --;
#line 136
      if ((int )*(zline + cchars) == 10) {
#line 137
        *(zline + cchars) = (char )'\000';
      }
      {
#line 138
      tmp___2 = __ctype_b_loc();
      }
#line 138
      if ((int const   )*(*tmp___2 + (int )((unsigned char )*(zline + 0))) & 8192) {
#line 139
        goto while_continue___2;
      } else
#line 138
      if ((int )*(zline + 0) == 35) {
#line 139
        goto while_continue___2;
      }
      {
#line 141
      ctoks = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
      }
#line 142
      if (ctoks < 0) {
        {
#line 144
        tmp___3 = __errno_location();
#line 144
        qglobal->ierrno = *tmp___3;
#line 145
        iret = 260;
        }
#line 146
        goto while_break___2;
      }
#line 151
      if (ctoks < 1) {
#line 153
        goto while_continue___2;
      } else {
        {
#line 151
        tmp___4 = strcmp(zsystem, (char const   *)*(pzsplit + 0));
        }
#line 151
        if (tmp___4 != 0) {
#line 153
          goto while_continue___2;
        }
      }
#line 158
      if ((unsigned long )pblock == (unsigned long )((void *)0)) {
        {
#line 160
        pblock = uuconf_malloc_block();
        }
#line 161
        if ((unsigned long )pblock == (unsigned long )((void *)0)) {
          {
#line 163
          tmp___5 = __errno_location();
#line 163
          qglobal->ierrno = *tmp___5;
#line 164
          iret = 260;
          }
#line 165
          goto while_break___2;
        }
        {
#line 167
        _uuconf_uclear_system(qsys);
#line 168
        qsys->uuconf_palloc = pblock;
#line 169
        qset = qsys;
        }
      } else {
        {
#line 175
        tmp___6 = uuconf_malloc(pblock, sizeof(struct uuconf_system ));
#line 175
        qset = (struct uuconf_system *)tmp___6;
        }
#line 177
        if ((unsigned long )qset == (unsigned long )((void *)0)) {
          {
#line 179
          tmp___7 = __errno_location();
#line 179
          qglobal->ierrno = *tmp___7;
#line 180
          iret = 260;
          }
#line 181
          goto while_break___2;
        }
        {
#line 183
        _uuconf_uclear_system(qset);
#line 184
        pq = & qsys->uuconf_qalternate;
        }
        {
#line 184
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 184
          if (! ((unsigned long )*pq != (unsigned long )((void *)0))) {
#line 184
            goto while_break___3;
          }
#line 184
          pq = & (*pq)->uuconf_qalternate;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 188
        *pq = qset;
      }
      {
#line 193
      tmp___9 = uuconf_add_block(pblock, (void *)zline);
      }
#line 193
      if (tmp___9 != 0) {
        {
#line 195
        tmp___8 = __errno_location();
#line 195
        qglobal->ierrno = *tmp___8;
#line 196
        iret = 260;
        }
#line 197
        goto while_break___2;
      }
#line 200
      zline = (char *)((void *)0);
#line 201
      cline = (size_t )0;
#line 211
      qset->uuconf_zname = *(pzsplit + 0);
#line 212
      qset->uuconf_fcall = 1;
#line 213
      qset->uuconf_fcalled = 0;
#line 215
      if (ctoks < 2) {
#line 216
        goto while_continue___2;
      }
      {
#line 220
      zretry = strchr((char const   *)*(pzsplit + 1), ';');
      }
#line 221
      if ((unsigned long )zretry == (unsigned long )((void *)0)) {
#line 222
        cretry = 0;
      } else {
        {
#line 225
        *zretry = (char )'\000';
#line 226
        tmp___10 = strtol((char const   */* __restrict  */)(zretry + 1), (char **/* __restrict  */)((char **)((void *)0)),
                          10);
#line 226
        cretry = (int )tmp___10;
        }
      }
      {
#line 229
      ctimes = _uuconf_istrsplit(*(pzsplit + 1), ',', & pzcomma, & ccomma);
      }
#line 230
      if (ctimes < 0) {
        {
#line 232
        tmp___11 = __errno_location();
#line 232
        qglobal->ierrno = *tmp___11;
#line 233
        iret = 260;
        }
#line 234
        goto while_break___2;
      }
#line 237
      i = 0;
      {
#line 237
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 237
        if (! (i < ctimes)) {
#line 237
          goto while_break___4;
        }
        {
#line 242
        z = *(pzcomma + i);
#line 243
        zslash = strchr((char const   *)z, '/');
        }
#line 244
        if ((unsigned long )zslash == (unsigned long )((void *)0)) {
#line 245
          bgrade = (char )'z';
        } else {
          {
#line 248
          *zslash = (char )'\000';
#line 249
          bgrade = *(zslash + 1);
#line 250
          tmp___12 = __ctype_b_loc();
          }
#line 250
          if (! ((int const   )*(*tmp___12 + (int )((unsigned char )bgrade)) & 8)) {
#line 251
            bgrade = (char )'z';
          }
        }
        {
#line 254
        iret = _uuconf_itime_parse(qglobal, z, (long )bgrade, cretry, & _uuconf_itime_grade_cmp,
                                   & qset->uuconf_qtimegrade, pblock);
        }
#line 262
        if (iret == 5) {
#line 263
          iret = 0;
        }
#line 265
        if (iret != 0) {
#line 266
          goto while_break___4;
        }
#line 270
        if ((int )bgrade != 122) {
#line 271
          qset->uuconf_qcalltimegrade = qset->uuconf_qtimegrade;
        }
#line 237
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 274
      if (iret != 0) {
#line 275
        goto while_break___2;
      }
#line 277
      if (ctoks < 3) {
#line 278
        goto while_continue___2;
      }
      {
#line 282
      qset->uuconf_zport = *(pzsplit + 2);
#line 283
      z = strchr((char const   *)*(pzsplit + 2), ',');
      }
#line 284
      if ((unsigned long )z != (unsigned long )((void *)0)) {
#line 286
        qset->uuconf_zprotocols = z + 1;
#line 287
        *z = (char )'\000';
      }
#line 290
      if (ctoks < 4) {
#line 291
        goto while_continue___2;
      }
      {
#line 297
      z = *(pzsplit + 3);
#line 298
      tmp___16 = strcasecmp((char const   *)z, "Any");
      }
#line 298
      if (tmp___16 != 0) {
        {
#line 298
        tmp___17 = strcmp((char const   *)z, "-");
        }
#line 298
        if (tmp___17 != 0) {
          {
#line 303
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 303
            if ((int )*z != 0) {
              {
#line 303
              tmp___13 = __ctype_b_loc();
              }
#line 303
              if ((int const   )*(*tmp___13 + (int )((unsigned char )*z)) & 2048) {
#line 303
                goto while_break___5;
              }
            } else {
#line 303
              goto while_break___5;
            }
#line 304
            z ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 306
          qset->uuconf_ibaud = strtol((char const   */* __restrict  */)z, (char **/* __restrict  */)(& zend),
                                      10);
          }
#line 307
          if ((int )*zend == 45) {
            {
#line 308
            qset->uuconf_ihighbaud = strtol((char const   */* __restrict  */)(zend + 1),
                                            (char **/* __restrict  */)((char **)((void *)0)),
                                            10);
            }
          }
#line 311
          if ((unsigned long )z != (unsigned long )*(pzsplit + 3)) {
            {
#line 315
            cport = strlen((char const   *)*(pzsplit + 2));
#line 316
            cclass = (size_t )(z - *(pzsplit + 3));
#line 317
            tmp___14 = uuconf_malloc(pblock, (cport + cclass) + 1UL);
#line 317
            qset->uuconf_zport = (char *)tmp___14;
            }
#line 319
            if ((unsigned long )qset->uuconf_zport == (unsigned long )((void *)0)) {
              {
#line 321
              tmp___15 = __errno_location();
#line 321
              qglobal->ierrno = *tmp___15;
#line 322
              iret = 260;
              }
#line 323
              goto while_break___2;
            }
            {
#line 325
            memcpy((void */* __restrict  */)((pointer )qset->uuconf_zport), (void const   */* __restrict  */)((pointer )*(pzsplit + 2)),
                   cport);
#line 327
            memcpy((void */* __restrict  */)((pointer )(qset->uuconf_zport + cport)),
                   (void const   */* __restrict  */)((pointer )*(pzsplit + 3)), cclass);
#line 329
            *(qset->uuconf_zport + (cport + cclass)) = (char )'\000';
            }
          }
        }
      }
#line 333
      if (ctoks < 5) {
#line 334
        goto while_continue___2;
      }
#line 337
      qset->uuconf_zphone = *(pzsplit + 4);
#line 339
      if (ctoks < 6) {
#line 340
        goto while_continue___2;
      }
      {
#line 345
      *(pzsplit + 4) = (char *)"chat";
#line 346
      iret = _uuconf_ichat_cmd(qglobal, ctoks - 4, pzsplit + 4, & qset->uuconf_schat,
                               pblock);
#line 348
      iret &= -2049;
      }
#line 349
      if (iret != 0) {
#line 350
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 353
    fclose(e);
    }
#line 355
    if (iret != 0) {
#line 356
      goto while_break___1;
    }
    __Cont___0: /* CIL Label */ 
#line 109
    pz ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 359
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 360
    free((pointer )zline);
    }
  }
#line 361
  if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
    {
#line 362
    free((pointer )pzsplit);
    }
  }
#line 363
  if ((unsigned long )pzcomma != (unsigned long )((void *)0)) {
    {
#line 364
    free((pointer )pzcomma);
    }
  }
#line 366
  if (iret != 0) {
#line 368
    qglobal->zfilename = (char const   *)*pz;
#line 369
    return ((iret | 512) | 1024);
  }
#line 372
  if ((unsigned long )pblock == (unsigned long )((void *)0)) {
#line 373
    return (1);
  }
#line 381
  ffound_machine = 0;
#line 382
  ffound_login = 0;
#line 383
  qother_machine = (struct shpermissions *)((void *)0);
#line 384
  qperm = (qglobal->qprocess)->qhdb_permissions;
  {
#line 384
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 384
    if (! ((unsigned long )qperm != (unsigned long )((void *)0))) {
#line 384
      goto while_break___6;
    }
#line 393
    if ((unsigned long )qother_machine == (unsigned long )((void *)0)) {
#line 393
      if ((unsigned long )qperm->pzmachine != (unsigned long )((void *)0)) {
#line 393
        if ((unsigned long )qperm->pzmachine != (unsigned long )(& _uuconf_unset)) {
#line 393
          if ((int )*(*(qperm->pzmachine + 0) + 0) == 79) {
            {
#line 393
            tmp___18 = strcmp((char const   *)*(qperm->pzmachine + 0), "OTHER");
            }
#line 393
            if (tmp___18 == 0) {
#line 398
              qother_machine = qperm;
            }
          }
        }
      }
    }
#line 403
    fmachine = 0;
#line 404
    if (! ffound_machine) {
#line 404
      if ((unsigned long )qperm->pzmachine != (unsigned long )((void *)0)) {
#line 404
        if ((unsigned long )qperm->pzmachine != (unsigned long )(& _uuconf_unset)) {
#line 408
          pz = qperm->pzmachine;
          {
#line 408
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 408
            if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 408
              goto while_break___7;
            }
#line 410
            if ((int )*(*pz + 0) == (int )*(zsystem + 0)) {
              {
#line 410
              tmp___19 = strcmp((char const   *)*pz, zsystem);
              }
#line 410
              if (tmp___19 == 0) {
#line 413
                qalt = qsys;
                {
#line 413
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 413
                  if (! ((unsigned long )qalt != (unsigned long )((void *)0))) {
#line 413
                    goto while_break___8;
                  }
#line 417
                  if (qalt->uuconf_fcall) {
                    {
#line 419
                    iret = ihadd_machine_perm(qglobal, qalt, qperm);
                    }
#line 420
                    if (iret != 0) {
#line 421
                      return (iret);
                    }
                  }
#line 413
                  qalt = qalt->uuconf_qalternate;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 425
                fmachine = 1;
#line 426
                ffound_machine = 1;
#line 428
                goto while_break___7;
              }
            }
#line 408
            pz ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
    }
#line 439
    if ((unsigned long )qperm->pzlogname != (unsigned long )((void *)0)) {
#line 439
      if ((unsigned long )qperm->pzlogname != (unsigned long )(& _uuconf_unset)) {
#line 439
        if ((unsigned long )qperm->pzvalidate != (unsigned long )((void *)0)) {
#line 439
          if ((unsigned long )qperm->pzvalidate != (unsigned long )(& _uuconf_unset)) {
#line 444
            pz = qperm->pzvalidate;
            {
#line 444
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 444
              if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 444
                goto while_break___9;
              }
#line 445
              if ((int )*(*pz + 0) == (int )*(zsystem + 0)) {
                {
#line 445
                tmp___20 = strcmp((char const   *)*pz, zsystem);
                }
#line 445
                if (tmp___20 == 0) {
#line 447
                  goto while_break___9;
                }
              }
#line 444
              pz ++;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 448
            if ((unsigned long )*pz != (unsigned long )((void *)0)) {
#line 450
              pz = qperm->pzlogname;
              {
#line 450
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 450
                if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 450
                  goto while_break___10;
                }
#line 461
                if (fmachine) {
#line 461
                  if ((unsigned long )qsys->uuconf_zcalled_login == (unsigned long )((void *)0)) {
                    {
#line 466
                    qsys->uuconf_zcalled_login = *pz;
#line 467
                    iret = ihadd_logname_perm(qglobal, qsys, qperm);
                    }
                  } else
#line 461
                  if ((unsigned long )qsys->uuconf_zcalled_login == (unsigned long )((char *)(& _uuconf_unset))) {
                    {
#line 466
                    qsys->uuconf_zcalled_login = *pz;
#line 467
                    iret = ihadd_logname_perm(qglobal, qsys, qperm);
                    }
                  } else {
#line 461
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  {
#line 474
                  tmp___21 = uuconf_malloc(pblock, sizeof(struct uuconf_system ));
#line 474
                  qnew = (struct uuconf_system *)tmp___21;
                  }
#line 477
                  if ((unsigned long )qnew == (unsigned long )((void *)0)) {
                    {
#line 479
                    tmp___22 = __errno_location();
#line 479
                    qglobal->ierrno = *tmp___22;
                    }
#line 480
                    return (260);
                  }
#line 483
                  *qnew = *qsys;
#line 484
                  qnew->uuconf_qalternate = (struct uuconf_system *)((void *)0);
#line 485
                  pq___0 = & qsys->uuconf_qalternate;
                  {
#line 485
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 485
                    if (! ((unsigned long )*pq___0 != (unsigned long )((void *)0))) {
#line 485
                      goto while_break___11;
                    }
#line 485
                    pq___0 = & (*pq___0)->uuconf_qalternate;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                  {
#line 489
                  *pq___0 = qnew;
#line 491
                  qnew->uuconf_zcalled_login = *pz;
#line 492
                  qnew->uuconf_fcall = 0;
#line 493
                  iret = ihadd_logname_perm(qglobal, qnew, qperm);
                  }
                }
#line 496
                if (iret != 0) {
#line 497
                  return (iret);
                }
#line 450
                pz ++;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 500
              ffound_login = 1;
            }
          }
        }
      }
    }
#line 384
    qperm = qperm->qnext;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 507
  if (! ffound_machine) {
#line 507
    if ((unsigned long )qother_machine != (unsigned long )((void *)0)) {
#line 509
      qalt = qsys;
      {
#line 509
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 509
        if (! ((unsigned long )qalt != (unsigned long )((void *)0))) {
#line 509
          goto while_break___12;
        }
#line 511
        if (qalt->uuconf_fcall) {
          {
#line 513
          iret = ihadd_machine_perm(qglobal, qalt, qother_machine);
          }
#line 514
          if (iret != 0) {
#line 515
            return (iret);
          }
        }
#line 509
        qalt = qalt->uuconf_qalternate;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
  }
#line 522
  if (! ffound_login) {
#line 524
    qperm = (qglobal->qprocess)->qhdb_permissions;
    {
#line 524
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 524
      if (! ((unsigned long )qperm != (unsigned long )((void *)0))) {
#line 524
        goto while_break___13;
      }
#line 528
      if ((unsigned long )qperm->pzlogname == (unsigned long )((void *)0)) {
#line 530
        goto __Cont___1;
      } else
#line 528
      if ((unsigned long )qperm->pzlogname == (unsigned long )(& _uuconf_unset)) {
#line 530
        goto __Cont___1;
      }
#line 532
      pz = qperm->pzlogname;
      {
#line 532
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 532
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 532
          goto while_break___14;
        }
        {
#line 537
        tmp___23 = uuconf_malloc(pblock, sizeof(struct uuconf_system ));
#line 537
        qnew___0 = (struct uuconf_system *)tmp___23;
        }
#line 540
        if ((unsigned long )qnew___0 == (unsigned long )((void *)0)) {
          {
#line 542
          tmp___24 = __errno_location();
#line 542
          qglobal->ierrno = *tmp___24;
          }
#line 543
          return (260);
        }
#line 546
        *qnew___0 = *qsys;
#line 547
        qnew___0->uuconf_qalternate = (struct uuconf_system *)((void *)0);
#line 548
        pq___1 = & qsys->uuconf_qalternate;
        {
#line 548
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 548
          if (! ((unsigned long )*pq___1 != (unsigned long )((void *)0))) {
#line 548
            goto while_break___15;
          }
#line 548
          pq___1 = & (*pq___1)->uuconf_qalternate;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 552
        *pq___1 = qnew___0;
#line 556
        tmp___25 = strcmp((char const   *)*pz, "OTHER");
        }
#line 556
        if (tmp___25 == 0) {
#line 557
          qnew___0->uuconf_zcalled_login = (char *)"ANY";
        } else {
#line 559
          qnew___0->uuconf_zcalled_login = *pz;
        }
        {
#line 560
        qnew___0->uuconf_fcall = 0;
#line 561
        iret = ihadd_logname_perm(qglobal, qnew___0, qperm);
        }
#line 562
        if (iret != 0) {
#line 563
          return (iret);
        }
#line 532
        pz ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      __Cont___1: /* CIL Label */ 
#line 524
      qperm = qperm->qnext;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
#line 571
  qalt = qsys;
  {
#line 571
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 571
    if (! ((unsigned long )qalt != (unsigned long )((void *)0))) {
#line 571
      goto while_break___16;
    }
    {
#line 573
    iret = _uuconf_iadd_string(qglobal, (char *)"/", 0, 0, & qalt->uuconf_pzlocal_receive,
                               pblock);
    }
#line 577
    if (iret != 0) {
#line 578
      return (iret);
    }
#line 571
    qalt = qalt->uuconf_qalternate;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 583
  if ((unsigned long )qsys->uuconf_qtimegrade != (unsigned long )((void *)0)) {
#line 583
    if ((unsigned long )qsys->uuconf_qtimegrade != (unsigned long )((struct uuconf_timespan *)(& _uuconf_unset))) {
#line 583
      if ((qsys->uuconf_qtimegrade)->uuconf_cretry > 0) {
#line 586
        qsys->uuconf_cmax_retries = 0;
      }
    }
  }
#line 588
  return (0);
}
}
#line 594 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsinfo.c"
static int ihadd_machine_perm(struct sglobal *qglobal  __attribute__((__unused__)) ,
                              struct uuconf_system *qsys , struct shpermissions *qperm ) 
{ 


  {
#line 600
  if (qperm->frequest >= 0) {
#line 601
    qsys->uuconf_fsend_request = qperm->frequest;
  } else {
#line 603
    qsys->uuconf_fsend_request = 0;
  }
#line 604
  qsys->uuconf_pzremote_send = qperm->pzread;
#line 605
  qsys->uuconf_pzremote_receive = qperm->pzwrite;
#line 606
  qsys->uuconf_pzcmds = qperm->pzcommands;
#line 607
  qsys->uuconf_zlocalname = qperm->zmyname;
#line 608
  qsys->uuconf_zpubdir = qperm->zpubdir;
#line 609
  qsys->uuconf_pzalias = qperm->pzalias;
#line 611
  return (0);
}
}
#line 617 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hsinfo.c"
static int ihadd_logname_perm(struct sglobal *qglobal  __attribute__((__unused__)) ,
                              struct uuconf_system *qsys , struct shpermissions *qperm ) 
{ 


  {
#line 623
  qsys->uuconf_fcalled = 1;
#line 624
  if (qperm->frequest >= 0) {
#line 625
    qsys->uuconf_fsend_request = qperm->frequest;
  } else {
#line 627
    qsys->uuconf_fsend_request = 0;
  }
#line 628
  qsys->uuconf_fcalled_transfer = qperm->fsendfiles;
#line 629
  qsys->uuconf_pzremote_send = qperm->pzread;
#line 630
  qsys->uuconf_pzremote_receive = qperm->pzwrite;
#line 631
  qsys->uuconf_fcallback = qperm->fcallback;
#line 632
  qsys->uuconf_zlocalname = qperm->zmyname;
#line 633
  qsys->uuconf_zpubdir = qperm->zpubdir;
#line 635
  return (0);
}
}
#line 1280 "../uuconf.h"
int uuconf_hdb_remote_unknown(void *pglobal , char **pzname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hrmunk.c"
char const   _uuconf_hrmunk_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hrmunk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'r',      (char const   )'m', 
        (char const   )'u',      (char const   )'n',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'5',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hrmunk.c"
int uuconf_hdb_remote_unknown(void *pglobal , char **pzname ) 
{ 
  struct sglobal *qglobal ;
  size_t csize ;
  void *tmp ;
  int *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 40
  qglobal = (struct sglobal *)pglobal;
#line 43
  csize = (sizeof("/usr/lib/uucp") + sizeof("/remote.unknown")) - 1UL;
#line 44
  tmp = malloc(csize);
#line 44
  *pzname = (char *)tmp;
  }
#line 45
  if ((unsigned long )*pzname == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___0 = __errno_location();
#line 47
    qglobal->ierrno = *tmp___0;
    }
#line 48
    return (260);
  }
  {
#line 50
  memcpy((void */* __restrict  */)*pzname, (void const   */* __restrict  */)"/usr/lib/uucp",
         sizeof("/usr/lib/uucp") - 1UL);
#line 51
  memcpy((void */* __restrict  */)((*pzname + sizeof("/usr/lib/uucp")) - 1), (void const   */* __restrict  */)"/remote.unknown",
         sizeof("/remote.unknown"));
  }
#line 53
  return (0);
}
}
#line 1246 "../uuconf.h"
int uuconf_hdb_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud  __attribute__((__unused__)) ,
                         int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) ,
                         void *pinfo , struct uuconf_port *qport ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hport.c"
char const   _uuconf_hport_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hport.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hport.c"
int uuconf_hdb_find_port(void *pglobal , char const   *zname , long ibaud , long ihighbaud  __attribute__((__unused__)) ,
                         int (*pifn)(struct uuconf_port * , void *uuconf_pinfo ) ,
                         void *pinfo , struct uuconf_port *qport ) 
{ 
  struct sglobal *qglobal ;
  char *zline ;
  size_t cline ;
  char **pzsplit ;
  size_t csplit ;
  int iret ;
  char **pz ;
  FILE *e ;
  int cchars ;
  int *tmp ;
  int *tmp___0 ;
  int ctoks ;
  char *z ;
  char *zprotos ;
  char *zport ;
  long ilow ;
  long ihigh ;
  pointer pblock ;
  char ***ppzdialer ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  char *zend ;
  unsigned short const   **tmp___3 ;
  size_t cclass ;
  size_t cport ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t c ;
  char **pzd ;
  int *tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
#line 47
  qglobal = (struct sglobal *)pglobal;
#line 55
  zline = (char *)((void *)0);
#line 56
  cline = (size_t )0;
#line 57
  pzsplit = (char **)((void *)0);
#line 58
  csplit = (size_t )0;
#line 60
  iret = 1;
#line 62
  pz = (qglobal->qprocess)->pzhdb_devices;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 62
      goto while_break;
    }
    {
#line 67
    qglobal->ilineno = 0;
#line 69
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 70
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 72
      tmp = __errno_location();
      }
#line 72
      if (*tmp == 2) {
#line 73
        goto __Cont;
      }
      {
#line 74
      tmp___0 = __errno_location();
#line 74
      qglobal->ierrno = *tmp___0;
#line 75
      iret = 258;
      }
#line 76
      goto while_break;
    }
#line 79
    iret = 1;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 81
      cchars = _uuconf_getline(qglobal, & zline, & cline, e);
      }
#line 81
      if (! (cchars > 0)) {
#line 81
        goto while_break___0;
      }
#line 89
      (qglobal->ilineno) ++;
#line 91
      iret = 1;
#line 93
      cchars --;
#line 94
      if ((int )*(zline + cchars) == 10) {
#line 95
        *(zline + cchars) = (char )'\000';
      }
      {
#line 96
      tmp___1 = __ctype_b_loc();
      }
#line 96
      if ((int const   )*(*tmp___1 + (int )((unsigned char )*(zline + 0))) & 8192) {
#line 97
        goto while_continue___0;
      } else
#line 96
      if ((int )*(zline + 0) == 35) {
#line 97
        goto while_continue___0;
      }
      {
#line 99
      ctoks = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
      }
#line 100
      if (ctoks < 0) {
        {
#line 102
        tmp___2 = __errno_location();
#line 102
        qglobal->ierrno = *tmp___2;
#line 103
        iret = 260;
        }
#line 104
        goto while_break___0;
      }
#line 115
      if (ctoks < 4) {
#line 116
        goto while_continue___0;
      }
      {
#line 120
      zprotos = strchr((char const   *)*(pzsplit + 0), ',');
      }
#line 121
      if ((unsigned long )zprotos != (unsigned long )((void *)0)) {
#line 123
        *zprotos = (char )'\000';
#line 124
        zprotos ++;
      }
      {
#line 127
      zport = *(pzsplit + 0);
#line 133
      z = *(pzsplit + 3);
#line 134
      tmp___6 = strcasecmp((char const   *)z, "Any");
      }
#line 134
      if (tmp___6 == 0) {
#line 137
        ilow = 0L;
#line 138
        ihigh = 0L;
      } else {
        {
#line 134
        tmp___7 = strcmp((char const   *)z, "-");
        }
#line 134
        if (tmp___7 == 0) {
#line 137
          ilow = 0L;
#line 138
          ihigh = 0L;
        } else {
          {
#line 144
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 144
            if ((int )*z != 0) {
              {
#line 144
              tmp___3 = __ctype_b_loc();
              }
#line 144
              if ((int const   )*(*tmp___3 + (int )((unsigned char )*z)) & 2048) {
#line 144
                goto while_break___1;
              }
            } else {
#line 144
              goto while_break___1;
            }
#line 145
            z ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 147
          ilow = strtol((char const   */* __restrict  */)z, (char **/* __restrict  */)(& zend),
                        10);
          }
#line 148
          if ((int )*zend == 45) {
            {
#line 149
            ihigh = strtol((char const   */* __restrict  */)(zend + 1), (char **/* __restrict  */)((char **)((void *)0)),
                           10);
            }
          } else {
#line 151
            ihigh = ilow;
          }
#line 153
          if ((unsigned long )z != (unsigned long )*(pzsplit + 3)) {
            {
#line 157
            cclass = (size_t )(z - *(pzsplit + 3));
#line 158
            cport = strlen((char const   *)*(pzsplit + 0));
#line 159
            tmp___4 = malloc((cport + cclass) + 1UL);
#line 159
            zport = (char *)tmp___4;
            }
#line 160
            if ((unsigned long )zport == (unsigned long )((void *)0)) {
              {
#line 162
              tmp___5 = __errno_location();
#line 162
              qglobal->ierrno = *tmp___5;
#line 163
              iret = 260;
              }
#line 164
              goto while_break___0;
            }
            {
#line 166
            memcpy((void */* __restrict  */)((pointer )zport), (void const   */* __restrict  */)((pointer )*(pzsplit + 0)),
                   cport);
#line 167
            memcpy((void */* __restrict  */)((pointer )(zport + cport)), (void const   */* __restrict  */)((pointer )*(pzsplit + 3)),
                   cclass);
#line 169
            *(zport + (cport + cclass)) = (char )'\000';
            }
          }
        }
      }
#line 174
      if ((unsigned long )zname != (unsigned long )((void *)0)) {
        {
#line 174
        tmp___8 = strcmp((char const   *)zport, zname);
        }
#line 174
        if (tmp___8 != 0) {
#line 174
          goto _L___0;
        } else {
#line 174
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 174
      if (ibaud != 0L) {
#line 174
        if (ilow != 0L) {
#line 174
          if (ilow > ibaud) {
#line 174
            goto _L___0;
          } else
#line 174
          if (ihigh < ibaud) {
            _L___0: /* CIL Label */ 
#line 180
            if ((unsigned long )zport != (unsigned long )*(pzsplit + 0)) {
              {
#line 181
              free((pointer )zport);
              }
            }
#line 182
            goto while_continue___0;
          }
        }
      }
      {
#line 189
      tmp___9 = strcspn((char const   *)*(pzsplit + 1), ",");
#line 189
      *(*(pzsplit + 1) + tmp___9) = (char )'\000';
#line 196
      pblock = (void *)0;
#line 197
      _uuconf_uclear_port(qport);
#line 198
      qport->uuconf_zname = zport;
#line 199
      qport->uuconf_zprotocols = zprotos;
#line 200
      tmp___15 = strcmp((char const   *)*(pzsplit + 0), "Direct");
      }
#line 200
      if (tmp___15 == 0) {
#line 202
        qport->uuconf_ttype = (enum uuconf_porttype )3;
#line 203
        qport->uuconf_u.uuconf_sdirect.uuconf_zdevice = *(pzsplit + 1);
#line 204
        qport->uuconf_u.uuconf_sdirect.uuconf_ibaud = ilow;
#line 205
        qport->uuconf_u.uuconf_sdirect.uuconf_fcarrier = 0;
#line 206
        qport->uuconf_u.uuconf_sdirect.uuconf_fhardflow = 1;
#line 207
        ppzdialer = (char ***)((void *)0);
      } else {
        {
#line 209
        tmp___14 = strcmp((char const   *)*(pzsplit + 0), "TCP");
        }
#line 209
        if (tmp___14 == 0) {
#line 213
          qport->uuconf_ttype = (enum uuconf_porttype )4;
#line 214
          qport->uuconf_ireliable = 31;
#line 218
          qport->uuconf_u.uuconf_stcp.uuconf_zport = *(pzsplit + 1);
#line 219
          qport->uuconf_u.uuconf_stcp.uuconf_iversion = 0;
#line 220
          ppzdialer = & qport->uuconf_u.uuconf_stcp.uuconf_pzdialer;
        } else
#line 222
        if (ctoks >= 5) {
          {
#line 222
          tmp___12 = strcmp((char const   *)*(pzsplit + 4), "TLI");
          }
#line 222
          if (tmp___12 == 0) {
#line 222
            goto _L___3;
          } else {
            {
#line 222
            tmp___13 = strcmp((char const   *)*(pzsplit + 4), "TLIS");
            }
#line 222
            if (tmp___13 == 0) {
              _L___3: /* CIL Label */ 
              {
#line 226
              qport->uuconf_ttype = (enum uuconf_porttype )5;
#line 227
              qport->uuconf_u.uuconf_stli.uuconf_zdevice = *(pzsplit + 1);
#line 228
              tmp___10 = strcmp((char const   *)*(pzsplit + 4), "TLIS");
#line 228
              qport->uuconf_u.uuconf_stli.uuconf_fstream = tmp___10 == 0;
#line 230
              qport->uuconf_u.uuconf_stli.uuconf_pzpush = (char **)((void *)0);
#line 231
              qport->uuconf_u.uuconf_stli.uuconf_zservaddr = (char *)((void *)0);
#line 232
              qport->uuconf_ireliable = 31;
#line 236
              ppzdialer = & qport->uuconf_u.uuconf_stli.uuconf_pzdialer;
              }
            } else {
#line 222
              goto _L___2;
            }
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 240
          qport->uuconf_ttype = (enum uuconf_porttype )2;
#line 241
          qport->uuconf_u.uuconf_smodem.uuconf_zdevice = *(pzsplit + 1);
#line 242
          tmp___11 = strcmp((char const   *)*(pzsplit + 2), "-");
          }
#line 242
          if (tmp___11 != 0) {
#line 243
            qport->uuconf_u.uuconf_smodem.uuconf_zdial_device = *(pzsplit + 2);
          } else {
#line 246
            qport->uuconf_u.uuconf_smodem.uuconf_zdial_device = (char *)((void *)0);
          }
#line 247
          if (ilow == ihigh) {
#line 249
            qport->uuconf_u.uuconf_smodem.uuconf_ibaud = ilow;
#line 250
            qport->uuconf_u.uuconf_smodem.uuconf_ilowbaud = 0L;
#line 251
            qport->uuconf_u.uuconf_smodem.uuconf_ihighbaud = 0L;
          } else {
#line 255
            qport->uuconf_u.uuconf_smodem.uuconf_ibaud = 0L;
#line 256
            qport->uuconf_u.uuconf_smodem.uuconf_ilowbaud = ilow;
#line 257
            qport->uuconf_u.uuconf_smodem.uuconf_ihighbaud = ihigh;
          }
#line 259
          qport->uuconf_u.uuconf_smodem.uuconf_fcarrier = 1;
#line 260
          qport->uuconf_u.uuconf_smodem.uuconf_fhardflow = 1;
#line 261
          qport->uuconf_u.uuconf_smodem.uuconf_qdialer = (struct uuconf_dialer *)((void *)0);
#line 262
          ppzdialer = & qport->uuconf_u.uuconf_smodem.uuconf_pzdialer;
        }
      }
#line 265
      if ((unsigned long )ppzdialer != (unsigned long )((void *)0)) {
#line 267
        if (ctoks < 5) {
#line 268
          *ppzdialer = (char **)((void *)0);
        } else {
          {
#line 274
          pblock = uuconf_malloc_block();
          }
#line 275
          if ((unsigned long )pblock == (unsigned long )((void *)0)) {
            {
#line 277
            tmp___16 = __errno_location();
#line 277
            qglobal->ierrno = *tmp___16;
#line 278
            iret = 260;
            }
#line 279
            goto while_break___0;
          }
          {
#line 281
          c = (unsigned long )(ctoks - 4) * sizeof(char *);
#line 282
          tmp___17 = uuconf_malloc(pblock, c + sizeof(char *));
#line 282
          pzd = (char **)tmp___17;
          }
#line 283
          if ((unsigned long )pzd == (unsigned long )((void *)0)) {
            {
#line 285
            tmp___18 = __errno_location();
#line 285
            qglobal->ierrno = *tmp___18;
#line 286
            uuconf_free_block(pblock);
#line 287
            iret = 260;
            }
#line 288
            goto while_break___0;
          }
          {
#line 290
          memcpy((void */* __restrict  */)((pointer )pzd), (void const   */* __restrict  */)((pointer )(pzsplit + 4)),
                 c);
#line 291
          *(pzd + (ctoks - 4)) = (char *)((void *)0);
#line 293
          *ppzdialer = pzd;
          }
        }
      }
#line 297
      if ((unsigned long )pifn != (unsigned long )((void *)0)) {
        {
#line 299
        iret = (*pifn)(qport, pinfo);
        }
#line 300
        if (iret != 0) {
#line 302
          if ((unsigned long )zport != (unsigned long )*(pzsplit + 0)) {
            {
#line 303
            free((pointer )zport);
            }
          }
#line 304
          if ((unsigned long )pblock != (unsigned long )((void *)0)) {
            {
#line 305
            uuconf_free_block(pblock);
            }
          }
#line 306
          if (iret != 1) {
#line 307
            goto while_break___0;
          }
#line 308
          goto while_continue___0;
        }
      }
#line 313
      if ((unsigned long )pblock == (unsigned long )((void *)0)) {
        {
#line 315
        pblock = uuconf_malloc_block();
        }
#line 316
        if ((unsigned long )pblock == (unsigned long )((void *)0)) {
          {
#line 318
          tmp___19 = __errno_location();
#line 318
          qglobal->ierrno = *tmp___19;
#line 319
          iret = 260;
          }
#line 320
          goto while_break___0;
        }
      }
      {
#line 324
      tmp___21 = uuconf_add_block(pblock, (void *)zline);
      }
#line 324
      if (tmp___21 != 0) {
        {
#line 328
        tmp___20 = __errno_location();
#line 328
        qglobal->ierrno = *tmp___20;
#line 329
        uuconf_free_block(pblock);
#line 330
        iret = 260;
        }
#line 331
        goto while_break___0;
      } else
#line 324
      if ((unsigned long )zport != (unsigned long )*(pzsplit + 0)) {
        {
#line 324
        tmp___22 = uuconf_add_block(pblock, (void *)zport);
        }
#line 324
        if (tmp___22 != 0) {
          {
#line 328
          tmp___20 = __errno_location();
#line 328
          qglobal->ierrno = *tmp___20;
#line 329
          uuconf_free_block(pblock);
#line 330
          iret = 260;
          }
#line 331
          goto while_break___0;
        }
      }
#line 333
      zline = (char *)((void *)0);
#line 335
      qport->uuconf_palloc = pblock;
#line 337
      iret = 0;
#line 339
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 342
    fclose(e);
    }
#line 344
    if (iret != 1) {
#line 345
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 62
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 349
    free((pointer )zline);
    }
  }
#line 350
  if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
    {
#line 351
    free((pointer )pzsplit);
    }
  }
#line 353
  if (iret != 0) {
#line 353
    if (iret != 1) {
#line 355
      qglobal->zfilename = (char const   *)*pz;
#line 356
      iret |= 1536;
    }
  }
#line 359
  return (iret);
}
}
#line 1272 "../uuconf.h"
int uuconf_hdb_login_localname(void *pglobal , char const   *zlogin , char **pzname ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hlocnm.c"
char const   _uuconf_hlocnm_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hlocnm.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'n',      (char const   )'m',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hlocnm.c"
int uuconf_hdb_login_localname(void *pglobal , char const   *zlogin , char **pzname ) 
{ 
  struct sglobal *qglobal ;
  struct shpermissions *qperm ;
  int iret ;
  char **pz ;
  int *tmp ;
  int tmp___0 ;

  {
#line 42
  qglobal = (struct sglobal *)pglobal;
#line 45
  if (! (qglobal->qprocess)->fhdb_read_permissions) {
    {
#line 49
    iret = _uuconf_ihread_permissions(qglobal);
    }
#line 50
    if (iret != 0) {
#line 51
      return (iret);
    }
  }
#line 54
  qperm = (qglobal->qprocess)->qhdb_permissions;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )qperm != (unsigned long )((void *)0))) {
#line 54
      goto while_break;
    }
#line 58
    if ((unsigned long )qperm->zmyname != (unsigned long )((void *)0)) {
#line 58
      if ((unsigned long )qperm->zmyname != (unsigned long )((char *)(& _uuconf_unset))) {
#line 58
        if ((unsigned long )qperm->pzlogname != (unsigned long )((void *)0)) {
#line 58
          if ((unsigned long )qperm->pzlogname != (unsigned long )(& _uuconf_unset)) {
#line 65
            pz = qperm->pzlogname;
            {
#line 65
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 65
              if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 65
                goto while_break___0;
              }
              {
#line 67
              tmp___0 = strcmp((char const   *)*pz, zlogin);
              }
#line 67
              if (tmp___0 == 0) {
                {
#line 69
                *pzname = strdup((char const   *)qperm->zmyname);
                }
#line 70
                if ((unsigned long )*pzname == (unsigned long )((void *)0)) {
                  {
#line 72
                  tmp = __errno_location();
#line 72
                  qglobal->ierrno = *tmp;
                  }
#line 73
                  return (260);
                }
#line 75
                return (0);
              }
#line 65
              pz ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 54
    qperm = qperm->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  *pzname = (char *)((void *)0);
#line 82
  return (1);
}
}
#line 1216 "../uuconf.h"
int uuconf_hdb_init(void **ppglobal , char const   *zprogram ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hinit.c"
char const   _uuconf_hinit_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hinit.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'i',      (char const   )'n', 
        (char const   )'i',      (char const   )'t',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'9',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hinit.c"
static char const   abHoldconfiglib[14]  = 
#line 35
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'u',      (char const   )'u',      (char const   )'c', 
        (char const   )'p',      (char const   )'\000'};
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hinit.c"
int uuconf_hdb_init(void **ppglobal , char const   *zprogram ) 
{ 
  struct sglobal **pqglobal ;
  int iret ;
  struct sglobal *qglobal ;
  pointer pblock ;
  char abdialcodes[(sizeof("/usr/lib/uucp") + sizeof("/Dialcodes")) - 1UL] ;
  char *zsys ;
  FILE *e ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *zline ;
  size_t cline ;
  char **pzargs ;
  size_t cargs ;
  char **pzcolon ;
  size_t ccolon ;
  int cchars ;
  int ctypes ;
  int cnames ;
  int i ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char ***ppz ;
  int cfiles ;
  int ifile ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *zdir ;
  size_t clen ;
  void *tmp___10 ;
  int *tmp___11 ;
  char ab___0[(sizeof("/usr/lib/uucp") + sizeof("/Systems")) - 1UL] ;
  char ab___1[(sizeof("/usr/lib/uucp") + sizeof("/Devices")) - 1UL] ;
  char ab___2[(sizeof("/usr/lib/uucp") + sizeof("/Dialers")) - 1UL] ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;

  {
#line 44
  pqglobal = (struct sglobal **)ppglobal;
#line 52
  if ((unsigned long )*pqglobal == (unsigned long )((void *)0)) {
    {
#line 54
    iret = _uuconf_iinit_global(pqglobal);
    }
#line 55
    if (iret != 0) {
#line 56
      return (iret);
    }
  }
#line 59
  qglobal = *pqglobal;
#line 60
  pblock = qglobal->pblock;
#line 62
  if ((unsigned long )zprogram == (unsigned long )((void *)0)) {
#line 64
    zprogram = "uucico";
  } else {
    {
#line 62
    tmp = strcmp(zprogram, "uucp");
    }
#line 62
    if (tmp == 0) {
#line 64
      zprogram = "uucico";
    }
  }
  {
#line 67
  memcpy((void */* __restrict  */)((pointer )(abdialcodes)), (void const   */* __restrict  */)((pointer )(abHoldconfiglib)),
         sizeof("/usr/lib/uucp") - 1UL);
#line 69
  memcpy((void */* __restrict  */)((pointer )((abdialcodes + sizeof("/usr/lib/uucp")) - 1)),
         (void const   */* __restrict  */)((pointer )"/Dialcodes"), sizeof("/Dialcodes"));
#line 71
  iret = _uuconf_iadd_string(qglobal, abdialcodes, 1, 0, & (qglobal->qprocess)->pzdialcodefiles,
                             pblock);
  }
#line 74
  if (iret != 0) {
#line 75
    return (iret);
  }
  {
#line 81
  tmp___0 = uuconf_malloc(pblock, (sizeof("/usr/lib/uucp") + sizeof("/Sysfiles")) - 1UL);
#line 81
  zsys = (char *)tmp___0;
  }
#line 83
  if ((unsigned long )zsys == (unsigned long )((void *)0)) {
    {
#line 85
    tmp___1 = __errno_location();
#line 85
    qglobal->ierrno = *tmp___1;
    }
#line 86
    return (260);
  }
  {
#line 88
  memcpy((void */* __restrict  */)((pointer )zsys), (void const   */* __restrict  */)((pointer )(abHoldconfiglib)),
         sizeof("/usr/lib/uucp") - 1UL);
#line 89
  memcpy((void */* __restrict  */)((pointer )((zsys + sizeof("/usr/lib/uucp")) - 1)),
         (void const   */* __restrict  */)((pointer )"/Sysfiles"), sizeof("/Sysfiles"));
#line 92
  iret = 0;
#line 94
  e = fopen((char const   */* __restrict  */)zsys, (char const   */* __restrict  */)"r");
  }
#line 95
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 96
    uuconf_free(pblock, (void *)zsys);
    }
  } else {
#line 107
    zline = (char *)((void *)0);
#line 108
    cline = (size_t )0;
#line 109
    pzargs = (char **)((void *)0);
#line 110
    cargs = (size_t )0;
#line 111
    pzcolon = (char **)((void *)0);
#line 112
    ccolon = (size_t )0;
#line 114
    qglobal->ilineno = 0;
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 116
      if (iret == 0) {
        {
#line 116
        cchars = _uuconf_getline(qglobal, & zline, & cline, e);
        }
#line 116
        if (! (cchars > 0)) {
#line 116
          goto while_break;
        }
      } else {
#line 116
        goto while_break;
      }
#line 122
      (qglobal->ilineno) ++;
#line 124
      cchars --;
#line 125
      if ((int )*(zline + cchars) == 10) {
#line 126
        *(zline + cchars) = (char )'\000';
      }
#line 127
      if ((int )*(zline + 0) == 35) {
#line 128
        goto while_continue;
      }
      {
#line 130
      ctypes = _uuconf_istrsplit(zline, '\000', & pzargs, & cargs);
      }
#line 131
      if (ctypes < 0) {
        {
#line 133
        tmp___2 = __errno_location();
#line 133
        qglobal->ierrno = *tmp___2;
#line 134
        iret = 260;
        }
#line 135
        goto while_break;
      }
#line 138
      if (ctypes == 0) {
#line 139
        goto while_continue;
      }
      {
#line 141
      tmp___3 = strncmp((char const   *)*(pzargs + 0), "service=", sizeof("service=") - 1UL);
      }
#line 141
      if (tmp___3 != 0) {
#line 143
        iret = 5;
#line 144
        goto while_break;
      }
      {
#line 146
      *(pzargs + 0) += sizeof("service=") - 1UL;
#line 148
      cnames = _uuconf_istrsplit(*(pzargs + 0), ':', & pzcolon, & ccolon);
      }
#line 149
      if (cnames < 0) {
        {
#line 151
        tmp___4 = __errno_location();
#line 151
        qglobal->ierrno = *tmp___4;
#line 152
        iret = 260;
        }
#line 153
        goto while_break;
      }
#line 156
      i = 0;
      {
#line 156
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 156
        if (! (i < cnames)) {
#line 156
          goto while_break___0;
        }
        {
#line 157
        tmp___5 = strcmp(zprogram, (char const   *)*(pzcolon + i));
        }
#line 157
        if (tmp___5 == 0) {
#line 158
          goto while_break___0;
        }
#line 156
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 160
      if (i >= cnames) {
#line 161
        goto while_continue;
      }
#line 163
      i = 1;
      {
#line 163
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 163
        if (i < ctypes) {
#line 163
          if (! (iret == 0)) {
#line 163
            goto while_break___1;
          }
        } else {
#line 163
          goto while_break___1;
        }
        {
#line 168
        tmp___8 = strncmp((char const   *)*(pzargs + i), "systems=", sizeof("systems=") - 1UL);
        }
#line 168
        if (tmp___8 == 0) {
#line 171
          ppz = & (qglobal->qprocess)->pzhdb_systems;
#line 172
          *(pzargs + i) += sizeof("systems=") - 1UL;
        } else {
          {
#line 174
          tmp___7 = strncmp((char const   *)*(pzargs + i), "devices=", sizeof("devices=") - 1UL);
          }
#line 174
          if (tmp___7 == 0) {
#line 177
            ppz = & (qglobal->qprocess)->pzhdb_devices;
#line 178
            *(pzargs + i) += sizeof("devices=") - 1UL;
          } else {
            {
#line 180
            tmp___6 = strncmp((char const   *)*(pzargs + i), "dialers=", sizeof("dialers=") - 1UL);
            }
#line 180
            if (tmp___6 == 0) {
#line 183
              ppz = & (qglobal->qprocess)->pzhdb_dialers;
#line 184
              *(pzargs + i) += sizeof("dialers=") - 1UL;
            } else {
#line 188
              iret = 5;
#line 189
              goto while_break___1;
            }
          }
        }
        {
#line 192
        cfiles = _uuconf_istrsplit(*(pzargs + i), ':', & pzcolon, & ccolon);
        }
#line 193
        if (cfiles < 0) {
          {
#line 195
          tmp___9 = __errno_location();
#line 195
          qglobal->ierrno = *tmp___9;
#line 196
          iret = 260;
          }
#line 197
          goto while_break___1;
        }
#line 200
        ifile = 0;
        {
#line 200
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 200
          if (ifile < cfiles) {
#line 200
            if (! (iret == 0)) {
#line 200
              goto while_break___2;
            }
          } else {
#line 200
            goto while_break___2;
          }
#line 206
          if ((int )*(*(pzcolon + ifile) + 0) == 47) {
            {
#line 207
            iret = _uuconf_iadd_string(qglobal, *(pzcolon + ifile), 1, 0, ppz, pblock);
            }
          } else {
            {
#line 214
            clen = strlen((char const   *)*(pzcolon + ifile));
#line 215
            tmp___10 = uuconf_malloc(pblock, ((sizeof("/usr/lib/uucp") + sizeof("/")) + clen) - 1UL);
#line 215
            zdir = (char *)tmp___10;
            }
#line 220
            if ((unsigned long )zdir == (unsigned long )((void *)0)) {
              {
#line 222
              tmp___11 = __errno_location();
#line 222
              qglobal->ierrno = *tmp___11;
#line 223
              iret = 260;
              }
#line 224
              goto while_break___2;
            }
            {
#line 226
            memcpy((void */* __restrict  */)((pointer )zdir), (void const   */* __restrict  */)((pointer )(abHoldconfiglib)),
                   sizeof("/usr/lib/uucp") - 1UL);
#line 228
            memcpy((void */* __restrict  */)((pointer )((zdir + sizeof("/usr/lib/uucp")) - 1)),
                   (void const   */* __restrict  */)"/", sizeof("/") - 1UL);
#line 230
            memcpy((void */* __restrict  */)((pointer )((((zdir + sizeof("/usr/lib/uucp")) - 1) + sizeof("/")) - 1)),
                   (void const   */* __restrict  */)((pointer )*(pzcolon + ifile)),
                   clen + 1UL);
#line 234
            iret = _uuconf_iadd_string(qglobal, zdir, 0, 0, ppz, pblock);
            }
          }
#line 200
          ifile ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 163
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 241
    fclose(e);
    }
#line 242
    if ((unsigned long )zline != (unsigned long )((void *)0)) {
      {
#line 243
      free((pointer )zline);
      }
    }
#line 244
    if ((unsigned long )pzargs != (unsigned long )((void *)0)) {
      {
#line 245
      free((pointer )pzargs);
      }
    }
#line 246
    if ((unsigned long )pzcolon != (unsigned long )((void *)0)) {
      {
#line 247
      free((pointer )pzcolon);
      }
    }
#line 249
    if (iret != 0) {
#line 251
      qglobal->zfilename = (char const   *)zsys;
#line 252
      return ((iret | 512) | 1024);
    }
  }
#line 256
  if ((unsigned long )(qglobal->qprocess)->pzhdb_systems == (unsigned long )((void *)0)) {
    {
#line 260
    memcpy((void */* __restrict  */)((pointer )(ab___0)), (void const   */* __restrict  */)((pointer )(abHoldconfiglib)),
           sizeof("/usr/lib/uucp") - 1UL);
#line 262
    memcpy((void */* __restrict  */)((pointer )((ab___0 + sizeof("/usr/lib/uucp")) - 1)),
           (void const   */* __restrict  */)((pointer )"/Systems"), sizeof("/Systems"));
#line 264
    iret = _uuconf_iadd_string(qglobal, ab___0, 1, 0, & (qglobal->qprocess)->pzhdb_systems,
                               pblock);
    }
  }
#line 268
  if ((unsigned long )(qglobal->qprocess)->pzhdb_devices == (unsigned long )((void *)0)) {
#line 268
    if (iret == 0) {
      {
#line 272
      memcpy((void */* __restrict  */)((pointer )(ab___1)), (void const   */* __restrict  */)((pointer )(abHoldconfiglib)),
             sizeof("/usr/lib/uucp") - 1UL);
#line 274
      memcpy((void */* __restrict  */)((pointer )((ab___1 + sizeof("/usr/lib/uucp")) - 1)),
             (void const   */* __restrict  */)((pointer )"/Devices"), sizeof("/Devices"));
#line 276
      iret = _uuconf_iadd_string(qglobal, ab___1, 1, 0, & (qglobal->qprocess)->pzhdb_devices,
                                 pblock);
      }
    }
  }
#line 280
  if ((unsigned long )(qglobal->qprocess)->pzhdb_dialers == (unsigned long )((void *)0)) {
#line 280
    if (iret == 0) {
      {
#line 284
      memcpy((void */* __restrict  */)((pointer )(ab___2)), (void const   */* __restrict  */)((pointer )(abHoldconfiglib)),
             sizeof("/usr/lib/uucp") - 1UL);
#line 286
      memcpy((void */* __restrict  */)((pointer )((ab___2 + sizeof("/usr/lib/uucp")) - 1)),
             (void const   */* __restrict  */)((pointer )"/Dialers"), sizeof("/Dialers"));
#line 288
      iret = _uuconf_iadd_string(qglobal, ab___2, 1, 0, & (qglobal->qprocess)->pzhdb_dialers,
                                 pblock);
      }
    }
  }
#line 293
  return (iret);
}
}
#line 1259 "../uuconf.h"
int uuconf_hdb_dialer_names(void *pglobal , char ***ppzdialers ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hdnams.c"
char const   _uuconf_hdnams_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hdnams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'d',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hdnams.c"
int uuconf_hdb_dialer_names(void *pglobal , char ***ppzdialers ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  char *zline ;
  size_t cline ;
  char **pz ;
  FILE *e ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 41
  qglobal = (struct sglobal *)pglobal;
#line 47
  *ppzdialers = (char **)((void *)0);
#line 49
  iret = 0;
#line 51
  zline = (char *)((void *)0);
#line 52
  cline = (size_t )0;
#line 54
  pz = (qglobal->qprocess)->pzhdb_dialers;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 54
      goto while_break;
    }
    {
#line 58
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 59
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 61
      tmp = __errno_location();
      }
#line 61
      if (*tmp == 2) {
#line 62
        goto __Cont;
      }
      {
#line 63
      tmp___0 = __errno_location();
#line 63
      qglobal->ierrno = *tmp___0;
#line 64
      iret = 258;
      }
#line 65
      goto while_break;
    }
#line 68
    qglobal->ilineno = 0;
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 70
      tmp___2 = _uuconf_getline(qglobal, & zline, & cline, e);
      }
#line 70
      if (! (tmp___2 > 0)) {
#line 70
        goto while_break___0;
      }
      {
#line 72
      (qglobal->ilineno) ++;
#line 78
      tmp___1 = strcspn((char const   *)zline, " \t#\n");
#line 78
      *(zline + tmp___1) = (char )'\000';
      }
#line 79
      if ((int )*zline == 0) {
#line 80
        goto while_continue___0;
      }
      {
#line 82
      iret = _uuconf_iadd_string(qglobal, zline, 1, 1, ppzdialers, (void *)0);
      }
#line 84
      if (iret != 0) {
#line 86
        iret |= 1024;
#line 87
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 91
    fclose(e);
    }
    __Cont: /* CIL Label */ 
#line 54
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 95
    free((pointer )zline);
    }
  }
#line 97
  if (iret != 0) {
#line 99
    qglobal->zfilename = (char const   *)*pz;
#line 100
    return (iret | 512);
  }
#line 103
  if ((unsigned long )*ppzdialers == (unsigned long )((void *)0)) {
    {
#line 104
    iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzdialers, (void *)0);
    }
  }
#line 107
  return (0);
}
}
#line 1264 "../uuconf.h"
int uuconf_hdb_dialer_info(void *pglobal , char const   *zname , struct uuconf_dialer *qdialer ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hdial.c"
char const   _uuconf_hdial_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hdial.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'h',      (char const   )'d',      (char const   )'i', 
        (char const   )'a',      (char const   )'l',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'7',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/hdial.c"
int uuconf_hdb_dialer_info(void *pglobal , char const   *zname , struct uuconf_dialer *qdialer ) 
{ 
  struct sglobal *qglobal ;
  char **pz ;
  char *zline ;
  size_t cline ;
  char **pzsplit ;
  size_t csplit ;
  int iret ;
  FILE *e ;
  int cchars ;
  int *tmp ;
  int *tmp___0 ;
  int ctoks ;
  pointer pblock ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *zsubs ;
  char bnext ;
  int tmp___7 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 42
  qglobal = (struct sglobal *)pglobal;
#line 50
  zline = (char *)((void *)0);
#line 51
  cline = (size_t )0;
#line 52
  pzsplit = (char **)((void *)0);
#line 53
  csplit = (size_t )0;
#line 55
  iret = 1;
#line 57
  pz = (qglobal->qprocess)->pzhdb_dialers;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 57
      goto while_break;
    }
    {
#line 62
    qglobal->ilineno = 0;
#line 64
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 65
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 67
      tmp = __errno_location();
      }
#line 67
      if (*tmp == 2) {
#line 68
        goto __Cont;
      }
      {
#line 69
      tmp___0 = __errno_location();
#line 69
      qglobal->ierrno = *tmp___0;
#line 70
      iret = 258;
      }
#line 71
      goto while_break;
    }
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 74
      cchars = _uuconf_getline(qglobal, & zline, & cline, e);
      }
#line 74
      if (! (cchars > 0)) {
#line 74
        goto while_break___0;
      }
#line 79
      (qglobal->ilineno) ++;
#line 81
      cchars --;
#line 82
      if ((int )*(zline + cchars) == 10) {
#line 83
        *(zline + cchars) = (char )'\000';
      }
      {
#line 84
      tmp___1 = __ctype_b_loc();
      }
#line 84
      if ((int const   )*(*tmp___1 + (int )((unsigned char )*(zline + 0))) & 8192) {
#line 85
        goto while_continue___0;
      } else
#line 84
      if ((int )*(zline + 0) == 35) {
#line 85
        goto while_continue___0;
      }
      {
#line 87
      ctoks = _uuconf_istrsplit(zline, '\000', & pzsplit, & csplit);
      }
#line 88
      if (ctoks < 0) {
        {
#line 90
        tmp___2 = __errno_location();
#line 90
        qglobal->ierrno = *tmp___2;
#line 91
        iret = 260;
        }
#line 92
        goto while_break___0;
      }
#line 95
      if (ctoks < 1) {
#line 96
        goto while_continue___0;
      }
      {
#line 98
      tmp___3 = strcmp(zname, (char const   *)*(pzsplit + 0));
      }
#line 98
      if (tmp___3 != 0) {
#line 99
        goto while_continue___0;
      }
      {
#line 102
      pblock = uuconf_malloc_block();
      }
#line 103
      if ((unsigned long )pblock == (unsigned long )((void *)0)) {
        {
#line 105
        tmp___4 = __errno_location();
#line 105
        qglobal->ierrno = *tmp___4;
#line 106
        iret = 260;
        }
#line 107
        goto while_break___0;
      }
      {
#line 109
      tmp___6 = uuconf_add_block(pblock, (void *)zline);
      }
#line 109
      if (tmp___6 != 0) {
        {
#line 111
        tmp___5 = __errno_location();
#line 111
        qglobal->ierrno = *tmp___5;
#line 112
        uuconf_free_block(pblock);
#line 113
        iret = 260;
        }
#line 114
        goto while_break___0;
      }
      {
#line 116
      zline = (char *)((void *)0);
#line 118
      _uuconf_uclear_dialer(qdialer);
#line 119
      qdialer->uuconf_zname = *(pzsplit + 0);
#line 120
      qdialer->uuconf_palloc = pblock;
      }
#line 122
      if (ctoks > 1) {
        {
#line 126
        tmp___7 = strcmp((char const   *)*(pzsplit + 1), "\"\"");
        }
#line 126
        if (tmp___7 == 0) {
#line 131
          zsubs = *(pzsplit + 1);
#line 132
          bnext = *zsubs;
          {
#line 133
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 133
            if (! ((int )bnext != 0)) {
#line 133
              goto while_break___1;
            }
#line 135
            if ((int )bnext == 61) {
#line 136
              qdialer->uuconf_zdialtone = zsubs + 1;
            } else
#line 137
            if ((int )bnext == 45) {
#line 138
              qdialer->uuconf_zpause = zsubs + 1;
            }
#line 139
            if ((int )*(zsubs + 1) == 0) {
#line 140
              goto while_break___1;
            }
#line 141
            zsubs += 2;
#line 142
            bnext = *zsubs;
#line 143
            *zsubs = (char )'\000';
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 148
        if (ctoks > 2) {
          {
#line 150
          *(pzsplit + 1) = (char *)"chat";
#line 151
          iret = _uuconf_ichat_cmd(qglobal, ctoks - 1, pzsplit + 1, & qdialer->uuconf_schat,
                                   pblock);
#line 155
          iret &= -2049;
          }
#line 156
          if (iret != 0) {
            {
#line 158
            uuconf_free_block(pblock);
            }
#line 159
            goto while_break___0;
          }
        }
      }
#line 164
      iret = 0;
#line 165
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 168
    fclose(e);
    }
#line 170
    if (iret != 1) {
#line 171
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 57
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 175
    free((pointer )zline);
    }
  }
#line 176
  if ((unsigned long )pzsplit != (unsigned long )((void *)0)) {
    {
#line 177
    free((pointer )pzsplit);
    }
  }
#line 179
  if (iret != 0) {
#line 179
    if (iret != 1) {
#line 181
      qglobal->zfilename = (char const   *)*pz;
#line 182
      iret |= 1536;
    }
  }
#line 185
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/grdcmp.c"
char const   _uuconf_grdcmp_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/grdcmp.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'g',      (char const   )'r',      (char const   )'d', 
        (char const   )'c',      (char const   )'m',      (char const   )'p',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/grdcmp.c"
int uuconf_grade_cmp(int barg1 , int barg2 ) 
{ 
  int b1 ;
  int b2 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 49
  b1 = (int )((unsigned char )barg1);
#line 50
  b2 = (int )((unsigned char )barg2);
#line 52
  tmp___4 = __ctype_b_loc();
  }
#line 52
  if ((int const   )*(*tmp___4 + b1) & 2048) {
    {
#line 54
    tmp = __ctype_b_loc();
    }
#line 54
    if ((int const   )*(*tmp + b2) & 2048) {
#line 55
      return (b1 - b2);
    } else {
#line 57
      return (-1);
    }
  } else {
    {
#line 59
    tmp___3 = __ctype_b_loc();
    }
#line 59
    if ((int const   )*(*tmp___3 + b1) & 256) {
      {
#line 61
      tmp___1 = __ctype_b_loc();
      }
#line 61
      if ((int const   )*(*tmp___1 + b2) & 2048) {
#line 62
        return (1);
      } else {
        {
#line 63
        tmp___0 = __ctype_b_loc();
        }
#line 63
        if ((int const   )*(*tmp___0 + b2) & 256) {
#line 64
          return (b1 - b2);
        } else {
#line 66
          return (-1);
        }
      }
    } else {
      {
#line 70
      tmp___2 = __ctype_b_loc();
      }
#line 70
      if ((int const   )*(*tmp___2 + b2) & 512) {
#line 73
        return (b1 - b2);
      } else {
#line 71
        return (1);
      }
    }
  }
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/fresys.c"
char const   _uuconf_fresys_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/fresys.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'y',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/fresys.c"
int uuconf_system_free(void *pglobal  __attribute__((__unused__)) , struct uuconf_system *qsys ) 
{ 


  {
  {
#line 41
  uuconf_free_block(qsys->uuconf_palloc);
  }
#line 42
  return (0);
}
}
#line 834 "../uuconf.h"
int uuconf_port_free(void *pglobal  __attribute__((__unused__)) , struct uuconf_port *qport ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/freprt.c"
char const   _uuconf_freprt_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/freprt.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )'r',      (char const   )'t',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/freprt.c"
int uuconf_port_free(void *pglobal  __attribute__((__unused__)) , struct uuconf_port *qport ) 
{ 


  {
  {
#line 41
  uuconf_free_block(qport->uuconf_palloc);
  }
#line 42
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/free.c"
char const   _uuconf_free_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/free.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'7',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/free.c"
void uuconf_free(void *pblock , void *pbuf ) 
{ 
  struct sblock *q ;

  {
#line 47
  q = (struct sblock *)pblock;
#line 49
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 50
    return;
  }
#line 52
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 54
    free(pbuf);
    }
#line 55
    return;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 58
      goto while_break;
    }
#line 60
    if ((unsigned long )q->plast == (unsigned long )pbuf) {
#line 62
      q->ifree = (size_t )((char *)pbuf - q->u.ab);
#line 64
      return;
    }
#line 58
    q = q->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 860 "../uuconf.h"
int uuconf_dialer_free(void *pglobal  __attribute__((__unused__)) , struct uuconf_dialer *qdialer ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/fredia.c"
char const   _uuconf_fredia_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/fredia.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'a',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/fredia.c"
int uuconf_dialer_free(void *pglobal  __attribute__((__unused__)) , struct uuconf_dialer *qdialer ) 
{ 


  {
  {
#line 41
  uuconf_free_block(qdialer->uuconf_palloc);
  }
#line 42
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/freblk.c"
char const   _uuconf_freblk_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/freblk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'b',      (char const   )'l',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/freblk.c"
void uuconf_free_block(void *pblock ) 
{ 
  struct sblock *q ;
  struct sblock *qloop ;
  struct sadded *qadd ;
  struct sblock *qnext ;

  {
#line 41
  q = (struct sblock *)pblock;
#line 46
  qloop = q;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! ((unsigned long )qloop != (unsigned long )((void *)0))) {
#line 46
      goto while_break;
    }
#line 50
    qadd = qloop->qadded;
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! ((unsigned long )qadd != (unsigned long )((void *)0))) {
#line 50
        goto while_break___0;
      }
      {
#line 51
      free(qadd->padded);
#line 50
      qadd = qadd->qnext;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 46
    qloop = qloop->qnext;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 54
      goto while_break___1;
    }
    {
#line 58
    qnext = q->qnext;
#line 59
    free((pointer )q);
#line 60
    q = qnext;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 1322 "../uuconf.h"
char const   *uuconf_error_filename(void *pglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/filnam.c"
char const   _uuconf_filnam_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/filnam.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/filnam.c"
char const   *uuconf_error_filename(void *pglobal ) 
{ 
  struct sglobal *qglobal ;
  char *__cil_tmp3 ;

  {
#line 37
  qglobal = (struct sglobal *)pglobal;
#line 39
  if ((unsigned long )qglobal == (unsigned long )((void *)0)) {
#line 40
    return ("");
  } else {
#line 42
    return (qglobal->zfilename);
  }
}
}
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 1305 "../uuconf.h"
int uuconf_error_string(void *pglobal , int ierr , char *zbuf___0 , unsigned long cbuf___0 ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errstr.c"
char const   _uuconf_errstr_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errstr.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'e',      (char const   )'r',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 31
static char *zeprint_num(char *ab___0 , size_t c , int i ) ;
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errstr.c"
int uuconf_error_string(void *pglobal , int ierr , char *zbuf___0 , unsigned long cbuf___0 ) 
{ 
  struct sglobal *qglobal ;
  char const   *zfile ;
  size_t cfile ;
  char const   *zlineno ;
  char ablineno[100] ;
  size_t clineno ;
  char const   *zmsg ;
  char abmsg[100] ;
  size_t cmsg ;
  char const   *zerrno ;
  size_t cerrno ;
  size_t cret ;
  size_t ccopy ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 43
  qglobal = (struct sglobal *)pglobal;
#line 68
  if ((ierr & 512) == 0) {
#line 72
    zfile = "";
#line 73
    cfile = (size_t )0;
  } else
#line 68
  if ((unsigned long )qglobal == (unsigned long )((void *)0)) {
#line 72
    zfile = "";
#line 73
    cfile = (size_t )0;
  } else
#line 68
  if ((unsigned long )qglobal->zfilename == (unsigned long )((void *)0)) {
#line 72
    zfile = "";
#line 73
    cfile = (size_t )0;
  } else {
    {
#line 77
    zfile = qglobal->zfilename;
#line 78
    tmp = strlen(zfile);
#line 78
    cfile = tmp + 1UL;
    }
  }
#line 82
  if (cfile == 0UL) {
#line 87
    zlineno = "";
#line 88
    clineno = (size_t )0;
  } else
#line 82
  if ((ierr & 1024) == 0) {
#line 87
    zlineno = "";
#line 88
    clineno = (size_t )0;
  } else
#line 82
  if ((unsigned long )qglobal == (unsigned long )((void *)0)) {
#line 87
    zlineno = "";
#line 88
    clineno = (size_t )0;
  } else
#line 82
  if (qglobal->ilineno <= 0) {
#line 87
    zlineno = "";
#line 88
    clineno = (size_t )0;
  } else {
    {
#line 92
    tmp___0 = zeprint_num(ablineno, sizeof(ablineno), qglobal->ilineno);
#line 92
    zlineno = (char const   *)tmp___0;
#line 93
    tmp___1 = strlen(zlineno);
#line 93
    clineno = tmp___1 + 1UL;
    }
  }
  {
#line 99
  if ((ierr & 255) == 0) {
#line 99
    goto case_0;
  }
#line 102
  if ((ierr & 255) == 1) {
#line 102
    goto case_1;
  }
#line 105
  if ((ierr & 255) == 2) {
#line 105
    goto case_2;
  }
#line 108
  if ((ierr & 255) == 3) {
#line 108
    goto case_3;
  }
#line 111
  if ((ierr & 255) == 4) {
#line 111
    goto case_4;
  }
#line 114
  if ((ierr & 255) == 5) {
#line 114
    goto case_5;
  }
#line 117
  goto switch_default;
  case_0: /* CIL Label */ 
#line 100
  zmsg = "no error";
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  zmsg = "not found";
#line 104
  goto switch_break;
  case_2: /* CIL Label */ 
#line 106
  zmsg = "fopen";
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
#line 109
  zmsg = "fseek";
#line 110
  goto switch_break;
  case_4: /* CIL Label */ 
#line 112
  zmsg = "malloc";
#line 113
  goto switch_break;
  case_5: /* CIL Label */ 
#line 115
  zmsg = "syntax error";
#line 116
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 118
  tmp___2 = zeprint_num(abmsg, sizeof(abmsg), ierr & 255);
#line 118
  zmsg = (char const   *)tmp___2;
#line 119
  zmsg -= sizeof("error ") - 1UL;
#line 120
  memcpy((void */* __restrict  */)((pointer )zmsg), (void const   */* __restrict  */)((pointer )"error "),
         sizeof("error ") - 1UL);
  }
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 124
  cmsg = strlen(zmsg);
  }
#line 125
  if (cfile > 0UL) {
#line 126
    cmsg ++;
  }
#line 130
  if ((ierr & 256) == 0) {
#line 133
    zerrno = "";
#line 134
    cerrno = (size_t )0;
  } else
#line 130
  if ((unsigned long )qglobal == (unsigned long )((void *)0)) {
#line 133
    zerrno = "";
#line 134
    cerrno = (size_t )0;
  } else {
    {
#line 138
    tmp___3 = strerror(qglobal->ierrno);
#line 138
    zerrno = (char const   *)tmp___3;
#line 139
    tmp___4 = strlen(zerrno);
#line 139
    cerrno = tmp___4 + 2UL;
    }
  }
#line 142
  cret = (((cfile + clineno) + cmsg) + cerrno) + 1UL;
#line 144
  if (cbuf___0 == 0UL) {
#line 145
    return ((int )cret);
  }
#line 148
  cbuf___0 --;
#line 150
  if (cfile > 0UL) {
#line 152
    ccopy = cfile - 1UL;
#line 153
    if (ccopy > cbuf___0) {
#line 154
      ccopy = cbuf___0;
    }
    {
#line 155
    memcpy((void */* __restrict  */)((pointer )zbuf___0), (void const   */* __restrict  */)((pointer )zfile),
           ccopy);
#line 156
    zbuf___0 += ccopy;
#line 157
    cbuf___0 -= ccopy;
    }
#line 158
    if (cbuf___0 > 0UL) {
#line 160
      tmp___5 = zbuf___0;
#line 160
      zbuf___0 ++;
#line 160
      *tmp___5 = (char )':';
#line 161
      cbuf___0 --;
    }
  }
#line 165
  if (clineno > 0UL) {
#line 167
    ccopy = clineno - 1UL;
#line 168
    if (ccopy > cbuf___0) {
#line 169
      ccopy = cbuf___0;
    }
    {
#line 170
    memcpy((void */* __restrict  */)((pointer )zbuf___0), (void const   */* __restrict  */)((pointer )zlineno),
           ccopy);
#line 171
    zbuf___0 += ccopy;
#line 172
    cbuf___0 -= ccopy;
    }
#line 173
    if (cbuf___0 > 0UL) {
#line 175
      tmp___6 = zbuf___0;
#line 175
      zbuf___0 ++;
#line 175
      *tmp___6 = (char )':';
#line 176
      cbuf___0 --;
    }
  }
#line 180
  if (cbuf___0 > 0UL) {
#line 180
    if (cfile > 0UL) {
#line 182
      tmp___7 = zbuf___0;
#line 182
      zbuf___0 ++;
#line 182
      *tmp___7 = (char )' ';
#line 183
      cbuf___0 --;
#line 184
      cmsg --;
    }
  }
#line 186
  ccopy = cmsg;
#line 187
  if (ccopy > cbuf___0) {
#line 188
    ccopy = cbuf___0;
  }
  {
#line 189
  memcpy((void */* __restrict  */)((pointer )zbuf___0), (void const   */* __restrict  */)((pointer )zmsg),
         ccopy);
#line 190
  zbuf___0 += ccopy;
#line 191
  cbuf___0 -= ccopy;
  }
#line 193
  if (cerrno > 0UL) {
#line 195
    if (cbuf___0 > 0UL) {
#line 197
      tmp___8 = zbuf___0;
#line 197
      zbuf___0 ++;
#line 197
      *tmp___8 = (char )':';
#line 198
      cbuf___0 --;
    }
#line 200
    if (cbuf___0 > 0UL) {
#line 202
      tmp___9 = zbuf___0;
#line 202
      zbuf___0 ++;
#line 202
      *tmp___9 = (char )' ';
#line 203
      cbuf___0 --;
    }
#line 205
    ccopy = cerrno - 2UL;
#line 206
    if (ccopy > cbuf___0) {
#line 207
      ccopy = cbuf___0;
    }
    {
#line 208
    memcpy((void */* __restrict  */)((pointer )zbuf___0), (void const   */* __restrict  */)((pointer )zerrno),
           ccopy);
#line 209
    zbuf___0 += ccopy;
#line 210
    cbuf___0 -= ccopy;
    }
  }
#line 213
  *zbuf___0 = (char )'\000';
#line 215
  return ((int )cret);
}
}
#line 222 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errstr.c"
static char *zeprint_num(char *ab___0 , size_t c , int i ) 
{ 
  register char *z ;

  {
#line 230
  z = ab___0 + c;
#line 231
  z --;
#line 231
  *z = (char )'\000';
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    z --;
#line 234
    *z = (char )(i % 10 + 48);
#line 235
    i /= 10;
#line 232
    if (! (i != 0)) {
#line 232
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return (z);
}
}
#line 1314 "../uuconf.h"
int uuconf_error_errno(void *pglobal ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errno.c"
char const   _uuconf_errno_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errno.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'e',      (char const   )'r',      (char const   )'r', 
        (char const   )'n',      (char const   )'o',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/errno.c"
int uuconf_error_errno(void *pglobal ) 
{ 
  struct sglobal *qglobal ;
  int *tmp ;

  {
#line 39
  qglobal = (struct sglobal *)pglobal;
#line 41
  if ((unsigned long )qglobal == (unsigned long )((void *)0)) {
    {
#line 42
    tmp = __errno_location();
    }
#line 42
    return (*tmp);
  } else {
#line 44
    return (qglobal->ierrno);
  }
}
}
#line 847 "../uuconf.h"
int uuconf_dialer_names(void *pglobal , char ***ppzdialers ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/dnams.c"
char const   _uuconf_dnams_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/dnams.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'n',      (char const   )'a', 
        (char const   )'m',      (char const   )'s',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/dnams.c"
int uuconf_dialer_names(void *pglobal , char ***ppzdialers ) 
{ 
  struct sglobal *qglobal ;
  char **pztaylor ;
  char **pzhdb ;
  int iret ;
  char **pz ;

  {
  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 43
  *ppzdialers = (char **)((void *)0);
#line 44
  pztaylor = (char **)((void *)0);
#line 45
  pzhdb = (char **)((void *)0);
#line 48
  iret = uuconf_taylor_dialer_names(pglobal, & pztaylor);
  }
#line 49
  if (iret != 0) {
#line 50
    return (iret);
  }
#line 62
  if ((unsigned long )pzhdb == (unsigned long )((void *)0)) {
#line 63
    *ppzdialers = pztaylor;
  } else
#line 64
  if ((unsigned long )pztaylor == (unsigned long )((void *)0)) {
#line 65
    *ppzdialers = pzhdb;
  } else {
#line 70
    iret = 0;
#line 72
    pz = pztaylor;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 72
        goto while_break;
      }
      {
#line 74
      iret = _uuconf_iadd_string(qglobal, *pz, 0, 1, ppzdialers, (void *)0);
      }
#line 76
      if (iret != 0) {
#line 77
        goto while_break;
      }
#line 72
      pz ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 80
    if (iret == 0) {
#line 82
      pz = pzhdb;
      {
#line 82
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 82
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 82
          goto while_break___0;
        }
        {
#line 84
        iret = _uuconf_iadd_string(qglobal, *pz, 0, 1, ppzdialers, (void *)0);
        }
#line 86
        if (iret != 0) {
#line 87
          goto while_break___0;
        }
#line 82
        pz ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 91
    if ((unsigned long )pztaylor != (unsigned long )((void *)0)) {
      {
#line 92
      free((pointer )pztaylor);
      }
    }
#line 93
    if ((unsigned long )pzhdb != (unsigned long )((void *)0)) {
      {
#line 94
      free((pointer )pzhdb);
      }
    }
  }
#line 97
  if (iret == 0) {
#line 97
    if ((unsigned long )*ppzdialers == (unsigned long )((void *)0)) {
      {
#line 98
      iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppzdialers, (void *)0);
      }
    }
  }
#line 101
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diasub.c"
char const   _uuconf_diasub_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diasub.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'a', 
        (char const   )'s',      (char const   )'u',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 40 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diasub.c"
void _uuconf_uclear_dialer(struct uuconf_dialer *qdialer ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 44
  qdialer->uuconf_zname = (char *)((void *)0);
#line 45
  qdialer->uuconf_schat.uuconf_pzchat = (char **)((void *)0);
#line 45
  qdialer->uuconf_schat.uuconf_pzprogram = (char **)((void *)0);
#line 45
  qdialer->uuconf_schat.uuconf_ctimeout = 60;
#line 45
  qdialer->uuconf_schat.uuconf_pzfail = (char **)((void *)0);
#line 45
  qdialer->uuconf_schat.uuconf_fstrip = 1;
#line 46
  qdialer->uuconf_zdialtone = (char *)",";
#line 47
  qdialer->uuconf_zpause = (char *)",";
#line 48
  qdialer->uuconf_fcarrier = 1;
#line 49
  qdialer->uuconf_ccarrier_wait = 60;
#line 50
  qdialer->uuconf_fdtr_toggle = 0;
#line 51
  qdialer->uuconf_fdtr_toggle_wait = 0;
#line 52
  qdialer->uuconf_scomplete.uuconf_pzchat = (char **)((void *)0);
#line 52
  qdialer->uuconf_scomplete.uuconf_pzprogram = (char **)((void *)0);
#line 52
  qdialer->uuconf_scomplete.uuconf_ctimeout = 60;
#line 52
  qdialer->uuconf_scomplete.uuconf_pzfail = (char **)((void *)0);
#line 52
  qdialer->uuconf_scomplete.uuconf_fstrip = 1;
#line 53
  qdialer->uuconf_sabort.uuconf_pzchat = (char **)((void *)0);
#line 53
  qdialer->uuconf_sabort.uuconf_pzprogram = (char **)((void *)0);
#line 53
  qdialer->uuconf_sabort.uuconf_ctimeout = 60;
#line 53
  qdialer->uuconf_sabort.uuconf_pzfail = (char **)((void *)0);
#line 53
  qdialer->uuconf_sabort.uuconf_fstrip = 1;
#line 54
  qdialer->uuconf_qproto_params = (struct uuconf_proto_param *)((void *)0);
#line 58
  qdialer->uuconf_ireliable = 22;
#line 61
  qdialer->uuconf_palloc = (void *)0;
#line 62
  return;
}
}
#line 852 "../uuconf.h"
int uuconf_dialer_info(void *pglobal , char const   *zdialer , struct uuconf_dialer *qdialer ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/dial.c"
char const   _uuconf_dial_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/dial.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'a', 
        (char const   )'l',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'7',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/dial.c"
int uuconf_dialer_info(void *pglobal , char const   *zdialer , struct uuconf_dialer *qdialer ) 
{ 
  int iret ;

  {
  {
#line 45
  iret = uuconf_taylor_dialer_info(pglobal, zdialer, qdialer);
  }
#line 46
  if (iret != 1) {
#line 47
    return (iret);
  }
#line 59
  return (1);
}
}
#line 995 "../uuconf.h"
int uuconf_dialcode(void *pglobal , char const   *zdial , char **pznum ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diacod.c"
char const   _uuconf_diacod_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diacod.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'a', 
        (char const   )'c',      (char const   )'o',      (char const   )'d',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'2', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 33
static int idcode(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) ;
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diacod.c"
int uuconf_dialcode(void *pglobal , char const   *zdial , char **pznum ) 
{ 
  struct sglobal *qglobal ;
  struct uuconf_cmdtab as[2] ;
  char **pz ;
  int iret ;
  FILE *e ;
  int *tmp ;
  int *tmp___0 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 44
  qglobal = (struct sglobal *)pglobal;
#line 49
  as[0].uuconf_zcmd = zdial;
#line 50
  as[0].uuconf_itype = 96;
#line 51
  as[0].uuconf_pvar = (pointer )pznum;
#line 52
  as[0].uuconf_pifn = & idcode;
#line 54
  as[1].uuconf_zcmd = (char const   *)((void *)0);
#line 56
  *pznum = (char *)((void *)0);
#line 58
  iret = 0;
#line 60
  pz = (qglobal->qprocess)->pzdialcodefiles;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 60
      goto while_break;
    }
    {
#line 64
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 65
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 67
      tmp = __errno_location();
      }
#line 67
      if (*tmp == 2) {
#line 68
        goto __Cont;
      }
      {
#line 69
      tmp___0 = __errno_location();
#line 69
      qglobal->ierrno = *tmp___0;
#line 70
      iret = 258;
      }
#line 71
      goto while_break;
    }
    {
#line 74
    iret = uuconf_cmd_file(pglobal, e, (struct uuconf_cmdtab  const  *)(as), (void *)0,
                           (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                                    void *uuconf_pvar , void *uuconf_pinfo ))((void *)0),
                           0, (void *)0);
#line 76
    fclose(e);
    }
#line 78
    if (iret != 0) {
#line 79
      goto while_break;
    } else
#line 78
    if ((unsigned long )*pznum != (unsigned long )((void *)0)) {
#line 79
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 60
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (iret != 0) {
#line 84
    qglobal->zfilename = (char const   *)*pz;
#line 85
    iret |= 512;
  } else
#line 87
  if ((unsigned long )*pznum == (unsigned long )((void *)0)) {
#line 88
    iret = 1;
  }
#line 90
  return (iret);
}
}
#line 97 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/diacod.c"
static int idcode(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo  __attribute__((__unused__)) ) 
{ 
  struct sglobal *qglobal ;
  char **pznum ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 105
  qglobal = (struct sglobal *)pglobal;
#line 106
  pznum = (char **)pvar;
#line 108
  if (argc == 1) {
    {
#line 110
    tmp = malloc((size_t )1);
#line 110
    *pznum = (char *)tmp;
    }
#line 111
    if ((unsigned long )*pznum != (unsigned long )((void *)0)) {
#line 112
      *(*pznum) = (char )'\000';
    }
  } else
#line 114
  if (argc == 2) {
    {
#line 115
    *pznum = strdup((char const   *)*(argv + 1));
    }
  } else {
#line 117
    return (4101);
  }
#line 119
  if ((unsigned long )*pznum == (unsigned long )((void *)0)) {
    {
#line 121
    tmp___0 = __errno_location();
#line 121
    qglobal->ierrno = *tmp___0;
    }
#line 122
    return (4356);
  }
#line 127
  return (4096);
}
}
#line 930 "../uuconf.h"
int uuconf_debuglevel(void *pglobal , char const   **pzdebug ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/deblev.c"
char const   _uuconf_deblev_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/deblev.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'v',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/deblev.c"
int uuconf_debuglevel(void *pglobal , char const   **pzdebug ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzdebug = (qglobal->qprocess)->zdebug;
#line 41
  return (0);
}
}
#line 923 "../uuconf.h"
int uuconf_debugfile(void *pglobal , char const   **pzdebug ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/debfil.c"
char const   _uuconf_debfil_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/debfil.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/debfil.c"
int uuconf_debugfile(void *pglobal , char const   **pzdebug ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  *pzdebug = (qglobal->qprocess)->zdebugfile;
#line 41
  return (0);
}
}
#line 870 "../uuconf.h"
int uuconf_config_files(void *pglobal , struct uuconf_config_file_names *qnames ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cnfnms.c"
char const   _uuconf_cnfnms_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cnfnms.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'n',      (char const   )'f', 
        (char const   )'n',      (char const   )'m',      (char const   )'s',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 33 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cnfnms.c"
int uuconf_config_files(void *pglobal , struct uuconf_config_file_names *qnames ) 
{ 
  struct sglobal *qglobal ;

  {
#line 38
  qglobal = (struct sglobal *)pglobal;
#line 40
  qnames->uuconf_ztaylor_config = (char const   *)(qglobal->qprocess)->zconfigfile;
#line 41
  qnames->uuconf_pztaylor_sys = (char const   * const  *)(qglobal->qprocess)->pzsysfiles;
#line 43
  qnames->uuconf_pztaylor_port = (char const   * const  *)(qglobal->qprocess)->pzportfiles;
#line 45
  qnames->uuconf_pztaylor_dial = (char const   * const  *)(qglobal->qprocess)->pzdialfiles;
#line 47
  qnames->uuconf_pzdialcode = (char const   * const  *)(qglobal->qprocess)->pzdialcodefiles;
#line 49
  qnames->uuconf_pztaylor_pwd = (char const   * const  *)(qglobal->qprocess)->pzpwdfiles;
#line 51
  qnames->uuconf_pztaylor_call = (char const   * const  *)(qglobal->qprocess)->pzcallfiles;
#line 54
  qnames->uuconf_zv2_systems = (char const   *)(qglobal->qprocess)->zv2systems;
#line 55
  qnames->uuconf_zv2_device = (char const   *)(qglobal->qprocess)->zv2devices;
#line 56
  qnames->uuconf_zv2_userfile = (char const   *)(qglobal->qprocess)->zv2userfile;
#line 57
  qnames->uuconf_zv2_cmds = (char const   *)(qglobal->qprocess)->zv2cmds;
#line 59
  qnames->uuconf_pzhdb_systems = (char const   * const  *)(qglobal->qprocess)->pzhdb_systems;
#line 61
  qnames->uuconf_pzhdb_devices = (char const   * const  *)(qglobal->qprocess)->pzhdb_devices;
#line 63
  qnames->uuconf_pzhdb_dialers = (char const   * const  *)(qglobal->qprocess)->pzhdb_dialers;
#line 66
  qnames->uuconf_zhdb_permissions = (char const   *)((void *)0);
#line 89
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdlin.c"
char const   _uuconf_cmdlin_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdlin.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'m',      (char const   )'d', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdlin.c"
int uuconf_cmd_line(void *pglobal , char *zline , struct uuconf_cmdtab  const  *qtab ,
                    void *pinfo , int (*pfiunknown)(void *uuconf_pglobal , int uuconf_argc ,
                                                    char **uuconf_argv , void *uuconf_pvar ,
                                                    void *uuconf_pinfo ) , int iflags ,
                    void *pblock ) 
{ 
  struct sglobal *qglobal ;
  char *z ;
  int cargs ;
  char *azargs[16] ;
  char **pzargs ;
  int iret ;
  char tmp ;
  unsigned short const   **tmp___0 ;
  char **pzsplit ;
  size_t csplit ;
  int cmore ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp24 ;

  {
#line 51
  qglobal = (struct sglobal *)pglobal;
#line 58
  if ((iflags & 4) == 0) {
#line 61
    z = zline;
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 62
      z = strchr((char const   *)z, '#');
      }
#line 62
      if (! ((unsigned long )z != (unsigned long )((void *)0))) {
#line 62
        goto while_break;
      }
#line 64
      if ((unsigned long )z == (unsigned long )zline) {
#line 66
        *z = (char )'\000';
#line 67
        goto while_break;
      } else
#line 64
      if ((int )*(z - 1) != 92) {
#line 66
        *z = (char )'\000';
#line 67
        goto while_break;
      }
      {
#line 70
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 70
        tmp = *z;
#line 70
        *(z - 1) = tmp;
#line 70
        if (! ((int )tmp != 0)) {
#line 70
          goto while_break___0;
        }
#line 71
        z ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 77
  z = zline;
#line 78
  cargs = 0;
#line 79
  pzargs = azargs;
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 82
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 82
      if ((int )*z != 0) {
        {
#line 82
        tmp___0 = __ctype_b_loc();
        }
#line 82
        if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*z)) & 8192)) {
#line 82
          goto while_break___2;
        }
      } else {
#line 82
        goto while_break___2;
      }
#line 83
      z ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 85
    if ((int )*z == 0) {
#line 86
      goto while_break___1;
    }
#line 88
    if (cargs >= 16) {
      {
#line 94
      pzsplit = (char **)((void *)0);
#line 95
      csplit = (size_t )0;
#line 96
      cmore = _uuconf_istrsplit(z, '\000', & pzsplit, & csplit);
      }
#line 97
      if (cmore < 0) {
        {
#line 99
        tmp___1 = __errno_location();
#line 99
        qglobal->ierrno = *tmp___1;
        }
#line 100
        return (260);
      }
      {
#line 103
      tmp___2 = malloc((unsigned long )(cmore + 16) * sizeof(char *));
#line 103
      pzargs = (char **)tmp___2;
      }
#line 104
      if ((unsigned long )pzargs == (unsigned long )((void *)0)) {
        {
#line 106
        tmp___3 = __errno_location();
#line 106
        qglobal->ierrno = *tmp___3;
#line 107
        free((pointer )pzsplit);
        }
#line 108
        return (260);
      }
      {
#line 111
      memcpy((void */* __restrict  */)((pointer )pzargs), (void const   */* __restrict  */)((pointer )(azargs)),
             16UL * sizeof(char *));
#line 113
      memcpy((void */* __restrict  */)((pointer )(pzargs + 16)), (void const   */* __restrict  */)((pointer )pzsplit),
             (unsigned long )cmore * sizeof(char *));
#line 115
      cargs = cmore + 16;
#line 117
      free((pointer )pzsplit);
      }
#line 119
      goto while_break___1;
    }
#line 122
    azargs[cargs] = z;
#line 123
    cargs ++;
    {
#line 125
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 125
      if ((int )*z != 0) {
        {
#line 125
        tmp___4 = __ctype_b_loc();
        }
#line 125
        if ((int const   )*(*tmp___4 + (int )((unsigned char )*z)) & 8192) {
#line 125
          goto while_break___3;
        }
      } else {
#line 125
        goto while_break___3;
      }
#line 126
      z ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 128
    if ((int )*z == 0) {
#line 129
      goto while_break___1;
    }
#line 131
    tmp___5 = z;
#line 131
    z ++;
#line 131
    *tmp___5 = (char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 134
  if (cargs <= 0) {
#line 135
    return (0);
  }
  {
#line 137
  iret = uuconf_cmd_args(pglobal, cargs, pzargs, qtab, pinfo, pfiunknown, iflags,
                         pblock);
  }
#line 140
  if ((unsigned long )pzargs != (unsigned long )(azargs)) {
    {
#line 141
    free((pointer )pzargs);
    }
  }
#line 143
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdfil.c"
char const   _uuconf_cmdfil_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdfil.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'m',      (char const   )'d', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdfil.c"
int uuconf_cmd_file(void *pglobal , FILE *e , struct uuconf_cmdtab  const  *qtab ,
                    void *pinfo , int (*pfiunknown)(void *uuconf_pglobal , int uuconf_argc ,
                                                    char **uuconf_argv , void *uuconf_pvar ,
                                                    void *uuconf_pinfo ) , int iflags ,
                    void *pblock ) 
{ 
  struct sglobal *qglobal ;
  boolean fcont ;
  char *zline ;
  size_t cline ;
  int iret ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __ssize_t tmp___2 ;
  __ssize_t tmp___3 ;

  {
#line 46
  qglobal = (struct sglobal *)pglobal;
#line 52
  fcont = (iflags & 2) != 0;
#line 54
  zline = (char *)((void *)0);
#line 55
  cline = (size_t )0;
#line 57
  iret = 0;
#line 59
  qglobal->ilineno = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (fcont) {
      {
#line 61
      tmp___1 = _uuconf_getline(qglobal, & zline, & cline, e);
#line 61
      tmp___3 = (__ssize_t )tmp___1;
      }
    } else {
      {
#line 61
      tmp___2 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                        (FILE */* __restrict  */)e);
#line 61
      tmp___3 = tmp___2;
      }
    }
#line 61
    if (! (tmp___3 > 0L)) {
#line 61
      goto while_break;
    }
    {
#line 65
    (qglobal->ilineno) ++;
#line 67
    iret = uuconf_cmd_line(pglobal, zline, qtab, pinfo, pfiunknown, iflags, pblock);
    }
#line 70
    if ((iret & 2048) != 0) {
#line 72
      iret &= -2049;
#line 74
      if ((unsigned long )pblock != (unsigned long )((void *)0)) {
        {
#line 76
        tmp___0 = uuconf_add_block(pblock, (void *)zline);
        }
#line 76
        if (tmp___0 != 0) {
          {
#line 78
          tmp = __errno_location();
#line 78
          qglobal->ierrno = *tmp;
#line 79
          iret = 1284;
          }
#line 82
          goto while_break;
        }
      }
#line 86
      zline = (char *)((void *)0);
#line 87
      cline = (size_t )0;
    }
#line 90
    if ((iret & 4096) != 0) {
#line 92
      iret &= -4097;
#line 93
      if (iret != 0) {
#line 94
        iret |= 1024;
      }
#line 95
      goto while_break;
    }
#line 98
    iret = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 102
    free((pointer )zline);
    }
  }
#line 104
  return (iret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdarg.c"
char const   _uuconf_cmdarg_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdarg.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'m',      (char const   )'d', 
        (char const   )'a',      (char const   )'r',      (char const   )'g',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/cmdarg.c"
int uuconf_cmd_args(void *pglobal , int cargs , char **pzargs , struct uuconf_cmdtab  const  *qtab ,
                    void *pinfo , int (*pfiunknown)(void *uuconf_pglobal , int uuconf_argc ,
                                                    char **uuconf_argv , void *uuconf_pvar ,
                                                    void *uuconf_pinfo ) , int iflags ,
                    void *pblock ) 
{ 
  struct sglobal *qglobal ;
  int bfirstu ;
  int bfirstl ;
  int (*pficmp)(char const   * , char const   * ) ;
  register struct uuconf_cmdtab  const  *q ;
  int itype ;
  int callowed ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int bfirst ;
  int tmp___1 ;
  size_t clen ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char ***ppz ;
  int iret ;
  char ***ppz___0 ;
  int i ;
  int iret___0 ;
  int tmp___8 ;
  char *__cil_tmp33 ;

  {
#line 53
  qglobal = (struct sglobal *)pglobal;
#line 60
  bfirstl = (int )*(*(pzargs + 0) + 0);
#line 60
  bfirstu = bfirstl;
#line 61
  if ((iflags & 1) != 0) {
#line 62
    pficmp = (int (*)(char const   * , char const   * ))(& strcmp);
  } else {
    {
#line 65
    tmp = __ctype_b_loc();
    }
#line 65
    if ((int const   )*(*tmp + bfirstu) & 512) {
      {
#line 66
      bfirstu = toupper(bfirstu);
      }
    }
    {
#line 67
    tmp___0 = __ctype_b_loc();
    }
#line 67
    if ((int const   )*(*tmp___0 + bfirstl) & 256) {
      {
#line 68
      bfirstl = tolower(bfirstl);
      }
    }
#line 69
    pficmp = (int (*)(char const   * , char const   * ))(& strcasecmp);
  }
#line 72
  itype = 0;
#line 74
  q = qtab;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )q->uuconf_zcmd != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 78
    bfirst = (int )*(q->uuconf_zcmd + 0);
#line 79
    if (bfirst != bfirstu) {
#line 79
      if (bfirst != bfirstl) {
#line 80
        goto __Cont;
      }
    }
#line 82
    itype = (int )(q->uuconf_itype & 112);
#line 83
    if (itype != 112) {
      {
#line 85
      tmp___1 = (*pficmp)((char const   *)q->uuconf_zcmd, (char const   *)*(pzargs + 0));
      }
#line 85
      if (tmp___1 == 0) {
#line 86
        goto while_break;
      }
    } else {
      {
#line 92
      clen = strlen((char const   *)q->uuconf_zcmd);
      }
#line 93
      if ((iflags & 1) != 0) {
        {
#line 95
        tmp___2 = strncmp((char const   *)q->uuconf_zcmd, (char const   *)*(pzargs + 0),
                          clen);
        }
#line 95
        if (tmp___2 == 0) {
#line 96
          goto while_break;
        }
      } else {
        {
#line 100
        tmp___3 = strncasecmp((char const   *)q->uuconf_zcmd, (char const   *)*(pzargs + 0),
                              clen);
        }
#line 100
        if (tmp___3 == 0) {
#line 101
          goto while_break;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 74
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if ((unsigned long )q->uuconf_zcmd == (unsigned long )((void *)0)) {
#line 108
    if ((unsigned long )pfiunknown == (unsigned long )((void *)0)) {
#line 109
      return (0);
    }
    {
#line 110
    tmp___4 = (*pfiunknown)(pglobal, cargs, pzargs, (void *)0, pinfo);
    }
#line 110
    return (tmp___4);
  }
#line 113
  callowed = (int )(q->uuconf_itype & 15);
#line 114
  if (callowed != 0) {
#line 114
    if (callowed != cargs) {
#line 115
      return (4101);
    }
  }
  {
#line 119
  if (itype == 64) {
#line 119
    goto case_64;
  }
#line 129
  if (itype == 32) {
#line 129
    goto case_32;
  }
#line 132
  if (itype == 48) {
#line 132
    goto case_48;
  }
#line 135
  if (itype == 16) {
#line 135
    goto case_16;
  }
#line 138
  if (itype == 80) {
#line 138
    goto case_80;
  }
#line 175
  if (itype == 112) {
#line 175
    goto case_112;
  }
#line 175
  if (itype == 96) {
#line 175
    goto case_112;
  }
#line 179
  goto switch_default;
  case_64: /* CIL Label */ 
#line 120
  if (cargs == 1) {
#line 121
    *((char **)q->uuconf_pvar) = (char *)"";
  } else
#line 122
  if (cargs == 2) {
#line 123
    *((char **)q->uuconf_pvar) = *(pzargs + 1);
  } else {
#line 125
    return (4101);
  }
#line 127
  return (2048);
  case_32: /* CIL Label */ 
  {
#line 130
  tmp___5 = _uuconf_iint(qglobal, (char const   *)*(pzargs + 1), (pointer )q->uuconf_pvar,
                         1);
  }
#line 130
  return (tmp___5);
  case_48: /* CIL Label */ 
  {
#line 133
  tmp___6 = _uuconf_iint(qglobal, (char const   *)*(pzargs + 1), (pointer )q->uuconf_pvar,
                         0);
  }
#line 133
  return (tmp___6);
  case_16: /* CIL Label */ 
  {
#line 136
  tmp___7 = _uuconf_iboolean(qglobal, (char const   *)*(pzargs + 1), (int *)q->uuconf_pvar);
  }
#line 136
  return (tmp___7);
  case_80: /* CIL Label */ 
#line 139
  if (cargs == 1) {
    {
#line 141
    ppz = (char ***)q->uuconf_pvar;
#line 144
    *ppz = (char **)((void *)0);
#line 145
    iret = _uuconf_iadd_string(qglobal, (char *)((void *)0), 0, 0, ppz, pblock);
    }
#line 147
    if (iret != 0) {
#line 148
      return (iret | 4096);
    }
#line 150
    return (0);
  } else {
#line 154
    ppz___0 = (char ***)q->uuconf_pvar;
#line 157
    *ppz___0 = (char **)((void *)0);
#line 158
    i = 1;
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! (i < cargs)) {
#line 158
        goto while_break___0;
      }
      {
#line 162
      iret___0 = _uuconf_iadd_string(qglobal, *(pzargs + i), 0, 0, ppz___0, pblock);
      }
#line 164
      if (iret___0 != 0) {
#line 166
        *ppz___0 = (char **)((void *)0);
#line 167
        return (iret___0 | 4096);
      }
#line 158
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 171
    return (2048);
  }
  case_112: /* CIL Label */ 
  case_96: /* CIL Label */ 
  {
#line 176
  tmp___8 = (*(q->uuconf_pifn))(pglobal, cargs, pzargs, (void *)q->uuconf_pvar, pinfo);
  }
#line 176
  return (tmp___8);
  switch_default: /* CIL Label */ 
#line 180
  return (4101);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
char const   _uuconf_chatc_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'0',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 34
static int icchat(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) ;
#line 36
static int icchat_fail(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                       pointer pvar , pointer pinfo ) ;
#line 38
static int icunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                     char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo  __attribute__((__unused__)) ) ;
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
static struct cmdtab_offset  const  asChat_cmds[6]  = {      {"chat", 96, (unsigned long )(& ((struct uuconf_chat *)0)->uuconf_pzchat), & icchat}, 
        {"chat-program",
      80, (unsigned long )(& ((struct uuconf_chat *)0)->uuconf_pzprogram), (int (*)(void *uuconf_pglobal ,
                                                                                    int uuconf_argc ,
                                                                                    char **uuconf_argv ,
                                                                                    void *uuconf_pvar ,
                                                                                    void *uuconf_pinfo ))((void *)0)}, 
        {"chat-timeout",
      34, (unsigned long )(& ((struct uuconf_chat *)0)->uuconf_ctimeout), (int (*)(void *uuconf_pglobal ,
                                                                                   int uuconf_argc ,
                                                                                   char **uuconf_argv ,
                                                                                   void *uuconf_pvar ,
                                                                                   void *uuconf_pinfo ))((void *)0)}, 
        {"chat-fail",
      98, (unsigned long )(& ((struct uuconf_chat *)0)->uuconf_pzfail), & icchat_fail}, 
        {"chat-seven-bit",
      18, (unsigned long )(& ((struct uuconf_chat *)0)->uuconf_fstrip), (int (*)(void *uuconf_pglobal ,
                                                                                 int uuconf_argc ,
                                                                                 char **uuconf_argv ,
                                                                                 void *uuconf_pvar ,
                                                                                 void *uuconf_pinfo ))((void *)0)}, 
        {(char const   *)((void *)0),
      0, (size_t )0, (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                              void *uuconf_pvar , void *uuconf_pinfo ))((void *)0)}};
#line 67 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
int _uuconf_ichat_cmd(struct sglobal *qglobal , int argc , char **argv , struct uuconf_chat *qchat ,
                      pointer pblock ) 
{ 
  char *zchat ;
  struct uuconf_cmdtab as[sizeof(asChat_cmds) / sizeof(asChat_cmds[0])] ;
  int iret ;
  int tmp ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 81
  zchat = *(argv + 0);
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((int )*zchat != 0)) {
#line 81
      goto while_break;
    }
#line 82
    if ((int )*zchat == 99) {
#line 82
      goto _L;
    } else
#line 82
    if ((int )*zchat == 67) {
      _L: /* CIL Label */ 
      {
#line 82
      tmp = strncasecmp((char const   *)zchat, "chat", sizeof("chat") - 1UL);
      }
#line 82
      if (tmp == 0) {
#line 84
        goto while_break;
      }
    }
#line 81
    zchat ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if ((int )*zchat == 0) {
#line 86
    return (5);
  }
  {
#line 87
  *(argv + 0) = zchat;
#line 89
  _uuconf_ucmdtab_base(asChat_cmds, sizeof(asChat_cmds) / sizeof(asChat_cmds[0]),
                       (char *)qchat, as);
#line 91
  iret = uuconf_cmd_args((pointer )qglobal, argc, argv, (struct uuconf_cmdtab  const  *)(as),
                         pblock, & icunknown, 0, pblock);
  }
#line 97
  if ((unsigned long )qchat->uuconf_pzprogram != (unsigned long )((void *)0)) {
#line 97
    if ((unsigned long )*(qchat->uuconf_pzprogram + 0) == (unsigned long )((void *)0)) {
#line 98
      qchat->uuconf_pzprogram = (char **)((void *)0);
    }
  }
#line 100
  return (iret & -4097);
}
}
#line 106 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
static int icchat(pointer pglobal , int argc , char **argv , pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  char ***ppz ;
  pointer pblock ;
  int i ;
  char *z ;
  char *zdash ;
  int iret ;
  size_t clen ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 114
  qglobal = (struct sglobal *)pglobal;
#line 115
  ppz = (char ***)pvar;
#line 116
  pblock = pinfo;
#line 119
  *ppz = (char **)((void *)0);
#line 121
  i = 1;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < argc)) {
#line 121
      goto while_break;
    }
    {
#line 127
    z = *(argv + i);
#line 128
    zdash = strchr((char const   *)z, '-');
    }
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! ((unsigned long )zdash != (unsigned long )((void *)0))) {
#line 129
        goto while_break___0;
      }
      {
#line 131
      *zdash = (char )'\000';
#line 132
      iret = _uuconf_iadd_string(qglobal, z, 1, 0, ppz, pblock);
      }
#line 134
      if (iret != 0) {
#line 135
        return (iret);
      }
      {
#line 136
      *zdash = (char )'-';
#line 137
      z = zdash;
#line 138
      zdash = strchr((char const   *)(z + 1), '-');
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 141
    iret = _uuconf_iadd_string(qglobal, z, 0, 0, ppz, pblock);
    }
#line 142
    if (iret != 0) {
#line 143
      return (iret);
    }
#line 149
    if (i + 1 < argc) {
#line 151
      if ((int )*(*(argv + (i + 1)) + 0) != 45) {
        {
#line 152
        iret = _uuconf_iadd_string(qglobal, *(argv + (i + 1)), 0, 0, ppz, pblock);
        }
      } else {
        {
#line 158
        clen = strlen((char const   *)*(argv + (i + 1)));
#line 159
        tmp = uuconf_malloc(pblock, clen + 2UL);
#line 159
        z = (char *)tmp;
        }
#line 160
        if ((unsigned long )z == (unsigned long )((void *)0)) {
          {
#line 162
          tmp___0 = __errno_location();
#line 162
          qglobal->ierrno = *tmp___0;
          }
#line 163
          return (260);
        }
        {
#line 165
        *(z + 0) = (char )'\\';
#line 166
        memcpy((void */* __restrict  */)((pointer )(z + 1)), (void const   */* __restrict  */)((pointer )*(argv + (i + 1))),
               clen + 1UL);
#line 167
        iret = _uuconf_iadd_string(qglobal, z, 0, 0, ppz, pblock);
        }
      }
#line 170
      if (iret != 0) {
#line 171
        return (iret);
      }
    }
#line 121
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (2048);
}
}
#line 181 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
static int icchat_fail(pointer pglobal , int argc  __attribute__((__unused__)) , char **argv ,
                       pointer pvar , pointer pinfo ) 
{ 
  struct sglobal *qglobal ;
  char ***ppz ;
  pointer pblock ;
  int tmp ;

  {
  {
#line 189
  qglobal = (struct sglobal *)pglobal;
#line 190
  ppz = (char ***)pvar;
#line 191
  pblock = pinfo;
#line 193
  tmp = _uuconf_iadd_string(qglobal, *(argv + 1), 1, 0, ppz, pblock);
  }
#line 193
  return (tmp);
}
}
#line 199 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/chatc.c"
static int icunknown(pointer pglobal  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ,
                     char **argv  __attribute__((__unused__)) , pointer pvar  __attribute__((__unused__)) ,
                     pointer pinfo  __attribute__((__unused__)) ) 
{ 


  {
#line 207
  return (5);
}
}
#line 971 "../uuconf.h"
int uuconf_callout(void *pglobal , struct uuconf_system  const  *qsys , char **pzlog ,
                   char **pzpass ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/calout.c"
char const   _uuconf_calout_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/calout.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )'u',      (char const   )'t',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/calout.c"
int uuconf_callout(void *pglobal , struct uuconf_system  const  *qsys , char **pzlog ,
                   char **pzpass ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = uuconf_taylor_callout(pglobal, qsys, pzlog, pzpass);
  }
#line 45
  return (tmp);
}
}
#line 963 "../uuconf.h"
int uuconf_callin(void *pglobal , int (*pcmpfn)(int  , void * , char const   * ) ,
                  void *pinfo ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/callin.c"
char const   _uuconf_callin_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/callin.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'4', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 33
static int ipcheck(pointer pglobal  __attribute__((__unused__)) , int argc , char **argv ,
                   pointer pvar  __attribute__((__unused__)) , pointer pinfo ) ;
#line 49 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/callin.c"
int uuconf_callin(void *pglobal , int (*pcmpfn)(int  , void * , char const   * ) ,
                  void *pinfo ) 
{ 
  struct sglobal *qglobal ;
  int iret ;
  char **pz ;
  struct uuconf_cmdtab as[1] ;
  struct sinfo___2 s ;
  char *zline ;
  size_t cline ;
  char ab___0[(sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp") + sizeof("/passwd")) - 1UL] ;
  FILE *e ;
  int *tmp ;
  int *tmp___0 ;
  char *z0 ;
  char *z1 ;
  char *tmp___1 ;
  __ssize_t tmp___2 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 55
  qglobal = (struct sglobal *)pglobal;
#line 64
  if ((unsigned long )(qglobal->qprocess)->pzpwdfiles == (unsigned long )((void *)0)) {
    {
#line 68
    memcpy((void */* __restrict  */)((pointer )(ab___0)), (void const   */* __restrict  */)((pointer )"/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp"),
           sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp") - 1UL);
#line 70
    memcpy((void */* __restrict  */)((pointer )((ab___0 + sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/conf/uucp")) - 1)),
           (void const   */* __restrict  */)((pointer )"/passwd"), sizeof("/passwd"));
#line 72
    iret = _uuconf_iadd_string(qglobal, ab___0, 1, 0, & (qglobal->qprocess)->pzpwdfiles,
                               qglobal->pblock);
    }
#line 75
    if (iret != 0) {
#line 76
      return (iret);
    }
  }
#line 79
  as[0].uuconf_zcmd = (char const   *)((void *)0);
#line 81
  s.pcmpfn = pcmpfn;
#line 82
  s.pinfo = pinfo;
#line 83
  s.ffound = 0;
#line 84
  s.fmatched = 0;
#line 86
  zline = (char *)((void *)0);
#line 87
  cline = (size_t )0;
#line 89
  iret = 0;
#line 91
  pz = (qglobal->qprocess)->pzpwdfiles;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 91
      goto while_break;
    }
    {
#line 95
    e = fopen((char const   */* __restrict  */)*pz, (char const   */* __restrict  */)"r");
    }
#line 96
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 98
      tmp = __errno_location();
      }
#line 98
      if (*tmp == 2) {
#line 99
        goto __Cont;
      }
      {
#line 100
      tmp___0 = __errno_location();
#line 100
      qglobal->ierrno = *tmp___0;
#line 101
      iret = 258;
      }
#line 102
      goto while_break;
    }
#line 105
    qglobal->ilineno = 0;
#line 107
    iret = 0;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 109
      tmp___2 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                        (FILE */* __restrict  */)e);
      }
#line 109
      if (! (tmp___2 > 0L)) {
#line 109
        goto while_break___0;
      }
      {
#line 113
      (qglobal->ilineno) ++;
#line 122
      z0 = strchr((char const   *)zline, ':');
      }
#line 123
      if ((unsigned long )z0 != (unsigned long )((void *)0)) {
        {
#line 125
        *z0 = (char )' ';
#line 126
        z1 = strchr((char const   *)z0, ':');
        }
#line 127
        if ((unsigned long )z1 != (unsigned long )((void *)0)) {
#line 129
          if (z1 - z0 == 1L) {
#line 130
            goto while_continue___0;
          }
          {
#line 131
          *z1 = (char )'\000';
#line 132
          tmp___1 = strchr((char const   *)(z0 + 1), ' ');
          }
#line 132
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 133
            goto while_continue___0;
          }
        }
      }
      {
#line 136
      iret = uuconf_cmd_line(pglobal, zline, (struct uuconf_cmdtab  const  *)(as),
                             (pointer )(& s), & ipcheck, 0, (void *)0);
      }
#line 138
      if ((iret & 4096) != 0) {
#line 140
        iret &= -4097;
#line 141
        if (iret != 0) {
#line 142
          iret |= 1024;
        }
#line 143
        goto while_break___0;
      }
#line 146
      iret = 0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 149
    fclose(e);
    }
#line 151
    if (iret != 0) {
#line 152
      goto while_break;
    } else
#line 151
    if (s.ffound) {
#line 152
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 91
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if ((unsigned long )zline != (unsigned long )((void *)0)) {
    {
#line 156
    free((pointer )zline);
    }
  }
#line 158
  if (iret != 0) {
#line 160
    qglobal->zfilename = (char const   *)*pz;
#line 161
    iret |= 512;
  } else
#line 163
  if (! s.ffound) {
#line 164
    iret = 1;
  } else
#line 163
  if (! s.fmatched) {
#line 164
    iret = 1;
  }
#line 166
  return (iret);
}
}
#line 174 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/callin.c"
static int ipcheck(pointer pglobal  __attribute__((__unused__)) , int argc , char **argv ,
                   pointer pvar  __attribute__((__unused__)) , pointer pinfo ) 
{ 
  struct sinfo___2 *q ;
  int tmp ;
  int tmp___0 ;

  {
#line 182
  q = (struct sinfo___2 *)pinfo;
#line 184
  if (argc != 2) {
#line 185
    return (4101);
  }
  {
#line 187
  tmp = (*(q->pcmpfn))(0, q->pinfo, (char const   *)*(argv + 0));
  }
#line 187
  if (! tmp) {
#line 188
    return (0);
  }
  {
#line 190
  q->ffound = 1;
#line 191
  tmp___0 = (*(q->pcmpfn))(1, q->pinfo, (char const   *)*(argv + 1));
#line 191
  q->fmatched = tmp___0 != 0;
  }
#line 193
  return (4096);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/bool.c"
char const   _uuconf_bool_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/bool.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'8',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/bool.c"
int _uuconf_iboolean(struct sglobal *qglobal  __attribute__((__unused__)) , char const   *zval ,
                     int *pi ) 
{ 


  {
  {
#line 48
  if ((int const   )*zval == 84) {
#line 48
    goto case_84;
  }
#line 48
  if ((int const   )*zval == 116) {
#line 48
    goto case_84;
  }
#line 48
  if ((int const   )*zval == 89) {
#line 48
    goto case_84;
  }
#line 48
  if ((int const   )*zval == 121) {
#line 48
    goto case_84;
  }
#line 54
  if ((int const   )*zval == 70) {
#line 54
    goto case_70;
  }
#line 54
  if ((int const   )*zval == 102) {
#line 54
    goto case_70;
  }
#line 54
  if ((int const   )*zval == 78) {
#line 54
    goto case_70;
  }
#line 54
  if ((int const   )*zval == 110) {
#line 54
    goto case_70;
  }
#line 57
  goto switch_default;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 49
  *pi = 1;
#line 50
  goto switch_break;
  case_70: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 55
  *pi = 0;
#line 56
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 58
  return (4101);
  switch_break: /* CIL Label */ ;
  }
#line 61
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/base.c"
char const   _uuconf_base_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/base.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'b',      (char const   )'a',      (char const   )'s', 
        (char const   )'e',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'6',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 34 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/base.c"
void _uuconf_ucmdtab_base(struct cmdtab_offset  const  *qoff , size_t celes , char *pbase ,
                          struct uuconf_cmdtab *qset ) 
{ 
  register size_t i ;

  {
#line 43
  i = (size_t )0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < celes)) {
#line 43
      goto while_break;
    }
#line 45
    qset->uuconf_zcmd = (char const   *)qoff->zcmd;
#line 46
    qset->uuconf_itype = (int )qoff->itype;
#line 47
    if (qoff->ioff == 0xffffffffffffffffUL) {
#line 48
      qset->uuconf_pvar = (void *)0;
    } else {
#line 50
      qset->uuconf_pvar = (UUCONF_POINTER )(pbase + qoff->ioff);
    }
#line 51
    qset->uuconf_pifn = (int (*)(void *uuconf_pglobal , int uuconf_argc , char **uuconf_argv ,
                                 void *uuconf_pvar , void *uuconf_pinfo ))qoff->pifn;
#line 43
    i ++;
#line 43
    qoff ++;
#line 43
    qset ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.c"
char const   _uuconf_alloc_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/alloc.c"
void *uuconf_malloc(void *pblock , unsigned long c ) 
{ 
  struct sblock *q ;
  pointer pret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 43
  q = (struct sblock *)pblock;
#line 46
  if (c == 0UL) {
#line 47
    return ((void *)0);
  }
#line 49
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 50
    tmp = malloc(c);
    }
#line 50
    return (tmp);
  }
#line 53
  c = (((c + sizeof(double )) - 1UL) / sizeof(double )) * sizeof(double );
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (q->ifree + c > 1008UL)) {
#line 55
      goto while_break;
    }
#line 57
    if ((unsigned long )q->qnext != (unsigned long )((void *)0)) {
#line 58
      q = q->qnext;
    } else {
#line 61
      if (c > 1008UL) {
        {
#line 62
        tmp___0 = malloc((sizeof(struct sblock ) + c) - 1008UL);
#line 62
        q->qnext = (struct sblock *)tmp___0;
        }
      } else {
        {
#line 65
        tmp___1 = malloc(sizeof(struct sblock ));
#line 65
        q->qnext = (struct sblock *)tmp___1;
        }
      }
#line 66
      if ((unsigned long )q->qnext == (unsigned long )((void *)0)) {
#line 67
        return ((void *)0);
      }
#line 68
      q = q->qnext;
#line 69
      q->qnext = (struct sblock *)((void *)0);
#line 70
      q->ifree = (size_t )0;
#line 71
      q->qadded = (struct sadded *)((void *)0);
#line 72
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  pret = (pointer )(q->u.ab + q->ifree);
#line 77
  q->ifree += c;
#line 78
  q->plast = pret;
#line 80
  return (pret);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/allblk.c"
char const   _uuconf_allblk_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/allblk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )'b',      (char const   )'l',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/allblk.c"
void *uuconf_malloc_block(void) 
{ 
  struct sblock *qret ;
  void *tmp ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 42
  tmp = malloc(sizeof(struct sblock ));
#line 42
  qret = (struct sblock *)tmp;
  }
#line 43
  if ((unsigned long )qret == (unsigned long )((void *)0)) {
#line 44
    return ((void *)0);
  }
#line 45
  qret->qnext = (struct sblock *)((void *)0);
#line 46
  qret->ifree = (size_t )0;
#line 47
  qret->plast = (void *)0;
#line 48
  qret->qadded = (struct sadded *)((void *)0);
#line 49
  return ((pointer )qret);
}
}
#line 247 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/uucnfi.h"
char *_uuconf_unset  ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/addstr.c"
char const   _uuconf_addstr_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/addstr.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'8',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 56 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/addstr.c"
int _uuconf_iadd_string(struct sglobal *qglobal , char *zadd , boolean fcopy , boolean fcheck ,
                        char ***ppzstrings , pointer pblock ) 
{ 
  char **pz ;
  size_t c ;
  int tmp ;
  size_t clen ;
  char *znew ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char **pznew ;
  void *tmp___5 ;
  int *tmp___6 ;

  {
#line 68
  if (fcheck) {
#line 68
    if ((unsigned long )*ppzstrings != (unsigned long )((void *)0)) {
#line 70
      pz = *ppzstrings;
      {
#line 70
      while (1) {
        while_continue: /* CIL Label */ ;
#line 70
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 70
          goto while_break;
        }
        {
#line 71
        tmp = strcmp((char const   *)zadd, (char const   *)*pz);
        }
#line 71
        if (tmp == 0) {
#line 72
          return (0);
        }
#line 70
        pz ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 75
  if (fcopy) {
    {
#line 80
    tmp___0 = strlen((char const   *)zadd);
#line 80
    clen = tmp___0 + 1UL;
#line 81
    tmp___1 = uuconf_malloc(pblock, clen);
#line 81
    znew = (char *)tmp___1;
    }
#line 82
    if ((unsigned long )znew == (unsigned long )((void *)0)) {
#line 84
      if ((unsigned long )qglobal != (unsigned long )((void *)0)) {
        {
#line 85
        tmp___2 = __errno_location();
#line 85
        qglobal->ierrno = *tmp___2;
        }
      }
#line 86
      return (260);
    }
    {
#line 88
    memcpy((void */* __restrict  */)((pointer )znew), (void const   */* __restrict  */)((pointer )zadd),
           clen);
#line 89
    zadd = znew;
    }
  }
#line 92
  pz = *ppzstrings;
#line 93
  if ((unsigned long )pz == (unsigned long )((void *)0)) {
#line 93
    goto _L;
  } else
#line 93
  if ((unsigned long )pz == (unsigned long )(& _uuconf_unset)) {
    _L: /* CIL Label */ 
    {
#line 95
    tmp___3 = uuconf_malloc(pblock, 8UL * sizeof(char *));
#line 95
    pz = (char **)tmp___3;
    }
#line 96
    if ((unsigned long )pz == (unsigned long )((void *)0)) {
#line 98
      if ((unsigned long )qglobal != (unsigned long )((void *)0)) {
        {
#line 99
        tmp___4 = __errno_location();
#line 99
        qglobal->ierrno = *tmp___4;
        }
      }
#line 100
      return (260);
    }
#line 102
    *ppzstrings = pz;
  } else {
#line 106
    c = (size_t )0;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 107
        goto while_break___0;
      }
#line 109
      pz ++;
#line 110
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 113
    if ((c + 1UL) % 8UL == 0UL) {
      {
#line 117
      tmp___5 = uuconf_malloc(pblock, ((c + 1UL) + 8UL) * sizeof(char *));
#line 117
      pznew = (char **)tmp___5;
      }
#line 120
      if ((unsigned long )pznew == (unsigned long )((void *)0)) {
#line 122
        if ((unsigned long )qglobal != (unsigned long )((void *)0)) {
          {
#line 123
          tmp___6 = __errno_location();
#line 123
          qglobal->ierrno = *tmp___6;
          }
        }
#line 124
        return (260);
      }
      {
#line 126
      memcpy((void */* __restrict  */)((pointer )pznew), (void const   */* __restrict  */)((pointer )*ppzstrings),
             c * sizeof(char *));
#line 128
      uuconf_free(pblock, (void *)*ppzstrings);
#line 129
      *ppzstrings = pznew;
#line 130
      pz = pznew + c;
      }
    }
  }
#line 134
  *(pz + 0) = zadd;
#line 135
  *(pz + 1) = (char *)((void *)0);
#line 137
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/addblk.c"
char const   _uuconf_addblk_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/addblk.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'b',      (char const   )'l',      (char const   )'k',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'6',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 38 "/home/wslee/gnu_benchmarks/uucp-1.07/uuconf/addblk.c"
int uuconf_add_block(void *pblock , void *padd ) 
{ 
  struct sblock *q ;
  struct sadded *qnew ;
  void *tmp ;

  {
  {
#line 43
  q = (struct sblock *)pblock;
#line 46
  tmp = uuconf_malloc(pblock, sizeof(struct sadded ));
#line 46
  qnew = (struct sadded *)tmp;
  }
#line 47
  if ((unsigned long )qnew == (unsigned long )((void *)0)) {
#line 48
    return (1);
  }
#line 50
  qnew->qnext = q->qadded;
#line 51
  qnew->padded = padd;
#line 52
  q->qadded = qnew;
#line 54
  return (0);
}
}
#line 155 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
char const   xqtsub_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'x',      (char const   )'q',      (char const   )'t', 
        (char const   )'s',      (char const   )'u',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'4', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 364 "../uudefs.h"
boolean fcopy_file(char const   *zfrom , char const   *zto , boolean fpublic , boolean fmkdirs ,
                   boolean fsignals ) ;
#line 183 "../system.h"
char *zsysdep_local_file(char const   *zfile , char const   *zpubdir , boolean *pfbadname ) ;
#line 379
boolean fsysdep_make_dirs(char const   *zfile , boolean fpublic ) ;
#line 602
char *zsysdep_find_command(char const   *zcmd , char **pzcmds , char **pzpath , boolean *pferr ) ;
#line 611
char *zsysdep_xqt_local_file(struct uuconf_system  const  *qsys , char const   *zfile ) ;
#line 643
boolean fsysdep_execute(struct uuconf_system  const  *qsys , char const   *zuser ,
                        char const   **pazargs , char const   *zfullcmd  __attribute__((__unused__)) ,
                        char const   *zinput , char const   *zoutput , boolean fshell ,
                        int iseq , char **pzerror , boolean *pftemp ) ;
#line 661
int ixsysdep_lock_uuxqt(char const   *zcmd , int cmaxuuxqts ) ;
#line 668
boolean fsysdep_unlock_uuxqt(int iseq , char const   *zcmd , int cmaxuuxqts  __attribute__((__unused__)) ) ;
#line 675
boolean fsysdep_uuxqt_locked(char const   *zcmd ) ;
#line 680
boolean fsysdep_lock_uuxqt_file(char const   *zfile ) ;
#line 683
boolean fsysdep_unlock_uuxqt_file(char const   *zfile ) ;
#line 688
boolean fsysdep_lock_uuxqt_dir(int iseq ) ;
#line 692
boolean fsysdep_unlock_uuxqt_dir(int iseq ) ;
#line 704
boolean fsysdep_copy_uuxqt_files(int cfiles , char const   * const  *pzfrom , char const   * const  *pzto ,
                                 int iseq , char **pzinput ) ;
#line 739
char *zsysdep_in_dir(char const   *zdir , char const   *zfile ) ;
#line 773
boolean fsysdep_directory(char const   *z ) ;
#line 1000
boolean fsysdep_rmdir(char const   *zdir ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 806
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 426 "../sysdep.h"
pid_t ixsspawn(char const   **pazargs , int *aidescs , boolean fkeepuid , boolean fkeepenv ,
               char const   *zchdir , boolean fnosigs , boolean fshell , char const   *zpath ,
               char const   *zuu_machine , char const   *zuu_user ) ;
#line 440
int ixswait(unsigned long ipid , char const   *zreport ) ;
#line 465
boolean fsdo_lock(char const   *zlock , boolean fspooldir , boolean *pferr ) ;
#line 469
boolean fsdo_unlock(char const   *zlock , boolean fspooldir ) ;
#line 493
char *zstemp_file(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 118
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , __mode_t __mode ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 80 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
static boolean fclean_uuxqt_dir(char const   *zxqtdir ) ;
#line 85 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
char *zsysdep_find_command(char const   *zcmd , char **pzcmds , char **pzpath , boolean *pferr ) 
{ 
  char **pz ;
  struct stat s ;
  char *zslash ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *zname ;
  int tmp___6 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 95
  *pferr = 0;
#line 97
  pz = pzcmds;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 97
      goto while_break;
    }
    {
#line 101
    tmp = strcmp((char const   *)*pz, "ALL");
    }
#line 101
    if (tmp == 0) {
#line 102
      goto while_break;
    }
    {
#line 104
    zslash = strrchr((char const   *)*pz, '/');
    }
#line 105
    if ((unsigned long )zslash != (unsigned long )((void *)0)) {
#line 106
      zslash ++;
    } else {
#line 108
      zslash = *pz;
    }
    {
#line 109
    tmp___4 = strcmp((char const   *)zslash, zcmd);
    }
#line 109
    if (tmp___4 == 0) {
#line 109
      goto _L;
    } else {
      {
#line 109
      tmp___5 = strcmp((char const   *)*pz, zcmd);
      }
#line 109
      if (tmp___5 == 0) {
        _L: /* CIL Label */ 
#line 114
        if ((int )*(*pz) == 47) {
          {
#line 117
          tmp___2 = stat((char const   */* __restrict  */)*pz, (struct stat */* __restrict  */)(& s));
          }
#line 117
          if (tmp___2 != 0) {
            {
#line 119
            tmp___0 = __errno_location();
#line 119
            tmp___1 = strerror(*tmp___0);
#line 119
            ulog((enum tlog )1, "%s: %s", *pz, tmp___1);
#line 120
            *pferr = 1;
            }
#line 121
            return ((char *)((void *)0));
          }
          {
#line 123
          tmp___3 = zbufcpy((char const   *)*pz);
          }
#line 123
          return (tmp___3);
        }
#line 125
        goto while_break;
      }
    }
#line 97
    pz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if ((unsigned long )*pz == (unsigned long )((void *)0)) {
#line 131
    return ((char *)((void *)0));
  }
#line 135
  pz = pzpath;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 135
      goto while_break___0;
    }
    {
#line 139
    zname = zsysdep_in_dir((char const   *)*pz, zcmd);
#line 140
    tmp___6 = stat((char const   */* __restrict  */)zname, (struct stat */* __restrict  */)(& s));
    }
#line 140
    if (tmp___6 == 0) {
#line 141
      return (zname);
    }
#line 135
    pz ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  return ((char *)((void *)0));
}
}
#line 154 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
char *zsysdep_xqt_local_file(struct uuconf_system  const  *qsys , char const   *zfile ) 
{ 
  size_t clen ;
  char *zret ;
  char *tmp ;

  {
#line 159
  if ((int const   )*zfile != 126) {
#line 160
    return ((char *)((void *)0));
  }
#line 161
  if ((int const   )*(zfile + 1) == 126) {
    {
#line 166
    clen = strlen(zfile);
#line 167
    zret = zbufalc(clen);
#line 168
    memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)(zfile + 1),
           clen);
    }
#line 169
    return (zret);
  }
  {
#line 171
  tmp = zsysdep_local_file(zfile, (char const   *)qsys->uuconf_zpubdir, (boolean *)((void *)0));
  }
#line 171
  return (tmp);
}
}
#line 219 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_execute(struct uuconf_system  const  *qsys , char const   *zuser ,
                        char const   **pazargs , char const   *zfullcmd  __attribute__((__unused__)) ,
                        char const   *zinput , char const   *zoutput , boolean fshell ,
                        int iseq , char **pzerror , boolean *pftemp ) 
{ 
  int aidescs[3] ;
  boolean ferr ;
  pid_t ipid ;
  int ierr ;
  char abxqtdir[sizeof(".Xqtdir") + 4UL] ;
  char const   *zxqtdir ;
  int istat ;
  char *zpath ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  boolean tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  boolean tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t c ;
  char **pz ;
  size_t tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 245
  *pzerror = (char *)((void *)0);
#line 246
  *pftemp = 0;
#line 248
  aidescs[0] = -1;
#line 249
  aidescs[1] = -1;
#line 250
  aidescs[2] = -1;
#line 252
  ferr = 0;
#line 254
  if ((unsigned long )zinput != (unsigned long )((void *)0)) {
    {
#line 256
    aidescs[0] = open((char const   *)((char *)zinput), 256, 0);
    }
#line 257
    if (aidescs[0] < 0) {
      {
#line 259
      tmp = __errno_location();
#line 259
      tmp___0 = strerror(*tmp);
#line 259
      ulog((enum tlog )1, "open (%s): %s", zinput, tmp___0);
#line 260
      ferr = 1;
      }
    } else {
      {
#line 262
      tmp___3 = fcntl(aidescs[0], 1, 0);
#line 262
      tmp___4 = fcntl(aidescs[0], 2, tmp___3 | 1);
      }
#line 262
      if (tmp___4 < 0) {
        {
#line 265
        tmp___1 = __errno_location();
#line 265
        tmp___2 = strerror(*tmp___1);
#line 265
        ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___2);
#line 266
        ferr = 1;
        }
      }
    }
  }
#line 270
  if (! ferr) {
#line 270
    if ((unsigned long )zoutput != (unsigned long )((void *)0)) {
      {
#line 272
      aidescs[1] = creat((char const   *)((char *)zoutput), (__mode_t )384);
      }
#line 273
      if (aidescs[1] < 0) {
        {
#line 275
        tmp___6 = __errno_location();
        }
#line 275
        if (*tmp___6 == 2) {
#line 275
          if ((int const   )*(zoutput + 0) != 47) {
            {
#line 277
            tmp___5 = fsysdep_make_dirs(zoutput, 0);
            }
#line 277
            if (tmp___5) {
              {
#line 283
              aidescs[1] = creat((char const   *)((char *)zoutput), (__mode_t )384);
              }
            } else {
#line 279
              *pftemp = 1;
#line 280
              ferr = 1;
            }
          }
        }
#line 285
        if (! ferr) {
#line 285
          if (aidescs[1] < 0) {
            {
#line 287
            tmp___7 = __errno_location();
#line 287
            tmp___8 = strerror(*tmp___7);
#line 287
            ulog((enum tlog )1, "creat (%s): %s", zoutput, tmp___8);
#line 288
            *pftemp = 1;
#line 289
            ferr = 1;
            }
          }
        }
      }
#line 292
      if (! ferr) {
        {
#line 292
        tmp___11 = fcntl(aidescs[1], 1, 0);
#line 292
        tmp___12 = fcntl(aidescs[1], 2, tmp___11 | 1);
        }
#line 292
        if (tmp___12 < 0) {
          {
#line 296
          tmp___9 = __errno_location();
#line 296
          tmp___10 = strerror(*tmp___9);
#line 296
          ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___10);
#line 297
          ferr = 1;
          }
        }
      }
    }
  }
#line 301
  if (! ferr) {
    {
#line 303
    *pzerror = zstemp_file(qsys);
#line 304
    aidescs[2] = creat((char const   *)*pzerror, (__mode_t )384);
    }
#line 305
    if (aidescs[2] < 0) {
      {
#line 307
      tmp___14 = __errno_location();
      }
#line 307
      if (*tmp___14 == 2) {
        {
#line 309
        tmp___13 = fsysdep_make_dirs((char const   *)*pzerror, 0);
        }
#line 309
        if (tmp___13) {
          {
#line 315
          aidescs[2] = creat((char const   *)*pzerror, (__mode_t )384);
          }
        } else {
#line 311
          *pftemp = 1;
#line 312
          ferr = 1;
        }
      }
#line 317
      if (! ferr) {
#line 317
        if (aidescs[2] < 0) {
          {
#line 319
          tmp___15 = __errno_location();
#line 319
          tmp___16 = strerror(*tmp___15);
#line 319
          ulog((enum tlog )1, "creat (%s): %s", *pzerror, tmp___16);
#line 320
          *pftemp = 1;
#line 321
          ferr = 1;
          }
        }
      }
    }
#line 324
    if (! ferr) {
      {
#line 324
      tmp___19 = fcntl(aidescs[2], 1, 0);
#line 324
      tmp___20 = fcntl(aidescs[2], 2, tmp___19 | 1);
      }
#line 324
      if (tmp___20 < 0) {
        {
#line 328
        tmp___17 = __errno_location();
#line 328
        tmp___18 = strerror(*tmp___17);
#line 328
        ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___18);
#line 329
        ferr = 1;
        }
      }
    }
  }
#line 333
  if (iseq == 0) {
#line 334
    zxqtdir = ".Xqtdir";
  } else {
    {
#line 337
    sprintf((char */* __restrict  */)(abxqtdir), (char const   */* __restrict  */)"%s%04d",
            ".Xqtdir", iseq);
#line 338
    zxqtdir = (char const   *)(abxqtdir);
    }
  }
#line 341
  if (ferr) {
#line 343
    if (aidescs[0] != -1) {
      {
#line 344
      close(aidescs[0]);
      }
    }
#line 345
    if (aidescs[1] != -1) {
      {
#line 346
      close(aidescs[1]);
      }
    }
#line 347
    if (aidescs[2] != -1) {
      {
#line 348
      close(aidescs[2]);
      }
    }
    {
#line 349
    ubuffree(*pzerror);
    }
#line 350
    return (0);
  }
#line 363
  fshell = 0;
#line 366
  if ((unsigned long )qsys->uuconf_pzpath == (unsigned long )((void *)0)) {
#line 367
    zpath = (char *)((void *)0);
  } else {
#line 373
    c = (size_t )0;
#line 374
    pz = (char **)qsys->uuconf_pzpath;
    {
#line 374
    while (1) {
      while_continue: /* CIL Label */ ;
#line 374
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 374
        goto while_break;
      }
      {
#line 375
      tmp___21 = strlen((char const   *)*pz);
#line 375
      c += tmp___21 + 1UL;
#line 374
      pz ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 376
    zpath = zbufalc(c);
#line 377
    *zpath = (char )'\000';
#line 378
    pz = (char **)qsys->uuconf_pzpath;
    }
    {
#line 378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 378
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 378
        goto while_break___0;
      }
      {
#line 380
      strcat((char */* __restrict  */)zpath, (char const   */* __restrict  */)*pz);
      }
#line 381
      if ((unsigned long )*(pz + 1) != (unsigned long )((void *)0)) {
        {
#line 382
        strcat((char */* __restrict  */)zpath, (char const   */* __restrict  */)":");
        }
      }
#line 378
      pz ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 388
  ipid = ixsspawn(pazargs, aidescs, 1, 0, zxqtdir, 1, ! fshell, (char const   *)zpath,
                  (char const   *)qsys->uuconf_zname, zuser);
#line 391
  tmp___22 = __errno_location();
#line 391
  ierr = *tmp___22;
#line 393
  ubuffree(zpath);
  }
#line 395
  if (aidescs[0] != -1) {
    {
#line 396
    close(aidescs[0]);
    }
  }
#line 397
  if (aidescs[1] != -1) {
    {
#line 398
    close(aidescs[1]);
    }
  }
#line 399
  if (aidescs[2] != -1) {
    {
#line 400
    close(aidescs[2]);
    }
  }
#line 402
  if (ipid < 0) {
    {
#line 404
    tmp___23 = strerror(ierr);
#line 404
    ulog((enum tlog )1, "ixsspawn: %s", tmp___23);
#line 405
    *pftemp = 1;
    }
#line 406
    return (0);
  }
  {
#line 409
  istat = ixswait((unsigned long )ipid, "Execution");
  }
#line 411
  if (istat == 75) {
#line 412
    *pftemp = 1;
  }
#line 414
  return (istat == 0);
}
}
#line 419 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
int ixsysdep_lock_uuxqt(char const   *zcmd , int cmaxuuxqts ) 
{ 
  char ab___0[sizeof("LCK.XQT.9999")] ;
  int i ;
  boolean tmp ;
  char abcmd[sizeof("LXQ.123456789")] ;
  size_t tmp___0 ;
  boolean tmp___1 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 427
  if (cmaxuuxqts <= 0) {
#line 428
    cmaxuuxqts = 9999;
  } else
#line 427
  if (cmaxuuxqts >= 10000) {
#line 428
    cmaxuuxqts = 9999;
  }
#line 429
  i = 0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < cmaxuuxqts)) {
#line 429
      goto while_break;
    }
    {
#line 431
    sprintf((char */* __restrict  */)(ab___0), (char const   */* __restrict  */)"LCK.XQT.%d",
            i);
#line 432
    tmp = fsdo_lock((char const   *)(ab___0), 1, (boolean *)((void *)0));
    }
#line 432
    if (tmp) {
#line 433
      goto while_break;
    }
#line 429
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if (i >= cmaxuuxqts) {
#line 436
    return (-1);
  }
#line 438
  if ((unsigned long )zcmd != (unsigned long )((void *)0)) {
    {
#line 442
    sprintf((char */* __restrict  */)(abcmd), (char const   */* __restrict  */)"LXQ.%.9s",
            zcmd);
#line 443
    tmp___0 = strcspn((char const   *)(abcmd), " \t/");
#line 443
    abcmd[tmp___0] = (char )'\000';
#line 444
    tmp___1 = fsdo_lock((char const   *)(abcmd), 1, (boolean *)((void *)0));
    }
#line 444
    if (! tmp___1) {
      {
#line 446
      fsdo_unlock((char const   *)(ab___0), 1);
      }
#line 447
      return (-1);
    }
  }
#line 451
  return (i);
}
}
#line 456 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_unlock_uuxqt(int iseq , char const   *zcmd , int cmaxuuxqts  __attribute__((__unused__)) ) 
{ 
  char ab___0[sizeof("LCK.XQT.9999")] ;
  boolean fret ;
  boolean tmp ;
  char abcmd[sizeof("LXQ.123456789")] ;
  size_t tmp___0 ;
  boolean tmp___1 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 465
  fret = 1;
#line 467
  sprintf((char */* __restrict  */)(ab___0), (char const   */* __restrict  */)"LCK.XQT.%d",
          iseq);
#line 468
  tmp = fsdo_unlock((char const   *)(ab___0), 1);
  }
#line 468
  if (! tmp) {
#line 469
    fret = 0;
  }
#line 471
  if ((unsigned long )zcmd != (unsigned long )((void *)0)) {
    {
#line 475
    sprintf((char */* __restrict  */)(abcmd), (char const   */* __restrict  */)"LXQ.%.9s",
            zcmd);
#line 476
    tmp___0 = strcspn((char const   *)(abcmd), " \t/");
#line 476
    abcmd[tmp___0] = (char )'\000';
#line 477
    tmp___1 = fsdo_unlock((char const   *)(abcmd), 1);
    }
#line 477
    if (! tmp___1) {
#line 478
      fret = 0;
    }
  }
#line 481
  return (fret);
}
}
#line 487 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_uuxqt_locked(char const   *zcmd ) 
{ 
  char ab___0[sizeof("LXQ.123456789")] ;
  struct stat s ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 494
  sprintf((char */* __restrict  */)(ab___0), (char const   */* __restrict  */)"LXQ.%.9s",
          zcmd);
#line 495
  tmp = stat((char const   */* __restrict  */)(ab___0), (struct stat */* __restrict  */)(& s));
  }
#line 495
  return (tmp == 0);
}
}
#line 500 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_lock_uuxqt_file(char const   *zfile ) 
{ 
  char *zcopy ;
  char *z ;
  boolean fret ;

  {
  {
#line 507
  zcopy = zbufcpy(zfile);
#line 509
  z = strrchr((char const   *)zcopy, '/');
  }
#line 510
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 511
    *zcopy = (char )'L';
  } else {
#line 513
    *(z + 1) = (char )'L';
  }
  {
#line 515
  fret = fsdo_lock((char const   *)zcopy, 1, (boolean *)((void *)0));
#line 516
  ubuffree(zcopy);
  }
#line 517
  return (fret);
}
}
#line 522 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_unlock_uuxqt_file(char const   *zfile ) 
{ 
  char *zcopy ;
  char *z ;
  boolean fret ;

  {
  {
#line 529
  zcopy = zbufcpy(zfile);
#line 531
  z = strrchr((char const   *)zcopy, '/');
  }
#line 532
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 533
    *zcopy = (char )'L';
  } else {
#line 535
    *(z + 1) = (char )'L';
  }
  {
#line 537
  fret = fsdo_unlock((char const   *)zcopy, 1);
#line 538
  ubuffree(zcopy);
  }
#line 539
  return (fret);
}
}
#line 547 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_lock_uuxqt_dir(int iseq ) 
{ 
  char const   *zxqtdir ;
  char abxqtdir[sizeof(".Xqtdir") + 4UL] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  boolean tmp___4 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 554
  if (iseq == 0) {
#line 555
    zxqtdir = ".Xqtdir";
  } else {
    {
#line 558
    sprintf((char */* __restrict  */)(abxqtdir), (char const   */* __restrict  */)"%s%04d",
            ".Xqtdir", iseq);
#line 559
    zxqtdir = (char const   *)(abxqtdir);
    }
  }
  {
#line 562
  tmp___1 = mkdir(zxqtdir, (__mode_t )448);
  }
#line 562
  if (tmp___1 < 0) {
    {
#line 562
    tmp___2 = __errno_location();
    }
#line 562
    if (*tmp___2 != 17) {
      {
#line 562
      tmp___3 = __errno_location();
      }
#line 562
      if (*tmp___3 != 21) {
        {
#line 566
        tmp = __errno_location();
#line 566
        tmp___0 = strerror(*tmp);
#line 566
        ulog((enum tlog )1, "mkdir (%s): %s", zxqtdir, tmp___0);
        }
#line 567
        return (0);
      }
    }
  }
  {
#line 570
  tmp___4 = fclean_uuxqt_dir(zxqtdir);
  }
#line 570
  return (tmp___4);
}
}
#line 577 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_unlock_uuxqt_dir(int iseq ) 
{ 
  char const   *zxqtdir ;
  char abxqtdir[sizeof(".Xqtdir") + 4UL] ;
  boolean tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 584
  if (iseq == 0) {
#line 585
    zxqtdir = ".Xqtdir";
  } else {
    {
#line 588
    sprintf((char */* __restrict  */)(abxqtdir), (char const   */* __restrict  */)"%s%04d",
            ".Xqtdir", iseq);
#line 589
    zxqtdir = (char const   *)(abxqtdir);
    }
  }
  {
#line 592
  tmp = fclean_uuxqt_dir(zxqtdir);
  }
#line 592
  return (tmp);
}
}
#line 595 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
static boolean fclean_uuxqt_dir(char const   *zxqtdir ) 
{ 
  DIR *qdir ;
  struct dirent *qentry ;
  char *z ;
  int tmp ;
  int tmp___0 ;
  int ierr ;
  int *tmp___1 ;
  char *tmp___2 ;
  boolean tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 601
  qdir = opendir((char const   *)((char *)zxqtdir));
  }
#line 602
  if ((unsigned long )qdir != (unsigned long )((void *)0)) {
    {
#line 606
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 606
      qentry = readdir(qdir);
      }
#line 606
      if (! ((unsigned long )qentry != (unsigned long )((void *)0))) {
#line 606
        goto while_break;
      }
      {
#line 610
      tmp = strcmp((char const   *)(qentry->d_name), ".");
      }
#line 610
      if (tmp == 0) {
#line 612
        goto while_continue;
      } else {
        {
#line 610
        tmp___0 = strcmp((char const   *)(qentry->d_name), "..");
        }
#line 610
        if (tmp___0 == 0) {
#line 612
          goto while_continue;
        }
      }
      {
#line 613
      z = zsysdep_in_dir(zxqtdir, (char const   *)(qentry->d_name));
#line 614
      tmp___4 = remove((char const   *)z);
      }
#line 614
      if (tmp___4 < 0) {
        {
#line 618
        tmp___1 = __errno_location();
#line 618
        ierr = *tmp___1;
#line 619
        tmp___3 = fsysdep_directory((char const   *)z);
        }
#line 619
        if (tmp___3) {
          {
#line 623
          fsysdep_rmdir((char const   *)z);
          }
        } else {
          {
#line 620
          tmp___2 = strerror(ierr);
#line 620
          ulog((enum tlog )1, "remove (%s): %s", z, tmp___2);
          }
        }
      }
      {
#line 625
      ubuffree(z);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 628
    closedir(qdir);
    }
  }
#line 631
  return (1);
}
}
#line 636 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtsub.c"
boolean fsysdep_copy_uuxqt_files(int cfiles , char const   * const  *pzfrom , char const   * const  *pzto ,
                                 int iseq , char **pzinput ) 
{ 
  char *zinput ;
  char const   *zxqtdir ;
  char abxqtdir[sizeof(".Xqtdir") + 4UL] ;
  int i ;
  char const   *zfrom ;
  char const   *zto ;
  char *zfree ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  boolean tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 649
  if ((unsigned long )pzinput == (unsigned long )((void *)0)) {
#line 650
    zinput = (char *)((void *)0);
  } else {
#line 652
    zinput = *pzinput;
  }
#line 654
  if (iseq == 0) {
#line 655
    zxqtdir = ".Xqtdir";
  } else {
    {
#line 658
    sprintf((char */* __restrict  */)(abxqtdir), (char const   */* __restrict  */)"%s%04d",
            ".Xqtdir", iseq);
#line 659
    zxqtdir = (char const   *)(abxqtdir);
    }
  }
#line 662
  i = 0;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! (i < cfiles)) {
#line 662
      goto while_break;
    }
#line 667
    if ((unsigned long )*(pzto + i) == (unsigned long )((void *)0)) {
#line 668
      goto __Cont;
    }
    {
#line 670
    zfree = zsysdep_in_dir(zxqtdir, (char const   *)*(pzto + i));
#line 672
    zfrom = (char const   *)*(pzfrom + i);
#line 673
    zto = (char const   *)zfree;
    }
#line 675
    if ((unsigned long )zinput != (unsigned long )((void *)0)) {
      {
#line 675
      tmp = strcmp((char const   *)zinput, zfrom);
      }
#line 675
      if (tmp == 0) {
        {
#line 677
        *pzinput = zbufcpy(zto);
#line 678
        zinput = (char *)((void *)0);
        }
      }
    }
    {
#line 681
    tmp___6 = link(zfrom, zto);
    }
#line 681
    if (tmp___6 < 0) {
      {
#line 683
      tmp___2 = __errno_location();
      }
#line 683
      if (*tmp___2 != 18) {
        {
#line 683
        tmp___3 = __errno_location();
        }
#line 683
        if (*tmp___3 != 17) {
          {
#line 683
          tmp___4 = __errno_location();
          }
#line 683
          if (*tmp___4 != 31) {
            {
#line 685
            tmp___0 = __errno_location();
#line 685
            tmp___1 = strerror(*tmp___0);
#line 685
            ulog((enum tlog )1, "link (%s, %s): %s", zfrom, zto, tmp___1);
#line 687
            ubuffree(zfree);
            }
#line 688
            return (0);
          }
        }
      }
      {
#line 691
      tmp___5 = fcopy_file(zfrom, zto, 0, 0, 0);
      }
#line 691
      if (! tmp___5) {
        {
#line 693
        ubuffree(zfree);
        }
#line 694
        return (0);
      }
    }
    {
#line 698
    chmod(zto, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 700
    ubuffree(zfree);
    }
    __Cont: /* CIL Label */ 
#line 662
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return (1);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
char const   xqtfil_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'x',      (char const   )'q',      (char const   )'t', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 579 "../system.h"
boolean fsysdep_get_xqt_init(char const   *zsystem ) ;
#line 589
char *zsysdep_get_xqt(char const   *zsystem  __attribute__((__unused__)) , char **pzsystem ,
                      boolean *pferr ) ;
#line 594
void usysdep_get_xqt_free(char const   *zsystem  __attribute__((__unused__)) ) ;
#line 76 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
static DIR *qSxqt_topdir  ;
#line 80 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
static boolean fSone_dir  ;
#line 81 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
static char *zSdir  ;
#line 82 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
static DIR *qSxqt_dir  ;
#line 83 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
static char *zSsystem  ;
#line 91 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
boolean fsysdep_get_xqt_init(char const   *zsystem ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 95
  usysdep_get_xqt_free((char const   *)((void *)0));
  }
#line 98
  if ((unsigned long )zsystem != (unsigned long )((void *)0)) {
    {
#line 107
    zSdir = zsysdep_in_dir(zsystem, "X.");
#line 110
    qSxqt_dir = opendir((char const   *)zSdir);
    }
#line 111
    if ((unsigned long )qSxqt_dir != (unsigned long )((void *)0)) {
      {
#line 113
      qSxqt_topdir = qSxqt_dir;
#line 114
      fSone_dir = 1;
#line 115
      zSsystem = zbufcpy(zsystem);
      }
#line 116
      return (1);
    }
  }
  {
#line 120
  fSone_dir = 0;
#line 123
  qSxqt_topdir = opendir((char const   *)((char *)"."));
  }
#line 124
  if ((unsigned long )qSxqt_topdir == (unsigned long )((void *)0)) {
    {
#line 126
    tmp = __errno_location();
    }
#line 126
    if (*tmp == 2) {
#line 127
      return (1);
    }
    {
#line 128
    tmp___0 = __errno_location();
#line 128
    tmp___1 = strerror(*tmp___0);
#line 128
    ulog((enum tlog )1, "opendir (%s): %s", ".", tmp___1);
    }
#line 129
    return (0);
  }
#line 132
  return (1);
}
}
#line 142 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
char *zsysdep_get_xqt(char const   *zsystem  __attribute__((__unused__)) , char **pzsystem ,
                      boolean *pferr ) 
{ 
  DIR *qdir ;
  struct dirent *q ;
  struct dirent *qtop ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *zret ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 148
  *pferr = 0;
#line 150
  if ((unsigned long )qSxqt_topdir == (unsigned long )((void *)0)) {
#line 151
    return ((char *)((void *)0));
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 164
      if (! ((unsigned long )qSxqt_dir == (unsigned long )((void *)0))) {
#line 164
        goto while_break___0;
      }
      {
#line 168
      qtop = readdir(qSxqt_topdir);
      }
#line 169
      if ((unsigned long )qtop == (unsigned long )((void *)0)) {
        {
#line 171
        closedir(qSxqt_topdir);
#line 172
        qSxqt_topdir = (DIR *)((void *)0);
        }
#line 173
        return ((char *)((void *)0));
      }
#line 178
      if ((int )qtop->d_name[0] == 46) {
#line 179
        goto while_continue___0;
      }
      {
#line 181
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 181
        if ((iDebug & 128) != 0) {
          {
#line 181
          ulog((enum tlog )3, "zsysdep_get_xqt: Found %s in top directory", qtop->d_name);
          }
        }
#line 181
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 185
      ubuffree(zSdir);
#line 194
      zSdir = zsysdep_in_dir((char const   *)(qtop->d_name), "X.");
#line 197
      ubuffree(zSsystem);
#line 198
      zSsystem = zbufcpy((char const   *)(qtop->d_name));
#line 200
      qSxqt_dir = opendir((char const   *)zSdir);
      }
#line 202
      if ((unsigned long )qSxqt_dir == (unsigned long )((void *)0)) {
        {
#line 202
        tmp___1 = __errno_location();
        }
#line 202
        if (*tmp___1 != 20) {
          {
#line 202
          tmp___2 = __errno_location();
          }
#line 202
          if (*tmp___2 != 2) {
            {
#line 205
            tmp = __errno_location();
#line 205
            tmp___0 = strerror(*tmp);
#line 205
            ulog((enum tlog )1, "opendir (%s): %s", zSdir, tmp___0);
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 208
    qdir = qSxqt_dir;
#line 211
    q = readdir(qdir);
    }
#line 214
    if ((unsigned long )q != (unsigned long )((void *)0)) {
      {
#line 215
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 215
        if ((iDebug & 128) != 0) {
          {
#line 215
          ulog((enum tlog )3, "zsysdep_get_xqt: Found %s in subdirectory %s", q->d_name,
               zSdir);
          }
        }
#line 215
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 225
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 225
      if ((int )q->d_name[0] == 88) {
#line 225
        if ((int )q->d_name[1] == 46) {
          {
#line 232
          *pzsystem = zbufcpy((char const   *)zSsystem);
#line 244
          zret = zsysdep_in_dir((char const   *)zSdir, (char const   *)(q->d_name));
          }
          {
#line 246
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 246
            if ((iDebug & 128) != 0) {
              {
#line 246
              ulog((enum tlog )3, "zsysdep_get_xqt: Returning %s (system %s)", zret,
                   *pzsystem);
              }
            }
#line 246
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 250
          return (zret);
        }
      }
    }
#line 256
    if ((unsigned long )q == (unsigned long )((void *)0)) {
      {
#line 258
      closedir(qdir);
#line 261
      qSxqt_dir = (DIR *)((void *)0);
      }
#line 262
      if (! fSone_dir) {
#line 263
        goto while_continue;
      }
#line 266
      qSxqt_topdir = (DIR *)((void *)0);
#line 267
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 276 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/xqtfil.c"
void usysdep_get_xqt_free(char const   *zsystem  __attribute__((__unused__)) ) 
{ 


  {
#line 280
  if ((unsigned long )qSxqt_topdir != (unsigned long )((void *)0)) {
    {
#line 282
    closedir(qSxqt_topdir);
#line 283
    qSxqt_topdir = (DIR *)((void *)0);
    }
  }
#line 286
  if ((unsigned long )qSxqt_dir != (unsigned long )((void *)0)) {
    {
#line 288
    closedir(qSxqt_dir);
#line 289
    qSxqt_dir = (DIR *)((void *)0);
    }
  }
  {
#line 291
  ubuffree(zSdir);
#line 292
  zSdir = (char *)((void *)0);
#line 293
  ubuffree(zSsystem);
#line 294
  zSsystem = (char *)((void *)0);
#line 295
  fSone_dir = 0;
  }
#line 297
  return;
}
}
#line 750 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 756
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
char const   work_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'w',      (char const   )'o',      (char const   )'r', 
        (char const   )'k',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'2',      (char const   )'4',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 210 "../system.h"
boolean fsysdep_file_exists(char const   *zfile ) ;
#line 297
boolean fsysdep_has_work(struct uuconf_system  const  *qsys ) ;
#line 306
boolean fsysdep_get_work_init(struct uuconf_system  const  *qsys , int bgrade , unsigned int cmax ) ;
#line 322
boolean fsysdep_get_work(struct uuconf_system  const  *qsys , int bgrade  __attribute__((__unused__)) ,
                         unsigned int cmax  __attribute__((__unused__)) , struct scmd *qcmd ) ;
#line 329
boolean fsysdep_did_work(pointer pseq ) ;
#line 340
char const   *zsysdep_save_temp_file(pointer pseq ) ;
#line 357
void usysdep_get_work_free(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ) ;
#line 370
char *zsysdep_spool_file_name(struct uuconf_system  const  *qsys , char const   *zfile ,
                              pointer pseq ) ;
#line 459
boolean fsysdep_move_file(char const   *zorig , char const   *zto , boolean fmkdirs ,
                          boolean fpublic , boolean fcheck , char const   *zuser ) ;
#line 792
char *zsysdep_jobid(struct uuconf_system  const  *qsys , pointer pseq ) ;
#line 462 "../sysdep.h"
int bsgrade(pointer pseq ) ;
#line 499
char *zsfile_to_jobid(struct uuconf_system  const  *qsys , char const   *zfile , int bgrade  __attribute__((__unused__)) ) ;
#line 554
char const   *zSspooldir ;
#line 50 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static char *zswork_directory(char const   *zsystem ) ;
#line 51
static boolean fswork_file(char const   *zsystem  __attribute__((__unused__)) , char const   *zfile ,
                           char *pbgrade ) ;
#line 53
static int iswork_cmp(constpointer pkey , constpointer pdatum ) ;
#line 99 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static struct ssfilename *asSwork_files  ;
#line 100 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static size_t cSwork_files  ;
#line 101 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static size_t iSwork_file  ;
#line 102 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static struct ssfile *qSwork_file  ;
#line 106 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static char *zswork_directory(char const   *zsystem ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 127
  tmp = zsysdep_in_dir(zsystem, "C.");
  }
#line 127
  return (tmp);
}
}
#line 136 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static boolean fswork_file(char const   *zsystem  __attribute__((__unused__)) , char const   *zfile ,
                           char *pbgrade ) 
{ 
  int tmp ;

  {
#line 183
  *pbgrade = (char )*(zfile + 2);
#line 184
  if ((int const   )*(zfile + 0) == 67) {
#line 184
    if ((int const   )*(zfile + 1) == 46) {
#line 184
      if ((int const   )*(zfile + 2) != 0) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
  } else {
#line 184
    tmp = 0;
  }
#line 184
  return (tmp);
}
}
#line 192 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static int iswork_cmp(constpointer pkey , constpointer pdatum ) 
{ 
  struct ssfilename  const  *qkey ;
  struct ssfilename  const  *qdatum ;
  int tmp ;

  {
  {
#line 197
  qkey = (struct ssfilename  const  *)pkey;
#line 198
  qdatum = (struct ssfilename  const  *)pdatum;
#line 200
  tmp = strcmp((char const   *)qkey->zfile, (char const   *)qdatum->zfile);
  }
#line 200
  return (tmp);
}
}
#line 205 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
boolean fsysdep_has_work(struct uuconf_system  const  *qsys ) 
{ 
  char *zdir ;
  DIR *qdir ;
  struct dirent *qentry ;
  char bgrade ;
  boolean tmp ;

  {
  {
#line 217
  zdir = zswork_directory((char const   *)qsys->uuconf_zname);
  }
#line 218
  if ((unsigned long )zdir == (unsigned long )((void *)0)) {
#line 219
    return (0);
  }
  {
#line 220
  qdir = opendir((char const   *)zdir);
  }
#line 221
  if ((unsigned long )qdir == (unsigned long )((void *)0)) {
    {
#line 223
    ubuffree(zdir);
    }
#line 224
    return (0);
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    qentry = readdir(qdir);
    }
#line 243
    if (! ((unsigned long )qentry != (unsigned long )((void *)0))) {
#line 243
      goto while_break;
    }
    {
#line 247
    tmp = fswork_file((char const   *)qsys->uuconf_zname, (char const   *)(qentry->d_name),
                      & bgrade);
    }
#line 247
    if (tmp) {
      {
#line 249
      closedir(qdir);
#line 253
      ubuffree(zdir);
      }
#line 254
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  closedir(qdir);
#line 265
  ubuffree(zdir);
  }
#line 266
  return (0);
}
}
#line 278 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
boolean fsysdep_get_work_init(struct uuconf_system  const  *qsys , int bgrade , unsigned int cmax ) 
{ 
  char *zdir ;
  DIR *qdir ;
  struct dirent *qentry ;
  size_t chad ;
  size_t callocated ;
  boolean fret ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char bfilegrade ;
  char *zname ;
  struct ssfilename slook ;
  pointer tmp___2 ;
  boolean tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 294
  zdir = zswork_directory((char const   *)qsys->uuconf_zname);
  }
#line 295
  if ((unsigned long )zdir == (unsigned long )((void *)0)) {
#line 296
    return (0);
  }
  {
#line 298
  qdir = opendir((char const   *)zdir);
  }
#line 299
  if ((unsigned long )qdir == (unsigned long )((void *)0)) {
    {
#line 303
    tmp___1 = __errno_location();
    }
#line 303
    if (*tmp___1 == 2) {
#line 304
      fret = 1;
    } else {
      {
#line 307
      tmp = __errno_location();
#line 307
      tmp___0 = strerror(*tmp);
#line 307
      ulog((enum tlog )1, "opendir (%s): %s", zdir, tmp___0);
#line 308
      fret = 0;
      }
    }
    {
#line 310
    ubuffree(zdir);
    }
#line 311
    return (fret);
  }
#line 314
  chad = cSwork_files;
#line 315
  callocated = cSwork_files;
#line 324
  if (chad > 0UL) {
    {
#line 325
    qsort((pointer )asSwork_files, chad, sizeof(struct ssfilename ), & iswork_cmp);
    }
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 355
    qentry = readdir(qdir);
    }
#line 355
    if (! ((unsigned long )qentry != (unsigned long )((void *)0))) {
#line 355
      goto while_break;
    }
    {
#line 362
    zname = zbufcpy((char const   *)(qentry->d_name));
#line 368
    slook.zfile = zname;
#line 369
    tmp___3 = fswork_file((char const   *)qsys->uuconf_zname, (char const   *)(qentry->d_name),
                          & bfilegrade);
    }
#line 369
    if (tmp___3) {
      {
#line 369
      tmp___4 = uuconf_grade_cmp(bgrade, (int )bfilegrade);
      }
#line 369
      if (tmp___4 < 0) {
        {
#line 377
        ubuffree(zname);
        }
      } else
#line 369
      if ((unsigned long )asSwork_files != (unsigned long )((void *)0)) {
        {
#line 369
        tmp___5 = bsearch((void const   *)((pointer )(& slook)), (void const   *)((pointer )asSwork_files),
                          chad, sizeof(struct ssfilename ), & iswork_cmp);
        }
#line 369
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
          {
#line 377
          ubuffree(zname);
          }
        } else {
#line 369
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 380
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 380
          if ((iDebug & 128) != 0) {
            {
#line 380
            ulog((enum tlog )3, "fsysdep_get_work_init: Found %s", zname);
            }
          }
#line 380
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 384
        if (cSwork_files >= callocated) {
          {
#line 386
          callocated += 10UL;
#line 387
          tmp___2 = xrealloc((pointer )asSwork_files, callocated * sizeof(struct ssfilename ));
#line 387
          asSwork_files = (struct ssfilename *)tmp___2;
          }
        }
#line 393
        (asSwork_files + cSwork_files)->zfile = zname;
#line 394
        (asSwork_files + cSwork_files)->bgrade = bfilegrade;
#line 395
        cSwork_files ++;
#line 396
        if (cmax != 0U) {
#line 396
          if (cSwork_files - chad > (size_t )cmax) {
#line 397
            goto while_break;
          }
        }
      }
    } else {
      {
#line 377
      ubuffree(zname);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  closedir(qdir);
#line 410
  ubuffree(zdir);
  }
#line 414
  if (cSwork_files > iSwork_file) {
    {
#line 415
    qsort((pointer )(asSwork_files + iSwork_file), cSwork_files - iSwork_file, sizeof(struct ssfilename ),
          & iswork_cmp);
    }
  }
#line 419
  return (1);
}
}
#line 430 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
boolean fsysdep_get_work(struct uuconf_system  const  *qsys , int bgrade  __attribute__((__unused__)) ,
                         unsigned int cmax  __attribute__((__unused__)) , struct scmd *qcmd ) 
{ 
  char *zdir ;
  FILE *e ;
  struct ssfile *qfile ;
  int iline ;
  int callocated ;
  char *zline ;
  size_t cline ;
  char *zname ;
  char bfilegrade ;
  int *tmp ;
  char *tmp___0 ;
  pointer tmp___1 ;
  pointer tmp___2 ;
  __ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int iline___0 ;
  boolean tmp___7 ;
  char *zreal ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 439
  if ((unsigned long )qSwork_file != (unsigned long )((void *)0)) {
#line 439
    if (qSwork_file->cdid >= qSwork_file->clines) {
#line 440
      qSwork_file = (struct ssfile *)((void *)0);
    }
  }
#line 442
  if ((unsigned long )asSwork_files == (unsigned long )((void *)0)) {
#line 444
    qcmd->bcmd = (char )'H';
#line 445
    return (1);
  }
#line 448
  zdir = (char *)((void *)0);
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      if (! ((unsigned long )qSwork_file == (unsigned long )((void *)0))) {
#line 454
        goto while_break___0;
      }
      {
#line 465
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 467
        if (iSwork_file >= cSwork_files) {
          {
#line 469
          qcmd->bcmd = (char )'H';
#line 470
          ubuffree(zdir);
          }
#line 471
          return (1);
        }
#line 474
        if ((unsigned long )zdir == (unsigned long )((void *)0)) {
          {
#line 476
          zdir = zswork_directory((char const   *)qsys->uuconf_zname);
          }
#line 477
          if ((unsigned long )zdir == (unsigned long )((void *)0)) {
#line 478
            return (0);
          }
        }
        {
#line 481
        zname = zsysdep_in_dir((char const   *)zdir, (char const   *)(asSwork_files + iSwork_file)->zfile);
#line 482
        bfilegrade = (asSwork_files + iSwork_file)->bgrade;
#line 484
        iSwork_file ++;
#line 486
        e = fopen((char const   */* __restrict  */)zname, (char const   */* __restrict  */)"r");
        }
#line 487
        if ((unsigned long )e == (unsigned long )((void *)0)) {
          {
#line 489
          tmp = __errno_location();
#line 489
          tmp___0 = strerror(*tmp);
#line 489
          ulog((enum tlog )1, "fopen (%s): %s", zname, tmp___0);
#line 491
          ubuffree(zname);
          }
        }
#line 465
        if (! ((unsigned long )e == (unsigned long )((void *)0))) {
#line 465
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 496
      tmp___1 = xmalloc(sizeof(struct ssfile ));
#line 496
      qfile = (struct ssfile *)tmp___1;
#line 497
      callocated = 10;
#line 498
      iline = 0;
#line 500
      zline = (char *)((void *)0);
#line 501
      cline = (size_t )0;
      }
      {
#line 502
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 502
        tmp___3 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                          (FILE */* __restrict  */)e);
        }
#line 502
        if (! (tmp___3 > 0L)) {
#line 502
          goto while_break___2;
        }
#line 504
        if (iline >= callocated) {
          {
#line 510
          tmp___2 = xrealloc((pointer )qfile, sizeof(struct ssfile ) + (unsigned long )callocated * sizeof(struct ssline ));
#line 510
          qfile = (struct ssfile *)tmp___2;
#line 515
          callocated += 10;
          }
        }
        {
#line 517
        qfile->aslines[iline].zline = zbufcpy((char const   *)zline);
#line 518
        qfile->aslines[iline].qfile = (struct ssfile *)((void *)0);
#line 519
        qfile->aslines[iline].ztemp = (char *)((void *)0);
#line 520
        iline ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 523
      xfree((pointer )zline);
#line 525
      tmp___6 = fclose(e);
      }
#line 525
      if (tmp___6 != 0) {
        {
#line 526
        tmp___4 = __errno_location();
#line 526
        tmp___5 = strerror(*tmp___4);
#line 526
        ulog((enum tlog )1, "fclose: %s", tmp___5);
        }
      }
#line 528
      if (iline == 0) {
        {
#line 532
        qfile->aslines[0].zline = zbufcpy("P");
#line 533
        qfile->aslines[0].qfile = (struct ssfile *)((void *)0);
#line 534
        qfile->aslines[0].ztemp = (char *)((void *)0);
#line 535
        iline = 1;
        }
      }
#line 538
      qfile->zfile = zname;
#line 539
      qfile->bgrade = bfilegrade;
#line 540
      qfile->clines = iline;
#line 541
      qfile->cdid = 0;
#line 542
      qSwork_file = qfile;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 547
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 551
      if (qSwork_file->cdid >= qSwork_file->clines) {
#line 556
        qSwork_file = (struct ssfile *)((void *)0);
#line 558
        goto while_break___3;
      }
      {
#line 561
      iline___0 = qSwork_file->cdid;
#line 562
      (qSwork_file->cdid) ++;
#line 565
      tmp___7 = fparse_cmd(qSwork_file->aslines[iline___0].zline, qcmd);
      }
#line 565
      if (! tmp___7) {
        {
#line 567
        ulog((enum tlog )1, "Bad line in command file %s", qSwork_file->zfile);
#line 569
        ubuffree(qSwork_file->aslines[iline___0].zline);
#line 570
        qSwork_file->aslines[iline___0].zline = (char *)((void *)0);
        }
#line 571
        goto while_continue___3;
      }
#line 573
      qcmd->bgrade = qSwork_file->bgrade;
#line 575
      qSwork_file->aslines[iline___0].qfile = qSwork_file;
#line 576
      qcmd->pseq = (pointer )(& qSwork_file->aslines[iline___0]);
#line 578
      if ((int )qcmd->bcmd == 83) {
#line 578
        goto _L;
      } else
#line 578
      if ((int )qcmd->bcmd == 69) {
        _L: /* CIL Label */ 
        {
#line 582
        zreal = zsysdep_spool_file_name(qsys, qcmd->ztemp, qcmd->pseq);
        }
#line 584
        if ((unsigned long )zreal == (unsigned long )((void *)0)) {
          {
#line 586
          ubuffree(qSwork_file->aslines[iline___0].zline);
#line 587
          qSwork_file->aslines[iline___0].zline = (char *)((void *)0);
#line 588
          ubuffree(zdir);
          }
#line 589
          return (0);
        }
#line 591
        qSwork_file->aslines[iline___0].ztemp = zreal;
      }
      {
#line 594
      ubuffree(zdir);
      }
#line 595
      return (1);
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 610 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
boolean fsysdep_did_work(pointer pseq ) 
{ 
  struct ssfile *qfile ;
  struct ssline *qline ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 618
  qline = (struct ssline *)pseq;
#line 620
  ubuffree(qline->zline);
#line 621
  qline->zline = (char *)((void *)0);
#line 623
  qfile = qline->qfile;
#line 624
  qline->qfile = (struct ssfile *)((void *)0);
  }
#line 630
  if ((unsigned long )qline->ztemp != (unsigned long )((void *)0)) {
    {
#line 632
    remove((char const   *)qline->ztemp);
#line 633
    ubuffree(qline->ztemp);
#line 634
    qline->ztemp = (char *)((void *)0);
    }
  }
#line 639
  if (qfile->cdid < qfile->clines) {
#line 640
    return (1);
  }
#line 643
  i = 0;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! (i < qfile->clines)) {
#line 643
      goto while_break;
    }
#line 644
    if ((unsigned long )qfile->aslines[i].qfile != (unsigned long )((void *)0)) {
#line 645
      return (1);
    }
#line 643
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 648
  tmp___1 = remove((char const   *)qfile->zfile);
  }
#line 648
  if (tmp___1 != 0) {
    {
#line 650
    tmp = __errno_location();
#line 650
    tmp___0 = strerror(*tmp);
#line 650
    ulog((enum tlog )1, "remove (%s): %s", qfile->zfile, tmp___0);
    }
#line 652
    return (0);
  }
  {
#line 655
  ubuffree(qfile->zfile);
#line 656
  xfree((pointer )qfile);
  }
#line 658
  if ((unsigned long )qfile == (unsigned long )qSwork_file) {
#line 659
    qSwork_file = (struct ssfile *)((void *)0);
  }
#line 661
  return (1);
}
}
#line 668 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
void usysdep_get_work_free(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ) 
{ 
  size_t i ;
  int i___0 ;

  {
#line 672
  if ((unsigned long )asSwork_files != (unsigned long )((void *)0)) {
#line 676
    i = (size_t )0;
    {
#line 676
    while (1) {
      while_continue: /* CIL Label */ ;
#line 676
      if (! (i < cSwork_files)) {
#line 676
        goto while_break;
      }
      {
#line 677
      ubuffree((char *)((pointer )(asSwork_files + i)->zfile));
#line 676
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 678
    xfree((pointer )asSwork_files);
#line 679
    asSwork_files = (struct ssfilename *)((void *)0);
#line 680
    cSwork_files = (size_t )0;
#line 681
    iSwork_file = (size_t )0;
    }
  }
#line 683
  if ((unsigned long )qSwork_file != (unsigned long )((void *)0)) {
    {
#line 687
    ubuffree(qSwork_file->zfile);
#line 688
    i___0 = 0;
    }
    {
#line 688
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 688
      if (! (i___0 < qSwork_file->cdid)) {
#line 688
        goto while_break___0;
      }
      {
#line 690
      ubuffree(qSwork_file->aslines[i___0].zline);
#line 691
      ubuffree(qSwork_file->aslines[i___0].ztemp);
#line 688
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 693
    i___0 = qSwork_file->cdid;
    {
#line 693
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 693
      if (! (i___0 < qSwork_file->clines)) {
#line 693
        goto while_break___1;
      }
      {
#line 694
      ubuffree(qSwork_file->aslines[i___0].zline);
#line 693
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 695
    xfree((pointer )qSwork_file);
#line 696
    qSwork_file = (struct ssfile *)((void *)0);
    }
  }
#line 698
  return;
}
}
#line 712 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static char *zbuf  ;
#line 713 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
static size_t cbuf  ;
#line 705 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
char const   *zsysdep_save_temp_file(pointer pseq ) 
{ 
  struct ssline *qline ;
  char *zto ;
  char *zslash ;
  size_t cwant ;
  boolean tmp ;
  size_t tmp___0 ;
  boolean tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 709
  qline = (struct ssline *)pseq;
#line 715
  tmp = fsysdep_file_exists((char const   *)qline->ztemp);
  }
#line 715
  if (! tmp) {
#line 716
    return ((char const   *)((void *)0));
  }
  {
#line 718
  zslash = strrchr((char const   *)qline->ztemp, '/');
  }
#line 719
  if ((unsigned long )zslash == (unsigned long )((void *)0)) {
#line 720
    zslash = qline->ztemp;
  } else {
#line 722
    zslash ++;
  }
  {
#line 724
  tmp___0 = strlen((char const   *)zslash);
#line 724
  zto = zbufalc((sizeof(".Preserve") + sizeof("/")) + tmp___0);
#line 725
  sprintf((char */* __restrict  */)zto, (char const   */* __restrict  */)"%s/%s",
          ".Preserve", zslash);
#line 727
  tmp___1 = fsysdep_move_file((char const   *)qline->ztemp, (char const   *)zto, 1,
                              0, 0, (char const   *)((void *)0));
  }
#line 727
  if (! tmp___1) {
    {
#line 731
    ubuffree(zto);
    }
#line 732
    return ("Could not move file to preservation directory");
  }
  {
#line 735
  tmp___2 = strlen(zSspooldir);
#line 735
  tmp___3 = strlen((char const   *)zto);
#line 735
  cwant = (sizeof("File saved as\n\t/") + tmp___2) + tmp___3;
  }
#line 736
  if (cwant > cbuf) {
    {
#line 738
    ubuffree(zbuf);
#line 739
    zbuf = zbufalc(cwant);
#line 740
    cbuf = cwant;
    }
  }
  {
#line 743
  sprintf((char */* __restrict  */)zbuf, (char const   */* __restrict  */)"File saved as\n\t%s/%s",
          zSspooldir, zto);
#line 744
  ubuffree(zto);
  }
#line 745
  return ((char const   *)zbuf);
}
}
#line 750 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
char *zsysdep_jobid(struct uuconf_system  const  *qsys , pointer pseq ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 755
  tmp = bsgrade(pseq);
#line 755
  tmp___0 = zsfile_to_jobid(qsys, (char const   *)(((struct ssline *)pseq)->qfile)->zfile,
                            tmp);
  }
#line 755
  return (tmp___0);
}
}
#line 764 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/work.c"
int bsgrade(pointer pseq ) 
{ 
  char const   *zfile ;
  char bgrade ;
  char *tmp ;

  {
#line 771
  if ((unsigned long )pseq == (unsigned long )((void *)0)) {
#line 772
    return (-1);
  }
  {
#line 774
  zfile = (char const   *)(((struct ssline *)pseq)->qfile)->zfile;
#line 777
  tmp = strrchr(zfile, '/');
#line 777
  bgrade = *(tmp + 3);
  }
#line 786
  return ((int )bgrade);
}
}
#line 517 "../system.h"
boolean fsysdep_wildcard_start(char const   *zfile ) ;
#line 523
char *zsysdep_wildcard(char const   *zfile  __attribute__((__unused__)) ) ;
#line 528
boolean fsysdep_wildcard_end(void) ;
#line 159 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int glob(char const   * __restrict  __pattern ,
                                              int __flags , int (*__errfunc)(char const   * ,
                                                                             int  ) ,
                                              glob_t * __restrict  __pglob ) ;
#line 164
extern  __attribute__((__nothrow__)) void globfree(glob_t *__pglob ) ;
#line 46 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/wldcrd.c"
static glob_t sSglob  ;
#line 47 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/wldcrd.c"
static unsigned int iSglob  ;
#line 56 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/wldcrd.c"
boolean fsysdep_wildcard_start(char const   *zfile ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
#line 63
  if ((int const   )*zfile != 47) {
    {
#line 64
    ulog((enum tlog )2, "fsysdep_wildcard: %s: Can\'t happen", zfile);
    }
  }
  {
#line 67
  tmp = glob((char const   */* __restrict  */)zfile, 0, (int (*)(char const   * ,
                                                                 int  ))((int (*)())((void *)0)),
             (glob_t */* __restrict  */)(& sSglob));
  }
#line 67
  if (tmp != 0) {
#line 68
    sSglob.gl_pathc = (size_t )0;
  }
#line 69
  iSglob = 0U;
#line 70
  return (1);
}
}
#line 156 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/wldcrd.c"
char *zsysdep_wildcard(char const   *zfile  __attribute__((__unused__)) ) 
{ 
  char *zret ;

  {
#line 164
  if ((size_t )iSglob >= sSglob.gl_pathc) {
#line 165
    return ((char *)((void *)0));
  }
  {
#line 166
  zret = zbufcpy((char const   *)*(sSglob.gl_pathv + iSglob));
#line 167
  iSglob ++;
  }
#line 168
  return (zret);
}
}
#line 200 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/wldcrd.c"
boolean fsysdep_wildcard_end(void) 
{ 


  {
  {
#line 204
  globfree(& sSglob);
  }
#line 205
  return (1);
}
}
#line 782 "../system.h"
boolean usysdep_walk_tree(char const   *zdir , void (*pufn)(char const   *zfull ,
                                                            char const   *zrelative ,
                                                            pointer pinfo ) , pointer pinfo ) ;
#line 137 "/usr/include/ftw.h"
extern int ( __attribute__((__nonnull__(1,2))) ftw)(char const   *__dir , int (*__func)(char const   *__filename ,
                                                                                        struct stat  const  *__status ,
                                                                                        int __flag ) ,
                                                    int __descriptors ) ;
#line 14 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/walk.c"
static int iswalk_dir(char const   *zname , struct stat  const  *qstat  __attribute__((__unused__)) ,
                      int iflag ) ;
#line 19 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/walk.c"
static size_t cSlen  ;
#line 20 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/walk.c"
static void (*puSfn)(char const   *zfull , char const   *zrelative , pointer pinfo )  ;
#line 22 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/walk.c"
static pointer pSinfo  ;
#line 24 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/walk.c"
boolean usysdep_walk_tree(char const   *zdir , void (*pufn)(char const   *zfull ,
                                                            char const   *zrelative ,
                                                            pointer pinfo ) , pointer pinfo ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 31
  tmp = strlen(zdir);
#line 31
  cSlen = tmp + 1UL;
#line 32
  puSfn = pufn;
#line 33
  pSinfo = pinfo;
#line 34
  tmp___0 = ftw((char const   *)((char *)zdir), & iswalk_dir, 5);
  }
#line 34
  return (tmp___0 == 0);
}
}
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/walk.c"
static int iswalk_dir(char const   *zname , struct stat  const  *qstat  __attribute__((__unused__)) ,
                      int iflag ) 
{ 
  char *zcopy ;

  {
#line 49
  if (iflag != 0) {
#line 50
    return (0);
  }
  {
#line 52
  zcopy = zbufcpy(zname + cSlen);
#line 54
  (*puSfn)(zname, (char const   *)zcopy, pSinfo);
#line 56
  ubuffree(zcopy);
  }
#line 58
  return (0);
}
}
#line 769 "../system.h"
char *zsysdep_uuto(char const   *zdest , char const   *zlocalname ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uuto.c"
char *zsysdep_uuto(char const   *zdest , char const   *zlocalname ) 
{ 
  char const   *zexclam ;
  char *zto ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 20
  tmp = strrchr(zdest, '!');
#line 20
  zexclam = (char const   *)tmp;
  }
#line 21
  if ((unsigned long )zexclam == (unsigned long )((void *)0)) {
#line 22
    return ((char *)((void *)0));
  }
  {
#line 23
  tmp___0 = strlen(zexclam);
#line 23
  tmp___1 = strlen(zlocalname);
#line 23
  tmp___2 = zbufalc((((unsigned long )(zexclam - zdest) + sizeof("!~/receive///")) + tmp___0) + tmp___1);
#line 23
  zto = tmp___2;
#line 27
  memcpy((void */* __restrict  */)zto, (void const   */* __restrict  */)zdest, (size_t )(zexclam - zdest));
#line 28
  sprintf((char */* __restrict  */)(zto + (zexclam - zdest)), (char const   */* __restrict  */)"!~/receive/%s/%s/",
          zexclam + 1, zlocalname);
  }
#line 30
  return (zto);
}
}
#line 291 "../system.h"
boolean fsysdep_unknown_caller(char const   *zscript , char const   *zsystem ) ;
#line 16 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/unknwn.c"
boolean fsysdep_unknown_caller(char const   *zscript , char const   *zsystem ) 
{ 
  char const   *azargs[3] ;
  int aidescs[3] ;
  pid_t ipid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 25
  azargs[0] = zscript;
#line 26
  azargs[1] = zsystem;
#line 27
  azargs[2] = (char const   *)((void *)0);
#line 29
  aidescs[0] = -1;
#line 30
  aidescs[1] = -1;
#line 31
  aidescs[2] = -1;
#line 33
  ipid = ixsspawn(azargs, aidescs, 1, 1, (char const   *)((void *)0), 0, 1, (char const   *)((void *)0),
                  (char const   *)((void *)0), (char const   *)((void *)0));
  }
#line 36
  if (ipid < 0) {
    {
#line 38
    tmp = __errno_location();
#line 38
    tmp___0 = strerror(*tmp);
#line 38
    ulog((enum tlog )1, "ixsspawn: %s", tmp___0);
    }
#line 39
    return (0);
  }
  {
#line 42
  tmp___1 = ixswait((unsigned long )ipid, (char const   *)((void *)0));
  }
#line 42
  return (tmp___1 != 0);
}
}
#line 478 "../sysdep.h"
boolean fsuser_perms(uid_t *pieuid , gid_t *piegid ) ;
#line 482
boolean fsuucp_perms(long ieuid  __attribute__((__unused__)) , long iegid  __attribute__((__unused__)) ) ;
#line 748 "../system.h"
unsigned int ixsysdep_user_file_mode(char const   *zfile ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/umode.c"
unsigned int ixsysdep_user_file_mode(char const   *zfile ) 
{ 
  uid_t ieuid ;
  gid_t iegid ;
  int iret ;
  struct stat s ;
  boolean tmp ;
  boolean tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 21
  tmp = fsuser_perms(& ieuid, & iegid);
  }
#line 21
  if (! tmp) {
#line 22
    return (0U);
  }
  {
#line 24
  iret = stat((char const   */* __restrict  */)((char *)zfile), (struct stat */* __restrict  */)(& s));
#line 26
  tmp___0 = fsuucp_perms((long )ieuid, (long )iegid);
  }
#line 26
  if (! tmp___0) {
#line 27
    return (0U);
  }
#line 29
  if (iret != 0) {
    {
#line 31
    tmp___1 = __errno_location();
#line 31
    tmp___2 = strerror(*tmp___1);
#line 31
    ulog((enum tlog )1, "stat (%s): %s", zfile, tmp___2);
    }
#line 32
    return (0U);
  }
#line 36
  if ((s.st_mode & 511U) == 0U) {
#line 37
    return (256U);
  }
#line 39
  return (s.st_mode & 511U);
}
}
#line 510 "../sysdep.h"
boolean fsultrix_has_spool(char const   *zsystem ) ;
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/ultspl.c"
boolean fsultrix_has_spool(char const   *zsystem ) 
{ 
  char *z ;
  boolean fret ;
  char *__cil_tmp4 ;

  {
  {
#line 17
  z = zsysdep_in_dir("sys", zsystem);
#line 18
  fret = fsysdep_directory((char const   *)z);
#line 19
  ubuffree(z);
  }
#line 20
  return (fret);
}
}
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 722
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 739
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uid.c"
boolean fsuser_perms(uid_t *pieuid , gid_t *piegid ) 
{ 
  uid_t ieuid ;
  uid_t iuid ;
  gid_t iegid ;
  gid_t igid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 49
  ieuid = geteuid();
#line 50
  iuid = getuid();
  }
#line 51
  if ((unsigned long )pieuid != (unsigned long )((void *)0)) {
#line 52
    *pieuid = ieuid;
  }
  {
#line 54
  iegid = getegid();
#line 55
  igid = getgid();
  }
#line 56
  if ((unsigned long )piegid != (unsigned long )((void *)0)) {
#line 57
    *piegid = iegid;
  }
  {
#line 63
  tmp___1 = setregid(iegid, igid);
  }
#line 63
  if (tmp___1 < 0) {
    {
#line 65
    tmp = __errno_location();
#line 65
    tmp___0 = strerror(*tmp);
#line 65
    ulog((enum tlog )1, "setregid (%ld, %ld): %s", (long )iegid, (long )igid, tmp___0);
    }
#line 67
    return (0);
  }
  {
#line 69
  tmp___4 = setreuid(ieuid, iuid);
  }
#line 69
  if (tmp___4 < 0) {
    {
#line 71
    tmp___2 = __errno_location();
#line 71
    tmp___3 = strerror(*tmp___2);
#line 71
    ulog((enum tlog )1, "setreuid (%ld, %ld): %s", (long )ieuid, (long )iuid, tmp___3);
    }
#line 73
    return (0);
  }
#line 101
  return (1);
}
}
#line 107 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uid.c"
boolean fsuucp_perms(long ieuid  __attribute__((__unused__)) , long iegid  __attribute__((__unused__)) ) 
{ 
  boolean tmp ;

  {
  {
#line 114
  tmp = fsuser_perms((uid_t *)((void *)0), (gid_t *)((void *)0));
  }
#line 114
  if (! tmp) {
#line 115
    return (0);
  }
#line 142
  return (1);
}
}
#line 405 "../system.h"
openfile_t esysdep_user_fopen(char const   *zfile , boolean frd , boolean fbinary  __attribute__((__unused__)) ) ;
#line 60 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/ufopen.c"
openfile_t esysdep_user_fopen(char const   *zfile , boolean frd , boolean fbinary  __attribute__((__unused__)) ) 
{ 
  uid_t ieuid ;
  gid_t iegid ;
  openfile_t e ;
  char const   *zerr ;
  int o ;
  boolean tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  boolean tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 70
  o = 0;
#line 72
  tmp = fsuser_perms(& ieuid, & iegid);
  }
#line 72
  if (! tmp) {
#line 73
    return ((FILE *)((void *)0));
  }
#line 75
  zerr = (char const   *)((void *)0);
#line 78
  if (frd) {
#line 78
    tmp___0 = "r";
  } else {
#line 78
    tmp___0 = "w";
  }
  {
#line 78
  e = fopen((char const   */* __restrict  */)zfile, (char const   */* __restrict  */)tmp___0);
  }
#line 79
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 80
    zerr = "fopen";
  } else {
    {
#line 82
    o = fileno(e);
    }
  }
  {
#line 101
  tmp___2 = fsuucp_perms((long )ieuid, (long )iegid);
  }
#line 101
  if (! tmp___2) {
#line 103
    if ((unsigned long )e != (unsigned long )((void *)0)) {
      {
#line 104
      tmp___1 = fclose(e);
      }
    }
#line 105
    return ((FILE *)((void *)0));
  }
#line 108
  if ((unsigned long )zerr != (unsigned long )((void *)0)) {
    {
#line 110
    tmp___3 = __errno_location();
#line 110
    tmp___4 = strerror(*tmp___3);
#line 110
    ulog((enum tlog )1, "%s (%s): %s", zerr, zfile, tmp___4);
    }
#line 124
    return ((FILE *)((void *)0));
  }
  {
#line 127
  tmp___8 = fcntl(o, 1, 0);
#line 127
  tmp___9 = fcntl(o, 2, tmp___8 | 1);
  }
#line 127
  if (tmp___9 < 0) {
    {
#line 129
    tmp___5 = __errno_location();
#line 129
    tmp___6 = strerror(*tmp___5);
#line 129
    ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___6);
#line 130
    tmp___7 = fclose(e);
    }
#line 131
    return ((FILE *)((void *)0));
  }
#line 134
  return (e);
}
}
#line 473 "../sysdep.h"
boolean fsuser_access(struct stat  const  *q , int imode , char const   *zuser ) ;
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 63 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 69
extern void endgrent(void) ;
#line 75
extern struct group *getgrent(void) ;
#line 59 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uacces.c"
static char *zuser_hold  ;
#line 60 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uacces.c"
static uid_t iuid_hold  ;
#line 61 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uacces.c"
static gid_t igid_hold  ;
#line 62 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uacces.c"
static int cgroups_hold  ;
#line 63 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uacces.c"
static gid_t *paigroups_hold  ;
#line 53 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/uacces.c"
boolean fsuser_access(struct stat  const  *q , int imode , char const   *zuser ) 
{ 
  unsigned int ir ;
  unsigned int iw ;
  unsigned int ix ;
  unsigned int iand ;
  struct passwd *qpwd ;
  struct group *qg ;
  char const   **pz ;
  pointer tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  boolean fgroup ;
  int i ;

  {
#line 66
  if (imode == 0) {
#line 67
    return (1);
  }
#line 69
  if ((unsigned long )zuser != (unsigned long )((void *)0)) {
#line 73
    if ((unsigned long )zuser_hold == (unsigned long )((void *)0)) {
#line 73
      goto _L;
    } else {
      {
#line 73
      tmp___1 = strcmp((char const   *)zuser_hold, zuser);
      }
#line 73
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
#line 77
        if ((unsigned long )zuser_hold != (unsigned long )((void *)0)) {
          {
#line 79
          ubuffree(zuser_hold);
#line 80
          zuser_hold = (char *)((void *)0);
#line 81
          cgroups_hold = 0;
#line 82
          xfree((pointer )paigroups_hold);
#line 83
          paigroups_hold = (gid_t *)((void *)0);
          }
        }
        {
#line 86
        qpwd = getpwnam((char const   *)((char *)zuser));
        }
#line 87
        if ((unsigned long )qpwd == (unsigned long )((void *)0)) {
#line 90
          zuser = (char const   *)((void *)0);
        } else {
          {
#line 98
          zuser_hold = zbufcpy(zuser);
#line 100
          iuid_hold = qpwd->pw_uid;
#line 101
          igid_hold = qpwd->pw_gid;
#line 108
          setgrent();
          }
          {
#line 109
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 109
            qg = getgrent();
            }
#line 109
            if (! ((unsigned long )qg != (unsigned long )((void *)0))) {
#line 109
              goto while_break;
            }
#line 113
            if (qg->gr_gid == igid_hold) {
#line 114
              goto while_continue;
            }
#line 115
            pz = (char const   **)qg->gr_mem;
            {
#line 115
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 115
              if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 115
                goto while_break___0;
              }
#line 117
              if ((int const   )*(*pz + 0) == (int const   )*zuser) {
                {
#line 117
                tmp___0 = strcmp(*pz, zuser);
                }
#line 117
                if (tmp___0 == 0) {
                  {
#line 120
                  tmp = xrealloc((pointer )paigroups_hold, (unsigned long )(cgroups_hold + 1) * sizeof(gid_t ));
#line 120
                  paigroups_hold = (gid_t *)tmp;
#line 125
                  *(paigroups_hold + cgroups_hold) = qg->gr_gid;
#line 126
                  cgroups_hold ++;
                  }
#line 127
                  goto while_break___0;
                }
              }
#line 115
              pz ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 131
          endgrent();
          }
        }
      }
    }
  }
#line 140
  if ((unsigned long )zuser != (unsigned long )((void *)0)) {
#line 143
    if (iuid_hold == 0U) {
#line 144
      return (1);
    }
    {
#line 149
    tmp___2 = geteuid();
    }
#line 149
    if (iuid_hold == tmp___2) {
#line 150
      return (1);
    }
  }
#line 153
  ir = (unsigned int )((256 >> 3) >> 3);
#line 154
  iw = (unsigned int )((128 >> 3) >> 3);
#line 155
  ix = (unsigned int )((64 >> 3) >> 3);
#line 157
  if ((unsigned long )zuser != (unsigned long )((void *)0)) {
#line 159
    if (iuid_hold == (uid_t )q->st_uid) {
#line 161
      ir = 256U;
#line 162
      iw = 128U;
#line 163
      ix = 64U;
    } else {
#line 169
      fgroup = 0;
#line 170
      if (igid_hold == (gid_t )q->st_gid) {
#line 171
        fgroup = 1;
      } else {
#line 176
        i = 0;
        {
#line 176
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 176
          if (! (i < cgroups_hold)) {
#line 176
            goto while_break___1;
          }
#line 178
          if (*(paigroups_hold + i) == (gid_t )q->st_gid) {
#line 180
            fgroup = 1;
#line 181
            goto while_break___1;
          }
#line 176
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 186
      if (fgroup) {
#line 188
        ir = (unsigned int )(256 >> 3);
#line 189
        iw = (unsigned int )(128 >> 3);
#line 190
        ix = (unsigned int )(64 >> 3);
      }
    }
  }
#line 195
  iand = 0U;
#line 196
  if ((imode & 4) != 0) {
#line 197
    iand |= ir;
  }
#line 198
  if ((imode & 2) != 0) {
#line 199
    iand |= iw;
  }
#line 200
  if ((imode & 1) != 0) {
#line 201
    iand |= ix;
  }
#line 203
  return ((q->st_mode & (unsigned int const   )iand) == (unsigned int const   )iand);
}
}
#line 1020 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 471 "../system.h"
openfile_t esysdep_truncate(openfile_t e , char const   *zname ) ;
#line 53 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/trunc.c"
openfile_t esysdep_truncate(openfile_t e , char const   *zname ) 
{ 
  int o ;
  int itrunc ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 63
  tmp___2 = fseek(e, 0L, 0);
  }
#line 63
  if (! (tmp___2 == 0)) {
    {
#line 65
    tmp = __errno_location();
#line 65
    tmp___0 = strerror(*tmp);
#line 65
    ulog((enum tlog )1, "rewind: %s", tmp___0);
#line 66
    tmp___1 = fclose(e);
#line 67
    remove(zname);
    }
#line 68
    return ((FILE *)((void *)0));
  }
  {
#line 72
  o = fileno(e);
#line 78
  itrunc = ftruncate(o, (__off_t )0);
  }
#line 101
  if (itrunc != 0) {
    {
#line 104
    tmp___3 = __errno_location();
#line 104
    tmp___4 = strerror(*tmp___3);
#line 104
    ulog((enum tlog )1, "ftruncate: %s", tmp___4);
#line 107
    tmp___5 = __errno_location();
#line 107
    tmp___6 = strerror(*tmp___5);
#line 107
    ulog((enum tlog )1, "ltrunc: %s", tmp___6);
#line 116
    tmp___7 = fclose(e);
#line 117
    remove(zname);
    }
#line 118
    return ((FILE *)((void *)0));
  }
#line 121
  return (e);
}
}
#line 623 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tmpfil.c"
static unsigned int icount  ;
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tmpfil.c"
char *zstemp_file(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ) 
{ 
  char const   *zdigs ;
  char ab___0[14] ;
  pid_t ime ;
  int iset ;
  char *tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 42
  zdigs = "0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
#line 47
  ab___0[0] = (char )'T';
#line 48
  ab___0[1] = (char )'M';
#line 49
  ab___0[2] = (char )'.';
#line 51
  ime = getpid();
#line 52
  iset = 3;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (ime > 0) {
#line 53
      if (! (iset < 10)) {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
#line 55
    ab___0[iset] = (char )*(zdigs + (unsigned long )ime % (sizeof("0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-") - 1UL));
#line 56
    ime = (pid_t )((unsigned long )ime / (sizeof("0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-") - 1UL));
#line 57
    iset ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  ab___0[iset] = (char )'.';
#line 61
  iset ++;
#line 63
  ab___0[iset] = (char )*(zdigs + (unsigned long )icount / (sizeof("0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-") - 1UL));
#line 64
  iset ++;
#line 65
  ab___0[iset] = (char )*(zdigs + (unsigned long )icount % (sizeof("0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-") - 1UL));
#line 66
  iset ++;
#line 68
  ab___0[iset] = (char )'\000';
#line 70
  icount ++;
#line 71
  if ((unsigned long )icount >= (sizeof("0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-") - 1UL) * (sizeof("0123456789abcdefghijklmnopqrtsuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-") - 1UL)) {
#line 72
    icount = 0U;
  }
  {
#line 78
  tmp = zsysdep_in_dir(".Temp", (char const   *)(ab___0));
  }
#line 78
  return (tmp);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tli.c"
char const   tli_rcsid[47]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tli.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'l',      (char const   )'i', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'8', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 237 "../system.h"
long ixsysdep_time(long *pimicros ) ;
#line 244
long ixsysdep_process_time(long *pimicros ) ;
#line 21 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/time.c"
long ixsysdep_time(long *pimicros ) 
{ 
  long tmp ;

  {
  {
#line 26
  tmp = ixsysdep_process_time(pimicros);
  }
#line 26
  return (tmp);
}
}
#line 457 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1))) bzero)(void *__s ,
                                                                                   size_t __n ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
char const   tcp_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'c',      (char const   )'p', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'1', 
        (char const   )'2',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'2',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 321 "../uudefs.h"
void ulog_id(int i ) ;
#line 330
void ulog_device(char const   *zdevice ) ;
#line 422
sig_atomic_t volatile   afSignal[5] ;
#line 598 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 392 "../sysdep.h"
boolean fsysdep_conn_read(struct sconnection *qconn , char *zbuf___0 , size_t *pclen ,
                          size_t cmin , int ctimeout , boolean freport ) ;
#line 396
boolean fsysdep_conn_write(struct sconnection *qconn , char const   *zwrite , size_t cwrite ) ;
#line 398
boolean fsysdep_conn_io(struct sconnection *qconn , char const   *zwrite , size_t *pcwrite ,
                        char *zread , size_t *pcread ) ;
#line 401
boolean fsysdep_conn_chat(struct sconnection *qconn , char **pzprog ) ;
#line 414
pid_t ixsfork(void) ;
#line 285 "../conn.h"
extern boolean fconn_dial_sequence(struct sconnection *qconn , pointer puuconf , char **pzdialer ,
                                   struct uuconf_system  const  *qsys , char const   *zphone ,
                                   struct uuconf_dialer *qdialer , enum tdialerfound *ptdialerfound ) ;
#line 320
boolean fsysdep_tcp_init(struct sconnection *qconn ) ;
#line 85 "../system.h"
void usysdep_exit(boolean fsuccess ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 368 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 370
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 638
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 644
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 647
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 75 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static void utcp_free(struct sconnection *qconn ) ;
#line 77
static boolean ftcp_set_hints(int iversion , struct addrinfo *qhints ) ;
#line 79
static boolean ftcp_set_flags(struct ssysdep_conn *qsysdep ) ;
#line 80
static boolean ftcp_open(struct sconnection *qconn , long ibaud  __attribute__((__unused__)) ,
                         boolean fwait , boolean fuser  __attribute__((__unused__)) ) ;
#line 82
static boolean ftcp_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                          struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                          boolean fsuccess  __attribute__((__unused__)) ) ;
#line 86
static boolean ftcp_dial(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys ,
                         char const   *zphone , struct uuconf_dialer *qdialer , enum tdialerfound *ptdialer ) ;
#line 91
static int itcp_port_number(char const   *zname ) ;
#line 94 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static struct sconncmds  const  stcpcmds  = 
#line 94
     {& utcp_free, (boolean (*)(struct sconnection *qconn , boolean fin , boolean fuser ))((void *)0),
    (boolean (*)(struct sconnection *qconn ))((void *)0), & ftcp_open, & ftcp_close,
    & ftcp_dial, & fsysdep_conn_read, & fsysdep_conn_write, & fsysdep_conn_io, (boolean (*)(struct sconnection *qconn ))((void *)0),
    (boolean (*)(struct sconnection *qconn , enum tparitysetting tparity , enum tstripsetting tstrip ,
                 enum txonxoffsetting txonxoff ))((void *)0), (boolean (*)(struct sconnection *qconn ,
                                                                           boolean fcarrier ))((void *)0),
    & fsysdep_conn_chat, (long (*)(struct sconnection *qconn ))((void *)0)};
#line 114 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
boolean fsysdep_tcp_init(struct sconnection *qconn ) 
{ 
  struct ssysdep_conn *q ;
  pointer tmp ;

  {
  {
#line 120
  tmp = xmalloc(sizeof(struct ssysdep_conn ));
#line 120
  q = (struct ssysdep_conn *)tmp;
#line 121
  q->o = -1;
#line 122
  q->ord = -1;
#line 123
  q->owr = -1;
#line 124
  q->zdevice = (char *)((void *)0);
#line 125
  q->iflags = -1;
#line 126
  q->iwr_flags = -1;
#line 127
  q->fterminal = 0;
#line 128
  q->ftli = 0;
#line 129
  q->ibaud = 0L;
#line 131
  qconn->psysdep = (pointer )q;
#line 132
  qconn->qcmds = & stcpcmds;
  }
#line 133
  return (1);
}
}
#line 138 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static void utcp_free(struct sconnection *qconn ) 
{ 


  {
  {
#line 142
  xfree(qconn->psysdep);
  }
#line 143
  return;
}
}
#line 149 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static boolean ftcp_set_hints(int iversion , struct addrinfo *qhints ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 156
  if (iversion == 0) {
#line 156
    goto case_0;
  }
#line 159
  if (iversion == 4) {
#line 159
    goto case_4;
  }
#line 162
  if (iversion == 6) {
#line 162
    goto case_6;
  }
#line 170
  goto switch_default;
  case_0: /* CIL Label */ 
#line 157
  qhints->ai_family = 0;
#line 158
  goto switch_break;
  case_4: /* CIL Label */ 
#line 160
  qhints->ai_family = 2;
#line 161
  goto switch_break;
  case_6: /* CIL Label */ 
#line 164
  qhints->ai_family = 10;
#line 169
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 171
  ulog((enum tlog )1, "Invalid IP version number %d", iversion);
  }
#line 172
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 174
  return (1);
}
}
#line 181 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static boolean ftcp_set_flags(struct ssysdep_conn *qsysdep ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 185
  tmp___1 = fcntl(qsysdep->o, 1, 0);
#line 185
  tmp___2 = fcntl(qsysdep->o, 2, tmp___1 | 1);
  }
#line 185
  if (tmp___2 < 0) {
    {
#line 188
    tmp = __errno_location();
#line 188
    tmp___0 = strerror(*tmp);
#line 188
    ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___0);
#line 189
    close(qsysdep->o);
#line 190
    qsysdep->o = -1;
    }
#line 191
    return (0);
  }
  {
#line 194
  qsysdep->iflags = fcntl(qsysdep->o, 3, 0);
  }
#line 195
  if (qsysdep->iflags < 0) {
    {
#line 197
    tmp___3 = __errno_location();
#line 197
    tmp___4 = strerror(*tmp___3);
#line 197
    ulog((enum tlog )1, "fcntl: %s", tmp___4);
#line 198
    close(qsysdep->o);
#line 199
    qsysdep->o = -1;
    }
#line 200
    return (0);
  }
#line 203
  return (1);
}
}
#line 210 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static boolean ftcp_open(struct sconnection *qconn , long ibaud  __attribute__((__unused__)) ,
                         boolean fwait , boolean fuser  __attribute__((__unused__)) ) 
{ 
  struct ssysdep_conn *qsysdep ;
  char const   *zport ;
  uid_t ieuid ;
  gid_t iegid ;
  boolean fswap ;
  struct addrinfo shints ;
  struct addrinfo *qres ;
  struct addrinfo *quse ;
  int ierr ;
  boolean tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  boolean tmp___4 ;
  __uid_t tmp___5 ;
  boolean tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  struct sockaddr_in sin ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  boolean tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  sockaddr_storage speer ;
  size_t clen ;
  int onew ;
  pid_t ipid ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  __pid_t tmp___24 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
  {
#line 229
  ulog_device("TCP");
#line 231
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 233
  qsysdep->o = -1;
#line 237
  qsysdep->ipid = getpid();
  }
#line 240
  if (! fwait) {
#line 241
    return (1);
  }
  {
#line 243
  zport = (char const   *)(qconn->qport)->uuconf_u.uuconf_stcp.uuconf_zport;
#line 246
  bzero((pointer )(& shints), sizeof(shints));
#line 247
  tmp = ftcp_set_hints((qconn->qport)->uuconf_u.uuconf_stcp.uuconf_iversion, & shints);
  }
#line 247
  if (! tmp) {
#line 249
    return (0);
  }
  {
#line 250
  shints.ai_socktype = 1;
#line 251
  shints.ai_flags = 1;
#line 252
  ierr = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)zport,
                     (struct addrinfo  const  */* __restrict  */)(& shints), (struct addrinfo **/* __restrict  */)(& qres));
  }
#line 253
  if (ierr == -8) {
    {
#line 253
    tmp___0 = strcmp(zport, "uucp");
    }
#line 253
    if (tmp___0 == 0) {
      {
#line 254
      ierr = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)"540",
                         (struct addrinfo  const  */* __restrict  */)(& shints), (struct addrinfo **/* __restrict  */)(& qres));
      }
    }
  }
#line 260
  if (ierr != 0) {
    {
#line 262
    tmp___1 = gai_strerror(ierr);
#line 262
    ulog((enum tlog )1, "getaddrinfo: %s", tmp___1);
#line 263
    qres = (struct addrinfo *)((void *)0);
#line 264
    quse = (struct addrinfo *)((void *)0);
    }
  } else {
#line 268
    quse = qres;
    {
#line 268
    while (1) {
      while_continue: /* CIL Label */ ;
#line 268
      if (! ((unsigned long )quse != (unsigned long )((void *)0))) {
#line 268
        goto while_break;
      }
      {
#line 270
      qsysdep->o = socket(quse->ai_family, quse->ai_socktype, quse->ai_protocol);
      }
#line 272
      if (qsysdep->o >= 0) {
#line 273
        goto while_break;
      }
#line 268
      quse = quse->ai_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 278
  if (qsysdep->o < 0) {
#line 280
    if ((qconn->qport)->uuconf_u.uuconf_stcp.uuconf_iversion != 0) {
#line 280
      if ((qconn->qport)->uuconf_u.uuconf_stcp.uuconf_iversion != 4) {
        {
#line 284
        ulog((enum tlog )1, "Could not get IPv6 socket");
        }
#line 288
        return (0);
      }
    }
    {
#line 291
    qsysdep->o = socket(2, 1, 0);
    }
#line 292
    if (qsysdep->o < 0) {
      {
#line 294
      tmp___2 = __errno_location();
#line 294
      tmp___3 = strerror(*tmp___2);
#line 294
      ulog((enum tlog )1, "socket: %s", tmp___3);
      }
#line 295
      return (0);
    }
  }
  {
#line 299
  tmp___4 = ftcp_set_flags(qsysdep);
  }
#line 299
  if (! tmp___4) {
#line 300
    return (0);
  }
  {
#line 337
  tmp___5 = geteuid();
#line 337
  fswap = tmp___5 != 0U;
  }
#line 338
  if (fswap) {
    {
#line 340
    tmp___6 = fsuser_perms(& ieuid, & iegid);
    }
#line 340
    if (! tmp___6) {
      {
#line 342
      close(qsysdep->o);
#line 343
      qsysdep->o = -1;
      }
#line 345
      if ((unsigned long )qres != (unsigned long )((void *)0)) {
        {
#line 346
        freeaddrinfo(qres);
        }
      }
#line 348
      return (0);
    }
  }
#line 353
  if ((unsigned long )quse != (unsigned long )((void *)0)) {
    {
#line 355
    tmp___9 = bind(qsysdep->o, (struct sockaddr  const  *)quse->ai_addr, quse->ai_addrlen);
    }
#line 355
    if (tmp___9 < 0) {
#line 357
      if (fswap) {
        {
#line 358
        fsuucp_perms((long )ieuid, (long )iegid);
        }
      }
      {
#line 359
      tmp___7 = __errno_location();
#line 359
      tmp___8 = strerror(*tmp___7);
#line 359
      ulog((enum tlog )2, "bind: %s", tmp___8);
      }
    }
  } else {
    {
#line 367
    bzero((pointer )(& sin), sizeof(sin));
#line 368
    sin.sin_family = (sa_family_t )2;
#line 369
    tmp___10 = itcp_port_number(zport);
#line 369
    sin.sin_port = (in_port_t )tmp___10;
#line 370
    sin.sin_addr.s_addr = htonl((in_addr_t )0);
#line 372
    tmp___13 = bind(qsysdep->o, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                    (socklen_t )sizeof(sin));
    }
#line 372
    if (tmp___13 < 0) {
#line 374
      if (fswap) {
        {
#line 375
        fsuucp_perms((long )ieuid, (long )iegid);
        }
      }
      {
#line 376
      tmp___11 = __errno_location();
#line 376
      tmp___12 = strerror(*tmp___11);
#line 376
      ulog((enum tlog )2, "bind: %s", tmp___12);
      }
    }
  }
#line 381
  if ((unsigned long )qres != (unsigned long )((void *)0)) {
    {
#line 382
    freeaddrinfo(qres);
    }
  }
#line 386
  if (fswap) {
    {
#line 388
    tmp___14 = fsuucp_perms((long )ieuid, (long )iegid);
    }
#line 388
    if (! tmp___14) {
      {
#line 389
      ulog((enum tlog )2, "Could not swap back to UUCP user permissions");
      }
    }
  }
  {
#line 392
  tmp___17 = listen(qsysdep->o, 5);
  }
#line 392
  if (tmp___17 < 0) {
    {
#line 393
    tmp___15 = __errno_location();
#line 393
    tmp___16 = strerror(*tmp___15);
#line 393
    ulog((enum tlog )2, "listen: %s", tmp___16);
    }
  }
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if (afSignal[0]) {
#line 395
      goto while_break___0;
    } else
#line 395
    if (afSignal[1]) {
#line 395
      goto while_break___0;
    } else
#line 395
    if (afSignal[2]) {
#line 395
      goto while_break___0;
    } else
#line 395
    if (afSignal[3]) {
#line 395
      goto while_break___0;
    } else
#line 395
    if (afSignal[4]) {
#line 395
      goto while_break___0;
    }
    {
#line 402
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 402
      if ((iDebug & 32) != 0) {
        {
#line 402
        ulog((enum tlog )3, "ftcp_open: Waiting for connections");
        }
      }
#line 402
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 405
    clen = sizeof(speer);
#line 406
    onew = accept(qsysdep->o, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& speer)),
                  (socklen_t */* __restrict  */)(& clen));
    }
#line 407
    if (onew < 0) {
      {
#line 408
      tmp___18 = __errno_location();
#line 408
      tmp___19 = strerror(*tmp___18);
#line 408
      ulog((enum tlog )2, "accept: %s", tmp___19);
      }
    }
    {
#line 410
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 410
      if ((iDebug & 32) != 0) {
        {
#line 410
        ulog((enum tlog )3, "ftcp_open: Got connection; forking");
        }
      }
#line 410
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 413
    ipid = ixsfork();
    }
#line 414
    if (ipid < 0) {
      {
#line 415
      tmp___20 = __errno_location();
#line 415
      tmp___21 = strerror(*tmp___20);
#line 415
      ulog((enum tlog )2, "fork: %s", tmp___21);
      }
    }
#line 416
    if (ipid == 0) {
      {
#line 418
      close(qsysdep->o);
#line 419
      qsysdep->o = onew;
#line 425
      ipid = ixsfork();
      }
#line 426
      if (ipid < 0) {
        {
#line 428
        tmp___22 = __errno_location();
#line 428
        tmp___23 = strerror(*tmp___22);
#line 428
        ulog((enum tlog )1, "fork: %s", tmp___23);
#line 429
        _exit(1);
        }
      }
#line 432
      if (ipid != 0) {
        {
#line 433
        _exit(0);
        }
      }
      {
#line 435
      tmp___24 = getpid();
#line 435
      ulog_id(tmp___24);
      }
#line 437
      return (1);
    }
    {
#line 440
    close(onew);
#line 443
    ixswait((unsigned long )ipid, (char const   *)((void *)0));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 447
  usysdep_exit(0);
  }
#line 450
  return (0);
}
}
#line 456 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static boolean ftcp_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                          struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                          boolean fsuccess  __attribute__((__unused__)) ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean fret ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 466
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 467
  fret = 1;
#line 468
  if (qsysdep->o >= 0) {
    {
#line 468
    tmp___1 = close(qsysdep->o);
    }
#line 468
    if (tmp___1 < 0) {
      {
#line 470
      tmp = __errno_location();
#line 470
      tmp___0 = strerror(*tmp);
#line 470
      ulog((enum tlog )1, "close: %s", tmp___0);
#line 471
      fret = 0;
      }
    }
  }
  {
#line 473
  qsysdep->o = -1;
#line 480
  tmp___2 = getpid();
  }
#line 480
  if (qsysdep->ipid != tmp___2) {
#line 481
    fret = 0;
  }
#line 483
  return (fret);
}
}
#line 489 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static boolean ftcp_dial(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys ,
                         char const   *zphone , struct uuconf_dialer *qdialer , enum tdialerfound *ptdialer ) 
{ 
  struct ssysdep_conn *qsysdep ;
  char const   *zhost ;
  char const   *zport ;
  char **pzdialer ;
  struct addrinfo shints ;
  struct addrinfo *qres ;
  struct addrinfo *quse ;
  int ierr ;
  boolean tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  struct hostent *qhost ;
  struct sockaddr_in sin ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  boolean tmp___15 ;
  boolean tmp___16 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 509
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 511
  qsysdep->o = -1;
#line 513
  *ptdialer = (enum tdialerfound )0;
#line 515
  zhost = zphone;
#line 516
  if ((unsigned long )zhost == (unsigned long )((void *)0)) {
#line 518
    if ((unsigned long )qsys == (unsigned long )((void *)0)) {
      {
#line 520
      ulog((enum tlog )1, "No address for TCP connection");
      }
#line 521
      return (0);
    }
#line 523
    zhost = (char const   *)qsys->uuconf_zname;
  }
  {
#line 526
  zport = (char const   *)(qconn->qport)->uuconf_u.uuconf_stcp.uuconf_zport;
#line 529
  bzero((pointer )(& shints), sizeof(shints));
#line 530
  tmp = ftcp_set_hints((qconn->qport)->uuconf_u.uuconf_stcp.uuconf_iversion, & shints);
  }
#line 530
  if (! tmp) {
#line 532
    return (0);
  }
  {
#line 533
  shints.ai_socktype = 1;
#line 534
  ierr = getaddrinfo((char const   */* __restrict  */)zhost, (char const   */* __restrict  */)zport,
                     (struct addrinfo  const  */* __restrict  */)(& shints), (struct addrinfo **/* __restrict  */)(& qres));
  }
#line 535
  if (ierr == -8) {
    {
#line 535
    tmp___0 = strcmp(zport, "uucp");
    }
#line 535
    if (tmp___0 == 0) {
      {
#line 536
      ierr = getaddrinfo((char const   */* __restrict  */)zhost, (char const   */* __restrict  */)"540",
                         (struct addrinfo  const  */* __restrict  */)(& shints), (struct addrinfo **/* __restrict  */)(& qres));
      }
    }
  }
#line 542
  if (ierr != 0) {
    {
#line 544
    tmp___1 = gai_strerror(ierr);
#line 544
    ulog((enum tlog )1, "getaddrinfo: %s", tmp___1);
#line 545
    qres = (struct addrinfo *)((void *)0);
#line 546
    quse = (struct addrinfo *)((void *)0);
#line 547
    ierr = 0;
    }
  } else {
#line 551
    ierr = 0;
#line 552
    quse = qres;
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;
#line 552
      if (! ((unsigned long )quse != (unsigned long )((void *)0))) {
#line 552
        goto while_break;
      }
      {
#line 554
      qsysdep->o = socket(quse->ai_family, quse->ai_socktype, quse->ai_protocol);
      }
#line 556
      if (qsysdep->o >= 0) {
        {
#line 558
        tmp___2 = connect(qsysdep->o, (struct sockaddr  const  *)quse->ai_addr, quse->ai_addrlen);
        }
#line 558
        if (tmp___2 >= 0) {
#line 559
          goto while_break;
        }
        {
#line 560
        tmp___3 = __errno_location();
#line 560
        ierr = *tmp___3;
#line 561
        close(qsysdep->o);
#line 562
        qsysdep->o = -1;
        }
      }
#line 552
      quse = quse->ai_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 565
    if ((unsigned long )qres != (unsigned long )((void *)0)) {
      {
#line 566
      freeaddrinfo(qres);
      }
    }
  }
#line 570
  if (qsysdep->o < 0) {
#line 575
    if ((qconn->qport)->uuconf_u.uuconf_stcp.uuconf_iversion != 0) {
#line 575
      if ((qconn->qport)->uuconf_u.uuconf_stcp.uuconf_iversion != 4) {
#line 579
        if (ierr != 0) {
          {
#line 580
          tmp___4 = strerror(ierr);
#line 580
          ulog((enum tlog )1, "connect: %s", tmp___4);
          }
        } else {
          {
#line 582
          ulog((enum tlog )1, "Could not get IPv6 address or socket");
          }
        }
#line 586
        return (0);
      }
    }
    {
#line 589
    qsysdep->o = socket(2, 1, 0);
    }
#line 590
    if (qsysdep->o < 0) {
      {
#line 592
      tmp___5 = __errno_location();
#line 592
      tmp___6 = strerror(*tmp___5);
#line 592
      ulog((enum tlog )1, "socket: %s", tmp___6);
      }
#line 593
      return (0);
    }
    {
#line 596
    tmp___7 = __errno_location();
#line 596
    *tmp___7 = 0;
#line 597
    bzero((pointer )(& sin), sizeof(sin));
#line 598
    qhost = gethostbyname((char const   *)((char *)zhost));
    }
#line 599
    if ((unsigned long )qhost != (unsigned long )((void *)0)) {
      {
#line 601
      sin.sin_family = (sa_family_t )qhost->h_addrtype;
#line 602
      memcpy((void */* __restrict  */)(& sin.sin_addr.s_addr), (void const   */* __restrict  */)*(qhost->h_addr_list + 0),
             (size_t )qhost->h_length);
      }
    } else {
      {
#line 607
      tmp___10 = __errno_location();
      }
#line 607
      if (*tmp___10 != 0) {
        {
#line 609
        tmp___8 = __errno_location();
#line 609
        tmp___9 = strerror(*tmp___8);
#line 609
        ulog((enum tlog )1, "gethostbyname (%s): %s", zhost, tmp___9);
        }
#line 611
        return (0);
      }
      {
#line 614
      sin.sin_family = (sa_family_t )2;
#line 615
      sin.sin_addr.s_addr = inet_addr((char const   *)((char *)zhost));
      }
#line 616
      if ((long )sin.sin_addr.s_addr == -1L) {
        {
#line 618
        ulog((enum tlog )1, "%s: unknown host name", zhost);
        }
#line 619
        return (0);
      }
    }
    {
#line 623
    tmp___11 = itcp_port_number(zport);
#line 623
    sin.sin_port = (in_port_t )tmp___11;
#line 625
    tmp___14 = connect(qsysdep->o, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                       (socklen_t )sizeof(sin));
    }
#line 625
    if (tmp___14 < 0) {
      {
#line 627
      tmp___12 = __errno_location();
#line 627
      tmp___13 = strerror(*tmp___12);
#line 627
      ulog((enum tlog )1, "connect: %s", tmp___13);
#line 628
      close(qsysdep->o);
#line 629
      qsysdep->o = -1;
      }
#line 630
      return (0);
    }
  }
  {
#line 634
  tmp___15 = ftcp_set_flags(qsysdep);
  }
#line 634
  if (! tmp___15) {
#line 635
    return (0);
  }
#line 638
  pzdialer = (qconn->qport)->uuconf_u.uuconf_stcp.uuconf_pzdialer;
#line 639
  if ((unsigned long )pzdialer != (unsigned long )((void *)0)) {
#line 639
    if ((unsigned long )*pzdialer != (unsigned long )((void *)0)) {
      {
#line 641
      tmp___16 = fconn_dial_sequence(qconn, puuconf, pzdialer, qsys, zphone, qdialer,
                                     ptdialer);
      }
#line 641
      if (! tmp___16) {
#line 643
        return (0);
      }
    }
  }
#line 646
  return (1);
}
}
#line 658 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static int iuucp  ;
#line 653 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/tcp.c"
static int itcp_port_number(char const   *zname ) 
{ 
  boolean fuucp ;
  int i ;
  char *zend ;
  struct servent *q ;
  int tmp ;
  long tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 663
  tmp = strcmp(zname, "uucp");
#line 663
  fuucp = tmp == 0;
  }
#line 664
  if (fuucp) {
#line 664
    if (iuucp != 0) {
#line 665
      return (iuucp);
    }
  }
  {
#line 668
  tmp___0 = strtol((char const   */* __restrict  */)((char *)zname), (char **/* __restrict  */)(& zend),
                   10);
#line 668
  i = (int )tmp___0;
  }
#line 669
  if (i != 0) {
#line 669
    if ((int )*zend == 0) {
      {
#line 670
      tmp___1 = htons((uint16_t )i);
      }
#line 670
      return ((int )tmp___1);
    }
  }
  {
#line 672
  q = getservbyname((char const   *)((char *)zname), (char const   *)((char *)"tcp"));
  }
#line 673
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 677
    if (fuucp) {
      {
#line 679
      tmp___2 = htons((uint16_t )540);
#line 679
      iuucp = (int )tmp___2;
      }
#line 680
      return (iuucp);
    }
    {
#line 682
    tmp___3 = __errno_location();
#line 682
    tmp___4 = strerror(*tmp___3);
#line 682
    ulog((enum tlog )1, "getservbyname (%s): %s", zname, tmp___4);
    }
#line 683
    return (-1);
  }
#line 686
  if (fuucp) {
#line 687
    iuucp = q->s_port;
  }
#line 689
  return (q->s_port);
}
}
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 476 "../system.h"
boolean fsysdep_sync(openfile_t e , char const   *zmsg ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/sync.c"
boolean fsysdep_sync(openfile_t e , char const   *zmsg ) 
{ 
  int o ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 20
  tmp___1 = fflush(e);
  }
#line 20
  if (tmp___1 == -1) {
    {
#line 22
    tmp = __errno_location();
#line 22
    tmp___0 = strerror(*tmp);
#line 22
    ulog((enum tlog )1, "%s: fflush: %s", zmsg, tmp___0);
    }
#line 23
    return (0);
  }
  {
#line 28
  o = fileno(e);
  }
#line 41
  return (1);
}
}
#line 276 "../system.h"
boolean fsysdep_get_status(struct uuconf_system  const  *qsys , struct sstatus *qret ,
                           boolean *pfnone ) ;
#line 282
boolean fsysdep_set_status(struct uuconf_system  const  *qsys , struct sstatus  const  *qset ) ;
#line 394
FILE *esysdep_fopen(char const   *zfile , boolean fpublic , boolean fappend , boolean fmkdirs ) ;
#line 57 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/status.c"
boolean fsysdep_get_status(struct uuconf_system  const  *qsys , struct sstatus *qret ,
                           boolean *pfnone ) 
{ 
  char *zname ;
  FILE *e ;
  char *zline ;
  char *zend ;
  char *znext ;
  boolean fbad ;
  int istat ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  size_t cline ;
  __ssize_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned short const   **tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 70
  if ((unsigned long )pfnone != (unsigned long )((void *)0)) {
#line 71
    *pfnone = 0;
  }
  {
#line 73
  zname = zsysdep_in_dir(".Status", (char const   *)qsys->uuconf_zname);
#line 74
  e = fopen((char const   */* __restrict  */)zname, (char const   */* __restrict  */)"r");
  }
#line 75
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 77
    tmp___1 = __errno_location();
    }
#line 77
    if (*tmp___1 != 2) {
      {
#line 79
      tmp = __errno_location();
#line 79
      tmp___0 = strerror(*tmp);
#line 79
      ulog((enum tlog )1, "fopen (%s): %s", zname, tmp___0);
#line 80
      ubuffree(zname);
      }
#line 81
      return (0);
    }
#line 83
    zline = (char *)((void *)0);
  } else {
    {
#line 89
    zline = (char *)((void *)0);
#line 90
    cline = (size_t )0;
#line 91
    tmp___2 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                      (FILE */* __restrict  */)e);
    }
#line 91
    if (tmp___2 <= 0L) {
      {
#line 93
      xfree((pointer )zline);
#line 94
      zline = (char *)((void *)0);
      }
    }
    {
#line 96
    fclose(e);
    }
  }
#line 99
  if ((unsigned long )zline == (unsigned long )((void *)0)) {
#line 103
    qret->ttype = (enum tstatus_type )0;
#line 104
    qret->cretries = 0;
#line 105
    qret->ilast = 0L;
#line 106
    qret->cwait = 0;
#line 107
    qret->zstring = (char *)((void *)0);
#line 108
    if ((unsigned long )pfnone != (unsigned long )((void *)0)) {
#line 109
      *pfnone = 1;
    }
    {
#line 110
    ubuffree(zname);
    }
#line 111
    return (1);
  }
  {
#line 123
  fbad = 0;
#line 124
  tmp___3 = strtol((char const   */* __restrict  */)zline, (char **/* __restrict  */)(& zend),
                   10);
#line 124
  istat = (int )tmp___3;
  }
#line 125
  if ((unsigned long )zend == (unsigned long )zline) {
#line 126
    fbad = 1;
  }
#line 145
  if (istat < 0) {
#line 146
    istat = 0;
  } else
#line 145
  if (istat >= 8) {
#line 146
    istat = 0;
  }
  {
#line 147
  qret->ttype = (enum tstatus_type )istat;
#line 148
  znext = zend;
#line 149
  tmp___4 = strtol((char const   */* __restrict  */)znext, (char **/* __restrict  */)(& zend),
                   10);
#line 149
  qret->cretries = (int )tmp___4;
  }
#line 150
  if ((unsigned long )zend == (unsigned long )znext) {
#line 151
    fbad = 1;
  }
  {
#line 152
  znext = zend;
#line 153
  qret->ilast = strtol((char const   */* __restrict  */)znext, (char **/* __restrict  */)(& zend),
                       10);
  }
#line 154
  if ((unsigned long )zend == (unsigned long )znext) {
#line 155
    fbad = 1;
  }
  {
#line 156
  znext = zend;
#line 157
  tmp___5 = strtol((char const   */* __restrict  */)znext, (char **/* __restrict  */)(& zend),
                   10);
#line 157
  qret->cwait = (int )tmp___5;
  }
#line 158
  if ((unsigned long )zend == (unsigned long )znext) {
#line 159
    fbad = 1;
  }
#line 161
  if (! fbad) {
#line 163
    znext = zend;
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 164
      tmp___6 = __ctype_b_loc();
      }
#line 164
      if (! ((int const   )*(*tmp___6 + (int )((unsigned char )*znext)) & 8192)) {
#line 164
        goto while_break;
      }
#line 165
      znext ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 166
    if ((int )*znext == 0) {
#line 167
      qret->zstring = (char *)((void *)0);
    } else {
#line 170
      if ((int )*znext == 34) {
#line 171
        znext ++;
      }
      {
#line 172
      qret->zstring = zbufcpy((char const   *)znext);
#line 173
      tmp___7 = strlen((char const   *)qret->zstring);
#line 173
      zend = qret->zstring + tmp___7;
      }
      {
#line 174
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 174
        if ((unsigned long )zend != (unsigned long )qret->zstring) {
#line 174
          if (! ((int )*zend != 32)) {
#line 174
            goto while_break___0;
          }
        } else {
#line 174
          goto while_break___0;
        }
#line 175
        zend --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 176
      if ((unsigned long )zend != (unsigned long )qret->zstring) {
#line 176
        if ((int )*(zend + -1) == 34) {
#line 177
          zend --;
        }
      }
#line 178
      if ((unsigned long )zend != (unsigned long )qret->zstring) {
#line 179
        *zend = (char )'\000';
      } else {
        {
#line 182
        ubuffree(qret->zstring);
#line 183
        qret->zstring = (char *)((void *)0);
        }
      }
    }
  }
  {
#line 188
  xfree((pointer )zline);
  }
#line 190
  if (fbad) {
    {
#line 192
    ulog((enum tlog )1, "%s: Bad status file format", zname);
#line 193
    ubuffree(zname);
    }
#line 194
    return (0);
  }
  {
#line 197
  ubuffree(zname);
  }
#line 199
  return (1);
}
}
#line 206 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/status.c"
boolean fsysdep_set_status(struct uuconf_system  const  *qsys , struct sstatus  const  *qset ) 
{ 
  char *zname ;
  FILE *e ;
  int istat ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 215
  zname = zsysdep_in_dir(".Status", (char const   *)qsys->uuconf_zname);
#line 217
  e = esysdep_fopen((char const   *)zname, 1, 0, 1);
#line 218
  ubuffree(zname);
  }
#line 219
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 220
    return (0);
  }
  {
#line 221
  istat = (int )qset->ttype;
#line 230
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"%d %d %ld %d ",
          istat, qset->cretries, qset->ilast, qset->cwait);
#line 236
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"%s", azStatus[(int )qset->ttype]);
#line 239
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" %s\n", qsys->uuconf_zname);
#line 240
  tmp___1 = fclose(e);
  }
#line 240
  if (tmp___1 != 0) {
    {
#line 242
    tmp = __errno_location();
#line 242
    tmp___0 = strerror(*tmp);
#line 242
    ulog((enum tlog )1, "fclose: %s", tmp___0);
    }
#line 243
    return (0);
  }
#line 246
  return (1);
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
char const   statsb_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'t',      (char const   )'s',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'0', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 230 "../uudefs.h"
boolean funknown_system(pointer puuconf , char const   *zsystem , struct uuconf_system *qsys ) ;
#line 310
void ulog_uuconf(enum tlog ttype , pointer puuconf , int iuuconf ) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 458 "../sysdep.h"
char *zsfind_file(char const   *zsimple , char const   *zsystem , int bgrade  __attribute__((__unused__)) ) ;
#line 505
char *zsjobid_to_file(char const   *zid , char **pzsystem , char *pbgrade ) ;
#line 557
char const   *zSlockdir ;
#line 109 "../system.h"
char const   *zsysdep_login_name(void) ;
#line 800
boolean fsysdep_privileged(void) ;
#line 805
boolean fsysdep_kill_job(pointer puuconf , char const   *zid ) ;
#line 813
boolean fsysdep_rejuvenate_job(pointer puuconf , char const   *zid ) ;
#line 819
long ixsysdep_work_time(struct uuconf_system  const  *qsys , pointer pseq ) ;
#line 825
long ixsysdep_file_time(char const   *zfile ) ;
#line 830
boolean fsysdep_touch_file(char const   *zfile ) ;
#line 848
boolean fsysdep_all_status_init(pointer *phold ) ;
#line 854
char *zsysdep_all_status(pointer phold , boolean *pferr , struct sstatus *qstat ) ;
#line 860
void usysdep_all_status_free(pointer phold ) ;
#line 864
boolean fsysdep_lock_status(void) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 46 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utime)(char const   *__file ,
                                                                                  struct utimbuf  const  *__file_times ) ;
#line 75 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
static int issettime(char const   *z , time_t inow ) ;
#line 76
static boolean fskill_or_rejuv(pointer puuconf , char const   *zid , boolean fkill ) ;
#line 83 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
static int issettime(char const   *z , time_t inow ) 
{ 
  struct utimbuf s ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 91
  s.actime = inow;
#line 92
  s.modtime = inow;
#line 93
  tmp = utime((char const   *)((char *)z), (struct utimbuf  const  *)(& s));
  }
#line 93
  return (tmp);
}
}
#line 105 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
boolean fsysdep_kill_job(pointer puuconf , char const   *zid ) 
{ 
  boolean tmp ;

  {
  {
#line 110
  tmp = fskill_or_rejuv(puuconf, zid, 1);
  }
#line 110
  return (tmp);
}
}
#line 115 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
boolean fsysdep_rejuvenate_job(pointer puuconf , char const   *zid ) 
{ 
  boolean tmp ;

  {
  {
#line 120
  tmp = fskill_or_rejuv(puuconf, zid, 0);
  }
#line 120
  return (tmp);
}
}
#line 125 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
static boolean fskill_or_rejuv(pointer puuconf , char const   *zid , boolean fkill ) 
{ 
  char *zfile ;
  char *zsys ;
  char bgrade ;
  time_t inow ;
  int iuuconf ;
  struct uuconf_system ssys ;
  FILE *e ;
  boolean fret ;
  char *zline ;
  size_t cline ;
  int isys ;
  boolean tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  struct scmd s ;
  boolean tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  boolean tmp___6 ;
  char *ztemp ;
  int *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  __ssize_t tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  int *tmp___15 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 134
  inow = (time_t )0;
#line 143
  zfile = zsjobid_to_file(zid, & zsys, & bgrade);
  }
#line 144
  if ((unsigned long )zfile == (unsigned long )((void *)0)) {
#line 145
    return (0);
  }
#line 147
  if (! fkill) {
    {
#line 148
    inow = time((time_t *)((void *)0));
    }
  }
  {
#line 150
  iuuconf = uuconf_system_info(puuconf, (char const   *)zsys, & ssys);
  }
#line 151
  if (iuuconf == 1) {
    {
#line 153
    tmp = funknown_system(puuconf, (char const   *)zsys, & ssys);
    }
#line 153
    if (! tmp) {
      {
#line 155
      ulog((enum tlog )1, "%s: Bad job id", zid);
#line 156
      ubuffree(zfile);
#line 157
      ubuffree(zsys);
      }
#line 158
      return (0);
    }
  } else
#line 161
  if (iuuconf != 0) {
    {
#line 163
    ulog_uuconf((enum tlog )1, puuconf, iuuconf);
#line 164
    ubuffree(zfile);
#line 165
    ubuffree(zsys);
    }
#line 166
    return (0);
  }
  {
#line 169
  e = fopen((char const   */* __restrict  */)zfile, (char const   */* __restrict  */)"r");
  }
#line 170
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 172
    tmp___2 = __errno_location();
    }
#line 172
    if (*tmp___2 == 2) {
      {
#line 173
      ulog((enum tlog )1, "%s: Job not found", zid);
      }
    } else {
      {
#line 175
      tmp___0 = __errno_location();
#line 175
      tmp___1 = strerror(*tmp___0);
#line 175
      ulog((enum tlog )1, "fopen (%s): %s", zfile, tmp___1);
      }
    }
    {
#line 176
    uuconf_system_free(puuconf, & ssys);
#line 177
    ubuffree(zfile);
#line 178
    ubuffree(zsys);
    }
#line 179
    return (0);
  }
#line 184
  fret = 1;
#line 185
  zline = (char *)((void *)0);
#line 186
  cline = (size_t )0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    tmp___11 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                       (FILE */* __restrict  */)e);
    }
#line 187
    if (! (tmp___11 > 0L)) {
#line 187
      goto while_break;
    }
    {
#line 191
    tmp___3 = fparse_cmd(zline, & s);
    }
#line 191
    if (! tmp___3) {
      {
#line 193
      ulog((enum tlog )1, "Bad line in command file %s", zfile);
#line 194
      fret = 0;
      }
#line 195
      goto while_continue;
    }
    {
#line 200
    tmp___4 = zsysdep_login_name();
#line 200
    tmp___5 = strcmp(s.zuser, tmp___4);
    }
#line 200
    if (tmp___5 != 0) {
      {
#line 200
      tmp___6 = fsysdep_privileged();
      }
#line 200
      if (! tmp___6) {
        {
#line 203
        ulog((enum tlog )1, "%s: Not submitted by you", zid);
#line 204
        xfree((pointer )zline);
#line 205
        fclose(e);
#line 206
        uuconf_system_free(puuconf, & ssys);
#line 207
        ubuffree(zfile);
#line 208
        ubuffree(zsys);
        }
#line 209
        return (0);
      }
    }
#line 212
    if ((int )s.bcmd == 83) {
#line 212
      goto _L;
    } else
#line 212
    if ((int )s.bcmd == 69) {
      _L: /* CIL Label */ 
      {
#line 216
      ztemp = zsfind_file(s.ztemp, (char const   *)ssys.uuconf_zname, (int )bgrade);
      }
#line 217
      if ((unsigned long )ztemp == (unsigned long )((void *)0)) {
#line 218
        fret = 0;
      } else {
#line 221
        if (fkill) {
          {
#line 222
          isys = remove((char const   *)ztemp);
          }
        } else {
          {
#line 224
          isys = issettime((char const   *)ztemp, inow);
          }
        }
#line 226
        if (isys != 0) {
          {
#line 226
          tmp___10 = __errno_location();
          }
#line 226
          if (*tmp___10 != 2) {
            {
#line 228
            tmp___7 = __errno_location();
#line 228
            tmp___8 = strerror(*tmp___7);
            }
#line 228
            if (fkill) {
#line 228
              tmp___9 = "remove";
            } else {
#line 228
              tmp___9 = "utime";
            }
            {
#line 228
            ulog((enum tlog )1, "%s (%s): %s", tmp___9, ztemp, tmp___8);
#line 231
            fret = 0;
            }
          }
        }
        {
#line 234
        ubuffree(ztemp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  xfree((pointer )zline);
#line 240
  fclose(e);
#line 241
  uuconf_system_free(puuconf, & ssys);
#line 242
  ubuffree(zsys);
  }
#line 244
  if (fkill) {
    {
#line 245
    isys = remove((char const   *)zfile);
    }
  } else {
    {
#line 247
    isys = issettime((char const   *)zfile, inow);
    }
  }
#line 249
  if (isys != 0) {
    {
#line 249
    tmp___15 = __errno_location();
    }
#line 249
    if (*tmp___15 != 2) {
      {
#line 251
      tmp___12 = __errno_location();
#line 251
      tmp___13 = strerror(*tmp___12);
      }
#line 251
      if (fkill) {
#line 251
        tmp___14 = "remove";
      } else {
#line 251
        tmp___14 = "utime";
      }
      {
#line 251
      ulog((enum tlog )1, "%s (%s): %s", tmp___14, zfile, tmp___13);
#line 253
      fret = 0;
      }
    }
  }
  {
#line 256
  ubuffree(zfile);
  }
#line 258
  return (fret);
}
}
#line 263 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
long ixsysdep_work_time(struct uuconf_system  const  *qsys , pointer pseq ) 
{ 
  char *zjobid ;
  char *zfile ;
  long iret ;

  {
  {
#line 271
  zjobid = zsysdep_jobid(qsys, pseq);
#line 272
  zfile = zsjobid_to_file((char const   *)zjobid, (char **)((void *)0), (char *)((void *)0));
  }
#line 273
  if ((unsigned long )zfile == (unsigned long )((void *)0)) {
#line 274
    return (0L);
  }
  {
#line 275
  ubuffree(zjobid);
#line 276
  iret = ixsysdep_file_time((char const   *)zfile);
#line 277
  ubuffree(zfile);
  }
#line 278
  return (iret);
}
}
#line 284 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
long ixsysdep_file_time(char const   *zfile ) 
{ 
  struct stat s ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 290
  tmp___3 = stat((char const   */* __restrict  */)((char *)zfile), (struct stat */* __restrict  */)(& s));
  }
#line 290
  if (tmp___3 < 0) {
    {
#line 292
    tmp___1 = __errno_location();
    }
#line 292
    if (*tmp___1 != 2) {
      {
#line 293
      tmp = __errno_location();
#line 293
      tmp___0 = strerror(*tmp);
#line 293
      ulog((enum tlog )1, "stat (%s): %s", zfile, tmp___0);
      }
    }
    {
#line 294
    tmp___2 = ixsysdep_time((long *)((void *)0));
    }
#line 294
    return (tmp___2);
  }
#line 297
  return (s.st_mtim.tv_sec);
}
}
#line 302 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
boolean fsysdep_touch_file(char const   *zfile ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 306
  tmp___1 = time((time_t *)((void *)0));
#line 306
  tmp___2 = issettime(zfile, tmp___1);
  }
#line 306
  if (tmp___2 != 0) {
    {
#line 308
    tmp = __errno_location();
#line 308
    tmp___0 = strerror(*tmp);
#line 308
    ulog((enum tlog )1, "utime (%s): %s", zfile, tmp___0);
    }
#line 309
    return (0);
  }
#line 312
  return (1);
}
}
#line 317 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
boolean fsysdep_all_status_init(pointer *phold ) 
{ 
  DIR *qdir ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 323
  qdir = opendir((char const   *)((char *)".Status"));
  }
#line 324
  if ((unsigned long )qdir == (unsigned long )((void *)0)) {
    {
#line 326
    tmp = __errno_location();
#line 326
    tmp___0 = strerror(*tmp);
#line 326
    ulog((enum tlog )1, "opendir (.Status): %s", tmp___0);
    }
#line 327
    return (0);
  }
#line 330
  *phold = (pointer )qdir;
#line 331
  return (1);
}
}
#line 336 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
char *zsysdep_all_status(pointer phold , boolean *pferr , struct sstatus *qstat ) 
{ 
  DIR *qdir ;
  struct dirent *qentry ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  struct uuconf_system ssys ;
  char *tmp___3 ;
  boolean tmp___4 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 342
  qdir = (DIR *)phold;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp = __errno_location();
#line 347
    *tmp = 0;
#line 348
    qentry = readdir(qdir);
    }
#line 349
    if ((unsigned long )qentry == (unsigned long )((void *)0)) {
      {
#line 351
      tmp___2 = __errno_location();
      }
#line 351
      if (*tmp___2 == 0) {
#line 352
        *pferr = 0;
      } else {
        {
#line 355
        tmp___0 = __errno_location();
#line 355
        tmp___1 = strerror(*tmp___0);
#line 355
        ulog((enum tlog )1, "readdir: %s", tmp___1);
#line 356
        *pferr = 1;
        }
      }
#line 358
      return ((char *)((void *)0));
    }
#line 361
    if ((int )qentry->d_name[0] != 46) {
      {
#line 369
      ssys.uuconf_zname = qentry->d_name;
#line 370
      tmp___4 = fsysdep_get_status((struct uuconf_system  const  *)(& ssys), qstat,
                                   (boolean *)((void *)0));
      }
#line 370
      if (tmp___4) {
        {
#line 371
        tmp___3 = zbufcpy((char const   *)(qentry->d_name));
        }
#line 371
        return (tmp___3);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 382 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
void usysdep_all_status_free(pointer phold ) 
{ 
  DIR *qdir ;

  {
  {
#line 386
  qdir = (DIR *)phold;
#line 388
  closedir(qdir);
  }
#line 389
  return;
}
}
#line 394 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/statsb.c"
boolean fsysdep_lock_status(void) 
{ 
  DIR *qdir ;
  struct dirent *qentry ;
  int calc ;
  pid_t *pai ;
  int cgot ;
  int aidescs[3] ;
  char *zcopy ;
  char *ztok ;
  int cargs ;
  int iarg ;
  char **pazargs ;
  int *tmp ;
  char *tmp___0 ;
  char *zname ;
  int o ;
  char ab___0[12] ;
  int cread ;
  int ierr ;
  pid_t ipid ;
  int icheck ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  long tmp___8 ;
  pointer tmp___9 ;
  pointer tmp___10 ;
  int i ;
  char *zlast ;
  char *zset ;
  size_t tmp___11 ;
  pid_t ipid___0 ;
  int *tmp___12 ;
  char *tmp___13 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 410
  qdir = opendir((char const   *)((char *)zSlockdir));
  }
#line 411
  if ((unsigned long )qdir == (unsigned long )((void *)0)) {
    {
#line 413
    tmp = __errno_location();
#line 413
    tmp___0 = strerror(*tmp);
#line 413
    ulog((enum tlog )1, "opendir (%s): %s", zSlockdir, tmp___0);
    }
#line 414
    return (0);
  }
#line 421
  calc = 0;
#line 422
  pai = (pid_t *)((void *)0);
#line 423
  cgot = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 427
    qentry = readdir(qdir);
    }
#line 427
    if (! ((unsigned long )qentry != (unsigned long )((void *)0))) {
#line 427
      goto while_break;
    }
    {
#line 447
    tmp___1 = strncmp((char const   *)(qentry->d_name), "LCK..", sizeof("LCK..") - 1UL);
    }
#line 447
    if (tmp___1 != 0) {
#line 448
      goto while_continue;
    }
    {
#line 450
    zname = zsysdep_in_dir(zSlockdir, (char const   *)(qentry->d_name));
#line 451
    o = open((char const   *)zname, 256, 0);
    }
#line 452
    if (o < 0) {
      {
#line 454
      tmp___4 = __errno_location();
      }
#line 454
      if (*tmp___4 != 2) {
        {
#line 455
        tmp___2 = __errno_location();
#line 455
        tmp___3 = strerror(*tmp___2);
#line 455
        ulog((enum tlog )1, "open (%s): %s", zname, tmp___3);
        }
      }
      {
#line 456
      ubuffree(zname);
      }
#line 457
      goto while_continue;
    }
    {
#line 463
    tmp___5 = read(o, (void *)(ab___0), sizeof(ab___0) - 1UL);
#line 463
    cread = (int )tmp___5;
#line 466
    tmp___6 = __errno_location();
#line 466
    ierr = *tmp___6;
#line 467
    close(o);
    }
#line 469
    if (cread < 0) {
      {
#line 471
      tmp___7 = strerror(ierr);
#line 471
      ulog((enum tlog )1, "read %s: %s", zname, tmp___7);
#line 472
      ubuffree(zname);
      }
#line 473
      goto while_continue;
    }
    {
#line 476
    ubuffree(zname);
#line 486
    ab___0[cread] = (char )'\000';
#line 487
    tmp___8 = strtol((char const   */* __restrict  */)(ab___0), (char **/* __restrict  */)((char **)((void *)0)),
                     10);
#line 487
    ipid = (pid_t )tmp___8;
#line 494
    printf((char const   */* __restrict  */)"%s: %ld\n", qentry->d_name, (long )ipid);
#line 497
    icheck = 0;
    }
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      if (! (icheck < cgot)) {
#line 497
        goto while_break___0;
      }
#line 498
      if (*(pai + icheck) == ipid) {
#line 499
        goto while_break___0;
      }
#line 497
      icheck ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 500
    if (icheck < cgot) {
#line 501
      goto while_continue;
    }
#line 503
    if (cgot >= calc) {
      {
#line 505
      calc += 10;
#line 506
      tmp___9 = xrealloc((pointer )pai, (unsigned long )calc * sizeof(pid_t ));
#line 506
      pai = (pid_t *)tmp___9;
      }
    }
#line 513
    *(pai + cgot) = ipid;
#line 517
    cgot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  if (cgot == 0) {
#line 521
    return (1);
  }
  {
#line 523
  aidescs[0] = -1;
#line 524
  aidescs[1] = 1;
#line 525
  aidescs[2] = 2;
#line 528
  zcopy = zbufcpy("/bin/ps -lp");
#line 530
  cargs = 0;
#line 531
  ztok = strtok((char */* __restrict  */)zcopy, (char const   */* __restrict  */)" \t");
  }
  {
#line 531
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 531
    if (! ((unsigned long )ztok != (unsigned long )((void *)0))) {
#line 531
      goto while_break___1;
    }
    {
#line 534
    cargs ++;
#line 531
    ztok = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t");
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 536
  tmp___10 = xmalloc((unsigned long )(cargs + 1) * sizeof(char *));
#line 536
  pazargs = (char **)tmp___10;
#line 538
  memcpy((void */* __restrict  */)zcopy, (void const   */* __restrict  */)"/bin/ps -lp",
         sizeof("/bin/ps -lp"));
#line 539
  ztok = strtok((char */* __restrict  */)zcopy, (char const   */* __restrict  */)" \t");
#line 539
  iarg = 0;
  }
  {
#line 539
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 539
    if (! ((unsigned long )ztok != (unsigned long )((void *)0))) {
#line 539
      goto while_break___2;
    }
    {
#line 542
    *(pazargs + iarg) = ztok;
#line 539
    ztok = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t");
#line 539
    iarg ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 543
  *(pazargs + iarg) = (char *)((void *)0);
#line 554
  zlast = *(pazargs + (cargs - 1));
#line 555
  tmp___11 = strlen((char const   *)zlast);
#line 555
  zset = zbufalc(tmp___11 + 20UL);
#line 572
  i = 0;
  }
  {
#line 572
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 572
    if (! (i < cgot)) {
#line 572
      goto while_break___3;
    }
    {
#line 576
    sprintf((char */* __restrict  */)zset, (char const   */* __restrict  */)"%s%ld",
            zlast, (long )*(pai + i));
#line 577
    *(pazargs + (cargs - 1)) = zset;
#line 584
    ipid___0 = ixsspawn((char const   **)pazargs, aidescs, 0, 0, (char const   *)((void *)0),
                        0, 1, (char const   *)((void *)0), (char const   *)((void *)0),
                        (char const   *)((void *)0));
    }
#line 588
    if (ipid___0 < 0) {
      {
#line 589
      tmp___12 = __errno_location();
#line 589
      tmp___13 = strerror(*tmp___12);
#line 589
      ulog((enum tlog )1, "ixsspawn: %s", tmp___13);
      }
    } else {
      {
#line 591
      ixswait((unsigned long )ipid___0, "/bin/ps -lp");
      }
    }
#line 572
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 593
  ubuffree(zset);
#line 629
  ubuffree(zcopy);
#line 630
  xfree((pointer )pazargs);
  }
#line 632
  return (1);
}
}
#line 851 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 37 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/srmdir.c"
static int isremove_dir(char const   *zfile , struct stat  const  *qstat  __attribute__((__unused__)) ,
                        int iflag ) ;
#line 47 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/srmdir.c"
static struct sdirlist *qSdirlist  ;
#line 51 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/srmdir.c"
boolean fsysdep_rmdir(char const   *zdir ) 
{ 
  boolean fret ;
  struct sdirlist *q ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sdirlist *qnext ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 58
  qSdirlist = (struct sdirlist *)((void *)0);
#line 60
  fret = 1;
#line 61
  tmp___1 = ftw((char const   *)((char *)zdir), & isremove_dir, 5);
  }
#line 61
  if (tmp___1 != 0) {
    {
#line 63
    tmp = __errno_location();
#line 63
    tmp___0 = strerror(*tmp);
#line 63
    ulog((enum tlog )1, "ftw: %s", tmp___0);
#line 64
    fret = 0;
    }
  }
#line 67
  q = qSdirlist;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
    {
#line 72
    tmp___4 = rmdir((char const   *)q->zdir);
    }
#line 72
    if (tmp___4 != 0) {
      {
#line 74
      tmp___2 = __errno_location();
#line 74
      tmp___3 = strerror(*tmp___2);
#line 74
      ulog((enum tlog )1, "rmdir (%s): %s", q->zdir, tmp___3);
#line 75
      fret = 0;
      }
    }
    {
#line 77
    ubuffree(q->zdir);
#line 78
    qnext = q->qnext;
#line 79
    xfree((pointer )q);
#line 80
    q = qnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (fret);
}
}
#line 89 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/srmdir.c"
static int isremove_dir(char const   *zfile , struct stat  const  *qstat  __attribute__((__unused__)) ,
                        int iflag ) 
{ 
  struct sdirlist *q ;
  pointer tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 95
  if (iflag == 1) {
    {
#line 99
    tmp = xmalloc(sizeof(struct sdirlist ));
#line 99
    q = (struct sdirlist *)tmp;
#line 100
    q->qnext = qSdirlist;
#line 101
    q->zdir = zbufcpy(zfile);
#line 102
    qSdirlist = q;
    }
  } else
#line 95
  if (iflag == 2) {
    {
#line 99
    tmp = xmalloc(sizeof(struct sdirlist ));
#line 99
    q = (struct sdirlist *)tmp;
#line 100
    q->qnext = qSdirlist;
#line 101
    q->zdir = zbufcpy(zfile);
#line 102
    qSdirlist = q;
    }
  } else {
    {
#line 106
    tmp___2 = remove(zfile);
    }
#line 106
    if (tmp___2 != 0) {
      {
#line 107
      tmp___0 = __errno_location();
#line 107
      tmp___1 = strerror(*tmp___0);
#line 107
      ulog((enum tlog )1, "remove (%s): %s", zfile, tmp___1);
      }
    }
  }
#line 110
  return (0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/spool.c"
char const   spool_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/spool.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'1',      (char const   )'4',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 485 "../sysdep.h"
char *zsappend3(char const   *zdir1 , char const   *zdir2 , char const   *zfile ) ;
#line 192 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/spool.c"
char *zsfind_file(char const   *zsimple , char const   *zsystem , int bgrade  __attribute__((__unused__)) ) 
{ 
  boolean tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 200
  if ((int const   )*(zsimple + 0) != 84) {
#line 200
    goto _L;
  } else
#line 200
  if ((int const   )*(zsimple + 1) != 77) {
#line 200
    goto _L;
  } else
#line 200
  if ((int const   )*(zsimple + 2) != 80) {
    _L: /* CIL Label */ 
    {
#line 200
    tmp = fspool_file(zsimple);
    }
#line 200
    if (! tmp) {
      {
#line 205
      ulog((enum tlog )1, "Unrecognized file name %s", zsimple);
      }
#line 206
      return ((char *)((void *)0));
    }
  }
  {
#line 272
  if ((int const   )*zsimple == 84) {
#line 272
    goto case_84;
  }
#line 272
  if ((int const   )*zsimple == 67) {
#line 272
    goto case_84;
  }
#line 286
  if ((int const   )*zsimple == 68) {
#line 286
    goto case_68;
  }
#line 403
  if ((int const   )*zsimple == 88) {
#line 403
    goto case_88;
  }
#line 269
  goto switch_break;
  case_84: /* CIL Label */ 
  case_67: /* CIL Label */ 
  {
#line 283
  tmp___0 = zsappend3(zsystem, "C.", zsimple);
  }
#line 283
  return (tmp___0);
  case_68: /* CIL Label */ 
#line 396
  if ((int const   )*(zsimple + 2) == 88) {
    {
#line 397
    tmp___1 = zsappend3(zsystem, "D.X", zsimple);
    }
#line 397
    return (tmp___1);
  } else {
    {
#line 399
    tmp___2 = zsappend3(zsystem, "D.", zsimple);
    }
#line 399
    return (tmp___2);
  }
  case_88: /* CIL Label */ 
  {
#line 419
  tmp___3 = zsappend3(zsystem, "X.", zsimple);
  }
#line 419
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
#line 424
  return ((char *)((void *)0));
}
}
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/splnam.c"
char *zsysdep_spool_file_name(struct uuconf_system  const  *qsys , char const   *zfile ,
                              pointer pseq ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 18
  tmp = bsgrade(pseq);
#line 18
  tmp___0 = zsfind_file(zfile, (char const   *)qsys->uuconf_zname, tmp);
  }
#line 18
  return (tmp___0);
}
}
#line 496 "../sysdep.h"
char *zscmd_file(struct uuconf_system  const  *qsys , int bgrade ) ;
#line 540 "../system.h"
char *zsysdep_spool_commands(struct uuconf_system  const  *qsys , int bgrade , int ccmds ,
                             struct scmd  const  *pascmds , boolean *pftemp ) ;
#line 39 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/splcmd.c"
char *zsysdep_spool_commands(struct uuconf_system  const  *qsys , int bgrade , int ccmds ,
                             struct scmd  const  *pascmds , boolean *pftemp ) 
{ 
  char abtempfile[sizeof("TMP1234567890")] ;
  char *ztemp ;
  FILE *e ;
  int i ;
  struct scmd  const  *qcmd ;
  char *z ;
  char *zjobid ;
  unsigned short const   **tmp ;
  __pid_t tmp___0 ;
  boolean fquote ;
  struct scmd  const  *q ;
  struct scmd squoted ;
  char const   *tmp___1 ;
  boolean tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 55
  if ((unsigned long )pftemp != (unsigned long )((void *)0)) {
#line 56
    *pftemp = 1;
  }
  {
#line 59
  tmp = __ctype_b_loc();
  }
#line 59
  if (! ((int const   )*(*tmp + (int )((unsigned char )bgrade)) & 8)) {
    {
#line 60
    ulog((enum tlog )2, "Bad grade %d", bgrade);
    }
  }
  {
#line 65
  tmp___0 = getpid();
#line 65
  sprintf((char */* __restrict  */)(abtempfile), (char const   */* __restrict  */)"TMP%010lx",
          (unsigned long )tmp___0);
#line 66
  ztemp = zsfind_file((char const   *)(abtempfile), (char const   *)qsys->uuconf_zname,
                      bgrade);
  }
#line 67
  if ((unsigned long )ztemp == (unsigned long )((void *)0)) {
#line 68
    return ((char *)((void *)0));
  }
  {
#line 70
  e = esysdep_fopen((char const   *)ztemp, 0, 0, 1);
  }
#line 71
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 73
    ubuffree(ztemp);
    }
#line 74
    return ((char *)((void *)0));
  }
#line 77
  i = 0;
#line 77
  qcmd = pascmds;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < ccmds)) {
#line 77
      goto while_break;
    }
    {
#line 83
    fquote = fcmd_needs_quotes(qcmd);
    }
#line 84
    if (! fquote) {
#line 85
      q = qcmd;
    } else {
      {
#line 88
      uquote_cmd(qcmd, & squoted);
#line 89
      q = (struct scmd  const  *)(& squoted);
      }
    }
    {
#line 94
    if ((int const   )q->bcmd == 83) {
#line 94
      goto case_83;
    }
#line 99
    if ((int const   )q->bcmd == 82) {
#line 99
      goto case_82;
    }
#line 103
    if ((int const   )q->bcmd == 88) {
#line 103
      goto case_88;
    }
#line 107
    if ((int const   )q->bcmd == 69) {
#line 107
      goto case_69;
    }
#line 112
    goto switch_default;
    case_83: /* CIL Label */ 
#line 95
    if ((unsigned long )q->znotify == (unsigned long )((void *)0)) {
#line 95
      tmp___1 = (char const   */* const  */)"";
    } else {
#line 95
      tmp___1 = q->znotify;
    }
    {
#line 95
    fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"S %s %s %s -%s %s 0%o %s\n",
            q->zfrom, q->zto, q->zuser, q->zoptions, q->ztemp, q->imode, tmp___1);
    }
#line 98
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 100
    fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"R %s %s %s -%s\n",
            q->zfrom, q->zto, q->zuser, q->zoptions);
    }
#line 102
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 104
    fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"X %s %s %s -%s\n",
            q->zfrom, q->zto, q->zuser, q->zoptions);
    }
#line 106
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 108
    fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"E %s %s %s -%s %s 0%o %s 0 %s\n",
            q->zfrom, q->zto, q->zuser, q->zoptions, q->ztemp, q->imode, q->znotify,
            q->zcmd);
    }
#line 111
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 113
    ulog((enum tlog )1, "zsysdep_spool_commands: Unrecognized type %d", (int const   )q->bcmd);
#line 116
    fclose(e);
#line 117
    remove((char const   *)ztemp);
#line 118
    ubuffree(ztemp);
    }
#line 119
    if ((unsigned long )pftemp != (unsigned long )((void *)0)) {
#line 120
      *pftemp = 0;
    }
#line 121
    return ((char *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
#line 124
    if (fquote) {
      {
#line 125
      ufree_quoted_cmd(& squoted);
      }
    }
#line 77
    i ++;
#line 77
    qcmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  tmp___2 = fsysdep_sync(e, (char const   *)ztemp);
  }
#line 128
  if (! tmp___2) {
    {
#line 130
    fclose(e);
#line 131
    remove((char const   *)ztemp);
#line 132
    ubuffree(ztemp);
    }
#line 133
    return ((char *)((void *)0));
  }
  {
#line 136
  tmp___5 = fclose(e);
  }
#line 136
  if (tmp___5 != 0) {
    {
#line 138
    tmp___3 = __errno_location();
#line 138
    tmp___4 = strerror(*tmp___3);
#line 138
    ulog((enum tlog )1, "fclose: %s", tmp___4);
#line 139
    remove((char const   *)ztemp);
#line 140
    ubuffree(ztemp);
    }
#line 141
    return ((char *)((void *)0));
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 151
    z = zscmd_file(qsys, bgrade);
    }
#line 152
    if ((unsigned long )z == (unsigned long )((void *)0)) {
      {
#line 154
      remove((char const   *)ztemp);
#line 155
      ubuffree(ztemp);
      }
#line 156
      return ((char *)((void *)0));
    }
    {
#line 159
    tmp___6 = link((char const   *)ztemp, (char const   *)z);
    }
#line 159
    if (tmp___6 >= 0) {
#line 160
      goto while_break___0;
    }
    {
#line 162
    tmp___9 = __errno_location();
    }
#line 162
    if (*tmp___9 != 17) {
      {
#line 164
      tmp___7 = __errno_location();
#line 164
      tmp___8 = strerror(*tmp___7);
#line 164
      ulog((enum tlog )1, "link (%s, %s): %s", ztemp, z, tmp___8);
#line 165
      remove((char const   *)ztemp);
#line 166
      ubuffree(ztemp);
#line 167
      ubuffree(z);
      }
#line 168
      return ((char *)((void *)0));
    }
    {
#line 171
    ubuffree(z);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  remove((char const   *)ztemp);
#line 175
  ubuffree(ztemp);
#line 177
  zjobid = zsfile_to_jobid(qsys, (char const   *)z, bgrade);
  }
#line 178
  if ((unsigned long )zjobid == (unsigned long )((void *)0)) {
    {
#line 179
    remove((char const   *)z);
    }
  }
  {
#line 180
  ubuffree(z);
  }
#line 181
  return (zjobid);
}
}
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 546
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execve)(char const   *__path ,
                                                                                   char * const  *__argv ,
                                                                                   char * const  *__envp ) ;
#line 717
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 734
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 51 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/spawn.c"
extern char **environ ;
#line 85 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/spawn.c"
pid_t ixsspawn(char const   **pazargs , int *aidescs , boolean fkeepuid , boolean fkeepenv ,
               char const   *zchdir , boolean fnosigs , boolean fshell , char const   *zpath ,
               char const   *zuu_machine , char const   *zuu_user ) 
{ 
  char *zshcmd ;
  int i ;
  char *azenv[9] ;
  char **pazenv ;
  boolean ferr ;
  int ierr ;
  int onull ;
  int aichild_descs[3] ;
  int cpar_close ;
  int aipar_close[4] ;
  int cchild_close ;
  int aichild_close[3] ;
  pid_t iret ;
  char const   *zcmd ;
  size_t clen ;
  size_t tmp ;
  char const   *zterm ;
  char const   *ztz ;
  char *zspace ;
  int ienv ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int aipipe[2] ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char **pz ;
  int *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  __uid_t tmp___23 ;
  __gid_t tmp___24 ;
  __uid_t tmp___25 ;
  __gid_t tmp___26 ;
  char *zto ;
  char const   *azshargs[4] ;
  char const   *zfrom ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int *tmp___30 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;

  {
#line 107
  ierr = 0;
#line 114
  iret = 0;
#line 120
  zshcmd = (char *)((void *)0);
#line 121
  if (fshell) {
#line 125
    clen = (size_t )0;
#line 126
    i = 0;
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! ((unsigned long )*(pazargs + i) != (unsigned long )((void *)0))) {
#line 126
        goto while_break;
      }
      {
#line 127
      tmp = strlen(*(pazargs + i));
#line 127
      clen += tmp;
#line 126
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 128
    zshcmd = zbufalc(2UL * clen + (size_t )i);
    }
  }
#line 133
  if (fkeepenv) {
#line 134
    pazenv = environ;
  } else {
#line 141
    if ((unsigned long )zpath == (unsigned long )((void *)0)) {
#line 142
      zpath = "/bin /usr/bin /usr/local/bin";
    }
    {
#line 144
    tmp___0 = strlen(zpath);
#line 144
    azenv[0] = zbufalc(sizeof("PATH=") + tmp___0);
#line 145
    sprintf((char */* __restrict  */)azenv[0], (char const   */* __restrict  */)"PATH=%s",
            zpath);
#line 146
    zspace = (azenv[0] + sizeof("PATH=")) - 1;
    }
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 147
      zspace = strchr((char const   *)zspace, ' ');
      }
#line 147
      if (! ((unsigned long )zspace != (unsigned long )((void *)0))) {
#line 147
        goto while_break___0;
      }
#line 148
      *zspace = (char )':';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 150
    tmp___1 = strlen(zSspooldir);
#line 150
    azenv[1] = zbufalc(sizeof("HOME=") + tmp___1);
#line 151
    sprintf((char */* __restrict  */)azenv[1], (char const   */* __restrict  */)"HOME=%s",
            zSspooldir);
#line 153
    tmp___2 = getenv("TERM");
#line 153
    zterm = (char const   *)tmp___2;
    }
#line 154
    if ((unsigned long )zterm == (unsigned long )((void *)0)) {
#line 155
      zterm = "unknown";
    }
    {
#line 156
    tmp___3 = strlen(zterm);
#line 156
    azenv[2] = zbufalc(sizeof("TERM=") + tmp___3);
#line 157
    sprintf((char */* __restrict  */)azenv[2], (char const   */* __restrict  */)"TERM=%s",
            zterm);
#line 159
    azenv[3] = zbufcpy("SHELL=/bin/sh");
#line 161
    tmp___4 = strlen("uucp");
#line 161
    azenv[4] = zbufalc(sizeof("USER=") + tmp___4);
#line 162
    sprintf((char */* __restrict  */)azenv[4], (char const   */* __restrict  */)"USER=%s",
            "uucp");
#line 164
    ienv = 5;
#line 166
    tmp___5 = getenv("TZ");
#line 166
    ztz = (char const   *)tmp___5;
    }
#line 167
    if ((unsigned long )ztz != (unsigned long )((void *)0)) {
      {
#line 169
      tmp___6 = strlen(ztz);
#line 169
      azenv[ienv] = zbufalc(sizeof("TZ=") + tmp___6);
#line 170
      sprintf((char */* __restrict  */)azenv[ienv], (char const   */* __restrict  */)"TZ=%s",
              ztz);
#line 171
      ienv ++;
      }
    }
#line 174
    if ((unsigned long )zuu_machine != (unsigned long )((void *)0)) {
      {
#line 176
      tmp___7 = strlen(zuu_machine);
#line 176
      azenv[ienv] = zbufalc(sizeof("UU_MACHINE=") + tmp___7);
#line 178
      sprintf((char */* __restrict  */)azenv[ienv], (char const   */* __restrict  */)"UU_MACHINE=%s",
              zuu_machine);
#line 179
      ienv ++;
      }
    }
#line 182
    if ((unsigned long )zuu_user != (unsigned long )((void *)0)) {
      {
#line 184
      tmp___8 = strlen(zuu_user);
#line 184
      azenv[ienv] = zbufalc(sizeof("UU_USER=") + tmp___8);
#line 186
      sprintf((char */* __restrict  */)azenv[ienv], (char const   */* __restrict  */)"UU_USER=%s",
              zuu_user);
#line 187
      ienv ++;
      }
    }
#line 190
    azenv[ienv] = (char *)((void *)0);
#line 191
    pazenv = azenv;
  }
#line 196
  ferr = 0;
#line 197
  onull = -1;
#line 198
  cpar_close = 0;
#line 199
  cchild_close = 0;
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 206
    if (! (i < 3)) {
#line 206
      goto while_break___1;
    }
#line 208
    if (*(aidescs + i) == -1) {
#line 210
      if (onull < 0) {
        {
#line 212
        onull = open((char const   *)((char *)"/dev/null"), 2);
        }
#line 213
        if (onull < 0) {
          {
#line 217
          tmp___9 = __errno_location();
#line 217
          ierr = *tmp___9;
#line 218
          close(onull);
#line 219
          ferr = 1;
          }
#line 220
          goto while_break___1;
        } else {
          {
#line 213
          tmp___10 = fcntl(onull, 1, 0);
#line 213
          tmp___11 = fcntl(onull, 2, tmp___10 | 1);
          }
#line 213
          if (tmp___11 < 0) {
            {
#line 217
            tmp___9 = __errno_location();
#line 217
            ierr = *tmp___9;
#line 218
            close(onull);
#line 219
            ferr = 1;
            }
#line 220
            goto while_break___1;
          }
        }
#line 222
        aipar_close[cpar_close] = onull;
#line 223
        cpar_close ++;
      }
#line 225
      aichild_descs[i] = onull;
    } else
#line 227
    if (*(aidescs + i) != -2) {
#line 227
      if (*(aidescs + i) != -3) {
#line 229
        aichild_descs[i] = *(aidescs + i);
      } else {
#line 227
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 244
      tmp___13 = pipe((int *)(aipipe));
      }
#line 244
      if (tmp___13 < 0) {
        {
#line 246
        tmp___12 = __errno_location();
#line 246
        ierr = *tmp___12;
#line 247
        ferr = 1;
        }
#line 248
        goto while_break___1;
      }
#line 251
      if (*(aidescs + i) == -2) {
#line 253
        *(aidescs + i) = aipipe[0];
#line 254
        aichild_close[cchild_close] = aipipe[0];
#line 255
        aichild_descs[i] = aipipe[1];
#line 256
        aipar_close[cpar_close] = aipipe[1];
      } else {
#line 260
        *(aidescs + i) = aipipe[1];
#line 261
        aichild_close[cchild_close] = aipipe[1];
#line 262
        aichild_descs[i] = aipipe[0];
#line 263
        aipar_close[cpar_close] = aipipe[0];
      }
      {
#line 266
      cpar_close ++;
#line 267
      cchild_close ++;
#line 269
      tmp___15 = fcntl(aipipe[0], 1, 0);
#line 269
      tmp___16 = fcntl(aipipe[0], 2, tmp___15 | 1);
      }
#line 269
      if (tmp___16 < 0) {
        {
#line 274
        tmp___14 = __errno_location();
#line 274
        ierr = *tmp___14;
#line 275
        ferr = 1;
        }
#line 276
        goto while_break___1;
      } else {
        {
#line 269
        tmp___17 = fcntl(aipipe[1], 1, 0);
#line 269
        tmp___18 = fcntl(aipipe[1], 2, tmp___17 | 1);
        }
#line 269
        if (tmp___18 < 0) {
          {
#line 274
          tmp___14 = __errno_location();
#line 274
          ierr = *tmp___14;
#line 275
          ferr = 1;
          }
#line 276
          goto while_break___1;
        }
      }
    }
#line 206
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 282
  if (! ferr) {
#line 282
    if ((iDebug & 256) != 0) {
      {
#line 284
      ulog((enum tlog )4, "Forking %s", *(pazargs + 0));
#line 285
      i = 1;
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 285
        if (! ((unsigned long )*(pazargs + i) != (unsigned long )((void *)0))) {
#line 285
          goto while_break___2;
        }
        {
#line 286
        ulog((enum tlog )5, " %s", *(pazargs + i));
#line 285
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 287
      ulog((enum tlog )6, "%s", "");
      }
    }
  }
#line 291
  if (! ferr) {
    {
#line 294
    iret = ixsfork();
    }
#line 295
    if (iret < 0) {
      {
#line 297
      ferr = 1;
#line 298
      tmp___19 = __errno_location();
#line 298
      ierr = *tmp___19;
      }
    }
  }
#line 302
  if (ferr) {
#line 304
    i = 0;
    {
#line 304
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 304
      if (! (i < cchild_close)) {
#line 304
        goto while_break___3;
      }
      {
#line 305
      close(aichild_close[i]);
#line 304
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 306
    iret = -1;
  }
#line 309
  if (iret != 0) {
#line 313
    i = 0;
    {
#line 313
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 313
      if (! (i < cpar_close)) {
#line 313
        goto while_break___4;
      }
      {
#line 314
      close(aipar_close[i]);
#line 313
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 315
    ubuffree(zshcmd);
    }
#line 316
    if (! fkeepenv) {
#line 320
      pz = azenv;
      {
#line 320
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 320
        if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 320
          goto while_break___5;
        }
        {
#line 321
        ubuffree(*pz);
#line 320
        pz ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 323
    tmp___20 = __errno_location();
#line 323
    *tmp___20 = ierr;
    }
#line 324
    return (iret);
  }
#line 335
  i = 0;
  {
#line 335
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 335
    if (! (i < 3)) {
#line 335
      goto while_break___6;
    }
#line 337
    if (aichild_descs[i] != i) {
      {
#line 338
      dup2(aichild_descs[i], i);
      }
    }
    {
#line 342
    tmp___21 = fcntl(i, 1, 0);
#line 342
    fcntl(i, 2, tmp___21 & -2);
#line 335
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 345
  zcmd = *(pazargs + 0);
#line 346
  tmp___22 = strrchr(zcmd, '/');
#line 346
  *(pazargs + 0) = (char const   *)tmp___22;
  }
#line 347
  if ((unsigned long )*(pazargs + 0) == (unsigned long )((void *)0)) {
#line 348
    *(pazargs + 0) = zcmd;
  } else {
#line 350
    (*(pazargs + 0)) ++;
  }
#line 352
  if (! fkeepuid) {
    {
#line 355
    tmp___23 = getuid();
#line 355
    setuid(tmp___23);
#line 356
    tmp___24 = getgid();
#line 356
    setgid(tmp___24);
    }
  } else {
    {
#line 372
    tmp___25 = geteuid();
#line 372
    setreuid(tmp___25, (__uid_t )-1);
#line 373
    tmp___26 = getegid();
#line 373
    setregid(tmp___26, (__gid_t )-1);
    }
  }
#line 380
  if ((unsigned long )zchdir != (unsigned long )((void *)0)) {
    {
#line 381
    chdir(zchdir);
    }
  }
#line 383
  if (fnosigs) {
    {
#line 386
    signal(1, (void (*)(int  ))1);
#line 389
    signal(2, (void (*)(int  ))1);
#line 392
    signal(3, (void (*)(int  ))1);
    }
  }
  {
#line 410
  execve((char const   *)((char *)zcmd), (char * const  *)((char **)pazargs), (char * const  *)pazenv);
#line 414
  tmp___30 = __errno_location();
  }
#line 414
  if (*tmp___30 == 8) {
#line 414
    if (fshell) {
#line 419
      *(pazargs + 0) = zcmd;
#line 420
      zto = zshcmd;
#line 421
      i = 0;
      {
#line 421
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 421
        if (! ((unsigned long )*(pazargs + i) != (unsigned long )((void *)0))) {
#line 421
          goto while_break___7;
        }
#line 425
        zfrom = *(pazargs + i);
        {
#line 425
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 425
          if (! ((int const   )*zfrom != 0)) {
#line 425
            goto while_break___8;
          }
#line 432
          if ((int const   )*zfrom != 47) {
#line 433
            tmp___27 = zto;
#line 433
            zto ++;
#line 433
            *tmp___27 = (char )'\\';
          }
#line 434
          tmp___28 = zto;
#line 434
          zto ++;
#line 434
          *tmp___28 = (char )*zfrom;
#line 425
          zfrom ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 436
        tmp___29 = zto;
#line 436
        zto ++;
#line 436
        *tmp___29 = (char )' ';
#line 421
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 438
      *(zto - 1) = (char )'\000';
#line 440
      azshargs[0] = "sh";
#line 441
      azshargs[1] = "-c";
#line 442
      azshargs[2] = (char const   *)zshcmd;
#line 443
      azshargs[3] = (char const   *)((void *)0);
#line 445
      execve((char const   *)((char *)"/bin/sh"), (char * const  *)((char **)(azshargs)),
             (char * const  *)pazenv);
      }
    }
  }
  {
#line 448
  _exit(1);
  }
#line 451
  return (-1);
}
}
#line 253 "../system.h"
void usysdep_sleep(int c ) ;
#line 257
void usysdep_pause(void) ;
#line 9 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/sleep.c"
void usysdep_sleep(int c ) 
{ 
  int i ;

  {
#line 17
  i = 2 * c;
  {
#line 17
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    if (! (i > 0)) {
#line 17
      goto while_break;
    }
    {
#line 18
    usysdep_pause();
#line 17
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return;
}
}
#line 835 "../system.h"
long csysdep_size(char const   *zfile ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/size.c"
long csysdep_size(char const   *zfile ) 
{ 
  struct stat s ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 18
  tmp___2 = stat((char const   */* __restrict  */)((char *)zfile), (struct stat */* __restrict  */)(& s));
  }
#line 18
  if (tmp___2 < 0) {
    {
#line 20
    tmp = __errno_location();
    }
#line 20
    if (*tmp == 2) {
#line 21
      return (-1L);
    }
    {
#line 22
    tmp___0 = __errno_location();
#line 22
    tmp___1 = strerror(*tmp___0);
#line 22
    ulog((enum tlog )1, "stat (%s): %s", zfile, tmp___1);
    }
#line 23
    return (-2L);
  }
#line 26
  return (s.st_size);
}
}
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/sindir.c"
char *zsysdep_in_dir(char const   *zdir , char const   *zfile ) 
{ 
  size_t cdir ;
  size_t cfile ;
  char *zret ;

  {
  {
#line 18
  cdir = strlen(zdir);
#line 19
  cfile = strlen(zfile);
#line 20
  zret = zbufalc((cdir + cfile) + 2UL);
  }
#line 21
  if (cdir == 1UL) {
#line 21
    if ((int const   )*zdir == 47) {
#line 22
      cdir = (size_t )0;
    } else {
      {
#line 24
      memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)zdir,
             cdir);
      }
    }
  } else {
    {
#line 24
    memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)zdir, cdir);
    }
  }
  {
#line 25
  memcpy((void */* __restrict  */)((zret + cdir) + 1), (void const   */* __restrict  */)zfile,
         cfile);
#line 26
  *(zret + cdir) = (char )'/';
#line 27
  *(zret + ((cdir + cfile) + 1UL)) = (char )'\000';
  }
#line 28
  return (zret);
}
}
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 423 "../uudefs.h"
sig_atomic_t volatile   afLog_signal[5] ;
#line 405 "../sysdep.h"
void usset_signal(int isig , void (*pfn)(int  ) , boolean fforce , boolean *pfignored ) ;
#line 411
void ussignal(int isig ) ;
#line 116 "../system.h"
void usysdep_signal(int isig ) ;
#line 70 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/signal.c"
void ussignal(int isig ) 
{ 
  int iindex ;

  {
  {
#line 84
  if (isig == 2) {
#line 84
    goto case_2;
  }
#line 87
  if (isig == 3) {
#line 87
    goto case_3;
  }
#line 90
  if (isig == 15) {
#line 90
    goto case_15;
  }
#line 93
  if (isig == 13) {
#line 93
    goto case_13;
  }
#line 82
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 82
  iindex = 0;
#line 82
  goto switch_break;
  case_2: /* CIL Label */ 
#line 84
  iindex = 1;
#line 84
  goto switch_break;
  case_3: /* CIL Label */ 
#line 87
  iindex = 2;
#line 87
  goto switch_break;
  case_15: /* CIL Label */ 
#line 90
  iindex = 3;
#line 90
  goto switch_break;
  case_13: /* CIL Label */ 
#line 93
  iindex = 4;
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 97
  afSignal[iindex] = (sig_atomic_t volatile   )1;
#line 98
  afLog_signal[iindex] = (sig_atomic_t volatile   )1;
#line 104
  return;
}
}
#line 115 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/signal.c"
void usset_signal(int isig , void (*pfn)(int  ) , boolean fforce , boolean *pfignored ) 
{ 
  struct sigaction s ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 126
  if (! fforce) {
    {
#line 128
    sigemptyset(& s.sa_mask);
#line 129
    tmp___1 = sigaction(isig, (struct sigaction  const  */* __restrict  */)((struct sigaction *)((void *)0)),
                        (struct sigaction */* __restrict  */)(& s));
    }
#line 129
    if (tmp___1 != 0) {
      {
#line 130
      tmp = __errno_location();
#line 130
      tmp___0 = strerror(*tmp);
#line 130
      ulog((enum tlog )2, "sigaction (%d): %s", isig, tmp___0);
      }
    }
#line 132
    if ((unsigned long )s.__sigaction_handler.sa_handler == (unsigned long )((void (*)(int  ))1)) {
#line 134
      if ((unsigned long )pfignored != (unsigned long )((void *)0)) {
#line 135
        *pfignored = 1;
      }
#line 136
      return;
    }
#line 139
    if ((unsigned long )pfignored != (unsigned long )((void *)0)) {
#line 140
      *pfignored = 0;
    }
  }
  {
#line 143
  s.__sigaction_handler.sa_handler = pfn;
#line 144
  sigemptyset(& s.sa_mask);
#line 145
  s.sa_flags = 536870912;
#line 147
  tmp___4 = sigaction(isig, (struct sigaction  const  */* __restrict  */)(& s), (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
  }
#line 147
  if (tmp___4 != 0) {
    {
#line 148
    tmp___2 = __errno_location();
#line 148
    tmp___3 = strerror(*tmp___2);
#line 148
    ulog((enum tlog )2, "sigaction (%d): %s", isig, tmp___3);
    }
  }
#line 197
  return;
}
}
#line 202 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/signal.c"
void usysdep_signal(int isig ) 
{ 


  {
  {
#line 206
  usset_signal(isig, & ussignal, 0, (boolean *)((void *)0));
  }
#line 207
  return;
}
}
#line 283 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 228
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 255
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
char const   serial_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'r', 
        (char const   )'i',      (char const   )'a',      (char const   )'l',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'7',      (char const   )'8', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 169 "../system.h"
char const   *zsysdep_port_name(boolean *ftcp_port ) ;
#line 265 "../conn.h"
extern boolean fchat(struct sconnection *qconn , pointer puuconf , struct uuconf_chat  const  *qchat ,
                     struct uuconf_system  const  *qsys , struct uuconf_dialer  const  *qdialer ,
                     char const   *zphone , boolean ftranslate , char const   *zport ,
                     long ibaud ) ;
#line 294
extern boolean fmodem_dial(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys ,
                           char const   *zphone , struct uuconf_dialer *qdialer ,
                           enum tdialerfound *ptdialerfound ) ;
#line 303
boolean fsysdep_modem_begin_dial(struct sconnection *qconn , struct uuconf_dialer *qdial ) ;
#line 312
boolean fsysdep_modem_end_dial(struct sconnection *qconn , struct uuconf_dialer *qdial ) ;
#line 316
boolean fsysdep_stdin_init(struct sconnection *qconn ) ;
#line 317
boolean fsysdep_modem_init(struct sconnection *qconn ) ;
#line 318
boolean fsysdep_direct_init(struct sconnection *qconn ) ;
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 67
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 81
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 91
extern  __attribute__((__nothrow__)) int tcflush(int __fd , int __queue_selector ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 429
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 441
extern unsigned int sleep(unsigned int __seconds ) ;
#line 443 "../sysdep.h"
boolean fsdouble_read(struct sconnection *qconn , char *zbuf___0 , size_t *pclen ,
                      size_t cmin , int ctimeout , boolean freport ) ;
#line 448
boolean fsdouble_write(struct sconnection *qconn , char const   *zwrite , size_t cwrite ) ;
#line 452
boolean fsdouble_chat(struct sconnection *qconn , char **pzprog ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 235 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static void usalarm(int isig  __attribute__((__unused__)) ) ;
#line 236
static boolean fsserial_init(struct sconnection *qconn , struct sconncmds  const  *qcmds ,
                             char const   *zdevice ) ;
#line 239
static void usserial_free(struct sconnection *qconn ) ;
#line 240
static boolean fsserial_lockfile(boolean flok , struct sconnection  const  *qconn ) ;
#line 242
static boolean fsserial_lock(struct sconnection *qconn , boolean fin , boolean fuser ) ;
#line 244
static boolean fsserial_unlock(struct sconnection *qconn ) ;
#line 245
static boolean fsserial_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                             boolean fuser , enum tclocal_setting tlocal ) ;
#line 248
static boolean fsstdin_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                            boolean fuser ) ;
#line 250
static boolean fsmodem_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                            boolean fuser ) ;
#line 252
static boolean fsdirect_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                             boolean fuser ) ;
#line 254
static boolean fsblock(struct ssysdep_conn *qs , boolean fblock ) ;
#line 255
static boolean fsserial_close(struct ssysdep_conn *q ) ;
#line 256
static boolean fsstdin_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                             struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                             boolean fsuccess  __attribute__((__unused__)) ) ;
#line 260
static boolean fsmodem_close(struct sconnection *qconn , pointer puuconf , struct uuconf_dialer *qdialer ,
                             boolean fsuccess ) ;
#line 264
static boolean fsdirect_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                              struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                              boolean fsuccess  __attribute__((__unused__)) ) ;
#line 268
static boolean fsserial_break(struct sconnection *qconn ) ;
#line 269
static boolean fsstdin_break(struct sconnection *qconn ) ;
#line 270
static boolean fsserial_set(struct sconnection *qconn , enum tparitysetting tparity ,
                            enum tstripsetting tstrip , enum txonxoffsetting txonxoff ) ;
#line 274
static boolean fsstdin_set(struct sconnection *qconn , enum tparitysetting tparity ,
                           enum tstripsetting tstrip , enum txonxoffsetting txonxoff ) ;
#line 278
static boolean fsmodem_carrier(struct sconnection *qconn , boolean fcarrier ) ;
#line 280
static boolean fsserial_hardflow(struct sconnection *qconn , boolean fhardflow ) ;
#line 282
static boolean fsrun_chat(int oread , int owrite , char **pzprog ) ;
#line 283
static long isserial_baud(struct sconnection *qconn ) ;
#line 287 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static struct sconncmds  const  sstdincmds  = 
#line 287
     {& usserial_free, (boolean (*)(struct sconnection *qconn , boolean fin , boolean fuser ))((void *)0),
    (boolean (*)(struct sconnection *qconn ))((void *)0), & fsstdin_open, & fsstdin_close,
    (boolean (*)(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys ,
                 char const   *zphone , struct uuconf_dialer *qdialer , enum tdialerfound *ptdialerfound ))((void *)0),
    & fsdouble_read, & fsdouble_write, & fsysdep_conn_io, & fsstdin_break, & fsstdin_set,
    (boolean (*)(struct sconnection *qconn , boolean fcarrier ))((void *)0), & fsdouble_chat,
    & isserial_baud};
#line 307 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static struct sconncmds  const  smodemcmds  = 
#line 307
     {& usserial_free, & fsserial_lock, & fsserial_unlock, & fsmodem_open, & fsmodem_close,
    & fmodem_dial, & fsysdep_conn_read, & fsysdep_conn_write, & fsysdep_conn_io, & fsserial_break,
    & fsserial_set, & fsmodem_carrier, & fsysdep_conn_chat, & isserial_baud};
#line 327 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static struct sconncmds  const  sdirectcmds  = 
#line 327
     {& usserial_free, & fsserial_lock, & fsserial_unlock, & fsdirect_open, & fsdirect_close,
    (boolean (*)(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys ,
                 char const   *zphone , struct uuconf_dialer *qdialer , enum tdialerfound *ptdialerfound ))((void *)0),
    & fsysdep_conn_read, & fsysdep_conn_write, & fsysdep_conn_io, & fsserial_break,
    & fsserial_set, (boolean (*)(struct sconnection *qconn , boolean fcarrier ))((void *)0),
    & fsysdep_conn_chat, & isserial_baud};
#line 352 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static int iSunblock  =    2048;
#line 361 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
sig_atomic_t volatile   fSalarm  ;
#line 363 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static void usalarm(int isig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 371
  fSalarm = (sig_atomic_t volatile   )1;
#line 376
  alarm(1U);
  }
#line 378
  return;
}
}
#line 393
static sigset_t isblocksigs(void) ;
#line 395 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static sigset_t isblocksigs(void) 
{ 
  sigset_t sblock ;
  sigset_t sold ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 402
  sigemptyset(& sblock);
#line 403
  sigaddset(& sblock, 2);
#line 404
  sigaddset(& sblock, 3);
#line 405
  sigaddset(& sblock, 15);
#line 406
  sigaddset(& sblock, 13);
#line 408
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sblock), (sigset_t */* __restrict  */)(& sold));
  }
#line 409
  return (sold);
}
}
#line 482 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_init(struct sconnection *qconn , struct sconncmds  const  *qcmds ,
                             char const   *zdevice ) 
{ 
  struct ssysdep_conn *q ;
  pointer tmp ;
  size_t clen ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 490
  tmp = xmalloc(sizeof(struct ssysdep_conn ));
#line 490
  q = (struct ssysdep_conn *)tmp;
  }
#line 491
  if ((unsigned long )zdevice == (unsigned long )((void *)0)) {
#line 491
    if ((unsigned long )qconn->qport != (unsigned long )((void *)0)) {
#line 491
      if ((unsigned int )(qconn->qport)->uuconf_ttype != 1U) {
#line 494
        zdevice = (char const   *)(qconn->qport)->uuconf_zname;
      }
    }
  }
#line 495
  if ((unsigned long )zdevice == (unsigned long )((void *)0)) {
#line 496
    q->zdevice = (char *)((void *)0);
  } else
#line 497
  if ((int const   )*zdevice == 47) {
    {
#line 498
    q->zdevice = zbufcpy(zdevice);
    }
  } else {
    {
#line 503
    clen = strlen(zdevice);
#line 504
    q->zdevice = zbufalc(sizeof("/dev/") + clen);
#line 505
    memcpy((void */* __restrict  */)q->zdevice, (void const   */* __restrict  */)"/dev/",
           sizeof("/dev/") - 1UL);
#line 506
    memcpy((void */* __restrict  */)((q->zdevice + sizeof("/dev/")) - 1), (void const   */* __restrict  */)zdevice,
           clen);
#line 507
    *(q->zdevice + ((sizeof("/dev/") + clen) - 1UL)) = (char )'\000';
    }
  }
#line 509
  q->o = -1;
#line 510
  q->ord = -1;
#line 511
  q->owr = -1;
#line 512
  q->ftli = 0;
#line 513
  qconn->psysdep = (pointer )q;
#line 514
  qconn->qcmds = qcmds;
#line 515
  return (1);
}
}
#line 520 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_stdin_init(struct sconnection *qconn ) 
{ 
  boolean tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 526
  chmod("/dev/tty", (__mode_t )384);
#line 527
  tmp = fsserial_init(qconn, & sstdincmds, (char const   *)((void *)0));
  }
#line 527
  return (tmp);
}
}
#line 532 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_modem_init(struct sconnection *qconn ) 
{ 
  boolean tmp ;

  {
  {
#line 536
  tmp = fsserial_init(qconn, & smodemcmds, (char const   *)(qconn->qport)->uuconf_u.uuconf_smodem.uuconf_zdevice);
  }
#line 536
  return (tmp);
}
}
#line 542 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_direct_init(struct sconnection *qconn ) 
{ 
  boolean tmp ;

  {
  {
#line 546
  tmp = fsserial_init(qconn, & sdirectcmds, (char const   *)(qconn->qport)->uuconf_u.uuconf_sdirect.uuconf_zdevice);
  }
#line 546
  return (tmp);
}
}
#line 552 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static void usserial_free(struct sconnection *qconn ) 
{ 
  struct ssysdep_conn *qsysdep ;

  {
  {
#line 558
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 559
  ubuffree(qsysdep->zdevice);
#line 560
  xfree((pointer )qsysdep);
#line 561
  qconn->psysdep = (void *)0;
  }
#line 562
  return;
}
}
#line 575 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_lockfile(boolean flok , struct sconnection  const  *qconn ) 
{ 
  struct ssysdep_conn *qsysdep ;
  char const   *z ;
  char *zalc ;
  boolean fret ;
  char const   *zbase ;
  size_t clen ;
  char *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 585
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 586
  if ((unsigned long )qconn->qport == (unsigned long )((void *)0)) {
#line 587
    z = (char const   *)((void *)0);
  } else {
#line 589
    z = (char const   *)(qconn->qport)->uuconf_zlockname;
  }
#line 590
  zalc = (char *)((void *)0);
#line 591
  if ((unsigned long )z == (unsigned long )((void *)0)) {
    {
#line 631
    tmp = strrchr((char const   *)qsysdep->zdevice, '/');
#line 631
    zbase = (char const   *)(tmp + 1);
#line 632
    clen = strlen(zbase);
#line 633
    zalc = zbufalc(sizeof("LCK..") + clen);
#line 634
    memcpy((void */* __restrict  */)zalc, (void const   */* __restrict  */)"LCK..",
           sizeof("LCK..") - 1UL);
#line 635
    memcpy((void */* __restrict  */)((zalc + sizeof("LCK..")) - 1), (void const   */* __restrict  */)zbase,
           clen + 1UL);
#line 645
    z = (char const   *)zalc;
    }
  }
#line 666
  if (flok) {
    {
#line 667
    fret = fsdo_lock(z, 0, (boolean *)((void *)0));
    }
  } else {
    {
#line 669
    fret = fsdo_unlock(z, 0);
    }
  }
  {
#line 727
  ubuffree(zalc);
  }
#line 728
  return (fret);
}
}
#line 735 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_lock(struct sconnection *qconn , boolean fin , boolean fuser ) 
{ 
  boolean tmp ;
  struct ssysdep_conn *qsysdep ;
  int iflag ;
  uid_t ieuid ;
  gid_t iegid ;
  boolean tmp___0 ;
  int *tmp___1 ;
  int ierr ;
  int *tmp___2 ;
  char *tmp___3 ;
  boolean tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 741
  tmp = fsserial_lockfile(1, (struct sconnection  const  *)qconn);
  }
#line 741
  if (! tmp) {
#line 742
    return (0);
  }
#line 752
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 754
  if (fin) {
#line 755
    iflag = 0;
  } else {
#line 757
    iflag = iSunblock;
  }
#line 759
  if (fuser) {
    {
#line 761
    tmp___0 = fsuser_perms(& ieuid, & iegid);
    }
#line 761
    if (! tmp___0) {
      {
#line 763
      fsserial_lockfile(0, (struct sconnection  const  *)qconn);
      }
#line 764
      return (0);
    }
  }
  {
#line 768
  qsysdep->o = open((char const   *)qsysdep->zdevice, 2 | iflag);
  }
#line 769
  if (qsysdep->o < 0) {
#line 772
    if (! fin) {
#line 772
      if (iSunblock != 2048) {
        {
#line 772
        tmp___1 = __errno_location();
        }
#line 772
        if (*tmp___1 == 22) {
          {
#line 774
          iSunblock = 2048;
#line 775
          qsysdep->o = open((char const   *)qsysdep->zdevice, 2050);
          }
        }
      }
    }
#line 779
    if (qsysdep->o < 0) {
      {
#line 783
      tmp___2 = __errno_location();
#line 783
      ierr = *tmp___2;
      }
#line 784
      if (fuser) {
        {
#line 785
        fsuucp_perms((long )ieuid, (long )iegid);
        }
      }
#line 786
      if (ierr != 16) {
        {
#line 787
        tmp___3 = strerror(ierr);
#line 787
        ulog((enum tlog )1, "open (%s): %s", qsysdep->zdevice, tmp___3);
        }
      }
      {
#line 789
      fsserial_lockfile(0, (struct sconnection  const  *)qconn);
      }
#line 790
      return (0);
    }
  }
#line 794
  if (fuser) {
    {
#line 796
    tmp___4 = fsuucp_perms((long )ieuid, (long )iegid);
    }
#line 796
    if (! tmp___4) {
      {
#line 798
      close(qsysdep->o);
#line 799
      qsysdep->o = -1;
#line 800
      fsserial_lockfile(0, (struct sconnection  const  *)qconn);
      }
#line 801
      return (0);
    }
  }
  {
#line 854
  tmp___7 = fcntl(qsysdep->o, 1, 0);
#line 854
  tmp___8 = fcntl(qsysdep->o, 2, tmp___7 | 1);
  }
#line 854
  if (tmp___8 < 0) {
    {
#line 857
    tmp___5 = __errno_location();
#line 857
    tmp___6 = strerror(*tmp___5);
#line 857
    ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___6);
#line 859
    ioctl(qsysdep->o, 21538UL, (char *)((void *)0));
#line 861
    close(qsysdep->o);
#line 862
    qsysdep->o = -1;
#line 863
    fsserial_lockfile(0, (struct sconnection  const  *)qconn);
    }
#line 864
    return (0);
  }
#line 869
  return (1);
}
}
#line 874 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_unlock(struct sconnection *qconn ) 
{ 
  boolean fret ;
  struct ssysdep_conn *qsysdep ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  boolean tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 881
  fret = 1;
#line 885
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 886
  if (qsysdep->o >= 0) {
    {
#line 889
    ioctl(qsysdep->o, 21538UL, (char *)((void *)0));
#line 891
    tmp___1 = close(qsysdep->o);
    }
#line 891
    if (tmp___1 < 0) {
      {
#line 893
      tmp = __errno_location();
#line 893
      tmp___0 = strerror(*tmp);
#line 893
      ulog((enum tlog )1, "close: %s", tmp___0);
#line 894
      fret = 0;
      }
    }
#line 896
    qsysdep->o = -1;
  }
  {
#line 899
  tmp___2 = fsserial_lockfile(0, (struct sconnection  const  *)qconn);
  }
#line 899
  if (! tmp___2) {
#line 900
    fret = 0;
  }
#line 902
  return (fret);
}
}
#line 913 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static struct sbaud_table asSbaud_table[31]  = 
#line 913
  {      {(baud_code )1, 50L}, 
        {(baud_code )2, 75L}, 
        {(baud_code )3, 110L}, 
        {(baud_code )4, 134L}, 
        {(baud_code )5, 150L}, 
        {(baud_code )6, 200L}, 
        {(baud_code )7, 300L}, 
        {(baud_code )8, 600L}, 
        {(baud_code )9, 1200L}, 
        {(baud_code )10, 1800L}, 
        {(baud_code )11, 2400L}, 
        {(baud_code )12, 4800L}, 
        {(baud_code )13, 9600L}, 
        {(baud_code )14, 19200L}, 
        {(baud_code )15, 38400L}, 
        {(baud_code )4097, 57600L}, 
        {(baud_code )4098, 115200L}, 
        {(baud_code )4099, 230400L}, 
        {(baud_code )4100, 460800L}, 
        {(baud_code )4101, 500000L}, 
        {(baud_code )4102, 576000L}, 
        {(baud_code )4103, 921600L}, 
        {(baud_code )4104, 1000000L}, 
        {(baud_code )4105, 1152000L}, 
        {(baud_code )4106, 1500000L}, 
        {(baud_code )4107, 2000000L}, 
        {(baud_code )4108, 2500000L}, 
        {(baud_code )4109, 3000000L}, 
        {(baud_code )4110, 3500000L}, 
        {(baud_code )4111, 4000000L}, 
        {(baud_code )0, 0L}};
#line 1010 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static int cSmin  ;
#line 1019 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                             boolean fuser , enum tclocal_setting tlocal ) 
{ 
  struct ssysdep_conn *q ;
  baud_code ib ;
  char const   *z ;
  int tmp ;
  char const   *zport ;
  boolean fdummy ;
  size_t i ;
  int iflag ;
  uid_t ieuid ;
  gid_t iegid ;
  boolean tmp___0 ;
  int *tmp___1 ;
  int ierr ;
  int *tmp___2 ;
  char *tmp___3 ;
  boolean tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  boolean tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  size_t i___0 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 1030
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 1032
  if ((unsigned long )q->zdevice != (unsigned long )((void *)0)) {
    {
#line 1039
    tmp = strncmp((char const   *)q->zdevice, "/dev/", sizeof("/dev/") - 1UL);
    }
#line 1039
    if (tmp == 0) {
#line 1040
      z = (char const   *)((q->zdevice + sizeof("/dev/")) - 1);
    } else {
#line 1042
      z = (char const   *)q->zdevice;
    }
    {
#line 1043
    ulog_device(z);
    }
  } else {
#line 1052
    if ((unsigned long )qconn->qport != (unsigned long )((void *)0)) {
#line 1052
      if ((unsigned int )(qconn->qport)->uuconf_ttype != 1U) {
        {
#line 1054
        ulog((enum tlog )2, "fsserial_open: Can\'t happen");
        }
      }
    }
    {
#line 1056
    zport = zsysdep_port_name(& fdummy);
    }
#line 1057
    if ((unsigned long )zport != (unsigned long )((void *)0)) {
      {
#line 1058
      ulog_device(zport);
      }
    }
  }
#line 1061
  ib = (baud_code )0;
#line 1062
  if (ibaud != 0L) {
#line 1066
    i = (size_t )0;
    {
#line 1066
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1066
      if (! (i < sizeof(asSbaud_table) / sizeof(asSbaud_table[0]))) {
#line 1066
        goto while_break;
      }
#line 1067
      if (asSbaud_table[i].ibaud == ibaud) {
#line 1068
        goto while_break;
      }
#line 1066
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1069
    if (i >= sizeof(asSbaud_table) / sizeof(asSbaud_table[0])) {
      {
#line 1071
      ulog((enum tlog )1, "Unsupported baud rate %ld", ibaud);
      }
#line 1072
      return (0);
    }
#line 1074
    ib = asSbaud_table[i].icode;
  }
#line 1078
  if (q->o < 0) {
#line 1084
    if (fwait) {
#line 1085
      iflag = 0;
    } else {
#line 1087
      iflag = iSunblock;
    }
#line 1089
    if (fuser) {
      {
#line 1091
      tmp___0 = fsuser_perms(& ieuid, & iegid);
      }
#line 1091
      if (! tmp___0) {
#line 1092
        return (0);
      }
    }
    {
#line 1095
    q->o = open((char const   *)q->zdevice, 2 | iflag);
    }
#line 1096
    if (q->o < 0) {
#line 1099
      if (! fwait) {
#line 1099
        if (iSunblock != 2048) {
          {
#line 1099
          tmp___1 = __errno_location();
          }
#line 1099
          if (*tmp___1 == 22) {
            {
#line 1101
            iSunblock = 2048;
#line 1102
            q->o = open((char const   *)q->zdevice, 2050);
            }
          }
        }
      }
#line 1105
      if (q->o < 0) {
        {
#line 1109
        tmp___2 = __errno_location();
#line 1109
        ierr = *tmp___2;
        }
#line 1110
        if (fuser) {
          {
#line 1111
          fsuucp_perms((long )ieuid, (long )iegid);
          }
        }
        {
#line 1112
        tmp___3 = strerror(ierr);
#line 1112
        ulog((enum tlog )1, "open (%s): %s", q->zdevice, tmp___3);
        }
#line 1114
        return (0);
      }
    }
#line 1118
    if (fuser) {
      {
#line 1120
      tmp___4 = fsuucp_perms((long )ieuid, (long )iegid);
      }
#line 1120
      if (! tmp___4) {
#line 1121
        return (0);
      }
    }
    {
#line 1124
    tmp___7 = fcntl(q->o, 1, 0);
#line 1124
    tmp___8 = fcntl(q->o, 2, tmp___7 | 1);
    }
#line 1124
    if (tmp___8 < 0) {
      {
#line 1126
      tmp___5 = __errno_location();
#line 1126
      tmp___6 = strerror(*tmp___5);
#line 1126
      ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___6);
      }
#line 1127
      return (0);
    }
  }
  {
#line 1133
  q->iflags = fcntl(q->o, 3, 0);
  }
#line 1134
  if (q->iflags < 0) {
    {
#line 1136
    tmp___9 = __errno_location();
#line 1136
    tmp___10 = strerror(*tmp___9);
#line 1136
    ulog((enum tlog )1, "fcntl: %s", tmp___10);
    }
#line 1137
    return (0);
  }
  {
#line 1139
  q->iwr_flags = -1;
#line 1141
  tmp___11 = fsblock(q, 1);
  }
#line 1141
  if (! tmp___11) {
#line 1142
    return (0);
  }
  {
#line 1144
  tmp___12 = tcgetattr(q->o, & q->sorig);
  }
#line 1144
  if (! (tmp___12 == 0)) {
#line 1146
    q->fterminal = 0;
#line 1147
    return (1);
  }
#line 1150
  q->fterminal = 1;
#line 1152
  q->snew = q->sorig;
#line 1237
  if (ibaud == 0L) {
    {
#line 1238
    ib = cfgetospeed((struct termios  const  *)(& q->snew));
    }
  }
  {
#line 1240
  q->snew.c_iflag &= 4294953472U;
#line 1241
  q->snew.c_oflag &= 4294967294U;
#line 1242
  q->snew.c_cflag &= 4294966479U;
#line 1243
  q->snew.c_cflag |= 1200U;
#line 1244
  q->snew.c_lflag &= 4294917636U;
#line 1245
  cSmin = 1;
#line 1246
  q->snew.c_cc[6] = (cc_t )cSmin;
#line 1247
  q->snew.c_cc[5] = (cc_t )1;
#line 1249
  cfsetospeed(& q->snew, ib);
#line 1250
  cfsetispeed(& q->snew, ib);
#line 1253
  tcflush(q->o, 0);
  }
  {
#line 1260
  if ((unsigned int )tlocal == 0U) {
#line 1260
    goto case_0;
  }
#line 1263
  if ((unsigned int )tlocal == 1U) {
#line 1263
    goto case_1;
  }
#line 1266
  if ((unsigned int )tlocal == 2U) {
#line 1266
    goto case_2;
  }
#line 1258
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1261
  q->snew.c_cflag |= 2048U;
#line 1262
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1264
  q->snew.c_cflag &= 4294965247U;
#line 1265
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1267
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1271
  tmp___15 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->snew));
  }
#line 1271
  if (! (tmp___15 == 0)) {
    {
#line 1273
    tmp___13 = __errno_location();
#line 1273
    tmp___14 = strerror(*tmp___13);
#line 1273
    ulog((enum tlog )1, "Can\'t set terminal settings: %s", tmp___14);
    }
#line 1274
    return (0);
  }
  {
#line 1279
  ioctl(q->o, 21518UL, 0);
  }
#line 1282
  if (ibaud != 0L) {
#line 1283
    q->ibaud = ibaud;
  } else {
#line 1288
    q->ibaud = 1200L;
#line 1289
    i___0 = (size_t )0;
    {
#line 1289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1289
      if (! (i___0 < sizeof(asSbaud_table) / sizeof(asSbaud_table[0]))) {
#line 1289
        goto while_break___0;
      }
#line 1291
      if (asSbaud_table[i___0].icode == ib) {
#line 1291
        if (asSbaud_table[i___0].ibaud != 0L) {
#line 1294
          q->ibaud = asSbaud_table[i___0].ibaud;
#line 1295
          goto while_break___0;
        }
      }
#line 1289
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1299
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1299
      if ((iDebug & 32) != 0) {
        {
#line 1299
        ulog((enum tlog )3, "fsserial_open: Baud rate is %ld", q->ibaud);
        }
      }
#line 1299
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1303
  return (1);
}
}
#line 1310 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsstdin_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                            boolean fuser ) 
{ 
  struct ssysdep_conn *q ;
  boolean tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 1319
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 1320
  q->ord = 0;
#line 1321
  q->owr = 1;
#line 1323
  q->o = q->ord;
#line 1324
  tmp = fsserial_open(qconn, ibaud, fwait, fuser, (enum tclocal_setting )2);
  }
#line 1324
  if (! tmp) {
#line 1325
    return (0);
  }
  {
#line 1326
  q->iwr_flags = fcntl(q->owr, 3, 0);
  }
#line 1327
  if (q->iwr_flags < 0) {
    {
#line 1329
    tmp___0 = __errno_location();
#line 1329
    tmp___1 = strerror(*tmp___0);
#line 1329
    ulog((enum tlog )1, "fcntl: %s", tmp___1);
    }
#line 1330
    return (0);
  }
#line 1332
  return (1);
}
}
#line 1337 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsmodem_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                            boolean fuser ) 
{ 
  struct uuconf_modem_port *qm ;
  int tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;

  {
#line 1346
  qm = & (qconn->qport)->uuconf_u.uuconf_smodem;
#line 1347
  if (ibaud == 0L) {
#line 1348
    ibaud = qm->uuconf_ibaud;
  }
#line 1350
  if (fwait) {
#line 1350
    tmp = 1;
  } else {
#line 1350
    tmp = 0;
  }
  {
#line 1350
  tmp___0 = fsserial_open(qconn, ibaud, fwait, fuser, (enum tclocal_setting )tmp);
  }
#line 1350
  if (! tmp___0) {
#line 1352
    return (0);
  }
#line 1359
  if (fwait) {
    {
#line 1359
    tmp___1 = fsserial_hardflow(qconn, qm->uuconf_fhardflow);
    }
#line 1359
    if (! tmp___1) {
#line 1361
      return (0);
    }
  }
#line 1363
  return (1);
}
}
#line 1368 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsdirect_open(struct sconnection *qconn , long ibaud , boolean fwait ,
                             boolean fuser ) 
{ 
  struct uuconf_direct_port *qd ;
  int tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;

  {
#line 1377
  qd = & (qconn->qport)->uuconf_u.uuconf_sdirect;
#line 1378
  if (ibaud == 0L) {
#line 1379
    ibaud = qd->uuconf_ibaud;
  }
#line 1380
  if (qd->uuconf_fcarrier) {
#line 1380
    tmp = 1;
  } else {
#line 1380
    tmp = 0;
  }
  {
#line 1380
  tmp___0 = fsserial_open(qconn, ibaud, fwait, fuser, (enum tclocal_setting )tmp);
  }
#line 1380
  if (! tmp___0) {
#line 1382
    return (0);
  }
  {
#line 1386
  tmp___1 = fsserial_hardflow(qconn, qd->uuconf_fhardflow);
  }
#line 1386
  return (tmp___1);
}
}
#line 1393 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsblock(struct ssysdep_conn *qs , boolean fblock ) 
{ 
  int iwant ;
  int isys ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1401
  if (fblock) {
#line 1402
    iwant = qs->iflags & -2049;
  } else {
#line 1404
    iwant = qs->iflags | iSunblock;
  }
#line 1406
  if (iwant == qs->iflags) {
#line 1407
    return (1);
  }
  {
#line 1409
  isys = fcntl(qs->o, 4, iwant);
  }
#line 1410
  if (isys < 0) {
#line 1413
    if (! fblock) {
#line 1413
      if (iSunblock != 2048) {
        {
#line 1413
        tmp = __errno_location();
        }
#line 1413
        if (*tmp == 22) {
          {
#line 1415
          iSunblock = 2048;
#line 1416
          iwant = qs->iflags | 2048;
#line 1417
          isys = fcntl(qs->o, 4, iwant);
          }
        }
      }
    }
#line 1420
    if (isys < 0) {
      {
#line 1422
      tmp___0 = __errno_location();
#line 1422
      tmp___1 = strerror(*tmp___0);
#line 1422
      ulog((enum tlog )1, "fcntl: %s", tmp___1);
      }
#line 1423
      return (0);
    }
  }
#line 1427
  qs->iflags = iwant;
#line 1429
  if (qs->iwr_flags >= 0) {
#line 1429
    if (qs->ord != qs->owr) {
#line 1431
      if (fblock) {
#line 1432
        iwant = qs->iwr_flags & -2049;
      } else {
#line 1434
        iwant = qs->iwr_flags | iSunblock;
      }
      {
#line 1436
      isys = fcntl(qs->owr, 4, iwant);
      }
#line 1437
      if (isys < 0) {
#line 1440
        if (! fblock) {
#line 1440
          if (iSunblock != 2048) {
            {
#line 1440
            tmp___2 = __errno_location();
            }
#line 1440
            if (*tmp___2 == 22) {
              {
#line 1442
              iSunblock = 2048;
#line 1443
              iwant = qs->iwr_flags | 2048;
#line 1444
              isys = fcntl(qs->owr, 4, iwant);
              }
            }
          }
        }
#line 1447
        if (isys < 0) {
          {
#line 1449
          tmp___3 = __errno_location();
#line 1449
          tmp___4 = strerror(*tmp___3);
#line 1449
          ulog((enum tlog )1, "fcntl: %s", tmp___4);
          }
#line 1450
          return (0);
        }
      }
#line 1454
      qs->iwr_flags = iwant;
    }
  }
#line 1457
  return (1);
}
}
#line 1462 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_close(struct ssysdep_conn *q ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1466
  if (q->o >= 0) {
#line 1470
    if (q->fterminal) {
      {
#line 1472
      fSalarm = (sig_atomic_t volatile   )0;
#line 1477
      usset_signal(14, & usalarm, 1, (boolean *)((void *)0));
#line 1478
      alarm(30U);
#line 1480
      tmp = tcsetattr(q->o, 1, (struct termios  const  *)(& q->sorig));
#line 1483
      usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 1484
      alarm(0U);
      }
#line 1489
      if (fSalarm) {
        {
#line 1490
        tmp___0 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->sorig));
        }
      }
    }
    {
#line 1498
    ioctl(q->o, 21538UL, (char *)((void *)0));
#line 1501
    close(q->o);
#line 1502
    q->o = -1;
#line 1506
    sleep(2U);
    }
  }
#line 1509
  return (1);
}
}
#line 1515 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsstdin_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                             struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                             boolean fsuccess  __attribute__((__unused__)) ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean tmp ;

  {
  {
#line 1524
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 1525
  close(qsysdep->owr);
#line 1526
  close(2);
#line 1527
  qsysdep->o = qsysdep->ord;
#line 1528
  tmp = fsserial_close(qsysdep);
  }
#line 1528
  return (tmp);
}
}
#line 1533 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsmodem_close(struct sconnection *qconn , pointer puuconf , struct uuconf_dialer *qdialer ,
                             boolean fsuccess ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean fret ;
  struct uuconf_dialer sdialer ;
  struct uuconf_chat  const  *qchat ;
  char const   *zdialer ;
  int iuuconf ;
  boolean fsighup_ignored ;
  sigset_t smask ;
  int i ;
  sig_atomic_t afhold[5] ;
  boolean tmp ;
  int tmp___0 ;
  boolean tmp___1 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
#line 1545
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 1547
  fret = 1;
#line 1551
  if ((unsigned long )qdialer == (unsigned long )((void *)0)) {
#line 1553
    if ((unsigned long )(qconn->qport)->uuconf_u.uuconf_smodem.uuconf_pzdialer != (unsigned long )((void *)0)) {
      {
#line 1558
      zdialer = (char const   *)*((qconn->qport)->uuconf_u.uuconf_smodem.uuconf_pzdialer + 0);
#line 1559
      iuuconf = uuconf_dialer_info(puuconf, zdialer, & sdialer);
      }
#line 1560
      if (iuuconf == 0) {
#line 1561
        qdialer = & sdialer;
      } else {
        {
#line 1564
        ulog_uuconf((enum tlog )1, puuconf, iuuconf);
#line 1565
        fret = 0;
        }
      }
    } else {
#line 1569
      qdialer = (qconn->qport)->uuconf_u.uuconf_smodem.uuconf_qdialer;
    }
  }
#line 1573
  qchat = (struct uuconf_chat  const  *)((void *)0);
#line 1574
  if ((unsigned long )qdialer != (unsigned long )((void *)0)) {
#line 1576
    if (fsuccess) {
#line 1577
      qchat = (struct uuconf_chat  const  *)(& qdialer->uuconf_scomplete);
    } else {
#line 1579
      qchat = (struct uuconf_chat  const  *)(& qdialer->uuconf_sabort);
    }
  }
#line 1582
  if ((unsigned long )qchat != (unsigned long )((void *)0)) {
#line 1582
    if ((unsigned long )qchat->uuconf_pzprogram != (unsigned long )((void *)0)) {
#line 1582
      goto _L;
    } else
#line 1582
    if ((unsigned long )qchat->uuconf_pzchat != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 1592
      fsmodem_carrier(qconn, 0);
#line 1606
      usset_signal(1, (void (*)(int  ))1, 0, & fsighup_ignored);
#line 1607
      smask = isblocksigs();
#line 1608
      i = 0;
      }
      {
#line 1608
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1608
        if (! (i < 5)) {
#line 1608
          goto while_break;
        }
#line 1610
        afhold[i] = (sig_atomic_t )afSignal[i];
#line 1611
        afSignal[i] = (sig_atomic_t volatile   )0;
#line 1608
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1613
      sigprocmask(2, (sigset_t const   */* __restrict  */)(& smask), (sigset_t */* __restrict  */)((sigset_t *)((void *)0)));
#line 1615
      tmp = fchat(qconn, puuconf, qchat, (struct uuconf_system  const  *)((void *)0),
                  (struct uuconf_dialer  const  *)((void *)0), (char const   *)((void *)0),
                  0, (char const   *)(qconn->qport)->uuconf_zname, qsysdep->ibaud);
      }
#line 1615
      if (! tmp) {
#line 1619
        fret = 0;
      }
#line 1625
      i = 0;
      {
#line 1625
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1625
        if (! (i < 5)) {
#line 1625
          goto while_break___0;
        }
#line 1626
        if (afhold[i]) {
#line 1627
          afSignal[i] = (sig_atomic_t volatile   )1;
        }
#line 1625
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1628
      if (! fsighup_ignored) {
        {
#line 1629
        usset_signal(1, & ussignal, 1, (boolean *)((void *)0));
        }
      }
    }
  }
#line 1632
  if ((unsigned long )qdialer != (unsigned long )((void *)0)) {
#line 1632
    if ((unsigned long )qdialer == (unsigned long )(& sdialer)) {
      {
#line 1634
      uuconf_dialer_free(puuconf, & sdialer);
      }
    }
  }
#line 1641
  if (qsysdep->fterminal) {
    {
#line 1651
    cfsetospeed(& qsysdep->snew, (speed_t )0);
#line 1654
    fSalarm = (sig_atomic_t volatile   )0;
#line 1659
    usset_signal(14, & usalarm, 1, (boolean *)((void *)0));
#line 1660
    alarm(30U);
#line 1662
    tmp___0 = tcsetattr(qsysdep->o, 1, (struct termios  const  *)(& qsysdep->snew));
#line 1665
    usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 1666
    alarm(0U);
#line 1670
    sleep(2U);
    }
  }
  {
#line 1674
  tmp___1 = fsserial_close(qsysdep);
  }
#line 1674
  if (! tmp___1) {
#line 1675
    fret = 0;
  }
#line 1677
  return (fret);
}
}
#line 1683 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsdirect_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                              struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                              boolean fsuccess  __attribute__((__unused__)) ) 
{ 
  boolean tmp ;

  {
  {
#line 1690
  tmp = fsserial_close((struct ssysdep_conn *)qconn->psysdep);
  }
#line 1690
  return (tmp);
}
}
#line 1696 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_modem_begin_dial(struct sconnection *qconn , struct uuconf_dialer *qdial ) 
{ 
  struct ssysdep_conn *qsysdep ;
  char const   *z ;
  sterminal sbaud ;
  int tmp ;
  int tmp___0 ;
  boolean tmp___1 ;
  char *zfree ;
  int o ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 1704
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 1718
  if (qdial->uuconf_fdtr_toggle) {
#line 1725
    if (qsysdep->fterminal) {
      {
#line 1729
      sbaud = qsysdep->snew;
#line 1739
      cfsetospeed(& sbaud, (speed_t )0);
#line 1742
      tmp = tcsetattr(qsysdep->o, 1, (struct termios  const  *)(& sbaud));
#line 1743
      sleep(2U);
#line 1744
      tmp___0 = tcsetattr(qsysdep->o, 0, (struct termios  const  *)(& qsysdep->snew));
      }
    }
#line 1748
    if (qdial->uuconf_fdtr_toggle_wait) {
      {
#line 1749
      sleep(2U);
      }
    }
  }
  {
#line 1752
  tmp___1 = fsmodem_carrier(qconn, 0);
  }
#line 1752
  if (! tmp___1) {
#line 1753
    return (0);
  }
#line 1756
  z = (char const   *)(qconn->qport)->uuconf_u.uuconf_smodem.uuconf_zdial_device;
#line 1757
  if ((unsigned long )z != (unsigned long )((void *)0)) {
#line 1762
    qsysdep->ohold = qsysdep->o;
#line 1764
    zfree = (char *)((void *)0);
#line 1765
    if ((int const   )*z != 47) {
      {
#line 1767
      tmp___2 = strlen(z);
#line 1767
      zfree = zbufalc(sizeof("/dev/") + tmp___2);
#line 1768
      sprintf((char */* __restrict  */)zfree, (char const   */* __restrict  */)"/dev/%s",
              z);
#line 1769
      z = (char const   *)zfree;
      }
    }
    {
#line 1772
    o = open((char const   *)((char *)z), 258);
    }
#line 1773
    if (o < 0) {
      {
#line 1775
      tmp___3 = __errno_location();
#line 1775
      tmp___4 = strerror(*tmp___3);
#line 1775
      ulog((enum tlog )1, "open (%s): %s", z, tmp___4);
#line 1776
      ubuffree(zfree);
      }
#line 1777
      return (0);
    }
    {
#line 1779
    ubuffree(zfree);
#line 1781
    tmp___7 = fcntl(o, 1, 0);
#line 1781
    tmp___8 = fcntl(o, 2, tmp___7 | 1);
    }
#line 1781
    if (tmp___8 < 0) {
      {
#line 1783
      tmp___5 = __errno_location();
#line 1783
      tmp___6 = strerror(*tmp___5);
#line 1783
      ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___6);
#line 1784
      close(o);
      }
#line 1785
      return (0);
    }
#line 1788
    qsysdep->o = o;
  }
#line 1791
  return (1);
}
}
#line 1801 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsmodem_carrier(struct sconnection *qconn , boolean fcarrier ) 
{ 
  register struct ssysdep_conn *q ;
  struct uuconf_modem_port *qm ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  boolean tmp___2 ;
  boolean tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1809
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 1811
  if (! q->fterminal) {
#line 1812
    return (1);
  }
#line 1814
  qm = & (qconn->qport)->uuconf_u.uuconf_smodem;
#line 1815
  if (fcarrier) {
#line 1817
    if (qm->uuconf_fcarrier) {
      {
#line 1847
      q->snew.c_cflag &= 4294965247U;
#line 1848
      tmp___1 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->snew));
      }
#line 1848
      if (! (tmp___1 == 0)) {
        {
#line 1850
        tmp = __errno_location();
#line 1850
        tmp___0 = strerror(*tmp);
#line 1850
        ulog((enum tlog )1, "Can\'t clear CLOCAL: %s", tmp___0);
        }
#line 1851
        return (0);
      }
    }
    {
#line 1859
    tmp___2 = fsserial_hardflow(qconn, qm->uuconf_fhardflow);
    }
#line 1859
    if (! tmp___2) {
#line 1860
      return (0);
    }
  } else {
    {
#line 1866
    tmp___3 = fsserial_hardflow(qconn, 0);
    }
#line 1866
    if (! tmp___3) {
#line 1867
      return (0);
    }
    {
#line 1898
    q->snew.c_cflag |= 2048U;
#line 1899
    tmp___6 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->snew));
    }
#line 1899
    if (! (tmp___6 == 0)) {
      {
#line 1901
      tmp___4 = __errno_location();
#line 1901
      tmp___5 = strerror(*tmp___4);
#line 1901
      ulog((enum tlog )1, "Can\'t set CLOCAL: %s", tmp___5);
      }
#line 1902
      return (0);
    }
  }
#line 1933
  return (1);
}
}
#line 1944 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_hardflow(struct sconnection *qconn , boolean fhardflow ) 
{ 
  register struct ssysdep_conn *q ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1951
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 1953
  if (! q->fterminal) {
#line 1954
    return (1);
  }
#line 1981
  if (fhardflow) {
    {
#line 1994
    q->snew.c_cflag |= 2147483648U;
#line 2009
    tmp___1 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->snew));
    }
#line 2009
    if (! (tmp___1 == 0)) {
      {
#line 2011
      tmp = __errno_location();
#line 2011
      tmp___0 = strerror(*tmp);
#line 2011
      ulog((enum tlog )1, "Can\'t enable hardware flow control: %s", tmp___0);
      }
#line 2013
      return (0);
    }
  } else {
    {
#line 2053
    q->snew.c_cflag &= 2147483647U;
#line 2068
    tmp___4 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->snew));
    }
#line 2068
    if (! (tmp___4 == 0)) {
      {
#line 2070
      tmp___2 = __errno_location();
#line 2070
      tmp___3 = strerror(*tmp___2);
#line 2070
      ulog((enum tlog )1, "Can\'t disable hardware flow control: %s", tmp___3);
      }
#line 2072
      return (0);
    }
  }
#line 2101
  return (1);
}
}
#line 2107 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_modem_end_dial(struct sconnection *qconn , struct uuconf_dialer *qdial ) 
{ 
  struct ssysdep_conn *q ;
  boolean tmp ;
  int onew ;
  boolean fbad ;
  int iflags ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2114
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 2116
  if ((unsigned long )(qconn->qport)->uuconf_u.uuconf_smodem.uuconf_zdial_device != (unsigned long )((void *)0)) {
    {
#line 2118
    close(q->o);
#line 2119
    q->o = q->ohold;
    }
  }
#line 2122
  if ((qconn->qport)->uuconf_u.uuconf_smodem.uuconf_fcarrier) {
#line 2122
    if (qdial->uuconf_fcarrier) {
      {
#line 2126
      tmp = fsmodem_carrier(qconn, 1);
      }
#line 2126
      if (! tmp) {
#line 2127
        return (0);
      }
      {
#line 2194
      onew = open((char const   *)q->zdevice, 2);
      }
#line 2195
      if (onew >= 0) {
        {
#line 2200
        fbad = 0;
#line 2202
        tmp___0 = fcntl(onew, 1, 0);
#line 2202
        tmp___1 = fcntl(onew, 2, tmp___0 | 1);
        }
#line 2202
        if (tmp___1 < 0) {
#line 2204
          fbad = 1;
        }
#line 2206
        if (! fbad) {
          {
#line 2208
          iflags = fcntl(onew, 3, 0);
          }
#line 2209
          if (iflags < 0) {
#line 2211
            fbad = 1;
          } else {
            {
#line 2209
            tmp___2 = tcsetattr(onew, 0, (struct termios  const  *)(& q->snew));
            }
#line 2209
            if (! (tmp___2 == 0)) {
#line 2211
              fbad = 1;
            }
          }
        }
#line 2214
        if (fbad) {
          {
#line 2215
          close(onew);
          }
        } else {
          {
#line 2218
          close(q->o);
#line 2219
          q->o = onew;
#line 2220
          q->iflags = iflags;
          }
        }
      }
    }
  }
#line 2231
  return (1);
}
}
#line 2275 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_conn_read(struct sconnection *qconn , char *zbuf___0 , size_t *pclen ,
                          size_t cmin , int ctimeout , boolean freport ) 
{ 
  size_t cwant ;
  boolean fret ;
  register struct ssysdep_conn *q ;
  int cwouldblock ;
  boolean tmp ;
  int cgot ;
  int csetmin ;
  int ierr ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  int ierr___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 2286
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 2290
  cwant = *pclen;
#line 2291
  *pclen = (size_t )0;
#line 2297
  if (ctimeout <= 0) {
#line 2298
    return (1);
  }
  {
#line 2301
  tmp = fsblock(q, 1);
  }
#line 2301
  if (! tmp) {
#line 2302
    return (0);
  }
  {
#line 2304
  fSalarm = (sig_atomic_t volatile   )0;
#line 2315
  usset_signal(14, & usalarm, 1, (boolean *)((void *)0));
#line 2316
  alarm((unsigned int )ctimeout);
#line 2325
  fret = 0;
#line 2327
  cwouldblock = 0;
  }
  {
#line 2328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2335
    if (q->fterminal) {
#line 2341
      if (cmin < 127UL) {
#line 2342
        csetmin = (int )cmin;
      } else {
#line 2344
        csetmin = 127;
      }
#line 2346
      if (csetmin != cSmin) {
#line 2348
        q->snew.c_cc[6] = (cc_t )csetmin;
        {
#line 2349
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 2349
          tmp___3 = tcsetattr(q->o, 0, (struct termios  const  *)(& q->snew));
          }
#line 2349
          if (tmp___3 == 0) {
#line 2349
            goto while_break___0;
          }
          {
#line 2351
          tmp___2 = __errno_location();
          }
#line 2351
          if (*tmp___2 != 4) {
#line 2351
            goto _L___0;
          } else
#line 2351
          if (afSignal[0]) {
#line 2351
            goto _L___0;
          } else
#line 2351
          if (afSignal[2]) {
#line 2351
            goto _L___0;
          } else
#line 2351
          if (afSignal[3]) {
#line 2351
            goto _L___0;
          } else
#line 2351
          if (afSignal[4]) {
            _L___0: /* CIL Label */ 
            {
#line 2359
            tmp___0 = __errno_location();
#line 2359
            ierr = *tmp___0;
#line 2360
            usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 2361
            alarm(0U);
#line 2363
            tmp___1 = strerror(ierr);
#line 2363
            ulog((enum tlog )1, "Can\'t set MIN for terminal: %s", tmp___1);
            }
#line 2365
            return (0);
          }
#line 2368
          if (fSalarm) {
            {
#line 2370
            ulog((enum tlog )1, "Timed out when setting MIN to %d; retrying", csetmin);
#line 2373
            fSalarm = (sig_atomic_t volatile   )0;
#line 2374
            alarm((unsigned int )ctimeout);
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2377
        cSmin = csetmin;
      }
    }
#line 2383
    if (afSignal[0]) {
#line 2384
      goto while_break;
    } else
#line 2383
    if (afSignal[2]) {
#line 2384
      goto while_break;
    } else
#line 2383
    if (afSignal[3]) {
#line 2384
      goto while_break;
    } else
#line 2383
    if (afSignal[4]) {
#line 2384
      goto while_break;
    }
#line 2388
    if (fSalarm) {
#line 2390
      fret = 1;
#line 2391
      goto while_break;
    }
    {
#line 2419
    tmp___4 = read(q->o, (void *)zbuf___0, cwant);
#line 2419
    cgot = (int )tmp___4;
    }
#line 2422
    if (cgot < 0) {
      {
#line 2424
      tmp___5 = __errno_location();
      }
#line 2424
      if (*tmp___5 == 4) {
        {
#line 2427
        ulog((enum tlog )1, (char const   *)((void *)0));
        }
      }
#line 2429
      if (fSalarm) {
#line 2431
        fret = 1;
#line 2432
        goto while_break;
      }
#line 2434
      if (afSignal[0]) {
#line 2435
        goto while_break;
      } else
#line 2434
      if (afSignal[2]) {
#line 2435
        goto while_break;
      } else
#line 2434
      if (afSignal[3]) {
#line 2435
        goto while_break;
      } else
#line 2434
      if (afSignal[4]) {
#line 2435
        goto while_break;
      }
    }
#line 2444
    if (cgot > 0) {
#line 2445
      cwouldblock = 0;
    } else
#line 2448
    if (cgot < 0) {
      {
#line 2448
      tmp___10 = __errno_location();
      }
#line 2448
      if (*tmp___10 == 4) {
#line 2449
        cgot = 0;
      } else {
#line 2448
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 2450
    if (cgot < 0) {
      {
#line 2450
      tmp___8 = __errno_location();
      }
#line 2450
      if (*tmp___8 == 11) {
#line 2450
        goto _L___3;
      } else {
        {
#line 2450
        tmp___9 = __errno_location();
        }
#line 2450
        if (*tmp___9 == 11) {
          _L___3: /* CIL Label */ 
#line 2450
          if (cwouldblock < 2) {
#line 2461
            cwouldblock ++;
#line 2462
            cgot = 0;
          } else {
#line 2450
            goto _L___2;
          }
        } else {
#line 2450
          goto _L___2;
        }
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 2468
      tmp___6 = __errno_location();
#line 2468
      ierr___0 = *tmp___6;
#line 2470
      usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 2471
      alarm(0U);
      }
#line 2474
      if (freport) {
#line 2476
        if (cgot == 0) {
          {
#line 2477
          ulog((enum tlog )1, "Line disconnected");
          }
        } else {
          {
#line 2479
          tmp___7 = strerror(ierr___0);
#line 2479
          ulog((enum tlog )1, "read: %s", tmp___7);
          }
        }
      }
#line 2482
      return (0);
    }
#line 2486
    cwant -= (size_t )cgot;
#line 2487
    if ((size_t )cgot >= cmin) {
#line 2488
      cmin = (size_t )0;
    } else {
#line 2490
      cmin -= (size_t )cgot;
    }
#line 2491
    zbuf___0 += cgot;
#line 2492
    *pclen += (size_t )cgot;
#line 2495
    if (cmin == 0UL) {
#line 2497
      fret = 1;
#line 2498
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2572
  usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 2573
  alarm(0U);
  }
#line 2576
  return (fret);
}
}
#line 2581 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsdouble_read(struct sconnection *qconn , char *zbuf___0 , size_t *pclen ,
                      size_t cmin , int ctimeout , boolean freport ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean tmp ;

  {
  {
#line 2592
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 2593
  qsysdep->o = qsysdep->ord;
#line 2594
  tmp = fsysdep_conn_read(qconn, zbuf___0, pclen, cmin, ctimeout, freport);
  }
#line 2594
  return (tmp);
}
}
#line 2600 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_conn_write(struct sconnection *qconn , char const   *zwrite , size_t cwrite ) 
{ 
  struct ssysdep_conn *q ;
  int czero ;
  boolean tmp ;
  int cdid ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 2609
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 2612
  tmp = fsblock(q, 1);
  }
#line 2612
  if (! tmp) {
#line 2613
    return (0);
  }
#line 2615
  czero = 0;
  {
#line 2617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2617
    if (! (cwrite > 0UL)) {
#line 2617
      goto while_break;
    }
    {
#line 2622
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2625
      if (afSignal[0]) {
#line 2626
        return (0);
      } else
#line 2625
      if (afSignal[2]) {
#line 2626
        return (0);
      } else
#line 2625
      if (afSignal[3]) {
#line 2626
        return (0);
      } else
#line 2625
      if (afSignal[4]) {
#line 2626
        return (0);
      }
      {
#line 2643
      tmp___0 = write(q->o, (void const   *)zwrite, cwrite);
#line 2643
      cdid = (int )tmp___0;
      }
#line 2645
      if (cdid >= 0) {
#line 2646
        goto while_break___0;
      }
      {
#line 2647
      tmp___1 = __errno_location();
      }
#line 2647
      if (*tmp___1 != 4) {
#line 2648
        goto while_break___0;
      }
      {
#line 2651
      ulog((enum tlog )1, (char const   *)((void *)0));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2654
    if (cdid < 0) {
      {
#line 2656
      tmp___4 = __errno_location();
      }
#line 2656
      if (*tmp___4 != 11) {
        {
#line 2656
        tmp___5 = __errno_location();
        }
#line 2656
        if (*tmp___5 != 11) {
          {
#line 2656
          tmp___6 = __errno_location();
          }
#line 2656
          if (*tmp___6 != 61) {
            {
#line 2658
            tmp___2 = __errno_location();
#line 2658
            tmp___3 = strerror(*tmp___2);
#line 2658
            ulog((enum tlog )1, "write: %s", tmp___3);
            }
#line 2659
            return (0);
          }
        }
      }
#line 2661
      cdid = 0;
    }
#line 2664
    if (cdid == 0) {
#line 2671
      czero ++;
#line 2672
      if (czero >= 10) {
        {
#line 2674
        ulog((enum tlog )1, "Line disconnected");
        }
#line 2675
        return (0);
      }
    } else {
#line 2680
      czero = 0;
#line 2682
      cwrite -= (size_t )cdid;
#line 2683
      zwrite += cdid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2687
  return (1);
}
}
#line 2692 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsdouble_write(struct sconnection *qconn , char const   *zwrite , size_t cwrite ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean tmp ;
  boolean tmp___0 ;

  {
  {
#line 2700
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 2701
  qsysdep->o = qsysdep->ord;
#line 2702
  tmp = fsblock(qsysdep, 1);
  }
#line 2702
  if (! tmp) {
#line 2703
    return (0);
  }
  {
#line 2704
  qsysdep->o = qsysdep->owr;
#line 2705
  tmp___0 = fsysdep_conn_write(qconn, zwrite, cwrite);
  }
#line 2705
  return (tmp___0);
}
}
#line 2714 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_conn_io(struct sconnection *qconn , char const   *zwrite , size_t *pcwrite ,
                        char *zread , size_t *pcread ) 
{ 
  struct ssysdep_conn *q ;
  size_t cwrite ;
  size_t cread ;
  int czero ;
  int cgot ;
  int cdid ;
  size_t cdo ;
  boolean tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ssize_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  struct timeval stime___0 ;
  fd_set smask ;
  int c ;
  unsigned long cwait ;
  int __d0 ;
  int __d1 ;
  int ierr ;
  boolean tmp___14 ;
  ssize_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 2726
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 2728
  cwrite = *pcwrite;
#line 2729
  *pcwrite = (size_t )0;
#line 2730
  cread = *pcread;
#line 2731
  *pcread = (size_t )0;
#line 2733
  czero = 0;
  {
#line 2735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2792
    if (q->ord >= 0) {
#line 2793
      q->o = q->ord;
    }
    {
#line 2796
    tmp = fsblock(q, 0);
    }
#line 2796
    if (! tmp) {
#line 2797
      return (0);
    }
    {
#line 2801
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2804
      if (afSignal[0]) {
#line 2805
        return (0);
      } else
#line 2804
      if (afSignal[2]) {
#line 2805
        return (0);
      } else
#line 2804
      if (afSignal[3]) {
#line 2805
        return (0);
      } else
#line 2804
      if (afSignal[4]) {
#line 2805
        return (0);
      }
      {
#line 2829
      tmp___0 = read(q->o, (void *)zread, cread);
#line 2829
      cgot = (int )tmp___0;
      }
#line 2831
      if (cgot >= 0) {
#line 2832
        goto while_break___0;
      }
      {
#line 2833
      tmp___1 = __errno_location();
      }
#line 2833
      if (*tmp___1 != 4) {
#line 2834
        goto while_break___0;
      }
      {
#line 2837
      ulog((enum tlog )1, (char const   *)((void *)0));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2840
    if (cgot < 0) {
      {
#line 2842
      tmp___4 = __errno_location();
      }
#line 2842
      if (*tmp___4 != 11) {
        {
#line 2842
        tmp___5 = __errno_location();
        }
#line 2842
        if (*tmp___5 != 11) {
          {
#line 2842
          tmp___6 = __errno_location();
          }
#line 2842
          if (*tmp___6 != 61) {
            {
#line 2844
            tmp___2 = __errno_location();
#line 2844
            tmp___3 = strerror(*tmp___2);
#line 2844
            ulog((enum tlog )1, "read: %s", tmp___3);
            }
#line 2845
            return (0);
          }
        }
      }
#line 2847
      cgot = 0;
    }
#line 2850
    cread -= (size_t )cgot;
#line 2851
    zread += cgot;
#line 2852
    *pcread += (size_t )cgot;
#line 2856
    if (cread == 0UL) {
#line 2857
      return (1);
    } else
#line 2856
    if (cwrite == 0UL) {
#line 2857
      return (1);
    }
#line 2860
    cdo = cwrite;
#line 2867
    if (q->owr >= 0) {
#line 2868
      q->o = q->owr;
    }
    {
#line 2871
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2874
      if (afSignal[0]) {
#line 2875
        return (0);
      } else
#line 2874
      if (afSignal[2]) {
#line 2875
        return (0);
      } else
#line 2874
      if (afSignal[3]) {
#line 2875
        return (0);
      } else
#line 2874
      if (afSignal[4]) {
#line 2875
        return (0);
      }
      {
#line 2897
      tmp___7 = write(q->o, (void const   *)zwrite, cdo);
#line 2897
      cdid = (int )tmp___7;
      }
#line 2899
      if (cdid >= 0) {
#line 2900
        goto while_break___1;
      }
      {
#line 2901
      tmp___8 = __errno_location();
      }
#line 2901
      if (*tmp___8 != 4) {
#line 2902
        goto while_break___1;
      }
      {
#line 2905
      ulog((enum tlog )1, (char const   *)((void *)0));
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2908
    if (cdid < 0) {
      {
#line 2910
      tmp___11 = __errno_location();
      }
#line 2910
      if (*tmp___11 != 11) {
        {
#line 2910
        tmp___12 = __errno_location();
        }
#line 2910
        if (*tmp___12 != 11) {
          {
#line 2910
          tmp___13 = __errno_location();
          }
#line 2910
          if (*tmp___13 != 61) {
            {
#line 2912
            tmp___9 = __errno_location();
#line 2912
            tmp___10 = strerror(*tmp___9);
#line 2912
            ulog((enum tlog )1, "write: %s", tmp___10);
            }
#line 2913
            return (0);
          }
        }
      }
#line 2915
      cdid = 0;
    }
#line 2918
    if (cdid > 0) {
#line 2922
      cwrite -= (size_t )cdid;
#line 2923
      zwrite += cdid;
#line 2924
      *pcwrite += (size_t )cdid;
#line 2926
      if (cwrite == 0UL) {
#line 2927
        return (1);
      }
#line 2929
      czero = 0;
    } else {
#line 2952
      if (q->fterminal) {
#line 2956
        cwait = 1024UL;
#line 2957
        if (cwait > cread) {
#line 2958
          cwait = cread;
        }
#line 2959
        stime___0.tv_sec = (__time_t )((cwait * 10UL) / (unsigned long )q->ibaud);
#line 2960
        stime___0.tv_usec = (__suseconds_t )((((cwait * 1000000UL) / (unsigned long )q->ibaud) * 10UL) % 1000000UL);
      } else {
#line 2972
        stime___0.tv_sec = (__time_t )1;
#line 2973
        stime___0.tv_usec = (__suseconds_t )0;
      }
      {
#line 2977
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2977
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& smask.__fds_bits[0]): "memory");
#line 2977
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2978
      smask.__fds_bits[q->o / (8 * (int )sizeof(__fd_mask ))] |= 1L << q->o % (8 * (int )sizeof(__fd_mask ));
#line 2986
      if (afSignal[0]) {
#line 2987
        return (0);
      } else
#line 2986
      if (afSignal[2]) {
#line 2987
        return (0);
      } else
#line 2986
      if (afSignal[3]) {
#line 2987
        return (0);
      } else
#line 2986
      if (afSignal[4]) {
#line 2987
        return (0);
      }
      {
#line 2989
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2989
        if ((iDebug & 32) != 0) {
          {
#line 2989
          ulog((enum tlog )3, "fsysdep_conn_io: Calling select");
          }
        }
#line 2989
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 2993
      c = select(q->o + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((pointer )(& smask)),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& stime___0));
      }
#line 2995
      if (c < 0) {
        {
#line 2995
        tmp___18 = __errno_location();
        }
#line 2995
        if (*tmp___18 == 4) {
          {
#line 2998
          ulog((enum tlog )1, (char const   *)((void *)0));
          }
        } else {
#line 2995
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 3000
      if (! (c >= 0)) {
#line 3031
        if (q->ord >= 0) {
#line 3032
          q->o = q->ord;
        }
        {
#line 3034
        tmp___14 = fsblock(q, 1);
        }
#line 3034
        if (! tmp___14) {
#line 3035
          return (0);
        }
        {
#line 3037
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3037
          if ((iDebug & 32) != 0) {
            {
#line 3037
            ulog((enum tlog )3, "fsysdep_conn_io: Blocking write");
            }
          }
#line 3037
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3039
        if (q->owr >= 0) {
#line 3040
          q->o = q->owr;
        }
#line 3043
        if (afSignal[0]) {
#line 3044
          return (0);
        } else
#line 3043
        if (afSignal[2]) {
#line 3044
          return (0);
        } else
#line 3043
        if (afSignal[3]) {
#line 3044
          return (0);
        } else
#line 3043
        if (afSignal[4]) {
#line 3044
          return (0);
        }
        {
#line 3049
        usset_signal(14, & usalarm, 1, (boolean *)((void *)0));
        }
#line 3050
        if (q->fterminal) {
          {
#line 3051
          alarm((unsigned int )((int )(10240L / q->ibaud) + 1));
          }
        } else {
          {
#line 3053
          alarm(1U);
          }
        }
        {
#line 3076
        tmp___15 = write(q->o, (void const   *)zwrite, (size_t )1);
#line 3076
        cdid = (int )tmp___15;
#line 3078
        tmp___16 = __errno_location();
#line 3078
        ierr = *tmp___16;
#line 3086
        usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 3087
        alarm(0U);
        }
#line 3089
        if (cdid < 0) {
#line 3091
          if (ierr == 4) {
            {
#line 3094
            ulog((enum tlog )1, (char const   *)((void *)0));
            }
          } else {
            {
#line 3098
            tmp___17 = strerror(ierr);
#line 3098
            ulog((enum tlog )1, "write: %s", tmp___17);
            }
#line 3099
            return (0);
          }
        } else
#line 3102
        if (cdid == 0) {
#line 3110
          czero ++;
#line 3111
          if (czero >= 10) {
            {
#line 3113
            ulog((enum tlog )1, "Line disconnected");
            }
#line 3114
            return (0);
          }
        } else {
#line 3119
          cwrite -= (size_t )cdid;
#line 3120
          zwrite += cdid;
#line 3121
          *pcwrite += (size_t )cdid;
#line 3122
          czero = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3131 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_break(struct sconnection *qconn ) 
{ 
  struct ssysdep_conn *q ;
  int tmp ;

  {
  {
#line 3137
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 3150
  tmp = tcsendbreak(q->o, 0);
  }
#line 3150
  return (tmp == 0);
}
}
#line 3156 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsstdin_break(struct sconnection *qconn ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean tmp ;

  {
  {
#line 3162
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 3163
  qsysdep->o = qsysdep->owr;
#line 3164
  tmp = fsserial_break(qconn);
  }
#line 3164
  return (tmp);
}
}
#line 3170 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsserial_set(struct sconnection *qconn , enum tparitysetting tparity ,
                            enum tstripsetting tstrip , enum txonxoffsetting txonxoff ) 
{ 
  register struct ssysdep_conn *q ;
  boolean fchanged ;
  boolean fdo ;
  unsigned int iset ;
  unsigned int iclear ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp13 ;

  {
#line 3179
  iset = 0U;
#line 3180
  iclear = 0U;
#line 3182
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 3184
  if (! q->fterminal) {
#line 3185
    return (1);
  }
#line 3187
  fchanged = 0;
#line 3240
  fdo = 0;
  {
#line 3243
  if ((unsigned int )tparity == 0U) {
#line 3243
    goto case_0;
  }
#line 3245
  if ((unsigned int )tparity == 1U) {
#line 3245
    goto case_1;
  }
#line 3250
  if ((unsigned int )tparity == 2U) {
#line 3250
    goto case_2;
  }
#line 3255
  if ((unsigned int )tparity == 3U) {
#line 3255
    goto case_3;
  }
#line 3261
  if ((unsigned int )tparity == 5U) {
#line 3261
    goto case_5;
  }
#line 3261
  if ((unsigned int )tparity == 4U) {
#line 3261
    goto case_5;
  }
#line 3241
  goto switch_break;
  case_0: /* CIL Label */ 
#line 3244
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3246
  iset = 48U;
#line 3247
  iclear = 768U;
#line 3248
  fdo = 1;
#line 3249
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3251
  iset = 288U;
#line 3252
  iclear = 528U;
#line 3253
  fdo = 1;
#line 3254
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3256
  iset = 800U;
#line 3257
  iclear = 16U;
#line 3258
  fdo = 1;
#line 3259
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 3263
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3266
  if (fdo) {
#line 3268
    if ((q->snew.c_cflag & iset) != iset) {
#line 3271
      q->snew.c_cflag |= iset;
#line 3272
      q->snew.c_cflag &= ~ iclear;
#line 3273
      fchanged = 1;
    } else
#line 3268
    if ((q->snew.c_cflag & iclear) != 0U) {
#line 3271
      q->snew.c_cflag |= iset;
#line 3272
      q->snew.c_cflag &= ~ iclear;
#line 3273
      fchanged = 1;
    }
  }
#line 3303
  fdo = 0;
  {
#line 3306
  if ((unsigned int )tstrip == 0U) {
#line 3306
    goto case_0___0;
  }
#line 3308
  if ((unsigned int )tstrip == 1U) {
#line 3308
    goto case_1___0;
  }
#line 3313
  if ((unsigned int )tstrip == 2U) {
#line 3313
    goto case_2___0;
  }
#line 3304
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 3307
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 3309
  iset = 0U;
#line 3310
  iclear = 32U;
#line 3311
  fdo = 1;
#line 3312
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 3314
  iset = 32U;
#line 3315
  iclear = 0U;
#line 3316
  fdo = 1;
#line 3317
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3320
  if (fdo) {
#line 3322
    if ((q->snew.c_iflag & iset) != iset) {
#line 3325
      q->snew.c_iflag |= iset;
#line 3326
      q->snew.c_iflag &= ~ iclear;
#line 3327
      fchanged = 1;
    } else
#line 3322
    if ((q->snew.c_iflag & iclear) != 0U) {
#line 3325
      q->snew.c_iflag |= iset;
#line 3326
      q->snew.c_iflag &= ~ iclear;
#line 3327
      fchanged = 1;
    }
  }
#line 3367
  fdo = 0;
  {
#line 3370
  if ((unsigned int )txonxoff == 0U) {
#line 3370
    goto case_0___1;
  }
#line 3372
  if ((unsigned int )txonxoff == 1U) {
#line 3372
    goto case_1___1;
  }
#line 3377
  if ((unsigned int )txonxoff == 2U) {
#line 3377
    goto case_2___1;
  }
#line 3368
  goto switch_break___1;
  case_0___1: /* CIL Label */ 
#line 3371
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 3373
  iset = 0U;
#line 3374
  iclear = 5120U;
#line 3375
  fdo = 1;
#line 3376
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 3383
  if ((q->snew.c_cflag & 2147483648U) != 0U) {
#line 3385
    iset = 1024U;
#line 3386
    iclear = 4096U;
#line 3387
    fdo = 1;
#line 3388
    goto switch_break___1;
  }
#line 3408
  iset = 5120U;
#line 3409
  iclear = 0U;
#line 3410
  fdo = 1;
#line 3411
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 3414
  if (fdo) {
#line 3416
    if ((q->snew.c_iflag & iset) != iset) {
#line 3419
      q->snew.c_iflag |= iset;
#line 3420
      q->snew.c_iflag &= ~ iclear;
#line 3421
      fchanged = 1;
    } else
#line 3416
    if ((q->snew.c_iflag & iclear) != 0U) {
#line 3419
      q->snew.c_iflag |= iset;
#line 3420
      q->snew.c_iflag &= ~ iclear;
#line 3421
      fchanged = 1;
    }
  }
#line 3427
  if (fchanged) {
    {
#line 3429
    tmp___1 = tcsetattr(q->o, 1, (struct termios  const  *)(& q->snew));
    }
#line 3429
    if (! (tmp___1 == 0)) {
      {
#line 3431
      tmp = __errno_location();
#line 3431
      tmp___0 = strerror(*tmp);
#line 3431
      ulog((enum tlog )1, "Can\'t change terminal settings: %s", tmp___0);
      }
#line 3433
      return (0);
    }
  }
#line 3478
  return (1);
}
}
#line 3483 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsstdin_set(struct sconnection *qconn , enum tparitysetting tparity ,
                           enum tstripsetting tstrip , enum txonxoffsetting txonxoff ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean tmp ;

  {
  {
#line 3492
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 3493
  qsysdep->o = qsysdep->ord;
#line 3494
  tmp = fsserial_set(qconn, tparity, tstrip, txonxoff);
  }
#line 3494
  return (tmp);
}
}
#line 3499 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static boolean fsrun_chat(int oread , int owrite , char **pzprog ) 
{ 
  int aidescs[3] ;
  FILE *e ;
  pid_t ipid ;
  char *z ;
  size_t c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t clen ;
  __ssize_t tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 3511
  aidescs[0] = oread;
#line 3512
  aidescs[1] = owrite;
#line 3513
  aidescs[2] = -2;
#line 3517
  ipid = ixsspawn((char const   **)pzprog, aidescs, 1, 1, (char const   *)((void *)0),
                  0, 1, (char const   *)((void *)0), (char const   *)((void *)0),
                  (char const   *)((void *)0));
  }
#line 3520
  if (ipid < 0) {
    {
#line 3522
    tmp = __errno_location();
#line 3522
    tmp___0 = strerror(*tmp);
#line 3522
    ulog((enum tlog )1, "ixsspawn (%s): %s", *(pzprog + 0), tmp___0);
    }
#line 3523
    return (0);
  }
  {
#line 3526
  e = fdopen(aidescs[2], (char const   *)((char *)"r"));
  }
#line 3527
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 3529
    tmp___1 = __errno_location();
#line 3529
    tmp___2 = strerror(*tmp___1);
#line 3529
    ulog((enum tlog )1, "fdopen: %s", tmp___2);
#line 3530
    close(aidescs[2]);
#line 3531
    kill(ipid, 9);
#line 3532
    ixswait((unsigned long )ipid, (char const   *)((void *)0));
    }
#line 3533
    return (0);
  }
#line 3538
  z = (char *)((void *)0);
#line 3539
  c = (size_t )0;
  {
#line 3540
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3540
    tmp___3 = getline((char **/* __restrict  */)(& z), (size_t */* __restrict  */)(& c),
                      (FILE */* __restrict  */)e);
    }
#line 3540
    if (! (tmp___3 > 0L)) {
#line 3540
      goto while_break;
    }
    {
#line 3544
    clen = strlen((char const   *)z);
    }
#line 3545
    if ((int )*(z + (clen - 1UL)) == 10) {
#line 3546
      *(z + (clen - 1UL)) = (char )'\000';
    }
#line 3547
    if ((int )*z != 0) {
      {
#line 3548
      ulog((enum tlog )0, "chat: %s", z);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3551
  xfree((pointer )z);
#line 3552
  fclose(e);
#line 3554
  tmp___4 = ixswait((unsigned long )ipid, "Chat program");
  }
#line 3554
  return (tmp___4 == 0);
}
}
#line 3560 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsdouble_chat(struct sconnection *qconn , char **pzprog ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean fret ;
  int tmp ;

  {
  {
#line 3568
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 3569
  fret = fsrun_chat(qsysdep->ord, qsysdep->owr, pzprog);
  }
#line 3570
  if (qsysdep->fterminal) {
    {
#line 3571
    tmp = tcgetattr(qsysdep->ord, & qsysdep->snew);
    }
  }
#line 3572
  return (fret);
}
}
#line 3577 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
boolean fsysdep_conn_chat(struct sconnection *qconn , char **pzprog ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean fret ;
  int tmp ;

  {
  {
#line 3585
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 3586
  fret = fsrun_chat(qsysdep->o, qsysdep->o, pzprog);
  }
#line 3587
  if (qsysdep->fterminal) {
    {
#line 3588
    tmp = tcgetattr(qsysdep->o, & qsysdep->snew);
    }
  }
#line 3589
  return (fret);
}
}
#line 3594 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/serial.c"
static long isserial_baud(struct sconnection *qconn ) 
{ 
  struct ssysdep_conn *qsysdep ;

  {
#line 3600
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 3601
  return (qsysdep->ibaud);
}
}
#line 269 "../system.h"
long ixsysdep_get_sequence(struct uuconf_system  const  *qsys ) ;
#line 41 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/seq.c"
long ixsysdep_get_sequence(struct uuconf_system  const  *qsys ) 
{ 
  FILE *e ;
  char *zname ;
  struct stat s ;
  long iseq ;
  boolean fok ;
  char *zline ;
  size_t cline ;
  int *tmp ;
  char *tmp___0 ;
  char *zend ;
  __ssize_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 56
  zname = zsysdep_in_dir(".Sequence", (char const   *)qsys->uuconf_zname);
#line 59
  iseq = 0L;
#line 60
  tmp___2 = stat((char const   */* __restrict  */)zname, (struct stat */* __restrict  */)(& s));
  }
#line 60
  if (tmp___2 == 0) {
#line 67
    if ((s.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) != 0U) {
      {
#line 69
      ulog((enum tlog )1, "Bad file protection for conversation sequence file");
#line 71
      ubuffree(zname);
      }
#line 72
      return (-1L);
    }
    {
#line 75
    e = fopen((char const   */* __restrict  */)zname, (char const   */* __restrict  */)"r+");
    }
#line 76
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      {
#line 78
      tmp = __errno_location();
#line 78
      tmp___0 = strerror(*tmp);
#line 78
      ulog((enum tlog )1, "fopen (%s): %s", zname, tmp___0);
#line 79
      ubuffree(zname);
      }
#line 80
      return (-1L);
    }
    {
#line 83
    ubuffree(zname);
#line 85
    fok = 1;
#line 86
    zline = (char *)((void *)0);
#line 87
    cline = (size_t )0;
#line 88
    tmp___1 = getline((char **/* __restrict  */)(& zline), (size_t */* __restrict  */)(& cline),
                      (FILE */* __restrict  */)e);
    }
#line 88
    if (tmp___1 <= 0L) {
#line 89
      fok = 0;
    } else {
      {
#line 94
      iseq = strtol((char const   */* __restrict  */)zline, (char **/* __restrict  */)(& zend),
                    10);
      }
#line 95
      if ((unsigned long )zend == (unsigned long )zline) {
#line 96
        fok = 0;
      }
    }
    {
#line 99
    xfree((pointer )zline);
    }
#line 101
    if (! fok) {
      {
#line 103
      ulog((enum tlog )1, "Bad format for conversation sequence file");
#line 104
      fclose(e);
      }
#line 105
      return (-1L);
    }
    {
#line 108
    rewind(e);
    }
  } else {
    {
#line 112
    e = esysdep_fopen((char const   *)zname, 0, 0, 1);
#line 113
    ubuffree(zname);
    }
#line 114
    if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 115
      return (-1L);
    }
  }
  {
#line 118
  iseq ++;
#line 120
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"%ld", iseq);
#line 122
  tmp___5 = fclose(e);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 124
    tmp___3 = __errno_location();
#line 124
    tmp___4 = strerror(*tmp___3);
#line 124
    ulog((enum tlog )1, "fclose: %s", tmp___4);
    }
#line 125
    return (-1L);
  }
#line 128
  return (iseq);
}
}
#line 333 "../uudefs.h"
void ulog_close(void) ;
#line 97 "../system.h"
void usysdep_detach(void) ;
#line 220
boolean fsysdep_run(boolean ffork , char const   *zprogram , char const   *zarg1 ,
                    char const   *zarg2 ) ;
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/run.c"
boolean fsysdep_run(boolean ffork , char const   *zprogram , char const   *zarg1 ,
                    char const   *zarg2 ) 
{ 
  char *zlib ;
  char const   *azargs[4] ;
  int aidescs[3] ;
  pid_t ipid ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 49
  if (ffork) {
    {
#line 51
    ipid = ixsfork();
    }
#line 52
    if (ipid < 0) {
      {
#line 54
      tmp = __errno_location();
#line 54
      tmp___0 = strerror(*tmp);
#line 54
      ulog((enum tlog )1, "fork: %s", tmp___0);
      }
#line 55
      return (0);
    }
#line 58
    if (ipid != 0) {
      {
#line 62
      ixswait((unsigned long )ipid, (char const   *)((void *)0));
#line 67
      ulog_close();
      }
#line 69
      return (1);
    }
    {
#line 76
    usysdep_detach();
    }
  }
  {
#line 81
  tmp___1 = strlen(zprogram);
#line 81
  zlib = zbufalc((sizeof("/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/sbin") + sizeof("/")) + tmp___1);
#line 82
  sprintf((char */* __restrict  */)zlib, (char const   */* __restrict  */)"%s/%s",
          "/home/wslee/gnu_benchmarks/uucp-1.07/sparrow/sbin", zprogram);
#line 84
  azargs[0] = (char const   *)zlib;
#line 85
  azargs[1] = zarg1;
#line 86
  azargs[2] = zarg2;
#line 87
  azargs[3] = (char const   *)((void *)0);
#line 89
  aidescs[0] = -1;
#line 90
  aidescs[1] = -1;
#line 91
  aidescs[2] = -1;
#line 95
  ipid = ixsspawn(azargs, aidescs, 1, 0, (char const   *)((void *)0), 0, 1, (char const   *)((void *)0),
                  (char const   *)((void *)0), (char const   *)((void *)0));
#line 98
  ubuffree(zlib);
  }
#line 100
  if (ipid < 0) {
    {
#line 102
    tmp___2 = __errno_location();
#line 102
    tmp___3 = strerror(*tmp___2);
#line 102
    ulog((enum tlog )1, "ixsspawn: %s", tmp___3);
    }
#line 103
    if (ffork) {
      {
#line 104
      _exit(1);
      }
    }
#line 105
    return (0);
  }
#line 108
  if (ffork) {
    {
#line 109
    _exit(0);
    }
  }
#line 111
  return (1);
}
}
#line 492 "../system.h"
boolean fsysdep_remember_reception(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                                   char const   *ztemp ) ;
#line 501
boolean fsysdep_already_received(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                                 char const   *ztemp ) ;
#line 510
boolean fsysdep_forget_reception(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                                 char const   *ztemp ) ;
#line 46 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/recep.c"
static char *zsreceived_name(struct uuconf_system  const  *qsys , char const   *ztemp ) ;
#line 72 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/recep.c"
static char *zsreceived_name(struct uuconf_system  const  *qsys , char const   *ztemp ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 77
  if ((unsigned long )ztemp != (unsigned long )((void *)0)) {
#line 77
    if ((int const   )*ztemp == 68) {
      {
#line 77
      tmp___0 = strcmp(ztemp, "D.0");
      }
#line 77
      if (tmp___0 != 0) {
        {
#line 80
        tmp = zsappend3(".Received", (char const   *)qsys->uuconf_zname, ztemp);
        }
#line 80
        return (tmp);
      } else {
#line 82
        return ((char *)((void *)0));
      }
    } else {
#line 82
      return ((char *)((void *)0));
    }
  } else {
#line 82
    return ((char *)((void *)0));
  }
}
}
#line 88 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/recep.c"
boolean fsysdep_remember_reception(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                                   char const   *ztemp ) 
{ 
  char *zfile ;
  int o ;
  boolean tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 97
  zfile = zsreceived_name(qsys, ztemp);
  }
#line 98
  if ((unsigned long )zfile == (unsigned long )((void *)0)) {
#line 99
    return (1);
  }
  {
#line 100
  o = creat((char const   *)zfile, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
  }
#line 101
  if (o < 0) {
    {
#line 103
    tmp___0 = __errno_location();
    }
#line 103
    if (*tmp___0 == 2) {
      {
#line 105
      tmp = fsysdep_make_dirs((char const   *)zfile, 0);
      }
#line 105
      if (tmp) {
        {
#line 107
        ubuffree(zfile);
        }
#line 108
        return (0);
      }
      {
#line 110
      o = creat((char const   *)zfile, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
      }
    }
#line 112
    if (o < 0) {
      {
#line 114
      tmp___1 = __errno_location();
#line 114
      tmp___2 = strerror(*tmp___1);
#line 114
      ulog((enum tlog )1, "creat (%s): %s", zfile, tmp___2);
#line 115
      ubuffree(zfile);
      }
#line 116
      return (0);
    }
  }
  {
#line 120
  ubuffree(zfile);
#line 125
  tmp___5 = close(o);
  }
#line 125
  if (tmp___5 < 0) {
    {
#line 127
    tmp___3 = __errno_location();
#line 127
    tmp___4 = strerror(*tmp___3);
#line 127
    ulog((enum tlog )1, "fsysdep_remember_reception: close: %s", tmp___4);
    }
#line 129
    return (0);
  }
#line 132
  return (1);
}
}
#line 145 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/recep.c"
boolean fsysdep_already_received(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                                 char const   *ztemp ) 
{ 
  char *zfile ;
  struct stat s ;
  boolean fret ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 155
  zfile = zsreceived_name(qsys, ztemp);
  }
#line 156
  if ((unsigned long )zfile == (unsigned long )((void *)0)) {
#line 157
    return (0);
  }
  {
#line 158
  tmp___2 = stat((char const   */* __restrict  */)zfile, (struct stat */* __restrict  */)(& s));
  }
#line 158
  if (tmp___2 < 0) {
    {
#line 160
    tmp___1 = __errno_location();
    }
#line 160
    if (*tmp___1 != 2) {
      {
#line 161
      tmp = __errno_location();
#line 161
      tmp___0 = strerror(*tmp);
#line 161
      ulog((enum tlog )1, "stat (%s): %s", zfile, tmp___0);
      }
    }
    {
#line 162
    ubuffree(zfile);
    }
#line 163
    return (0);
  }
  {
#line 167
  tmp___3 = time((time_t *)((void *)0));
#line 167
  fret = s.st_mtim.tv_sec + 604800L >= tmp___3;
  }
#line 169
  if (fret) {
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 170
      if ((iDebug & 128) != 0) {
        {
#line 170
        ulog((enum tlog )3, "fsysdep_already_received: Found %s", zfile);
        }
      }
#line 170
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 173
  ubuffree(zfile);
  }
#line 175
  return (fret);
}
}
#line 181 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/recep.c"
boolean fsysdep_forget_reception(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                                 char const   *ztemp ) 
{ 
  char *zfile ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 189
  zfile = zsreceived_name(qsys, ztemp);
  }
#line 190
  if ((unsigned long )zfile == (unsigned long )((void *)0)) {
#line 191
    return (1);
  }
  {
#line 192
  tmp___1 = remove((char const   *)zfile);
  }
#line 192
  if (tmp___1 < 0) {
    {
#line 192
    tmp___2 = __errno_location();
    }
#line 192
    if (*tmp___2 != 2) {
      {
#line 195
      tmp = __errno_location();
#line 195
      tmp___0 = strerror(*tmp);
#line 195
      ulog((enum tlog )1, "remove (%s): %s", zfile, tmp___0);
#line 196
      ubuffree(zfile);
      }
#line 197
      return (0);
    }
  }
#line 199
  return (1);
}
}
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 114 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/proctm.c"
long ixsysdep_process_time(long *pimicros ) 
{ 
  struct timeval stime___0 ;
  struct timezone stz ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 122
  gettimeofday((struct timeval */* __restrict  */)(& stime___0), (__timezone_ptr_t )(& stz));
  }
#line 123
  if ((unsigned long )pimicros != (unsigned long )((void *)0)) {
#line 124
    *pimicros = stime___0.tv_usec;
  }
#line 125
  return (stime___0.tv_sec);
}
}
#line 17 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/priv.c"
boolean fsysdep_privileged(void) 
{ 
  uid_t iuid ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 22
  iuid = getuid();
  }
#line 23
  if (iuid == 0U) {
#line 23
    tmp___0 = 1;
  } else {
    {
#line 23
    tmp = geteuid();
    }
#line 23
    if (iuid == tmp) {
#line 23
      tmp___0 = 1;
    } else {
#line 23
      tmp___0 = 0;
    }
  }
#line 23
  return (tmp___0);
}
}
#line 786 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 119 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 25 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/portnm.c"
char const   *zsysdep_port_name(boolean *ftcp_port ) 
{ 
  char const   *z ;
  size_t clen ;
  struct sockaddr s ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 31
  *ftcp_port = 0;
#line 38
  clen = sizeof(struct sockaddr );
#line 39
  tmp = getsockname(0, (struct sockaddr */* __restrict  */)(& s), (socklen_t */* __restrict  */)(& clen));
  }
#line 39
  if (tmp == 0) {
#line 40
    *ftcp_port = 1;
  }
  {
#line 44
  tmp___0 = ttyname(0);
#line 44
  z = (char const   *)tmp___0;
  }
#line 45
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 46
    return ((char const   *)((void *)0));
  }
  {
#line 47
  tmp___1 = strncmp(z, "/dev/", sizeof("/dev/") - 1UL);
  }
#line 47
  if (tmp___1 == 0) {
#line 48
    return ((z + sizeof("/dev/")) - 1);
  } else {
#line 50
    return (z);
  }
}
}
#line 29 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
char const   pipe_rcsid[49]  = 
#line 29 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'i',      (char const   )'p', 
        (char const   )'e',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'1',      (char const   )'0',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 325 "../conn.h"
boolean fsysdep_pipe_init(struct sconnection *qconn ) ;
#line 50 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
static void uspipe_free(struct sconnection *qconn ) ;
#line 51
static boolean fspipe_open(struct sconnection *qconn  __attribute__((__unused__)) ,
                           long ibaud  __attribute__((__unused__)) , boolean fwait ,
                           boolean fuser  __attribute__((__unused__)) ) ;
#line 53
static boolean fspipe_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                            struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                            boolean fsuccess  __attribute__((__unused__)) ) ;
#line 57
static boolean fspipe_dial(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys  __attribute__((__unused__)) ,
                           char const   *zphone  __attribute__((__unused__)) , struct uuconf_dialer *qdialer ,
                           enum tdialerfound *ptdialer ) ;
#line 65 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
static struct sconncmds  const  spipecmds  = 
#line 65
     {& uspipe_free, (boolean (*)(struct sconnection *qconn , boolean fin , boolean fuser ))((void *)0),
    (boolean (*)(struct sconnection *qconn ))((void *)0), & fspipe_open, & fspipe_close,
    & fspipe_dial, & fsdouble_read, & fsdouble_write, & fsysdep_conn_io, (boolean (*)(struct sconnection *qconn ))((void *)0),
    (boolean (*)(struct sconnection *qconn , enum tparitysetting tparity , enum tstripsetting tstrip ,
                 enum txonxoffsetting txonxoff ))((void *)0), (boolean (*)(struct sconnection *qconn ,
                                                                           boolean fcarrier ))((void *)0),
    & fsdouble_chat, (long (*)(struct sconnection *qconn ))((void *)0)};
#line 85 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
boolean fsysdep_pipe_init(struct sconnection *qconn ) 
{ 
  struct ssysdep_conn *q ;
  pointer tmp ;

  {
  {
#line 91
  tmp = xmalloc(sizeof(struct ssysdep_conn ));
#line 91
  q = (struct ssysdep_conn *)tmp;
#line 92
  q->o = -1;
#line 93
  q->ord = -1;
#line 94
  q->owr = -1;
#line 95
  q->zdevice = (char *)((void *)0);
#line 96
  q->iflags = -1;
#line 97
  q->iwr_flags = -1;
#line 98
  q->fterminal = 0;
#line 99
  q->ftli = 0;
#line 100
  q->ibaud = 0L;
#line 101
  q->ipid = -1;
#line 102
  qconn->psysdep = (pointer )q;
#line 103
  qconn->qcmds = & spipecmds;
  }
#line 104
  return (1);
}
}
#line 107 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
static void uspipe_free(struct sconnection *qconn ) 
{ 


  {
  {
#line 111
  xfree(qconn->psysdep);
  }
#line 112
  return;
}
}
#line 117 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
static boolean fspipe_open(struct sconnection *qconn  __attribute__((__unused__)) ,
                           long ibaud  __attribute__((__unused__)) , boolean fwait ,
                           boolean fuser  __attribute__((__unused__)) ) 
{ 


  {
#line 125
  if (fwait) {
#line 126
    return (0);
  }
#line 128
  return (1);
}
}
#line 134 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
static boolean fspipe_close(struct sconnection *qconn , pointer puuconf  __attribute__((__unused__)) ,
                            struct uuconf_dialer *qdialer  __attribute__((__unused__)) ,
                            boolean fsuccess  __attribute__((__unused__)) ) 
{ 
  struct ssysdep_conn *qsysdep ;
  boolean fret ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 144
  qsysdep = (struct ssysdep_conn *)qconn->psysdep;
#line 145
  fret = 1;
#line 148
  if (qsysdep->ord >= 0) {
    {
#line 148
    tmp___1 = close(qsysdep->ord);
    }
#line 148
    if (tmp___1 < 0) {
      {
#line 150
      tmp = __errno_location();
#line 150
      tmp___0 = strerror(*tmp);
#line 150
      ulog((enum tlog )1, "fspipe_close: close read fd: %s", tmp___0);
#line 151
      fret = 0;
      }
    }
  }
#line 153
  if (qsysdep->owr != qsysdep->ord) {
#line 153
    if (qsysdep->owr >= 0) {
      {
#line 153
      tmp___4 = close(qsysdep->owr);
      }
#line 153
      if (tmp___4 < 0) {
        {
#line 157
        tmp___2 = __errno_location();
#line 157
        tmp___3 = strerror(*tmp___2);
#line 157
        ulog((enum tlog )1, "fspipe_close: close write fd: %s", tmp___3);
#line 158
        fret = 0;
        }
      }
    }
  }
#line 160
  qsysdep->ord = -1;
#line 161
  qsysdep->owr = -1;
#line 164
  if (qsysdep->ipid >= 0) {
    {
#line 166
    tmp___5 = kill(qsysdep->ipid, 1);
    }
#line 166
    if (tmp___5 == 0) {
      {
#line 167
      usysdep_sleep(2);
      }
    }
    {
#line 169
    tmp___6 = kill(qsysdep->ipid, 13);
    }
#line 169
    if (tmp___6 == 0) {
      {
#line 170
      usysdep_sleep(2);
      }
    }
    {
#line 172
    tmp___9 = kill(qsysdep->ipid, 9);
    }
#line 172
    if (tmp___9 < 0) {
      {
#line 172
      tmp___10 = __errno_location();
      }
#line 172
      if (*tmp___10 == 1) {
        {
#line 174
        tmp___7 = __errno_location();
#line 174
        tmp___8 = strerror(*tmp___7);
#line 174
        ulog((enum tlog )1, "fspipe_close: Cannot kill child pid %lu: %s", (unsigned long )qsysdep->ipid,
             tmp___8);
#line 176
        fret = 0;
        }
      } else {
        {
#line 179
        ixswait((unsigned long )qsysdep->ipid, (char const   *)((void *)0));
        }
      }
    } else {
      {
#line 179
      ixswait((unsigned long )qsysdep->ipid, (char const   *)((void *)0));
      }
    }
  }
#line 181
  qsysdep->ipid = -1;
#line 182
  return (fret);
}
}
#line 190 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pipe.c"
static boolean fspipe_dial(struct sconnection *qconn , pointer puuconf , struct uuconf_system  const  *qsys  __attribute__((__unused__)) ,
                           char const   *zphone  __attribute__((__unused__)) , struct uuconf_dialer *qdialer ,
                           enum tdialerfound *ptdialer ) 
{ 
  struct ssysdep_conn *q ;
  int aidescs[3] ;
  char const   **pzprog ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 203
  q = (struct ssysdep_conn *)qconn->psysdep;
#line 205
  *ptdialer = (enum tdialerfound )0;
#line 207
  pzprog = (char const   **)(qconn->qport)->uuconf_u.uuconf_spipe.uuconf_pzcmd;
#line 209
  if ((unsigned long )pzprog == (unsigned long )((void *)0)) {
    {
#line 211
    ulog((enum tlog )1, "No command for pipe connection");
    }
#line 212
    return (0);
  }
  {
#line 215
  aidescs[0] = -3;
#line 216
  aidescs[1] = -2;
#line 217
  aidescs[2] = -1;
#line 221
  q->ipid = ixsspawn(pzprog, aidescs, 1, 1, (char const   *)((void *)0), 0, 1, (char const   *)((void *)0),
                     (char const   *)((void *)0), (char const   *)((void *)0));
  }
#line 224
  if (q->ipid < 0) {
    {
#line 226
    tmp = __errno_location();
#line 226
    tmp___0 = strerror(*tmp);
#line 226
    ulog((enum tlog )1, "ixsspawn (%s): %s", *(pzprog + 0), tmp___0);
    }
#line 227
    return (0);
  }
  {
#line 230
  q->owr = aidescs[0];
#line 231
  q->ord = aidescs[1];
#line 232
  q->o = q->ord;
#line 234
  q->iflags = fcntl(q->ord, 3, 0);
#line 235
  q->iwr_flags = fcntl(q->owr, 3, 0);
  }
#line 236
  if (q->iflags < 0) {
    {
#line 238
    tmp___1 = __errno_location();
#line 238
    tmp___2 = strerror(*tmp___1);
#line 238
    ulog((enum tlog )1, "fspipe_dial: fcntl: %s", tmp___2);
#line 239
    fspipe_close(qconn, puuconf, qdialer, 0);
    }
#line 240
    return (0);
  } else
#line 236
  if (q->iwr_flags < 0) {
    {
#line 238
    tmp___1 = __errno_location();
#line 238
    tmp___2 = strerror(*tmp___1);
#line 238
    ulog((enum tlog )1, "fspipe_dial: fcntl: %s", tmp___2);
#line 239
    fspipe_close(qconn, puuconf, qdialer, 0);
    }
#line 240
    return (0);
  }
#line 243
  return (1);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
char const   picksb_rcsid[51]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'i',      (char const   )'c', 
        (char const   )'k',      (char const   )'s',      (char const   )'b',      (char const   )'.', 
        (char const   )'c',      (char const   )',',      (char const   )'v',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'3', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )'/',      (char const   )'0',      (char const   )'3', 
        (char const   )'/',      (char const   )'0',      (char const   )'5',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'1', 
        (char const   )'0',      (char const   )':',      (char const   )'4',      (char const   )'2', 
        (char const   )' ',      (char const   )'i',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'R',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 715 "../system.h"
char *zsysdep_local_file_cwd(char const   *zfile , char const   *zpubdir , boolean *pfbadname ) ;
#line 975
boolean fsysdep_uupick_init(char const   *zsystem  __attribute__((__unused__)) , char const   *zpubdir ) ;
#line 985
char *zsysdep_uupick(char const   *zsysarg , char const   *zpubdir  __attribute__((__unused__)) ,
                     char **pzfrom , char **pzfull ) ;
#line 989
boolean fsysdep_uupick_free(char const   *zsystem  __attribute__((__unused__)) , char const   *zpubdir  __attribute__((__unused__)) ) ;
#line 996
char *zsysdep_uupick_local_file(char const   *zfile , boolean *pfbadname ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 56 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
static DIR *qStopdir  ;
#line 59 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
static char *zStopdir  ;
#line 62 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
static DIR *qSsysdir  ;
#line 65 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
static char *zSsysdir  ;
#line 70 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
boolean fsysdep_uupick_init(char const   *zsystem  __attribute__((__unused__)) , char const   *zpubdir ) 
{ 
  char const   *zuser ;
  size_t tmp ;
  size_t tmp___0 ;
  pointer tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 77
  zuser = zsysdep_login_name();
#line 79
  tmp = strlen(zpubdir);
#line 79
  tmp___0 = strlen(zuser);
#line 79
  tmp___1 = xmalloc((tmp + sizeof("/receive/")) + tmp___0);
#line 79
  zStopdir = (char *)tmp___1;
#line 82
  sprintf((char */* __restrict  */)zStopdir, (char const   */* __restrict  */)"%s/receive/%s",
          zpubdir, zuser);
#line 84
  qStopdir = opendir((char const   *)zStopdir);
  }
#line 85
  if ((unsigned long )qStopdir == (unsigned long )((void *)0)) {
    {
#line 85
    tmp___4 = __errno_location();
    }
#line 85
    if (*tmp___4 != 2) {
      {
#line 87
      tmp___2 = __errno_location();
#line 87
      tmp___3 = strerror(*tmp___2);
#line 87
      ulog((enum tlog )1, "opendir (%s): %s", zStopdir, tmp___3);
      }
#line 89
      return (0);
    }
  }
#line 92
  qSsysdir = (DIR *)((void *)0);
#line 94
  return (1);
}
}
#line 100 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
char *zsysdep_uupick(char const   *zsysarg , char const   *zpubdir  __attribute__((__unused__)) ,
                     char **pzfrom , char **pzfull ) 
{ 
  struct dirent *qentry ;
  char const   *zsystem ;
  char *zdir ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! ((unsigned long )qSsysdir == (unsigned long )((void *)0))) {
#line 111
        goto while_break___0;
      }
#line 116
      if ((unsigned long )qStopdir == (unsigned long )((void *)0)) {
#line 117
        return ((char *)((void *)0));
      }
#line 119
      if ((unsigned long )zsysarg != (unsigned long )((void *)0)) {
        {
#line 121
        closedir(qStopdir);
#line 122
        qStopdir = (DIR *)((void *)0);
#line 123
        zsystem = zsysarg;
        }
      } else {
        {
#line 127
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 129
          qentry = readdir(qStopdir);
          }
#line 130
          if ((unsigned long )qentry == (unsigned long )((void *)0)) {
            {
#line 132
            closedir(qStopdir);
#line 133
            qStopdir = (DIR *)((void *)0);
            }
#line 134
            return ((char *)((void *)0));
          }
          {
#line 127
          tmp = strcmp((char const   *)(qentry->d_name), ".");
          }
#line 127
          if (! (tmp == 0)) {
            {
#line 127
            tmp___0 = strcmp((char const   *)(qentry->d_name), "..");
            }
#line 127
            if (! (tmp___0 == 0)) {
#line 127
              goto while_break___1;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 140
        zsystem = (char const   *)(qentry->d_name);
      }
      {
#line 143
      tmp___1 = strlen((char const   *)zStopdir);
#line 143
      tmp___2 = strlen(zsystem);
#line 143
      zdir = zbufalc((tmp___1 + tmp___2) + sizeof("/"));
#line 144
      sprintf((char */* __restrict  */)zdir, (char const   */* __restrict  */)"%s/%s",
              zStopdir, zsystem);
#line 146
      qSsysdir = opendir((char const   *)zdir);
      }
#line 147
      if ((unsigned long )qSsysdir == (unsigned long )((void *)0)) {
        {
#line 149
        tmp___5 = __errno_location();
        }
#line 149
        if (*tmp___5 != 2) {
          {
#line 149
          tmp___6 = __errno_location();
          }
#line 149
          if (*tmp___6 != 20) {
            {
#line 150
            tmp___3 = __errno_location();
#line 150
            tmp___4 = strerror(*tmp___3);
#line 150
            ulog((enum tlog )1, "opendir (%s): %s", zdir, tmp___4);
            }
          }
        }
      } else {
        {
#line 154
        ubuffree(zSsysdir);
#line 155
        zSsysdir = zbufcpy(zsystem);
        }
      }
      {
#line 158
      ubuffree(zdir);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 161
    qentry = readdir(qSsysdir);
    }
#line 162
    if ((unsigned long )qentry == (unsigned long )((void *)0)) {
      {
#line 164
      closedir(qSsysdir);
#line 165
      qSsysdir = (DIR *)((void *)0);
      }
#line 166
      goto while_continue;
    }
    {
#line 169
    tmp___7 = strcmp((char const   *)(qentry->d_name), ".");
    }
#line 169
    if (tmp___7 == 0) {
#line 171
      goto while_continue;
    } else {
      {
#line 169
      tmp___8 = strcmp((char const   *)(qentry->d_name), "..");
      }
#line 169
      if (tmp___8 == 0) {
#line 171
        goto while_continue;
      }
    }
    {
#line 173
    *pzfrom = zbufcpy((char const   *)zSsysdir);
#line 174
    *pzfull = zsappend3((char const   *)zStopdir, (char const   *)zSsysdir, (char const   *)(qentry->d_name));
#line 175
    tmp___9 = zbufcpy((char const   *)(qentry->d_name));
    }
#line 175
    return (tmp___9);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 180 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
boolean fsysdep_uupick_free(char const   *zsystem  __attribute__((__unused__)) , char const   *zpubdir  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 185
  xfree((pointer )zStopdir);
  }
#line 186
  if ((unsigned long )qStopdir != (unsigned long )((void *)0)) {
    {
#line 188
    closedir(qStopdir);
#line 189
    qStopdir = (DIR *)((void *)0);
    }
  }
  {
#line 191
  ubuffree(zSsysdir);
#line 192
  zSsysdir = (char *)((void *)0);
  }
#line 193
  if ((unsigned long )qSsysdir != (unsigned long )((void *)0)) {
    {
#line 195
    closedir(qSsysdir);
#line 196
    qSsysdir = (DIR *)((void *)0);
    }
  }
#line 199
  return (1);
}
}
#line 204 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/picksb.c"
char *zsysdep_uupick_local_file(char const   *zfile , boolean *pfbadname ) 
{ 
  struct passwd *q ;
  char *tmp ;
  __uid_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 211
  if ((unsigned long )pfbadname != (unsigned long )((void *)0)) {
#line 212
    *pfbadname = 0;
  }
#line 218
  if ((int const   )*(zfile + 0) != 126) {
    {
#line 220
    tmp = zsysdep_local_file_cwd(zfile, (char const   *)((void *)0), pfbadname);
    }
#line 220
    return (tmp);
  } else
#line 218
  if ((int const   )*(zfile + 1) != 47) {
#line 218
    if ((int const   )*(zfile + 1) != 0) {
      {
#line 220
      tmp = zsysdep_local_file_cwd(zfile, (char const   *)((void *)0), pfbadname);
      }
#line 220
      return (tmp);
    }
  }
  {
#line 222
  tmp___0 = getuid();
#line 222
  q = getpwuid(tmp___0);
  }
#line 223
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 225
    ulog((enum tlog )1, "Can\'t get home directory");
    }
#line 226
    return ((char *)((void *)0));
  }
#line 229
  if ((int const   )*(zfile + 1) == 0) {
    {
#line 230
    tmp___1 = zbufcpy((char const   *)q->pw_dir);
    }
#line 230
    return (tmp___1);
  }
  {
#line 232
  tmp___2 = zsysdep_in_dir((char const   *)q->pw_dir, zfile + 2);
  }
#line 232
  return (tmp___2);
}
}
#line 456 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 65 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/pause.c"
void usysdep_pause(void) 
{ 


  {
  {
#line 79
  usleep((__useconds_t )500000L);
  }
#line 101
  return;
}
}
#line 414 "../system.h"
openfile_t esysdep_open_send(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ,
                             char const   *zfile , boolean fcheck , char const   *zuser ) ;
#line 427
char *zsysdep_receive_temp(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                           char const   *ztemp , boolean frestart ) ;
#line 443
openfile_t esysdep_open_receive(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ,
                                char const   *zto  __attribute__((__unused__)) , char const   *ztemp ,
                                char const   *zreceive , long *pcrestart ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 67 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/opensr.c"
openfile_t esysdep_open_send(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ,
                             char const   *zfile , boolean fcheck , char const   *zuser ) 
{ 
  struct stat s ;
  openfile_t e ;
  int o ;
  boolean tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  boolean tmp___12 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 78
  tmp = fsysdep_directory(zfile);
  }
#line 78
  if (tmp) {
    {
#line 80
    ulog((enum tlog )1, "%s: is a directory", zfile);
    }
#line 81
    return ((FILE *)((void *)0));
  }
  {
#line 85
  e = fopen((char const   */* __restrict  */)zfile, (char const   */* __restrict  */)"r");
  }
#line 86
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 88
    tmp___0 = __errno_location();
#line 88
    tmp___1 = strerror(*tmp___0);
#line 88
    ulog((enum tlog )1, "fopen (%s): %s", zfile, tmp___1);
    }
#line 89
    return ((openfile_t )((void *)0));
  }
  {
#line 91
  o = fileno(e);
#line 102
  tmp___5 = fcntl(o, 1, 0);
#line 102
  tmp___6 = fcntl(o, 2, tmp___5 | 1);
  }
#line 102
  if (tmp___6 < 0) {
    {
#line 104
    tmp___2 = __errno_location();
#line 104
    tmp___3 = strerror(*tmp___2);
#line 104
    ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___3);
#line 105
    tmp___4 = fclose(e);
    }
#line 106
    return ((FILE *)((void *)0));
  }
  {
#line 109
  tmp___9 = fstat(o, & s);
  }
#line 109
  if (tmp___9 == -1) {
    {
#line 111
    tmp___7 = __errno_location();
#line 111
    tmp___8 = strerror(*tmp___7);
#line 111
    ulog((enum tlog )1, "fstat: %s", tmp___8);
#line 112
    s.st_mode = (__mode_t )438;
    }
  }
#line 119
  if (fcheck) {
    {
#line 121
    tmp___12 = fsuser_access((struct stat  const  *)(& s), 4, zuser);
    }
#line 121
    if (! tmp___12) {
      {
#line 123
      tmp___10 = strerror(13);
#line 123
      ulog((enum tlog )1, "%s: %s", zfile, tmp___10);
#line 124
      tmp___11 = fclose(e);
      }
#line 125
      return ((FILE *)((void *)0));
    }
  }
#line 129
  return (e);
}
}
#line 136 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/opensr.c"
char *zsysdep_receive_temp(struct uuconf_system  const  *qsys , char const   *zto  __attribute__((__unused__)) ,
                           char const   *ztemp , boolean frestart ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 143
  if (frestart) {
#line 143
    if ((unsigned long )ztemp != (unsigned long )((void *)0)) {
#line 143
      if ((int const   )*ztemp == 68) {
        {
#line 143
        tmp___1 = strcmp(ztemp, "D.0");
        }
#line 143
        if (tmp___1 != 0) {
          {
#line 147
          tmp = zsappend3(".Temp", (char const   *)qsys->uuconf_zname, ztemp);
          }
#line 147
          return (tmp);
        } else {
          {
#line 149
          tmp___0 = zstemp_file(qsys);
          }
#line 149
          return (tmp___0);
        }
      } else {
        {
#line 149
        tmp___0 = zstemp_file(qsys);
        }
#line 149
        return (tmp___0);
      }
    } else {
      {
#line 149
      tmp___0 = zstemp_file(qsys);
      }
#line 149
      return (tmp___0);
    }
  } else {
    {
#line 149
    tmp___0 = zstemp_file(qsys);
    }
#line 149
    return (tmp___0);
  }
}
}
#line 160 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/opensr.c"
openfile_t esysdep_open_receive(struct uuconf_system  const  *qsys  __attribute__((__unused__)) ,
                                char const   *zto  __attribute__((__unused__)) , char const   *ztemp ,
                                char const   *zreceive , long *pcrestart ) 
{ 
  int o ;
  openfile_t e ;
  struct stat s ;
  int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  boolean tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 175
  o = -1;
#line 176
  if ((unsigned long )pcrestart != (unsigned long )((void *)0)) {
#line 177
    *pcrestart = -1L;
  }
#line 178
  if ((unsigned long )pcrestart != (unsigned long )((void *)0)) {
#line 178
    if ((unsigned long )ztemp != (unsigned long )((void *)0)) {
#line 178
      if ((int const   )*ztemp == 68) {
        {
#line 178
        tmp___1 = strcmp(ztemp, "D.0");
        }
#line 178
        if (tmp___1 != 0) {
          {
#line 183
          o = open((char const   *)((char *)zreceive), 1);
          }
#line 184
          if (o >= 0) {
            {
#line 194
            tmp = fstat(o, & s);
            }
#line 194
            if (tmp < 0) {
              {
#line 197
              close(o);
#line 198
              o = -1;
              }
            } else {
              {
#line 194
              tmp___0 = time((time_t *)((void *)0));
              }
#line 194
              if (s.st_mtim.tv_sec + 604800L < tmp___0) {
                {
#line 197
                close(o);
#line 198
                o = -1;
                }
              } else {
                {
#line 202
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 202
                  if ((iDebug & 128) != 0) {
                    {
#line 202
                    ulog((enum tlog )3, "esysdep_open_receive: Reusing %s", zreceive);
                    }
                  }
#line 202
                  goto while_break;
                }
                while_break: /* CIL Label */ ;
                }
#line 205
                *pcrestart = s.st_size;
              }
            }
          }
        }
      }
    }
  }
#line 210
  if (o < 0) {
    {
#line 211
    o = creat((char const   *)((char *)zreceive), (__mode_t )384);
    }
  }
#line 213
  if (o < 0) {
    {
#line 215
    tmp___3 = __errno_location();
    }
#line 215
    if (*tmp___3 == 2) {
      {
#line 217
      tmp___2 = fsysdep_make_dirs(zreceive, 0);
      }
#line 217
      if (! tmp___2) {
#line 218
        return ((FILE *)((void *)0));
      }
      {
#line 219
      o = creat((char const   *)((char *)zreceive), (__mode_t )384);
      }
    }
#line 221
    if (o < 0) {
      {
#line 223
      tmp___4 = __errno_location();
#line 223
      tmp___5 = strerror(*tmp___4);
#line 223
      ulog((enum tlog )1, "creat (%s): %s", zreceive, tmp___5);
      }
#line 224
      return ((FILE *)((void *)0));
    }
  }
  {
#line 228
  tmp___8 = fcntl(o, 1, 0);
#line 228
  tmp___9 = fcntl(o, 2, tmp___8 | 1);
  }
#line 228
  if (tmp___9 < 0) {
    {
#line 230
    tmp___6 = __errno_location();
#line 230
    tmp___7 = strerror(*tmp___6);
#line 230
    ulog((enum tlog )1, "fcntl (FD_CLOEXEC): %s", tmp___7);
#line 231
    close(o);
#line 232
    remove(zreceive);
    }
#line 233
    return ((FILE *)((void *)0));
  }
  {
#line 237
  e = fdopen(o, (char const   *)((char *)"w"));
  }
#line 239
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 241
    tmp___10 = __errno_location();
#line 241
    tmp___11 = strerror(*tmp___10);
#line 241
    ulog((enum tlog )1, "fdopen (%s): %s", zreceive, tmp___11);
#line 242
    close(o);
#line 243
    remove(zreceive);
    }
#line 244
    return ((FILE *)((void *)0));
  }
#line 250
  return (e);
}
}
#line 157 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 47 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/move.c"
boolean fsysdep_move_file(char const   *zorig , char const   *zto , boolean fmkdirs ,
                          boolean fpublic , boolean fcheck , char const   *zuser ) 
{ 
  struct stat s ;
  int o ;
  char *zcopy ;
  char *zslash ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  boolean tmp___3 ;
  int tmp___4 ;
  boolean tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  boolean tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  boolean tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if ((iDebug & 128) != 0) {
      {
#line 59
      ulog((enum tlog )3, "fsysdep_move_file: Moving %s to %s", zorig, zto);
      }
    }
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (fcheck) {
    {
#line 69
    zcopy = zbufcpy(zto);
#line 70
    zslash = strrchr((char const   *)zcopy, '/');
    }
#line 71
    if ((unsigned long )zslash == (unsigned long )zcopy) {
#line 72
      *(zslash + 1) = (char )'\000';
    } else {
#line 74
      *zslash = (char )'\000';
    }
    {
#line 76
    tmp___1 = stat((char const   */* __restrict  */)zcopy, (struct stat */* __restrict  */)(& s));
    }
#line 76
    if (tmp___1 != 0) {
      {
#line 78
      tmp = __errno_location();
#line 78
      tmp___0 = strerror(*tmp);
#line 78
      ulog((enum tlog )1, "stat (%s): %s", zcopy, tmp___0);
#line 79
      ubuffree(zcopy);
      }
#line 80
      return (0);
    }
    {
#line 82
    tmp___3 = fsuser_access((struct stat  const  *)(& s), 2, zuser);
    }
#line 82
    if (! tmp___3) {
      {
#line 84
      tmp___2 = strerror(13);
#line 84
      ulog((enum tlog )1, "%s: %s", zcopy, tmp___2);
#line 85
      ubuffree(zcopy);
      }
#line 86
      return (0);
    }
    {
#line 88
    ubuffree(zcopy);
    }
  }
  {
#line 101
  tmp___4 = rename(zorig, zto);
  }
#line 101
  if (tmp___4 == 0) {
#line 102
    return (1);
  }
#line 104
  if (fmkdirs) {
    {
#line 104
    tmp___7 = __errno_location();
    }
#line 104
    if (*tmp___7 == 2) {
      {
#line 106
      tmp___5 = fsysdep_make_dirs(zto, fpublic);
      }
#line 106
      if (! tmp___5) {
#line 107
        return (0);
      }
      {
#line 108
      tmp___6 = rename(zorig, zto);
      }
#line 108
      if (tmp___6 == 0) {
#line 109
        return (1);
      }
    }
  }
  {
#line 116
  tmp___8 = __errno_location();
#line 116
  *tmp___8 = 18;
#line 120
  tmp___11 = __errno_location();
  }
#line 120
  if (*tmp___11 != 18) {
    {
#line 122
    tmp___9 = __errno_location();
#line 122
    tmp___10 = strerror(*tmp___9);
#line 122
    ulog((enum tlog )1, "rename (%s, %s): %s", zorig, zto, tmp___10);
    }
#line 124
    return (0);
  }
  {
#line 128
  tmp___14 = stat((char const   */* __restrict  */)((char *)zorig), (struct stat */* __restrict  */)(& s));
  }
#line 128
  if (tmp___14 < 0) {
    {
#line 130
    tmp___12 = __errno_location();
#line 130
    tmp___13 = strerror(*tmp___12);
#line 130
    ulog((enum tlog )1, "stat (%s): %s", zorig, tmp___13);
    }
#line 131
    return (0);
  }
  {
#line 136
  remove(zto);
#line 137
  o = creat((char const   *)((char *)zto), s.st_mode);
  }
#line 138
  if (o < 0) {
#line 140
    if (fmkdirs) {
      {
#line 140
      tmp___16 = __errno_location();
      }
#line 140
      if (*tmp___16 == 2) {
        {
#line 142
        tmp___15 = fsysdep_make_dirs(zto, fpublic);
        }
#line 142
        if (! tmp___15) {
#line 143
          return (0);
        }
        {
#line 144
        o = creat((char const   *)((char *)zto), s.st_mode);
        }
      }
    }
#line 146
    if (o < 0) {
      {
#line 148
      tmp___17 = __errno_location();
#line 148
      tmp___18 = strerror(*tmp___17);
#line 148
      ulog((enum tlog )1, "creat (%s): %s", zto, tmp___18);
      }
#line 149
      return (0);
    }
  }
  {
#line 152
  close(o);
#line 154
  tmp___19 = fcopy_file(zorig, zto, fpublic, fmkdirs, 0);
  }
#line 154
  if (! tmp___19) {
#line 155
    return (0);
  }
  {
#line 157
  tmp___22 = remove(zorig);
  }
#line 157
  if (tmp___22 != 0) {
    {
#line 158
    tmp___20 = __errno_location();
#line 158
    tmp___21 = strerror(*tmp___20);
#line 158
    ulog((enum tlog )1, "remove (%s): %s", zorig, tmp___21);
    }
  }
#line 160
  return (1);
}
}
#line 743 "../system.h"
unsigned int ixsysdep_file_mode(char const   *zfile ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/mode.c"
unsigned int ixsysdep_file_mode(char const   *zfile ) 
{ 
  struct stat s ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 18
  tmp___1 = stat((char const   */* __restrict  */)((char *)zfile), (struct stat */* __restrict  */)(& s));
  }
#line 18
  if (tmp___1 != 0) {
    {
#line 20
    tmp = __errno_location();
#line 20
    tmp___0 = strerror(*tmp);
#line 20
    ulog((enum tlog )1, "stat (%s): %s", zfile, tmp___0);
    }
#line 21
    return (0U);
  }
#line 29
  if ((s.st_mode & 511U) == 0U) {
#line 30
    return (256U);
  }
#line 32
  return (s.st_mode & 511U);
}
}
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/mkdirs.c"
boolean fsysdep_make_dirs(char const   *zfile , boolean fpublic ) 
{ 
  char *zcopy ;
  char *z ;
  int imode ;
  int ierr ;
  int *tmp ;
  char *tmp___0 ;
  boolean tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 20
  zcopy = zbufcpy(zfile);
  }
#line 22
  if (fpublic) {
#line 23
    imode = (448 | (448 >> 3)) | ((448 >> 3) >> 3);
  } else {
#line 25
    imode = (((448 | (256 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((64 >> 3) >> 3);
  }
#line 27
  z = zcopy;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ((int )*z != 0)) {
#line 27
      goto while_break;
    }
#line 29
    if ((int )*z == 47) {
#line 29
      if ((unsigned long )z != (unsigned long )zcopy) {
#line 34
        if ((int )*(z + -1) == 47) {
#line 35
          goto __Cont;
        }
        {
#line 36
        *z = (char )'\000';
#line 37
        tmp___2 = mkdir((char const   *)zcopy, (__mode_t )imode);
        }
#line 37
        if (tmp___2 != 0) {
          {
#line 41
          tmp = __errno_location();
#line 41
          ierr = *tmp;
          }
#line 42
          if (ierr != 17) {
#line 42
            if (ierr != 21) {
#line 42
              if (ierr != 30) {
#line 42
                if (ierr != 13) {
                  {
#line 49
                  tmp___0 = strerror(ierr);
#line 49
                  ulog((enum tlog )1, "mkdir (%s): %s", zcopy, tmp___0);
#line 51
                  ubuffree(zcopy);
                  }
#line 52
                  return (0);
                } else {
                  {
#line 42
                  tmp___1 = fsysdep_directory((char const   *)zcopy);
                  }
#line 42
                  if (! tmp___1) {
                    {
#line 49
                    tmp___0 = strerror(ierr);
#line 49
                    ulog((enum tlog )1, "mkdir (%s): %s", zcopy, tmp___0);
#line 51
                    ubuffree(zcopy);
                    }
#line 52
                    return (0);
                  }
                }
              }
            }
          }
        }
#line 55
        *z = (char )'/';
      }
    }
    __Cont: /* CIL Label */ 
#line 27
    z ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  ubuffree(zcopy);
  }
#line 61
  return (1);
}
}
#line 662 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 434 "../sysdep.h"
FILE *espopen(char const   **pazargs , boolean frd , pid_t *pipid ) ;
#line 560
char const   *zSlocalname ;
#line 228 "../system.h"
boolean fsysdep_mail(char const   *zto , char const   *zsubject , int cstrs , char const   **paz ) ;
#line 258 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 43 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/mail.c"
boolean fsysdep_mail(char const   *zto , char const   *zsubject , int cstrs , char const   **paz ) 
{ 
  char **pazargs ;
  char *zcopy ;
  char *ztok ;
  size_t cargs ;
  size_t iarg ;
  FILE *e ;
  pid_t ipid ;
  time_t itime ;
  int i ;
  pointer tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 59
  zcopy = zbufcpy("/usr/lib/sendmail -t");
#line 61
  cargs = (size_t )0;
#line 62
  ztok = strtok((char */* __restrict  */)zcopy, (char const   */* __restrict  */)" \t");
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )ztok != (unsigned long )((void *)0))) {
#line 62
      goto while_break;
    }
    {
#line 65
    cargs ++;
#line 62
    ztok = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  tmp = xmalloc((cargs + 4UL) * sizeof(char *));
#line 67
  pazargs = (char **)tmp;
#line 69
  memcpy((void */* __restrict  */)zcopy, (void const   */* __restrict  */)"/usr/lib/sendmail -t",
         sizeof("/usr/lib/sendmail -t"));
#line 70
  ztok = strtok((char */* __restrict  */)zcopy, (char const   */* __restrict  */)" \t");
#line 70
  iarg = (size_t )0;
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )ztok != (unsigned long )((void *)0))) {
#line 70
      goto while_break___0;
    }
    {
#line 73
    *(pazargs + iarg) = ztok;
#line 70
    ztok = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)" \t");
#line 70
    iarg ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 84
  *(pazargs + iarg) = (char *)((void *)0);
#line 86
  e = espopen((char const   **)pazargs, 0, & ipid);
#line 88
  ubuffree(zcopy);
#line 89
  xfree((pointer )pazargs);
  }
#line 91
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 93
    tmp___0 = __errno_location();
#line 93
    tmp___1 = strerror(*tmp___0);
#line 93
    ulog((enum tlog )1, "espopen (%s): %s", "/usr/lib/sendmail -t", tmp___1);
    }
#line 95
    return (0);
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"To: %s\n",
          zto);
#line 102
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"Subject: %s\n",
          zsubject);
#line 106
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"\n");
#line 109
  time(& itime);
#line 111
  tmp___2 = ctime((time_t const   *)(& itime));
#line 111
  fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"Message from UUCP on %s %s\n",
          zSlocalname, tmp___2);
#line 114
  i = 0;
  }
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 114
    if (! (i < cstrs)) {
#line 114
      goto while_break___1;
    }
    {
#line 115
    fputs((char const   */* __restrict  */)*(paz + i), (FILE */* __restrict  */)e);
#line 114
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 117
  fclose(e);
#line 119
  tmp___3 = ixswait((unsigned long )ipid, "/usr/lib/sendmail -t");
  }
#line 119
  return (tmp___3 == 0);
}
}
#line 237 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 250 "../system.h"
void usysdep_localtime(long itime , struct tm *q ) ;
#line 18 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/loctim.c"
void usysdep_localtime(long itime , struct tm *q ) 
{ 
  time_t i ;
  struct tm *tmp ;

  {
  {
#line 25
  i = itime;
#line 26
  tmp = localtime((time_t const   *)(& i));
#line 26
  *q = *tmp;
  }
#line 27
  return;
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lock.c"
char const   lock_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lock.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'k',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'2',      (char const   )'3',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 87 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lock.c"
boolean fsdo_lock(char const   *zlock , boolean fspooldir , boolean *pferr ) 
{ 
  char *zfree ;
  char const   *zpath ;
  char const   *zslash ;
  size_t cslash ;
  pid_t ime ;
  char *ztempfile ;
  char abtempfile[sizeof("TMP12345678901234567890")] ;
  int o ;
  char ab___0[12] ;
  int cwrote ;
  char const   *zerr ;
  boolean fret ;
  char *tmp ;
  boolean tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int cgot ;
  pid_t ipid ;
  boolean freadonly ;
  struct stat st ;
  char abtime[sizeof("1991-12-31 12:00:00")] ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  ssize_t tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  time_t itm ;
  struct tm *q ;
  int tmp___18 ;
  int tmp___19 ;
  __off_t tmp___20 ;
  size_t tmp___21 ;
  ssize_t tmp___22 ;
  __off_t tmp___23 ;
  ssize_t tmp___24 ;
  long tmp___25 ;
  struct stat sfile ;
  struct stat sdescriptor ;
  int *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;

  {
#line 115
  if ((unsigned long )pferr != (unsigned long )((void *)0)) {
#line 116
    *pferr = 1;
  }
#line 118
  if (fspooldir) {
#line 120
    zfree = (char *)((void *)0);
#line 121
    zpath = zlock;
  } else {
    {
#line 125
    zfree = zsysdep_in_dir(zSlockdir, zlock);
#line 126
    zpath = (char const   *)zfree;
    }
  }
  {
#line 129
  ime = getpid();
#line 142
  tmp = strrchr(zpath, '/');
#line 142
  zslash = (char const   *)tmp;
  }
#line 143
  if ((unsigned long )zslash == (unsigned long )((void *)0)) {
#line 144
    cslash = (size_t )0;
  } else {
#line 146
    cslash = (size_t )((zslash - zpath) + 1L);
  }
  {
#line 152
  sprintf((char */* __restrict  */)(abtempfile), (char const   */* __restrict  */)"TMP%010lx",
          (unsigned long )ime);
#line 154
  ztempfile = zbufalc(cslash + sizeof(abtempfile));
#line 155
  memcpy((void */* __restrict  */)ztempfile, (void const   */* __restrict  */)zpath,
         cslash);
#line 156
  memcpy((void */* __restrict  */)(ztempfile + cslash), (void const   */* __restrict  */)(abtempfile),
         sizeof(abtempfile));
#line 158
  o = creat((char const   *)ztempfile, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
  }
#line 159
  if (o < 0) {
    {
#line 161
    tmp___1 = __errno_location();
    }
#line 161
    if (*tmp___1 == 2) {
      {
#line 163
      tmp___0 = fsysdep_make_dirs((char const   *)ztempfile, 0);
      }
#line 163
      if (! tmp___0) {
        {
#line 165
        ubuffree(zfree);
#line 166
        ubuffree(ztempfile);
        }
#line 167
        return (0);
      }
      {
#line 169
      o = creat((char const   *)ztempfile, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
      }
    }
#line 171
    if (o < 0) {
      {
#line 173
      tmp___2 = __errno_location();
#line 173
      tmp___3 = strerror(*tmp___2);
#line 173
      ulog((enum tlog )1, "creat (%s): %s", ztempfile, tmp___3);
#line 174
      ubuffree(zfree);
#line 175
      ubuffree(ztempfile);
      }
#line 176
      return (0);
    }
  }
  {
#line 188
  sprintf((char */* __restrict  */)(ab___0), (char const   */* __restrict  */)"%10ld\n",
          (long )ime);
#line 189
  tmp___4 = strlen((char const   *)(ab___0));
#line 189
  tmp___5 = write(o, (void const   *)(ab___0), tmp___4);
#line 189
  cwrote = (int )tmp___5;
#line 193
  zerr = (char const   *)((void *)0);
  }
#line 194
  if (cwrote < 0) {
#line 195
    zerr = "write";
  }
  {
#line 196
  tmp___6 = close(o);
  }
#line 196
  if (tmp___6 < 0) {
#line 197
    zerr = "close";
  }
#line 198
  if ((unsigned long )zerr != (unsigned long )((void *)0)) {
    {
#line 200
    tmp___7 = __errno_location();
#line 200
    tmp___8 = strerror(*tmp___7);
#line 200
    ulog((enum tlog )1, "%s (%s): %s", zerr, ztempfile, tmp___8);
#line 201
    remove((char const   *)ztempfile);
#line 202
    ubuffree(zfree);
#line 203
    ubuffree(ztempfile);
    }
#line 204
    return (0);
  }
#line 212
  fret = 1;
#line 213
  if ((unsigned long )pferr != (unsigned long )((void *)0)) {
#line 214
    *pferr = 0;
  }
#line 215
  o = -1;
#line 216
  zerr = (char const   *)((void *)0);
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 218
    tmp___30 = link((char const   *)ztempfile, zpath);
    }
#line 218
    if (! (tmp___30 != 0)) {
#line 218
      goto while_break;
    }
    {
#line 229
    fret = 0;
#line 231
    tmp___11 = __errno_location();
    }
#line 231
    if (*tmp___11 != 17) {
      {
#line 233
      tmp___9 = __errno_location();
#line 233
      tmp___10 = strerror(*tmp___9);
#line 233
      ulog((enum tlog )1, "link (%s, %s): %s", ztempfile, zpath, tmp___10);
      }
#line 235
      if ((unsigned long )pferr != (unsigned long )((void *)0)) {
#line 236
        *pferr = 1;
      }
#line 237
      goto while_break;
    }
    {
#line 240
    freadonly = 0;
#line 241
    o = open((char const   *)((char *)zpath), 258, 0);
    }
#line 242
    if (o < 0) {
      {
#line 244
      tmp___12 = __errno_location();
      }
#line 244
      if (*tmp___12 == 13) {
        {
#line 246
        freadonly = 1;
#line 247
        o = open((char const   *)((char *)zpath), 0, 0);
        }
      }
#line 249
      if (o < 0) {
        {
#line 251
        tmp___13 = __errno_location();
        }
#line 251
        if (*tmp___13 == 2) {
#line 255
          fret = 1;
#line 256
          goto while_continue;
        }
#line 258
        zerr = "open";
#line 259
        goto while_break;
      }
    }
    {
#line 268
    tmp___14 = read(o, (void *)(ab___0), sizeof(ab___0) - 1UL);
#line 268
    cgot = (int )tmp___14;
    }
#line 271
    if (cgot < 0) {
#line 273
      zerr = "read";
#line 274
      goto while_break;
    }
#line 289
    if (cgot == 4) {
      {
#line 290
      ulog((enum tlog )1, "Lock file %s may be V2 format; check LOCKFILES in policy.h",
           zpath);
      }
    }
    {
#line 304
    ab___0[cgot] = (char )'\000';
#line 305
    tmp___15 = strtol((char const   */* __restrict  */)(ab___0), (char **/* __restrict  */)((char **)((void *)0)),
                      10);
#line 305
    ipid = (pid_t )tmp___15;
    }
#line 319
    if (ipid == ime) {
#line 325
      fret = 1;
#line 326
      goto while_break;
    }
#line 333
    if (cgot > 0) {
      {
#line 343
      tmp___16 = kill(ipid, 0);
      }
#line 343
      if (tmp___16 == 0) {
#line 344
        goto while_break;
      } else {
        {
#line 343
        tmp___17 = __errno_location();
        }
#line 343
        if (*tmp___17 == 1) {
#line 344
          goto while_break;
        }
      }
    }
    {
#line 348
    tmp___18 = fstat(o, & st);
    }
#line 348
    if (tmp___18 < 0) {
      {
#line 349
      strcpy((char */* __restrict  */)(abtime), (char const   */* __restrict  */)"unknown");
      }
    } else {
      {
#line 355
      itm = st.st_mtim.tv_sec;
#line 356
      q = localtime((time_t const   *)(& itm));
#line 357
      sprintf((char */* __restrict  */)(abtime), (char const   */* __restrict  */)"%04d-%02d-%02d %02d:%02d:%02d",
              q->tm_year + 1900, q->tm_mon + 1, q->tm_mday, q->tm_hour, q->tm_min,
              q->tm_sec);
      }
    }
    {
#line 367
    ulog((enum tlog )1, "Stale lock %s held by process %ld created %s", zpath, (long )ipid,
         abtime);
    }
#line 423
    if (freadonly) {
      {
#line 425
      close(o);
#line 426
      o = -1;
#line 427
      tmp___19 = remove(zpath);
      }
#line 427
      if (tmp___19 != 0) {
#line 429
        zerr = "remove";
#line 430
        goto while_break;
      }
#line 432
      fret = 1;
#line 433
      goto while_continue;
    }
    {
#line 436
    tmp___20 = lseek(o, (off_t )0, 0);
    }
#line 436
    if (tmp___20 != 0L) {
#line 438
      zerr = "lseek";
#line 439
      goto while_break;
    }
    {
#line 450
    sprintf((char */* __restrict  */)(ab___0), (char const   */* __restrict  */)"%10ld\n",
            (long )ime);
#line 451
    tmp___21 = strlen((char const   *)(ab___0));
#line 451
    tmp___22 = write(o, (void const   *)(ab___0), tmp___21);
#line 451
    cwrote = (int )tmp___22;
    }
#line 455
    if (cwrote < 0) {
#line 457
      zerr = "write";
#line 458
      goto while_break;
    }
    {
#line 461
    sleep(5U);
#line 463
    tmp___23 = lseek(o, (off_t )0, 0);
    }
#line 463
    if (tmp___23 != 0L) {
#line 465
      zerr = "lseek";
#line 466
      goto while_break;
    }
    {
#line 472
    tmp___24 = read(o, (void *)(ab___0), sizeof(ab___0) - 1UL);
#line 472
    cgot = (int )tmp___24;
    }
#line 475
    if (cgot < 0) {
#line 477
      zerr = "read";
#line 478
      goto while_break;
    }
    {
#line 489
    ab___0[cgot] = (char )'\000';
#line 490
    tmp___25 = strtol((char const   */* __restrict  */)(ab___0), (char **/* __restrict  */)((char **)((void *)0)),
                      10);
#line 490
    ipid = (pid_t )tmp___25;
    }
#line 494
    if (ipid == ime) {
      {
#line 504
      tmp___29 = stat((char const   */* __restrict  */)((char *)zpath), (struct stat */* __restrict  */)(& sfile));
      }
#line 504
      if (tmp___29 < 0) {
        {
#line 506
        tmp___26 = __errno_location();
        }
#line 506
        if (*tmp___26 != 2) {
#line 508
          zerr = "stat";
#line 509
          goto while_break;
        }
      } else {
        {
#line 515
        tmp___27 = fstat(o, & sdescriptor);
        }
#line 515
        if (tmp___27 < 0) {
#line 517
          zerr = "fstat";
#line 518
          goto while_break;
        }
#line 521
        if (sfile.st_ino == sdescriptor.st_ino) {
#line 521
          if (sfile.st_dev == sdescriptor.st_dev) {
            {
#line 526
            tmp___28 = close(o);
            }
#line 526
            if (tmp___28 < 0) {
#line 528
              zerr = "close";
#line 529
              goto while_break;
            }
#line 532
            o = -1;
#line 535
            fret = 1;
#line 536
            goto while_break;
          }
        }
      }
    }
    {
#line 544
    close(o);
#line 545
    o = -1;
#line 546
    fret = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  if ((unsigned long )zerr != (unsigned long )((void *)0)) {
    {
#line 551
    tmp___31 = __errno_location();
#line 551
    tmp___32 = strerror(*tmp___31);
#line 551
    ulog((enum tlog )1, "%s (%s): %s", zerr, zpath, tmp___32);
    }
#line 552
    if ((unsigned long )pferr != (unsigned long )((void *)0)) {
#line 553
      *pferr = 1;
    }
  }
#line 556
  if (o >= 0) {
    {
#line 557
    close(o);
    }
  }
  {
#line 559
  ubuffree(zfree);
#line 565
  tmp___35 = remove((char const   *)ztempfile);
  }
#line 565
  if (tmp___35 != 0) {
    {
#line 566
    tmp___33 = __errno_location();
#line 566
    tmp___34 = strerror(*tmp___33);
#line 566
    ulog((enum tlog )1, "remove (%s): %s", ztempfile, tmp___34);
    }
  }
  {
#line 568
  ubuffree(ztempfile);
  }
#line 570
  return (fret);
}
}
#line 575 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lock.c"
boolean fsdo_unlock(char const   *zlock , boolean fspooldir ) 
{ 
  char *zfree ;
  char const   *zpath ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 583
  if (fspooldir) {
#line 585
    zfree = (char *)((void *)0);
#line 586
    zpath = zlock;
  } else {
    {
#line 590
    zfree = zsysdep_in_dir(zSlockdir, zlock);
#line 591
    zpath = (char const   *)zfree;
    }
  }
  {
#line 594
  tmp___1 = remove(zpath);
  }
#line 594
  if (tmp___1 == 0) {
    {
#line 597
    ubuffree(zfree);
    }
#line 598
    return (1);
  } else {
    {
#line 594
    tmp___2 = __errno_location();
    }
#line 594
    if (*tmp___2 == 2) {
      {
#line 597
      ubuffree(zfree);
      }
#line 598
      return (1);
    } else {
      {
#line 602
      tmp = __errno_location();
#line 602
      tmp___0 = strerror(*tmp);
#line 602
      ulog((enum tlog )1, "remove (%s): %s", zpath, tmp___0);
#line 603
      ubuffree(zfree);
      }
#line 604
      return (0);
    }
  }
}
}
#line 42 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/locfil.c"
char *zsysdep_local_file(char const   *zfile , char const   *zpubdir , boolean *pfbadname ) 
{ 
  char const   *zdir ;
  char *tmp ;
  char *tmp___0 ;
  size_t cuserlen ;
  char *zcopy ;
  struct passwd *q ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 50
  if ((unsigned long )pfbadname != (unsigned long )((void *)0)) {
#line 51
    *pfbadname = 0;
  }
#line 53
  if ((int const   )*zfile == 47) {
    {
#line 54
    tmp = zbufcpy(zfile);
    }
#line 54
    return (tmp);
  }
#line 56
  if ((int const   )*zfile != 126) {
#line 57
    zdir = zpubdir;
  } else {
#line 60
    if ((int const   )*(zfile + 1) == 0) {
      {
#line 61
      tmp___0 = zbufcpy(zpubdir);
      }
#line 61
      return (tmp___0);
    }
#line 63
    if ((int const   )*(zfile + 1) == 47) {
#line 65
      zdir = zpubdir;
#line 66
      zfile += 2;
    } else {
      {
#line 74
      zfile ++;
#line 75
      cuserlen = strcspn((char const   *)((char *)zfile), "/");
#line 76
      zcopy = zbufalc(cuserlen + 1UL);
#line 77
      memcpy((void */* __restrict  */)zcopy, (void const   */* __restrict  */)zfile,
             cuserlen);
#line 78
      *(zcopy + cuserlen) = (char )'\000';
#line 80
      q = getpwnam((char const   *)zcopy);
      }
#line 81
      if ((unsigned long )q == (unsigned long )((void *)0)) {
        {
#line 83
        ulog((enum tlog )1, "User %s not found", zcopy);
#line 84
        ubuffree(zcopy);
        }
#line 85
        if ((unsigned long )pfbadname != (unsigned long )((void *)0)) {
#line 86
          *pfbadname = 1;
        }
#line 87
        return ((char *)((void *)0));
      }
      {
#line 89
      ubuffree(zcopy);
      }
#line 91
      if ((int const   )*(zfile + cuserlen) == 0) {
        {
#line 92
        tmp___1 = zbufcpy((char const   *)q->pw_dir);
        }
#line 92
        return (tmp___1);
      }
#line 94
      zdir = (char const   *)q->pw_dir;
#line 95
      zfile += cuserlen + 1UL;
    }
  }
  {
#line 99
  tmp___2 = zsysdep_in_dir(zdir, zfile);
  }
#line 99
  return (tmp___2);
}
}
#line 157 "../system.h"
boolean fsysdep_link(char const   *zfrom , char const   *zto , boolean *pfworked ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/link.c"
boolean fsysdep_link(char const   *zfrom , char const   *zto , boolean *pfworked ) 
{ 
  int tmp ;
  boolean tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp11 ;

  {
  {
#line 18
  *pfworked = 0;
#line 19
  tmp = link(zfrom, zto);
  }
#line 19
  if (tmp == 0) {
#line 21
    *pfworked = 1;
#line 22
    return (1);
  }
  {
#line 24
  tmp___2 = __errno_location();
  }
#line 24
  if (*tmp___2 == 2) {
    {
#line 26
    tmp___0 = fsysdep_make_dirs(zto, 1);
    }
#line 26
    if (! tmp___0) {
#line 27
      return (0);
    }
    {
#line 28
    tmp___1 = link(zfrom, zto);
    }
#line 28
    if (tmp___1 == 0) {
#line 30
      *pfworked = 1;
#line 31
      return (1);
    }
  }
  {
#line 34
  tmp___3 = __errno_location();
  }
#line 34
  if (*tmp___3 == 18) {
#line 35
    return (1);
  }
  {
#line 36
  tmp___4 = __errno_location();
#line 36
  tmp___5 = strerror(*tmp___4);
#line 36
  ulog((enum tlog )1, "link (%s, %s): %s", zfrom, zto, tmp___5);
  }
#line 37
  return (0);
}
}
#line 261 "../system.h"
boolean fsysdep_lock_system(struct uuconf_system  const  *qsys ) ;
#line 265
boolean fsysdep_unlock_system(struct uuconf_system  const  *qsys ) ;
#line 13 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lcksys.c"
static boolean fslock_sys(boolean flock , char const   *zname ) ;
#line 15 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lcksys.c"
static boolean fslock_sys(boolean flock , char const   *zname ) 
{ 
  size_t clen ;
  char *z ;
  boolean fret ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 24
  clen = strlen(zname);
#line 31
  z = zbufalc(sizeof("LCK..") + clen);
#line 32
  memcpy((void */* __restrict  */)z, (void const   */* __restrict  */)"LCK..", sizeof("LCK..") - 1UL);
#line 33
  memcpy((void */* __restrict  */)((z + sizeof("LCK..")) - 1), (void const   */* __restrict  */)zname,
         clen);
#line 34
  *(z + ((sizeof("LCK..") - 1UL) + clen)) = (char )'\000';
  }
#line 36
  if (flock) {
    {
#line 37
    fret = fsdo_lock((char const   *)z, 0, (boolean *)((void *)0));
    }
  } else {
    {
#line 39
    fret = fsdo_unlock((char const   *)z, 0);
    }
  }
  {
#line 41
  ubuffree(z);
  }
#line 43
  return (fret);
}
}
#line 48 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lcksys.c"
boolean fsysdep_lock_system(struct uuconf_system  const  *qsys ) 
{ 
  boolean tmp ;

  {
  {
#line 52
  tmp = fslock_sys(1, (char const   *)qsys->uuconf_zname);
  }
#line 52
  return (tmp);
}
}
#line 57 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/lcksys.c"
boolean fsysdep_unlock_system(struct uuconf_system  const  *qsys ) 
{ 
  boolean tmp ;

  {
  {
#line 61
  tmp = fslock_sys(0, (char const   *)qsys->uuconf_zname);
  }
#line 61
  return (tmp);
}
}
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/jobid.c"
char *zsfile_to_jobid(struct uuconf_system  const  *qsys , char const   *zfile , int bgrade  __attribute__((__unused__)) ) 
{ 
  size_t clen ;
  char *zret ;
  size_t cseqlen ;
  char *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 44
  clen = strlen((char const   *)qsys->uuconf_zname);
#line 68
  tmp = strrchr(zfile, '/');
#line 68
  zfile = (char const   *)tmp;
  }
#line 71
  if ((unsigned long )zfile == (unsigned long )((void *)0)) {
    {
#line 75
    ulog((enum tlog )2, "zsfile_to_jobid: Can\'t happen");
    }
  } else
#line 71
  if ((int const   )*(zfile + 1) != 67) {
    {
#line 75
    ulog((enum tlog )2, "zsfile_to_jobid: Can\'t happen");
    }
  } else
#line 71
  if ((int const   )*(zfile + 2) != 46) {
    {
#line 75
    ulog((enum tlog )2, "zsfile_to_jobid: Can\'t happen");
    }
  } else
#line 71
  if ((int const   )*(zfile + 3) == 0) {
    {
#line 75
    ulog((enum tlog )2, "zsfile_to_jobid: Can\'t happen");
    }
  }
  {
#line 79
  zfile += 2;
#line 81
  cseqlen = strlen(zfile);
#line 82
  zret = zbufalc((clen + cseqlen) + 1UL);
#line 83
  memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)qsys->uuconf_zname,
         clen);
#line 84
  memcpy((void */* __restrict  */)(zret + clen), (void const   */* __restrict  */)zfile,
         cseqlen + 1UL);
  }
#line 89
  return (zret);
}
}
#line 94 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/jobid.c"
char *zsjobid_to_file(char const   *zid , char **pzsystem , char *pbgrade ) 
{ 
  char *zdot ;
  size_t csyslen ;
  char *zsys ;
  char ab___0[15] ;
  char *zret ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 141
  zdot = strrchr(zid, '.');
  }
#line 142
  if ((unsigned long )zdot == (unsigned long )((void *)0)) {
    {
#line 144
    ulog((enum tlog )1, "%s: Bad job id", zid);
    }
#line 145
    return ((char *)((void *)0));
  }
  {
#line 148
  csyslen = (size_t )(zdot - (char *)zid);
#line 149
  zsys = zbufalc(csyslen + 1UL);
#line 150
  memcpy((void */* __restrict  */)zsys, (void const   */* __restrict  */)zid, csyslen);
#line 151
  *(zsys + csyslen) = (char )'\000';
#line 153
  ab___0[0] = (char )'C';
#line 154
  strcpy((char */* __restrict  */)(ab___0 + 1), (char const   */* __restrict  */)zdot);
#line 156
  zret = zsfind_file((char const   *)(ab___0), (char const   *)zsys, (int )*(zdot + 1));
  }
#line 158
  if ((unsigned long )zret != (unsigned long )((void *)0)) {
#line 158
    if ((unsigned long )pzsystem != (unsigned long )((void *)0)) {
#line 159
      *pzsystem = zsys;
    } else {
      {
#line 161
      ubuffree(zsys);
      }
    }
  } else {
    {
#line 161
    ubuffree(zsys);
    }
  }
#line 163
  if ((unsigned long )pbgrade != (unsigned long )((void *)0)) {
#line 164
    *pbgrade = *(zdot + 1);
  }
#line 166
  return (zret);
}
}
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 85 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/iswait.c"
int ixswait(unsigned long ipid , char const   *zreport ) 
{ 
  wait_status istat ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  union __anonunion_50 __constr_expr_1 ;
  union __anonunion_51 __constr_expr_2 ;
  int tmp___3 ;
  union __anonunion_52 __constr_expr_3 ;
  char const   *tmp___4 ;
  union __anonunion_54 __constr_expr_5 ;
  union __anonunion_55 __constr_expr_6 ;
  union __anonunion_56 __constr_expr_7 ;
  union __anonunion_57 __constr_expr_8 ;
  union __anonunion_58 __constr_expr_9 ;
  union __anonunion_59 __constr_expr_10 ;
  union __anonunion_60 __constr_expr_11 ;
  union __anonunion_61 __constr_expr_12 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp___2 = waitpid((pid_t )ipid, (int *)((pointer )(& istat)), 0);
    }
#line 93
    if (! (tmp___2 < 0)) {
#line 93
      goto while_break;
    }
    {
#line 95
    tmp___1 = __errno_location();
    }
#line 95
    if (*tmp___1 != 4) {
#line 97
      if ((unsigned long )zreport != (unsigned long )((void *)0)) {
        {
#line 98
        tmp = __errno_location();
#line 98
        tmp___0 = strerror(*tmp);
#line 98
        ulog((enum tlog )1, "waitpid: %s", tmp___0);
        }
      }
#line 99
      return (-1);
    }
    {
#line 101
    ulog((enum tlog )1, (char const   *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if ((iDebug & 256) != 0) {
#line 138
      __constr_expr_3.__in = istat;
#line 138
      if ((__constr_expr_3.__i & 127) == 0) {
#line 138
        __constr_expr_1.__in = istat;
#line 138
        tmp___3 = (__constr_expr_1.__i & 65280) >> 8;
      } else {
#line 138
        __constr_expr_2.__in = istat;
#line 138
        tmp___3 = __constr_expr_2.__i & 127;
      }
#line 138
      __constr_expr_5.__in = istat;
#line 138
      if ((__constr_expr_5.__i & 127) == 0) {
#line 138
        tmp___4 = "Exit status";
      } else {
#line 138
        tmp___4 = "Signal";
      }
      {
#line 138
      ulog((enum tlog )3, "%s %d", tmp___4, tmp___3);
      }
    }
#line 138
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 142
  __constr_expr_6.__in = istat;
#line 142
  if ((__constr_expr_6.__i & 127) == 0) {
#line 142
    __constr_expr_7.__in = istat;
#line 142
    if ((__constr_expr_7.__i & 65280) >> 8 == 0) {
#line 143
      return (0);
    }
  }
#line 145
  if ((unsigned long )zreport != (unsigned long )((void *)0)) {
#line 147
    __constr_expr_10.__in = istat;
#line 147
    if ((__constr_expr_10.__i & 127) == 0) {
      {
#line 150
      __constr_expr_9.__in = istat;
#line 150
      ulog((enum tlog )1, "%s: Exit status %d", zreport, (__constr_expr_9.__i & 65280) >> 8);
      }
    } else {
      {
#line 148
      __constr_expr_8.__in = istat;
#line 148
      ulog((enum tlog )1, "%s: Got signal %d", zreport, __constr_expr_8.__i & 127);
      }
    }
  }
#line 154
  __constr_expr_12.__in = istat;
#line 154
  if ((__constr_expr_12.__i & 127) == 0) {
#line 155
    __constr_expr_11.__in = istat;
#line 155
    return ((__constr_expr_11.__i & 65280) >> 8);
  } else {
#line 157
    return (-1);
  }
}
}
#line 773 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/isfork.c"
pid_t ixsfork(void) 
{ 
  int i ;
  pid_t iret ;
  int *tmp ;

  {
#line 16
  i = 0;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! (i < 10)) {
#line 16
      goto while_break;
    }
    {
#line 18
    iret = fork();
    }
#line 19
    if (iret >= 0) {
#line 20
      return (iret);
    } else {
      {
#line 19
      tmp = __errno_location();
      }
#line 19
      if (*tmp != 11) {
#line 20
        return (iret);
      }
    }
    {
#line 21
    sleep(5U);
#line 16
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return (iret);
}
}
#line 9 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/isdir.c"
boolean fsysdep_directory(char const   *z ) 
{ 
  struct stat s ;
  int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 15
  tmp = stat((char const   */* __restrict  */)((char *)z), (struct stat */* __restrict  */)(& s));
  }
#line 15
  if (tmp < 0) {
#line 16
    return (0);
  }
#line 17
  return ((s.st_mode & 61440U) == 16384U);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 49 "../system.h"
size_t cSysdep_max_name_len ;
#line 80
void usysdep_initialize(pointer puuconf , int iflags ) ;
#line 91
boolean fsysdep_other_config(char const   *z  __attribute__((__unused__)) ) ;
#line 102
char const   *zsysdep_localname(void) ;
#line 507 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 865
extern char *getlogin(void) ;
#line 895
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 993
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 551 "../sysdep.h"
char *zScwd  ;
#line 554 "../sysdep.h"
char const   *zSspooldir  ;
#line 557 "../sysdep.h"
char const   *zSlockdir  ;
#line 560 "../sysdep.h"
char const   *zSlocalname  ;
#line 117 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
static char *zSlogin  ;
#line 142 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
size_t cSysdep_max_name_len  =    (size_t )255;
#line 150 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
void usysdep_initialize(pointer puuconf , int iflags ) 
{ 
  int iuuconf ;
  char *z ;
  struct passwd *q ;
  __pid_t tmp ;
  int cdescs ;
  int o ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char ab___0[256] ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  __uid_t tmp___11 ;
  __uid_t tmp___12 ;
  __uid_t tmp___13 ;
  char const   *zenv ;
  struct stat senv ;
  struct stat sdot ;
  char *tmp___14 ;
  size_t c ;
  pointer tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  size_t tmp___18 ;
  pointer tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 159
  tmp = getpid();
#line 159
  ulog_id(tmp);
  }
#line 161
  if ((iflags & 8) == 0) {
    {
#line 168
    cdescs = getdtablesize();
#line 185
    o = 3;
    }
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      if (! (o < cdescs)) {
#line 185
        goto while_break;
      }
      {
#line 186
      close(o);
#line 185
      o ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 190
  tmp___0 = fcntl(0, 1, 0);
  }
#line 190
  if (tmp___0 < 0) {
    {
#line 190
    tmp___1 = open((char const   *)((char *)"/dev/null"), 0, 0);
    }
#line 190
    if (tmp___1 != 0) {
      {
#line 192
      exit(1);
      }
    }
  }
  {
#line 193
  tmp___2 = fcntl(1, 1, 0);
  }
#line 193
  if (tmp___2 < 0) {
    {
#line 193
    tmp___3 = open((char const   *)((char *)"/dev/null"), 1, 0);
    }
#line 193
    if (tmp___3 != 1) {
      {
#line 195
      exit(1);
      }
    }
  }
  {
#line 196
  tmp___4 = fcntl(2, 1, 0);
  }
#line 196
  if (tmp___4 < 0) {
    {
#line 196
    tmp___5 = open((char const   *)((char *)"/dev/null"), 1, 0);
    }
#line 196
    if (tmp___5 != 2) {
      {
#line 198
      exit(1);
      }
    }
  }
  {
#line 200
  iuuconf = uuconf_spooldir(puuconf, & zSspooldir);
  }
#line 201
  if (iuuconf != 0) {
    {
#line 202
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 204
  iuuconf = uuconf_lockdir(puuconf, & zSlockdir);
  }
#line 205
  if (iuuconf != 0) {
    {
#line 206
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 208
  iuuconf = uuconf_localname(puuconf, & zSlocalname);
  }
#line 209
  if (iuuconf == 1) {
    {
#line 214
    tmp___8 = gethostname(ab___0, sizeof(ab___0) - 1UL);
    }
#line 214
    if (tmp___8 < 0) {
      {
#line 215
      tmp___6 = __errno_location();
#line 215
      tmp___7 = strerror(*tmp___6);
#line 215
      ulog((enum tlog )2, "gethostname: %s", tmp___7);
      }
    }
    {
#line 216
    ab___0[sizeof(ab___0) - 1UL] = (char )'\000';
#line 217
    tmp___9 = strcspn((char const   *)(ab___0), ".");
#line 217
    ab___0[tmp___9] = (char )'\000';
#line 218
    tmp___10 = zbufcpy((char const   *)(ab___0));
#line 218
    zSlocalname = (char const   *)tmp___10;
    }
  } else
#line 231
  if (iuuconf != 0) {
    {
#line 232
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 235
  umask((__mode_t )0);
#line 241
  z = getenv("LOGNAME");
  }
#line 242
  if ((unsigned long )z == (unsigned long )((void *)0)) {
    {
#line 243
    z = getenv("USER");
    }
  }
#line 244
  if ((unsigned long )z == (unsigned long )((void *)0)) {
    {
#line 245
    z = getlogin();
    }
  }
#line 246
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 247
    q = (struct passwd *)((void *)0);
  } else {
    {
#line 250
    q = getpwnam((char const   *)z);
    }
#line 251
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 252
      z = q->pw_name;
    }
  }
#line 254
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 254
    goto _L;
  } else {
    {
#line 254
    tmp___12 = getuid();
    }
#line 254
    if (q->pw_uid != tmp___12) {
      _L: /* CIL Label */ 
      {
#line 256
      tmp___11 = getuid();
#line 256
      q = getpwuid(tmp___11);
      }
#line 257
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 258
        z = (char *)((void *)0);
      } else {
#line 260
        z = q->pw_name;
      }
    }
  }
#line 262
  if ((unsigned long )z != (unsigned long )((void *)0)) {
    {
#line 263
    zSlogin = zbufcpy((char const   *)z);
    }
  }
#line 270
  if ((iflags & 4) != 0) {
    {
#line 270
    tmp___13 = geteuid();
    }
#line 270
    if (tmp___13 == 0U) {
      {
#line 273
      q = getpwnam("uucp");
      }
#line 274
      if ((unsigned long )q != (unsigned long )((void *)0)) {
        {
#line 275
        setuid(q->pw_uid);
        }
      }
    }
  }
#line 278
  if ((iflags & 1) != 0) {
    {
#line 288
    tmp___14 = getenv("PWD");
#line 288
    zenv = (char const   *)tmp___14;
    }
#line 289
    if ((unsigned long )zenv != (unsigned long )((void *)0)) {
      {
#line 289
      tmp___20 = stat((char const   */* __restrict  */)((char *)zenv), (struct stat */* __restrict  */)(& senv));
      }
#line 289
      if (tmp___20 == 0) {
        {
#line 289
        tmp___21 = stat((char const   */* __restrict  */)((char *)"."), (struct stat */* __restrict  */)(& sdot));
        }
#line 289
        if (tmp___21 == 0) {
#line 289
          if (senv.st_ino == sdot.st_ino) {
#line 289
            if (senv.st_dev == sdot.st_dev) {
              {
#line 294
              zScwd = zbufcpy(zenv);
              }
            } else {
#line 289
              goto _L___3;
            }
          } else {
#line 289
            goto _L___3;
          }
        } else {
#line 289
          goto _L___3;
        }
      } else {
#line 289
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 302
      c = (size_t )128;
      {
#line 303
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 305
        tmp___15 = xmalloc(c);
#line 305
        zScwd = (char *)tmp___15;
#line 306
        tmp___16 = getcwd(zScwd, c);
        }
#line 306
        if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
#line 307
          goto while_break___0;
        }
        {
#line 308
        xfree((pointer )zScwd);
#line 309
        zScwd = (char *)((void *)0);
#line 310
        tmp___17 = __errno_location();
        }
#line 310
        if (*tmp___17 != 34) {
#line 311
          goto while_break___0;
        }
#line 312
        c <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 326
      if ((unsigned long )zScwd != (unsigned long )((void *)0)) {
        {
#line 327
        tmp___18 = strlen((char const   *)zScwd);
#line 327
        tmp___19 = xrealloc((pointer )zScwd, tmp___18 + 1UL);
#line 327
        zScwd = (char *)tmp___19;
        }
      }
    }
  }
#line 332
  if ((iflags & 2) == 0) {
    {
#line 336
    tmp___29 = chdir(zSspooldir);
    }
#line 336
    if (tmp___29 < 0) {
      {
#line 338
      tmp___24 = __errno_location();
      }
#line 338
      if (*tmp___24 == 2) {
        {
#line 338
        tmp___25 = mkdir((char const   *)((char *)zSspooldir), (__mode_t )((((448 | (256 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((64 >> 3) >> 3)));
        }
#line 338
        if (tmp___25 < 0) {
          {
#line 340
          tmp___22 = __errno_location();
#line 340
          tmp___23 = strerror(*tmp___22);
#line 340
          ulog((enum tlog )2, "mkdir (%s): %s", zSspooldir, tmp___23);
          }
        }
      }
      {
#line 342
      tmp___28 = chdir(zSspooldir);
      }
#line 342
      if (tmp___28 < 0) {
        {
#line 343
        tmp___26 = __errno_location();
#line 343
        tmp___27 = strerror(*tmp___26);
#line 343
        ulog((enum tlog )2, "chdir (%s): %s", zSspooldir, tmp___27);
        }
      }
    }
  }
#line 347
  return;
}
}
#line 351 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
void usysdep_exit(boolean fsuccess ) 
{ 
  int tmp ;

  {
#line 355
  if (fsuccess) {
#line 355
    tmp = 0;
  } else {
#line 355
    tmp = 1;
  }
  {
#line 355
  exit(tmp);
  }
}
}
#line 370 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
boolean fsysdep_other_config(char const   *z  __attribute__((__unused__)) ) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;

  {
  {
#line 373
  tmp = getuid();
#line 373
  setuid(tmp);
#line 374
  tmp___0 = getgid();
#line 374
  setgid(tmp___0);
  }
#line 375
  return (1);
}
}
#line 381 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
char const   *zsysdep_localname(void) 
{ 


  {
#line 384
  return (zSlocalname);
}
}
#line 391 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/init.c"
char const   *zsysdep_login_name(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 394
  if ((unsigned long )zSlogin == (unsigned long )((void *)0)) {
    {
#line 395
    ulog((enum tlog )2, "Can\'t get login name");
    }
  }
#line 396
  return ((char const   *)zSlogin);
}
}
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 202 "../system.h"
boolean fsysdep_in_directory(char const   *zfile , char const   *zdir , boolean fcheck ,
                             boolean freadable , char const   *zuser ) ;
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/indir.c"
boolean fsysdep_in_directory(char const   *zfile , char const   *zdir , boolean fcheck ,
                             boolean freadable , char const   *zuser ) 
{ 
  size_t c ;
  char *zcopy ;
  char *zslash ;
  struct stat s ;
  int tmp ;
  char *tmp___0 ;
  char b ;
  struct stat shold ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  boolean tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  boolean tmp___9 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 47
  if ((int const   )*zfile != 47) {
#line 48
    return (0);
  }
  {
#line 49
  c = strlen(zdir);
  }
#line 50
  if (c > 0UL) {
#line 50
    if ((int const   )*(zdir + (c - 1UL)) == 47) {
#line 51
      c --;
    }
  }
  {
#line 52
  tmp = strncmp(zfile, zdir, c);
  }
#line 52
  if (tmp != 0) {
#line 54
    return (0);
  } else
#line 52
  if ((int const   )*(zfile + c) != 47) {
#line 52
    if ((int const   )*(zfile + c) != 0) {
#line 54
      return (0);
    }
  }
  {
#line 55
  tmp___0 = strstr(zfile + c, "/../");
  }
#line 55
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 56
    return (0);
  }
#line 59
  if (! fcheck) {
#line 60
    return (1);
  }
  {
#line 62
  zcopy = zbufcpy(zfile);
#line 68
  zslash = zcopy + c;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    b = *zslash;
#line 75
    *zslash = (char )'\000';
#line 77
    shold = s;
#line 78
    tmp___4 = stat((char const   */* __restrict  */)zcopy, (struct stat */* __restrict  */)(& s));
    }
#line 78
    if (tmp___4 != 0) {
      {
#line 80
      tmp___3 = __errno_location();
      }
#line 80
      if (*tmp___3 != 2) {
        {
#line 82
        tmp___1 = __errno_location();
#line 82
        tmp___2 = strerror(*tmp___1);
#line 82
        ulog((enum tlog )1, "stat (%s): %s", zcopy, tmp___2);
#line 83
        ubuffree(zcopy);
        }
#line 84
        return (0);
      }
#line 89
      if ((unsigned long )zslash == (unsigned long )(zcopy + c)) {
        {
#line 91
        ubuffree(zcopy);
        }
#line 92
        return (1);
      }
#line 97
      s = shold;
#line 98
      goto while_break;
    }
#line 102
    if (! ((s.st_mode & 61440U) == 16384U)) {
#line 103
      goto while_break;
    }
    {
#line 106
    tmp___6 = fsuser_access((struct stat  const  *)(& s), 1, zuser);
    }
#line 106
    if (! tmp___6) {
      {
#line 108
      tmp___5 = strerror(13);
#line 108
      ulog((enum tlog )1, "%s: %s", zcopy, tmp___5);
#line 109
      ubuffree(zcopy);
      }
#line 110
      return (0);
    }
#line 114
    if ((int )b == 0) {
#line 115
      goto while_break;
    }
    {
#line 117
    *zslash = b;
#line 69
    zslash = strchr((char const   *)(zslash + 1), '/');
    }
#line 69
    if (! ((unsigned long )zslash != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  if (freadable) {
#line 123
    tmp___8 = 4;
  } else {
#line 123
    tmp___8 = 2;
  }
  {
#line 123
  tmp___9 = fsuser_access((struct stat  const  *)(& s), tmp___8, zuser);
  }
#line 123
  if (! tmp___9) {
    {
#line 125
    tmp___7 = strerror(13);
#line 125
    ulog((enum tlog )1, "%s: %s", zcopy, tmp___7);
#line 126
    ubuffree(zcopy);
    }
#line 127
    return (0);
  }
  {
#line 130
  ubuffree(zcopy);
  }
#line 131
  return (1);
}
}
#line 31 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/fsusg.h"
int get_fs_usage(char *path , char *disk  __attribute__((__unused__)) , struct fs_usage *fsp ) ;
#line 52 "/usr/include/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) statvfs)(char const   * __restrict  __file ,
                                                                                      struct statvfs * __restrict  __buf ) ;
#line 93 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/fsusg.c"
static long adjust_blocks(long blocks , int fromsize , int tosize ) ;
#line 99 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/fsusg.c"
static long adjust_blocks(long blocks , int fromsize , int tosize ) 
{ 
  int tmp ;

  {
#line 104
  if (tosize <= 0) {
    {
#line 105
    abort();
    }
  }
#line 106
  if (fromsize <= 0) {
#line 107
    return (-1L);
  }
#line 109
  if (fromsize == tosize) {
#line 110
    return (blocks);
  } else
#line 111
  if (fromsize > tosize) {
#line 112
    return (blocks * (long )(fromsize / tosize));
  } else {
#line 114
    if (blocks < 0L) {
#line 114
      tmp = -1;
    } else {
#line 114
      tmp = 1;
    }
#line 114
    return ((blocks + (long )tmp) / (long )(tosize / fromsize));
  }
}
}
#line 125 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/fsusg.c"
int get_fs_usage(char *path , char *disk  __attribute__((__unused__)) , struct fs_usage *fsp ) 
{ 
  struct statvfs fsd ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 194
  tmp = statvfs((char const   */* __restrict  */)path, (struct statvfs */* __restrict  */)(& fsd));
  }
#line 194
  if (tmp < 0) {
#line 195
    return (-1);
  }
#line 291
  if (fsd.f_frsize) {
#line 291
    tmp___0 = fsd.f_frsize;
  } else {
#line 291
    tmp___0 = fsd.f_bsize;
  }
  {
#line 291
  fsp->fsu_blocks = adjust_blocks((long )fsd.f_blocks, (int )tmp___0, 512);
  }
#line 292
  if (fsd.f_frsize) {
#line 292
    tmp___1 = fsd.f_frsize;
  } else {
#line 292
    tmp___1 = fsd.f_bsize;
  }
  {
#line 292
  fsp->fsu_bfree = adjust_blocks((long )fsd.f_bfree, (int )tmp___1, 512);
  }
#line 293
  if (fsd.f_frsize) {
#line 293
    tmp___2 = fsd.f_frsize;
  } else {
#line 293
    tmp___2 = fsd.f_bsize;
  }
  {
#line 293
  fsp->fsu_bavail = adjust_blocks((long )fsd.f_bavail, (int )tmp___2, 512);
#line 294
  fsp->fsu_files = (long )fsd.f_files;
#line 295
  fsp->fsu_ffree = (long )fsd.f_ffree;
  }
#line 301
  return (0);
}
}
#line 563 "../system.h"
char *zsysdep_data_file_name(struct uuconf_system  const  *qsys , char const   *zlocalname ,
                             int bgrade , boolean fxqt , char *ztname , char *zdname ,
                             char *zxname ) ;
#line 571
char *zsysdep_xqt_file_name(void) ;
#line 85 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
static boolean fscmd_seq(char const   *zsystem , char *zseq ) ;
#line 86
static char *zsfile_name(int btype , char const   *zsystem , char const   *zlocalname ,
                         int bgrade , boolean fxqt , char *ztname , char *zdname ,
                         char *zxname ) ;
#line 97 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
static boolean fscmd_seq(char const   *zsystem , char *zseq ) 
{ 
  int cdelay ;
  char *zfree ;
  char const   *zfile ;
  int o ;
  boolean flockfile___0 ;
  int i ;
  boolean fret ;
  boolean tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct flock slock ;
  boolean fagain ;
  boolean ferr ;
  boolean tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  ssize_t tmp___11 ;
  char const   *zdig ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  __off_t tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 110
  cdelay = 5;
#line 128
  zfree = (char *)((void *)0);
#line 147
  zfree = zsysdep_in_dir(zsystem, "SEQF");
#line 148
  zfile = (char const   *)zfree;
#line 152
  o = open((char const   *)((char *)zfile), 322, 384);
  }
#line 166
  if (o < 0) {
    {
#line 168
    tmp___0 = __errno_location();
    }
#line 168
    if (*tmp___0 == 2) {
      {
#line 170
      tmp = fsysdep_make_dirs(zfile, 0);
      }
#line 170
      if (! tmp) {
#line 175
        return (0);
      }
      {
#line 178
      o = open((char const   *)((char *)zfile), 322, 384);
      }
    }
#line 190
    if (o < 0) {
      {
#line 192
      tmp___1 = __errno_location();
#line 192
      tmp___2 = strerror(*tmp___1);
#line 192
      ulog((enum tlog )1, "open (%s): %s", zfile, tmp___2);
      }
#line 196
      return (0);
    }
  }
#line 206
  flockfile___0 = 0;
#line 208
  slock.l_type = (short)1;
#line 209
  slock.l_whence = (short)0;
#line 210
  slock.l_start = (__off_t )0;
#line 211
  slock.l_len = (__off_t )0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    tmp___10 = fcntl(o, 7, & slock);
    }
#line 212
    if (! (tmp___10 == -1)) {
#line 212
      goto while_break;
    }
    {
#line 219
    tmp___4 = __errno_location();
    }
#line 219
    if (*tmp___4 == 22) {
      {
#line 224
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 224
        tmp___3 = fsdo_lock("LCK..SEQ", 1, & ferr);
        }
#line 224
        if (tmp___3) {
#line 224
          goto while_break___0;
        }
#line 226
        if (ferr) {
          {
#line 228
          close(o);
          }
#line 229
          return (0);
        } else
#line 226
        if (afSignal[0]) {
          {
#line 228
          close(o);
          }
#line 229
          return (0);
        } else
#line 226
        if (afSignal[1]) {
          {
#line 228
          close(o);
          }
#line 229
          return (0);
        } else
#line 226
        if (afSignal[2]) {
          {
#line 228
          close(o);
          }
#line 229
          return (0);
        } else
#line 226
        if (afSignal[3]) {
          {
#line 228
          close(o);
          }
#line 229
          return (0);
        } else
#line 226
        if (afSignal[4]) {
          {
#line 228
          close(o);
          }
#line 229
          return (0);
        }
        {
#line 231
        sleep((unsigned int )cdelay);
        }
#line 232
        if (cdelay < 60) {
#line 233
          cdelay ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 236
      flockfile___0 = 1;
#line 238
      goto while_break;
    }
    {
#line 241
    fagain = 0;
#line 242
    tmp___5 = __errno_location();
    }
#line 242
    if (*tmp___5 == 12) {
#line 243
      fagain = 1;
    }
    {
#line 245
    tmp___6 = __errno_location();
    }
#line 245
    if (*tmp___6 == 37) {
#line 246
      fagain = 1;
    }
    {
#line 249
    tmp___7 = __errno_location();
    }
#line 249
    if (*tmp___7 == 28) {
#line 250
      fagain = 1;
    }
#line 252
    if (fagain) {
      {
#line 254
      sleep((unsigned int )cdelay);
      }
#line 255
      if (cdelay < 60) {
#line 256
        cdelay ++;
      }
#line 257
      goto while_continue;
    }
    {
#line 259
    tmp___8 = __errno_location();
#line 259
    tmp___9 = strerror(*tmp___8);
#line 259
    ulog((enum tlog )1, "Locking %s: %s", zfile, tmp___9);
#line 260
    close(o);
    }
#line 261
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  tmp___11 = read(o, (void *)zseq, (size_t )4);
  }
#line 266
  if (tmp___11 != 4L) {
    {
#line 267
    strcpy((char */* __restrict  */)zseq, (char const   */* __restrict  */)"0000");
    }
  }
#line 268
  *(zseq + 4) = (char )'\000';
#line 283
  i = 3;
  {
#line 283
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 283
    if (! (i >= 0)) {
#line 283
      goto while_break___1;
    }
    {
#line 287
    tmp___12 = strchr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", (int )*(zseq + i));
#line 287
    zdig = (char const   *)tmp___12;
    }
#line 288
    if ((unsigned long )zdig == (unsigned long )((void *)0)) {
#line 289
      *(zseq + i) = (char )'0';
    } else
#line 288
    if ((int const   )*(zdig + 0) == 0) {
#line 289
      *(zseq + i) = (char )'0';
    } else
#line 288
    if ((int const   )*(zdig + 1) == 0) {
#line 289
      *(zseq + i) = (char )'0';
    } else {
#line 292
      *(zseq + i) = (char )*(zdig + 1);
#line 293
      goto while_break___1;
    }
#line 283
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 298
  fret = 1;
#line 300
  tmp___15 = lseek(o, (off_t )0, 0);
  }
#line 300
  if (tmp___15 < 0L) {
    {
#line 304
    tmp___13 = __errno_location();
#line 304
    tmp___14 = strerror(*tmp___13);
#line 304
    ulog((enum tlog )1, "lseek or write or close %s: %s", zfile, tmp___14);
#line 306
    close(o);
#line 307
    fret = 0;
    }
  } else {
    {
#line 300
    tmp___16 = write(o, (void const   *)zseq, (size_t )4);
    }
#line 300
    if (tmp___16 != 4L) {
      {
#line 304
      tmp___13 = __errno_location();
#line 304
      tmp___14 = strerror(*tmp___13);
#line 304
      ulog((enum tlog )1, "lseek or write or close %s: %s", zfile, tmp___14);
#line 306
      close(o);
#line 307
      fret = 0;
      }
    } else {
      {
#line 300
      tmp___17 = close(o);
      }
#line 300
      if (tmp___17 < 0) {
        {
#line 304
        tmp___13 = __errno_location();
#line 304
        tmp___14 = strerror(*tmp___13);
#line 304
        ulog((enum tlog )1, "lseek or write or close %s: %s", zfile, tmp___14);
#line 306
        close(o);
#line 307
        fret = 0;
        }
      }
    }
  }
#line 310
  if (flockfile___0) {
    {
#line 311
    fsdo_unlock("LCK..SEQ", 1);
    }
  }
  {
#line 313
  ubuffree(zfree);
  }
#line 315
  return (fret);
}
}
#line 331 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
static char *zsfile_name(int btype , char const   *zsystem , char const   *zlocalname ,
                         int bgrade , boolean fxqt , char *ztname , char *zdname ,
                         char *zxname ) 
{ 
  char abseq[5] ;
  char absimple[15] ;
  char *zname ;
  boolean tmp ;
  boolean tmp___0 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 346
  if ((unsigned long )zlocalname == (unsigned long )((void *)0)) {
#line 347
    zlocalname = zSlocalname;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 351
    tmp = fscmd_seq(zsystem, abseq);
    }
#line 351
    if (! tmp) {
#line 352
      return ((char *)((void *)0));
    }
#line 354
    if (btype == 67) {
      {
#line 359
      sprintf((char */* __restrict  */)(absimple), (char const   */* __restrict  */)"C.%c%s",
              bgrade, abseq);
      }
    } else
#line 362
    if (btype == 68) {
#line 376
      if (fxqt) {
        {
#line 377
        sprintf((char */* __restrict  */)(absimple), (char const   */* __restrict  */)"D.X%s",
                abseq);
        }
      } else {
        {
#line 379
        sprintf((char */* __restrict  */)(absimple), (char const   */* __restrict  */)"D.%s",
                abseq);
        }
      }
    } else {
      {
#line 385
      ulog((enum tlog )2, "zsfile_name: Can\'t happen");
      }
    }
    {
#line 388
    zname = zsfind_file((char const   *)(absimple), zsystem, bgrade);
    }
#line 389
    if ((unsigned long )zname == (unsigned long )((void *)0)) {
#line 390
      return ((char *)((void *)0));
    }
    {
#line 392
    tmp___0 = fsysdep_file_exists((char const   *)zname);
    }
#line 392
    if (! tmp___0) {
#line 393
      goto while_break;
    }
    {
#line 395
    ubuffree(zname);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  if ((unsigned long )ztname != (unsigned long )((void *)0)) {
    {
#line 399
    strcpy((char */* __restrict  */)ztname, (char const   */* __restrict  */)(absimple));
    }
  }
#line 401
  if ((unsigned long )zdname != (unsigned long )((void *)0)) {
    {
#line 402
    sprintf((char */* __restrict  */)zdname, (char const   */* __restrict  */)"D.%.7s%c%s",
            zlocalname, bgrade, abseq);
    }
  }
#line 404
  if ((unsigned long )zxname != (unsigned long )((void *)0)) {
    {
#line 405
    sprintf((char */* __restrict  */)zxname, (char const   */* __restrict  */)"X.%.7s%c%s",
            zlocalname, bgrade, abseq);
    }
  }
#line 407
  return (zname);
}
}
#line 422 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
char *zsysdep_data_file_name(struct uuconf_system  const  *qsys , char const   *zlocalname ,
                             int bgrade , boolean fxqt , char *ztname , char *zdname ,
                             char *zxname ) 
{ 
  char *tmp ;

  {
  {
#line 433
  tmp = zsfile_name('D', (char const   *)qsys->uuconf_zname, zlocalname, bgrade, fxqt,
                    ztname, zdname, zxname);
  }
#line 433
  return (tmp);
}
}
#line 443
static void usput62(long i , char *z , int c ) ;
#line 445 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
static void usput62(long i , char *z , int c ) 
{ 
  int d ;

  {
#line 451
  c --;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (c >= 0)) {
#line 451
      goto while_break;
    }
#line 455
    d = (int )(i % 62L);
#line 456
    i /= 62L;
#line 457
    if (d < 26) {
#line 458
      *(z + c) = (char )(65 + d);
    } else
#line 459
    if (d < 52) {
#line 460
      *(z + c) = (char )((97 + d) - 26);
    } else {
#line 462
      *(z + c) = (char )((48 + d) - 52);
    }
#line 451
    c --;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 470 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
char *zscmd_file(struct uuconf_system  const  *qsys , int bgrade ) 
{ 
  char *zname ;
  long isecs ;
  long imicros ;
  pid_t ipid ;
  char ab___0[15] ;
  boolean tmp ;
  void *__cil_tmp9 ;

  {
  {
#line 496
  isecs = ixsysdep_time(& imicros);
#line 497
  ipid = getpid();
#line 507
  isecs %= 86400L;
#line 510
  imicros %= 1000000L;
#line 511
  imicros /= 5L;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 517
    ab___0[0] = (char )'C';
#line 518
    ab___0[1] = (char )'.';
#line 519
    ab___0[2] = (char )bgrade;
#line 520
    usput62(isecs, ab___0 + 3, 3);
#line 521
    usput62(imicros, ab___0 + 6, 3);
#line 522
    usput62((long )ipid, ab___0 + 9, 5);
#line 523
    ab___0[14] = (char )'\000';
#line 525
    zname = zsfind_file((char const   *)(ab___0), (char const   *)qsys->uuconf_zname,
                        bgrade);
    }
#line 526
    if ((unsigned long )zname == (unsigned long )((void *)0)) {
#line 527
      return ((char *)((void *)0));
    }
    {
#line 529
    tmp = fsysdep_file_exists((char const   *)zname);
    }
#line 529
    if (! tmp) {
#line 530
      goto while_break;
    }
    {
#line 532
    ubuffree(zname);
    }
#line 540
    if (imicros == 0L) {
#line 542
      imicros = 238328L;
#line 543
      if (isecs == 0L) {
#line 544
        isecs = 238328L;
      }
#line 545
      isecs --;
    }
#line 547
    imicros --;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  return (zname);
}
}
#line 558 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/filnam.c"
char *zsysdep_xqt_file_name(void) 
{ 
  char abseq[5] ;
  char absx[15] ;
  char *zname ;
  boolean tmp ;
  boolean tmp___0 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 567
    tmp = fscmd_seq(zSlocalname, abseq);
    }
#line 567
    if (! tmp) {
#line 568
      return ((char *)((void *)0));
    }
    {
#line 570
    sprintf((char */* __restrict  */)(absx), (char const   */* __restrict  */)"X.%.7sX%s",
            zSlocalname, abseq);
#line 572
    zname = zsfind_file((char const   *)(absx), zSlocalname, -1);
    }
#line 573
    if ((unsigned long )zname == (unsigned long )((void *)0)) {
#line 574
      return ((char *)((void *)0));
    }
    {
#line 576
    tmp___0 = fsysdep_file_exists((char const   *)zname);
    }
#line 576
    if (! tmp___0) {
#line 577
      goto while_break;
    }
    {
#line 579
    ubuffree(zname);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  return (zname);
}
}
#line 352 "../system.h"
char *zsysdep_save_failed_file(char const   *zfile ) ;
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/failed.c"
char *zsysdep_save_failed_file(char const   *zfile ) 
{ 
  char *zto ;
  boolean tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 16
  zto = zsappend3(zSspooldir, ".Failed", zfile);
#line 18
  tmp = fsysdep_move_file(zfile, (char const   *)zto, 1, 0, 0, (char const   *)((void *)0));
  }
#line 18
  if (! tmp) {
    {
#line 21
    ubuffree(zto);
    }
#line 22
    return ((char *)((void *)0));
  }
#line 25
  return (zto);
}
}
#line 9 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/exists.c"
boolean fsysdep_file_exists(char const   *zfile ) 
{ 
  struct stat s ;
  int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 15
  tmp = stat((char const   */* __restrict  */)((char *)zfile), (struct stat */* __restrict  */)(& s));
  }
#line 15
  return (tmp == 0);
}
}
#line 36 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/epopen.c"
FILE *espopen(char const   **pazargs , boolean frd , pid_t *pipid ) 
{ 
  int aidescs[3] ;
  pid_t ipid ;
  FILE *eret ;
  int ierr ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 46
  if (frd) {
#line 48
    aidescs[0] = -1;
#line 49
    aidescs[1] = -2;
  } else {
#line 53
    aidescs[0] = -3;
#line 54
    aidescs[1] = -1;
  }
  {
#line 56
  aidescs[2] = -1;
#line 58
  ipid = ixsspawn(pazargs, aidescs, 1, 0, (char const   *)((void *)0), 0, 1, (char const   *)((void *)0),
                  (char const   *)((void *)0), (char const   *)((void *)0));
  }
#line 62
  if (ipid < 0) {
#line 63
    return ((FILE *)((void *)0));
  }
#line 65
  if (frd) {
    {
#line 66
    eret = fdopen(aidescs[1], (char const   *)((char *)"r"));
    }
  } else {
    {
#line 68
    eret = fdopen(aidescs[0], (char const   *)((char *)"w"));
    }
  }
#line 69
  if ((unsigned long )eret == (unsigned long )((void *)0)) {
    {
#line 73
    tmp = __errno_location();
#line 73
    ierr = *tmp;
    }
#line 74
    if (frd) {
#line 74
      tmp___0 = aidescs[1];
    } else {
#line 74
      tmp___0 = aidescs[0];
    }
    {
#line 74
    close(tmp___0);
#line 75
    kill(ipid, 9);
#line 76
    ixswait((unsigned long )ipid, (char const   *)((void *)0));
#line 77
    tmp___1 = __errno_location();
#line 77
    *tmp___1 = ierr;
    }
#line 78
    return ((FILE *)((void *)0));
  }
#line 81
  *pipid = ipid;
#line 83
  return (eret);
}
}
#line 40 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/efopen.c"
FILE *esysdep_fopen(char const   *zfile , boolean fpublic , boolean fappend , boolean fmkdirs ) 
{ 
  int imode ;
  int o ;
  FILE *e ;
  boolean tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 51
  if (fpublic) {
#line 52
    imode = (384 | (256 >> 3)) | ((256 >> 3) >> 3);
  } else {
#line 54
    imode = 384;
  }
#line 56
  if (! fappend) {
    {
#line 57
    o = creat((char const   *)((char *)zfile), (__mode_t )imode);
    }
  } else {
    {
#line 61
    o = open((char const   *)((char *)zfile), 1345, imode);
    }
  }
#line 71
  if (o < 0) {
    {
#line 73
    tmp___0 = __errno_location();
    }
#line 73
    if (*tmp___0 == 2) {
#line 73
      if (fmkdirs) {
        {
#line 75
        tmp = fsysdep_make_dirs(zfile, fpublic);
        }
#line 75
        if (! tmp) {
#line 76
          return ((FILE *)((void *)0));
        }
#line 77
        if (! fappend) {
          {
#line 78
          o = creat((char const   *)((char *)zfile), (__mode_t )imode);
          }
        } else {
          {
#line 82
          o = open((char const   *)((char *)zfile), 1345, imode);
          }
        }
      }
    }
#line 90
    if (o < 0) {
      {
#line 92
      tmp___1 = __errno_location();
#line 92
      tmp___2 = strerror(*tmp___1);
#line 92
      ulog((enum tlog )1, "open (%s): %s", zfile, tmp___2);
      }
#line 93
      return ((FILE *)((void *)0));
    }
  }
  {
#line 112
  tmp___5 = fcntl(o, 1, 0);
#line 112
  tmp___6 = fcntl(o, 2, tmp___5 | 1);
  }
#line 112
  if (tmp___6 < 0) {
    {
#line 114
    tmp___3 = __errno_location();
#line 114
    tmp___4 = strerror(*tmp___3);
#line 114
    ulog((enum tlog )1, "fcntl (%s, FD_CLOEXEC): %s", zfile, tmp___4);
#line 116
    close(o);
    }
#line 117
    return ((FILE *)((void *)0));
  }
#line 120
  if (fappend) {
    {
#line 121
    e = fdopen(o, (char const   *)((char *)"a"));
    }
  } else {
    {
#line 123
    e = fdopen(o, (char const   *)((char *)"w"));
    }
  }
#line 125
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 127
    tmp___7 = __errno_location();
#line 127
    tmp___8 = strerror(*tmp___7);
#line 127
    ulog((enum tlog )1, "fdopen: %s", tmp___8);
#line 128
    close(o);
    }
  }
#line 131
  return (e);
}
}
#line 626 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 684
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 68 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/detach.c"
void usysdep_detach(void) 
{ 
  pid_t igrp ;
  boolean fignored ;
  pid_t ipid ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  __pid_t tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 76
  ulog((enum tlog )0, (char const   *)((void *)0));
#line 82
  igrp = getpgrp();
#line 85
  tmp___2 = getpid();
  }
#line 85
  if (igrp == tmp___2) {
    {
#line 92
    usset_signal(1, (void (*)(int  ))1, 0, & fignored);
#line 94
    ipid = ixsfork();
    }
#line 95
    if (ipid < 0) {
      {
#line 96
      tmp = __errno_location();
#line 96
      tmp___0 = strerror(*tmp);
#line 96
      ulog((enum tlog )2, "fork: %s", tmp___0);
      }
    }
#line 98
    if (ipid != 0) {
      {
#line 99
      _exit(0);
      }
    }
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 104
      tmp___1 = getppid();
      }
#line 104
      if (! (tmp___1 != 1)) {
#line 104
        goto while_break;
      }
      {
#line 105
      sleep(1U);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 107
    ipid = getpid();
#line 108
    ulog_id(ipid);
    }
#line 111
    if (! fignored) {
      {
#line 112
      usset_signal(1, & ussignal, 1, (boolean *)((void *)0));
      }
    }
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if ((iDebug & 32) != 0) {
        {
#line 114
        ulog((enum tlog )3, "usysdep_detach: Forked; old PID %ld, new pid %ld", (long )igrp,
             (long )ipid);
        }
      }
#line 114
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 136
  close(0);
#line 137
  close(1);
#line 138
  close(2);
#line 139
  tmp___5 = open((char const   *)((char *)"/dev/null"), 0);
  }
#line 139
  if (tmp___5 != 0) {
    {
#line 142
    tmp___3 = __errno_location();
#line 142
    tmp___4 = strerror(*tmp___3);
#line 142
    ulog((enum tlog )2, "open (/dev/null): %s", tmp___4);
    }
  } else {
    {
#line 139
    tmp___6 = open((char const   *)((char *)"/dev/null"), 1);
    }
#line 139
    if (tmp___6 != 1) {
      {
#line 142
      tmp___3 = __errno_location();
#line 142
      tmp___4 = strerror(*tmp___3);
#line 142
      ulog((enum tlog )2, "open (/dev/null): %s", tmp___4);
      }
    } else {
      {
#line 139
      tmp___7 = open((char const   *)((char *)"/dev/null"), 1);
      }
#line 139
      if (tmp___7 != 2) {
        {
#line 142
        tmp___3 = __errno_location();
#line 142
        tmp___4 = strerror(*tmp___3);
#line 142
        ulog((enum tlog )2, "open (/dev/null): %s", tmp___4);
        }
      }
    }
  }
  {
#line 149
  tmp___10 = setsid();
  }
#line 149
  if (tmp___10 < 0) {
    {
#line 150
    tmp___8 = __errno_location();
#line 150
    tmp___9 = strerror(*tmp___8);
#line 150
    ulog((enum tlog )1, "setsid: %s", tmp___9);
    }
  }
#line 180
  return;
}
}
#line 722 "../system.h"
char *zsysdep_add_cwd(char const   *zfile ) ;
#line 730
boolean fsysdep_needs_cwd(char const   *zfile ) ;
#line 14 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cwd.c"
boolean fsysdep_needs_cwd(char const   *zfile ) 
{ 
  int tmp ;

  {
#line 18
  if ((int const   )*zfile != 47) {
#line 18
    if ((int const   )*zfile != 126) {
#line 18
      tmp = 1;
    } else {
#line 18
      tmp = 0;
    }
  } else {
#line 18
    tmp = 0;
  }
#line 18
  return (tmp);
}
}
#line 26 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cwd.c"
char *zsysdep_local_file_cwd(char const   *zfile , char const   *zpubdir , boolean *pfbadname ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 32
  if ((unsigned long )pfbadname != (unsigned long )((void *)0)) {
#line 33
    *pfbadname = 0;
  }
#line 34
  if ((int const   )*zfile == 47) {
    {
#line 35
    tmp = zbufcpy(zfile);
    }
#line 35
    return (tmp);
  } else
#line 36
  if ((int const   )*zfile == 126) {
    {
#line 37
    tmp___0 = zsysdep_local_file(zfile, zpubdir, pfbadname);
    }
#line 37
    return (tmp___0);
  } else {
    {
#line 39
    tmp___1 = zsysdep_add_cwd(zfile);
    }
#line 39
    return (tmp___1);
  }
}
}
#line 44 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cwd.c"
char *zsysdep_add_cwd(char const   *zfile ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 48
  if ((int const   )*zfile == 47) {
    {
#line 49
    tmp = zbufcpy(zfile);
    }
#line 49
    return (tmp);
  } else
#line 48
  if ((int const   )*zfile == 126) {
    {
#line 49
    tmp = zbufcpy(zfile);
    }
#line 49
    return (tmp);
  }
#line 51
  if ((unsigned long )zScwd == (unsigned long )((void *)0)) {
    {
#line 53
    ulog((enum tlog )1, "Can\'t determine current directory");
    }
#line 54
    return ((char *)((void *)0));
  }
  {
#line 57
  tmp___0 = zsysdep_in_dir((char const   *)zScwd, zfile);
  }
#line 57
  return (tmp___0);
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
char const   cusub_rcsid[50]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'u',      (char const   )'s', 
        (char const   )'u',      (char const   )'b',      (char const   )'.',      (char const   )'c', 
        (char const   )',',      (char const   )'v',      (char const   )' ',      (char const   )'1', 
        (char const   )'.',      (char const   )'2',      (char const   )'7',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'2', 
        (char const   )'/',      (char const   )'0',      (char const   )'3',      (char const   )'/', 
        (char const   )'0',      (char const   )'5',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )':',      (char const   )'1',      (char const   )'0', 
        (char const   )':',      (char const   )'4',      (char const   )'2',      (char const   )' ', 
        (char const   )'i',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'R',      (char const   )'e',      (char const   )'l',      (char const   )' ', 
        (char const   )'$',      (char const   )'\000'};
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 465
extern int pause(void) ;
#line 870 "../system.h"
boolean fsysdep_port_access(struct uuconf_port *qport ) ;
#line 875
boolean fsysdep_port_is_line(struct uuconf_port *qport , char const   *zline ) ;
#line 885
boolean fsysdep_terminal_raw(boolean flocalecho ) ;
#line 889
boolean fsysdep_terminal_restore(void) ;
#line 895
char *zsysdep_terminal_line(char const   *zprompt ) ;
#line 901
boolean fsysdep_terminal_puts(char const   *zline ) ;
#line 907
boolean fsysdep_terminal_signals(boolean faccept ) ;
#line 918
boolean fsysdep_cu_init(struct sconnection *qconn ) ;
#line 928
boolean fsysdep_cu(struct sconnection *qconn , char *pbcmd , char const   *zlocalname ) ;
#line 936
boolean fsysdep_cu_copy(boolean fcopy ) ;
#line 941
boolean fsysdep_cu_finish(void) ;
#line 958
boolean fsysdep_shell(struct sconnection *qconn , char const   *zcmd , enum tshell_cmd tcmd ) ;
#line 964
boolean fsysdep_chdir(char const   *zdir ) ;
#line 969
boolean fsysdep_suspend(void) ;
#line 29 "../cu.h"
extern char const   *zCuvar_escape ;
#line 37
extern char const   *zCuvar_eol ;
#line 232 "../conn.h"
extern boolean fconn_write(struct sconnection *qconn , char const   *zbuf , size_t cbytes ) ;
#line 127 "../prot.h"
extern char abPrecbuf[16384] ;
#line 130
extern int iPrecstart ;
#line 133
extern int iPrecend ;
#line 94 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static char bSeof  ;
#line 97 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static char bStstp  ;
#line 101
static char const   *zsport_line(struct uuconf_port  const  *qport ) ;
#line 102
static void uscu_child(struct sconnection *qconn , int opipe ) ;
#line 103
static void uscu_child_handler(int isig ) ;
#line 104
static void uscu_alarm(int isig  __attribute__((__unused__)) ) ;
#line 105
static int cscu_escape(char *pbcmd , char const   *zlocalname ) ;
#line 106
static void uscu_alarm_kill(int isig  __attribute__((__unused__)) ) ;
#line 110 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static char const   *zsport_line(struct uuconf_port  const  *qport ) 
{ 
  char const   *zline ;

  {
#line 116
  if ((unsigned long )qport == (unsigned long )((void *)0)) {
#line 117
    return ((char const   *)((void *)0));
  }
  {
#line 124
  if ((unsigned int const   )qport->uuconf_ttype == 2U) {
#line 124
    goto case_2;
  }
#line 127
  if ((unsigned int const   )qport->uuconf_ttype == 3U) {
#line 127
    goto case_3;
  }
#line 132
  if ((unsigned int const   )qport->uuconf_ttype == 6U) {
#line 132
    goto case_6;
  }
#line 132
  if ((unsigned int const   )qport->uuconf_ttype == 5U) {
#line 132
    goto case_6;
  }
#line 132
  if ((unsigned int const   )qport->uuconf_ttype == 4U) {
#line 132
    goto case_6;
  }
#line 121
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 123
  return ((char const   *)((void *)0));
  case_2: /* CIL Label */ 
#line 125
  zline = (char const   *)qport->uuconf_u.uuconf_smodem.uuconf_zdevice;
#line 126
  goto switch_break;
  case_3: /* CIL Label */ 
#line 128
  zline = (char const   *)qport->uuconf_u.uuconf_sdirect.uuconf_zdevice;
#line 129
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 133
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 136
  if ((unsigned long )zline == (unsigned long )((void *)0)) {
#line 137
    zline = (char const   *)qport->uuconf_zname;
  }
#line 138
  return (zline);
}
}
#line 143 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_port_access(struct uuconf_port *qport ) 
{ 
  char const   *zline ;
  char *zfree ;
  boolean fret ;
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 151
  zline = zsport_line((struct uuconf_port  const  *)qport);
  }
#line 152
  if ((unsigned long )zline == (unsigned long )((void *)0)) {
#line 153
    return (1);
  }
#line 155
  zfree = (char *)((void *)0);
#line 156
  if ((int const   )*zline != 47) {
    {
#line 158
    tmp = strlen(zline);
#line 158
    zfree = zbufalc(sizeof("/dev/") + tmp);
#line 159
    sprintf((char */* __restrict  */)zfree, (char const   */* __restrict  */)"/dev/%s",
            zline);
#line 160
    zline = (char const   *)zfree;
    }
  }
  {
#line 163
  tmp___0 = access(zline, 6);
#line 163
  fret = tmp___0 == 0;
#line 164
  ubuffree(zfree);
  }
#line 165
  return (fret);
}
}
#line 170 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_port_is_line(struct uuconf_port *qport , char const   *zline ) 
{ 
  char const   *zpline ;
  char *zfree1 ;
  char *zfree2 ;
  boolean fret ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 179
  zpline = zsport_line((struct uuconf_port  const  *)qport);
  }
#line 180
  if ((unsigned long )zpline == (unsigned long )((void *)0)) {
#line 181
    return (0);
  }
  {
#line 183
  tmp = strcmp(zline, zpline);
  }
#line 183
  if (tmp == 0) {
#line 184
    return (1);
  }
#line 186
  zfree1 = (char *)((void *)0);
#line 187
  zfree2 = (char *)((void *)0);
#line 188
  if ((int const   )*zline != 47) {
    {
#line 190
    tmp___0 = strlen(zline);
#line 190
    zfree1 = zbufalc(sizeof("/dev/") + tmp___0);
#line 191
    sprintf((char */* __restrict  */)zfree1, (char const   */* __restrict  */)"/dev/%s",
            zline);
#line 192
    zline = (char const   *)zfree1;
    }
  }
#line 194
  if ((int const   )*zpline != 47) {
    {
#line 196
    tmp___1 = strlen(zpline);
#line 196
    zfree2 = zbufalc(sizeof("/dev/") + tmp___1);
#line 197
    sprintf((char */* __restrict  */)zfree2, (char const   */* __restrict  */)"/dev/%s",
            zpline);
#line 198
    zpline = (char const   *)zfree2;
    }
  }
  {
#line 201
  tmp___2 = strcmp(zline, zpline);
#line 201
  fret = tmp___2 == 0;
#line 202
  ubuffree(zfree1);
#line 203
  ubuffree(zfree2);
  }
#line 204
  return (fret);
}
}
#line 219 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static pid_t volatile   iSchild  ;
#line 222 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static int oSpipe  ;
#line 232 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_cu_init(struct sconnection *qconn ) 
{ 
  int ai[2] ;
  char *z ;
  int c ;
  int cwrote ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  pid_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (iPrecend != iPrecstart)) {
#line 241
      goto while_break;
    }
#line 246
    z = abPrecbuf + iPrecstart;
#line 247
    if (iPrecend > iPrecstart) {
#line 248
      c = iPrecend - iPrecstart;
    } else {
#line 250
      c = 16384 - iPrecstart;
    }
#line 252
    iPrecstart = (iPrecstart + c) % 16384;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (c > 0)) {
#line 254
        goto while_break___0;
      }
      {
#line 258
      tmp = write(1, (void const   *)z, (size_t )c);
#line 258
      cwrote = (int )tmp;
      }
#line 259
      if (cwrote <= 0) {
#line 261
        if (cwrote < 0) {
          {
#line 262
          tmp___0 = __errno_location();
#line 262
          tmp___1 = strerror(*tmp___0);
#line 262
          ulog((enum tlog )1, "write: %s", tmp___1);
          }
        } else {
          {
#line 264
          ulog((enum tlog )1, "Line disconnected");
          }
        }
#line 265
        return (0);
      }
#line 267
      c -= cwrote;
#line 268
      z += cwrote;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  tmp___4 = pipe((int *)(ai));
  }
#line 272
  if (tmp___4 < 0) {
    {
#line 274
    tmp___2 = __errno_location();
#line 274
    tmp___3 = strerror(*tmp___2);
#line 274
    ulog((enum tlog )1, "pipe: %s", tmp___3);
    }
#line 275
    return (0);
  }
  {
#line 278
  tmp___5 = ixsfork();
#line 278
  iSchild = (pid_t volatile   )tmp___5;
  }
#line 279
  if (iSchild < (pid_t volatile   )0) {
    {
#line 281
    tmp___6 = __errno_location();
#line 281
    tmp___7 = strerror(*tmp___6);
#line 281
    ulog((enum tlog )1, "fork: %s", tmp___7);
    }
#line 282
    return (0);
  }
#line 285
  if (iSchild == (pid_t volatile   )0) {
    {
#line 287
    close(ai[0]);
#line 288
    uscu_child(qconn, ai[1]);
    }
  }
  {
#line 292
  close(ai[1]);
#line 294
  oSpipe = ai[0];
  }
#line 296
  return (1);
}
}
#line 303 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_cu(struct sconnection *qconn , char *pbcmd , char const   *zlocalname ) 
{ 
  boolean fstart ;
  char b ;
  int c ;
  ssize_t tmp ;
  boolean tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 313
  fstart = 1;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 325
    tmp = read(0, (void *)(& b), (size_t )1);
#line 325
    c = (int )tmp;
    }
#line 329
    if (c <= 0) {
#line 330
      goto while_break;
    }
#line 332
    if (fstart) {
#line 332
      if ((int )b == (int )*zCuvar_escape) {
#line 332
        if ((int )b != 0) {
          {
#line 334
          c = cscu_escape(pbcmd, zlocalname);
          }
#line 335
          if (c <= 0) {
#line 336
            goto while_break;
          }
#line 337
          if ((int )*pbcmd != (int )b) {
            {
#line 339
            write(1, (void const   *)pbcmd, (size_t )1);
            }
#line 344
            if ((int )*pbcmd == (int )bSeof) {
#line 345
              *pbcmd = (char )'.';
            }
#line 346
            if ((int )*pbcmd == (int )bStstp) {
#line 347
              *pbcmd = (char )'z';
            }
#line 348
            return (1);
          }
        }
      }
    }
    {
#line 351
    tmp___0 = fconn_write(qconn, (char const   *)(& b), (size_t )1);
    }
#line 351
    if (! tmp___0) {
#line 352
      return (0);
    }
    {
#line 353
    tmp___1 = strchr(zCuvar_eol, (int )b);
#line 353
    fstart = (unsigned long )tmp___1 != (unsigned long )((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  if (c < 0) {
    {
#line 358
    tmp___4 = __errno_location();
    }
#line 358
    if (*tmp___4 != 4) {
      {
#line 359
      tmp___2 = __errno_location();
#line 359
      tmp___3 = strerror(*tmp___2);
#line 359
      ulog((enum tlog )1, "read: %s", tmp___3);
      }
    } else {
      {
#line 361
      ulog((enum tlog )1, (char const   *)((void *)0));
      }
    }
#line 362
    return (0);
  }
  {
#line 366
  ulog((enum tlog )1, "End of file on terminal");
  }
#line 367
  return (0);
}
}
#line 372 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
sig_atomic_t volatile   fScu_alarm  ;
#line 374 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static void uscu_alarm(int isig  __attribute__((__unused__)) ) 
{ 


  {
#line 382
  fScu_alarm = (sig_atomic_t volatile   )1;
#line 388
  return;
}
}
#line 395 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static int cscu_escape(char *pbcmd , char const   *zlocalname ) 
{ 
  int c ;
  char b ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 402
  write(1, (void const   *)zCuvar_escape, (size_t )1);
#line 404
  fScu_alarm = (sig_atomic_t volatile   )0;
#line 405
  usset_signal(14, & uscu_alarm, 1, (boolean *)((void *)0));
#line 410
  alarm(1U);
#line 413
  c = 0;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (fScu_alarm) {
      {
#line 421
      fScu_alarm = (sig_atomic_t volatile   )0;
#line 422
      b = (char )'[';
#line 423
      write(1, (void const   *)(& b), (size_t )1);
#line 424
      tmp = strlen(zlocalname);
#line 424
      write(1, (void const   *)zlocalname, tmp);
#line 425
      b = (char )']';
#line 426
      write(1, (void const   *)(& b), (size_t )1);
      }
    }
#line 429
    if (c <= 0) {
      {
#line 430
      tmp___0 = read(0, (void *)pbcmd, (size_t )1);
#line 430
      c = (int )tmp___0;
      }
    }
#line 431
    if (c >= 0) {
      {
#line 434
      usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 435
      alarm(0U);
      }
#line 436
      return (c);
    } else {
      {
#line 431
      tmp___1 = __errno_location();
      }
#line 431
      if (*tmp___1 != 4) {
        {
#line 434
        usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 435
        alarm(0U);
        }
#line 436
        return (c);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 446 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static sig_atomic_t volatile   iSsend_sig  ;
#line 448 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static void uscu_alarm_kill(int isig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 456
  kill((__pid_t )iSchild, (int )iSsend_sig);
#line 458
  alarm(1U);
  }
#line 459
  return;
}
}
#line 467 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_cu_copy(boolean fcopy ) 
{ 
  int ierr ;
  int c ;
  char b ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 474
  usset_signal(14, & uscu_alarm_kill, 1, (boolean *)((void *)0));
  }
#line 475
  if (fcopy) {
#line 476
    iSsend_sig = (sig_atomic_t volatile   )10;
  } else {
#line 478
    iSsend_sig = (sig_atomic_t volatile   )12;
  }
  {
#line 480
  uscu_alarm_kill(14);
#line 482
  alarm(1U);
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 488
    tmp = read(oSpipe, (void *)(& b), (size_t )1);
#line 488
    c = (int )tmp;
    }
#line 491
    if (c > 0) {
      {
#line 492
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 492
        if ((iDebug & 512) != 0) {
          {
#line 492
          ulog((enum tlog )3, "fsysdep_cu_copy: Got \'%d\'", (int )b);
          }
        }
#line 492
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 496
    if (c < 0) {
      {
#line 496
      tmp___0 = __errno_location();
      }
#line 496
      if (*tmp___0 != 4) {
#line 499
        goto while_break;
      } else {
#line 496
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 496
    if (c == 0) {
#line 499
      goto while_break;
    } else
#line 496
    if (c > 0) {
#line 496
      if (fcopy) {
#line 496
        tmp___1 = 'G';
      } else {
#line 496
        tmp___1 = 'S';
      }
#line 496
      if ((int )b == tmp___1) {
#line 499
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 508
  tmp___2 = __errno_location();
#line 508
  ierr = *tmp___2;
#line 510
  usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 511
  alarm(0U);
  }
#line 513
  if (c > 0) {
#line 514
    return (1);
  }
#line 516
  if (c == 0) {
    {
#line 517
    ulog((enum tlog )1, "EOF on child pipe");
    }
  } else {
    {
#line 519
    tmp___3 = strerror(ierr);
#line 519
    ulog((enum tlog )1, "read: %s", tmp___3);
    }
  }
#line 521
  return (0);
}
}
#line 526 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_cu_finish(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 529
  close(oSpipe);
#line 533
  tmp___2 = kill((__pid_t )iSchild, 15);
  }
#line 533
  if (tmp___2 < 0) {
    {
#line 536
    tmp___1 = __errno_location();
    }
#line 536
    if (*tmp___1 != 3) {
      {
#line 537
      tmp = __errno_location();
#line 537
      tmp___0 = strerror(*tmp);
#line 537
      ulog((enum tlog )1, "kill: %s", tmp___0);
      }
    }
  }
  {
#line 540
  usset_signal(14, & uscu_alarm_kill, 1, (boolean *)((void *)0));
#line 541
  iSsend_sig = (sig_atomic_t volatile   )9;
#line 542
  alarm(2U);
#line 544
  ixswait((unsigned long )iSchild, "child");
#line 546
  usset_signal(14, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 547
  alarm(0U);
  }
#line 549
  return (1);
}
}
#line 557 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static sig_atomic_t volatile   iSchild_sig  ;
#line 559 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static void uscu_child_handler(int isig ) 
{ 


  {
#line 567
  iSchild_sig = (sig_atomic_t volatile   )isig;
#line 573
  return;
}
}
#line 582 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static void uscu_child(struct sconnection *qconn , int opipe ) 
{ 
  int oport ;
  boolean fstopped ;
  boolean fgot ;
  int cwrite ;
  char abbuf[1024] ;
  int tmp ;
  int isig ;
  int c ;
  char b ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __pid_t tmp___4 ;
  char *zbuf___0 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  __pid_t tmp___10 ;
  int *tmp___11 ;
  ssize_t tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  __pid_t tmp___16 ;
  int *tmp___17 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 592
  fgot = 0;
#line 597
  if ((unsigned long )qconn->qport == (unsigned long )((void *)0)) {
#line 598
    oport = 0;
  } else {
    {
#line 609
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 6U) {
#line 609
      goto case_6;
    }
#line 613
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 1U) {
#line 613
      goto case_1;
    }
#line 619
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 5U) {
#line 619
      goto case_5;
    }
#line 619
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 4U) {
#line 619
      goto case_5;
    }
#line 619
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 3U) {
#line 619
      goto case_5;
    }
#line 619
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 2U) {
#line 619
      goto case_5;
    }
#line 604
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 605
    ulog((enum tlog )2, "uscu_child: Can\'t happen");
#line 606
    oport = -1;
    }
#line 607
    goto switch_break;
    case_6: /* CIL Label */ 
#line 611
    fgot = 1;
    case_1: /* CIL Label */ 
#line 614
    oport = ((struct ssysdep_conn *)qconn->psysdep)->ord;
#line 615
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 620
    oport = ((struct ssysdep_conn *)qconn->psysdep)->o;
#line 621
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 626
  tmp = fcntl(oport, 3, 0);
#line 626
  fcntl(oport, 4, tmp & -2049);
#line 629
  usset_signal(10, & uscu_child_handler, 1, (boolean *)((void *)0));
#line 630
  usset_signal(12, & uscu_child_handler, 1, (boolean *)((void *)0));
#line 631
  usset_signal(2, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 632
  usset_signal(3, (void (*)(int  ))1, 1, (boolean *)((void *)0));
#line 633
  usset_signal(13, (void (*)(int  ))0, 1, (boolean *)((void *)0));
#line 634
  usset_signal(15, & uscu_child_handler, 1, (boolean *)((void *)0));
#line 636
  fstopped = 0;
#line 637
  iSchild_sig = (sig_atomic_t volatile   )0;
#line 638
  cwrite = 0;
  }
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    isig = (int )iSchild_sig;
#line 655
    iSchild_sig = (sig_atomic_t volatile   )0;
#line 656
    if (isig != 0) {
#line 660
      if (isig == 15) {
        {
#line 661
        exit(0);
        }
      }
#line 663
      if (isig == 10) {
#line 665
        fstopped = 0;
#line 666
        b = (char )'G';
      } else {
#line 670
        fstopped = 1;
#line 671
        b = (char )'S';
#line 672
        cwrite = 0;
      }
      {
#line 675
      tmp___0 = write(opipe, (void const   *)(& b), (size_t )1);
#line 675
      c = (int )tmp___0;
      }
#line 678
      if (c < 0) {
        {
#line 678
        tmp___1 = __errno_location();
        }
#line 678
        if (*tmp___1 == 11) {
#line 680
          c = 0;
        } else {
          {
#line 678
          tmp___2 = __errno_location();
          }
#line 678
          if (*tmp___2 == 11) {
#line 680
            c = 0;
          } else {
            {
#line 678
            tmp___3 = __errno_location();
            }
#line 678
            if (*tmp___3 == 61) {
#line 680
              c = 0;
            }
          }
        }
      }
#line 682
      if (c <= 0) {
        {
#line 685
        tmp___4 = getppid();
#line 685
        kill(tmp___4, 1);
#line 686
        exit(1);
        }
      }
    }
#line 690
    if (fstopped) {
      {
#line 691
      pause();
      }
    } else
#line 692
    if (cwrite > 0) {
#line 696
      zbuf___0 = abbuf;
      {
#line 697
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 697
        if (! (cwrite > 0)) {
#line 697
          goto while_break___0;
        }
        {
#line 699
        tmp___5 = write(1, (void const   *)zbuf___0, (size_t )cwrite);
#line 699
        c = (int )tmp___5;
        }
#line 702
        if (c < 0) {
          {
#line 702
          tmp___6 = __errno_location();
          }
#line 702
          if (*tmp___6 == 11) {
#line 706
            c = 0;
          } else {
            {
#line 702
            tmp___7 = __errno_location();
            }
#line 702
            if (*tmp___7 == 11) {
#line 706
              c = 0;
            } else {
              {
#line 702
              tmp___8 = __errno_location();
              }
#line 702
              if (*tmp___8 == 61) {
#line 706
                c = 0;
              }
            }
          }
        }
#line 708
        if (c < 0) {
          {
#line 708
          tmp___9 = __errno_location();
          }
#line 708
          if (*tmp___9 == 4) {
#line 709
            goto while_break___0;
          }
        }
#line 710
        if (c <= 0) {
          {
#line 713
          tmp___10 = getppid();
#line 713
          kill(tmp___10, 1);
#line 714
          exit(1);
          }
        }
#line 716
        cwrite -= c;
#line 717
        zbuf___0 += c;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 727
      tmp___11 = __errno_location();
#line 727
      *tmp___11 = 0;
#line 728
      tmp___12 = read(oport, (void *)(abbuf), sizeof(abbuf));
#line 728
      c = (int )tmp___12;
      }
#line 731
      if (c < 0) {
        {
#line 731
        tmp___13 = __errno_location();
        }
#line 731
        if (*tmp___13 == 11) {
#line 733
          c = 0;
        } else {
          {
#line 731
          tmp___14 = __errno_location();
          }
#line 731
          if (*tmp___14 == 11) {
#line 733
            c = 0;
          } else {
            {
#line 731
            tmp___15 = __errno_location();
            }
#line 731
            if (*tmp___15 == 61) {
#line 733
              c = 0;
            }
          }
        }
      }
#line 735
      if (c == 0) {
#line 735
        if (fgot) {
          {
#line 740
          tmp___16 = getppid();
#line 740
          kill(tmp___16, 1);
#line 741
          exit(0);
          }
        } else {
#line 735
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 735
      if (c < 0) {
        {
#line 735
        tmp___17 = __errno_location();
        }
#line 735
        if (*tmp___17 != 4) {
          {
#line 740
          tmp___16 = getppid();
#line 740
          kill(tmp___16, 1);
#line 741
          exit(0);
          }
        }
      }
#line 743
      if (c > 0) {
#line 745
        fgot = 1;
#line 746
        cwrite = c;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 755 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static boolean fSterm  ;
#line 758 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static boolean fSlocalecho  ;
#line 761 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static sterminal sSterm_orig  ;
#line 764 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static sterminal sSterm_new  ;
#line 769 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
static boolean fStstp_ignored  ;
#line 775 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_terminal_raw(boolean flocalecho ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 779
  fSlocalecho = flocalecho;
#line 782
  bSeof = (char )'\004';
#line 783
  bStstp = (char )'\032';
#line 785
  tmp = tcgetattr(0, & sSterm_orig);
  }
#line 785
  if (! (tmp == 0)) {
#line 787
    fSterm = 0;
#line 788
    return (1);
  }
#line 791
  fSterm = 1;
#line 793
  sSterm_new = sSterm_orig;
#line 848
  bSeof = (char )sSterm_new.c_cc[4];
#line 849
  bStstp = (char )sSterm_new.c_cc[10];
#line 850
  if (! flocalecho) {
#line 851
    sSterm_new.c_lflag &= 4294934404U;
  } else {
#line 854
    sSterm_new.c_lflag &= 4294934524U;
  }
  {
#line 855
  sSterm_new.c_iflag &= 4294961727U;
#line 856
  sSterm_new.c_oflag &= 4294967294U;
#line 857
  sSterm_new.c_cc[6] = (cc_t )1;
#line 858
  sSterm_new.c_cc[5] = (cc_t )0;
#line 862
  tmp___2 = tcsetattr(0, 0, (struct termios  const  *)(& sSterm_new));
  }
#line 862
  if (! (tmp___2 == 0)) {
    {
#line 864
    tmp___0 = __errno_location();
#line 864
    tmp___1 = strerror(*tmp___0);
#line 864
    ulog((enum tlog )1, "Can\'t set terminal settings: %s", tmp___1);
    }
#line 865
    return (0);
  }
#line 868
  return (1);
}
}
#line 873 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_terminal_restore(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;

  {
#line 876
  if (! fSterm) {
#line 877
    return (1);
  }
  {
#line 879
  tmp___1 = tcsetattr(0, 0, (struct termios  const  *)(& sSterm_orig));
  }
#line 879
  if (! (tmp___1 == 0)) {
    {
#line 881
    tmp = __errno_location();
#line 881
    tmp___0 = strerror(*tmp);
#line 881
    ulog((enum tlog )1, "Can\'t restore terminal: %s", tmp___0);
    }
#line 882
    return (0);
  }
#line 884
  return (1);
}
}
#line 890 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
char *zsysdep_terminal_line(char const   *zprompt ) 
{ 
  size_t cbuf___0 ;
  char *zbuf___0 ;
  size_t cgot ;
  size_t tmp ;
  boolean tmp___0 ;
  char b ;
  int c ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *znew ;
  char *znew___0 ;
  boolean tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 894
  cbuf___0 = (size_t )0;
#line 895
  zbuf___0 = (char *)((void *)0);
#line 896
  cgot = (size_t )0;
#line 898
  if ((unsigned long )zprompt != (unsigned long )((void *)0)) {
#line 898
    if ((int const   )*zprompt != 0) {
      {
#line 899
      tmp = strlen(zprompt);
#line 899
      write(1, (void const   *)zprompt, tmp);
      }
    }
  }
  {
#line 905
  afSignal[1] = (sig_atomic_t volatile   )0;
#line 906
  afSignal[2] = (sig_atomic_t volatile   )0;
#line 908
  tmp___0 = fsysdep_terminal_restore();
  }
#line 908
  if (! tmp___0) {
#line 909
    return ((char *)((void *)0));
  }
#line 914
  cbuf___0 = (size_t )0;
#line 915
  zbuf___0 = (char *)((void *)0);
#line 916
  cgot = (size_t )0;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (afSignal[1]) {
      {
#line 929
      ulog((enum tlog )1, (char const   *)((void *)0));
#line 931
      cgot = (size_t )0;
      }
#line 932
      goto while_break;
    } else
#line 924
    if (afSignal[2]) {
      {
#line 929
      ulog((enum tlog )1, (char const   *)((void *)0));
#line 931
      cgot = (size_t )0;
      }
#line 932
      goto while_break;
    }
    {
#line 939
    tmp___1 = read(0, (void *)(& b), (size_t )1);
#line 939
    c = (int )tmp___1;
    }
#line 940
    if (c < 0) {
      {
#line 942
      tmp___2 = __errno_location();
      }
#line 942
      if (*tmp___2 == 4) {
#line 943
        goto while_continue;
      }
      {
#line 945
      tmp___3 = __errno_location();
#line 945
      tmp___4 = strerror(*tmp___3);
#line 945
      ulog((enum tlog )1, "read: %s", tmp___4);
#line 946
      fsysdep_terminal_raw(fSlocalecho);
      }
#line 947
      return ((char *)((void *)0));
    }
#line 949
    if (c == 0) {
      {
#line 953
      ulog((enum tlog )1, "EOF on terminal");
#line 954
      fsysdep_terminal_raw(fSlocalecho);
      }
#line 955
      return ((char *)((void *)0));
    }
#line 958
    if (cgot >= cbuf___0) {
      {
#line 962
      cbuf___0 += 64UL;
#line 963
      znew = zbufalc(cbuf___0);
      }
#line 964
      if ((unsigned long )zbuf___0 != (unsigned long )((void *)0)) {
        {
#line 966
        memcpy((void */* __restrict  */)znew, (void const   */* __restrict  */)zbuf___0,
               cgot);
#line 967
        ubuffree(zbuf___0);
        }
      }
#line 969
      zbuf___0 = znew;
    }
#line 972
    *(zbuf___0 + cgot) = b;
#line 974
    cgot ++;
#line 976
    if ((int )b == 10) {
#line 979
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  if (cgot >= cbuf___0) {
    {
#line 987
    cbuf___0 ++;
#line 988
    znew___0 = zbufalc(cbuf___0);
    }
#line 989
    if ((unsigned long )zbuf___0 != (unsigned long )((void *)0)) {
      {
#line 991
      memcpy((void */* __restrict  */)znew___0, (void const   */* __restrict  */)zbuf___0,
             cgot);
#line 992
      ubuffree(zbuf___0);
      }
    }
#line 994
    zbuf___0 = znew___0;
  }
  {
#line 997
  *(zbuf___0 + cgot) = (char )'\000';
#line 999
  tmp___5 = fsysdep_terminal_raw(fSlocalecho);
  }
#line 999
  if (! tmp___5) {
#line 1000
    return ((char *)((void *)0));
  }
#line 1002
  return (zbuf___0);
}
}
#line 1007 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_terminal_puts(char const   *zline ) 
{ 
  char *zalc ;
  char *zprint ;
  size_t clen ;
  int c ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 1014
  if ((unsigned long )zline == (unsigned long )((void *)0)) {
    {
#line 1016
    zalc = zbufalc((size_t )2);
#line 1017
    clen = (size_t )0;
    }
  } else {
    {
#line 1021
    clen = strlen(zline);
#line 1022
    zalc = zbufalc(clen + 2UL);
#line 1023
    memcpy((void */* __restrict  */)zalc, (void const   */* __restrict  */)zline,
           clen);
    }
  }
#line 1026
  if (fSterm) {
#line 1028
    *(zalc + clen) = (char )'\r';
#line 1029
    clen ++;
  }
#line 1031
  *(zalc + clen) = (char )'\n';
#line 1032
  clen ++;
#line 1034
  zprint = zalc;
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1035
    if (! (clen > 0UL)) {
#line 1035
      goto while_break;
    }
    {
#line 1039
    tmp = write(1, (void const   *)zprint, clen);
#line 1039
    c = (int )tmp;
    }
#line 1040
    if (c <= 0) {
      {
#line 1042
      ubuffree(zalc);
#line 1043
      tmp___0 = __errno_location();
#line 1043
      tmp___1 = strerror(*tmp___0);
#line 1043
      ulog((enum tlog )1, "write: %s", tmp___1);
      }
#line 1044
      return (0);
    }
#line 1046
    clen -= (size_t )c;
#line 1047
    zprint += c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1050
  ubuffree(zalc);
  }
#line 1052
  return (1);
}
}
#line 1057 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_terminal_signals(boolean faccept ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
#line 1076
  if (faccept) {
#line 1077
    sSterm_new.c_lflag |= 1U;
  } else {
#line 1079
    sSterm_new.c_lflag &= 4294967294U;
  }
#line 1086
  if (faccept) {
    {
#line 1087
    usset_signal(20, (void (*)(int  ))1, 0, & fStstp_ignored);
    }
  } else
#line 1088
  if (! fStstp_ignored) {
    {
#line 1089
    usset_signal(20, (void (*)(int  ))0, 1, (boolean *)((void *)0));
    }
  }
  {
#line 1094
  tmp___1 = tcsetattr(0, 0, (struct termios  const  *)(& sSterm_new));
  }
#line 1094
  if (! (tmp___1 == 0)) {
    {
#line 1096
    tmp = __errno_location();
#line 1096
    tmp___0 = strerror(*tmp);
#line 1096
    ulog((enum tlog )1, "Can\'t set terminal: %s", tmp___0);
    }
#line 1097
    return (0);
  }
#line 1100
  return (1);
}
}
#line 1107 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_shell(struct sconnection *qconn , char const   *zcmd , enum tshell_cmd tcmd ) 
{ 
  char const   *azargs[4] ;
  int oread ;
  int owrite ;
  int aidescs[3] ;
  pid_t ipid ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1118
  if ((unsigned int )tcmd != 0U) {
#line 1119
    azargs[0] = "/bin/sh";
  } else {
    {
#line 1122
    tmp = getenv("SHELL");
#line 1122
    azargs[0] = (char const   *)tmp;
    }
#line 1123
    if ((unsigned long )azargs[0] == (unsigned long )((void *)0)) {
#line 1124
      azargs[0] = "/bin/sh";
    }
  }
#line 1126
  if ((unsigned long )zcmd == (unsigned long )((void *)0)) {
#line 1127
    azargs[1] = (char const   *)((void *)0);
  } else
#line 1126
  if ((int const   )*zcmd == 0) {
#line 1127
    azargs[1] = (char const   *)((void *)0);
  } else {
#line 1130
    azargs[1] = "-c";
#line 1131
    azargs[2] = zcmd;
#line 1132
    azargs[3] = (char const   *)((void *)0);
  }
#line 1135
  if ((unsigned long )qconn->qport == (unsigned long )((void *)0)) {
#line 1137
    oread = 0;
#line 1138
    owrite = 1;
  } else {
    {
#line 1148
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 6U) {
#line 1148
      goto case_6;
    }
#line 1148
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 1U) {
#line 1148
      goto case_6;
    }
#line 1155
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 5U) {
#line 1155
      goto case_5;
    }
#line 1155
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 4U) {
#line 1155
      goto case_5;
    }
#line 1155
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 3U) {
#line 1155
      goto case_5;
    }
#line 1155
    if ((unsigned int )(qconn->qport)->uuconf_ttype == 2U) {
#line 1155
      goto case_5;
    }
#line 1144
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1145
    owrite = -1;
#line 1145
    oread = owrite;
#line 1146
    goto switch_break;
    case_6: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1149
    oread = ((struct ssysdep_conn *)qconn->psysdep)->ord;
#line 1150
    owrite = ((struct ssysdep_conn *)qconn->psysdep)->owr;
#line 1151
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1156
    owrite = ((struct ssysdep_conn *)qconn->psysdep)->o;
#line 1156
    oread = owrite;
#line 1157
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1161
  aidescs[0] = 0;
#line 1162
  aidescs[1] = 1;
#line 1163
  aidescs[2] = 2;
#line 1165
  if ((unsigned int )tcmd == 2U) {
#line 1166
    aidescs[0] = oread;
  } else
#line 1165
  if ((unsigned int )tcmd == 3U) {
#line 1166
    aidescs[0] = oread;
  }
#line 1167
  if ((unsigned int )tcmd == 1U) {
#line 1168
    aidescs[1] = owrite;
  } else
#line 1167
  if ((unsigned int )tcmd == 3U) {
#line 1168
    aidescs[1] = owrite;
  }
  {
#line 1170
  ipid = ixsspawn(azargs, aidescs, 0, 1, (char const   *)((void *)0), 0, 0, (char const   *)((void *)0),
                  (char const   *)((void *)0), (char const   *)((void *)0));
  }
#line 1173
  if (ipid < 0) {
    {
#line 1175
    tmp___0 = __errno_location();
#line 1175
    tmp___1 = strerror(*tmp___0);
#line 1175
    ulog((enum tlog )1, "ixsspawn (/bin/sh): %s", tmp___1);
    }
#line 1176
    return (0);
  }
  {
#line 1179
  tmp___2 = ixswait((unsigned long )ipid, "shell");
  }
#line 1179
  return (tmp___2 == 0);
}
}
#line 1184 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_chdir(char const   *zdir ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1188
  if ((unsigned long )zdir == (unsigned long )((void *)0)) {
#line 1188
    goto _L;
  } else
#line 1188
  if ((int const   )*zdir == 0) {
    _L: /* CIL Label */ 
    {
#line 1190
    tmp = getenv("HOME");
#line 1190
    zdir = (char const   *)tmp;
    }
#line 1191
    if ((unsigned long )zdir == (unsigned long )((void *)0)) {
      {
#line 1193
      ulog((enum tlog )1, "HOME not defined");
      }
#line 1194
      return (0);
    }
  }
  {
#line 1197
  tmp___2 = chdir(zdir);
  }
#line 1197
  if (tmp___2 < 0) {
    {
#line 1199
    tmp___0 = __errno_location();
#line 1199
    tmp___1 = strerror(*tmp___0);
#line 1199
    ulog((enum tlog )1, "chdir (%s): %s", zdir, tmp___1);
    }
#line 1200
    return (0);
  }
#line 1202
  return (1);
}
}
#line 1207 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/cusub.c"
boolean fsysdep_suspend(void) 
{ 
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 1213
  tmp = getpid();
#line 1213
  tmp___0 = kill(tmp, 20);
  }
#line 1213
  return (tmp___0 == 0);
}
}
#line 346 "../system.h"
char *zsysdep_save_corrupt_file(char const   *zfile ) ;
#line 10 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/corrup.c"
char *zsysdep_save_corrupt_file(char const   *zfile ) 
{ 
  char const   *zslash ;
  char *zto ;
  char *tmp ;
  boolean tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 17
  tmp = strrchr(zfile, '/');
#line 17
  zslash = (char const   *)tmp;
  }
#line 18
  if ((unsigned long )zslash == (unsigned long )((void *)0)) {
#line 19
    zslash = zfile;
  } else {
#line 21
    zslash ++;
  }
  {
#line 23
  zto = zsappend3(zSspooldir, ".Corrupt", zslash);
#line 25
  tmp___0 = fsysdep_move_file(zfile, (char const   *)zto, 1, 0, 0, (char const   *)((void *)0));
  }
#line 25
  if (! tmp___0) {
    {
#line 28
    ubuffree(zto);
    }
#line 29
    return ((char *)((void *)0));
  }
#line 32
  return (zto);
}
}
#line 465 "../system.h"
boolean fsysdep_change_mode(char const   *zfile , unsigned int imode ) ;
#line 14 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/chmod.c"
boolean fsysdep_change_mode(char const   *zfile , unsigned int imode ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 19
  tmp___1 = chmod((char const   *)((char *)zfile), imode);
  }
#line 19
  if (tmp___1 < 0) {
    {
#line 21
    tmp = __errno_location();
#line 21
    tmp___0 = strerror(*tmp);
#line 21
    ulog((enum tlog )1, "chmod (%s): %s", zfile, tmp___0);
    }
#line 22
    return (0);
  }
#line 24
  return (1);
}
}
#line 840 "../system.h"
long csysdep_bytes_free(char const   *zfile ) ;
#line 16 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/bytfre.c"
long csysdep_bytes_free(char const   *zfile ) 
{ 
  struct fs_usage s ;
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 22
  tmp = get_fs_usage((char *)zfile, (char *)((void *)0), & s);
  }
#line 22
  if (tmp < 0) {
#line 23
    return (-1L);
  }
#line 24
  if (s.fsu_bavail >= 18014398509481983L) {
#line 25
    return (9223372036854775807L);
  }
#line 26
  return (s.fsu_bavail * 512L);
}
}
#line 736 "../system.h"
char *zsysdep_base_name(char const   *zfile ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/basnam.c"
char *zsysdep_base_name(char const   *zfile ) 
{ 
  char const   *z ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 18
  tmp = strrchr(zfile, '/');
#line 18
  z = (char const   *)tmp;
  }
#line 19
  if ((unsigned long )z != (unsigned long )((void *)0)) {
    {
#line 20
    tmp___0 = zbufcpy(z + 1);
    }
#line 20
    return (tmp___0);
  }
  {
#line 21
  tmp___1 = zbufcpy(zfile);
  }
#line 21
  return (tmp___1);
}
}
#line 489 "../sysdep.h"
char *zsappend4(char const   *zdir1 , char const   *zdir2 , char const   *zdir3 ,
                char const   *zfile ) ;
#line 9 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/app4.c"
char *zsappend4(char const   *zdir1 , char const   *zdir2 , char const   *zdir3 ,
                char const   *zfile ) 
{ 
  size_t cdir1 ;
  size_t cdir2 ;
  size_t cdir3 ;
  size_t cfile ;
  char *zret ;

  {
  {
#line 19
  cdir1 = strlen(zdir1);
#line 20
  cdir2 = strlen(zdir2);
#line 21
  cdir3 = strlen(zdir3);
#line 22
  cfile = strlen(zfile);
#line 23
  zret = zbufalc((((cdir1 + cdir2) + cdir3) + cfile) + 4UL);
  }
#line 24
  if (cdir1 == 1UL) {
#line 24
    if ((int const   )*zdir1 == 47) {
#line 25
      cdir1 = (size_t )0;
    } else {
      {
#line 27
      memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)zdir1,
             cdir1);
      }
    }
  } else {
    {
#line 27
    memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)zdir1,
           cdir1);
    }
  }
  {
#line 28
  memcpy((void */* __restrict  */)((zret + cdir1) + 1), (void const   */* __restrict  */)zdir2,
         cdir2);
#line 29
  memcpy((void */* __restrict  */)(((zret + cdir1) + cdir2) + 2), (void const   */* __restrict  */)zdir3,
         cdir3);
#line 30
  memcpy((void */* __restrict  */)((((zret + cdir1) + cdir2) + cdir3) + 3), (void const   */* __restrict  */)zfile,
         cfile);
#line 31
  *(zret + cdir1) = (char )'/';
#line 32
  *(zret + ((cdir1 + cdir2) + 1UL)) = (char )'/';
#line 33
  *(zret + (((cdir1 + cdir2) + cdir3) + 2UL)) = (char )'/';
#line 34
  *(zret + ((((cdir1 + cdir2) + cdir3) + cfile) + 3UL)) = (char )'\000';
  }
#line 35
  return (zret);
}
}
#line 9 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/app3.c"
char *zsappend3(char const   *zdir1 , char const   *zdir2 , char const   *zfile ) 
{ 
  size_t cdir1 ;
  size_t cdir2 ;
  size_t cfile ;
  char *zret ;

  {
  {
#line 18
  cdir1 = strlen(zdir1);
#line 19
  cdir2 = strlen(zdir2);
#line 20
  cfile = strlen(zfile);
#line 21
  zret = zbufalc(((cdir1 + cdir2) + cfile) + 3UL);
  }
#line 22
  if (cdir1 == 1UL) {
#line 22
    if ((int const   )*zdir1 == 47) {
#line 23
      cdir1 = (size_t )0;
    } else {
      {
#line 25
      memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)zdir1,
             cdir1);
      }
    }
  } else {
    {
#line 25
    memcpy((void */* __restrict  */)zret, (void const   */* __restrict  */)zdir1,
           cdir1);
    }
  }
  {
#line 26
  memcpy((void */* __restrict  */)((zret + cdir1) + 1), (void const   */* __restrict  */)zdir2,
         cdir2);
#line 27
  memcpy((void */* __restrict  */)(((zret + cdir1) + cdir2) + 2), (void const   */* __restrict  */)zfile,
         cfile);
#line 28
  *(zret + cdir1) = (char )'/';
#line 29
  *(zret + ((cdir1 + cdir2) + 1UL)) = (char )'/';
#line 30
  *(zret + (((cdir1 + cdir2) + cfile) + 2UL)) = (char )'\000';
  }
#line 31
  return (zret);
}
}
#line 363 "../system.h"
char *zsysdep_add_base(char const   *zfile , char const   *zname ) ;
#line 12 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/addbas.c"
char *zsysdep_add_base(char const   *zfile , char const   *zname ) 
{ 
  size_t clen ;
  char const   *zlook ;
  char *zfree ;
  char *zret ;
  char *tmp ;
  boolean tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;

  {
#line 23
  if ((int const   )*zfile != 47) {
    {
#line 24
    ulog((enum tlog )2, "zsysdep_add_base: %s: Can\'t happen", zfile);
    }
  }
  {
#line 27
  clen = strlen(zfile);
  }
#line 29
  if ((int const   )*(zfile + (clen - 1UL)) != 47) {
    {
#line 31
    tmp___0 = fsysdep_directory(zfile);
    }
#line 31
    if (! tmp___0) {
      {
#line 32
      tmp = zbufcpy(zfile);
      }
#line 32
      return (tmp);
    }
#line 33
    zfree = (char *)((void *)0);
  } else {
    {
#line 38
    zfree = zbufcpy(zfile);
#line 39
    *(zfree + (clen - 1UL)) = (char )'\000';
#line 40
    zfile = (char const   *)zfree;
    }
  }
  {
#line 43
  tmp___1 = strrchr(zname, '/');
#line 43
  zlook = (char const   *)tmp___1;
  }
#line 44
  if ((unsigned long )zlook != (unsigned long )((void *)0)) {
#line 45
    zname = zlook + 1;
  }
  {
#line 47
  zret = zsysdep_in_dir(zfile, zname);
#line 48
  ubuffree(zfree);
  }
#line 49
  return (zret);
}
}
#line 754 "../system.h"
boolean fsysdep_access(char const   *zfile ) ;
#line 762
boolean fsysdep_daemon_access(char const   *zfile ) ;
#line 15 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/access.c"
boolean fsysdep_access(char const   *zfile ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 19
  tmp = access(zfile, 4);
  }
#line 19
  if (tmp == 0) {
#line 20
    return (1);
  }
  {
#line 21
  tmp___0 = __errno_location();
#line 21
  tmp___1 = strerror(*tmp___0);
#line 21
  ulog((enum tlog )1, "%s: %s", zfile, tmp___1);
  }
#line 22
  return (0);
}
}
#line 35 "/home/wslee/gnu_benchmarks/uucp-1.07/unix/access.c"
boolean fsysdep_daemon_access(char const   *zfile ) 
{ 
  struct stat s ;
  uid_t ieuid ;
  uid_t iuid ;
  uid_t iegid ;
  uid_t igid ;
  boolean fok ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 43
  ieuid = geteuid();
  }
#line 44
  if (ieuid == 0U) {
#line 45
    return (1);
  }
  {
#line 46
  iuid = getuid();
#line 47
  iegid = getegid();
#line 48
  igid = getgid();
  }
#line 52
  if (ieuid == iuid) {
#line 52
    if (iegid == igid) {
#line 53
      return (1);
    }
  }
  {
#line 55
  tmp___2 = stat((char const   */* __restrict  */)((char *)zfile), (struct stat */* __restrict  */)(& s));
  }
#line 55
  if (tmp___2 != 0) {
    {
#line 59
    tmp___1 = __errno_location();
    }
#line 59
    if (*tmp___1 == 13) {
      {
#line 60
      ulog((enum tlog )1, "%s: cannot be read by daemon", zfile);
      }
    } else {
      {
#line 62
      tmp = __errno_location();
#line 62
      tmp___0 = strerror(*tmp);
#line 62
      ulog((enum tlog )1, "stat (%s): %s", zfile, tmp___0);
      }
    }
#line 63
    return (0);
  }
#line 74
  if (ieuid != iuid) {
#line 74
    if (ieuid == s.st_uid) {
#line 75
      fok = (s.st_mode & 256U) != 0U;
    } else {
#line 74
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 76
  if (iegid != igid) {
#line 76
    if (iegid == s.st_gid) {
#line 77
      fok = (s.st_mode & (unsigned int )(256 >> 3)) != 0U;
    } else {
#line 79
      fok = (s.st_mode & (unsigned int )((256 >> 3) >> 3)) != 0U;
    }
  } else {
#line 79
    fok = (s.st_mode & (unsigned int )((256 >> 3) >> 3)) != 0U;
  }
#line 81
  if (! fok) {
    {
#line 83
    ulog((enum tlog )1, "%s: cannot be read by daemon", zfile);
    }
#line 84
    return (0);
  }
#line 87
  return (1);
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/copy.c"
char const   copy_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/copy.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'2',      (char const   )'2',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'1',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 369 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
boolean fcopy_open_file(FILE *efrom , char const   *zto , boolean fpublic , boolean fmkdirs ,
                        boolean fsignals ) ;
#line 42 "/home/wslee/gnu_benchmarks/uucp-1.07/copy.c"
boolean fcopy_file(char const   *zfrom , char const   *zto , boolean fpublic , boolean fmkdirs ,
                   boolean fsignals ) 
{ 
  FILE *efrom ;
  boolean fret ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 53
  efrom = fopen((char const   */* __restrict  */)zfrom, (char const   */* __restrict  */)"r");
  }
#line 54
  if ((unsigned long )efrom == (unsigned long )((void *)0)) {
    {
#line 56
    tmp = __errno_location();
#line 56
    tmp___0 = strerror(*tmp);
#line 56
    ulog((enum tlog )1, "fopen (%s): %s", zfrom, tmp___0);
    }
#line 57
    return (0);
  }
  {
#line 60
  fret = fcopy_open_file(efrom, zto, fpublic, fmkdirs, fsignals);
#line 61
  fclose(efrom);
  }
#line 62
  return (fret);
}
}
#line 65 "/home/wslee/gnu_benchmarks/uucp-1.07/copy.c"
boolean fcopy_open_file(FILE *efrom , char const   *zto , boolean fpublic , boolean fmkdirs ,
                        boolean fsignals ) 
{ 
  FILE *eto ;
  char ab___0[8192] ;
  size_t c ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  boolean tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 77
  eto = esysdep_fopen(zto, fpublic, 0, fmkdirs);
  }
#line 78
  if ((unsigned long )eto == (unsigned long )((void *)0)) {
#line 79
    return (0);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    c = fread((void */* __restrict  */)(ab___0), sizeof(char ), sizeof(ab___0), (FILE */* __restrict  */)efrom);
    }
#line 81
    if (! (c != 0UL)) {
#line 81
      goto while_break;
    }
    {
#line 83
    tmp___1 = fwrite((void const   */* __restrict  */)(ab___0), sizeof(char ), c,
                     (FILE */* __restrict  */)eto);
    }
#line 83
    if (tmp___1 != c) {
      {
#line 85
      tmp = __errno_location();
#line 85
      tmp___0 = strerror(*tmp);
#line 85
      ulog((enum tlog )1, "fwrite: %s", tmp___0);
#line 86
      fclose(eto);
#line 87
      remove(zto);
      }
#line 88
      return (0);
    }
#line 90
    if (fsignals) {
#line 90
      if (afSignal[0]) {
        {
#line 93
        ulog((enum tlog )1, (char const   *)((void *)0));
#line 94
        fclose(eto);
#line 95
        remove(zto);
        }
#line 96
        return (0);
      } else
#line 90
      if (afSignal[1]) {
        {
#line 93
        ulog((enum tlog )1, (char const   *)((void *)0));
#line 94
        fclose(eto);
#line 95
        remove(zto);
        }
#line 96
        return (0);
      } else
#line 90
      if (afSignal[2]) {
        {
#line 93
        ulog((enum tlog )1, (char const   *)((void *)0));
#line 94
        fclose(eto);
#line 95
        remove(zto);
        }
#line 96
        return (0);
      } else
#line 90
      if (afSignal[3]) {
        {
#line 93
        ulog((enum tlog )1, (char const   *)((void *)0));
#line 94
        fclose(eto);
#line 95
        remove(zto);
        }
#line 96
        return (0);
      } else
#line 90
      if (afSignal[4]) {
        {
#line 93
        ulog((enum tlog )1, (char const   *)((void *)0));
#line 94
        fclose(eto);
#line 95
        remove(zto);
        }
#line 96
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  tmp___2 = fsysdep_sync(eto, zto);
  }
#line 100
  if (! tmp___2) {
    {
#line 102
    fclose(eto);
#line 103
    remove(zto);
    }
#line 104
    return (0);
  }
  {
#line 107
  tmp___5 = fclose(eto);
  }
#line 107
  if (tmp___5 != 0) {
    {
#line 109
    tmp___3 = __errno_location();
#line 109
    tmp___4 = strerror(*tmp___3);
#line 109
    ulog((enum tlog )1, "fclose: %s", tmp___4);
#line 110
    remove(zto);
    }
#line 111
    return (0);
  }
  {
#line 114
  tmp___8 = ferror(efrom);
  }
#line 114
  if (tmp___8) {
    {
#line 116
    tmp___6 = __errno_location();
#line 116
    tmp___7 = strerror(*tmp___6);
#line 116
    ulog((enum tlog )1, "fread: %s", tmp___7);
#line 117
    remove(zto);
    }
#line 118
    return (0);
  }
#line 121
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
char const   log_rcsid[48]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'g', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'6', 
        (char const   )'5',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'/',      (char const   )'0', 
        (char const   )'3',      (char const   )'/',      (char const   )'0',      (char const   )'5', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )':', 
        (char const   )'1',      (char const   )'0',      (char const   )':',      (char const   )'4', 
        (char const   )'1',      (char const   )' ',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'R',      (char const   )'e', 
        (char const   )'l',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 314 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
void ulog_fatal_fn(void (*pfn)(void) ) ;
#line 318
void ulog_to_file(pointer puuconf , boolean ffile ) ;
#line 324
void ulog_system(char const   *zsystem ) ;
#line 327
void ulog_user(char const   *zuser ) ;
#line 336
void ustats(boolean fsucceeded , char const   *zuser , char const   *zsystem , boolean fsent ,
            long cbytes , long csecs , long cmicros , boolean fcaller  __attribute__((__unused__)) ) ;
#line 342
void ustats_close(void) ;
#line 400 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
char const   *zProgram  ;
#line 422 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
sig_atomic_t volatile   afSignal[5]  ;
#line 423 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
sig_atomic_t volatile   afLog_signal[5]  ;
#line 424
boolean fLog_sighup ;
#line 451 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
char *zLdevice  ;
#line 455 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
void (*pfLstart)(void)  ;
#line 459 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
void (*pfLend)(void)  ;
#line 50 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
__inline static char *zstpcpy(char *zto , char const   *zfrom ) ;
#line 51
static char const   *zldate_and_time(void) ;
#line 57 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char const   *zLogfile  ;
#line 60 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static void (*pfLfatal)(void)  ;
#line 63 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static boolean fLfile  ;
#line 66 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static int iLid  ;
#line 69 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char *zLuser  ;
#line 72 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char *zLsystem  ;
#line 78 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static FILE *eLlog  ;
#line 84 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static boolean fLlog_tried  ;
#line 88 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char const   *zLdebugfile  ;
#line 91 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static FILE *eLdebug  ;
#line 94 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static boolean fLdebug_tried  ;
#line 98 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char const   *zLstatsfile  ;
#line 101 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static FILE *eLstats  ;
#line 104 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static boolean fLstats_tried  ;
#line 119 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
boolean fLog_sighup  =    1;
#line 122 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char const   * const  azSignal_names[5]  = {      (char const   */* const  */)"hangup",      (char const   */* const  */)"interrupt",      (char const   */* const  */)"quit",      (char const   */* const  */)"termination", 
        (char const   */* const  */)"SIGPIPE"};
#line 134 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_fatal_fn(void (*pfn)(void) ) 
{ 


  {
#line 138
  pfLfatal = pfn;
#line 139
  return;
}
}
#line 143 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_to_file(pointer puuconf , boolean ffile ) 
{ 
  int iuuconf ;

  {
  {
#line 150
  iuuconf = uuconf_logfile(puuconf, & zLogfile);
  }
#line 151
  if (iuuconf != 0) {
    {
#line 152
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 155
  iuuconf = uuconf_debugfile(puuconf, & zLdebugfile);
  }
#line 156
  if (iuuconf != 0) {
    {
#line 157
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 160
  iuuconf = uuconf_statsfile(puuconf, & zLstatsfile);
  }
#line 161
  if (iuuconf != 0) {
    {
#line 162
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
#line 164
  fLfile = ffile;
#line 165
  return;
}
}
#line 170 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_id(int i ) 
{ 


  {
#line 174
  iLid = i;
#line 175
  return;
}
}
#line 180 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_user(char const   *zuser ) 
{ 


  {
  {
#line 184
  ubuffree(zLuser);
#line 185
  zLuser = zbufcpy(zuser);
  }
#line 186
  return;
}
}
#line 191 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_system(char const   *zsystem ) 
{ 
  int tmp ;

  {
#line 195
  if ((unsigned long )zsystem == (unsigned long )((void *)0)) {
    {
#line 199
    ubuffree(zLsystem);
#line 200
    zLsystem = zbufcpy(zsystem);
    }
  } else
#line 195
  if ((unsigned long )zLsystem == (unsigned long )((void *)0)) {
    {
#line 199
    ubuffree(zLsystem);
#line 200
    zLsystem = zbufcpy(zsystem);
    }
  } else {
    {
#line 195
    tmp = strcmp(zsystem, (char const   *)zLsystem);
    }
#line 195
    if (tmp != 0) {
      {
#line 199
      ubuffree(zLsystem);
#line 200
      zLsystem = zbufcpy(zsystem);
      }
    }
  }
#line 206
  return;
}
}
#line 210 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_device(char const   *zdevice ) 
{ 


  {
  {
#line 214
  ubuffree(zLdevice);
#line 215
  zLdevice = zbufcpy(zdevice);
  }
#line 216
  return;
}
}
#line 220 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
__inline static char *zstpcpy(char *zto , char const   *zfrom ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    tmp = zto;
#line 225
    zto ++;
#line 225
    tmp___1 = zfrom;
#line 225
    zfrom ++;
#line 225
    tmp___0 = (char )*tmp___1;
#line 225
    *tmp = tmp___0;
#line 225
    if (! ((int )tmp___0 != 0)) {
#line 225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (zto - 1);
}
}
#line 264 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static boolean fdoing_sigs  ;
#line 240 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ( /* format attribute */  ulog)(enum tlog ttype , char const   *zmsg  , ...) 
{ 
  va_list parg ;
  FILE *e ;
  FILE *edebug ;
  boolean fstart ;
  boolean fend ;
  char const   *zhdr ;
  char *zprefix ;
  register char *zset ;
  char *zformat ;
  char *zfrom ;
  int isig ;
  char const   *zprint ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *zbase ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 266
  if (! fdoing_sigs) {
#line 270
    fdoing_sigs = 1;
#line 271
    isig = 0;
    {
#line 271
    while (1) {
      while_continue: /* CIL Label */ ;
#line 271
      if (! (isig < 5)) {
#line 271
        goto while_break;
      }
#line 273
      if (afLog_signal[isig]) {
#line 275
        afLog_signal[isig] = (sig_atomic_t volatile   )0;
#line 280
        if (isig != 0) {
#line 280
          if (isig != 1) {
            {
#line 282
            ulog((enum tlog )1, "Got %s signal", azSignal_names[isig]);
            }
          } else {
#line 280
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 280
        if (fLog_sighup) {
          {
#line 282
          ulog((enum tlog )1, "Got %s signal", azSignal_names[isig]);
          }
        }
      }
#line 271
      isig ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 285
    fdoing_sigs = 0;
  }
#line 293
  if (fLfile) {
#line 293
    if ((unsigned long )eLdebug == (unsigned long )((void *)0)) {
#line 293
      if (! fLdebug_tried) {
#line 293
        if (iDebug != 0) {
          {
#line 298
          fLdebug_tried = 1;
#line 299
          eLdebug = esysdep_fopen(zLdebugfile, 0, 1, 1);
          }
        }
      }
    }
  }
#line 303
  if (! fLfile) {
#line 304
    e = stderr;
  } else
#line 306
  if ((int )ttype >= 3) {
#line 308
    e = eLdebug;
#line 312
    if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 313
      return;
    }
  } else {
#line 318
    if ((unsigned long )eLlog == (unsigned long )((void *)0)) {
#line 318
      if (! fLlog_tried) {
        {
#line 320
        zprint = (char const   *)((void *)0);
#line 322
        fLlog_tried = 1;
#line 324
        eLlog = esysdep_fopen(zLogfile, 1, 1, 1);
#line 325
        zprint = zLogfile;
        }
#line 395
        if ((unsigned long )eLlog == (unsigned long )((void *)0)) {
          {
#line 402
          tmp = __errno_location();
#line 402
          tmp___0 = strerror(*tmp);
#line 402
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: can not open log file: %s\n",
                  zProgram, zprint, tmp___0);
          }
#line 404
          if ((unsigned long )pfLfatal != (unsigned long )((void *)0)) {
            {
#line 405
            (*pfLfatal)();
            }
          }
          {
#line 406
          usysdep_exit(0);
          }
        }
      }
    }
#line 410
    e = eLlog;
#line 414
    if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 415
      return;
    }
  }
#line 418
  if ((unsigned long )zmsg == (unsigned long )((void *)0)) {
#line 419
    return;
  }
#line 421
  if ((unsigned long )pfLstart != (unsigned long )((void *)0)) {
    {
#line 422
    (*pfLstart)();
    }
  }
#line 424
  edebug = (FILE *)((void *)0);
#line 426
  if ((int )ttype < 3) {
#line 427
    edebug = eLdebug;
  }
#line 430
  fstart = 1;
#line 431
  fend = 1;
  {
#line 435
  if ((unsigned int )ttype == 0U) {
#line 435
    goto case_0;
  }
#line 438
  if ((unsigned int )ttype == 1U) {
#line 438
    goto case_1;
  }
#line 441
  if ((unsigned int )ttype == 2U) {
#line 441
    goto case_2;
  }
#line 445
  if ((unsigned int )ttype == 3U) {
#line 445
    goto case_3;
  }
#line 448
  if ((unsigned int )ttype == 4U) {
#line 448
    goto case_4;
  }
#line 452
  if ((unsigned int )ttype == 5U) {
#line 452
    goto case_5;
  }
#line 457
  if ((unsigned int )ttype == 6U) {
#line 457
    goto case_6;
  }
#line 462
  goto switch_default;
  case_0: /* CIL Label */ 
#line 436
  zhdr = "";
#line 437
  goto switch_break;
  case_1: /* CIL Label */ 
#line 439
  zhdr = "ERROR: ";
#line 440
  goto switch_break;
  case_2: /* CIL Label */ 
#line 442
  zhdr = "FATAL: ";
#line 443
  goto switch_break;
  case_3: /* CIL Label */ 
#line 446
  zhdr = "DEBUG: ";
#line 447
  goto switch_break;
  case_4: /* CIL Label */ 
#line 449
  zhdr = "DEBUG: ";
#line 450
  fend = 0;
#line 451
  goto switch_break;
  case_5: /* CIL Label */ 
#line 453
  zhdr = (char const   *)((void *)0);
#line 454
  fstart = 0;
#line 455
  fend = 0;
#line 456
  goto switch_break;
  case_6: /* CIL Label */ 
#line 458
  zhdr = (char const   *)((void *)0);
#line 459
  fstart = 0;
#line 460
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 463
  zhdr = "???: ";
#line 464
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 467
  if (! fstart) {
    {
#line 468
    zprefix = zbufcpy("");
    }
  } else
#line 471
  if (! fLfile) {
    {
#line 473
    tmp___1 = strlen(zProgram);
#line 473
    zprefix = zbufalc(tmp___1 + 3UL);
#line 474
    sprintf((char */* __restrict  */)zprefix, (char const   */* __restrict  */)"%s: ",
            zProgram);
    }
  } else {
    {
#line 478
    tmp___2 = strlen(zProgram);
    }
#line 478
    if ((unsigned long )zLsystem == (unsigned long )((void *)0)) {
#line 478
      tmp___4 = (size_t )1;
    } else {
      {
#line 478
      tmp___3 = strlen((char const   *)zLsystem);
#line 478
      tmp___4 = tmp___3;
      }
    }
#line 478
    if ((unsigned long )zLuser == (unsigned long )((void *)0)) {
#line 478
      tmp___6 = (size_t )4;
    } else {
      {
#line 478
      tmp___5 = strlen((char const   *)zLuser);
#line 478
      tmp___6 = tmp___5;
      }
    }
    {
#line 478
    tmp___7 = strlen(zhdr);
#line 478
    zprefix = zbufalc(((((tmp___2 + tmp___4) + tmp___6) + sizeof("1991-12-31 12:00:00.00")) + tmp___7) + 100UL);
#line 484
    zset = zprefix;
#line 489
    zbase = zsysdep_base_name(zProgram);
    }
#line 490
    if ((unsigned long )zbase == (unsigned long )((void *)0)) {
      {
#line 491
      zbase = zbufcpy(zProgram);
      }
    }
    {
#line 492
    zset = zstpcpy(zset, (char const   *)zbase);
#line 493
    tmp___8 = zset;
#line 493
    zset ++;
#line 493
    *tmp___8 = (char )' ';
#line 494
    ubuffree(zbase);
    }
#line 501
    if ((unsigned long )zLsystem == (unsigned long )((void *)0)) {
#line 501
      tmp___9 = "-";
    } else {
#line 501
      tmp___9 = (char const   *)zLsystem;
    }
    {
#line 501
    zset = zstpcpy(zset, tmp___9);
#line 502
    tmp___10 = zset;
#line 502
    zset ++;
#line 502
    *tmp___10 = (char )' ';
    }
#line 505
    if ((unsigned long )zLuser == (unsigned long )((void *)0)) {
#line 505
      tmp___11 = "-";
    } else {
#line 505
      tmp___11 = (char const   *)zLuser;
    }
    {
#line 505
    zset = zstpcpy(zset, tmp___11);
#line 506
    tmp___12 = zset;
#line 506
    zset ++;
#line 506
    *tmp___12 = (char )' ';
#line 509
    tmp___13 = zset;
#line 509
    zset ++;
#line 509
    *tmp___13 = (char )'(';
#line 510
    tmp___14 = zldate_and_time();
#line 510
    zset = zstpcpy(zset, tmp___14);
    }
#line 512
    if (iLid != 0) {
      {
#line 516
      sprintf((char */* __restrict  */)zset, (char const   */* __restrict  */)" %d",
              iLid);
#line 530
      tmp___15 = strlen((char const   *)zset);
#line 530
      zset += tmp___15;
      }
    }
    {
#line 538
    tmp___16 = zset;
#line 538
    zset ++;
#line 538
    *tmp___16 = (char )')';
#line 539
    tmp___17 = zset;
#line 539
    zset ++;
#line 539
    *tmp___17 = (char )' ';
#line 541
    strcpy((char */* __restrict  */)zset, (char const   */* __restrict  */)zhdr);
    }
  }
  {
#line 545
  tmp___18 = strlen((char const   *)zprefix);
#line 545
  tmp___19 = strlen(zmsg);
#line 545
  zformat = zbufalc((2UL * tmp___18 + tmp___19) + 2UL);
#line 547
  zset = zformat;
#line 548
  zfrom = zprefix;
  }
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 549
    if (! ((int )*zfrom != 0)) {
#line 549
      goto while_break___0;
    }
#line 551
    if ((int )*zfrom == 37) {
#line 552
      tmp___20 = zset;
#line 552
      zset ++;
#line 552
      *tmp___20 = (char )'%';
    }
#line 553
    tmp___21 = zset;
#line 553
    zset ++;
#line 553
    tmp___22 = zfrom;
#line 553
    zfrom ++;
#line 553
    *tmp___21 = *tmp___22;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 556
  ubuffree(zprefix);
#line 558
  zset = zstpcpy(zset, zmsg);
  }
#line 560
  if (fend) {
#line 562
    tmp___23 = zset;
#line 562
    zset ++;
#line 562
    *tmp___23 = (char )'\n';
#line 563
    *zset = (char )'\000';
  }
  {
#line 567
  __builtin_va_start(parg, zmsg);
#line 568
  vfprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)zformat, parg);
#line 569
  __builtin_va_end(parg);
  }
#line 570
  if ((unsigned long )edebug != (unsigned long )((void *)0)) {
    {
#line 572
    __builtin_va_start(parg, zmsg);
#line 573
    vfprintf((FILE */* __restrict  */)edebug, (char const   */* __restrict  */)zformat,
             parg);
#line 574
    __builtin_va_end(parg);
    }
  }
  {
#line 582
  ubuffree(zformat);
#line 584
  fflush(e);
  }
#line 585
  if ((unsigned long )edebug != (unsigned long )((void *)0)) {
    {
#line 586
    fflush(edebug);
    }
  }
#line 588
  if ((unsigned long )pfLend != (unsigned long )((void *)0)) {
    {
#line 589
    (*pfLend)();
    }
  }
#line 591
  if ((unsigned int )ttype == 2U) {
#line 593
    if ((unsigned long )pfLfatal != (unsigned long )((void *)0)) {
      {
#line 594
      (*pfLfatal)();
      }
    }
    {
#line 595
    usysdep_exit(0);
    }
  }
#line 601
  return;
}
}
#line 605 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_uuconf(enum tlog ttype , pointer puuconf , int iuuconf ) 
{ 
  char ab___0[512] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 613
  uuconf_error_string(puuconf, iuuconf, ab___0, sizeof(ab___0));
#line 614
  ulog(ttype, "%s", ab___0);
  }
#line 615
  return;
}
}
#line 620 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ulog_close(void) 
{ 


  {
  {
#line 624
  ulog((enum tlog )1, (char const   *)((void *)0));
  }
#line 626
  if ((unsigned long )eLlog != (unsigned long )((void *)0)) {
    {
#line 628
    fclose(eLlog);
#line 629
    eLlog = (FILE *)((void *)0);
#line 630
    fLlog_tried = 0;
    }
  }
#line 634
  if ((unsigned long )eLdebug != (unsigned long )((void *)0)) {
    {
#line 636
    fclose(eLdebug);
#line 637
    eLdebug = (FILE *)((void *)0);
#line 638
    fLdebug_tried = 0;
    }
  }
#line 641
  return;
}
}
#line 647 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ustats(boolean fsucceeded , char const   *zuser , char const   *zsystem , boolean fsent ,
            long cbytes , long csecs , long cmicros , boolean fcaller  __attribute__((__unused__)) ) 
{ 
  long cbps ;
  long cmillis ;
  long cdiv ;
  long crem ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 662
  if (cmicros < 0L) {
#line 664
    csecs -= - cmicros / 1000000L + 1L;
#line 665
    cmicros = 1000000L - - cmicros % 1000000L;
  }
#line 667
  if (cmicros >= 1000000L) {
#line 669
    csecs += cmicros / 10000000L;
#line 670
    cmicros %= 1000000L;
  }
#line 675
  if (csecs == 0L) {
#line 675
    if (cmicros < 1000L) {
#line 676
      cbps = 0L;
    } else {
#line 675
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 688
    cmillis = csecs * 1000L + cmicros / 1000L;
#line 689
    cdiv = (cbytes / cmillis) * 1000L;
#line 690
    crem = (cbytes % cmillis) * 1000L;
#line 691
    cbps = cdiv + crem / cmillis;
#line 692
    if (cmillis < 0L) {
#line 692
      goto _L;
    } else
#line 692
    if (cdiv < 0L) {
#line 692
      goto _L;
    } else
#line 692
    if (crem < 0L) {
#line 692
      goto _L;
    } else
#line 692
    if (cbps < 0L) {
      _L: /* CIL Label */ 
#line 695
      if (cmicros > 500000L) {
#line 695
        tmp = 1;
      } else {
#line 695
        tmp = 0;
      }
#line 695
      cbps = cbytes / (csecs + (long )tmp);
    }
  }
#line 699
  if ((unsigned long )eLstats == (unsigned long )((void *)0)) {
#line 701
    if (fLstats_tried) {
#line 702
      return;
    }
    {
#line 703
    fLstats_tried = 1;
#line 704
    eLstats = esysdep_fopen(zLstatsfile, 1, 1, 1);
    }
#line 705
    if ((unsigned long )eLstats == (unsigned long )((void *)0)) {
#line 706
      return;
    }
  }
#line 710
  if ((unsigned long )zLdevice == (unsigned long )((void *)0)) {
#line 710
    tmp___0 = "unknown";
  } else {
#line 710
    tmp___0 = (char const   *)zLdevice;
  }
#line 710
  if (fsent) {
#line 710
    tmp___1 = "sent";
  } else {
#line 710
    tmp___1 = "received";
  }
#line 710
  if (fsucceeded) {
#line 710
    tmp___2 = "";
  } else {
#line 710
    tmp___2 = "failed after ";
  }
  {
#line 710
  tmp___3 = zldate_and_time();
#line 710
  fprintf((FILE */* __restrict  */)eLstats, (char const   */* __restrict  */)"%s %s (%s) %s%s %ld bytes in %ld.%03ld seconds (%ld bytes/sec) on port %s\n",
          zuser, zsystem, tmp___3, tmp___2, tmp___1, cbytes, csecs, cmicros / 1000L,
          cbps, tmp___0);
#line 748
  fflush(eLstats);
  }
#line 753
  return;
}
}
#line 757 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
void ustats_close(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;

  {
#line 760
  if ((unsigned long )eLstats != (unsigned long )((void *)0)) {
    {
#line 762
    tmp___1 = fclose(eLstats);
    }
#line 762
    if (tmp___1 != 0) {
      {
#line 763
      tmp = __errno_location();
#line 763
      tmp___0 = strerror(*tmp);
#line 763
      ulog((enum tlog )1, "fclose: %s", tmp___0);
      }
    }
#line 764
    eLstats = (FILE *)((void *)0);
#line 765
    fLstats_tried = 0;
  }
#line 767
  return;
}
}
#line 777 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char ab[23UL]  ;
#line 771 "/home/wslee/gnu_benchmarks/uucp-1.07/log.c"
static char const   *zldate_and_time(void) 
{ 
  long isecs ;
  long imicros ;
  struct tm s ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 786
  isecs = ixsysdep_time(& imicros);
#line 787
  usysdep_localtime(isecs, & s);
#line 790
  sprintf((char */* __restrict  */)(ab), (char const   */* __restrict  */)"%04d-%02d-%02d %02d:%02d:%02d.%02d",
          s.tm_year + 1900, s.tm_mon + 1, s.tm_mday, s.tm_hour, s.tm_min, s.tm_sec,
          (int )(imicros / 10000L));
  }
#line 803
  return ((char const   *)(ab));
}
}
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/util.c"
char const   util_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/util.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'u',      (char const   )'t',      (char const   )'i', 
        (char const   )'l',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'1',      (char const   )'1',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 245 "/home/wslee/gnu_benchmarks/uucp-1.07/uudefs.h"
char *zremove_local_sys(struct uuconf_system *qlocalsys , char *z ) ;
#line 269
boolean fin_directory_list(char const   *zfile , char **pzdirs , char const   *zpubdir ,
                           boolean fcheck , boolean freadable , char const   *zuser ) ;
#line 42 "/home/wslee/gnu_benchmarks/uucp-1.07/util.c"
boolean funknown_system(pointer puuconf , char const   *zsystem , struct uuconf_system *qsys ) 
{ 
  char *z ;
  int iuuconf ;
  char **pznames ;
  char **pz ;
  boolean ffound ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 51
  tmp___0 = strlen(zsystem);
  }
#line 51
  if (tmp___0 <= cSysdep_max_name_len) {
    {
#line 52
    z = zbufcpy(zsystem);
    }
  } else {
    {
#line 58
    z = zbufalc(cSysdep_max_name_len + 1UL);
#line 59
    memcpy((void */* __restrict  */)z, (void const   */* __restrict  */)zsystem, cSysdep_max_name_len);
#line 60
    *(z + cSysdep_max_name_len) = (char )'\000';
#line 62
    iuuconf = uuconf_system_names(puuconf, & pznames, 1);
    }
#line 63
    if (iuuconf != 0) {
      {
#line 64
      ulog_uuconf((enum tlog )2, puuconf, iuuconf);
      }
    }
#line 66
    ffound = 0;
#line 67
    pz = pznames;
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
#line 67
      if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 67
        goto while_break;
      }
      {
#line 69
      tmp = strcmp((char const   *)*pz, (char const   *)z);
      }
#line 69
      if (tmp == 0) {
#line 70
        ffound = 1;
      }
      {
#line 71
      xfree((pointer )*pz);
#line 67
      pz ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 73
    xfree((pointer )pznames);
    }
#line 75
    if (ffound) {
      {
#line 77
      ubuffree(z);
      }
#line 78
      return (0);
    }
  }
  {
#line 82
  iuuconf = uuconf_system_unknown(puuconf, qsys);
  }
#line 83
  if (iuuconf == 1) {
    {
#line 85
    ubuffree(z);
    }
#line 86
    return (0);
  } else
#line 88
  if (iuuconf != 0) {
    {
#line 89
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )qsys != (unsigned long )((void *)0))) {
#line 91
      goto while_break___0;
    }
#line 92
    qsys->uuconf_zname = z;
#line 91
    qsys = qsys->uuconf_qalternate;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  return (1);
}
}
#line 101 "/home/wslee/gnu_benchmarks/uucp-1.07/util.c"
char *zremove_local_sys(struct uuconf_system *qlocalsys , char *z ) 
{ 
  size_t clen ;
  char *zexclam ;
  char **pzal ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 109
  clen = strlen((char const   *)qlocalsys->uuconf_zname);
#line 110
  zexclam = strchr((char const   *)z, '!');
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )zexclam != (unsigned long )((void *)0))) {
#line 111
      goto while_break;
    }
#line 113
    if (! ((unsigned long )z == (unsigned long )zexclam)) {
#line 113
      if ((size_t )(zexclam - z) == clen) {
        {
#line 113
        tmp___1 = strncmp((char const   *)z, (char const   *)qlocalsys->uuconf_zname,
                          clen);
        }
#line 113
        if (! (tmp___1 == 0)) {
#line 113
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 117
      if ((unsigned long )qlocalsys->uuconf_pzalias == (unsigned long )((void *)0)) {
#line 118
        goto while_break;
      } else {
#line 123
        pzal = qlocalsys->uuconf_pzalias;
        {
#line 123
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 123
          if (! ((unsigned long )*pzal != (unsigned long )((void *)0))) {
#line 123
            goto while_break___0;
          }
          {
#line 124
          tmp = strlen((char const   *)*pzal);
          }
#line 124
          if (tmp == (size_t )(zexclam - z)) {
            {
#line 124
            tmp___0 = strncmp((char const   *)z, (char const   *)*pzal, (size_t )(zexclam - z));
            }
#line 124
            if (tmp___0 == 0) {
#line 126
              goto while_break___0;
            }
          }
#line 123
          pzal ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 127
        if ((unsigned long )*pzal == (unsigned long )((void *)0)) {
#line 128
          goto while_break;
        }
      }
    }
    {
#line 130
    z = zexclam + 1;
#line 131
    zexclam = strchr((char const   *)z, '!');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (z);
}
}
#line 140 "/home/wslee/gnu_benchmarks/uucp-1.07/util.c"
boolean fin_directory_list(char const   *zfile , char **pzdirs , char const   *zpubdir ,
                           boolean fcheck , boolean freadable , char const   *zuser ) 
{ 
  boolean fmatch ;
  char **pz ;
  char *zuse ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 152
  fmatch = 0;
#line 154
  pz = pzdirs;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )*pz != (unsigned long )((void *)0))) {
#line 154
      goto while_break;
    }
#line 158
    if ((int )*(*(pz + 0) + 0) == 33) {
      {
#line 160
      zuse = zsysdep_local_file((char const   *)(*pz + 1), zpubdir, (boolean *)((void *)0));
      }
#line 161
      if ((unsigned long )zuse == (unsigned long )((void *)0)) {
#line 162
        return (0);
      }
      {
#line 164
      tmp = fsysdep_in_directory(zfile, (char const   *)zuse, 0, 0, (char const   *)((void *)0));
      }
#line 164
      if (tmp) {
#line 166
        fmatch = 0;
      }
    } else {
      {
#line 170
      zuse = zsysdep_local_file((char const   *)*pz, zpubdir, (boolean *)((void *)0));
      }
#line 171
      if ((unsigned long )zuse == (unsigned long )((void *)0)) {
#line 172
        return (0);
      }
      {
#line 174
      tmp___0 = fsysdep_in_directory(zfile, (char const   *)zuse, fcheck, freadable,
                                     zuser);
      }
#line 174
      if (tmp___0) {
#line 176
        fmatch = 1;
      }
    }
    {
#line 179
    ubuffree(zuse);
#line 154
    pz ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (fmatch);
}
}
#line 335 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.h"
int main(int argc , char **argv ) ;
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
char const   uucp_rcsid[49]  = 
#line 28 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'u',      (char const   )'u',      (char const   )'c', 
        (char const   )'p',      (char const   )'.',      (char const   )'c',      (char const   )',', 
        (char const   )'v',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'7',      (char const   )'6',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )'/', 
        (char const   )'0',      (char const   )'3',      (char const   )'/',      (char const   )'0', 
        (char const   )'5',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )':',      (char const   )'1',      (char const   )'0',      (char const   )':', 
        (char const   )'4',      (char const   )'2',      (char const   )' ',      (char const   )'i', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 42
static void ucusage(void) ;
#line 43
static void uchelp(void) ;
#line 44
static void ucdirfile(char const   *zfull , char const   *zrelative , pointer pinfo ) ;
#line 46
static void uccopy(char const   *zfile , char const   *zdest , boolean fforcelocal ) ;
#line 48
static void ucadd_cmd(struct uuconf_system  const  *qsys , struct scmd  const  *qcmd ,
                      char const   *zlog ) ;
#line 50
static void ucspool_cmds(boolean fjobid ) ;
#line 51
static char const   *zcone_system(boolean *pfany ) ;
#line 52
static void ucrecord_file(char const   *zfile ) ;
#line 53
static void ucabort(void) ;
#line 58 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static struct option  const  asClongopts[19]  = 
#line 58
  {      {"copy", 0, (int *)((void *)0), 'C'}, 
        {"nocopy", 0, (int *)((void *)0), 'c'}, 
        {"directories", 0, (int *)((void *)0), 'd'}, 
        {"nodirectories", 0, (int *)((void *)0), 'f'}, 
        {"grade", 1, (int *)((void *)0), 'g'}, 
        {"jobid", 0, (int *)((void *)0), 'j'}, 
        {"mail", 0, (int *)((void *)0), 'm'}, 
        {"notify", 1, (int *)((void *)0), 'n'}, 
        {"nouucico", 0, (int *)((void *)0), 'r'}, 
        {"recursive", 0, (int *)((void *)0), 'R'}, 
        {"status", 1, (int *)((void *)0), 's'}, 
        {"uuto", 0, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"noexpand", 0, (int *)((void *)0), 'W'}, 
        {"config", 1, (int *)((void *)0), 'I'}, 
        {"debug", 1, (int *)((void *)0), 'x'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 1}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 87 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static pointer pCuuconf  ;
#line 90 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fCcopy  =    1;
#line 93 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char bCgrade  =    (char )'N';
#line 97 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fCmail  =    0;
#line 100 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char const   *zCnotify  =    "";
#line 104 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fCexpand  =    1;
#line 108 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fCmkdirs  =    1;
#line 111 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char const   *zClocalname  ;
#line 114 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char const   *zCuser  =    (char const   *)((void *)0);
#line 117 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fCremote  =    0;
#line 120 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fClocaldest  ;
#line 123 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static struct uuconf_system sCdestsys  ;
#line 126 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char *zCforward  ;
#line 129 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char abCsend_options[20]  ;
#line 132 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char abCrec_options[20]  ;
#line 135 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static boolean fCneeds_cwd  ;
#line 139 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
int main(int argc , char **argv ) 
{ 
  char const   *zconfig ;
  boolean fjobid ;
  boolean fuucico ;
  boolean frecursive ;
  char const   *zstatus_file ;
  boolean fuuto ;
  int iopt ;
  pointer puuconf ;
  int iuuconf ;
  int i ;
  boolean fgetcwd ;
  struct uuconf_system slocalsys ;
  char *zexclam ;
  char *zdestfile ;
  char const   *zdestsys ;
  char *zoptions ;
  boolean fexit ;
  boolean tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char const   *zdebug ;
  int tmp___3 ;
  boolean tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t clen ;
  char *zcopy ;
  boolean tmp___15 ;
  size_t clen___0 ;
  boolean flocal ;
  char *zfrom ;
  boolean tmp___16 ;
  char *tmp___17 ;
  char *zbase ;
  char *zindir ;
  boolean tmp___18 ;
  char const   *zsys ;
  boolean fany ;
  char const   *zarg ;
  char *zconfigarg ;
  char *z ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 145
  zconfig = (char const   *)((void *)0);
#line 147
  fjobid = 0;
#line 149
  fuucico = 1;
#line 151
  frecursive = 0;
#line 153
  zstatus_file = (char const   *)((void *)0);
#line 155
  fuuto = 0;
#line 168
  zProgram = (char const   *)*(argv + 0);
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    iopt = getopt_long(argc, (char * const  *)argv, "cCdfg:I:jmn:prRs:tu:Wvx:", asClongopts,
                       (int *)((void *)0));
    }
#line 170
    if (! (iopt != -1)) {
#line 170
      goto while_break;
    }
    {
#line 175
    if (iopt == 99) {
#line 175
      goto case_99;
    }
#line 181
    if (iopt == 67) {
#line 181
      goto case_67;
    }
#line 181
    if (iopt == 112) {
#line 181
      goto case_67;
    }
#line 186
    if (iopt == 100) {
#line 186
      goto case_100;
    }
#line 191
    if (iopt == 102) {
#line 191
      goto case_102;
    }
#line 196
    if (iopt == 103) {
#line 196
      goto case_103;
    }
#line 201
    if (iopt == 73) {
#line 201
      goto case_73;
    }
#line 207
    if (iopt == 106) {
#line 207
      goto case_106;
    }
#line 212
    if (iopt == 109) {
#line 212
      goto case_109;
    }
#line 217
    if (iopt == 110) {
#line 217
      goto case_110;
    }
#line 222
    if (iopt == 114) {
#line 222
      goto case_114;
    }
#line 227
    if (iopt == 82) {
#line 227
      goto case_82;
    }
#line 232
    if (iopt == 115) {
#line 232
      goto case_115;
    }
#line 237
    if (iopt == 116) {
#line 237
      goto case_116;
    }
#line 242
    if (iopt == 117) {
#line 242
      goto case_117;
    }
#line 247
    if (iopt == 87) {
#line 247
      goto case_87;
    }
#line 252
    if (iopt == 120) {
#line 252
      goto case_120;
    }
#line 259
    if (iopt == 118) {
#line 259
      goto case_118;
    }
#line 268
    if (iopt == 1) {
#line 268
      goto case_1;
    }
#line 274
    if (iopt == 0) {
#line 274
      goto case_0;
    }
#line 278
    goto switch_default;
    case_99: /* CIL Label */ 
#line 177
    fCcopy = 0;
#line 178
    goto switch_break;
    case_67: /* CIL Label */ 
    case_112: /* CIL Label */ 
#line 183
    fCcopy = 1;
#line 184
    goto switch_break;
    case_100: /* CIL Label */ 
#line 188
    fCmkdirs = 1;
#line 189
    goto switch_break;
    case_102: /* CIL Label */ 
#line 193
    fCmkdirs = 0;
#line 194
    goto switch_break;
    case_103: /* CIL Label */ 
#line 198
    bCgrade = *(gnu_optarg + 0);
#line 199
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 203
    tmp = fsysdep_other_config((char const   *)gnu_optarg);
    }
#line 203
    if (tmp) {
#line 204
      zconfig = (char const   *)gnu_optarg;
    }
#line 205
    goto switch_break;
    case_106: /* CIL Label */ 
#line 209
    fjobid = 1;
#line 210
    goto switch_break;
    case_109: /* CIL Label */ 
#line 214
    fCmail = 1;
#line 215
    goto switch_break;
    case_110: /* CIL Label */ 
#line 219
    zCnotify = (char const   *)gnu_optarg;
#line 220
    goto switch_break;
    case_114: /* CIL Label */ 
#line 224
    fuucico = 0;
#line 225
    goto switch_break;
    case_82: /* CIL Label */ 
#line 229
    frecursive = 1;
#line 230
    goto switch_break;
    case_115: /* CIL Label */ 
#line 234
    zstatus_file = (char const   *)gnu_optarg;
#line 235
    goto switch_break;
    case_116: /* CIL Label */ 
#line 239
    fuuto = 1;
#line 240
    goto switch_break;
    case_117: /* CIL Label */ 
#line 244
    zCuser = (char const   *)gnu_optarg;
#line 245
    goto switch_break;
    case_87: /* CIL Label */ 
#line 249
    fCexpand = 0;
#line 250
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 255
    tmp___0 = idebug_parse((char const   *)gnu_optarg);
#line 255
    iDebug |= tmp___0;
    }
#line 257
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 261
    printf((char const   */* __restrict  */)"uucp (Taylor UUCP) %s\n", "1.07");
#line 262
    printf((char const   */* __restrict  */)"Copyright (C) 1991, 92, 93, 94, 1995, 2002 Ian Lance Taylor\n");
#line 263
    printf((char const   */* __restrict  */)"This program is free software; you may redistribute it under the terms of\n");
#line 264
    printf((char const   */* __restrict  */)"the GNU General Public LIcense.  This program has ABSOLUTELY NO WARRANTY.\n");
#line 265
    exit(0);
    }
    case_1: /* CIL Label */ 
    {
#line 270
    uchelp();
#line 271
    exit(0);
    }
    case_0: /* CIL Label */ 
#line 276
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 279
    ucusage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___1 = __ctype_b_loc();
  }
#line 284
  if ((int const   )*(*tmp___1 + (int )((unsigned char )bCgrade)) & 8) {
#line 284
    if ((int )bCgrade < 48) {
#line 284
      goto _L___0;
    } else
#line 284
    if ((int )bCgrade > 57) {
      _L___0: /* CIL Label */ 
#line 284
      if ((int )bCgrade < 97) {
#line 284
        goto _L;
      } else
#line 284
      if ((int )bCgrade > 122) {
        _L: /* CIL Label */ 
#line 284
        if ((int )bCgrade < 65) {
          {
#line 289
          ulog((enum tlog )1, "Ignoring illegal grade");
#line 290
          bCgrade = (char )'N';
          }
        } else
#line 284
        if ((int )bCgrade > 90) {
          {
#line 289
          ulog((enum tlog )1, "Ignoring illegal grade");
#line 290
          bCgrade = (char )'N';
          }
        }
      }
    }
  } else {
    {
#line 289
    ulog((enum tlog )1, "Ignoring illegal grade");
#line 290
    bCgrade = (char )'N';
    }
  }
#line 297
  if ((unsigned long )zCuser != (unsigned long )((void *)0)) {
    {
#line 299
    tmp___2 = strchr(zCuser, '!');
    }
#line 299
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 300
      fCremote = 1;
    } else {
      {
#line 303
      ulog((enum tlog )1, "Ignoring local user name");
#line 304
      zCuser = (char const   *)((void *)0);
      }
    }
  }
#line 308
  if (argc - gnu_optind < 2) {
    {
#line 309
    ucusage();
    }
  }
  {
#line 311
  iuuconf = uuconf_init(& puuconf, (char const   *)((void *)0), zconfig);
  }
#line 312
  if (iuuconf != 0) {
    {
#line 313
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 314
  pCuuconf = puuconf;
#line 320
  iuuconf = uuconf_debuglevel(puuconf, & zdebug);
  }
#line 321
  if (iuuconf != 0) {
    {
#line 322
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
#line 323
  if ((unsigned long )zdebug != (unsigned long )((void *)0)) {
    {
#line 324
    tmp___3 = idebug_parse(zdebug);
#line 324
    iDebug |= tmp___3;
    }
  }
#line 332
  fgetcwd = 0;
#line 333
  i = gnu_optind;
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 333
    if (! (i < argc)) {
#line 333
      goto while_break___0;
    }
    {
#line 335
    zexclam = strrchr((char const   *)*(argv + i), '!');
    }
#line 336
    if ((unsigned long )zexclam == (unsigned long )((void *)0)) {
#line 337
      zexclam = *(argv + i);
    } else {
#line 339
      zexclam ++;
    }
    {
#line 340
    tmp___4 = fsysdep_needs_cwd((char const   *)zexclam);
    }
#line 340
    if (tmp___4) {
#line 342
      fgetcwd = 1;
#line 343
      goto while_break___0;
    }
#line 333
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 348
  usysdep_signal(2);
#line 351
  usysdep_signal(1);
#line 354
  usysdep_signal(3);
#line 357
  usysdep_signal(15);
#line 360
  usysdep_signal(13);
  }
#line 363
  if (fgetcwd) {
#line 363
    tmp___5 = 1;
  } else {
#line 363
    tmp___5 = 0;
  }
  {
#line 363
  usysdep_initialize(puuconf, 4 | tmp___5);
#line 365
  ulog_fatal_fn(& ucabort);
  }
#line 367
  if ((unsigned long )zCuser == (unsigned long )((void *)0)) {
    {
#line 368
    zCuser = zsysdep_login_name();
    }
  }
  {
#line 370
  iuuconf = uuconf_localname(puuconf, & zClocalname);
  }
#line 371
  if (iuuconf == 1) {
    {
#line 373
    zClocalname = zsysdep_localname();
    }
#line 374
    if ((unsigned long )zClocalname == (unsigned long )((void *)0)) {
      {
#line 375
      exit(1);
      }
    }
  } else
#line 377
  if (iuuconf != 0) {
    {
#line 378
    ulog_uuconf((enum tlog )2, puuconf, iuuconf);
    }
  }
  {
#line 381
  iuuconf = uuconf_system_info(puuconf, zClocalname, & slocalsys);
  }
#line 382
  if (iuuconf != 0) {
#line 384
    if (iuuconf != 1) {
      {
#line 385
      ulog_uuconf((enum tlog )2, puuconf, iuuconf);
      }
    }
    {
#line 386
    iuuconf = uuconf_system_local(puuconf, & slocalsys);
    }
#line 387
    if (iuuconf != 0) {
      {
#line 388
      ulog_uuconf((enum tlog )2, puuconf, iuuconf);
      }
    }
#line 389
    slocalsys.uuconf_zname = (char *)zClocalname;
  }
#line 396
  if (fuuto) {
#line 398
    if ((int const   )*zCnotify == 0) {
      {
#line 400
      zexclam = strrchr((char const   *)*(argv + (argc - 1)), '!');
      }
#line 401
      if ((unsigned long )zexclam == (unsigned long )((void *)0)) {
        {
#line 402
        ucusage();
        }
      }
#line 403
      zCnotify = (char const   *)(zexclam + 1);
    }
    {
#line 405
    *(argv + (argc - 1)) = zsysdep_uuto((char const   *)*(argv + (argc - 1)), zClocalname);
    }
#line 406
    if ((unsigned long )*(argv + (argc - 1)) == (unsigned long )((void *)0)) {
      {
#line 407
      ucusage();
      }
    }
  }
#line 411
  zoptions = abCsend_options;
#line 412
  if (fCcopy) {
#line 413
    tmp___6 = zoptions;
#line 413
    zoptions ++;
#line 413
    *tmp___6 = (char )'C';
  } else {
#line 415
    tmp___7 = zoptions;
#line 415
    zoptions ++;
#line 415
    *tmp___7 = (char )'c';
  }
#line 416
  if (fCmkdirs) {
#line 417
    tmp___8 = zoptions;
#line 417
    zoptions ++;
#line 417
    *tmp___8 = (char )'d';
  } else {
#line 419
    tmp___9 = zoptions;
#line 419
    zoptions ++;
#line 419
    *tmp___9 = (char )'f';
  }
#line 420
  if (fCmail) {
#line 421
    tmp___10 = zoptions;
#line 421
    zoptions ++;
#line 421
    *tmp___10 = (char )'m';
  }
#line 422
  if ((int const   )*zCnotify != 0) {
#line 423
    tmp___11 = zoptions;
#line 423
    zoptions ++;
#line 423
    *tmp___11 = (char )'n';
  }
#line 424
  *zoptions = (char )'\000';
#line 426
  zoptions = abCrec_options;
#line 427
  if (fCmkdirs) {
#line 428
    tmp___12 = zoptions;
#line 428
    zoptions ++;
#line 428
    *tmp___12 = (char )'d';
  } else {
#line 430
    tmp___13 = zoptions;
#line 430
    zoptions ++;
#line 430
    *tmp___13 = (char )'f';
  }
#line 431
  if (fCmail) {
#line 432
    tmp___14 = zoptions;
#line 432
    zoptions ++;
#line 432
    *tmp___14 = (char )'m';
  }
  {
#line 433
  *zoptions = (char )'\000';
#line 435
  *(argv + (argc - 1)) = zremove_local_sys(& slocalsys, *(argv + (argc - 1)));
#line 437
  zexclam = strchr((char const   *)*(argv + (argc - 1)), '!');
  }
#line 438
  if ((unsigned long )zexclam == (unsigned long )((void *)0)) {
#line 440
    zdestsys = zClocalname;
#line 441
    zdestfile = *(argv + (argc - 1));
#line 442
    fClocaldest = 1;
  } else {
    {
#line 449
    clen = (size_t )(zexclam - *(argv + (argc - 1)));
#line 450
    zcopy = zbufalc(clen + 1UL);
#line 451
    memcpy((void */* __restrict  */)zcopy, (void const   */* __restrict  */)*(argv + (argc - 1)),
           clen);
#line 452
    *(zcopy + clen) = (char )'\000';
#line 453
    zdestsys = (char const   *)zcopy;
#line 455
    zdestfile = zexclam + 1;
#line 457
    fClocaldest = 0;
    }
  }
  {
#line 460
  iuuconf = uuconf_system_info(puuconf, zdestsys, & sCdestsys);
  }
#line 461
  if (iuuconf != 0) {
#line 463
    if (iuuconf != 1) {
      {
#line 464
      ulog_uuconf((enum tlog )2, puuconf, iuuconf);
      }
    }
#line 465
    if (fClocaldest) {
      {
#line 467
      iuuconf = uuconf_system_local(puuconf, & sCdestsys);
      }
#line 468
      if (iuuconf != 0) {
        {
#line 469
        ulog_uuconf((enum tlog )2, puuconf, iuuconf);
        }
      }
#line 470
      sCdestsys.uuconf_zname = (char *)zClocalname;
    } else {
      {
#line 474
      tmp___15 = funknown_system(puuconf, zdestsys, & sCdestsys);
      }
#line 474
      if (! tmp___15) {
        {
#line 475
        ulog((enum tlog )2, "%s: System not found", zdestsys);
        }
      }
    }
  }
  {
#line 483
  zexclam = strrchr((char const   *)zdestfile, '!');
  }
#line 484
  if ((unsigned long )zexclam == (unsigned long )((void *)0)) {
#line 485
    zCforward = (char *)((void *)0);
  } else {
#line 491
    if (fClocaldest) {
      {
#line 492
      ulog((enum tlog )2, "Can\'t happen");
      }
    }
    {
#line 494
    clen___0 = (size_t )(zexclam - zdestfile);
#line 495
    zCforward = zbufalc(clen___0 + 1UL);
#line 496
    memcpy((void */* __restrict  */)zCforward, (void const   */* __restrict  */)zdestfile,
           clen___0);
#line 497
    *(zCforward + clen___0) = (char )'\000';
#line 498
    zdestfile = zexclam + 1;
    }
  }
#line 503
  if (fClocaldest) {
    {
#line 504
    zdestfile = zsysdep_local_file_cwd((char const   *)zdestfile, sCdestsys.uuconf_zpubdir,
                                       (boolean *)((void *)0));
    }
  } else
#line 506
  if (fCexpand) {
    {
#line 507
    zdestfile = zsysdep_add_cwd((char const   *)zdestfile);
    }
  }
#line 508
  if ((unsigned long )zdestfile == (unsigned long )((void *)0)) {
    {
#line 510
    ulog_close();
#line 511
    usysdep_exit(0);
    }
  }
#line 515
  i = gnu_optind;
  {
#line 515
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 515
    if (i < argc - 1) {
#line 515
      if (afSignal[0]) {
#line 515
        goto while_break___1;
      } else
#line 515
      if (afSignal[1]) {
#line 515
        goto while_break___1;
      } else
#line 515
      if (afSignal[2]) {
#line 515
        goto while_break___1;
      } else
#line 515
      if (afSignal[3]) {
#line 515
        goto while_break___1;
      } else
#line 515
      if (afSignal[4]) {
#line 515
        goto while_break___1;
      }
    } else {
#line 515
      goto while_break___1;
    }
    {
#line 520
    fCneeds_cwd = 0;
#line 522
    *(argv + i) = zremove_local_sys(& slocalsys, *(argv + i));
#line 524
    tmp___17 = strchr((char const   *)*(argv + i), '!');
    }
#line 524
    if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
      {
#line 526
      flocal = 0;
#line 527
      zfrom = zbufcpy((char const   *)*(argv + i));
      }
    } else {
      {
#line 534
      flocal = 1;
#line 535
      tmp___16 = fsysdep_needs_cwd((char const   *)*(argv + i));
      }
#line 535
      if (tmp___16) {
#line 536
        fCneeds_cwd = 1;
      }
      {
#line 537
      zfrom = zsysdep_local_file_cwd((char const   *)*(argv + i), sCdestsys.uuconf_zpubdir,
                                     (boolean *)((void *)0));
      }
#line 540
      if ((unsigned long )zfrom == (unsigned long )((void *)0)) {
        {
#line 541
        ucabort();
        }
      }
    }
#line 544
    if (! flocal) {
      {
#line 545
      uccopy((char const   *)zfrom, (char const   *)zdestfile, 0);
      }
    } else {
      {
#line 544
      tmp___18 = fsysdep_directory((char const   *)zfrom);
      }
#line 544
      if (tmp___18) {
#line 550
        if (! frecursive) {
          {
#line 551
          ulog((enum tlog )2, "%s: directory without -R", zfrom);
          }
        }
        {
#line 553
        zbase = zsysdep_base_name((char const   *)zfrom);
        }
#line 554
        if ((unsigned long )zbase == (unsigned long )((void *)0)) {
          {
#line 555
          ucabort();
          }
        }
        {
#line 556
        zindir = zsysdep_in_dir((char const   *)zdestfile, (char const   *)zbase);
#line 557
        ubuffree(zbase);
        }
#line 558
        if ((unsigned long )zindir == (unsigned long )((void *)0)) {
          {
#line 559
          ucabort();
          }
        }
        {
#line 560
        usysdep_walk_tree((char const   *)zfrom, & ucdirfile, (pointer )zindir);
#line 561
        ubuffree(zindir);
        }
      } else {
        {
#line 545
        uccopy((char const   *)zfrom, (char const   *)zdestfile, 0);
        }
      }
    }
    {
#line 564
    ubuffree(zfrom);
#line 515
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 568
  if (afSignal[0]) {
    {
#line 569
    ucabort();
    }
  } else
#line 568
  if (afSignal[1]) {
    {
#line 569
    ucabort();
    }
  } else
#line 568
  if (afSignal[2]) {
    {
#line 569
    ucabort();
    }
  } else
#line 568
  if (afSignal[3]) {
    {
#line 569
    ucabort();
    }
  } else
#line 568
  if (afSignal[4]) {
    {
#line 569
    ucabort();
    }
  }
  {
#line 572
  ulog_to_file(puuconf, 1);
#line 573
  ulog_user(zCuser);
#line 575
  ucspool_cmds(fjobid);
#line 577
  ulog_close();
  }
#line 579
  if (! fuucico) {
#line 580
    fexit = 1;
  } else {
    {
#line 586
    zsys = zcone_system(& fany);
    }
#line 588
    if ((unsigned long )zsys == (unsigned long )((void *)0)) {
#line 588
      if (! fany) {
#line 589
        fexit = 1;
      } else {
#line 588
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 595
      if ((unsigned long )zsys == (unsigned long )((void *)0)) {
#line 596
        zarg = "-r1";
      } else {
        {
#line 601
        tmp___19 = strlen(zsys);
#line 601
        z = zbufalc(sizeof("-Cs") + tmp___19);
#line 602
        sprintf((char */* __restrict  */)z, (char const   */* __restrict  */)"-Cs%s",
                zsys);
#line 603
        zarg = (char const   *)z;
        }
      }
#line 606
      if ((unsigned long )zconfig == (unsigned long )((void *)0)) {
#line 607
        zconfigarg = (char *)((void *)0);
      } else {
        {
#line 610
        tmp___20 = strlen(zconfig);
#line 610
        zconfigarg = zbufalc(sizeof("-I") + tmp___20);
#line 611
        sprintf((char */* __restrict  */)zconfigarg, (char const   */* __restrict  */)"-I%s",
                zconfig);
        }
      }
      {
#line 614
      fexit = fsysdep_run(0, "uucico", zarg, (char const   *)zconfigarg);
      }
    }
  }
  {
#line 618
  usysdep_exit(fexit);
  }
#line 621
  return (0);
}
}
#line 626 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void ucusage(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 629
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [options] file1 [file2 ...] dest\n",
          zProgram);
#line 631
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use %s --help for help\n",
          zProgram);
#line 632
  exit(1);
  }
}
}
#line 637 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void uchelp(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 640
  printf((char const   */* __restrict  */)"Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995, 2002 Ian Lance Taylor\n",
         "1.07");
#line 642
  printf((char const   */* __restrict  */)"Usage: %s [options] file1 [file2 ...] dest\n",
         zProgram);
#line 643
  printf((char const   */* __restrict  */)" -c,--nocopy: Do not copy local files to spool directory\n");
#line 644
  printf((char const   */* __restrict  */)" -C,-p,--copy: Copy local files to spool directory (default)\n");
#line 645
  printf((char const   */* __restrict  */)" -d,--directories: Create necessary directories (default)\n");
#line 646
  printf((char const   */* __restrict  */)" -f,--nodirectories: Do not create directories (fail if they do not exist)\n");
#line 647
  printf((char const   */* __restrict  */)" -g,--grade grade: Set job grade (must be alphabetic)\n");
#line 648
  printf((char const   */* __restrict  */)" -m,--mail: Report status of copy by mail\n");
#line 649
  printf((char const   */* __restrict  */)" -n,--notify user: Report status of copy by mail to remote user\n");
#line 650
  printf((char const   */* __restrict  */)" -R,--recursive: Copy directories recursively\n");
#line 651
  printf((char const   */* __restrict  */)" -r,--nouucico: Do not start uucico daemon\n");
#line 652
  printf((char const   */* __restrict  */)" -s,--status file: Report completion status to file\n");
#line 653
  printf((char const   */* __restrict  */)" -j,--jobid: Report job id\n");
#line 654
  printf((char const   */* __restrict  */)" -W,--noexpand: Do not add current directory to remote filenames\n");
#line 655
  printf((char const   */* __restrict  */)" -t,--uuto: Emulate uuto\n");
#line 656
  printf((char const   */* __restrict  */)" -u,--user name: Set user name\n");
#line 657
  printf((char const   */* __restrict  */)" -x,--debug debug: Set debugging level\n");
#line 659
  printf((char const   */* __restrict  */)" -I,--config file: Set configuration file to use\n");
#line 661
  printf((char const   */* __restrict  */)" -v,--version: Print version and exit\n");
#line 662
  printf((char const   */* __restrict  */)" --help: Print help and exit\n");
#line 663
  printf((char const   */* __restrict  */)"Report bugs to taylor-uucp@gnu.org\n");
  }
#line 664
  return;
}
}
#line 668 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void ucdirfile(char const   *zfull , char const   *zrelative , pointer pinfo ) 
{ 
  char const   *zdestfile ;
  char *zto ;

  {
  {
#line 674
  zdestfile = (char const   *)pinfo;
#line 677
  zto = zsysdep_in_dir(zdestfile, zrelative);
  }
#line 678
  if ((unsigned long )zto == (unsigned long )((void *)0)) {
    {
#line 679
    ucabort();
    }
  }
  {
#line 681
  uccopy(zfull, (char const   *)zto, 1);
#line 683
  ubuffree(zto);
  }
#line 684
  return;
}
}
#line 691 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void uccopy(char const   *zfile , char const   *zdest , boolean fforcelocal ) 
{ 
  struct scmd s ;
  char *zexclam ;
  char *zto ;
  openfile_t efrom ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean fok ;
  unsigned int imode ;
  boolean tmp___1 ;
  int tmp___2 ;
  char const   *zloc ;
  char abtname[15] ;
  unsigned int imode___0 ;
  char *ztemp ;
  boolean tmp___3 ;
  char const   *tmp___4 ;
  boolean tmp___5 ;
  boolean tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *zbase ;
  char *zxqt ;
  char abxtname[15] ;
  char abdname[15] ;
  char abxname[15] ;
  FILE *e ;
  char *zlog ;
  boolean tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *zfrom ;
  char *zforward ;
  size_t clen ;
  char *zcopy ;
  struct uuconf_system *qfromsys ;
  int iuuconf ;
  char const   *zloc___0 ;
  pointer tmp___23 ;
  boolean tmp___24 ;
  boolean fok___0 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  char *zxqt___0 ;
  char abtname___0[15] ;
  char abxname___0[15] ;
  FILE *e___0 ;
  char *zcmd ;
  char *zlog___0 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  boolean tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  size_t tmp___45 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;

  {
  {
#line 701
  zexclam = strchr(zfile, '!');
  }
#line 703
  if ((unsigned long )zexclam == (unsigned long )((void *)0)) {
#line 703
    goto _L___0;
  } else
#line 703
  if (fforcelocal) {
    _L___0: /* CIL Label */ 
    {
#line 709
    tmp = fsysdep_access(zfile);
    }
#line 709
    if (! tmp) {
      {
#line 710
      ucabort();
      }
    }
#line 718
    if (fCremote) {
#line 718
      if (! fCneeds_cwd) {
        {
#line 718
        tmp___0 = fin_directory_list(zfile, sCdestsys.uuconf_pzremote_send, sCdestsys.uuconf_zpubdir,
                                     1, 1, (char const   *)((void *)0));
        }
#line 718
        if (! tmp___0) {
          {
#line 723
          ulog((enum tlog )2, "Not permitted to send %s", zfile);
          }
        }
      }
    }
#line 725
    if (fClocaldest) {
#line 734
      if (fCremote) {
        {
#line 735
        fok = fin_directory_list(zdest, sCdestsys.uuconf_pzremote_receive, sCdestsys.uuconf_zpubdir,
                                 1, 0, (char const   *)((void *)0));
        }
      } else {
        {
#line 740
        fok = fin_directory_list(zdest, sCdestsys.uuconf_pzlocal_receive, sCdestsys.uuconf_zpubdir,
                                 1, 0, zCuser);
        }
      }
#line 744
      if (! fok) {
        {
#line 745
        ulog((enum tlog )2, "Not permitted to receive to %s", zdest);
        }
      }
      {
#line 747
      zto = zsysdep_add_base(zdest, zfile);
      }
#line 748
      if ((unsigned long )zto == (unsigned long )((void *)0)) {
        {
#line 749
        ucabort();
        }
      }
      {
#line 751
      efrom = esysdep_user_fopen(zfile, 1, 1);
      }
#line 752
      if (! ((unsigned long )efrom != (unsigned long )((void *)0))) {
        {
#line 753
        ucabort();
        }
      }
      {
#line 754
      tmp___1 = fcopy_open_file(efrom, (char const   *)zto, 0, fCmkdirs, 1);
      }
#line 754
      if (! tmp___1) {
        {
#line 755
        ucabort();
        }
      }
      {
#line 756
      tmp___2 = fclose(efrom);
#line 757
      ubuffree(zto);
#line 759
      imode = ixsysdep_user_file_mode(zfile);
      }
#line 760
      if (imode != 0U) {
        {
#line 761
        fsysdep_change_mode((char const   *)zto, imode);
        }
      }
    } else {
      {
#line 772
      imode___0 = ixsysdep_user_file_mode(zfile);
      }
#line 773
      if (imode___0 == 0U) {
        {
#line 774
        ucabort();
        }
      }
#line 776
      zloc = (char const   *)sCdestsys.uuconf_zlocalname;
#line 777
      if ((unsigned long )zloc == (unsigned long )((void *)0)) {
#line 778
        zloc = zClocalname;
      }
      {
#line 780
      ztemp = zsysdep_data_file_name((struct uuconf_system  const  *)(& sCdestsys),
                                     zloc, (int )bCgrade, 0, abtname, (char *)((void *)0),
                                     (char *)((void *)0));
      }
#line 783
      if ((unsigned long )ztemp == (unsigned long )((void *)0)) {
        {
#line 784
        ucabort();
        }
      }
#line 786
      if (! fCcopy) {
        {
#line 791
        ubuffree(ztemp);
#line 795
        tmp___3 = fsysdep_daemon_access(zfile);
        }
#line 795
        if (! tmp___3) {
          {
#line 796
          ucabort();
          }
        }
#line 797
        if (fCremote) {
#line 797
          tmp___4 = (char const   *)((void *)0);
        } else {
#line 797
          tmp___4 = zCuser;
        }
        {
#line 797
        tmp___5 = fin_directory_list(zfile, sCdestsys.uuconf_pzlocal_send, sCdestsys.uuconf_zpubdir,
                                     1, 1, tmp___4);
        }
#line 797
        if (! tmp___5) {
          {
#line 802
          ulog((enum tlog )2, "Daemon not permitted to send %s (suggest --copy)",
               zfile);
          }
        }
      } else {
        {
#line 808
        efrom = esysdep_user_fopen(zfile, 1, 1);
        }
#line 809
        if (! ((unsigned long )efrom != (unsigned long )((void *)0))) {
          {
#line 810
          ucabort();
          }
        }
        {
#line 811
        ucrecord_file((char const   *)ztemp);
#line 812
        tmp___6 = fcopy_open_file(efrom, (char const   *)ztemp, 0, 1, 1);
        }
#line 812
        if (! tmp___6) {
          {
#line 813
          ucabort();
          }
        }
        {
#line 814
        tmp___7 = fclose(efrom);
        }
      }
#line 817
      if ((unsigned long )zCforward == (unsigned long )((void *)0)) {
        {
#line 820
        s.bcmd = (char )'S';
#line 821
        s.bgrade = bCgrade;
#line 822
        s.pseq = (void *)0;
#line 823
        tmp___8 = zbufcpy(zfile);
#line 823
        s.zfrom = (char const   *)tmp___8;
#line 824
        tmp___9 = zbufcpy(zdest);
#line 824
        s.zto = (char const   *)tmp___9;
#line 825
        s.zuser = zCuser;
#line 826
        s.zoptions = (char const   *)(abCsend_options);
#line 827
        tmp___10 = zbufcpy((char const   *)(abtname));
#line 827
        s.ztemp = (char const   *)tmp___10;
#line 828
        s.imode = imode___0;
#line 829
        s.znotify = zCnotify;
#line 830
        s.cbytes = -1L;
#line 831
        s.zcmd = (char const   *)((void *)0);
#line 832
        s.ipos = 0L;
#line 834
        ucadd_cmd((struct uuconf_system  const  *)(& sCdestsys), (struct scmd  const  *)(& s),
                  (char const   *)((void *)0));
        }
      } else {
        {
#line 849
        zbase = zsysdep_base_name(zfile);
        }
#line 850
        if ((unsigned long )zbase == (unsigned long )((void *)0)) {
          {
#line 851
          ucabort();
          }
        }
        {
#line 853
        zxqt = zsysdep_data_file_name((struct uuconf_system  const  *)(& sCdestsys),
                                      zloc, (int )bCgrade, 1, abxtname, abdname, abxname);
        }
#line 856
        if ((unsigned long )zxqt == (unsigned long )((void *)0)) {
          {
#line 857
          ucabort();
          }
        }
        {
#line 858
        e = esysdep_fopen((char const   *)zxqt, 0, 0, 1);
        }
#line 859
        if ((unsigned long )e == (unsigned long )((void *)0)) {
          {
#line 860
          ucabort();
          }
        }
        {
#line 861
        ucrecord_file((char const   *)zxqt);
#line 863
        fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"U %s %s\n",
                zCuser, zloc);
#line 864
        fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"F %s %s\n",
                abdname, zbase);
#line 865
        fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)"C uucp -C");
        }
#line 866
        if (fCmkdirs) {
          {
#line 867
          fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" -d");
          }
        } else {
          {
#line 869
          fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" -f");
          }
        }
        {
#line 870
        fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" -g %c",
                (int )bCgrade);
        }
#line 871
        if (fCmail) {
          {
#line 872
          fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" -m");
          }
        }
#line 873
        if ((int const   )*zCnotify != 0) {
          {
#line 874
          fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" -n %s",
                  zCnotify);
          }
        }
#line 875
        if (! fCexpand) {
          {
#line 876
          fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" -W");
          }
        }
        {
#line 877
        fprintf((FILE */* __restrict  */)e, (char const   */* __restrict  */)" %s %s!%s\n",
                zbase, zCforward, zdest);
#line 879
        ubuffree(zbase);
#line 881
        tmp___11 = fsysdep_sync(e, (char const   *)zxqt);
        }
#line 881
        if (! tmp___11) {
          {
#line 882
          ulog((enum tlog )2, "fsync failed");
          }
        }
        {
#line 883
        tmp___14 = fclose(e);
        }
#line 883
        if (tmp___14 != 0) {
          {
#line 884
          tmp___12 = __errno_location();
#line 884
          tmp___13 = strerror(*tmp___12);
#line 884
          ulog((enum tlog )2, "fclose: %s", tmp___13);
          }
        }
        {
#line 887
        s.bcmd = (char )'S';
#line 888
        s.bgrade = bCgrade;
#line 889
        s.pseq = (void *)0;
#line 890
        tmp___15 = zbufcpy((char const   *)(abxtname));
#line 890
        s.zfrom = (char const   *)tmp___15;
#line 891
        tmp___16 = zbufcpy((char const   *)(abxname));
#line 891
        s.zto = (char const   *)tmp___16;
#line 892
        s.zuser = zCuser;
#line 893
        s.zoptions = "C";
#line 894
        s.ztemp = s.zfrom;
#line 895
        s.imode = 438U;
#line 896
        s.znotify = (char const   *)((void *)0);
#line 897
        s.cbytes = -1L;
#line 898
        s.zcmd = (char const   *)((void *)0);
#line 899
        s.ipos = 0L;
#line 901
        tmp___17 = strlen(zfile);
#line 901
        tmp___18 = strlen((char const   *)zCforward);
#line 901
        tmp___19 = strlen(zdest);
#line 901
        zlog = zbufalc(((sizeof("Queuing uucp  !") + tmp___17) + tmp___18) + tmp___19);
#line 903
        sprintf((char */* __restrict  */)zlog, (char const   */* __restrict  */)"Queuing uucp %s %s!%s",
                zfile, zCforward, zdest);
#line 906
        ucadd_cmd((struct uuconf_system  const  *)(& sCdestsys), (struct scmd  const  *)(& s),
                  (char const   *)zlog);
#line 909
        s.bcmd = (char )'S';
#line 910
        s.bgrade = bCgrade;
#line 911
        s.pseq = (void *)0;
#line 912
        tmp___20 = zbufcpy(zfile);
#line 912
        s.zfrom = (char const   *)tmp___20;
#line 913
        tmp___21 = zbufcpy((char const   *)(abdname));
#line 913
        s.zto = (char const   *)tmp___21;
#line 914
        s.zuser = zCuser;
        }
#line 915
        if (fCcopy) {
#line 915
          s.zoptions = "C";
        } else {
#line 915
          s.zoptions = "c";
        }
        {
#line 916
        tmp___22 = zbufcpy((char const   *)(abtname));
#line 916
        s.ztemp = (char const   *)tmp___22;
#line 917
        s.imode = 438U;
#line 918
        s.znotify = (char const   *)((void *)0);
#line 919
        s.cbytes = -1L;
#line 920
        s.zcmd = (char const   *)((void *)0);
#line 921
        s.ipos = 0L;
#line 923
        ucadd_cmd((struct uuconf_system  const  *)(& sCdestsys), (struct scmd  const  *)(& s),
                  "");
        }
      }
    }
  } else {
    {
#line 939
    zfrom = strrchr(zfile, '!');
    }
#line 940
    if ((unsigned long )zfrom == (unsigned long )zexclam) {
#line 941
      zforward = (char *)((void *)0);
    } else {
      {
#line 944
      clen = (size_t )((zfrom - zexclam) - 1L);
#line 945
      zforward = zbufalc(clen + 1UL);
#line 946
      memcpy((void */* __restrict  */)zforward, (void const   */* __restrict  */)(zexclam + 1),
             clen);
#line 947
      *(zforward + clen) = (char )'\000';
      }
    }
#line 950
    zfrom ++;
#line 951
    if (fCexpand) {
      {
#line 955
      zfrom = zsysdep_add_cwd((char const   *)zfrom);
      }
#line 956
      if ((unsigned long )zfrom == (unsigned long )((void *)0)) {
        {
#line 957
        ucabort();
        }
      }
    }
    {
#line 961
    clen = (size_t )(zexclam - (char *)zfile);
#line 962
    zcopy = zbufalc(clen + 1UL);
#line 963
    memcpy((void */* __restrict  */)zcopy, (void const   */* __restrict  */)zfile,
           clen);
#line 964
    *(zcopy + clen) = (char )'\000';
#line 966
    tmp___23 = xmalloc(sizeof(struct uuconf_system ));
#line 966
    qfromsys = (struct uuconf_system *)tmp___23;
#line 969
    iuuconf = uuconf_system_info(pCuuconf, (char const   *)zcopy, qfromsys);
    }
#line 970
    if (iuuconf == 1) {
      {
#line 972
      tmp___24 = funknown_system(pCuuconf, (char const   *)zcopy, qfromsys);
      }
#line 972
      if (! tmp___24) {
        {
#line 973
        ulog((enum tlog )2, "%s: System not found", zcopy);
        }
      }
    } else
#line 975
    if (iuuconf != 0) {
      {
#line 976
      ulog_uuconf((enum tlog )2, pCuuconf, iuuconf);
      }
    }
    {
#line 977
    ubuffree(zcopy);
#line 979
    zloc___0 = (char const   *)qfromsys->uuconf_zlocalname;
    }
#line 980
    if ((unsigned long )zloc___0 == (unsigned long )((void *)0)) {
#line 981
      zloc___0 = zClocalname;
    }
#line 983
    if ((unsigned long )zforward == (unsigned long )((void *)0)) {
#line 983
      if (fClocaldest) {
#line 993
        if (fCremote) {
          {
#line 994
          fok___0 = fin_directory_list(zdest, qfromsys->uuconf_pzremote_receive, qfromsys->uuconf_zpubdir,
                                       1, 0, (char const   *)((void *)0));
          }
        } else {
          {
#line 999
          fok___0 = fin_directory_list(zdest, qfromsys->uuconf_pzlocal_receive, qfromsys->uuconf_zpubdir,
                                       1, 0, zCuser);
          }
        }
#line 1003
        if (! fok___0) {
          {
#line 1004
          ulog((enum tlog )2, "Not permitted to receive to %s", zdest);
          }
        }
        {
#line 1010
        tmp___27 = strcspn((char const   *)zfrom, "*?[");
        }
#line 1010
        if ((int )*(zfrom + tmp___27) != 0) {
          {
#line 1012
          s.bcmd = (char )'X';
#line 1013
          tmp___25 = strlen(zloc___0);
#line 1013
          tmp___26 = strlen(zdest);
#line 1013
          zto = zbufalc((tmp___25 + tmp___26) + sizeof("!"));
#line 1014
          sprintf((char */* __restrict  */)zto, (char const   */* __restrict  */)"%s!%s",
                  zloc___0, zdest);
          }
        } else {
          {
#line 1018
          s.bcmd = (char )'R';
#line 1019
          zto = zbufcpy(zdest);
          }
        }
        {
#line 1022
        s.bgrade = bCgrade;
#line 1023
        s.pseq = (void *)0;
#line 1024
        s.zfrom = (char const   *)zfrom;
#line 1025
        s.zto = (char const   *)zto;
#line 1026
        s.zuser = zCuser;
#line 1027
        s.zoptions = (char const   *)(abCrec_options);
#line 1028
        s.ztemp = "";
#line 1029
        s.imode = 0U;
#line 1030
        s.znotify = "";
#line 1031
        s.cbytes = -1L;
#line 1032
        s.zcmd = (char const   *)((void *)0);
#line 1033
        s.ipos = 0L;
#line 1035
        ucadd_cmd((struct uuconf_system  const  *)qfromsys, (struct scmd  const  *)(& s),
                  (char const   *)((void *)0));
        }
      } else {
#line 983
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1049
      zxqt___0 = zsysdep_data_file_name((struct uuconf_system  const  *)qfromsys,
                                        zloc___0, (int )bCgrade, 1, abtname___0, (char *)((void *)0),
                                        abxname___0);
      }
#line 1052
      if ((unsigned long )zxqt___0 == (unsigned long )((void *)0)) {
        {
#line 1053
        ucabort();
        }
      }
      {
#line 1054
      e___0 = esysdep_fopen((char const   *)zxqt___0, 0, 0, 1);
      }
#line 1055
      if ((unsigned long )e___0 == (unsigned long )((void *)0)) {
        {
#line 1056
        ucabort();
        }
      }
      {
#line 1057
      ucrecord_file((char const   *)zxqt___0);
#line 1059
      fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)"U %s %s\n",
              zCuser, zloc___0);
#line 1060
      fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)"C uucp -C");
      }
#line 1061
      if (fCmkdirs) {
        {
#line 1062
        fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" -d");
        }
      } else {
        {
#line 1064
        fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" -f");
        }
      }
      {
#line 1065
      fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" -g %c",
              (int )bCgrade);
      }
#line 1066
      if (fCmail) {
        {
#line 1067
        fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" -m");
        }
      }
#line 1068
      if ((int const   )*zCnotify != 0) {
        {
#line 1069
        fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" -n %s",
                zCnotify);
        }
      }
#line 1070
      if (! fCexpand) {
        {
#line 1071
        fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" -W");
        }
      }
      {
#line 1073
      tmp___28 = strlen((char const   *)zfrom);
#line 1073
      tmp___29 = strlen(zloc___0);
#line 1073
      tmp___30 = strlen((char const   *)sCdestsys.uuconf_zname);
#line 1073
      tmp___31 = strlen(zdest);
#line 1073
      clen = ((tmp___28 + tmp___29) + tmp___30) + tmp___31;
      }
#line 1075
      if ((unsigned long )zforward != (unsigned long )((void *)0)) {
        {
#line 1076
        tmp___32 = strlen((char const   *)zforward);
#line 1076
        clen += tmp___32;
        }
      }
#line 1077
      if ((unsigned long )zCforward != (unsigned long )((void *)0)) {
        {
#line 1078
        tmp___33 = strlen((char const   *)zCforward);
#line 1078
        clen += tmp___33;
        }
      }
      {
#line 1079
      zcmd = zbufalc(sizeof("! !!!") + clen);
#line 1080
      *zcmd = (char )'\000';
      }
#line 1081
      if ((unsigned long )zforward != (unsigned long )((void *)0)) {
        {
#line 1082
        tmp___34 = strlen((char const   *)zcmd);
#line 1082
        sprintf((char */* __restrict  */)(zcmd + tmp___34), (char const   */* __restrict  */)"%s!",
                zforward);
        }
      }
      {
#line 1083
      tmp___35 = strlen((char const   *)zcmd);
#line 1083
      sprintf((char */* __restrict  */)(zcmd + tmp___35), (char const   */* __restrict  */)"%s %s!",
              zfrom, zloc___0);
      }
#line 1084
      if (! fClocaldest) {
        {
#line 1085
        tmp___36 = strlen((char const   *)zcmd);
#line 1085
        sprintf((char */* __restrict  */)(zcmd + tmp___36), (char const   */* __restrict  */)"%s!",
                sCdestsys.uuconf_zname);
        }
      }
#line 1086
      if ((unsigned long )zCforward != (unsigned long )((void *)0)) {
        {
#line 1087
        tmp___37 = strlen((char const   *)zcmd);
#line 1087
        sprintf((char */* __restrict  */)(zcmd + tmp___37), (char const   */* __restrict  */)"%s!",
                zCforward);
        }
      }
      {
#line 1088
      tmp___38 = strlen((char const   *)zcmd);
#line 1088
      sprintf((char */* __restrict  */)(zcmd + tmp___38), (char const   */* __restrict  */)"%s",
              zdest);
#line 1090
      fprintf((FILE */* __restrict  */)e___0, (char const   */* __restrict  */)" %s\n",
              zcmd);
#line 1092
      tmp___39 = fsysdep_sync(e___0, (char const   *)zxqt___0);
      }
#line 1092
      if (! tmp___39) {
        {
#line 1093
        ulog((enum tlog )2, "fsync failed");
        }
      }
      {
#line 1094
      tmp___42 = fclose(e___0);
      }
#line 1094
      if (tmp___42 != 0) {
        {
#line 1095
        tmp___40 = __errno_location();
#line 1095
        tmp___41 = strerror(*tmp___40);
#line 1095
        ulog((enum tlog )2, "fclose: %s", tmp___41);
        }
      }
      {
#line 1098
      s.bcmd = (char )'S';
#line 1099
      s.bgrade = bCgrade;
#line 1100
      s.pseq = (void *)0;
#line 1101
      tmp___43 = zbufcpy((char const   *)(abtname___0));
#line 1101
      s.zfrom = (char const   *)tmp___43;
#line 1102
      tmp___44 = zbufcpy((char const   *)(abxname___0));
#line 1102
      s.zto = (char const   *)tmp___44;
#line 1103
      s.zuser = zCuser;
#line 1104
      s.zoptions = "C";
#line 1105
      s.ztemp = s.zfrom;
#line 1106
      s.imode = 438U;
#line 1107
      s.znotify = (char const   *)((void *)0);
#line 1108
      s.cbytes = -1L;
#line 1109
      s.zcmd = (char const   *)((void *)0);
#line 1110
      s.ipos = 0L;
#line 1112
      tmp___45 = strlen((char const   *)zcmd);
#line 1112
      zlog___0 = zbufalc(sizeof("Queueing uucp ") + tmp___45);
#line 1113
      sprintf((char */* __restrict  */)zlog___0, (char const   */* __restrict  */)"Queueing uucp %s",
              zcmd);
#line 1115
      ucadd_cmd((struct uuconf_system  const  *)qfromsys, (struct scmd  const  *)(& s),
                (char const   *)zlog___0);
#line 1117
      ubuffree(zcmd);
#line 1118
      ubuffree(zforward);
      }
    }
  }
#line 1121
  return;
}
}
#line 1134 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static struct sjob *qCjobs  ;
#line 1136 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void ucadd_cmd(struct uuconf_system  const  *qsys , struct scmd  const  *qcmd ,
                      char const   *zlog ) 
{ 
  struct sjob *qjob ;
  int tmp ;
  pointer tmp___0 ;
  pointer tmp___1 ;
  pointer tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 1144
  if (! qsys->uuconf_fcall_transfer) {
#line 1144
    if (! qsys->uuconf_fcalled_transfer) {
      {
#line 1146
      ulog((enum tlog )2, "Not permitted to transfer files to or from %s", qsys->uuconf_zname);
      }
    }
  }
#line 1149
  qjob = qCjobs;
  {
#line 1149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1149
    if (! ((unsigned long )qjob != (unsigned long )((void *)0))) {
#line 1149
      goto while_break;
    }
    {
#line 1150
    tmp = strcmp((char const   *)(qjob->qsys)->uuconf_zname, (char const   *)qsys->uuconf_zname);
    }
#line 1150
    if (tmp == 0) {
#line 1151
      goto while_break;
    }
#line 1149
    qjob = qjob->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  if ((unsigned long )qjob == (unsigned long )((void *)0)) {
    {
#line 1155
    tmp___0 = xmalloc(sizeof(struct sjob ));
#line 1155
    qjob = (struct sjob *)tmp___0;
#line 1156
    qjob->qnext = qCjobs;
#line 1157
    qjob->qsys = qsys;
#line 1158
    qjob->ccmds = 0;
#line 1159
    qjob->pascmds = (struct scmd *)((void *)0);
#line 1160
    qjob->pazlogs = (char const   **)((void *)0);
#line 1161
    qCjobs = qjob;
    }
  }
  {
#line 1164
  tmp___1 = xrealloc((pointer )qjob->pascmds, (unsigned long )(qjob->ccmds + 1) * sizeof(struct scmd ));
#line 1164
  qjob->pascmds = (struct scmd *)tmp___1;
#line 1167
  *(qjob->pascmds + qjob->ccmds) = (struct scmd )*qcmd;
#line 1168
  tmp___2 = xrealloc((pointer )qjob->pazlogs, (unsigned long )(qjob->ccmds + 1) * sizeof(char const   *));
#line 1168
  qjob->pazlogs = (char const   **)tmp___2;
#line 1171
  *(qjob->pazlogs + qjob->ccmds) = zlog;
#line 1172
  (qjob->ccmds) ++;
  }
#line 1173
  return;
}
}
#line 1175 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void ucspool_cmds(boolean fjobid ) 
{ 
  struct sjob *qjob ;
  char *zjobid ;
  int i ;
  struct scmd *qcmd ;
  char const   **pz ;
  char const   *zto ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1182
  qjob = qCjobs;
  {
#line 1182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1182
    if (! ((unsigned long )qjob != (unsigned long )((void *)0))) {
#line 1182
      goto while_break;
    }
    {
#line 1184
    ulog_system((char const   *)(qjob->qsys)->uuconf_zname);
#line 1185
    zjobid = zsysdep_spool_commands(qjob->qsys, (int )bCgrade, qjob->ccmds, (struct scmd  const  *)qjob->pascmds,
                                    (boolean *)((void *)0));
    }
#line 1187
    if ((unsigned long )zjobid != (unsigned long )((void *)0)) {
#line 1193
      i = 0;
#line 1193
      qcmd = qjob->pascmds;
#line 1193
      pz = qjob->pazlogs;
      {
#line 1193
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1193
        if (! (i < qjob->ccmds)) {
#line 1193
          goto while_break___0;
        }
#line 1197
        if ((unsigned long )*pz != (unsigned long )((void *)0)) {
#line 1199
          if ((int const   )*(*pz) != 0) {
            {
#line 1200
            ulog((enum tlog )0, "%s", *pz);
            }
          }
        } else
#line 1202
        if ((int )qcmd->bcmd == 83) {
          {
#line 1203
          ulog((enum tlog )0, "Queuing send of %s to %s", qcmd->zfrom, qcmd->zto);
          }
        } else
#line 1205
        if ((int )qcmd->bcmd == 82) {
          {
#line 1206
          ulog((enum tlog )0, "Queuing request of %s to %s", qcmd->zfrom, qcmd->zto);
          }
        } else {
          {
#line 1212
          tmp = strrchr(qcmd->zto, '!');
#line 1212
          zto = (char const   *)tmp;
          }
#line 1213
          if ((unsigned long )zto != (unsigned long )((void *)0)) {
#line 1214
            zto ++;
          } else {
#line 1216
            zto = qcmd->zto;
          }
          {
#line 1217
          ulog((enum tlog )0, "Queuing request of %s to %s", qcmd->zfrom, zto);
          }
        }
#line 1193
        i ++;
#line 1193
        qcmd ++;
#line 1193
        pz ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1222
      if (fjobid) {
        {
#line 1223
        printf((char const   */* __restrict  */)"%s\n", zjobid);
        }
      }
      {
#line 1225
      ubuffree(zjobid);
      }
    }
#line 1182
    qjob = qjob->qnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 1228
  return;
}
}
#line 1234 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char const   *zcone_system(boolean *pfany ) 
{ 


  {
#line 1238
  if ((unsigned long )qCjobs == (unsigned long )((void *)0)) {
#line 1240
    *pfany = 0;
#line 1241
    return ((char const   *)((void *)0));
  }
#line 1244
  *pfany = 1;
#line 1246
  if ((unsigned long )qCjobs->qnext == (unsigned long )((void *)0)) {
#line 1247
    return ((char const   *)(qCjobs->qsys)->uuconf_zname);
  } else {
#line 1249
    return ((char const   *)((void *)0));
  }
}
}
#line 1255 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static int cCfiles  ;
#line 1256 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static char const   **pCaz  ;
#line 1258 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void ucrecord_file(char const   *zfile ) 
{ 
  pointer tmp ;

  {
  {
#line 1262
  tmp = xrealloc((pointer )pCaz, (unsigned long )(cCfiles + 1) * sizeof(char const   *));
#line 1262
  pCaz = (char const   **)tmp;
#line 1264
  *(pCaz + cCfiles) = zfile;
#line 1265
  cCfiles ++;
  }
#line 1266
  return;
}
}
#line 1270 "/home/wslee/gnu_benchmarks/uucp-1.07/uucp.c"
static void ucabort(void) 
{ 
  int i ;

  {
#line 1275
  i = 0;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! (i < cCfiles)) {
#line 1275
      goto while_break;
    }
    {
#line 1276
    remove(*(pCaz + i));
#line 1275
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1277
  ulog_close();
#line 1278
  usysdep_exit(0);
  }
#line 1279
  return;
}
}
