/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 56 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef unsigned long u4;
#line 58 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef unsigned long long u8;
#line 60 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
struct source {
   u8 size ;
   int size_known ;
   void *cache_head ;
   int sequential ;
   u8 seq_pos ;
   int blocksize ;
   struct source *foundation ;
   int (*analyze)(struct source *s , int level ) ;
   u8 (*read_bytes)(struct source *s , u8 pos , u8 len , void *buf ) ;
   int (*read_block)(struct source *s , u8 pos , void *buf ) ;
   void (*close)(struct source *s ) ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef struct source SOURCE;
#line 78 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
struct section {
   u8 pos ;
   u8 size ;
   int flags ;
   SOURCE *source ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef struct section SECTION;
#line 54 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef unsigned short u2;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
struct chunk {
   u8 start ;
   u8 end ;
   u8 len ;
   void *buf ;
   struct chunk *next ;
   struct chunk *prev ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
typedef struct chunk CHUNK;
#line 69 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
struct cache {
   CHUNK *hashtab[13] ;
   void *tempbuf ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
typedef struct cache CACHE;
#line 55 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef long s4;
#line 37 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
struct dostype {
   char *typecode ;
   int isfs ;
   char *name ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 52 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef unsigned char u1;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 51 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
struct file_source {
   SOURCE c ;
   int fd ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
typedef struct file_source FILE_SOURCE;
#line 37 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
struct systypes {
   unsigned char type ;
   char *name ;
};
#line 287 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
struct gpttypes {
   char *guid ;
   char *name ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
struct vhd_chunk {
   int present ;
   u8 off ;
   u1 bitmap[1] ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
typedef struct vhd_chunk VHD_CHUNK;
#line 40 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
struct vhd_source {
   SOURCE c ;
   u8 off ;
   u4 chunk_size ;
   u4 chunk_count ;
   u4 *raw_map ;
   VHD_CHUNK **chunks ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
typedef struct vhd_source VHD_SOURCE;
#line 84 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
typedef void (*DETECTOR)(SECTION *section , int level );
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
struct cdimage_source {
   SOURCE c ;
   u8 off ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
typedef struct cdimage_source CDIMAGE_SOURCE;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 50 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
struct compressed_source {
   SOURCE c ;
   u8 offset ;
   u8 write_pos ;
   u8 write_max ;
   int write_pipe ;
   int read_pipe ;
   int nfds ;
   pid_t pid ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
typedef struct compressed_source COMPRESSED_SOURCE;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 154 "/usr/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 162 "/usr/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 189 "/usr/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 219 "/usr/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
u8 get_buffer(SECTION *section , u8 pos , u8 len , void **buf ) ;
#line 109
void print_line(int level , char const   *fmt  , ...) ;
#line 116
void format_blocky_size(char *buf , u8 count , u4 blocksize , char const   *blockname ,
                        char const   *append ) ;
#line 132
u4 get_be_long(void *from ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/cloop.c"
void detect_cloop(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u4 blocksize ;
  u4 blockcount ;
  char s[256] ;
  char const   *sig_20 ;
  u8 tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  sig_20 = "#!/bin/sh\n#V2.0 Format\nmodprobe cloop";
#line 42
  tmp = get_buffer(section, (u8 )0, (u8 )256, (void **)(& buf));
  }
#line 42
  if (tmp < 256ULL) {
#line 43
    return;
  }
  {
#line 44
  tmp___0 = strlen(sig_20);
#line 44
  tmp___1 = memcmp((void const   *)buf, (void const   *)sig_20, tmp___0);
  }
#line 44
  if (tmp___1 != 0) {
#line 45
    return;
  }
  {
#line 47
  print_line(level, "Linux cloop 2.0 image");
#line 49
  blocksize = get_be_long((void *)(buf + 128));
#line 50
  blockcount = get_be_long((void *)(buf + 132));
#line 51
  format_blocky_size(s, (u8 )blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 52
  print_line(level + 1, "Volume size %s", s);
  }
#line 53
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void format_size(char *buf , u8 size ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/disktype-9/blank.c"
void detect_blank(SECTION *section , int level ) 
{ 
  unsigned char *buffer ;
  int i ;
  int j ;
  int block_size ;
  int max_blocks ;
  int blank_blocks ;
  unsigned char code ;
  char s[256] ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  {
#line 47
  block_size = 512;
#line 48
  max_blocks = 4096;
#line 49
  blank_blocks = 0;
#line 53
  tmp = get_buffer(section, (u8 )0, (u8 )1, (void **)(& buffer));
  }
#line 53
  if (tmp < 1ULL) {
#line 54
    return;
  }
#line 55
  code = *(buffer + 0);
#line 58
  if (section->size) {
#line 58
    if (section->size < (u8 )(max_blocks * block_size)) {
#line 59
      max_blocks = (int )(section->size / (u8 )block_size);
    }
  }
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < max_blocks)) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___0 = get_buffer(section, (u8 )(i * block_size), (u8 )block_size, (void **)(& buffer));
    }
#line 64
    if (tmp___0 < (u8 )block_size) {
#line 65
      goto while_break;
    }
#line 67
    j = 0;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 67
      if (! (j < block_size)) {
#line 67
        goto while_break___0;
      }
#line 68
      if ((int )*(buffer + j) != (int )code) {
#line 69
        goto while_break___0;
      }
#line 67
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 71
    if (j < block_size) {
#line 72
      goto while_break;
    }
#line 74
    blank_blocks = i + 1;
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (blank_blocks >= max_blocks) {
    {
#line 78
    print_line(level, "Blank disk/medium");
    }
  } else
#line 79
  if (blank_blocks > 128) {
    {
#line 80
    format_size(s, (u8 )(blank_blocks * block_size));
#line 81
    print_line(level, "First %s are blank", s);
    }
  }
#line 83
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void analyze_recursive(SECTION *section , int level , u8 rel_pos , u8 size , int flags ) ;
#line 121
void format_ascii(void *from , char *to ) ;
#line 122
void format_utf16_be(void *from , u4 len , char *to ) ;
#line 131
u2 get_be_short(void *from ) ;
#line 133
u8 get_be_quad(void *from ) ;
#line 147
void get_string(void *from , int len , char *to ) ;
#line 148
void get_pstring(void *from , char *to ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/apple.c"
void detect_apple_partmap(SECTION *section , int level ) 
{ 
  int i ;
  int magic ;
  int count ;
  char s[256] ;
  char append[64] ;
  unsigned char *buf ;
  u8 start ;
  u8 size ;
  u8 tmp ;
  u2 tmp___0 ;
  u4 tmp___1 ;
  u8 tmp___2 ;
  u2 tmp___3 ;
  u4 tmp___4 ;
  u4 tmp___5 ;

  {
  {
#line 53
  tmp = get_buffer(section, (u8 )512, (u8 )512, (void **)(& buf));
  }
#line 53
  if (tmp < 512ULL) {
#line 54
    return;
  }
  {
#line 56
  tmp___0 = get_be_short((void *)buf);
#line 56
  magic = (int )tmp___0;
  }
#line 57
  if (magic == 21587) {
    {
#line 58
    print_line(level, "Old-style Apple partition map");
    }
#line 59
    return;
  }
#line 61
  if (magic != 20557) {
#line 62
    return;
  }
  {
#line 65
  tmp___1 = get_be_long((void *)(buf + 4));
#line 65
  count = (int )tmp___1;
#line 66
  print_line(level, "Apple partition map, %d entries", count);
#line 68
  i = 1;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i <= count)) {
#line 68
      goto while_break;
    }
#line 72
    if (i > 1) {
      {
#line 72
      tmp___2 = get_buffer(section, (u8 )(i * 512), (u8 )512, (void **)(& buf));
      }
#line 72
      if (tmp___2 < 512ULL) {
#line 73
        return;
      }
    }
    {
#line 76
    tmp___3 = get_be_short((void *)buf);
    }
#line 76
    if ((int )tmp___3 != 20557) {
      {
#line 77
      print_line(level, "Partition %d: invalid signature, skipping", i);
      }
#line 78
      goto __Cont;
    }
    {
#line 82
    tmp___4 = get_be_long((void *)(buf + 8));
#line 82
    start = (u8 )tmp___4;
#line 83
    tmp___5 = get_be_long((void *)(buf + 12));
#line 83
    size = (u8 )tmp___5;
#line 84
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %llu",
            start);
#line 85
    format_blocky_size(s, size, (u4 )512, "sectors", (char const   *)(append));
#line 86
    print_line(level, "Partition %d: %s", i, s);
#line 90
    get_string((void *)(buf + 48), 32, s);
#line 91
    print_line(level + 1, "Type \"%s\"", s);
    }
#line 94
    if (start > (u8 )count) {
#line 94
      if (size > 0ULL) {
        {
#line 95
        analyze_recursive(section, level + 1, start * 512ULL, size * 512ULL, 0);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/disktype-9/apple.c"
void detect_apple_volume(SECTION *section , int level ) 
{ 
  char s[256] ;
  char t[514] ;
  unsigned char *buf ;
  u2 magic ;
  u2 version ;
  u2 volnamelen ;
  u4 blocksize ;
  u4 blockstart ;
  u8 blockcount ;
  u8 offset ;
  u8 catalogstart ;
  u8 cataloglength ;
  u4 firstleafnode ;
  u4 nodesize ;
  u8 tmp ;
  u2 tmp___0 ;
  u2 tmp___1 ;
  u2 tmp___2 ;
  u2 tmp___3 ;
  u4 tmp___4 ;
  u4 tmp___5 ;
  u4 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u2 tmp___9 ;
  u8 tmp___10 ;
  u2 tmp___11 ;
  u4 tmp___12 ;

  {
  {
#line 115
  tmp = get_buffer(section, (u8 )1024, (u8 )512, (void **)(& buf));
  }
#line 115
  if (tmp < 512ULL) {
#line 116
    return;
  }
  {
#line 118
  magic = get_be_short((void *)buf);
#line 119
  version = get_be_short((void *)(buf + 2));
  }
#line 121
  if ((int )magic == 53975) {
    {
#line 122
    print_line(level, "MFS file system");
    }
  } else
#line 124
  if ((int )magic == 16964) {
    {
#line 125
    print_line(level, "HFS file system");
#line 126
    tmp___0 = get_be_short((void *)(buf + 18));
#line 126
    blockcount = (u8 )tmp___0;
#line 127
    blocksize = get_be_long((void *)(buf + 20));
#line 128
    tmp___1 = get_be_short((void *)(buf + 28));
#line 128
    blockstart = (u4 )tmp___1;
#line 130
    get_pstring((void *)(buf + 36), s);
#line 131
    format_ascii((void *)(s), t);
#line 132
    print_line(level + 1, "Volume name \"%s\"", t);
#line 134
    format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 135
    print_line(level + 1, "Volume size %s", s);
#line 137
    tmp___3 = get_be_short((void *)(buf + 124));
    }
#line 137
    if ((int )tmp___3 == 18475) {
      {
#line 138
      print_line(level, "HFS wrapper for HFS Plus");
#line 140
      tmp___2 = get_be_short((void *)(buf + 126));
#line 140
      offset = (u8 )tmp___2 * (u8 )blocksize + (u8 )blockstart * 512ULL;
#line 144
      analyze_recursive(section, level + 1, offset, (u8 )0, 0);
      }
    }
  } else
#line 148
  if ((int )magic == 18475) {
    {
#line 149
    print_line(level, "HFS Plus file system");
#line 151
    blocksize = get_be_long((void *)(buf + 40));
#line 152
    tmp___4 = get_be_long((void *)(buf + 44));
#line 152
    blockcount = (u8 )tmp___4;
#line 154
    format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 155
    print_line(level + 1, "Volume size %s", s);
#line 166
    tmp___5 = get_be_long((void *)(buf + 288));
#line 166
    catalogstart = (u8 )(tmp___5 * blocksize);
#line 167
    tmp___6 = get_be_long((void *)(buf + 292));
#line 167
    cataloglength = (u8 )(tmp___6 * blocksize);
#line 169
    tmp___7 = get_be_quad((void *)(buf + 272));
    }
#line 169
    if (cataloglength > tmp___7) {
      {
#line 170
      cataloglength = get_be_quad((void *)(buf + 272));
      }
    }
    {
#line 173
    tmp___8 = get_buffer(section, catalogstart, (u8 )4096, (void **)(& buf));
    }
#line 173
    if (tmp___8 < 4096ULL) {
#line 174
      return;
    }
    {
#line 175
    firstleafnode = get_be_long((void *)(buf + 24));
#line 176
    tmp___9 = get_be_short((void *)(buf + 32));
#line 176
    nodesize = (u4 )tmp___9;
    }
#line 177
    if (nodesize < 4096UL) {
#line 178
      return;
    }
#line 181
    if ((u8 )((firstleafnode + 1UL) * nodesize) > cataloglength) {
#line 182
      return;
    }
    {
#line 183
    tmp___10 = get_buffer(section, catalogstart + (u8 )(firstleafnode * nodesize),
                          (u8 )nodesize, (void **)(& buf));
    }
#line 183
    if (tmp___10 < (u8 )nodesize) {
#line 185
      return;
    }
#line 188
    if ((int )*(buf + 8) != 255) {
#line 189
      return;
    }
    {
#line 190
    tmp___11 = get_be_short((void *)(buf + 14));
    }
#line 190
    if ((int )tmp___11 <= 6) {
#line 191
      return;
    }
    {
#line 192
    tmp___12 = get_be_long((void *)(buf + 16));
    }
#line 192
    if (tmp___12 != 1UL) {
#line 193
      return;
    }
    {
#line 194
    volnamelen = get_be_short((void *)(buf + 20));
#line 195
    format_utf16_be((void *)(buf + 22), (u4 )((int )volnamelen * 2), t);
#line 196
    print_line(level + 1, "Volume name \"%s\"", t);
    }
  }
#line 198
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/disktype-9/apple.c"
void detect_udif(SECTION *section , int level ) 
{ 
  u8 pos ;
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 209
  if (section->size < 1024ULL) {
#line 210
    return;
  } else
#line 209
  if ((section->source)->sequential) {
#line 210
    return;
  }
  {
#line 212
  pos = section->size - 512ULL;
#line 213
  tmp = get_buffer(section, pos, (u8 )512, (void **)(& buf));
  }
#line 213
  if (tmp < 512ULL) {
#line 214
    return;
  }
  {
#line 216
  tmp___0 = memcmp((void const   *)buf, (void const   *)"koly", (size_t )4);
  }
#line 216
  if (tmp___0 == 0) {
    {
#line 217
    print_line(level, "Apple UDIF disk image, content detection may or may not work...");
    }
  }
#line 219
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void analyze_source(SOURCE *s , int level ) ;
#line 97
SOURCE *init_file_source(int fd , int filekind ) ;
#line 105
void close_source(SOURCE *s ) ;
#line 119
void format_size_verbose(char *buf , u8 size ) ;
#line 160
void error(char const   *msg  , ...) ;
#line 161
void errore(char const   *msg  , ...) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/disktype-9/main.c"
static void analyze_file(char const   *filename ) ;
#line 39
static void print_kind(int filekind , u8 size , int size_known ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/disktype-9/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;

  {
#line 54
  if (argc < 2) {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s <device/file>...\n",
            "disktype");
    }
#line 56
    return (1);
  }
  {
#line 60
  print_line(0, "");
#line 61
  i = 1;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < argc)) {
#line 61
      goto while_break;
    }
    {
#line 62
    analyze_file((char const   *)*(argv + i));
#line 63
    print_line(0, "");
#line 61
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/disktype-9/main.c"
static void analyze_file(char const   *filename ) 
{ 
  int fd ;
  int filekind ;
  u8 filesize ;
  struct stat sb ;
  char *reason ;
  SOURCE *s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 81
  print_line(0, "--- %s", filename);
#line 84
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& sb));
  }
#line 84
  if (tmp < 0) {
    {
#line 85
    errore("Can\'t stat %.300s", filename);
    }
#line 86
    return;
  }
#line 89
  filekind = 0;
#line 90
  filesize = (u8 )0;
#line 91
  reason = (char *)((void *)0);
#line 92
  if ((sb.st_mode & 61440U) == 32768U) {
    {
#line 93
    filesize = (u8 )sb.st_size;
#line 94
    print_kind(filekind, filesize, 1);
    }
  } else
#line 95
  if ((sb.st_mode & 61440U) == 24576U) {
#line 96
    filekind = 1;
  } else
#line 97
  if ((sb.st_mode & 61440U) == 8192U) {
#line 98
    filekind = 2;
  } else
#line 99
  if ((sb.st_mode & 61440U) == 16384U) {
#line 100
    reason = (char *)"Is a directory";
  } else
#line 101
  if ((sb.st_mode & 61440U) == 4096U) {
#line 102
    reason = (char *)"Is a FIFO";
  } else
#line 104
  if ((sb.st_mode & 61440U) == 49152U) {
#line 105
    reason = (char *)"Is a socket";
  } else {
#line 108
    reason = (char *)"Is an unknown kind of special file";
  }
#line 110
  if ((unsigned long )reason != (unsigned long )((void *)0)) {
    {
#line 111
    error("%.300s: %s", filename, reason);
    }
#line 112
    return;
  }
#line 122
  if (filekind == 0) {
#line 122
    if (filesize == 0ULL) {
#line 123
      return;
    }
  }
  {
#line 126
  fd = open(filename, 0);
  }
#line 127
  if (fd < 0) {
    {
#line 128
    errore("Can\'t open %.300s", filename);
    }
#line 129
    return;
  }
#line 133
  if (filekind == 2) {
    {
#line 134
    tmp___0 = isatty(fd);
    }
#line 134
    if (tmp___0) {
      {
#line 135
      error("%.300s: Is a TTY device", filename);
      }
#line 136
      return;
    }
  }
  {
#line 141
  s = init_file_source(fd, filekind);
  }
#line 144
  if (filekind != 0) {
    {
#line 145
    print_kind(filekind, s->size, s->size_known);
    }
  }
  {
#line 148
  analyze_source(s, 0);
#line 151
  close_source(s);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/disktype-9/main.c"
static void print_kind(int filekind , u8 size , int size_known ) 
{ 
  char buf[256] ;
  char *kindname ;

  {
#line 158
  if (filekind == 0) {
#line 159
    kindname = (char *)"Regular file";
  } else
#line 160
  if (filekind == 1) {
#line 161
    kindname = (char *)"Block device";
  } else
#line 162
  if (filekind == 2) {
#line 163
    kindname = (char *)"Character device";
  } else {
#line 165
    kindname = (char *)"Unknown kind";
  }
#line 167
  if (size_known) {
    {
#line 168
    format_size_verbose(buf, size);
#line 169
    print_line(0, "%s, size %s", kindname, buf);
    }
  } else {
    {
#line 171
    print_line(0, "%s, unknown size", kindname);
    }
  }
#line 173
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
u8 get_buffer_real(SOURCE *s , u8 pos , u8 len , void *inbuf , void **outbuf ) ;
#line 162
void bailout(char const   *msg  , ...) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
static CHUNK *ensure_chunk(SOURCE *s , CACHE *cache , u8 start ) ;
#line 81
static CHUNK *get_chunk_alloc(CACHE *cache , u8 start ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
u8 get_buffer(SECTION *section , u8 pos , u8 len , void **buf ) 
{ 
  SOURCE *s ;
  u8 tmp ;

  {
  {
#line 92
  s = section->source;
#line 93
  pos += section->pos;
#line 95
  tmp = get_buffer_real(s, pos, len, (void *)0, buf);
  }
#line 95
  return (tmp);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
u8 get_buffer_real(SOURCE *s , u8 pos , u8 len , void *inbuf , void **outbuf ) 
{ 
  CACHE *cache ;
  CHUNK *c ;
  u8 end ;
  u8 first_chunk ;
  u8 last_chunk ;
  u8 curr_chunk ;
  u8 got ;
  u8 tocopy ;
  void *mybuf ;
  void *tmp ;

  {
#line 110
  if (len == 0ULL) {
#line 111
    return ((u8 )0);
  } else
#line 110
  if ((unsigned long )inbuf == (unsigned long )((void *)0)) {
#line 110
    if ((unsigned long )outbuf == (unsigned long )((void *)0)) {
#line 111
      return ((u8 )0);
    }
  }
#line 114
  if (s->size_known) {
#line 114
    if (pos >= s->size) {
#line 116
      return ((u8 )0);
    }
  }
#line 118
  end = pos + len;
#line 119
  if (s->size_known) {
#line 119
    if (end > s->size) {
#line 121
      end = s->size;
#line 122
      len = end - pos;
    }
  }
#line 126
  cache = (CACHE *)s->cache_head;
#line 127
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
    {
#line 129
    tmp = malloc(sizeof(CACHE ));
#line 129
    cache = (CACHE *)tmp;
    }
#line 130
    if ((unsigned long )cache == (unsigned long )((void *)0)) {
      {
#line 131
      bailout("Out of memory");
      }
    }
    {
#line 132
    memset((void *)cache, 0, sizeof(CACHE ));
#line 133
    s->cache_head = (void *)cache;
    }
  }
#line 136
  if ((unsigned long )cache->tempbuf != (unsigned long )((void *)0)) {
    {
#line 137
    free(cache->tempbuf);
#line 138
    cache->tempbuf = (void *)0;
    }
  }
#line 142
  first_chunk = pos & (unsigned long long )(~ ((1 << 12) - 1));
#line 143
  last_chunk = (end - 1ULL) & (unsigned long long )(~ ((1 << 12) - 1));
#line 145
  if (last_chunk == first_chunk) {
    {
#line 147
    c = ensure_chunk(s, cache, first_chunk);
    }
#line 150
    if (pos >= c->end) {
#line 151
      return ((u8 )0);
    }
#line 154
    if (len < c->end - pos) {
#line 154
      len = len;
    } else {
#line 154
      len = c->end - pos;
    }
#line 155
    mybuf = c->buf + (pos - c->start);
#line 156
    if (inbuf) {
      {
#line 157
      memcpy((void */* __restrict  */)inbuf, (void const   */* __restrict  */)mybuf,
             (size_t )len);
      }
    }
#line 158
    if (outbuf) {
#line 159
      *outbuf = mybuf;
    }
#line 161
    return (len);
  } else {
#line 166
    if (inbuf) {
#line 167
      mybuf = inbuf;
    } else {
      {
#line 175
      cache->tempbuf = malloc((size_t )len);
      }
#line 176
      if ((unsigned long )cache->tempbuf == (unsigned long )((void *)0)) {
        {
#line 177
        error("Out of memory, still going");
        }
#line 178
        return ((u8 )0);
      }
#line 180
      mybuf = cache->tempbuf;
    }
#line 184
    got = (u8 )0;
#line 185
    curr_chunk = first_chunk;
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      if (! (curr_chunk <= last_chunk)) {
#line 185
        goto while_break;
      }
      {
#line 188
      c = ensure_chunk(s, cache, curr_chunk);
      }
#line 191
      if (pos > curr_chunk) {
#line 201
        if (c->end > pos) {
          {
#line 202
          tocopy = c->end - pos;
#line 203
          memcpy((void */* __restrict  */)mybuf, (void const   */* __restrict  */)(c->buf + (pos & (unsigned long long )((1 << 12) - 1))),
                 (size_t )tocopy);
          }
        } else {
#line 205
          tocopy = (u8 )0;
        }
      } else {
#line 208
        if (c->len < len - got) {
#line 208
          tocopy = c->len;
        } else {
#line 208
          tocopy = len - got;
        }
#line 209
        if (tocopy) {
          {
#line 210
          memcpy((void */* __restrict  */)(mybuf + got), (void const   */* __restrict  */)c->buf,
                 (size_t )tocopy);
          }
        }
      }
#line 212
      got += tocopy;
#line 216
      if (c->len < (u8 )(1 << 12)) {
#line 217
        goto while_break;
      }
#line 185
      curr_chunk += (u8 )(1 << 12);
    }
    while_break: /* CIL Label */ ;
    }
#line 221
    if (len < got) {
#line 221
      len = len;
    } else {
#line 221
      len = got;
    }
#line 222
    if (outbuf) {
#line 223
      *outbuf = mybuf;
    }
#line 224
    return (len);
  }
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
static CHUNK *ensure_chunk(SOURCE *s , CACHE *cache , u8 start ) 
{ 
  CHUNK *c ;
  u8 pos ;
  u8 rel_start ;
  u8 rel_end ;
  u8 toread ;
  u8 result ;
  u8 curr_chunk ;
  int tmp ;

  {
  {
#line 235
  c = get_chunk_alloc(cache, start);
  }
#line 236
  if (c->len >= (u8 )(1 << 12)) {
#line 238
    return (c);
  } else
#line 236
  if (s->size_known) {
#line 236
    if (c->end >= s->size) {
#line 238
      return (c);
    }
  }
#line 241
  if (s->sequential) {
#line 244
    if (s->seq_pos < start) {
#line 246
      curr_chunk = s->seq_pos & (unsigned long long )(~ ((1 << 12) - 1));
      {
#line 247
      while (1) {
        while_continue: /* CIL Label */ ;
#line 247
        if (! (curr_chunk < start)) {
#line 247
          goto while_break;
        }
        {
#line 249
        ensure_chunk(s, cache, curr_chunk);
#line 250
        curr_chunk += (u8 )(1 << 12);
        }
#line 251
        if (s->seq_pos < curr_chunk) {
#line 252
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 256
      if (s->size_known) {
#line 256
        if (c->end >= s->size) {
#line 257
          return (c);
        }
      }
    }
#line 260
    if (s->seq_pos != c->end) {
#line 261
      return (c);
    }
  }
#line 265
  if ((unsigned long )s->read_block != (unsigned long )((void *)0)) {
#line 268
    if (s->blocksize < 256) {
      {
#line 271
      bailout("Internal error: Invalid block size %d", s->blocksize);
      }
    } else
#line 268
    if (s->blocksize > 1 << 12) {
      {
#line 271
      bailout("Internal error: Invalid block size %d", s->blocksize);
      }
    } else
#line 268
    if ((s->blocksize & (s->blocksize - 1)) != 0) {
      {
#line 271
      bailout("Internal error: Invalid block size %d", s->blocksize);
      }
    }
#line 274
    rel_start = (u8 )0;
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! (rel_start < (u8 )(1 << 12))) {
#line 274
        goto while_break___0;
      }
#line 275
      rel_end = rel_start + (u8 )s->blocksize;
#line 276
      if (c->len >= rel_end) {
#line 277
        goto __Cont;
      }
#line 278
      pos = c->start + rel_start;
#line 279
      if (s->size_known) {
#line 279
        if (pos >= s->size) {
#line 280
          goto while_break___0;
        }
      }
      {
#line 283
      tmp = (*(s->read_block))(s, pos, c->buf + rel_start);
      }
#line 283
      if (tmp) {
#line 285
        c->len = rel_end;
#line 286
        c->end = c->start + c->len;
      } else {
#line 289
        c->len = rel_start;
#line 290
        c->end = c->start + c->len;
#line 292
        if (! s->size_known) {
#line 293
          s->size_known = 1;
#line 294
          s->size = c->end;
        } else
#line 292
        if (s->size > c->end) {
#line 293
          s->size_known = 1;
#line 294
          s->size = c->end;
        }
#line 296
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 274
      rel_start = rel_end;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 303
    if (s->size_known) {
#line 303
      if (s->size < c->start + (u8 )(1 << 12)) {
#line 305
        toread = s->size - c->end;
      } else {
#line 308
        toread = (u8 )(1 << 12) - c->len;
      }
    } else {
#line 308
      toread = (u8 )(1 << 12) - c->len;
    }
    {
#line 310
    result = (*(s->read_bytes))(s, c->start + c->len, toread, c->buf + c->len);
    }
#line 312
    if (result > 0ULL) {
#line 314
      c->len += result;
#line 315
      c->end = c->start + c->len;
#line 316
      if (s->sequential) {
#line 317
        s->seq_pos += result;
      }
    }
#line 319
    if (result < toread) {
#line 322
      if (! s->size_known) {
#line 323
        s->size_known = 1;
#line 324
        s->size = c->end;
      } else
#line 322
      if (s->size > c->end) {
#line 323
        s->size_known = 1;
#line 324
        s->size = c->end;
      }
    }
  }
#line 329
  return (c);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
static CHUNK *get_chunk_alloc(CACHE *cache , u8 start ) 
{ 
  int hpos ;
  CHUNK *chain ;
  CHUNK *trav ;
  CHUNK *c ;
  void *tmp ;
  struct chunk *tmp___0 ;
  void *tmp___1 ;

  {
#line 338
  hpos = (int )((start >> 12) % 13ULL);
#line 339
  chain = cache->hashtab[hpos];
#line 341
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 343
    tmp = malloc(sizeof(CHUNK ));
#line 343
    c = (CHUNK *)tmp;
    }
#line 344
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 345
      bailout("Out of memory");
      }
    }
    {
#line 346
    c->buf = malloc((size_t )(1 << 12));
    }
#line 347
    if ((unsigned long )c->buf == (unsigned long )((void *)0)) {
      {
#line 348
      bailout("Out of memory");
      }
    }
#line 349
    c->start = start;
#line 350
    c->end = start;
#line 351
    c->len = (u8 )0;
#line 353
    tmp___0 = c;
#line 353
    c->next = tmp___0;
#line 353
    c->prev = tmp___0;
#line 354
    cache->hashtab[hpos] = c;
#line 355
    return (c);
  }
#line 359
  trav = chain;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (trav->start == start) {
#line 362
      return (trav);
    }
#line 363
    trav = trav->next;
#line 360
    if (! ((unsigned long )trav != (unsigned long )chain)) {
#line 360
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 367
  tmp___1 = malloc(sizeof(CHUNK ));
#line 367
  c = (CHUNK *)tmp___1;
  }
#line 368
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 369
    bailout("Out of memory");
    }
  }
  {
#line 370
  c->buf = malloc((size_t )(1 << 12));
  }
#line 371
  if ((unsigned long )c->buf == (unsigned long )((void *)0)) {
    {
#line 372
    bailout("Out of memory");
    }
  }
#line 373
  c->start = start;
#line 374
  c->end = start;
#line 375
  c->len = (u8 )0;
#line 377
  c->prev = chain->prev;
#line 378
  c->next = chain;
#line 379
  (c->prev)->next = c;
#line 380
  (c->next)->prev = c;
#line 381
  cache->hashtab[hpos] = c;
#line 382
  return (c);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/disktype-9/buffer.c"
void close_source(SOURCE *s ) 
{ 
  CACHE *cache ;
  int hpos ;
  CHUNK *chain ;
  CHUNK *trav ;
  CHUNK *nexttrav ;

  {
#line 396
  cache = (CACHE *)s->cache_head;
#line 397
  if ((unsigned long )cache != (unsigned long )((void *)0)) {
#line 401
    if ((unsigned long )cache->tempbuf != (unsigned long )((void *)0)) {
      {
#line 402
      free(cache->tempbuf);
      }
    }
#line 403
    hpos = 0;
    {
#line 403
    while (1) {
      while_continue: /* CIL Label */ ;
#line 403
      if (! (hpos < 13)) {
#line 403
        goto while_break;
      }
#line 407
      chain = cache->hashtab[hpos];
#line 408
      if ((unsigned long )chain != (unsigned long )((void *)0)) {
#line 409
        trav = chain;
        {
#line 410
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 416
          nexttrav = trav->next;
#line 417
          free(trav->buf);
#line 418
          free((void *)trav);
#line 419
          trav = nexttrav;
          }
#line 410
          if (! ((unsigned long )trav != (unsigned long )chain)) {
#line 410
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 403
      hpos ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 433
  if ((unsigned long )s->close != (unsigned long )((void *)0)) {
    {
#line 434
    (*(s->close))(s);
    }
  }
  {
#line 437
  free((void *)s);
  }
#line 438
  return;
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/atari.c"
static char *get_name_for_type(char *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 36
  tmp___1 = memcmp((void const   *)type, (void const   *)"GEM", (size_t )3);
  }
#line 36
  if (tmp___1 == 0) {
#line 37
    return ((char *)"Standard GEMDOS");
  } else {
    {
#line 38
    tmp___0 = memcmp((void const   *)type, (void const   *)"BGM", (size_t )3);
    }
#line 38
    if (tmp___0 == 0) {
#line 39
      return ((char *)"Big GEMDOS");
    } else {
      {
#line 40
      tmp = memcmp((void const   *)type, (void const   *)"XGM", (size_t )3);
      }
#line 40
      if (tmp == 0) {
#line 41
        return ((char *)"Extended");
      }
    }
  }
#line 42
  return ((char *)"Unknown");
}
}
#line 45
static void detect_atari_partmap_ext(SECTION *section , u8 extbase , int level ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/disktype-9/atari.c"
void detect_atari_partmap(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int off ;
  int used ;
  int flag ;
  int flags[4] ;
  u4 start ;
  u4 size ;
  u4 starts[4] ;
  u4 sizes[4] ;
  char types[4][4] ;
  char *type ;
  u2 atari_csum ;
  char s[256] ;
  char append[64] ;
  u8 tmp ;
  u2 tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 57
  if (section->pos != 0ULL) {
#line 58
    return;
  }
  {
#line 60
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 60
  if (tmp < 512ULL) {
#line 61
    return;
  }
#line 64
  atari_csum = (u2 )0;
#line 65
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < 512)) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp___0 = get_be_short((void *)(buf + i));
#line 66
    atari_csum = (u2 )((int )atari_csum + (int )tmp___0);
#line 65
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  if ((int )atari_csum != 4660) {
#line 68
    return;
  }
#line 71
  used = 0;
#line 72
  off = 454;
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! (i < 4)) {
#line 72
      goto while_break___0;
    }
    {
#line 73
    flags[i] = (int )*(buf + off);
#line 74
    get_string((void *)((buf + off) + 1), 3, types[i]);
#line 75
    starts[i] = get_be_long((void *)((buf + off) + 4));
#line 76
    sizes[i] = get_be_long((void *)((buf + off) + 8));
    }
#line 77
    if (flags[i] & 1) {
#line 77
      if (starts[i] != 0UL) {
#line 77
        if (sizes[i] != 0UL) {
#line 78
          used = 1;
        }
      }
    }
#line 72
    i ++;
#line 72
    off += 12;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 80
  if (! used) {
#line 81
    return;
  }
  {
#line 84
  print_line(level, "ATARI ST partition map");
#line 85
  i = 0;
  }
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! (i < 4)) {
#line 85
      goto while_break___1;
    }
#line 86
    start = starts[i];
#line 87
    size = sizes[i];
#line 88
    flag = flags[i];
#line 89
    type = types[i];
#line 90
    if ((flag & 1) == 0) {
#line 91
      goto __Cont;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %lu",
            start);
    }
#line 94
    if (flag & 128) {
      {
#line 95
      strcat((char */* __restrict  */)(append), (char const   */* __restrict  */)", bootable");
      }
    }
    {
#line 96
    format_blocky_size(s, (u8 )size, (u4 )512, "sectors", (char const   *)(append));
#line 97
    print_line(level, "Partition %d: %s", i + 1, s);
#line 100
    tmp___1 = get_name_for_type(type);
#line 100
    print_line(level + 1, "Type \"%s\" (%s)", type, tmp___1);
#line 103
    tmp___2 = memcmp((void const   *)type, (void const   *)"XGM", (size_t )3);
    }
#line 103
    if (tmp___2 == 0) {
      {
#line 105
      detect_atari_partmap_ext(section, (u8 )start, level + 1);
      }
    } else {
      {
#line 108
      analyze_recursive(section, level + 1, (u8 )start * 512ULL, (u8 )size * 512ULL,
                        0);
      }
    }
    __Cont: /* CIL Label */ 
#line 85
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/disktype-9/atari.c"
static void detect_atari_partmap_ext(SECTION *section , u8 extbase , int level ) 
{ 
  unsigned char *buf ;
  int extpartnum ;
  u8 tablebase ;
  u8 nexttablebase ;
  int i ;
  int off ;
  int flags[4] ;
  u4 start ;
  u4 size ;
  u4 starts[4] ;
  u4 sizes[4] ;
  char types[4][4] ;
  char *type ;
  char s[256] ;
  char append[64] ;
  u8 tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 117
  extpartnum = 5;
#line 124
  tablebase = extbase;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! tablebase) {
#line 124
      goto while_break;
    }
    {
#line 126
    tmp = get_buffer(section, tablebase << 9, (u8 )512, (void **)(& buf));
    }
#line 126
    if (tmp < 512ULL) {
#line 127
      return;
    }
#line 130
    off = 454;
#line 130
    i = 0;
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 130
      if (! (i < 4)) {
#line 130
        goto while_break___0;
      }
      {
#line 131
      flags[i] = (int )*(buf + off);
#line 132
      get_string((void *)((buf + off) + 1), 3, types[i]);
#line 133
      starts[i] = get_be_long((void *)((buf + off) + 4));
#line 134
      sizes[i] = get_be_long((void *)((buf + off) + 8));
#line 130
      i ++;
#line 130
      off += 12;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    nexttablebase = (u8 )0;
#line 139
    i = 0;
    {
#line 139
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 139
      if (! (i < 4)) {
#line 139
        goto while_break___1;
      }
#line 140
      start = starts[i];
#line 141
      size = sizes[i];
#line 142
      type = types[i];
#line 143
      if ((flags[i] & 1) == 0) {
#line 144
        goto __Cont;
      }
      {
#line 146
      tmp___1 = memcmp((void const   *)type, (void const   *)"XGM", (size_t )3);
      }
#line 146
      if (tmp___1 == 0) {
#line 149
        nexttablebase = extbase + (u8 )start;
      } else {
        {
#line 154
        sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %lu",
                start);
#line 155
        format_blocky_size(s, (u8 )size, (u4 )512, "sectors", (char const   *)(append));
#line 156
        print_line(level, "Partition %d: %s", extpartnum, s);
#line 158
        extpartnum ++;
#line 160
        tmp___0 = get_name_for_type(type);
#line 160
        print_line(level + 1, "Type \"%s\" (%s)", type, tmp___0);
#line 164
        analyze_recursive(section, level + 1, (tablebase + (u8 )start) * 512ULL, (u8 )size * 512ULL,
                          0);
        }
      }
      __Cont: /* CIL Label */ 
#line 139
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 124
    tablebase = nexttablebase;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void stop_detect(void) ;
#line 125
void format_uuid(void *uuid , char *to ) ;
#line 135
u2 get_le_short(void *from ) ;
#line 136
u4 get_le_long(void *from ) ;
#line 137
u8 get_le_quad(void *from ) ;
#line 139
u2 get_ve_short(int endianness , void *from ) ;
#line 140
u4 get_ve_long(int endianness , void *from ) ;
#line 143
char const   *get_ve_name(int endianness ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_jfs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int version ;
  char s[256] ;
  u4 blocksize ;
  u8 blockcount ;
  u8 tmp ;
  int tmp___0 ;
  u4 tmp___1 ;

  {
  {
#line 42
  tmp = get_buffer(section, (u8 )32768, (u8 )512, (void **)(& buf));
  }
#line 42
  if (tmp < 512ULL) {
#line 43
    return;
  }
  {
#line 46
  tmp___0 = memcmp((void const   *)buf, (void const   *)"JFS1", (size_t )4);
  }
#line 46
  if (tmp___0 != 0) {
#line 47
    return;
  }
  {
#line 50
  tmp___1 = get_le_long((void *)(buf + 4));
#line 50
  version = (int )tmp___1;
#line 51
  print_line(level, "JFS file system, version %d", version);
#line 53
  get_string((void *)(buf + 101), 11, s);
#line 54
  print_line(level + 1, "Volume name \"%s\"", s);
#line 56
  blocksize = get_le_long((void *)(buf + 24));
#line 57
  blockcount = get_le_quad((void *)(buf + 8));
#line 58
  format_blocky_size(s, blockcount, blocksize, "h/w blocks", (char const   *)((void *)0));
#line 59
  print_line(level + 1, "Volume size %s", s);
  }
#line 60
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_xfs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u4 raw_version ;
  u4 blocksize ;
  u8 blockcount ;
  int version ;
  char s[256] ;
  u8 tmp ;
  u4 tmp___0 ;
  u2 tmp___1 ;

  {
  {
#line 74
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 74
  if (tmp < 512ULL) {
#line 75
    return;
  }
  {
#line 78
  tmp___0 = get_be_long((void *)buf);
  }
#line 78
  if (tmp___0 != 1481003842UL) {
#line 79
    return;
  }
  {
#line 82
  tmp___1 = get_be_short((void *)(buf + 100));
#line 82
  raw_version = (u4 )tmp___1;
#line 83
  version = (int )(raw_version & 15UL);
#line 84
  print_line(level, "XFS file system, version %d", version);
#line 86
  get_string((void *)(buf + 108), 12, s);
#line 87
  print_line(level + 1, "Volume name \"%s\"", s);
#line 89
  format_uuid((void *)(buf + 32), s);
#line 90
  print_line(level + 1, "UUID %s", s);
#line 92
  blocksize = get_be_long((void *)(buf + 4));
#line 93
  blockcount = get_be_quad((void *)(buf + 8));
#line 94
  format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 95
  print_line(level + 1, "Volume size %s", s);
  }
#line 96
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_ufs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int at ;
  int en ;
  int namelen ;
  int offsets[5] ;
  u4 magic ;
  char s[256] ;
  u8 tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  u2 tmp___5 ;
  u4 tmp___6 ;
  u4 tmp___7 ;
  u4 tmp___8 ;
  u8 tmp___9 ;

  {
#line 105
  offsets[0] = 0;
#line 105
  offsets[1] = 8;
#line 105
  offsets[2] = 64;
#line 105
  offsets[3] = 256;
#line 105
  offsets[4] = -1;
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (offsets[i] >= 0)) {
#line 114
      goto while_break;
    }
    {
#line 115
    at = offsets[i];
#line 116
    tmp = get_buffer(section, (u8 )(at * 1024), (u8 )1536, (void **)(& buf));
    }
#line 116
    if (tmp < 1536ULL) {
#line 117
      goto while_break;
    }
#line 119
    en = 0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (! (en < 2)) {
#line 119
        goto while_break___0;
      }
      {
#line 120
      magic = get_ve_long(en, (void *)(buf + 1372));
      }
#line 122
      if (magic == 72020UL) {
        {
#line 123
        tmp___0 = get_ve_name(en);
#line 123
        print_line(level, "UFS file system, %d KiB offset, %s", at, tmp___0);
        }
      } else
#line 125
      if (magic == 610324UL) {
        {
#line 126
        tmp___1 = get_ve_name(en);
#line 126
        print_line(level, "UFS file system, %d KiB offset, long file names, %s", at,
                   tmp___1);
        }
      } else
#line 128
      if (magic == 1660434UL) {
        {
#line 129
        tmp___2 = get_ve_name(en);
#line 129
        print_line(level, "UFS file system, %d KiB offset, fs_featurebits, %s", at,
                   tmp___2);
        }
      } else
#line 131
      if (magic == 86186388UL) {
        {
#line 132
        tmp___3 = get_ve_name(en);
#line 132
        print_line(level, "UFS file system, %d KiB offset, fs_featurebits, >4GB support, %s",
                   at, tmp___3);
        }
      } else
#line 134
      if (magic == 424935705UL) {
        {
#line 135
        tmp___4 = get_ve_name(en);
#line 135
        print_line(level, "UFS2 file system, %d KiB offset, %s", at, tmp___4);
        }
      } else {
#line 138
        goto __Cont;
      }
      {
#line 141
      get_string((void *)(buf + 680), 32, s);
      }
#line 142
      if (s[0]) {
        {
#line 143
        print_line(level + 1, "Volume name \"%s\" (in superblock)", s);
        }
      }
      {
#line 146
      get_string((void *)(buf + 212), 255, s);
      }
#line 147
      if (s[0]) {
        {
#line 148
        print_line(level + 1, "Last mounted at \"%s\"", s);
        }
      }
      {
#line 151
      tmp___9 = get_buffer(section, (u8 )7168, (u8 )1024, (void **)(& buf));
      }
#line 151
      if (tmp___9 == 1024ULL) {
        {
#line 152
        tmp___7 = get_ve_long(en, (void *)buf);
        }
#line 152
        if (tmp___7 == 1279345228UL) {
          {
#line 152
          tmp___8 = get_ve_long(en, (void *)(buf + 8));
          }
#line 152
          if (tmp___8 == 1UL) {
            {
#line 154
            tmp___5 = get_ve_short(en, (void *)(buf + 16));
#line 154
            namelen = (int )tmp___5;
#line 155
            get_string((void *)(buf + 18), namelen, s);
#line 156
            tmp___6 = get_ve_long(en, (void *)(buf + 8));
#line 156
            print_line(level + 1, "Volume name \"%s\" (in label v%lu)", s, tmp___6);
            }
          }
        }
      }
#line 161
      return;
      __Cont: /* CIL Label */ 
#line 119
      en ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_sysv(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int at ;
  int en ;
  int offsets[5] ;
  unsigned int tmp ;
  s4 blocksize_code ;
  char s[256] ;
  u8 tmp___0 ;
  u4 tmp___1 ;
  char const   *tmp___2 ;
  u4 tmp___3 ;
  u4 tmp___4 ;
  char const   *tmp___5 ;
  u4 tmp___6 ;

  {
#line 173
  offsets[0] = 512;
#line 173
  offsets[1] = 1024;
#line 173
  offsets[2] = -1;
#line 173
  tmp = 3U;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (tmp >= 5U) {
#line 173
      goto while_break;
    }
#line 173
    offsets[tmp] = 0;
#line 173
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! (offsets[i] >= 0)) {
#line 177
      goto while_break___0;
    }
    {
#line 178
    at = offsets[i];
#line 179
    tmp___0 = get_buffer(section, (u8 )at, (u8 )1024, (void **)(& buf));
    }
#line 179
    if (tmp___0 < 1024ULL) {
#line 180
      goto while_break___0;
    }
#line 182
    en = 0;
    {
#line 182
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 182
      if (! (en < 2)) {
#line 182
        goto while_break___1;
      }
      {
#line 183
      tmp___3 = get_ve_long(en, (void *)(buf + 1016));
      }
#line 183
      if (tmp___3 == 2839876UL) {
        {
#line 184
        tmp___1 = get_ve_long(en, (void *)(buf + 1020));
#line 184
        blocksize_code = (s4 )tmp___1;
#line 185
        s[0] = (char)0;
        }
#line 186
        if (blocksize_code == 1L) {
          {
#line 187
          strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"512 byte blocks");
          }
        } else
#line 188
        if (blocksize_code == 2L) {
          {
#line 189
          strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"1 KiB blocks");
          }
        } else
#line 190
        if (blocksize_code == 3L) {
          {
#line 191
          strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"2 KiB blocks");
          }
        } else {
          {
#line 193
          snprintf((char */* __restrict  */)(s), (size_t )255, (char const   */* __restrict  */)"unknown block size code %d",
                   (int )blocksize_code);
          }
        }
        {
#line 195
        tmp___2 = get_ve_name(en);
#line 195
        print_line(level, "XENIX file system (SysV variant), %s, %s", tmp___2, s);
        }
#line 197
        return;
      }
      {
#line 200
      tmp___6 = get_ve_long(en, (void *)(buf + 504));
      }
#line 200
      if (tmp___6 == 4246240800UL) {
        {
#line 201
        tmp___4 = get_ve_long(en, (void *)(buf + 508));
#line 201
        blocksize_code = (s4 )tmp___4;
#line 202
        s[0] = (char)0;
        }
#line 203
        if (blocksize_code == 1L) {
          {
#line 204
          strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"512 byte blocks");
          }
        } else
#line 205
        if (blocksize_code == 2L) {
          {
#line 206
          strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"1 KiB blocks");
          }
        } else {
          {
#line 208
          snprintf((char */* __restrict  */)(s), (size_t )255, (char const   */* __restrict  */)"unknown block size code %d",
                   (int )blocksize_code);
          }
        }
        {
#line 210
        tmp___5 = get_ve_name(en);
#line 210
        print_line(level, "SysV file system, %s, %s", tmp___5, s);
        }
#line 212
        return;
      }
#line 182
      en ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
static char *bsdtype_names[17]  = 
#line 222
  {      (char *)"Unused",      (char *)"swap",      (char *)"Sixth Edition",      (char *)"Seventh Edition", 
        (char *)"System V",      (char *)"V7 with 1 KiB blocks",      (char *)"Eighth Edition, 4 KiB blocks",      (char *)"4.2BSD fast file system", 
        (char *)"ext2 or MS-DOS",      (char *)"4.4BSD log-structured file system",      (char *)"\"Other\"",      (char *)"HPFS", 
        (char *)"ISO9660",      (char *)"bootstrap",      (char *)"AmigaDOS fast file system",      (char *)"Macintosh HFS", 
        (char *)"Digital Unix AdvFS"};
#line 242 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
static char *get_name_for_bsdtype(int type ) 
{ 


  {
#line 244
  if (type >= 0) {
#line 244
    if (type <= 16) {
#line 245
      return (bsdtype_names[type]);
    }
  }
#line 246
  return ((char *)"Unknown");
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_bsd_disklabel(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int off ;
  int partcount ;
  int types[16] ;
  int min_offset_valid ;
  int did_recurse ;
  u4 starts[16] ;
  u4 sizes[16] ;
  u4 sectsize ;
  u4 nsectors ;
  u4 ntracks ;
  u4 ncylinders ;
  u4 secpercyl ;
  u4 secperunit ;
  u8 offset ;
  u8 min_offset ;
  u8 base_offset ;
  char s[256] ;
  char append[64] ;
  char pn ;
  u8 tmp ;
  u4 tmp___0 ;
  u4 tmp___1 ;
  u2 tmp___2 ;
  char *tmp___3 ;

  {
#line 258
  if (section->flags & 1) {
#line 259
    return;
  }
  {
#line 261
  tmp = get_buffer(section, (u8 )512, (u8 )512, (void **)(& buf));
  }
#line 261
  if (tmp < 512ULL) {
#line 262
    return;
  }
  {
#line 264
  tmp___0 = get_le_long((void *)buf);
  }
#line 264
  if (tmp___0 != 2186691927UL) {
#line 266
    return;
  } else {
    {
#line 264
    tmp___1 = get_le_long((void *)(buf + 132));
    }
#line 264
    if (tmp___1 != 2186691927UL) {
#line 266
      return;
    }
  }
  {
#line 268
  sectsize = get_le_long((void *)(buf + 40));
#line 269
  nsectors = get_le_long((void *)(buf + 44));
#line 270
  ntracks = get_le_long((void *)(buf + 48));
#line 271
  ncylinders = get_le_long((void *)(buf + 52));
#line 272
  secpercyl = get_le_long((void *)(buf + 56));
#line 273
  secperunit = get_le_long((void *)(buf + 60));
#line 275
  tmp___2 = get_le_short((void *)(buf + 138));
#line 275
  partcount = (int )tmp___2;
  }
#line 277
  if (partcount <= 8) {
    {
#line 278
    print_line(level, "BSD disklabel (at sector 1), %d partitions", partcount);
    }
  } else
#line 279
  if (partcount > 8) {
#line 279
    if (partcount <= 16) {
      {
#line 280
      print_line(level, "BSD disklabel (at sector 1), %d partitions (more than usual, but valid)",
                 partcount);
      }
    } else {
#line 279
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 282
  if (partcount > 16) {
    {
#line 283
    print_line(level, "BSD disklabel (at sector 1), %d partitions (broken, limiting to 16)",
               partcount);
#line 285
    partcount = 16;
    }
  }
#line 287
  if (sectsize != 512UL) {
    {
#line 288
    print_line(level + 1, "Unusual sector size %d bytes, your mileage may vary");
    }
  }
#line 291
  min_offset = (u8 )0;
#line 292
  min_offset_valid = 0;
#line 293
  i = 0;
#line 293
  off = 148;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < partcount)) {
#line 293
      goto while_break;
    }
    {
#line 294
    starts[i] = get_le_long((void *)((buf + off) + 4));
#line 295
    sizes[i] = get_le_long((void *)(buf + off));
#line 296
    types[i] = (int )*(buf + (off + 12));
    }
#line 298
    if (types[i] != 0) {
#line 298
      goto _L___0;
    } else
#line 298
    if (i == 2) {
      _L___0: /* CIL Label */ 
#line 299
      offset = (u8 )starts[i] * 512ULL;
#line 300
      if (! min_offset_valid) {
#line 301
        min_offset = offset;
#line 302
        min_offset_valid = 1;
      } else
#line 300
      if (offset < min_offset) {
#line 301
        min_offset = offset;
#line 302
        min_offset_valid = 1;
      }
    }
#line 293
    i ++;
#line 293
    off += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (section->pos == min_offset) {
#line 310
    base_offset = section->pos;
  } else
#line 311
  if (section->pos == 0ULL) {
    {
#line 313
    print_line(level + 1, "Adjusting offsets for disklabel in a DOS partition at sector %llu",
               min_offset >> 9);
#line 314
    base_offset = min_offset;
    }
  } else
#line 315
  if (min_offset == 0ULL) {
#line 317
    base_offset = (u8 )0;
  } else {
    {
#line 319
    print_line(level + 1, "Warning: Unable to adjust offsets, your mileage may vary");
#line 320
    base_offset = section->pos;
    }
  }
#line 324
  did_recurse = 0;
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (i < partcount)) {
#line 325
      goto while_break___0;
    }
#line 326
    pn = (char )(97 + i);
#line 327
    if (types[i] == 0) {
#line 327
      if (i != 2) {
#line 328
        goto __Cont;
      }
    }
    {
#line 330
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %lu",
            starts[i]);
#line 331
    format_blocky_size(s, (u8 )sizes[i], (u4 )512, "sectors", (char const   *)(append));
#line 332
    print_line(level, "Partition %c: %s", (int )pn, s);
#line 335
    tmp___3 = get_name_for_bsdtype(types[i]);
#line 335
    print_line(level + 1, "Type %d (%s)", types[i], tmp___3);
    }
#line 338
    if (types[i] == 0) {
#line 339
      goto __Cont;
    } else
#line 338
    if (sizes[i] == 0UL) {
#line 339
      goto __Cont;
    }
#line 341
    offset = (u8 )starts[i] * 512ULL;
#line 342
    if (offset < base_offset) {
      {
#line 343
      print_line(level + 1, "(Illegal start offset, no detection)");
      }
    } else
#line 344
    if (offset == base_offset) {
      {
#line 345
      print_line(level + 1, "Includes the disklabel and boot code");
#line 348
      analyze_recursive(section, level + 1, offset - base_offset, (u8 )sizes[i] * 512ULL,
                        1);
#line 351
      did_recurse = 1;
      }
    } else {
      {
#line 354
      analyze_recursive(section, level + 1, offset - base_offset, (u8 )sizes[i] * 512ULL,
                        0);
      }
    }
    __Cont: /* CIL Label */ 
#line 325
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 360
  if (did_recurse) {
    {
#line 361
    stop_detect();
    }
  }
#line 363
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_bsd_loader(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u4 tmp ;
  u4 tmp___0 ;
  u2 tmp___1 ;
  u2 tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;

  {
#line 373
  if (section->flags & 1) {
#line 374
    return;
  }
  {
#line 376
  tmp___3 = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 376
  if (tmp___3 == 512ULL) {
    {
#line 377
    tmp___2 = get_le_short((void *)(buf + 432));
    }
#line 377
    if ((int )tmp___2 == 47974) {
      {
#line 378
      print_line(level, "FreeBSD boot manager (i386 boot0 at sector 0)");
      }
    } else {
      {
#line 379
      tmp = get_le_long((void *)(buf + 502));
      }
#line 379
      if (tmp == 0UL) {
        {
#line 379
        tmp___0 = get_le_long((void *)(buf + 506));
        }
#line 379
        if (tmp___0 == 50000UL) {
          {
#line 379
          tmp___1 = get_le_short((void *)(buf + 510));
          }
#line 379
          if ((int )tmp___1 == 43605) {
            {
#line 382
            print_line(level, "FreeBSD boot loader (i386 boot1 at sector 0)");
            }
          }
        }
      }
    }
  }
  {
#line 386
  tmp___5 = get_buffer(section, (u8 )1024, (u8 )512, (void **)(& buf));
  }
#line 386
  if (tmp___5 == 512ULL) {
    {
#line 387
    tmp___4 = memcmp((void const   *)(buf + 2), (void const   *)"BTX", (size_t )3);
    }
#line 387
    if (tmp___4 == 0) {
      {
#line 388
      print_line(level, "FreeBSD boot loader (i386 boot2/BTX %d.%02d at sector 2)",
                 (int )*(buf + 5), (int )*(buf + 6));
      }
    }
  }
#line 392
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_solaris_disklabel(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int off1 ;
  int off2 ;
  int types[8] ;
  int did_recurse ;
  u4 sizes[8] ;
  u8 starts[8] ;
  u8 cylsize ;
  u8 offset ;
  char s[256] ;
  char append[256] ;
  char pn ;
  u8 tmp ;
  u2 tmp___0 ;
  u2 tmp___1 ;
  u2 tmp___2 ;
  u2 tmp___3 ;
  u4 tmp___4 ;

  {
#line 406
  if (section->flags & 1) {
#line 407
    return;
  }
  {
#line 409
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 409
  if (tmp < 512ULL) {
#line 410
    return;
  }
  {
#line 412
  tmp___0 = get_be_short((void *)(buf + 508));
  }
#line 412
  if ((int )tmp___0 != 55998) {
#line 413
    return;
  }
  {
#line 415
  print_line(level, "Solaris SPARC disklabel");
#line 417
  tmp___1 = get_be_short((void *)(buf + 436));
#line 417
  tmp___2 = get_be_short((void *)(buf + 438));
#line 417
  cylsize = (u8 )tmp___1 * (u8 )tmp___2;
#line 418
  i = 0;
#line 418
  off1 = 142;
#line 418
  off2 = 444;
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (i < 8)) {
#line 418
      goto while_break;
    }
    {
#line 419
    tmp___3 = get_be_short((void *)(buf + off1));
#line 419
    types[i] = (int )tmp___3;
#line 420
    tmp___4 = get_be_long((void *)(buf + off2));
#line 420
    starts[i] = (u8 )tmp___4 * cylsize;
#line 421
    sizes[i] = get_be_long((void *)((buf + off2) + 4));
#line 418
    i ++;
#line 418
    off1 += 4;
#line 418
    off2 += 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  did_recurse = 0;
#line 426
  i = 0;
  {
#line 426
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 426
    if (! (i < 8)) {
#line 426
      goto while_break___0;
    }
#line 427
    pn = (char )(48 + i);
#line 428
    if (sizes[i] == 0UL) {
#line 429
      goto __Cont;
    }
    {
#line 431
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %llu",
            starts[i]);
#line 432
    format_blocky_size(s, (u8 )sizes[i], (u4 )512, "sectors", (char const   *)(append));
#line 433
    print_line(level, "Partition %c: %s", (int )pn, s);
#line 435
    print_line(level + 1, "Type %d", types[i]);
#line 438
    offset = starts[i] * 512ULL;
    }
#line 439
    if (offset == 0ULL) {
      {
#line 440
      print_line(level + 1, "Includes the disklabel");
#line 443
      analyze_recursive(section, level + 1, offset, (u8 )sizes[i] * 512ULL, 1);
#line 446
      did_recurse = 1;
      }
    } else {
      {
#line 449
      analyze_recursive(section, level + 1, offset, (u8 )sizes[i] * 512ULL, 0);
      }
    }
    __Cont: /* CIL Label */ 
#line 426
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 455
  if (did_recurse) {
    {
#line 456
    stop_detect();
    }
  }
#line 459
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
static char *vtoctype_names[11]  = 
#line 465
  {      (char *)"Unused",      (char *)"Boot",      (char *)"Root",      (char *)"Swap", 
        (char *)"Usr",      (char *)"Overlap",      (char *)"Stand",      (char *)"Var", 
        (char *)"Home",      (char *)"Alternate sector",      (char *)"Cache"};
#line 479 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
static char *get_name_for_vtoctype(int type ) 
{ 


  {
#line 481
  if (type >= 0) {
#line 481
    if (type <= 10) {
#line 482
      return (vtoctype_names[type]);
    }
  }
#line 483
  return ((char *)"Unknown");
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_solaris_vtoc(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int off ;
  int partcount ;
  int sectorsize ;
  int types[16] ;
  int did_recurse ;
  u4 starts[16] ;
  u4 sizes[16] ;
  u4 version ;
  u8 offset ;
  char s[256] ;
  char append[64] ;
  u8 tmp ;
  u4 tmp___0 ;
  u2 tmp___1 ;
  u2 tmp___2 ;
  u2 tmp___3 ;
  char *tmp___4 ;

  {
#line 495
  if (section->flags & 1) {
#line 496
    return;
  }
  {
#line 498
  tmp = get_buffer(section, (u8 )512, (u8 )512, (void **)(& buf));
  }
#line 498
  if (tmp < 512ULL) {
#line 499
    return;
  }
  {
#line 501
  tmp___0 = get_le_long((void *)(buf + 12));
  }
#line 501
  if (tmp___0 != 1611521774UL) {
#line 502
    return;
  }
  {
#line 503
  version = get_le_long((void *)(buf + 16));
  }
#line 504
  if (version != 1UL) {
    {
#line 505
    print_line(level, "Solaris x86 disklabel, unknown version %lu", version);
    }
#line 506
    return;
  }
  {
#line 508
  tmp___1 = get_le_short((void *)(buf + 30));
#line 508
  partcount = (int )tmp___1;
  }
#line 509
  if (partcount > 16) {
    {
#line 510
    print_line(level, "Solaris x86 disklabel, version 1, %d partitions (limiting to 16)",
               partcount);
#line 512
    partcount = 16;
    }
  } else {
    {
#line 514
    print_line(level, "Solaris x86 disklabel, version 1, %d partitions", partcount);
    }
  }
  {
#line 518
  tmp___2 = get_le_short((void *)(buf + 28));
#line 518
  sectorsize = (int )tmp___2;
  }
#line 519
  if (sectorsize != 512) {
    {
#line 520
    print_line(level + 1, "Unusual sector size %d bytes, your mileage may vary", sectorsize);
    }
  }
  {
#line 523
  get_string((void *)(buf + 20), 8, s);
  }
#line 524
  if (s[0]) {
    {
#line 525
    print_line(level + 1, "Volume name \"%s\"", s);
    }
  }
#line 527
  i = 0;
#line 527
  off = 72;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! (i < partcount)) {
#line 527
      goto while_break;
    }
    {
#line 528
    tmp___3 = get_le_short((void *)(buf + off));
#line 528
    types[i] = (int )tmp___3;
#line 529
    starts[i] = get_le_long((void *)((buf + off) + 4));
#line 530
    sizes[i] = get_le_long((void *)((buf + off) + 8));
#line 527
    i ++;
#line 527
    off += 12;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  did_recurse = 0;
#line 535
  i = 0;
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 535
    if (! (i < partcount)) {
#line 535
      goto while_break___0;
    }
#line 536
    if (sizes[i] == 0UL) {
#line 537
      goto __Cont;
    }
    {
#line 539
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %lu",
            starts[i]);
#line 540
    format_blocky_size(s, (u8 )sizes[i], (u4 )512, "sectors", (char const   *)(append));
#line 541
    print_line(level, "Partition %d: %s", i, s);
#line 544
    tmp___4 = get_name_for_vtoctype(types[i]);
#line 544
    print_line(level + 1, "Type %d (%s)", types[i], tmp___4);
#line 547
    offset = (u8 )starts[i] * 512ULL;
    }
#line 548
    if (offset == 0ULL) {
      {
#line 549
      print_line(level + 1, "Includes the disklabel");
#line 552
      analyze_recursive(section, level + 1, offset, (u8 )sizes[i] * 512ULL, 1);
#line 555
      did_recurse = 1;
      }
    } else {
      {
#line 558
      analyze_recursive(section, level + 1, offset, (u8 )sizes[i] * 512ULL, 0);
      }
    }
    __Cont: /* CIL Label */ 
#line 535
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  if (did_recurse) {
    {
#line 565
    stop_detect();
    }
  }
#line 567
  return;
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_qnx(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u8 tmp ;
  u4 tmp___0 ;

  {
  {
#line 577
  tmp = get_buffer(section, (u8 )512, (u8 )512, (void **)(& buf));
  }
#line 577
  if (tmp < 512ULL) {
#line 578
    return;
  }
  {
#line 581
  tmp___0 = get_le_long((void *)buf);
  }
#line 581
  if (tmp___0 != 47UL) {
#line 582
    return;
  }
  {
#line 588
  print_line(level, "QNX4 file system");
  }
#line 589
  return;
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/disktype-9/unix.c"
void detect_vxfs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int en ;
  int version ;
  u4 blocksize ;
  u4 blockcount ;
  char s[256] ;
  u8 tmp ;
  u4 tmp___0 ;
  char const   *tmp___1 ;
  u4 tmp___2 ;

  {
  {
#line 602
  tmp = get_buffer(section, (u8 )1024, (u8 )1024, (void **)(& buf));
  }
#line 602
  if (tmp < 1024ULL) {
#line 603
    return;
  }
#line 606
  en = 0;
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    if (! (en < 2)) {
#line 606
      goto while_break;
    }
    {
#line 607
    tmp___2 = get_ve_long(en, (void *)buf);
    }
#line 607
    if (tmp___2 == 2768370933UL) {
      {
#line 608
      tmp___0 = get_ve_long(en, (void *)(buf + 4));
#line 608
      version = (int )tmp___0;
#line 609
      tmp___1 = get_ve_name(en);
#line 609
      print_line(level, "Veritas VxFS file system, version %d, %s", version, tmp___1);
#line 612
      blocksize = get_ve_long(en, (void *)(buf + 32));
#line 613
      blockcount = get_ve_long(en, (void *)(buf + 36));
#line 614
      format_blocky_size(s, (u8 )blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 615
      print_line(level + 1, "Volume size %s", s);
      }
    }
#line 606
    en ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return;
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
struct dostype amiga_dostypes[50]  = 
#line 44 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
  {      {(char *)"DOS\000", 1, (char *)"Amiga OFS file system (non-intl.)"}, 
        {(char *)"DOS\001", 1, (char *)"Amiga FFS file system (non-intl.)"}, 
        {(char *)"DOS\002", 1, (char *)"Amiga OFS file system (intl., no dir cache)"}, 
        {(char *)"DOS\003",
      1, (char *)"Amiga FFS file system (intl., no dir cache)"}, 
        {(char *)"DOS\004", 1, (char *)"Amiga OFS file system (intl., dir cache)"}, 
        {(char *)"DOS\005", 1, (char *)"Amiga FFS file system (intl., dir cache)"}, 
        {(char *)"DOS\006", 1, (char *)"Amiga OFS file system (LNFS)"}, 
        {(char *)"DOS\a", 1, (char *)"Amiga FFS file system (LNFS)"}, 
        {(char *)"muFS", 1, (char *)"Amiga muFS FFS file system (intl., no dir cache)"}, 
        {(char *)"muF\000",
      1, (char *)"Amiga muFS OFS file system (non-intl.)"}, 
        {(char *)"muF\001", 1, (char *)"Amiga muFS FFS file system (non-intl.)"}, 
        {(char *)"muF\002", 1, (char *)"Amiga muFS OFS file system (intl., no dir cache)"}, 
        {(char *)"muF\003",
      1, (char *)"Amiga muFS FFS file system (intl., no dir cache)"}, 
        {(char *)"muF\004", 1, (char *)"Amiga muFS OFS file system (intl., dir cache)"}, 
        {(char *)"muF\005",
      1, (char *)"Amiga muFS FFS file system (intl., dir cache)"}, 
        {(char *)"SFS\000", 1, (char *)"Amiga Smart File System"}, 
        {(char *)"PFS\000", 1, (char *)"Amiga PFS file system 0"}, 
        {(char *)"PFS\001", 1, (char *)"Amiga PFS file system 1"}, 
        {(char *)"PFS\002", 1, (char *)"Amiga PFS file system 2"}, 
        {(char *)"PFS\003", 1, (char *)"Amiga PFS file system 3"}, 
        {(char *)"PDS\002", 1, (char *)"Amiga PFS file system 2, SCSIdirect"}, 
        {(char *)"PDS\003", 1, (char *)"Amiga PFS file system 3, SCSIdirect"}, 
        {(char *)"muPF", 1, (char *)"Amiga PFS file system, multiuser"}, 
        {(char *)"AFS\000", 1, (char *)"Amiga AFS file system"}, 
        {(char *)"AFS\001", 1, (char *)"Amiga AFS file system (experimental)"}, 
        {(char *)"UNI\000", 0, (char *)"Amiga Amix 0"}, 
        {(char *)"UNI\001", 0, (char *)"Amiga Amix 1"}, 
        {(char *)"KICK", 1, (char *)"Amiga Kickstart disk"}, 
        {(char *)"BOOU", 1, (char *)"Amiga generic boot disk"}, 
        {(char *)"BAD\000", 0, (char *)"Unreadable disk"}, 
        {(char *)"NDOS", 0, (char *)"Not a DOS disk"}, 
        {(char *)"resv", 0, (char *)"reserved"}, 
        {(char *)"CD00", 0, (char *)"CD-ROM High Sierra format"}, 
        {(char *)"CD01", 0, (char *)"CD-ROM ISO9660 format"}, 
        {(char *)"CDDA", 0, (char *)"CD Audio"}, 
        {(char *)"CDFS", 0, (char *)"CD-ROM - Amiga CDrive or AmiCDFS"}, 
        {(char *)"f-\253\254", 0, (char *)"CD-ROM - AsimCDFS"}, 
        {(char *)"NBR\a", 0, (char *)"NetBSD root"}, 
        {(char *)"NBS\001", 0, (char *)"NetBSD swap"}, 
        {(char *)"NBU\a", 0, (char *)"NetBSD other"}, 
        {(char *)"LNX\000", 0, (char *)"Linux native"}, 
        {(char *)"EXT2", 0, (char *)"Linux ext2"}, 
        {(char *)"SWAP", 0, (char *)"Linux swap"}, 
        {(char *)"SWP\000", 0, (char *)"Linux swap"}, 
        {(char *)"MNX\000", 0, (char *)"Linux minix"}, 
        {(char *)"MAC\000", 0, (char *)"Macintosh HFS"}, 
        {(char *)"MSD\000", 0, (char *)"MS-DOS disk"}, 
        {(char *)"MSH\000", 0, (char *)"MS-DOS PC-Task hardfile"}, 
        {(char *)"BFFS", 0, (char *)"Berkeley Fast Filesystem"}, 
        {(char *)((void *)0), 0, (char *)((void *)0)}};
#line 109 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
static char *get_name_for_dostype(unsigned char const   *dostype ) 
{ 
  int i ;
  int tmp ;

  {
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! amiga_dostypes[i].name) {
#line 113
      goto while_break;
    }
    {
#line 114
    tmp = memcmp((void const   *)dostype, (void const   *)amiga_dostypes[i].typecode,
                 (size_t )4);
    }
#line 114
    if (tmp == 0) {
#line 115
      return (amiga_dostypes[i].name);
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return ((char *)"Unknown");
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
static void format_dostype(char *buf , unsigned char const   *dostype ) 
{ 
  int i ;
  unsigned char c ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 125
  p = buf;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < 4)) {
#line 126
      goto while_break;
    }
#line 127
    c = (unsigned char )*(dostype + i);
#line 128
    if ((int )c < 10) {
#line 129
      tmp = p;
#line 129
      p ++;
#line 129
      *tmp = (char )'\\';
#line 130
      tmp___0 = p;
#line 130
      p ++;
#line 130
      *tmp___0 = (char )(48 + (int )c);
    } else
#line 131
    if ((int )c < 32) {
      {
#line 132
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"0x%02x",
              (int )c);
#line 133
      p = strchr((char const   *)p, 0);
      }
    } else {
#line 135
      tmp___1 = p;
#line 135
      p ++;
#line 135
      *tmp___1 = (char )c;
    }
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  *p = (char)0;
#line 139
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
void detect_amiga_partmap(SECTION *section , int level ) 
{ 
  int i ;
  int off ;
  int found ;
  unsigned char *buf ;
  char s[256] ;
  char append[64] ;
  u4 blocksize ;
  u4 part_ptr ;
  u8 cylsize ;
  u8 start ;
  u8 size ;
  u8 tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  int tmp___2 ;
  u4 tmp___3 ;
  u4 tmp___4 ;
  u4 tmp___5 ;
  u4 tmp___6 ;
  u4 tmp___7 ;
  char *tmp___8 ;

  {
#line 153
  off = 0;
#line 153
  found = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (off < 16)) {
#line 153
      goto while_break;
    }
    {
#line 154
    tmp = get_buffer(section, (u8 )(off * 512), (u8 )512, (void **)(& buf));
    }
#line 154
    if (tmp < 512ULL) {
#line 155
      goto while_break;
    }
    {
#line 157
    tmp___0 = memcmp((void const   *)buf, (void const   *)"RDSK", (size_t )4);
    }
#line 157
    if (tmp___0 == 0) {
#line 158
      found = 1;
#line 159
      goto while_break;
    }
#line 153
    off ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if (! found) {
#line 163
    return;
  }
#line 165
  if (off == 0) {
    {
#line 166
    print_line(level, "Amiga Rigid Disk partition map");
    }
  } else {
    {
#line 168
    print_line(level, "Amiga Rigid Disk partition map at sector %d", off);
    }
  }
  {
#line 171
  blocksize = get_be_long((void *)(buf + 16));
  }
#line 172
  if (blocksize < 256UL) {
    {
#line 173
    print_line(level + 1, "Illegal block size %lu", blocksize);
    }
#line 174
    return;
  } else
#line 172
  if (blocksize & (blocksize - 1UL)) {
    {
#line 173
    print_line(level + 1, "Illegal block size %lu", blocksize);
    }
#line 174
    return;
  } else
#line 175
  if (blocksize != 512UL) {
    {
#line 176
    print_line(level + 1, "Unusual block size %lu, not sure this will work...", blocksize);
    }
  }
  {
#line 181
  part_ptr = get_be_long((void *)(buf + 28));
#line 182
  i = 1;
  }
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (part_ptr != 4294967295UL)) {
#line 182
      goto while_break___0;
    }
    {
#line 183
    tmp___1 = get_buffer(section, (u8 )part_ptr * 512ULL, (u8 )256, (void **)(& buf));
    }
#line 183
    if (tmp___1 < 256ULL) {
      {
#line 185
      print_line(level, "Partition %d: Can\'t read partition info block");
      }
#line 186
      goto while_break___0;
    }
    {
#line 190
    tmp___2 = memcmp((void const   *)buf, (void const   *)"PART", (size_t )4);
    }
#line 190
    if (tmp___2 != 0) {
      {
#line 191
      print_line(level, "Partition %d: Invalid signature");
      }
#line 192
      goto while_break___0;
    }
    {
#line 196
    part_ptr = get_be_long((void *)(buf + 16));
#line 199
    tmp___3 = get_be_long((void *)(buf + 140));
#line 199
    tmp___4 = get_be_long((void *)(buf + 148));
#line 199
    cylsize = (u8 )tmp___3 * (u8 )tmp___4;
#line 200
    tmp___5 = get_be_long((void *)(buf + 164));
#line 200
    start = (u8 )tmp___5 * cylsize;
#line 201
    tmp___6 = get_be_long((void *)(buf + 168));
#line 201
    tmp___7 = get_be_long((void *)(buf + 164));
#line 201
    size = (u8 )((tmp___6 + 1UL) - tmp___7) * cylsize;
#line 203
    snprintf((char */* __restrict  */)(append), (size_t )63, (char const   */* __restrict  */)" from %llu",
             start);
#line 204
    format_blocky_size(s, size, (u4 )512, "sectors", (char const   *)(append));
#line 205
    print_line(level, "Partition %d: %s", i, s);
#line 209
    get_pstring((void *)(buf + 36), s);
    }
#line 210
    if (s[0]) {
      {
#line 211
      print_line(level + 1, "Drive name \"%s\"", s);
      }
    }
    {
#line 214
    format_dostype(s, (unsigned char const   *)(buf + 192));
#line 215
    tmp___8 = get_name_for_dostype((unsigned char const   *)(buf + 192));
#line 215
    print_line(level + 1, "Type \"%s\" (%s)", s, tmp___8);
    }
#line 219
    if (size > 0ULL) {
#line 219
      if (start > 0ULL) {
        {
#line 220
        analyze_recursive(section, level + 1, start * 512ULL, size * 512ULL, 0);
        }
      }
    }
#line 182
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/disktype-9/amiga.c"
void detect_amiga_fs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int isfs ;
  char s[256] ;
  char *typename ;
  u8 tmp ;
  int tmp___0 ;

  {
  {
#line 236
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 236
  if (tmp < 512ULL) {
#line 237
    return;
  }
#line 240
  isfs = 0;
#line 241
  typename = (char *)((void *)0);
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! amiga_dostypes[i].name) {
#line 242
      goto while_break;
    }
    {
#line 243
    tmp___0 = memcmp((void const   *)buf, (void const   *)amiga_dostypes[i].typecode,
                     (size_t )4);
    }
#line 243
    if (tmp___0 == 0) {
#line 244
      isfs = amiga_dostypes[i].isfs;
#line 245
      typename = amiga_dostypes[i].name;
#line 246
      goto while_break;
    }
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if ((unsigned long )typename == (unsigned long )((void *)0)) {
#line 249
    return;
  }
#line 251
  if (isfs) {
    {
#line 253
    print_line(level, "%s", typename);
#line 255
    format_dostype(s, (unsigned char const   *)buf);
#line 256
    print_line(level + 1, "Type \"%s\"", s);
    }
#line 258
    if (section->size == 901120ULL) {
      {
#line 259
      print_line(level + 1, "Size matches DD floppy");
      }
    } else
#line 260
    if (section->size == 1802240ULL) {
      {
#line 261
      print_line(level + 1, "Size matches HD floppy");
      }
    }
  } else {
    {
#line 266
    format_dostype(s, (unsigned char const   *)buf);
#line 267
    print_line(level, "Amiga type code \"%s\" (%s)", s, typename);
    }
  }
#line 270
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void format_utf16_le(void *from , u4 len , char *to ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/disktype-9/udf.c"
static int probe_udf(SECTION *section , int level , int sector_size ) ;
#line 39
static int validate_tag(unsigned char *buf , u4 sector ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/disktype-9/udf.c"
void detect_udf(SECTION *section , int level ) 
{ 
  unsigned char *buffer ;
  unsigned char sig_bea[7] ;
  unsigned char sig_nsr2[7] ;
  unsigned char sig_nsr3[7] ;
  unsigned char sig_tea[7] ;
  int recog_state ;
  int sector ;
  int detected ;
  int probe_result ;
  int sizes[5] ;
  int i ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 44
  sig_bea[0] = (unsigned char)0;
#line 44
  sig_bea[1] = (unsigned char)66;
#line 44
  sig_bea[2] = (unsigned char)69;
#line 44
  sig_bea[3] = (unsigned char)65;
#line 44
  sig_bea[4] = (unsigned char)48;
#line 44
  sig_bea[5] = (unsigned char)49;
#line 44
  sig_bea[6] = (unsigned char)1;
#line 46
  sig_nsr2[0] = (unsigned char)0;
#line 46
  sig_nsr2[1] = (unsigned char)78;
#line 46
  sig_nsr2[2] = (unsigned char)83;
#line 46
  sig_nsr2[3] = (unsigned char)82;
#line 46
  sig_nsr2[4] = (unsigned char)48;
#line 46
  sig_nsr2[5] = (unsigned char)50;
#line 46
  sig_nsr2[6] = (unsigned char)1;
#line 48
  sig_nsr3[0] = (unsigned char)0;
#line 48
  sig_nsr3[1] = (unsigned char)78;
#line 48
  sig_nsr3[2] = (unsigned char)83;
#line 48
  sig_nsr3[3] = (unsigned char)82;
#line 48
  sig_nsr3[4] = (unsigned char)48;
#line 48
  sig_nsr3[5] = (unsigned char)51;
#line 48
  sig_nsr3[6] = (unsigned char)1;
#line 50
  sig_tea[0] = (unsigned char)0;
#line 50
  sig_tea[1] = (unsigned char)84;
#line 50
  sig_tea[2] = (unsigned char)69;
#line 50
  sig_tea[3] = (unsigned char)65;
#line 50
  sig_tea[4] = (unsigned char)48;
#line 50
  sig_tea[5] = (unsigned char)49;
#line 50
  sig_tea[6] = (unsigned char)1;
#line 54
  detected = 0;
#line 56
  sizes[0] = 2048;
#line 56
  sizes[1] = 512;
#line 56
  sizes[2] = 1024;
#line 56
  sizes[3] = 4096;
#line 56
  sizes[4] = -1;
#line 61
  recog_state = 0;
#line 62
  sector = 16;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (sector < 64)) {
#line 62
      goto while_break;
    }
    {
#line 63
    tmp = get_buffer(section, (u8 )(sector * 2048), (u8 )2048, (void **)(& buffer));
    }
#line 63
    if (tmp < 2048ULL) {
#line 64
      return;
    }
#line 66
    if ((int )*(buffer + 2) == (int )*(buffer + 1)) {
#line 66
      if ((int )*(buffer + 3) == (int )*(buffer + 1)) {
#line 66
        if ((int )*(buffer + 4) == (int )*(buffer + 1)) {
#line 66
          if ((int )*(buffer + 5) == (int )*(buffer + 1)) {
#line 70
            goto while_break;
          }
        }
      }
    }
#line 71
    if (recog_state == 0) {
      {
#line 71
      tmp___0 = memcmp((void const   *)buffer, (void const   *)(sig_bea), (size_t )7);
      }
#line 71
      if (tmp___0 == 0) {
#line 72
        recog_state = 1;
      }
    }
#line 73
    if (recog_state == 1) {
      {
#line 73
      tmp___1 = memcmp((void const   *)buffer, (void const   *)(sig_tea), (size_t )7);
      }
#line 73
      if (tmp___1 == 0) {
#line 74
        recog_state = 0;
      }
    }
#line 75
    if (recog_state == 1) {
      {
#line 75
      tmp___2 = memcmp((void const   *)buffer, (void const   *)(sig_nsr2), (size_t )7);
      }
#line 75
      if (tmp___2 == 0) {
#line 77
        detected = 1;
#line 78
        goto while_break;
      } else {
        {
#line 75
        tmp___3 = memcmp((void const   *)buffer, (void const   *)(sig_nsr3), (size_t )7);
        }
#line 75
        if (tmp___3 == 0) {
#line 77
          detected = 1;
#line 78
          goto while_break;
        }
      }
    }
#line 62
    sector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (! detected) {
#line 82
    return;
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (sizes[i] > 0)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    probe_result = probe_udf(section, level, sizes[i]);
    }
#line 95
    if (probe_result > 0) {
#line 96
      return;
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 101
  print_line(level, "UDF recognition sequence, unable to locate anchor descriptor");
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/disktype-9/udf.c"
static int probe_udf(SECTION *section , int level , int sector_size ) 
{ 
  unsigned char *buffer ;
  u4 count ;
  u4 addr ;
  u4 sect ;
  int seen_primary ;
  int seen_logical ;
  int i ;
  char s[256] ;
  u8 tmp ;
  int tmp___0 ;
  u2 tmp___1 ;
  u4 tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  u2 tmp___5 ;
  int tmp___6 ;

  {
  {
#line 109
  seen_primary = 0;
#line 110
  seen_logical = 0;
#line 115
  tmp = get_buffer(section, (u8 )(256 * sector_size), (u8 )512, (void **)(& buffer));
  }
#line 115
  if (tmp < 512ULL) {
#line 116
    return (0);
  }
  {
#line 117
  tmp___0 = validate_tag(buffer, (u4 )256);
  }
#line 117
  if (! tmp___0) {
#line 118
    return (0);
  }
  {
#line 120
  tmp___1 = get_le_short((void *)buffer);
  }
#line 120
  if ((int )tmp___1 != 2) {
#line 121
    return (0);
  }
  {
#line 123
  print_line(level, "UDF file system");
#line 124
  print_line(level + 1, "Sector size %d bytes", sector_size);
#line 127
  tmp___2 = get_le_long((void *)(buffer + 16));
#line 127
  count = tmp___2 / (u4 )sector_size;
#line 128
  addr = get_le_long((void *)(buffer + 20));
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((u4 )i < count)) {
#line 131
      goto while_break;
    }
    {
#line 132
    sect = addr + (u4 )i;
#line 133
    tmp___3 = get_buffer(section, (u8 )sect * (u8 )sector_size, (u8 )512, (void **)(& buffer));
    }
#line 133
    if (tmp___3 < 512ULL) {
#line 134
      goto while_break;
    }
    {
#line 135
    tmp___4 = validate_tag(buffer, sect);
    }
#line 135
    if (! tmp___4) {
#line 136
      goto __Cont;
    }
    {
#line 139
    tmp___5 = get_le_short((void *)buffer);
    }
    {
#line 140
    if ((int )tmp___5 == 1) {
#line 140
      goto case_1;
    }
#line 157
    if ((int )tmp___5 == 6) {
#line 157
      goto case_6;
    }
#line 139
    goto switch_break;
    case_1: /* CIL Label */ 
#line 141
    if (! seen_primary) {
#line 142
      seen_primary = 1;
#line 144
      if ((int )*(buffer + 24) == 8) {
        {
#line 145
        get_string((void *)(buffer + 25), 30, s);
#line 146
        print_line(level + 1, "Volume name \"%s\"", s);
        }
      } else
#line 147
      if ((int )*(buffer + 24) == 16) {
        {
#line 148
        format_utf16_le((void *)(buffer + 25), (u4 )30, s);
#line 149
        print_line(level + 1, "Volume name \"%s\"", s);
        }
      } else {
        {
#line 151
        print_line(level + 1, "Volume name encoding not supported");
        }
      }
    }
#line 155
    goto switch_break;
    case_6: /* CIL Label */ 
#line 158
    if (! seen_logical) {
      {
#line 159
      seen_logical = 1;
#line 161
      tmp___6 = memcmp((void const   *)((buffer + 216) + 1), (void const   *)"*OSTA UDF Compliant",
                       (size_t )19);
      }
#line 161
      if (tmp___6 == 0) {
        {
#line 162
        print_line(level + 1, "UDF version %x.%02x", (int )*(buffer + 241), (int )*(buffer + 240));
        }
      }
    }
#line 167
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (! seen_primary) {
    {
#line 172
    print_line(level + 1, "Primary Volume Descriptor missing");
    }
  }
#line 175
  return (1);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/disktype-9/udf.c"
static int validate_tag(unsigned char *buf , u4 sector ) 
{ 
  int cksum ;
  int i ;
  u4 tmp ;

  {
#line 183
  cksum = 0;
#line 184
  i = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < 16)) {
#line 184
      goto while_break;
    }
#line 185
    if (i != 4) {
#line 186
      cksum += (int )*(buf + i);
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if ((cksum & 255) != (int )*(buf + 4)) {
#line 188
    return (0);
  }
#line 191
  if ((int )*(buf + 5) != 0) {
#line 192
    return (0);
  }
  {
#line 195
  tmp = get_le_long((void *)(buf + 12));
  }
#line 195
  if (tmp != sector) {
#line 196
    return (0);
  }
#line 198
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void start_line(char const   *fmt  , ...) ;
#line 111
void continue_line(char const   *fmt  , ...) ;
#line 112
void finish_line(int level ) ;
#line 126
void format_uuid_lvm(void *uuid , char *to ) ;
#line 127
void format_guid(void *guid , char *to ) ;
#line 141
u8 get_ve_quad(int endianness , void *from ) ;
#line 149
void get_padded_string(void *from , int len , char pad , char *to ) ;
#line 151
int find_memory(void *haystack , int haystack_len , void *needle , int needle_len ) ;
#line 163
void bailoute(char const   *msg  , ...) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
static char const   *insets[8]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
  {      "",      "  ",      "    ",      "      ", 
        "        ",      "          ",      "            ",      "              "};
#line 47 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
static char line_akku[4096]  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void print_line(int level , char const   *fmt  , ...) 
{ 
  va_list par ;

  {
  {
#line 53
  __builtin_va_start(par, fmt);
#line 54
  vsnprintf((char */* __restrict  */)(line_akku), (size_t )4096, (char const   */* __restrict  */)fmt,
            par);
#line 55
  __builtin_va_end(par);
  }
#line 57
  if (level >= 8) {
    {
#line 58
    bailout("Recursion loop caught");
    }
  }
  {
#line 59
  printf((char const   */* __restrict  */)"%s%s\n", insets[level], line_akku);
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void start_line(char const   *fmt  , ...) 
{ 
  va_list par ;

  {
  {
#line 66
  __builtin_va_start(par, fmt);
#line 67
  vsnprintf((char */* __restrict  */)(line_akku), (size_t )4096, (char const   */* __restrict  */)fmt,
            par);
#line 68
  __builtin_va_end(par);
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void continue_line(char const   *fmt  , ...) 
{ 
  va_list par ;
  int len ;
  size_t tmp ;

  {
  {
#line 74
  tmp = strlen((char const   *)(line_akku));
#line 74
  len = (int )tmp;
#line 76
  __builtin_va_start(par, fmt);
#line 77
  vsnprintf((char */* __restrict  */)(line_akku + len), (size_t )(4096 - len), (char const   */* __restrict  */)fmt,
            par);
#line 78
  __builtin_va_end(par);
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void finish_line(int level ) 
{ 


  {
#line 83
  if (level >= 8) {
    {
#line 84
    bailout("Recursion loop caught");
    }
  }
  {
#line 85
  printf((char const   */* __restrict  */)"%s%s\n", insets[level], line_akku);
  }
#line 86
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
static int format_raw_size(char *buf , u8 size ) 
{ 
  int unit_index ;
  int dd ;
  u8 unit_size ;
  u8 card ;
  char const   *unit_names[7] ;
  int dd_mult[4] ;
  int tmp ;

  {
#line 107
  unit_names[0] = "KiB";
#line 107
  unit_names[1] = "MiB";
#line 107
  unit_names[2] = "GiB";
#line 107
  unit_names[3] = "TiB";
#line 107
  unit_names[4] = "PiB";
#line 107
  unit_names[5] = "EiB";
#line 107
  unit_names[6] = (char const   *)((void *)0);
#line 109
  dd_mult[0] = 1;
#line 109
  dd_mult[1] = 10;
#line 109
  dd_mult[2] = 100;
#line 109
  dd_mult[3] = 1000;
#line 112
  if (size < 1024ULL) {
    {
#line 113
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%llu bytes",
            size);
    }
#line 114
    return (2);
  }
#line 118
  unit_index = 0;
#line 118
  unit_size = (u8 )1024;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )unit_names[unit_index] != (unsigned long )((void *)0))) {
#line 118
      goto while_break;
    }
#line 123
    if (size >= 1024ULL * unit_size) {
#line 124
      goto __Cont;
    }
#line 127
    if (size % unit_size == 0ULL) {
      {
#line 128
      card = size / unit_size;
#line 129
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%d %s",
              (int )card, unit_names[unit_index]);
      }
#line 132
      if (unit_index) {
#line 132
        tmp = 0;
      } else {
#line 132
        tmp = 1;
      }
#line 132
      return (tmp);
    }
#line 136
    dd = 3;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (dd >= 1)) {
#line 136
        goto while_break___0;
      }
#line 137
      card = (size * (u8 )dd_mult[dd] + (unit_size >> 1)) / unit_size;
#line 138
      if (card >= 10000ULL) {
#line 139
        goto __Cont___0;
      }
      {
#line 141
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%d.%0*d %s",
              (int )(card / (u8 )dd_mult[dd]), dd, (int )(card % (unsigned long long )dd_mult[dd]),
              unit_names[unit_index]);
      }
#line 145
      return (0);
      __Cont___0: /* CIL Label */ 
#line 136
      dd --;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 118
    unit_index ++;
#line 118
    unit_size <<= 10;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"off the scale");
  }
#line 151
  return (0);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_blocky_size(char *buf , u8 count , u4 blocksize , char const   *blockname ,
                        char const   *append ) 
{ 
  int used ;
  u8 total_size ;
  char *p ;
  char blocksizebuf[32] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 162
  total_size = count * (u8 )blocksize;
#line 163
  used = format_raw_size(buf, total_size);
#line 164
  p = strchr((char const   *)buf, 0);
#line 166
  tmp = p;
#line 166
  p ++;
#line 166
  *tmp = (char )' ';
#line 167
  tmp___0 = p;
#line 167
  p ++;
#line 167
  *tmp___0 = (char )'(';
  }
#line 169
  if (used != 2) {
    {
#line 170
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%llu bytes, ",
            total_size);
#line 171
    p = strchr((char const   *)buf, 0);
    }
  }
#line 174
  if (blocksize == 512UL) {
    {
#line 174
    tmp___1 = strcmp(blockname, "sectors");
    }
#line 174
    if (tmp___1 == 0) {
      {
#line 175
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%llu %s",
              count, blockname);
      }
    } else {
#line 174
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 177
    if (blocksize < 65536UL) {
#line 177
      if (blocksize % 1024UL != 0UL) {
        {
#line 178
        sprintf((char */* __restrict  */)(blocksizebuf), (char const   */* __restrict  */)"%lu bytes",
                blocksize);
        }
      } else {
        {
#line 180
        format_raw_size(blocksizebuf, (u8 )blocksize);
        }
      }
    } else {
      {
#line 180
      format_raw_size(blocksizebuf, (u8 )blocksize);
      }
    }
    {
#line 181
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%llu %s of %s",
            count, blockname, blocksizebuf);
    }
  }
  {
#line 183
  p = strchr((char const   *)buf, 0);
  }
#line 185
  if ((unsigned long )append != (unsigned long )((void *)0)) {
    {
#line 186
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)append);
#line 187
    p = strchr((char const   *)buf, 0);
    }
  }
#line 190
  tmp___2 = p;
#line 190
  p ++;
#line 190
  *tmp___2 = (char )')';
#line 191
  tmp___3 = p;
#line 191
  p ++;
#line 191
  *tmp___3 = (char)0;
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_size(char *buf , u8 size ) 
{ 
  int used ;
  char *tmp ;

  {
  {
#line 198
  used = format_raw_size(buf, size);
  }
#line 199
  if (used > 0) {
#line 200
    return;
  }
  {
#line 202
  tmp = strchr((char const   *)buf, 0);
#line 202
  sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)" (%llu bytes)",
          size);
  }
#line 203
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_size_verbose(char *buf , u8 size ) 
{ 
  int used ;
  char *tmp ;

  {
  {
#line 209
  used = format_raw_size(buf, size);
  }
#line 210
  if (used == 2) {
#line 211
    return;
  }
  {
#line 213
  tmp = strchr((char const   *)buf, 0);
#line 213
  sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)" (%llu bytes)",
          size);
  }
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_ascii(void *from , char *to ) 
{ 
  u1 *p ;
  u1 *q ;
  int c ;
  u1 *tmp ;
  u1 *tmp___0 ;
  u1 *tmp___1 ;
  u1 *tmp___2 ;
  u1 *tmp___3 ;
  u1 *tmp___4 ;

  {
#line 218
  p = (u1 *)from;
#line 219
  q = (u1 *)to;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    tmp___4 = p;
#line 222
    p ++;
#line 222
    c = (int )*tmp___4;
#line 222
    if (! c) {
#line 222
      goto while_break;
    }
#line 223
    if (c >= 127) {
#line 223
      goto _L;
    } else
#line 223
    if (c < 32) {
      _L: /* CIL Label */ 
#line 224
      tmp = q;
#line 224
      q ++;
#line 224
      *tmp = (u1 )'<';
#line 225
      tmp___0 = q;
#line 225
      q ++;
#line 225
      *tmp___0 = (u1 )*("0123456789ABCDEF" + (c >> 4));
#line 226
      tmp___1 = q;
#line 226
      q ++;
#line 226
      *tmp___1 = (u1 )*("0123456789ABCDEF" + (c & 15));
#line 227
      tmp___2 = q;
#line 227
      q ++;
#line 227
      *tmp___2 = (u1 )'>';
    } else {
#line 229
      tmp___3 = q;
#line 229
      q ++;
#line 229
      *tmp___3 = (u1 )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  *q = (u1 )0;
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_utf16_be(void *from , u4 len , char *to ) 
{ 
  u2 *p ;
  u2 *p_end ;
  u1 *q ;
  u2 c ;
  u1 *tmp ;
  u1 *tmp___0 ;
  u1 *tmp___1 ;
  u1 *tmp___2 ;
  u1 *tmp___3 ;
  u1 *tmp___4 ;
  u1 *tmp___5 ;

  {
#line 237
  p = (u2 *)from;
#line 239
  q = (u1 *)to;
#line 242
  if (len) {
#line 243
    p_end = (u2 *)((u1 *)from + len);
  } else {
#line 245
    p_end = (u2 *)((void *)0);
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! ((unsigned long )p_end == (unsigned long )((void *)0))) {
#line 247
      if (! ((unsigned long )p < (unsigned long )p_end)) {
#line 247
        goto while_break;
      }
    }
    {
#line 248
    c = get_be_short((void *)p);
    }
#line 249
    if ((int )c == 0) {
#line 250
      goto while_break;
    }
#line 251
    p ++;
#line 253
    if ((int )c >= 127) {
#line 253
      goto _L;
    } else
#line 253
    if ((int )c < 32) {
      _L: /* CIL Label */ 
#line 254
      tmp = q;
#line 254
      q ++;
#line 254
      *tmp = (u1 )'<';
#line 255
      tmp___0 = q;
#line 255
      q ++;
#line 255
      *tmp___0 = (u1 )*("0123456789ABCDEF" + ((int )c >> 12));
#line 256
      tmp___1 = q;
#line 256
      q ++;
#line 256
      *tmp___1 = (u1 )*("0123456789ABCDEF" + (((int )c >> 8) & 15));
#line 257
      tmp___2 = q;
#line 257
      q ++;
#line 257
      *tmp___2 = (u1 )*("0123456789ABCDEF" + (((int )c >> 4) & 15));
#line 258
      tmp___3 = q;
#line 258
      q ++;
#line 258
      *tmp___3 = (u1 )*("0123456789ABCDEF" + ((int )c & 15));
#line 259
      tmp___4 = q;
#line 259
      q ++;
#line 259
      *tmp___4 = (u1 )'>';
    } else {
#line 261
      tmp___5 = q;
#line 261
      q ++;
#line 261
      *tmp___5 = (u1 )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  *q = (u1 )0;
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_utf16_le(void *from , u4 len , char *to ) 
{ 
  u2 *p ;
  u2 *p_end ;
  u1 *q ;
  u2 c ;
  u1 *tmp ;
  u1 *tmp___0 ;
  u1 *tmp___1 ;
  u1 *tmp___2 ;
  u1 *tmp___3 ;
  u1 *tmp___4 ;
  u1 *tmp___5 ;

  {
#line 269
  p = (u2 *)from;
#line 271
  q = (u1 *)to;
#line 274
  if (len) {
#line 275
    p_end = (u2 *)((u1 *)from + len);
  } else {
#line 277
    p_end = (u2 *)((void *)0);
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! ((unsigned long )p_end == (unsigned long )((void *)0))) {
#line 279
      if (! ((unsigned long )p < (unsigned long )p_end)) {
#line 279
        goto while_break;
      }
    }
    {
#line 280
    c = get_le_short((void *)p);
    }
#line 281
    if ((int )c == 0) {
#line 282
      goto while_break;
    }
#line 283
    p ++;
#line 285
    if ((int )c >= 127) {
#line 285
      goto _L;
    } else
#line 285
    if ((int )c < 32) {
      _L: /* CIL Label */ 
#line 286
      tmp = q;
#line 286
      q ++;
#line 286
      *tmp = (u1 )'<';
#line 287
      tmp___0 = q;
#line 287
      q ++;
#line 287
      *tmp___0 = (u1 )*("0123456789ABCDEF" + ((int )c >> 12));
#line 288
      tmp___1 = q;
#line 288
      q ++;
#line 288
      *tmp___1 = (u1 )*("0123456789ABCDEF" + (((int )c >> 8) & 15));
#line 289
      tmp___2 = q;
#line 289
      q ++;
#line 289
      *tmp___2 = (u1 )*("0123456789ABCDEF" + (((int )c >> 4) & 15));
#line 290
      tmp___3 = q;
#line 290
      q ++;
#line 290
      *tmp___3 = (u1 )*("0123456789ABCDEF" + ((int )c & 15));
#line 291
      tmp___4 = q;
#line 291
      q ++;
#line 291
      *tmp___4 = (u1 )'>';
    } else {
#line 293
      tmp___5 = q;
#line 293
      q ++;
#line 293
      *tmp___5 = (u1 )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  *q = (u1 )0;
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_uuid(void *uuid , char *to ) 
{ 
  u1 *from ;
  int i ;
  int c ;
  int variant ;
  int version ;
  int tmp ;
  u1 *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 301
  from = (u1 *)uuid;
#line 304
  tmp = memcmp((void const   *)uuid, (void const   *)"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
               (size_t )16);
  }
#line 304
  if (tmp == 0) {
    {
#line 305
    strcpy((char */* __restrict  */)to, (char const   */* __restrict  */)"nil");
    }
#line 306
    return;
  }
#line 309
  variant = (int )*(from + 8) >> 5;
#line 310
  version = (int )*(from + 6) >> 4;
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < 16)) {
#line 312
      goto while_break;
    }
#line 313
    tmp___0 = from;
#line 313
    from ++;
#line 313
    c = (int )*tmp___0;
#line 314
    tmp___1 = to;
#line 314
    to ++;
#line 314
    *tmp___1 = (char )*("0123456789ABCDEF" + (c >> 4));
#line 315
    tmp___2 = to;
#line 315
    to ++;
#line 315
    *tmp___2 = (char )*("0123456789ABCDEF" + (c & 15));
#line 316
    if (i == 3) {
#line 317
      tmp___3 = to;
#line 317
      to ++;
#line 317
      *tmp___3 = (char )'-';
    } else
#line 316
    if (i == 5) {
#line 317
      tmp___3 = to;
#line 317
      to ++;
#line 317
      *tmp___3 = (char )'-';
    } else
#line 316
    if (i == 7) {
#line 317
      tmp___3 = to;
#line 317
      to ++;
#line 317
      *tmp___3 = (char )'-';
    } else
#line 316
    if (i == 9) {
#line 317
      tmp___3 = to;
#line 317
      to ++;
#line 317
      *tmp___3 = (char )'-';
    }
#line 312
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if ((variant & 4) == 0) {
    {
#line 321
    strcpy((char */* __restrict  */)to, (char const   */* __restrict  */)" (NCS)");
    }
  } else
#line 322
  if ((variant & 2) == 0) {
    {
#line 323
    sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)" (DCE, v%1.1d)",
            version);
    }
  } else
#line 324
  if ((variant & 1) == 0) {
    {
#line 325
    strcpy((char */* __restrict  */)to, (char const   */* __restrict  */)" (MS GUID)");
    }
  } else {
    {
#line 327
    strcpy((char */* __restrict  */)to, (char const   */* __restrict  */)" (Reserved)");
    }
  }
#line 329
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_uuid_lvm(void *uuid , char *to ) 
{ 
  char *from ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 333
  from = (char *)uuid;
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < 32)) {
#line 336
      goto while_break;
    }
#line 337
    tmp = to;
#line 337
    to ++;
#line 337
    tmp___0 = from;
#line 337
    from ++;
#line 337
    *tmp = *tmp___0;
#line 338
    if ((i & 3) == 1) {
#line 338
      if (i > 1) {
#line 338
        if (i < 29) {
#line 339
          tmp___1 = to;
#line 339
          to ++;
#line 339
          *tmp___1 = (char )'-';
        }
      }
    }
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  *to = (char)0;
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void format_guid(void *guid , char *to ) 
{ 
  u1 *from ;
  int i ;
  int c ;
  int tmp ;
  u1 *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 346
  from = (u1 *)guid;
#line 349
  tmp = memcmp((void const   *)guid, (void const   *)"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
               (size_t )16);
  }
#line 349
  if (tmp == 0) {
    {
#line 350
    strcpy((char */* __restrict  */)to, (char const   */* __restrict  */)"nil");
    }
#line 351
    return;
  }
#line 354
  i = 0;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (i < 16)) {
#line 354
      goto while_break;
    }
#line 355
    tmp___0 = from;
#line 355
    from ++;
#line 355
    c = (int )*tmp___0;
#line 356
    tmp___1 = to;
#line 356
    to ++;
#line 356
    *tmp___1 = (char )*("0123456789ABCDEF" + (c >> 4));
#line 357
    tmp___2 = to;
#line 357
    to ++;
#line 357
    *tmp___2 = (char )*("0123456789ABCDEF" + (c & 15));
#line 358
    if (i == 3) {
#line 359
      tmp___3 = to;
#line 359
      to ++;
#line 359
      *tmp___3 = (char )'-';
    } else
#line 358
    if (i == 5) {
#line 359
      tmp___3 = to;
#line 359
      to ++;
#line 359
      *tmp___3 = (char )'-';
    } else
#line 358
    if (i == 7) {
#line 359
      tmp___3 = to;
#line 359
      to ++;
#line 359
      *tmp___3 = (char )'-';
    } else
#line 358
    if (i == 9) {
#line 359
      tmp___3 = to;
#line 359
      to ++;
#line 359
      *tmp___3 = (char )'-';
    }
#line 354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  *to = (char)0;
#line 362
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u2 get_be_short(void *from ) 
{ 
  u1 *p ;

  {
#line 370
  p = (u1 *)from;
#line 371
  return ((u2 )(((int )((u2 )*(p + 0)) << 8) + (int )((u2 )*(p + 1))));
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u4 get_be_long(void *from ) 
{ 
  u1 *p ;

  {
#line 377
  p = (u1 *)from;
#line 378
  return (((((u4 )*(p + 0) << 24) + ((u4 )*(p + 1) << 16)) + ((u4 )*(p + 2) << 8)) + (u4 )*(p + 3));
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u8 get_be_quad(void *from ) 
{ 
  u1 *p ;

  {
#line 386
  p = (u1 *)from;
#line 387
  return (((((((((u8 )*(p + 0) << 56) + ((u8 )*(p + 1) << 48)) + ((u8 )*(p + 2) << 40)) + ((u8 )*(p + 3) << 32)) + ((u8 )*(p + 4) << 24)) + ((u8 )*(p + 5) << 16)) + ((u8 )*(p + 6) << 8)) + (u8 )*(p + 7));
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u2 get_le_short(void *from ) 
{ 
  u1 *p ;

  {
#line 399
  p = (u1 *)from;
#line 400
  return ((u2 )(((int )((u2 )*(p + 1)) << 8) + (int )((u2 )*(p + 0))));
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u4 get_le_long(void *from ) 
{ 
  u1 *p ;

  {
#line 406
  p = (u1 *)from;
#line 407
  return (((((u4 )*(p + 3) << 24) + ((u4 )*(p + 2) << 16)) + ((u4 )*(p + 1) << 8)) + (u4 )*(p + 0));
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u8 get_le_quad(void *from ) 
{ 
  u1 *p ;

  {
#line 415
  p = (u1 *)from;
#line 416
  return (((((((((u8 )*(p + 7) << 56) + ((u8 )*(p + 6) << 48)) + ((u8 )*(p + 5) << 40)) + ((u8 )*(p + 4) << 32)) + ((u8 )*(p + 3) << 24)) + ((u8 )*(p + 2) << 16)) + ((u8 )*(p + 1) << 8)) + (u8 )*(p + 0));
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u2 get_ve_short(int endianness , void *from ) 
{ 
  u2 tmp ;
  u2 tmp___0 ;

  {
#line 428
  if (endianness) {
    {
#line 429
    tmp = get_le_short(from);
    }
#line 429
    return (tmp);
  } else {
    {
#line 431
    tmp___0 = get_be_short(from);
    }
#line 431
    return (tmp___0);
  }
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u4 get_ve_long(int endianness , void *from ) 
{ 
  u4 tmp ;
  u4 tmp___0 ;

  {
#line 436
  if (endianness) {
    {
#line 437
    tmp = get_le_long(from);
    }
#line 437
    return (tmp);
  } else {
    {
#line 439
    tmp___0 = get_be_long(from);
    }
#line 439
    return (tmp___0);
  }
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
u8 get_ve_quad(int endianness , void *from ) 
{ 
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 444
  if (endianness) {
    {
#line 445
    tmp = get_le_quad(from);
    }
#line 445
    return (tmp);
  } else {
    {
#line 447
    tmp___0 = get_be_quad(from);
    }
#line 447
    return (tmp___0);
  }
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
char const   *get_ve_name(int endianness ) 
{ 


  {
#line 452
  if (endianness) {
#line 453
    return ("little-endian");
  } else {
#line 455
    return ("big-endian");
  }
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void get_string(void *from , int len , char *to ) 
{ 


  {
#line 464
  if (len > 255) {
#line 465
    len = 255;
  }
  {
#line 466
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, (size_t )len);
#line 467
  *(to + len) = (char)0;
  }
#line 468
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void get_pstring(void *from , char *to ) 
{ 
  int len ;

  {
  {
#line 472
  len = (int )*((unsigned char *)from);
#line 473
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)((char *)from + 1),
         (size_t )len);
#line 474
  *(to + len) = (char)0;
  }
#line 475
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void get_padded_string(void *from , int len , char pad , char *to ) 
{ 
  int pos ;
  size_t tmp ;

  {
  {
#line 481
  get_string(from, len, to);
#line 483
  tmp = strlen((char const   *)to);
#line 483
  pos = (int )(tmp - 1UL);
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (pos >= 0) {
#line 483
      if (! ((int )*(to + pos) == (int )pad)) {
#line 483
        goto while_break;
      }
    } else {
#line 483
      goto while_break;
    }
#line 484
    *(to + pos) = (char)0;
#line 483
    pos --;
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
int find_memory(void *haystack , int haystack_len , void *needle , int needle_len ) 
{ 
  int searchlen ;
  int pos ;
  void *p ;
  int tmp ;

  {
#line 490
  searchlen = (haystack_len - needle_len) + 1;
#line 491
  pos = 0;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! (pos < searchlen)) {
#line 494
      goto while_break;
    }
    {
#line 495
    p = memchr((void const   *)((char *)haystack + pos), (int )*((unsigned char *)needle),
               (size_t )(searchlen - pos));
    }
#line 497
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 498
      return (-1);
    }
    {
#line 499
    pos = (int )((char *)p - (char *)haystack);
#line 500
    tmp = memcmp((void const   *)p, (void const   *)needle, (size_t )needle_len);
    }
#line 500
    if (tmp == 0) {
#line 501
      return (pos);
    }
#line 502
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  return (-1);
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void error(char const   *msg  , ...) 
{ 
  va_list par ;
  char buf[4096] ;

  {
  {
#line 517
  __builtin_va_start(par, msg);
#line 518
  vsnprintf((char */* __restrict  */)(buf), (size_t )4096, (char const   */* __restrict  */)msg,
            par);
#line 519
  __builtin_va_end(par);
#line 521
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"disktype: %s\n",
          buf);
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void errore(char const   *msg  , ...) 
{ 
  va_list par ;
  char buf[4096] ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 529
  __builtin_va_start(par, msg);
#line 530
  vsnprintf((char */* __restrict  */)(buf), (size_t )4096, (char const   */* __restrict  */)msg,
            par);
#line 531
  __builtin_va_end(par);
#line 533
  tmp = __errno_location();
#line 533
  tmp___0 = strerror(*tmp);
#line 533
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"disktype: %s: %s\n",
          buf, tmp___0);
  }
#line 534
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void bailout(char const   *msg  , ...) 
{ 
  va_list par ;
  char buf[4096] ;

  {
  {
#line 541
  __builtin_va_start(par, msg);
#line 542
  vsnprintf((char */* __restrict  */)(buf), (size_t )4096, (char const   */* __restrict  */)msg,
            par);
#line 543
  __builtin_va_end(par);
#line 545
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"disktype: %s\n",
          buf);
#line 546
  exit(1);
  }
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/disktype-9/lib.c"
void bailoute(char const   *msg  , ...) 
{ 
  va_list par ;
  char buf[4096] ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 554
  __builtin_va_start(par, msg);
#line 555
  vsnprintf((char */* __restrict  */)(buf), (size_t )4096, (char const   */* __restrict  */)msg,
            par);
#line 556
  __builtin_va_end(par);
#line 558
  tmp = __errno_location();
#line 558
  tmp___0 = strerror(*tmp);
#line 558
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"disktype: %s: %s\n",
          buf, tmp___0);
#line 559
  exit(1);
  }
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/disktype-9/beos.c"
void detect_bfs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  char s[256] ;
  int off ;
  int en ;
  u4 blocksize ;
  u8 blockcount ;
  u8 tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u4 tmp___2 ;
  u4 tmp___3 ;
  u4 tmp___4 ;
  u4 tmp___5 ;

  {
#line 43
  off = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (off <= 512)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp = get_buffer(section, (u8 )off, (u8 )512, (void **)(& buf));
    }
#line 44
    if (tmp < 512ULL) {
#line 45
      goto __Cont;
    }
#line 47
    en = 0;
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 47
      if (! (en < 2)) {
#line 47
        goto while_break___0;
      }
      {
#line 48
      tmp___2 = get_ve_long(en, (void *)(buf + 32));
      }
#line 48
      if (tmp___2 == 1111905073UL) {
        {
#line 48
        tmp___3 = get_ve_long(en, (void *)(buf + 36));
        }
#line 48
        if (tmp___3 == 1112098629UL) {
          {
#line 48
          tmp___4 = get_ve_long(en, (void *)(buf + 68));
          }
#line 48
          if (tmp___4 == 3708948529UL) {
            {
#line 48
            tmp___5 = get_ve_long(en, (void *)(buf + 112));
            }
#line 48
            if (tmp___5 == 364282638UL) {
              {
#line 53
              tmp___0 = get_ve_name(en);
              }
#line 53
              if (off == 0) {
#line 53
                tmp___1 = "Apple";
              } else {
#line 53
                tmp___1 = "Intel";
              }
              {
#line 53
              print_line(level, "BeOS BFS (BeFS) file system, %s placement, %s", tmp___1,
                         tmp___0);
#line 58
              get_string((void *)buf, 32, s);
              }
#line 59
              if (s[0]) {
                {
#line 60
                print_line(level + 1, "Volume name \"%s\"", s);
                }
              }
              {
#line 63
              blocksize = get_ve_long(en, (void *)(buf + 40));
#line 64
              blockcount = get_ve_quad(en, (void *)(buf + 48));
#line 71
              format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 72
              print_line(level + 1, "Volume size %s", s);
              }
#line 74
              return;
            }
          }
        }
      }
#line 47
      en ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 43
    off += 512;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/disktype-9/beos.c"
void detect_beos_loader(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 88
  if (section->flags & 1) {
#line 89
    return;
  }
  {
#line 91
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 91
  if (tmp < 512ULL) {
#line 92
    return;
  }
  {
#line 94
  tmp___0 = find_memory((void *)buf, 512, (void *)"Be Boot Loader", 14);
  }
#line 94
  if (tmp___0 >= 0) {
    {
#line 95
    print_line(level, "BeOS boot loader");
    }
  }
  {
#line 96
  tmp___1 = find_memory((void *)buf, 512, (void *)"yT Boot Loader", 14);
  }
#line 96
  if (tmp___1 >= 0) {
    {
#line 97
    print_line(level, "ZETA/yellowTab boot loader");
    }
  }
  {
#line 98
  tmp___2 = find_memory((void *)buf, 512, (void *)"\004beos\006system\005zbeos", 18);
  }
#line 98
  if (tmp___2 >= 0) {
    {
#line 99
    print_line(level, "Haiku boot loader");
    }
  }
#line 100
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_ext23(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  char s[256] ;
  u4 blocksize ;
  u8 blockcount ;
  u8 tmp ;
  u4 tmp___0 ;
  u4 tmp___1 ;
  u4 tmp___2 ;
  u4 tmp___3 ;
  u2 tmp___4 ;

  {
  {
#line 41
  tmp = get_buffer(section, (u8 )1024, (u8 )1024, (void **)(& buf));
  }
#line 41
  if (tmp < 1024ULL) {
#line 42
    return;
  }
  {
#line 44
  tmp___4 = get_le_short((void *)(buf + 56));
  }
#line 44
  if ((int )tmp___4 == 61267) {
    {
#line 45
    tmp___1 = get_le_long((void *)(buf + 96));
    }
#line 45
    if (tmp___1 & 8UL) {
      {
#line 46
      print_line(level, "Ext3 external journal");
      }
    } else {
      {
#line 47
      tmp___0 = get_le_long((void *)(buf + 92));
      }
#line 47
      if (tmp___0 & 4UL) {
        {
#line 48
        print_line(level, "Ext3 file system");
        }
      } else {
        {
#line 50
        print_line(level, "Ext2 file system");
        }
      }
    }
    {
#line 52
    get_string((void *)(buf + 120), 16, s);
    }
#line 53
    if (s[0]) {
      {
#line 54
      print_line(level + 1, "Volume name \"%s\"", s);
      }
    }
    {
#line 56
    format_uuid((void *)(buf + 104), s);
#line 57
    print_line(level + 1, "UUID %s", s);
#line 59
    get_string((void *)(buf + 136), 64, s);
    }
#line 60
    if (s[0]) {
      {
#line 61
      print_line(level + 1, "Last mounted at \"%s\"", s);
      }
    }
    {
#line 63
    tmp___2 = get_le_long((void *)(buf + 24));
#line 63
    blocksize = (u4 )(1024 << tmp___2);
#line 64
    tmp___3 = get_le_long((void *)(buf + 4));
#line 64
    blockcount = (u8 )tmp___3;
#line 65
    format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 66
    print_line(level + 1, "Volume size %s", s);
    }
  }
#line 73
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_reiser(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int at ;
  int newformat ;
  int offsets[3] ;
  char s[256] ;
  u8 blockcount ;
  u4 blocksize ;
  u8 tmp ;
  u2 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u4 tmp___4 ;
  u2 tmp___5 ;

  {
#line 83
  offsets[0] = 8;
#line 83
  offsets[1] = 64;
#line 83
  offsets[2] = -1;
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (offsets[i] >= 0)) {
#line 88
      goto while_break;
    }
    {
#line 89
    at = offsets[i];
#line 90
    tmp = get_buffer(section, (u8 )(at * 1024), (u8 )1024, (void **)(& buf));
    }
#line 90
    if (tmp < 1024ULL) {
#line 91
      goto __Cont;
    }
    {
#line 94
    tmp___3 = memcmp((void const   *)(buf + 52), (void const   *)"ReIsErFs", (size_t )8);
    }
#line 94
    if (tmp___3 == 0) {
      {
#line 95
      print_line(level, "ReiserFS file system (old 3.5 format, standard journal, starts at %d KiB)",
                 at);
#line 96
      newformat = 0;
      }
    } else {
      {
#line 97
      tmp___2 = memcmp((void const   *)(buf + 52), (void const   *)"ReIsEr2Fs", (size_t )9);
      }
#line 97
      if (tmp___2 == 0) {
        {
#line 98
        print_line(level, "ReiserFS file system (new 3.6 format, standard journal, starts at %d KiB)",
                   at);
#line 99
        newformat = 1;
        }
      } else {
        {
#line 100
        tmp___1 = memcmp((void const   *)(buf + 52), (void const   *)"ReIsEr3Fs",
                         (size_t )9);
        }
#line 100
        if (tmp___1 == 0) {
          {
#line 101
          tmp___0 = get_le_short((void *)(buf + 72));
#line 101
          newformat = (int )tmp___0;
          }
#line 102
          if (newformat == 0) {
            {
#line 103
            print_line(level, "ReiserFS file system (old 3.5 format, non-standard journal, starts at %d KiB)",
                       at);
            }
          } else
#line 104
          if (newformat == 2) {
            {
#line 105
            print_line(level, "ReiserFS file system (new 3.6 format, non-standard journal, starts at %d KiB)",
                       at);
#line 106
            newformat = 1;
            }
          } else {
            {
#line 108
            print_line(level, "ReiserFS file system (v3 magic, but unknown version %d, starts at %d KiB)",
                       newformat, at);
            }
#line 109
            goto __Cont;
          }
        } else {
#line 112
          goto __Cont;
        }
      }
    }
    {
#line 115
    tmp___4 = get_le_long((void *)buf);
#line 115
    blockcount = (u8 )tmp___4;
#line 116
    tmp___5 = get_le_short((void *)(buf + 44));
#line 116
    blocksize = (u4 )tmp___5;
#line 122
    get_string((void *)(buf + 100), 16, s);
    }
#line 123
    if (s[0]) {
      {
#line 124
      print_line(level + 1, "Volume name \"%s\"", s);
      }
    }
    {
#line 126
    format_uuid((void *)(buf + 84), s);
#line 127
    print_line(level + 1, "UUID %s", s);
#line 130
    format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 131
    print_line(level + 1, "Volume size %s", s);
    }
    __Cont: /* CIL Label */ 
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_reiser4(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  char s[256] ;
  int layout_id ;
  char layout_name[64] ;
  u4 blocksize ;
  u8 blockcount ;
  u8 tmp ;
  int tmp___0 ;
  u2 tmp___1 ;
  u2 tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;

  {
  {
#line 150
  tmp = get_buffer(section, (u8 )65536, (u8 )1024, (void **)(& buf));
  }
#line 150
  if (tmp < 1024ULL) {
#line 151
    return;
  }
  {
#line 154
  tmp___0 = memcmp((void const   *)buf, (void const   *)"ReIsEr4", (size_t )7);
  }
#line 154
  if (tmp___0 != 0) {
#line 155
    return;
  }
  {
#line 158
  tmp___1 = get_le_short((void *)(buf + 16));
#line 158
  layout_id = (int )tmp___1;
#line 159
  tmp___2 = get_le_short((void *)(buf + 18));
#line 159
  blocksize = (u4 )tmp___2;
  }
#line 160
  if (layout_id == 0) {
    {
#line 161
    strcpy((char */* __restrict  */)(layout_name), (char const   */* __restrict  */)"4.0 layout");
    }
  } else {
    {
#line 163
    sprintf((char */* __restrict  */)(layout_name), (char const   */* __restrict  */)"Unknown layout with ID %d",
            layout_id);
    }
  }
  {
#line 165
  format_size(s, (u8 )blocksize);
#line 166
  print_line(level, "Reiser4 file system (%s, block size %s)", layout_name, s);
#line 170
  get_string((void *)(buf + 36), 16, s);
  }
#line 171
  if (s[0]) {
    {
#line 172
    print_line(level + 1, "Volume name \"%s\"", s);
    }
  }
  {
#line 174
  format_uuid((void *)(buf + 20), s);
#line 175
  print_line(level + 1, "UUID %s", s);
  }
#line 177
  if (layout_id == 0) {
    {
#line 179
    tmp___3 = get_buffer(section, (u8 )69632, (u8 )1024, (void **)(& buf));
    }
#line 179
    if (tmp___3 < 1024ULL) {
#line 180
      return;
    }
    {
#line 181
    tmp___4 = memcmp((void const   *)(buf + 52), (void const   *)"ReIsEr40FoRmAt",
                     (size_t )14);
    }
#line 181
    if (tmp___4 != 0) {
      {
#line 182
      print_line(level + 1, "Superblock for 4.0 format missing");
      }
#line 183
      return;
    }
    {
#line 186
    blockcount = get_le_quad((void *)buf);
#line 187
    format_blocky_size(s, blockcount, blocksize, "blocks", (char const   *)((void *)0));
#line 188
    print_line(level + 1, "Volume size %s", s);
    }
  }
#line 190
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
static char *levels[10]  = 
#line 196
  {      (char *)"Multipath",      (char *)"\'HSM\'",      (char *)"\'translucent\'",      (char *)"Linear", 
        (char *)"RAID0",      (char *)"RAID1",      (char *)((void *)0),      (char *)((void *)0), 
        (char *)"RAID4(?)",      (char *)"RAID5"};
#line 208 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_linux_raid(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u8 pos ;
  int rlevel ;
  int nr_disks ;
  int raid_disks ;
  int spare ;
  u1 uuid[16] ;
  char s[256] ;
  u8 tmp ;
  u4 tmp___0 ;
  u4 tmp___1 ;
  u4 tmp___2 ;
  u4 tmp___3 ;
  u4 tmp___4 ;
  u4 tmp___5 ;
  u4 tmp___6 ;

  {
#line 221
  if (section->size < 65536ULL) {
#line 222
    return;
  } else
#line 221
  if ((section->source)->sequential) {
#line 222
    return;
  }
  {
#line 225
  pos = (section->size & 0xffffffffffff0000ULL) - 65536ULL;
#line 226
  tmp = get_buffer(section, pos, (u8 )4096, (void **)(& buf));
  }
#line 226
  if (tmp < 4096ULL) {
#line 227
    return;
  }
  {
#line 230
  tmp___0 = get_le_long((void *)buf);
  }
#line 230
  if (tmp___0 != 2838187772UL) {
#line 231
    return;
  }
  {
#line 233
  tmp___1 = get_le_long((void *)(buf + 12));
#line 233
  tmp___2 = get_le_long((void *)(buf + 8));
#line 233
  tmp___3 = get_le_long((void *)(buf + 4));
#line 233
  print_line(level, "Linux RAID disk, version %lu.%lu.%lu", tmp___3, tmp___2, tmp___1);
#line 238
  tmp___4 = get_le_long((void *)(buf + 28));
#line 238
  rlevel = (int )((long )tmp___4);
#line 239
  tmp___5 = get_le_long((void *)(buf + 36));
#line 239
  nr_disks = (int )tmp___5;
#line 240
  tmp___6 = get_le_long((void *)(buf + 40));
#line 240
  raid_disks = (int )tmp___6;
#line 241
  spare = nr_disks - raid_disks;
  }
#line 244
  if (rlevel < -4) {
    {
#line 245
    print_line(level + 1, "Unknown RAID level %d using %d regular %d spare disks",
               rlevel, raid_disks, spare);
    }
  } else
#line 244
  if (rlevel > 5) {
    {
#line 245
    print_line(level + 1, "Unknown RAID level %d using %d regular %d spare disks",
               rlevel, raid_disks, spare);
    }
  } else
#line 244
  if ((unsigned long )levels[rlevel + 4] == (unsigned long )((void *)0)) {
    {
#line 245
    print_line(level + 1, "Unknown RAID level %d using %d regular %d spare disks",
               rlevel, raid_disks, spare);
    }
  } else {
    {
#line 248
    print_line(level + 1, "%s set using %d regular %d spare disks", levels[rlevel + 4],
               raid_disks, spare);
    }
  }
  {
#line 253
  memcpy((void */* __restrict  */)(uuid), (void const   */* __restrict  */)(buf + 20),
         (size_t )4);
#line 254
  memcpy((void */* __restrict  */)(uuid + 4), (void const   */* __restrict  */)(buf + 52),
         (size_t )12);
#line 255
  format_uuid((void *)(uuid), s);
#line 256
  print_line(level + 1, "RAID set UUID %s", s);
  }
#line 257
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_linux_lvm(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  char s[256] ;
  int minor_version ;
  int pv_number ;
  u8 pe_size ;
  u8 pe_count ;
  u8 pe_start ;
  u8 tmp ;
  u4 tmp___0 ;
  u4 tmp___1 ;
  u2 tmp___2 ;
  char const   *tmp___3 ;
  u4 tmp___4 ;
  u4 tmp___5 ;
  u4 tmp___6 ;
  u4 tmp___7 ;
  u4 tmp___8 ;
  u4 tmp___9 ;

  {
  {
#line 270
  tmp = get_buffer(section, (u8 )0, (u8 )1024, (void **)(& buf));
  }
#line 270
  if (tmp < 1024ULL) {
#line 271
    return;
  }
#line 274
  if ((int )*(buf + 0) != 72) {
#line 275
    return;
  } else
#line 274
  if ((int )*(buf + 1) != 77) {
#line 275
    return;
  }
  {
#line 277
  tmp___0 = get_le_long((void *)(buf + 36));
  }
#line 277
  if (tmp___0 == 0UL) {
#line 278
    return;
  } else {
    {
#line 277
    tmp___1 = get_le_long((void *)(buf + 40));
    }
#line 277
    if (tmp___1 == 0UL) {
#line 278
      return;
    }
  }
  {
#line 280
  tmp___2 = get_le_short((void *)(buf + 2));
#line 280
  minor_version = (int )tmp___2;
  }
#line 281
  if (minor_version < 1) {
#line 281
    tmp___3 = " (unknown)";
  } else
#line 281
  if (minor_version > 2) {
#line 281
    tmp___3 = " (unknown)";
  } else {
#line 281
    tmp___3 = "";
  }
  {
#line 281
  print_line(level, "Linux LVM1 volume, version %d%s", minor_version, tmp___3);
#line 286
  get_string((void *)(buf + 172), 128, s);
#line 287
  print_line(level + 1, "Volume group name \"%s\"", s);
#line 290
  format_uuid_lvm((void *)(buf + 44), s);
#line 291
  print_line(level + 1, "PV UUID %s", s);
#line 294
  tmp___4 = get_le_long((void *)(buf + 432));
#line 294
  pv_number = (int )tmp___4;
#line 295
  print_line(level + 1, "PV number %d", pv_number);
#line 298
  tmp___5 = get_le_long((void *)(buf + 452));
#line 298
  pe_size = (u8 )tmp___5;
#line 299
  tmp___6 = get_le_long((void *)(buf + 456));
#line 299
  pe_count = (u8 )tmp___6;
#line 300
  format_blocky_size(s, pe_count, (u4 )(pe_size * 512ULL), "PEs", (char const   *)((void *)0));
#line 301
  print_line(level + 1, "Useable size %s", s);
  }
#line 304
  if (minor_version == 1) {
    {
#line 306
    tmp___7 = get_le_long((void *)(buf + 36));
#line 306
    tmp___8 = get_le_long((void *)(buf + 40));
#line 306
    pe_start = (u8 )(tmp___7 + tmp___8);
    }
  } else
#line 307
  if (minor_version == 2) {
    {
#line 309
    tmp___9 = get_le_long((void *)(buf + 464));
#line 309
    pe_start = (u8 )(tmp___9 << 9);
    }
  } else {
#line 312
    pe_start = (u8 )0;
  }
#line 316
  if (pe_start > 0ULL) {
    {
#line 317
    analyze_recursive(section, level + 1, pe_start, (u8 )0, 0);
    }
  }
#line 321
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_linux_lvm2(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int at ;
  int i ;
  char s[256] ;
  u8 labelsector ;
  u4 labeloffset ;
  u8 pvsize ;
  u8 mdoffset ;
  u8 mdsize ;
  int mda_version ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  u4 tmp___5 ;

  {
#line 337
  at = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (at < 4)) {
#line 337
      goto while_break;
    }
    {
#line 338
    tmp = get_buffer(section, (u8 )(at * 512), (u8 )512, (void **)(& buf));
    }
#line 338
    if (tmp < 512ULL) {
#line 339
      goto __Cont;
    }
    {
#line 342
    tmp___0 = memcmp((void const   *)buf, (void const   *)"LABELONE", (size_t )8);
    }
#line 342
    if (tmp___0 != 0) {
#line 343
      goto __Cont;
    }
    {
#line 345
    labelsector = get_le_quad((void *)(buf + 8));
#line 346
    labeloffset = get_le_long((void *)(buf + 20));
#line 348
    tmp___1 = memcmp((void const   *)(buf + 24), (void const   *)"LVM2 001", (size_t )8);
    }
#line 348
    if (tmp___1 != 0) {
      {
#line 349
      get_string((void *)(buf + 24), 8, s);
#line 350
      print_line(level, "LABELONE label at sector %d, unknown type \"%s\"", at, s);
      }
#line 352
      return;
    }
    {
#line 355
    print_line(level, "Linux LVM2 volume, version 001");
#line 356
    print_line(level + 1, "LABELONE label at sector %d", at);
    }
#line 359
    if (labeloffset >= 512UL) {
      {
#line 361
      print_line(level + 1, "LABELONE data inconsistent, aborting analysis");
      }
#line 362
      return;
    } else
#line 359
    if (labelsector > 256ULL) {
      {
#line 361
      print_line(level + 1, "LABELONE data inconsistent, aborting analysis");
      }
#line 362
      return;
    } else
#line 359
    if (labelsector != (u8 )at) {
      {
#line 361
      print_line(level + 1, "LABELONE data inconsistent, aborting analysis");
      }
#line 362
      return;
    }
    {
#line 366
    format_uuid_lvm((void *)(buf + labeloffset), s);
#line 367
    print_line(level + 1, "PV UUID %s", s);
#line 370
    pvsize = get_le_quad((void *)((buf + labeloffset) + 32));
#line 371
    format_size_verbose(s, pvsize);
#line 372
    print_line(level + 1, "Volume size %s", s);
#line 375
    mdoffset = (u8 )0;
#line 376
    i = 0;
    }
    {
#line 376
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 376
      if (! (i < 16)) {
#line 376
        goto while_break___0;
      }
      {
#line 377
      tmp___2 = get_le_quad((void *)(((buf + labeloffset) + 40) + i * 16));
      }
#line 377
      if (tmp___2 == 0ULL) {
        {
#line 378
        i ++;
#line 379
        mdoffset = get_le_quad((void *)(((buf + labeloffset) + 40) + i * 16));
#line 380
        mdsize = get_le_quad((void *)((((buf + labeloffset) + 40) + i * 16) + 8));
        }
#line 381
        goto while_break___0;
      }
#line 376
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    if (mdoffset == 0ULL) {
#line 384
      return;
    }
    {
#line 386
    tmp___3 = get_buffer(section, mdoffset, mdsize, (void **)(& buf));
    }
#line 386
    if (tmp___3 < mdsize) {
#line 387
      return;
    }
    {
#line 389
    tmp___4 = memcmp((void const   *)(buf + 4), (void const   *)" LVM2 x[5A%r0N*>",
                     (size_t )16);
    }
#line 389
    if (tmp___4 != 0) {
#line 390
      return;
    }
    {
#line 391
    tmp___5 = get_le_long((void *)(buf + 20));
#line 391
    mda_version = (int )tmp___5;
#line 393
    print_line(level + 1, "Meta-data version %d", mda_version);
    }
#line 397
    return;
    __Cont: /* CIL Label */ 
#line 337
    at ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_linux_swap(SECTION *section , int level ) 
{ 
  int i ;
  int en ;
  int pagesize ;
  unsigned char *buf ;
  u4 version ;
  u4 pages ;
  char s[256] ;
  int pagesizes[3] ;
  u8 tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  char const   *tmp___2 ;
  u4 tmp___3 ;
  int tmp___4 ;

  {
#line 411
  pagesizes[0] = 4096;
#line 411
  pagesizes[1] = 8192;
#line 411
  pagesizes[2] = 0;
#line 413
  i = 0;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! pagesizes[i]) {
#line 413
      goto while_break;
    }
    {
#line 414
    pagesize = pagesizes[i];
#line 416
    tmp = get_buffer(section, (u8 )(pagesize - 512), (u8 )512, (void **)(& buf));
    }
#line 416
    if (tmp != 512ULL) {
#line 417
      goto while_break;
    }
    {
#line 419
    tmp___0 = memcmp((void const   *)(((char *)buf + 512) - 10), (void const   *)"SWAP-SPACE",
                     (size_t )10);
    }
#line 419
    if (tmp___0 == 0) {
      {
#line 420
      print_line(level, "Linux swap, version 1, %d KiB pages", pagesize >> 10);
      }
    }
    {
#line 423
    tmp___4 = memcmp((void const   *)(((char *)buf + 512) - 10), (void const   *)"SWAPSPACE2",
                     (size_t )10);
    }
#line 423
    if (tmp___4 == 0) {
      {
#line 424
      tmp___1 = get_buffer(section, (u8 )1024, (u8 )512, (void **)(& buf));
      }
#line 424
      if (tmp___1 != 512ULL) {
#line 425
        goto while_break;
      }
#line 427
      en = 0;
      {
#line 427
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 427
        if (! (en < 2)) {
#line 427
          goto while_break___0;
        }
        {
#line 428
        version = get_ve_long(en, (void *)buf);
        }
#line 429
        if (version >= 1UL) {
#line 429
          if (version < 10UL) {
#line 430
            goto while_break___0;
          }
        }
#line 427
        en ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 432
      if (en < 2) {
        {
#line 433
        tmp___2 = get_ve_name(en);
#line 433
        print_line(level, "Linux swap, version 2, subversion %d, %d KiB pages, %s",
                   (int )version, pagesize >> 10, tmp___2);
        }
#line 435
        if (version == 1UL) {
          {
#line 436
          tmp___3 = get_ve_long(en, (void *)(buf + 4));
#line 436
          pages = tmp___3 - 1UL;
#line 437
          format_blocky_size(s, (u8 )pages, (u4 )pagesize, "pages", (char const   *)((void *)0));
#line 438
          print_line(level + 1, "Swap size %s", s);
          }
        }
      } else {
        {
#line 441
        print_line(level, "Linux swap, version 2, illegal subversion, %d KiB pages",
                   pagesize >> 10);
        }
      }
    }
#line 413
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_linux_misc(SECTION *section , int level ) 
{ 
  int magic ;
  int fill ;
  int off ;
  int en ;
  unsigned char *buf ;
  char s[256] ;
  u8 size ;
  u8 blocks ;
  u8 blocksize ;
  u8 tmp ;
  int version ;
  int namesize ;
  u2 tmp___0 ;
  u2 tmp___1 ;
  u4 tmp___2 ;
  u2 tmp___3 ;
  u2 tmp___4 ;
  u4 tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  u4 tmp___8 ;
  u4 tmp___9 ;
  u4 tmp___10 ;
  int major ;
  int minor ;
  u2 tmp___11 ;
  u2 tmp___12 ;
  char const   *tmp___13 ;
  u4 tmp___14 ;
  u4 tmp___15 ;
  u2 tmp___16 ;
  u4 tmp___17 ;

  {
  {
#line 459
  tmp = get_buffer(section, (u8 )0, (u8 )2048, (void **)(& buf));
#line 459
  fill = (int )tmp;
  }
#line 460
  if (fill < 512) {
#line 461
    return;
  }
#line 464
  if (fill >= 2048) {
    {
#line 465
    version = 0;
#line 465
    namesize = 14;
#line 467
    tmp___0 = get_le_short((void *)((buf + 1024) + 16));
#line 467
    magic = (int )tmp___0;
    }
#line 468
    if (magic == 4991) {
#line 469
      version = 1;
    }
#line 470
    if (magic == 5007) {
#line 471
      version = 1;
#line 472
      namesize = 30;
    }
#line 474
    if (magic == 9320) {
#line 475
      version = 2;
    }
#line 476
    if (magic == 9336) {
#line 477
      version = 2;
#line 478
      namesize = 30;
    }
#line 480
    if (version) {
      {
#line 481
      print_line(level, "Minix file system (v%d, %d chars)", version, namesize);
      }
#line 483
      if (version == 1) {
        {
#line 484
        tmp___1 = get_le_short((void *)((buf + 1024) + 2));
#line 484
        blocks = (u8 )tmp___1;
        }
      } else {
        {
#line 486
        tmp___2 = get_le_long((void *)((buf + 1024) + 20));
#line 486
        blocks = (u8 )tmp___2;
        }
      }
      {
#line 487
      tmp___3 = get_le_short((void *)((buf + 1024) + 8));
#line 487
      tmp___4 = get_le_short((void *)((buf + 1024) + 10));
#line 487
      blocks = (blocks - (u8 )tmp___3) << (int )tmp___4;
#line 489
      format_blocky_size(s, blocks, (u4 )1024, "blocks", (char const   *)((void *)0));
#line 490
      print_line(level + 1, "Volume size %s", s);
      }
    }
  }
  {
#line 495
  tmp___6 = memcmp((void const   *)buf, (void const   *)"-rom1fs-", (size_t )8);
  }
#line 495
  if (tmp___6 == 0) {
    {
#line 496
    tmp___5 = get_be_long((void *)(buf + 8));
#line 496
    size = (u8 )tmp___5;
#line 497
    print_line(level, "Linux romfs");
#line 498
    print_line(level + 1, "Volume name \"%.300s\"", (char *)(buf + 16));
#line 499
    format_size_verbose(s, size);
#line 500
    print_line(level + 1, "Volume size %s", s);
    }
  }
#line 504
  off = 0;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (off <= 512)) {
#line 504
      goto while_break;
    }
#line 505
    if (fill < off + 512) {
#line 506
      goto while_break;
    }
#line 507
    en = 0;
    {
#line 507
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 507
      if (! (en < 2)) {
#line 507
        goto while_break___0;
      }
      {
#line 508
      tmp___10 = get_ve_long(en, (void *)(buf + off));
      }
#line 508
      if (tmp___10 == 684539205UL) {
        {
#line 509
        tmp___7 = get_ve_name(en);
#line 509
        print_line(level, "Linux cramfs, starts sector %d, %s", off >> 9, tmp___7);
#line 512
        get_string((void *)((buf + off) + 48), 16, s);
#line 513
        print_line(level + 1, "Volume name \"%s\"", s);
#line 515
        tmp___8 = get_ve_long(en, (void *)((buf + off) + 4));
#line 515
        size = (u8 )tmp___8;
#line 516
        tmp___9 = get_ve_long(en, (void *)((buf + off) + 40));
#line 516
        blocks = (u8 )tmp___9;
#line 517
        format_size_verbose(s, size);
#line 518
        print_line(level + 1, "Compressed size %s", s);
#line 519
        format_blocky_size(s, blocks, (u4 )4096, "blocks", " -assumed-");
#line 520
        print_line(level + 1, "Data size %s", s);
        }
      }
#line 507
      en ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 504
    off += 512;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  en = 0;
  {
#line 526
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 526
    if (! (en < 2)) {
#line 526
      goto while_break___1;
    }
    {
#line 527
    tmp___17 = get_ve_long(en, (void *)buf);
    }
#line 527
    if (tmp___17 == 1936814952UL) {
      {
#line 530
      tmp___11 = get_ve_short(en, (void *)(buf + 28));
#line 530
      major = (int )tmp___11;
#line 531
      tmp___12 = get_ve_short(en, (void *)(buf + 30));
#line 531
      minor = (int )tmp___12;
#line 532
      tmp___13 = get_ve_name(en);
#line 532
      print_line(level, "Linux squashfs, version %d.%d, %s", major, minor, tmp___13);
      }
#line 535
      if (major > 2) {
        {
#line 536
        size = get_ve_quad(en, (void *)(buf + 63));
        }
      } else {
        {
#line 538
        tmp___14 = get_ve_long(en, (void *)(buf + 8));
#line 538
        size = (u8 )tmp___14;
        }
      }
#line 539
      if (major > 1) {
        {
#line 540
        tmp___15 = get_ve_long(en, (void *)(buf + 51));
#line 540
        blocksize = (u8 )tmp___15;
        }
      } else {
        {
#line 542
        tmp___16 = get_ve_short(en, (void *)(buf + 32));
#line 542
        blocksize = (u8 )tmp___16;
        }
      }
      {
#line 544
      format_size_verbose(s, size);
#line 545
      print_line(level + 1, "Compressed size %s", s);
#line 546
      format_size(s, blocksize);
#line 547
      print_line(level + 1, "Block size %s", s);
      }
    }
#line 526
    en ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 550
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/disktype-9/linux.c"
void detect_linux_loader(SECTION *section , int level ) 
{ 
  int fill ;
  int executable ;
  int id ;
  unsigned char *buf ;
  u8 tmp ;
  u2 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *name ;
  char *number ;
  char *total ;
  int tmp___8 ;

  {
#line 561
  if (section->flags & 1) {
#line 562
    return;
  }
  {
#line 564
  tmp = get_buffer(section, (u8 )0, (u8 )2048, (void **)(& buf));
#line 564
  fill = (int )tmp;
  }
#line 565
  if (fill < 512) {
#line 566
    return;
  }
  {
#line 568
  tmp___1 = get_le_short((void *)(buf + 510));
  }
#line 568
  if ((int )tmp___1 == 43605) {
#line 568
    executable = 1;
  } else {
#line 568
    executable = 0;
  }
#line 571
  if (executable) {
    {
#line 571
    tmp___2 = memcmp((void const   *)(buf + 2), (void const   *)"LILO", (size_t )4);
    }
#line 571
    if (tmp___2 == 0) {
      {
#line 573
      print_line(level, "LILO boot loader");
      }
    } else {
      {
#line 571
      tmp___3 = memcmp((void const   *)(buf + 6), (void const   *)"LILO", (size_t )4);
      }
#line 571
      if (tmp___3 == 0) {
        {
#line 573
        print_line(level, "LILO boot loader");
        }
      }
    }
  }
#line 574
  if (executable) {
    {
#line 574
    tmp___4 = memcmp((void const   *)(buf + 3), (void const   *)"SYSLINUX", (size_t )8);
    }
#line 574
    if (tmp___4 == 0) {
      {
#line 575
      print_line(level, "SYSLINUX boot loader");
      }
    }
  }
#line 576
  if (fill >= 1024) {
    {
#line 576
    tmp___5 = find_memory((void *)buf, fill, (void *)"ISOLINUX", 8);
    }
#line 576
    if (tmp___5 >= 0) {
      {
#line 577
      print_line(level, "ISOLINUX boot loader");
      }
    }
  }
#line 580
  if (executable) {
    {
#line 580
    tmp___6 = find_memory((void *)buf, 512, (void *)"Geom\000Hard Disk\000Read\000 Error\000",
                          27);
    }
#line 580
    if (tmp___6 >= 0) {
#line 582
      if ((int )*(buf + 62) == 3) {
        {
#line 583
        print_line(level, "GRUB boot loader, compat version %d.%d, boot drive 0x%02x",
                   (int )*(buf + 62), (int )*(buf + 63), (int )*(buf + 64));
        }
      } else
#line 585
      if (executable) {
#line 585
        if ((int )*(buf + 444) == 2) {
#line 585
          if ((int )*(buf + 445) <= 2) {
#line 586
            id = (int )*(buf + 62);
#line 587
            if (id == 16) {
              {
#line 588
              print_line(level, "GRUB boot loader, compat version %d.%d, normal version",
                         (int )*(buf + 444), (int )*(buf + 445));
              }
            } else
#line 590
            if (id == 32) {
              {
#line 591
              print_line(level, "GRUB boot loader, compat version %d.%d, LBA version",
                         (int )*(buf + 444), (int )*(buf + 445));
              }
            } else {
              {
#line 594
              print_line(level, "GRUB boot loader, compat version %d.%d", (int )*(buf + 444),
                         (int )*(buf + 445));
              }
            }
          } else {
            {
#line 598
            print_line(level, "GRUB boot loader, unknown compat version %d", (int )*(buf + 62));
            }
          }
        } else {
          {
#line 598
          print_line(level, "GRUB boot loader, unknown compat version %d", (int )*(buf + 62));
          }
        }
      } else {
        {
#line 598
        print_line(level, "GRUB boot loader, unknown compat version %d", (int )*(buf + 62));
        }
      }
    }
  }
#line 604
  if (fill >= 1024) {
    {
#line 604
    tmp___7 = memcmp((void const   *)((buf + 512) + 2), (void const   *)"HdrS", (size_t )4);
    }
#line 604
    if (tmp___7 == 0) {
      {
#line 605
      print_line(level, "Linux kernel build-in loader");
      }
    }
  }
  {
#line 610
  tmp___8 = memcmp((void const   *)buf, (void const   *)"Floppy split ", (size_t )13);
  }
#line 610
  if (tmp___8 == 0) {
    {
#line 611
    name = (char *)buf + 32;
#line 612
    number = (char *)buf + 164;
#line 613
    total = (char *)buf + 172;
#line 614
    print_line(level, "Debian floppy split, name \"%s\", disk %s of %s", name, number,
               total);
    }
  }
#line 617
  return;
}
}
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
int analyze_cdaccess(int fd , SOURCE *s , int level ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
static int analyze_file___0(SOURCE *s , int level ) ;
#line 61
static u8 read_file(SOURCE *s , u8 pos , u8 len , void *buf ) ;
#line 62
static void close_file(SOURCE *s ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
SOURCE *init_file_source(int fd , int filekind ) 
{ 
  FILE_SOURCE *fs ;
  off_t result ;
  void *tmp ;
  u8 devsize ;
  int tmp___0 ;
  u4 blockcount ;
  int tmp___1 ;

  {
  {
#line 77
  tmp = malloc(sizeof(FILE_SOURCE ));
#line 77
  fs = (FILE_SOURCE *)tmp;
  }
#line 78
  if ((unsigned long )fs == (unsigned long )((void *)0)) {
    {
#line 79
    bailout("Out of memory");
    }
  }
  {
#line 80
  memset((void *)fs, 0, sizeof(FILE_SOURCE ));
  }
#line 82
  if (filekind != 0) {
#line 83
    fs->c.analyze = & analyze_file___0;
  }
#line 84
  fs->c.read_bytes = & read_file;
#line 85
  fs->c.close = & close_file;
#line 86
  fs->fd = fd;
#line 97
  if (! fs->c.size_known) {
    {
#line 98
    result = lseek(fd, (__off64_t )0, 2);
    }
#line 102
    if (result > 0L) {
#line 103
      fs->c.size_known = 1;
#line 104
      fs->c.size = (u8 )result;
    }
  }
#line 115
  if (! fs->c.size_known) {
#line 115
    if (filekind != 0) {
      {
#line 117
      tmp___0 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(18 << 8)) | 114U) | (sizeof(size_t ) << 16),
                      (void *)(& devsize));
      }
#line 117
      if (tmp___0 >= 0) {
#line 118
        fs->c.size_known = 1;
#line 119
        fs->c.size = devsize;
      }
    }
  }
#line 128
  if (! fs->c.size_known) {
#line 128
    if (filekind != 0) {
      {
#line 130
      tmp___1 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 96U), (void *)(& blockcount));
      }
#line 130
      if (tmp___1 >= 0) {
#line 131
        fs->c.size_known = 1;
#line 132
        fs->c.size = (u8 )blockcount * 512ULL;
      }
    }
  }
#line 219
  return ((SOURCE *)fs);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
static int analyze_file___0(SOURCE *s , int level ) 
{ 
  int tmp ;

  {
  {
#line 228
  tmp = analyze_cdaccess(((FILE_SOURCE *)s)->fd, s, level);
  }
#line 228
  if (tmp) {
#line 229
    return (1);
  }
#line 231
  return (0);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
static u8 read_file(SOURCE *s , u8 pos , u8 len , void *buf ) 
{ 
  off_t result_seek ;
  ssize_t result_read ;
  char *p ;
  u8 got ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 244
  fd = ((FILE_SOURCE *)s)->fd;
#line 247
  result_seek = lseek(fd, (__off64_t )pos, 0);
  }
#line 248
  if ((u8 )result_seek != pos) {
    {
#line 249
    errore("Seek to %llu failed", pos);
    }
#line 250
    return ((u8 )0);
  }
#line 254
  p = (char *)buf;
#line 255
  got = (u8 )0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (len > 0ULL)) {
#line 256
      goto while_break;
    }
    {
#line 257
    result_read = read(fd, (void *)p, (size_t )len);
    }
#line 258
    if (result_read < 0L) {
      {
#line 259
      tmp = __errno_location();
      }
#line 259
      if (*tmp == 4) {
#line 260
        goto while_continue;
      } else {
        {
#line 259
        tmp___0 = __errno_location();
        }
#line 259
        if (*tmp___0 == 11) {
#line 260
          goto while_continue;
        }
      }
      {
#line 261
      errore("Data read failed at position %llu", pos + got);
      }
#line 262
      goto while_break;
    } else
#line 263
    if (result_read == 0L) {
#line 265
      goto while_break;
    } else {
#line 267
      len -= (u8 )result_read;
#line 268
      got += (u8 )result_read;
#line 269
      p += result_read;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return (got);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/disktype-9/file.c"
static void close_file(SOURCE *s ) 
{ 
  int fd ;

  {
#line 282
  fd = ((FILE_SOURCE *)s)->fd;
#line 284
  if (fd >= 0) {
    {
#line 285
    close(fd);
    }
  }
#line 286
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
char *get_name_for_mbrtype(int type ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
struct systypes i386_sys_types[92]  = 
#line 42 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
  {      {(unsigned char)0, (char *)"Empty"}, 
        {(unsigned char)1, (char *)"FAT12"}, 
        {(unsigned char)2, (char *)"XENIX root"}, 
        {(unsigned char)3, (char *)"XENIX usr"}, 
        {(unsigned char)4, (char *)"FAT16 <32M"}, 
        {(unsigned char)5, (char *)"Extended"}, 
        {(unsigned char)6, (char *)"FAT16"}, 
        {(unsigned char)7, (char *)"HPFS/NTFS"}, 
        {(unsigned char)8, (char *)"AIX"}, 
        {(unsigned char)9, (char *)"AIX bootable"}, 
        {(unsigned char)10, (char *)"OS/2 Boot Manager"}, 
        {(unsigned char)11, (char *)"Win95 FAT32"}, 
        {(unsigned char)12, (char *)"Win95 FAT32 (LBA)"}, 
        {(unsigned char)14, (char *)"Win95 FAT16 (LBA)"}, 
        {(unsigned char)15, (char *)"Win95 Ext\'d (LBA)"}, 
        {(unsigned char)16, (char *)"OPUS"}, 
        {(unsigned char)17, (char *)"Hidden FAT12"}, 
        {(unsigned char)18, (char *)"Compaq diagnostics"}, 
        {(unsigned char)20, (char *)"Hidden FAT16 <32M"}, 
        {(unsigned char)22, (char *)"Hidden FAT16"}, 
        {(unsigned char)23, (char *)"Hidden HPFS/NTFS"}, 
        {(unsigned char)24, (char *)"AST SmartSleep"}, 
        {(unsigned char)27, (char *)"Hidden Win95 FAT32"}, 
        {(unsigned char)28, (char *)"Hidden Win95 FAT32 (LBA)"}, 
        {(unsigned char)30, (char *)"Hidden Win95 FAT16 (LBA)"}, 
        {(unsigned char)36, (char *)"NEC DOS"}, 
        {(unsigned char)57, (char *)"Plan 9"}, 
        {(unsigned char)60, (char *)"PartitionMagic recovery"}, 
        {(unsigned char)64, (char *)"Venix 80286"}, 
        {(unsigned char)65, (char *)"PPC PReP Boot"}, 
        {(unsigned char)66, (char *)"SFS / MS LDM"}, 
        {(unsigned char)77, (char *)"QNX4.x"}, 
        {(unsigned char)78, (char *)"QNX4.x 2nd part"}, 
        {(unsigned char)79, (char *)"QNX4.x 3rd part"}, 
        {(unsigned char)80, (char *)"OnTrack DM"}, 
        {(unsigned char)81, (char *)"OnTrack DM6 Aux1"}, 
        {(unsigned char)82, (char *)"CP/M"}, 
        {(unsigned char)83, (char *)"OnTrack DM6 Aux3"}, 
        {(unsigned char)84, (char *)"OnTrackDM6"}, 
        {(unsigned char)85, (char *)"EZ-Drive"}, 
        {(unsigned char)86, (char *)"Golden Bow"}, 
        {(unsigned char)92, (char *)"Priam Edisk"}, 
        {(unsigned char)97, (char *)"SpeedStor"}, 
        {(unsigned char)99, (char *)"GNU HURD or SysV"}, 
        {(unsigned char)100, (char *)"Novell Netware 286"}, 
        {(unsigned char)101, (char *)"Novell Netware 386"}, 
        {(unsigned char)112, (char *)"DiskSecure Multi-Boot"}, 
        {(unsigned char)117, (char *)"PC/IX"}, 
        {(unsigned char)120, (char *)"XOSL"}, 
        {(unsigned char)128, (char *)"Old Minix"}, 
        {(unsigned char)129, (char *)"Minix / old Linux"}, 
        {(unsigned char)130, (char *)"Linux swap / Solaris"}, 
        {(unsigned char)131, (char *)"Linux"}, 
        {(unsigned char)132, (char *)"OS/2 hidden C: drive"}, 
        {(unsigned char)133, (char *)"Linux extended"}, 
        {(unsigned char)134, (char *)"NTFS volume set"}, 
        {(unsigned char)135, (char *)"NTFS volume set"}, 
        {(unsigned char)142, (char *)"Linux LVM"}, 
        {(unsigned char)147, (char *)"Amoeba"}, 
        {(unsigned char)148, (char *)"Amoeba BBT"}, 
        {(unsigned char)159, (char *)"BSD/OS"}, 
        {(unsigned char)160, (char *)"IBM Thinkpad hibernation"}, 
        {(unsigned char)165, (char *)"FreeBSD"}, 
        {(unsigned char)166, (char *)"OpenBSD"}, 
        {(unsigned char)167, (char *)"NeXTSTEP"}, 
        {(unsigned char)169, (char *)"NetBSD"}, 
        {(unsigned char)175, (char *)"Mac OS X"}, 
        {(unsigned char)183, (char *)"BSDI fs"}, 
        {(unsigned char)184, (char *)"BSDI swap"}, 
        {(unsigned char)187, (char *)"Boot Wizard hidden"}, 
        {(unsigned char)193, (char *)"DRDOS/sec (FAT-12)"}, 
        {(unsigned char)196, (char *)"DRDOS/sec (FAT-16 < 32M)"}, 
        {(unsigned char)198, (char *)"DRDOS/sec (FAT-16)"}, 
        {(unsigned char)199, (char *)"Syrinx"}, 
        {(unsigned char)218, (char *)"Non-FS data"}, 
        {(unsigned char)219, (char *)"CP/M / CTOS / ..."}, 
        {(unsigned char)222, (char *)"Dell Utility"}, 
        {(unsigned char)223, (char *)"BootIt"}, 
        {(unsigned char)225, (char *)"DOS access"}, 
        {(unsigned char)227, (char *)"DOS R/O"}, 
        {(unsigned char)228, (char *)"SpeedStor"}, 
        {(unsigned char)235, (char *)"BeOS fs"}, 
        {(unsigned char)238, (char *)"EFI GPT protective"}, 
        {(unsigned char)239, (char *)"EFI System (FAT)"}, 
        {(unsigned char)240, (char *)"Linux/PA-RISC boot"}, 
        {(unsigned char)241, (char *)"SpeedStor"}, 
        {(unsigned char)244, (char *)"SpeedStor"}, 
        {(unsigned char)242, (char *)"DOS secondary"}, 
        {(unsigned char)253, (char *)"Linux raid autodetect"}, 
        {(unsigned char)254, (char *)"LANstep"}, 
        {(unsigned char)255, (char *)"BBT"}, 
        {(unsigned char)0, (char *)0}};
#line 138 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
char *get_name_for_mbrtype(int type ) 
{ 
  int i ;

  {
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! i386_sys_types[i].name) {
#line 142
      goto while_break;
    }
#line 143
    if ((int )i386_sys_types[i].type == type) {
#line 144
      return (i386_sys_types[i].name);
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return ((char *)"Unknown");
}
}
#line 152
static void detect_dos_partmap_ext(SECTION *section , u8 extbase , int level , int *extpartnum ) ;
#line 155 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
void detect_dos_partmap(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int i ;
  int off ;
  int used ;
  int type ;
  int types[4] ;
  int bootflags[4] ;
  u4 start ;
  u4 size ;
  u4 starts[4] ;
  u4 sizes[4] ;
  int extpartnum ;
  char s[256] ;
  char append[64] ;
  u8 tmp ;
  char *tmp___0 ;

  {
#line 160
  extpartnum = 5;
#line 164
  if (section->pos != 0ULL) {
#line 165
    return;
  }
  {
#line 167
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 167
  if (tmp < 512ULL) {
#line 168
    return;
  }
#line 171
  if ((int )*(buf + 510) != 85) {
#line 172
    return;
  } else
#line 171
  if ((int )*(buf + 511) != 170) {
#line 172
    return;
  }
#line 175
  used = 0;
#line 176
  off = 446;
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 4)) {
#line 176
      goto while_break;
    }
    {
#line 178
    bootflags[i] = (int )*(buf + off);
#line 179
    types[i] = (int )*(buf + (off + 4));
#line 180
    starts[i] = get_le_long((void *)((buf + off) + 8));
#line 181
    sizes[i] = get_le_long((void *)((buf + off) + 12));
    }
#line 184
    if (bootflags[i] != 0) {
#line 184
      if (bootflags[i] != 128) {
#line 185
        return;
      }
    }
#line 187
    if (starts[i]) {
#line 187
      if (sizes[i]) {
#line 188
        used = 1;
      }
    }
#line 176
    i ++;
#line 176
    off += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  if (! used) {
#line 191
    return;
  }
  {
#line 194
  print_line(level, "DOS/MBR partition map");
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < 4)) {
#line 195
      goto while_break___0;
    }
#line 196
    start = starts[i];
#line 197
    size = sizes[i];
#line 198
    type = types[i];
#line 199
    if (start == 0UL) {
#line 200
      goto __Cont;
    } else
#line 199
    if (size == 0UL) {
#line 200
      goto __Cont;
    }
    {
#line 202
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %lu",
            start);
    }
#line 203
    if (bootflags[i] == 128) {
      {
#line 204
      strcat((char */* __restrict  */)(append), (char const   */* __restrict  */)", bootable");
      }
    }
    {
#line 205
    format_blocky_size(s, (u8 )size, (u4 )512, "sectors", (char const   *)(append));
#line 206
    print_line(level, "Partition %d: %s", i + 1, s);
#line 209
    tmp___0 = get_name_for_mbrtype(type);
#line 209
    print_line(level + 1, "Type 0x%02X (%s)", type, tmp___0);
    }
#line 211
    if (type == 5) {
      {
#line 213
      detect_dos_partmap_ext(section, (u8 )start, level + 1, & extpartnum);
      }
    } else
#line 211
    if (type == 15) {
      {
#line 213
      detect_dos_partmap_ext(section, (u8 )start, level + 1, & extpartnum);
      }
    } else
#line 211
    if (type == 133) {
      {
#line 213
      detect_dos_partmap_ext(section, (u8 )start, level + 1, & extpartnum);
      }
    } else
#line 214
    if (type != 238) {
      {
#line 216
      analyze_recursive(section, level + 1, (u8 )start * 512ULL, (u8 )size * 512ULL,
                        0);
      }
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
static void detect_dos_partmap_ext(SECTION *section , u8 extbase , int level , int *extpartnum ) 
{ 
  unsigned char *buf ;
  u8 tablebase ;
  u8 nexttablebase ;
  int i ;
  int off ;
  int type ;
  int types[4] ;
  u4 start ;
  u4 size ;
  u4 starts[4] ;
  u4 sizes[4] ;
  char s[256] ;
  char append[64] ;
  u8 tmp ;
  char *tmp___0 ;

  {
#line 231
  tablebase = extbase;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! tablebase) {
#line 231
      goto while_break;
    }
    {
#line 233
    tmp = get_buffer(section, tablebase << 9, (u8 )512, (void **)(& buf));
    }
#line 233
    if (tmp < 512ULL) {
#line 234
      return;
    }
#line 237
    if ((int )*(buf + 510) != 85) {
      {
#line 238
      print_line(level, "Signature missing");
      }
#line 239
      return;
    } else
#line 237
    if ((int )*(buf + 511) != 170) {
      {
#line 238
      print_line(level, "Signature missing");
      }
#line 239
      return;
    }
#line 243
    off = 446;
#line 243
    i = 0;
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if (! (i < 4)) {
#line 243
        goto while_break___0;
      }
      {
#line 244
      types[i] = (int )*(buf + (off + 4));
#line 245
      starts[i] = get_le_long((void *)((buf + off) + 8));
#line 246
      sizes[i] = get_le_long((void *)((buf + off) + 12));
#line 243
      i ++;
#line 243
      off += 16;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 250
    nexttablebase = (u8 )0;
#line 251
    i = 0;
    {
#line 251
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 251
      if (! (i < 4)) {
#line 251
        goto while_break___1;
      }
#line 252
      start = starts[i];
#line 253
      size = sizes[i];
#line 254
      type = types[i];
#line 255
      if (size == 0UL) {
#line 256
        goto __Cont;
      }
#line 258
      if (type == 5) {
#line 261
        nexttablebase = extbase + (u8 )start;
      } else
#line 258
      if (type == 133) {
#line 261
        nexttablebase = extbase + (u8 )start;
      } else {
        {
#line 266
        sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %llu+%lu",
                tablebase, start);
#line 267
        format_blocky_size(s, (u8 )size, (u4 )512, "sectors", (char const   *)(append));
#line 268
        print_line(level, "Partition %d: %s", *extpartnum, s);
#line 270
        (*extpartnum) ++;
#line 271
        tmp___0 = get_name_for_mbrtype(type);
#line 271
        print_line(level + 1, "Type 0x%02X (%s)", type, tmp___0);
        }
#line 274
        if (type != 238) {
          {
#line 275
          analyze_recursive(section, level + 1, (tablebase + (u8 )start) * 512ULL,
                            (u8 )size * 512ULL, 0);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 251
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 231
    tablebase = nexttablebase;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
struct gpttypes gpt_types[18]  = 
#line 292
  {      {(char *)"(s*\301\037\370\322\021\272K\000\240\311>\311;", (char *)"EFI System (FAT)"}, 
        {(char *)"A\356M\002\3473\323\021\235i\000\b\307\201\363\237",
      (char *)"MBR partition scheme"}, 
        {(char *)"\026\343\311\343\\\v\270M\201}\371-\360\002\025\256", (char *)"MS Reserved"}, 
        {(char *)"\242\240\320\353\345\2713D\207\300h\266\267&\231\307",
      (char *)"Basic Data"}, 
        {(char *)"\252\310\bX\217~\340B\205\322\341\351\0044\317\263", (char *)"MS LDM Metadata"}, 
        {(char *)"\240`\233\2571\024bO\274h3\021qJi\255",
      (char *)"MS LDM Data"}, 
        {(char *)"\036L\211u\353:\323\021\267\301{\003\240\000\000\000", (char *)"HP/UX Data"}, 
        {(char *)"(\347\241\342\3432\326\021\246\202{\003\240\000\000\000",
      (char *)"HP/UX Service"}, 
        {(char *)"\017\210\235\241\374\005;M\240\006t?\017\204\221\036", (char *)"Linux RAID"}, 
        {(char *)"m\375W\006\253\244\304C\204\345\t3\310KOO",
      (char *)"Linux Swap"}, 
        {(char *)"y\323\326\346\a\365\302D\242<#\217*=\371(", (char *)"Linux LVM"}, 
        {(char *)"93\246\215\a\000\300`\3046\b:\310#\t\b", (char *)"Linux Reserved"}, 
        {(char *)"\264|nQ\317n\326\021\217\370\000\002-\tq+",
      (char *)"FreeBSD Data"}, 
        {(char *)"\265|nQ\317n\326\021\217\370\000\002-\tq+", (char *)"FreeBSD Swap"}, 
        {(char *)"\266|nQ\317n\326\021\217\370\000\002-\tq+",
      (char *)"FreeBSD UFS"}, 
        {(char *)"\270|nQ\317n\326\021\217\370\000\002-\tq+", (char *)"FreeBSD Vinum"}, 
        {(char *)"\000SFH\000\000\252\021\252\021\0000eC\354\254",
      (char *)"Mac HFS+"}, 
        {(char *)0, (char *)0}};
#line 313 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
static char *get_name_for_guid(void *guid ) 
{ 
  int i ;
  int tmp ;

  {
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! gpt_types[i].name) {
#line 317
      goto while_break;
    }
    {
#line 318
    tmp = memcmp((void const   *)gpt_types[i].guid, (void const   *)guid, (size_t )16);
    }
#line 318
    if (tmp == 0) {
#line 319
      return (gpt_types[i].name);
    }
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return ((char *)"Unknown");
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
void detect_gpt_partmap(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u8 diskblocks ;
  u8 partmap_start ;
  u8 start ;
  u8 end ;
  u8 size ;
  u4 partmap_count ;
  u4 partmap_entry_size ;
  u4 i ;
  char s[256] ;
  char append[64] ;
  int last_unused ;
  u8 tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 333
  if (section->pos != 0ULL) {
#line 334
    return;
  }
  {
#line 337
  tmp = get_buffer(section, (u8 )512, (u8 )512, (void **)(& buf));
  }
#line 337
  if (tmp < 512ULL) {
#line 338
    return;
  }
  {
#line 341
  tmp___0 = memcmp((void const   *)buf, (void const   *)"EFI PART", (size_t )8);
  }
#line 341
  if (tmp___0 != 0) {
#line 342
    return;
  }
  {
#line 345
  tmp___1 = get_le_quad((void *)(buf + 24));
  }
#line 345
  if (tmp___1 != 1ULL) {
#line 346
    return;
  }
  {
#line 347
  tmp___2 = get_le_quad((void *)(buf + 32));
#line 347
  diskblocks = tmp___2 + 1ULL;
#line 348
  partmap_start = get_le_quad((void *)(buf + 72));
#line 349
  partmap_count = get_le_long((void *)(buf + 80));
#line 350
  partmap_entry_size = get_le_long((void *)(buf + 84));
#line 352
  print_line(level, "GPT partition map, %d entries", (int )partmap_count);
#line 353
  format_blocky_size(s, diskblocks, (u4 )512, "sectors", (char const   *)((void *)0));
#line 354
  print_line(level + 1, "Disk size %s", s);
#line 355
  format_guid((void *)(buf + 56), s);
#line 356
  print_line(level + 1, "Disk GUID %s", s);
#line 359
  last_unused = 0;
#line 360
  i = (u4 )0;
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < partmap_count)) {
#line 360
      goto while_break;
    }
    {
#line 361
    tmp___3 = get_buffer(section, partmap_start * 512ULL + (u8 )(i * partmap_entry_size),
                         (u8 )partmap_entry_size, (void **)(& buf));
    }
#line 361
    if (tmp___3 < (u8 )partmap_entry_size) {
#line 362
      return;
    }
    {
#line 364
    tmp___4 = memcmp((void const   *)buf, (void const   *)"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
                     (size_t )16);
    }
#line 364
    if (tmp___4 == 0) {
#line 365
      if (last_unused == 0) {
        {
#line 366
        print_line(level, "Partition %d: unused", i + 1UL);
        }
      }
#line 367
      last_unused = 1;
#line 368
      goto __Cont;
    }
    {
#line 370
    last_unused = 0;
#line 373
    start = get_le_quad((void *)(buf + 32));
#line 374
    end = get_le_quad((void *)(buf + 40));
#line 375
    size = (end + 1ULL) - start;
#line 377
    sprintf((char */* __restrict  */)(append), (char const   */* __restrict  */)" from %llu",
            start);
#line 378
    format_blocky_size(s, size, (u4 )512, "sectors", (char const   *)(append));
#line 379
    print_line(level, "Partition %d: %s", i + 1UL, s);
#line 382
    format_guid((void *)buf, s);
#line 383
    tmp___5 = get_name_for_guid((void *)buf);
#line 383
    print_line(level + 1, "Type %s (GUID %s)", tmp___5, s);
#line 386
    format_utf16_le((void *)(buf + 56), (u4 )72, s);
#line 387
    print_line(level + 1, "Partition Name \"%s\"", s);
#line 390
    format_guid((void *)(buf + 16), s);
#line 391
    print_line(level + 1, "Partition GUID %s", s);
    }
#line 394
    if (start > 0ULL) {
#line 394
      if (size > 0ULL) {
        {
#line 395
        analyze_recursive(section, level + 1, start * 512ULL, size * 512ULL, 0);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
static char *fatnames[3]  = {      (char *)"FAT12",      (char *)"FAT16",      (char *)"FAT32"};
#line 407 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
void detect_fat(SECTION *section , int level ) 
{ 
  int i ;
  int score ;
  int fattype ;
  u4 sectsize ;
  u4 clustersize ;
  u4 reserved ;
  u4 fatcount ;
  u4 dirsize ;
  u4 fatsize ;
  u8 sectcount ;
  u8 clustercount ;
  u2 atari_csum ;
  unsigned char *buf ;
  char s[256] ;
  u8 tmp ;
  u2 tmp___0 ;
  int tmp___1 ;
  u2 tmp___2 ;
  u2 tmp___3 ;
  u2 tmp___4 ;
  u4 tmp___5 ;
  u2 tmp___6 ;
  u2 tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 416
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 416
  if (tmp < 512ULL) {
#line 417
    return;
  }
  {
#line 421
  tmp___0 = get_le_short((void *)(buf + 11));
#line 421
  sectsize = (u4 )tmp___0;
  }
#line 422
  if (sectsize != 512UL) {
#line 422
    if (sectsize != 1024UL) {
#line 422
      if (sectsize != 2048UL) {
#line 422
        if (sectsize != 4096UL) {
#line 424
          return;
        }
      }
    }
  }
#line 426
  clustersize = (u4 )*(buf + 13);
#line 427
  if (clustersize == 0UL) {
#line 428
    return;
  } else
#line 427
  if (clustersize & (clustersize - 1UL)) {
#line 428
    return;
  }
  {
#line 430
  tmp___1 = memcmp((void const   *)(buf + 3), (void const   *)"NTFS    ", (size_t )8);
  }
#line 430
  if (tmp___1 == 0) {
#line 431
    return;
  }
#line 434
  score = 0;
#line 437
  if ((int )*(buf + 0) == 235) {
#line 437
    if ((int )*(buf + 2) == 144) {
#line 439
      score ++;
    } else {
#line 437
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 437
  if ((int )*(buf + 0) == 233) {
#line 439
    score ++;
  }
#line 441
  if ((int )*(buf + 510) == 85) {
#line 441
    if ((int )*(buf + 511) == 170) {
#line 442
      score ++;
    }
  }
  {
#line 444
  tmp___2 = get_le_short((void *)(buf + 14));
#line 444
  reserved = (u4 )tmp___2;
  }
#line 445
  if (reserved == 1UL) {
#line 446
    score ++;
  } else
#line 445
  if (reserved == 32UL) {
#line 446
    score ++;
  }
#line 448
  fatcount = (u4 )*(buf + 16);
#line 449
  if (fatcount == 2UL) {
#line 450
    score ++;
  }
  {
#line 452
  tmp___3 = get_le_short((void *)(buf + 17));
#line 452
  dirsize = (u4 )tmp___3;
#line 454
  tmp___4 = get_le_short((void *)(buf + 19));
#line 454
  sectcount = (u8 )tmp___4;
  }
#line 455
  if (sectcount == 0ULL) {
    {
#line 456
    tmp___5 = get_le_long((void *)(buf + 32));
#line 456
    sectcount = (u8 )tmp___5;
    }
  }
#line 458
  if ((int )*(buf + 21) == 240) {
#line 459
    score ++;
  } else
#line 458
  if ((int )*(buf + 21) >= 248) {
#line 459
    score ++;
  }
  {
#line 461
  tmp___6 = get_le_short((void *)(buf + 22));
#line 461
  fatsize = (u4 )tmp___6;
  }
#line 462
  if (fatsize == 0UL) {
    {
#line 463
    fatsize = get_le_long((void *)(buf + 36));
    }
  }
#line 466
  dirsize = (dirsize * 32UL + (sectsize - 1UL)) / sectsize;
#line 467
  clustercount = sectcount - (u8 )((reserved + fatcount * fatsize) + dirsize);
#line 468
  clustercount /= (u8 )clustersize;
#line 470
  if (clustercount < 4085ULL) {
#line 471
    fattype = 0;
  } else
#line 472
  if (clustercount < 65525ULL) {
#line 473
    fattype = 1;
  } else {
#line 475
    fattype = 2;
  }
#line 478
  atari_csum = (u2 )0;
#line 479
  i = 0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < 512)) {
#line 479
      goto while_break;
    }
    {
#line 480
    tmp___7 = get_be_short((void *)(buf + i));
#line 480
    atari_csum = (u2 )((int )atari_csum + (int )tmp___7);
#line 479
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  s[0] = (char)0;
#line 484
  if ((int )atari_csum == 4660) {
    {
#line 485
    strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)", ATARI ST bootable");
    }
  }
  {
#line 486
  print_line(level, "%s file system (hints score %d of %d%s)", fatnames[fattype],
             score, 5, s);
  }
#line 489
  if (sectsize > 512UL) {
    {
#line 490
    print_line(level + 1, "Unusual sector size %lu bytes", sectsize);
    }
  }
  {
#line 492
  format_blocky_size(s, clustercount, clustersize * sectsize, "clusters", (char const   *)((void *)0));
#line 494
  print_line(level + 1, "Volume size %s", s);
  }
#line 497
  if (fattype < 2) {
#line 498
    if ((int )*(buf + 38) == 41) {
      {
#line 499
      memcpy((void */* __restrict  */)(s), (void const   */* __restrict  */)(buf + 43),
             (size_t )11);
#line 500
      s[11] = (char)0;
#line 501
      i = 10;
      }
      {
#line 501
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 501
        if (i >= 0) {
#line 501
          if (! ((int )s[i] == 32)) {
#line 501
            goto while_break___0;
          }
        } else {
#line 501
          goto while_break___0;
        }
#line 502
        s[i] = (char)0;
#line 501
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 503
      tmp___8 = strcmp((char const   *)(s), "NO NAME");
      }
#line 503
      if (tmp___8 != 0) {
        {
#line 504
        print_line(level + 1, "Volume name \"%s\"", s);
        }
      }
    }
  } else
#line 507
  if ((int )*(buf + 66) == 41) {
    {
#line 508
    memcpy((void */* __restrict  */)(s), (void const   */* __restrict  */)(buf + 71),
           (size_t )11);
#line 509
    s[11] = (char)0;
#line 510
    i = 10;
    }
    {
#line 510
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 510
      if (i >= 0) {
#line 510
        if (! ((int )s[i] == 32)) {
#line 510
          goto while_break___1;
        }
      } else {
#line 510
        goto while_break___1;
      }
#line 511
      s[i] = (char)0;
#line 510
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 512
    tmp___9 = strcmp((char const   *)(s), "NO NAME");
    }
#line 512
    if (tmp___9 != 0) {
      {
#line 513
      print_line(level + 1, "Volume name \"%s\"", s);
      }
    }
  }
#line 516
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
void detect_ntfs(SECTION *section , int level ) 
{ 
  u4 sectsize ;
  u4 clustersize ;
  u8 sectcount ;
  unsigned char *buf ;
  char s[256] ;
  u8 tmp ;
  int tmp___0 ;
  u2 tmp___1 ;

  {
  {
#line 529
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
  }
#line 529
  if (tmp < 512ULL) {
#line 530
    return;
  }
  {
#line 533
  tmp___0 = memcmp((void const   *)(buf + 3), (void const   *)"NTFS    ", (size_t )8);
  }
#line 533
  if (tmp___0 != 0) {
#line 534
    return;
  }
  {
#line 541
  tmp___1 = get_le_short((void *)(buf + 11));
#line 541
  sectsize = (u4 )tmp___1;
  }
#line 542
  if (sectsize < 512UL) {
#line 543
    return;
  } else
#line 542
  if (sectsize & (sectsize - 1UL)) {
#line 543
    return;
  }
#line 545
  clustersize = (u4 )*(buf + 13);
#line 546
  if (clustersize == 0UL) {
#line 547
    return;
  } else
#line 546
  if (clustersize & (clustersize - 1UL)) {
#line 547
    return;
  }
  {
#line 550
  sectcount = get_le_quad((void *)(buf + 40));
#line 553
  print_line(level, "NTFS file system");
#line 555
  format_blocky_size(s, sectcount, sectsize, "sectors", (char const   *)((void *)0));
#line 556
  print_line(level + 1, "Volume size %s", s);
  }
#line 557
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
void detect_hpfs(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  char s[256] ;
  u8 sectcount ;
  u8 tmp ;
  int tmp___0 ;
  u4 tmp___1 ;

  {
  {
#line 569
  tmp = get_buffer(section, (u8 )8192, (u8 )512, (void **)(& buf));
  }
#line 569
  if (tmp < 512ULL) {
#line 570
    return;
  }
  {
#line 572
  tmp___0 = memcmp((void const   *)buf, (void const   *)"\371\225\350I\372S\351\305",
                   (size_t )8);
  }
#line 572
  if (tmp___0 != 0) {
#line 573
    return;
  }
  {
#line 575
  print_line(level, "HPFS file system (version %d, functional version %d)", (int )*(buf + 8),
             (int )*(buf + 9));
#line 578
  tmp___1 = get_le_long((void *)(buf + 16));
#line 578
  sectcount = (u8 )tmp___1;
#line 579
  format_blocky_size(s, sectcount, (u4 )512, "sectors", (char const   *)((void *)0));
#line 580
  print_line(level + 1, "Volume size %s", s);
  }
#line 583
  return;
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/disktype-9/dos.c"
void detect_dos_loader(SECTION *section , int level ) 
{ 
  int fill ;
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 594
  if (section->flags & 1) {
#line 595
    return;
  }
  {
#line 597
  tmp = get_buffer(section, (u8 )0, (u8 )2048, (void **)(& buf));
#line 597
  fill = (int )tmp;
  }
#line 598
  if (fill < 512) {
#line 599
    return;
  }
  {
#line 601
  tmp___2 = find_memory((void *)buf, fill, (void *)"NTLDR", 5);
  }
#line 601
  if (tmp___2 >= 0) {
    {
#line 602
    print_line(level, "Windows NTLDR boot loader");
    }
  } else {
    {
#line 603
    tmp___1 = find_memory((void *)buf, 512, (void *)"WINBOOT SYS", 11);
    }
#line 603
    if (tmp___1 >= 0) {
      {
#line 604
      print_line(level, "Windows 95/98/ME boot loader");
      }
    } else {
      {
#line 605
      tmp___0 = find_memory((void *)buf, 512, (void *)"MSDOS   SYS", 11);
      }
#line 605
      if (tmp___0 >= 0) {
        {
#line 606
        print_line(level, "Windows / MS-DOS boot loader");
        }
      }
    }
  }
#line 607
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
static SOURCE *init_vhd_source(SECTION *section , int level , u8 total_size , u8 sparse_offset ) ;
#line 55
static int read_block_vhd(SOURCE *s , u8 pos , void *buf ) ;
#line 56
static void close_vhd(SOURCE *s ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
void detect_vhd(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  int found ;
  int type ;
  u8 sparse_offset ;
  u8 total_size ;
  char s[256] ;
  SOURCE *src ;
  u8 tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  int tmp___2 ;
  u4 tmp___3 ;

  {
  {
#line 70
  found = 0;
#line 73
  tmp = get_buffer(section, (u8 )0, (u8 )511, (void **)(& buf));
  }
#line 73
  if (tmp < 511ULL) {
#line 74
    return;
  }
  {
#line 75
  tmp___0 = memcmp((void const   *)buf, (void const   *)"conectix", (size_t )8);
  }
#line 75
  if (tmp___0 == 0) {
#line 76
    found = 1;
  }
#line 80
  if (! found) {
#line 80
    if (section->size > 1024ULL) {
#line 80
      if (! (section->source)->sequential) {
        {
#line 81
        tmp___1 = get_buffer(section, section->size - 511ULL, (u8 )511, (void **)(& buf));
        }
#line 81
        if (tmp___1 < 511ULL) {
#line 82
          return;
        }
        {
#line 83
        tmp___2 = memcmp((void const   *)buf, (void const   *)"conectix", (size_t )8);
        }
#line 83
        if (tmp___2 == 0) {
#line 84
          found = 1;
        }
      }
    }
  }
#line 88
  if (! found) {
#line 89
    return;
  }
  {
#line 92
  tmp___3 = get_be_long((void *)(buf + 60));
#line 92
  type = (int )tmp___3;
#line 93
  total_size = get_be_quad((void *)(buf + 40));
  }
#line 95
  if (type == 2) {
    {
#line 96
    print_line(level, "Connectix Virtual PC hard disk image, fixed size");
    }
  } else
#line 97
  if (type == 3) {
    {
#line 98
    print_line(level, "Connectix Virtual PC hard disk image, dynamic size");
    }
  } else
#line 99
  if (type == 4) {
    {
#line 100
    print_line(level, "Connectix Virtual PC hard disk image, differential");
    }
  } else {
    {
#line 102
    print_line(level, "Connectix Virtual PC hard disk image, unknown type %d", type);
    }
  }
  {
#line 105
  format_size_verbose(s, total_size);
#line 106
  print_line(level + 1, "Disk size %s", s);
  }
#line 108
  if (type == 3) {
    {
#line 110
    sparse_offset = get_be_quad((void *)(buf + 16));
#line 112
    src = init_vhd_source(section, level, total_size, sparse_offset);
    }
#line 114
    if ((unsigned long )src != (unsigned long )((void *)0)) {
      {
#line 116
      analyze_source(src, level);
#line 117
      close_source(src);
      }
    }
  }
#line 121
  if (type == 3) {
    {
#line 122
    stop_detect();
    }
  } else
#line 121
  if (type == 4) {
    {
#line 122
    stop_detect();
    }
  }
#line 123
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
static SOURCE *init_vhd_source(SECTION *section , int level , u8 total_size , u8 sparse_offset ) 
{ 
  VHD_SOURCE *vs ;
  unsigned char *buf ;
  u8 map_offset ;
  u4 map_size ;
  char s[256] ;
  void *tmp ;
  u8 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u8 tmp___3 ;

  {
  {
#line 139
  tmp = malloc(sizeof(VHD_SOURCE ));
#line 139
  vs = (VHD_SOURCE *)tmp;
  }
#line 140
  if ((unsigned long )vs == (unsigned long )((void *)0)) {
    {
#line 141
    bailout("Out of memory");
    }
  }
  {
#line 142
  memset((void *)vs, 0, sizeof(VHD_SOURCE ));
#line 144
  vs->c.size_known = 1;
#line 145
  vs->c.size = total_size;
#line 146
  vs->c.blocksize = 512;
#line 147
  vs->c.foundation = section->source;
#line 148
  vs->c.read_block = & read_block_vhd;
#line 149
  vs->c.close = & close_vhd;
#line 150
  vs->off = section->pos;
#line 153
  tmp___0 = get_buffer(section, sparse_offset, (u8 )512, (void **)(& buf));
  }
#line 153
  if (tmp___0 < 512ULL) {
    {
#line 154
    print_line(level + 1, "Error reading the sparse image info block");
    }
#line 155
    goto errorexit;
  }
  {
#line 157
  map_offset = get_be_quad((void *)(buf + 16));
#line 158
  vs->chunk_count = get_be_long((void *)(buf + 28));
#line 159
  vs->chunk_size = get_be_long((void *)(buf + 32));
#line 161
  format_size(s, (u8 )vs->chunk_size);
#line 162
  print_line(level + 1, "Dynamic sizing uses %lu chunks of %s", vs->chunk_count, s);
  }
#line 165
  if ((u8 )vs->chunk_count * (u8 )vs->chunk_size < total_size) {
    {
#line 166
    print_line(level + 1, "Error: Sparse parameters don\'t match total size");
    }
#line 167
    goto errorexit;
  }
#line 169
  if (vs->chunk_size < 4096UL) {
    {
#line 170
    print_line(level + 1, "Error: Sparse chunk size too small (%lu bytes)", vs->chunk_size);
    }
#line 172
    goto errorexit;
  }
#line 174
  if (vs->chunk_size > 2097152UL) {
    {
#line 176
    print_line(level + 1, "Error: Sparse chunk size too large (%lu bytes)", vs->chunk_size);
    }
#line 178
    goto errorexit;
  }
  {
#line 182
  map_size = vs->chunk_count * 4UL;
#line 183
  tmp___1 = malloc(map_size);
#line 183
  vs->raw_map = (u4 *)tmp___1;
  }
#line 184
  if ((unsigned long )vs->raw_map == (unsigned long )((void *)0)) {
    {
#line 185
    bailout("Out of memory");
    }
  }
  {
#line 186
  tmp___2 = malloc(vs->chunk_count * sizeof(VHD_CHUNK *));
#line 186
  vs->chunks = (VHD_CHUNK **)tmp___2;
  }
#line 187
  if ((unsigned long )vs->chunks == (unsigned long )((void *)0)) {
    {
#line 188
    bailout("Out of memory");
    }
  }
  {
#line 189
  memset((void *)vs->chunks, 0, vs->chunk_count * sizeof(VHD_CHUNK *));
#line 192
  tmp___3 = get_buffer_real(section->source, vs->off + map_offset, (u8 )map_size,
                            (void *)vs->raw_map, (void **)((void *)0));
  }
#line 192
  if (tmp___3 < (u8 )map_size) {
    {
#line 194
    print_line(level + 1, "Error reading the sparse image map");
    }
#line 195
    goto errorexit;
  }
#line 198
  return ((SOURCE *)vs);
  errorexit: 
  {
#line 201
  close_vhd((SOURCE *)vs);
#line 202
  free((void *)vs);
  }
#line 203
  return ((SOURCE *)((void *)0));
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
static int read_block_vhd(SOURCE *s , u8 pos , void *buf ) 
{ 
  VHD_SOURCE *vs ;
  SOURCE *fs ;
  u4 chunk ;
  u4 chunk_start_sector ;
  u4 sector ;
  u8 chunk_disk_off ;
  u8 sector_pos ;
  unsigned char *filebuf ;
  int present ;
  u8 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u8 tmp___2 ;

  {
#line 212
  vs = (VHD_SOURCE *)s;
#line 213
  fs = s->foundation;
#line 219
  chunk = (u4 )(pos / (u8 )vs->chunk_size);
#line 220
  if (chunk >= vs->chunk_count) {
#line 221
    return (0);
  }
#line 223
  if ((unsigned long )*(vs->chunks + chunk) == (unsigned long )((void *)0)) {
    {
#line 226
    chunk_start_sector = get_be_long((void *)(vs->raw_map + chunk));
    }
#line 229
    if (chunk_start_sector == 4294967295UL) {
#line 230
      present = 0;
    } else {
      {
#line 232
      chunk_disk_off = vs->off + (u8 )chunk_start_sector * 512ULL;
#line 233
      tmp = get_buffer_real(fs, chunk_disk_off, (u8 )512, (void *)0, (void **)(& filebuf));
      }
#line 233
      if (tmp < 512ULL) {
#line 235
        present = 0;
      } else {
#line 237
        present = 1;
      }
    }
#line 240
    if (! present) {
      {
#line 241
      tmp___0 = malloc(sizeof(VHD_CHUNK ));
#line 241
      *(vs->chunks + chunk) = (VHD_CHUNK *)tmp___0;
      }
#line 242
      if ((unsigned long )*(vs->chunks + chunk) == (unsigned long )((void *)0)) {
        {
#line 243
        bailout("Out of memory");
        }
      }
#line 244
      (*(vs->chunks + chunk))->present = 0;
    } else {
      {
#line 246
      tmp___1 = malloc(sizeof(VHD_CHUNK ) + 512UL);
#line 246
      *(vs->chunks + chunk) = (VHD_CHUNK *)tmp___1;
      }
#line 247
      if ((unsigned long )*(vs->chunks + chunk) == (unsigned long )((void *)0)) {
        {
#line 248
        bailout("Out of memory");
        }
      }
      {
#line 249
      (*(vs->chunks + chunk))->present = 1;
#line 250
      (*(vs->chunks + chunk))->off = chunk_disk_off + 512ULL;
#line 251
      memcpy((void */* __restrict  */)((*(vs->chunks + chunk))->bitmap), (void const   */* __restrict  */)filebuf,
             (size_t )512);
      }
    }
  }
#line 255
  if (! (*(vs->chunks + chunk))->present) {
    {
#line 257
    memset(buf, 0, (size_t )512);
    }
#line 258
    return (1);
  }
#line 261
  sector = (u4 )((pos - (u8 )chunk * (u8 )vs->chunk_size) / 512ULL);
#line 262
  if ((int )(*(vs->chunks + chunk))->bitmap[sector >> 3] & (128 >> (sector & 7UL))) {
    {
#line 264
    sector_pos = (*(vs->chunks + chunk))->off + (u8 )sector * 512ULL;
#line 265
    tmp___2 = get_buffer_real(fs, sector_pos, (u8 )512, buf, (void **)((void *)0));
    }
#line 265
    if (tmp___2 < 512ULL) {
#line 266
      return (0);
    }
  } else {
    {
#line 269
    memset(buf, 0, (size_t )512);
    }
  }
#line 271
  return (1);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/disktype-9/vpc.c"
static void close_vhd(SOURCE *s ) 
{ 
  VHD_SOURCE *vs ;
  u4 chunk ;

  {
#line 280
  vs = (VHD_SOURCE *)s;
#line 284
  if ((unsigned long )vs->raw_map != (unsigned long )((void *)0)) {
    {
#line 285
    free((void *)vs->raw_map);
    }
  }
#line 288
  if ((unsigned long )vs->chunks != (unsigned long )((void *)0)) {
#line 289
    chunk = (u4 )0;
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      if (! (chunk < vs->chunk_count)) {
#line 289
        goto while_break;
      }
#line 290
      if ((unsigned long )*(vs->chunks + chunk) != (unsigned long )((void *)0)) {
        {
#line 291
        free((void *)*(vs->chunks + chunk));
        }
      }
#line 289
      chunk ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 293
    free((void *)vs->chunks);
    }
  }
#line 295
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdrom.c"
static void dump_boot_catalog(SECTION *section , u8 pos , int level ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdrom.c"
void detect_iso(SECTION *section , int level ) 
{ 
  char s[256] ;
  char t[256] ;
  int i ;
  int sector ;
  int type ;
  u4 blocksize ;
  u8 blocks ;
  u8 bcpos ;
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;
  u4 tmp___1 ;
  u2 tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u4 tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 49
  tmp = get_buffer(section, (u8 )32768, (u8 )2048, (void **)(& buf));
  }
#line 49
  if (tmp < 2048ULL) {
#line 50
    return;
  }
  {
#line 53
  tmp___0 = memcmp((void const   *)buf, (void const   *)"\001CD001", (size_t )6);
  }
#line 53
  if (tmp___0 != 0) {
#line 54
    return;
  }
  {
#line 56
  print_line(level, "ISO9660 file system");
#line 59
  get_padded_string((void *)(buf + 40), 32, (char )' ', s);
#line 60
  print_line(level + 1, "Volume name \"%s\"", s);
#line 62
  get_padded_string((void *)(buf + 318), 128, (char )' ', s);
  }
#line 63
  if (s[0]) {
    {
#line 64
    print_line(level + 1, "Publisher   \"%s\"", s);
    }
  }
  {
#line 66
  get_padded_string((void *)(buf + 446), 128, (char )' ', s);
  }
#line 67
  if (s[0]) {
    {
#line 68
    print_line(level + 1, "Preparer    \"%s\"", s);
    }
  }
  {
#line 70
  get_padded_string((void *)(buf + 574), 128, (char )' ', s);
  }
#line 71
  if (s[0]) {
    {
#line 72
    print_line(level + 1, "Application \"%s\"", s);
    }
  }
  {
#line 75
  tmp___1 = get_le_long((void *)(buf + 80));
#line 75
  blocks = (u8 )tmp___1;
#line 76
  tmp___2 = get_le_short((void *)(buf + 128));
#line 76
  blocksize = (u4 )tmp___2;
#line 77
  format_blocky_size(s, blocks, blocksize, "blocks", (char const   *)((void *)0));
#line 78
  print_line(level + 1, "Data size %s", s);
#line 80
  sector = 17;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    tmp___3 = get_buffer(section, (u8 )(sector * 2048), (u8 )2048, (void **)(& buf));
    }
#line 82
    if (tmp___3 < 2048ULL) {
#line 83
      return;
    }
    {
#line 86
    tmp___4 = memcmp((void const   *)(buf + 1), (void const   *)"CD001", (size_t )5);
    }
#line 86
    if (tmp___4 != 0) {
      {
#line 87
      print_line(level + 1, "Signature missing in sector %d", sector);
      }
#line 88
      return;
    }
#line 90
    type = (int )*(buf + 0);
#line 91
    if (type == 255) {
#line 92
      goto while_break;
    }
    {
#line 96
    if (type == 0) {
#line 96
      goto case_0;
    }
#line 111
    if (type == 1) {
#line 111
      goto case_1;
    }
#line 115
    if (type == 2) {
#line 115
      goto case_2;
    }
#line 123
    if (type == 3) {
#line 123
      goto case_3;
    }
#line 127
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 98
    tmp___5 = memcmp((void const   *)(buf + 7), (void const   *)"EL TORITO SPECIFICATION",
                     (size_t )23);
    }
#line 98
    if (tmp___5 != 0) {
      {
#line 99
      print_line(level + 1, "Boot record of unknown format");
      }
#line 100
      goto switch_break;
    }
    {
#line 103
    tmp___6 = get_le_long((void *)(buf + 71));
#line 103
    bcpos = (u8 )tmp___6;
#line 104
    print_line(level + 1, "El Torito boot record, catalog at %llu", bcpos);
#line 107
    dump_boot_catalog(section, bcpos * 2048ULL, level + 2);
    }
#line 109
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 112
    print_line(level + 1, "Additional Primary Volume Descriptor");
    }
#line 113
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 117
    format_utf16_be((void *)(buf + 40), (u4 )32, t);
#line 118
    tmp___7 = strlen((char const   *)(t));
#line 118
    i = (int )(tmp___7 - 1UL);
    }
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (i >= 0) {
#line 118
        if (! ((int )t[i] == 32)) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 119
      t[i] = (char)0;
#line 118
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 120
    print_line(level + 1, "Joliet extension, volume name \"%s\"", t);
    }
#line 121
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 124
    print_line(level + 1, "Volume Partition Descriptor");
    }
#line 125
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 128
    print_line(level + 1, "Descriptor type %d at sector %d", type, sector);
    }
#line 129
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 80
    sector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdrom.c"
static char *media_types[16]  = 
#line 138
  {      (char *)"non-emulated",      (char *)"1.2M floppy",      (char *)"1.44M floppy",      (char *)"2.88M floppy", 
        (char *)"hard disk",      (char *)"reserved type 5",      (char *)"reserved type 6",      (char *)"reserved type 7", 
        (char *)"reserved type 8",      (char *)"reserved type 9",      (char *)"reserved type 10",      (char *)"reserved type 11", 
        (char *)"reserved type 12",      (char *)"reserved type 13",      (char *)"reserved type 14",      (char *)"reserved type 15"};
#line 150 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdrom.c"
static char *get_name_for_eltorito_platform(int id ) 
{ 


  {
#line 152
  if (id == 0) {
#line 153
    return ((char *)"x86");
  }
#line 154
  if (id == 1) {
#line 155
    return ((char *)"PowerPC");
  }
#line 156
  if (id == 2) {
#line 157
    return ((char *)"Macintosh");
  }
#line 158
  if (id == 239) {
#line 159
    return ((char *)"EFI");
  }
#line 160
  return ((char *)"unknown");
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdrom.c"
static void dump_boot_catalog(SECTION *section , u8 pos , int level ) 
{ 
  unsigned char *buf ;
  int bootable ;
  int media ;
  int platform ;
  int system_type ;
  u4 start ;
  u4 preload ;
  int entry ;
  int maxentry ;
  int off ;
  char s[256] ;
  u8 tmp ;
  u8 tmp___0 ;
  u2 tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  u2 tmp___5 ;
  int tmp___6 ;

  {
  {
#line 172
  tmp = get_buffer(section, pos, (u8 )2048, (void **)(& buf));
  }
#line 172
  if (tmp < 2048ULL) {
#line 173
    return;
  }
#line 176
  if ((int )*(buf + 0) != 1) {
    {
#line 177
    print_line(level, "Validation entry missing");
    }
#line 178
    return;
  } else
#line 176
  if ((int )*(buf + 30) != 85) {
    {
#line 177
    print_line(level, "Validation entry missing");
    }
#line 178
    return;
  } else
#line 176
  if ((int )*(buf + 31) != 170) {
    {
#line 177
    print_line(level, "Validation entry missing");
    }
#line 178
    return;
  }
#line 181
  platform = (int )*(buf + 1);
#line 184
  maxentry = 2;
#line 185
  entry = 1;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (entry < maxentry + 1)) {
#line 185
      goto while_break;
    }
#line 186
    if ((entry & 63) == 0) {
      {
#line 188
      tmp___0 = get_buffer(section, pos + (u8 )((entry / 64) * 2048), (u8 )2048, (void **)(& buf));
      }
#line 188
      if (tmp___0 < 2048ULL) {
#line 189
        return;
      }
    }
#line 191
    off = (entry * 32) % 2048;
#line 193
    if (entry >= maxentry) {
#line 194
      if ((int )*(buf + off) == 136) {
#line 195
        maxentry ++;
      } else {
#line 197
        goto while_break;
      }
    }
#line 200
    if (entry == 1) {
#line 201
      if (! ((int )*(buf + off) == 136)) {
#line 201
        if (! ((int )*(buf + off) == 0)) {
          {
#line 202
          print_line(level, "Initial/Default entry missing");
          }
#line 203
          goto while_break;
        }
      }
#line 205
      if ((int )*(buf + (off + 32)) == 144) {
#line 206
        maxentry = 3;
      } else
#line 205
      if ((int )*(buf + (off + 32)) == 145) {
#line 206
        maxentry = 3;
      }
    }
#line 209
    if ((int )*(buf + off) == 136) {
#line 209
      goto _L___0;
    } else
#line 209
    if ((int )*(buf + off) == 0) {
      _L___0: /* CIL Label */ 
#line 210
      if ((int )*(buf + off) == 136) {
#line 210
        bootable = 1;
      } else {
#line 210
        bootable = 0;
      }
      {
#line 211
      media = (int )*(buf + (off + 1)) & 15;
#line 212
      system_type = (int )*(buf + (off + 4));
#line 213
      start = get_le_long((void *)((buf + off) + 8));
#line 214
      tmp___1 = get_le_short((void *)((buf + off) + 6));
#line 214
      preload = (u4 )tmp___1;
#line 217
      format_size(s, (u8 )(preload * 512UL));
      }
#line 218
      if (bootable) {
#line 218
        tmp___2 = "Bootable";
      } else {
#line 218
        tmp___2 = "Non-bootable";
      }
      {
#line 218
      print_line(level, "%s %s image, starts at %lu, preloads %s", tmp___2, media_types[media],
                 start, s);
#line 221
      tmp___3 = get_name_for_mbrtype(system_type);
#line 221
      tmp___4 = get_name_for_eltorito_platform(platform);
#line 221
      print_line(level + 1, "Platform 0x%02X (%s), System Type 0x%02X (%s)", platform,
                 tmp___4, system_type, tmp___3);
      }
#line 224
      if (start > 0UL) {
        {
#line 225
        analyze_recursive(section, level + 1, (u8 )start * 2048ULL, (u8 )0, 0);
        }
      }
    } else
#line 230
    if ((int )*(buf + off) == 68) {
#line 231
      maxentry ++;
    } else
#line 233
    if ((int )*(buf + off) == 144) {
#line 233
      goto _L;
    } else
#line 233
    if ((int )*(buf + off) == 145) {
      _L: /* CIL Label */ 
      {
#line 234
      platform = (int )*(buf + (off + 1));
#line 235
      tmp___5 = get_le_short((void *)((buf + off) + 2));
      }
#line 235
      if ((int )*(buf + off) == 144) {
#line 235
        tmp___6 = 1;
      } else {
#line 235
        tmp___6 = 0;
      }
#line 235
      maxentry = ((entry + 1) + (int )tmp___5) + tmp___6;
    } else {
      {
#line 240
      print_line(level, "Unknown entry type 0x%02X", (int )*(buf + off));
      }
#line 241
      goto while_break;
    }
#line 185
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdrom.c"
void detect_cdrom_misc(SECTION *section , int level ) 
{ 
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 255
  tmp = get_buffer(section, (u8 )0, (u8 )2048, (void **)(& buf));
  }
#line 255
  if (tmp < 2048ULL) {
#line 256
    return;
  }
  {
#line 259
  tmp___0 = memcmp((void const   *)buf, (void const   *)"SEGA SEGAKATANA SEGA ENTERPRISES",
                   (size_t )32);
  }
#line 259
  if (tmp___0 == 0) {
    {
#line 260
    print_line(level, "Sega Dreamcast signature");
    }
  }
  {
#line 264
  tmp___1 = memcmp((void const   *)buf, (void const   *)"\001ZZZZZ\001\000", (size_t )8);
  }
#line 264
  if (tmp___1 == 0) {
    {
#line 264
    tmp___2 = memcmp((void const   *)(buf + 40), (void const   *)"CD-ROM", (size_t )6);
    }
#line 264
    if (tmp___2 == 0) {
      {
#line 266
      print_line(level, "3DO CD-ROM file system");
      }
    }
  }
  {
#line 270
  tmp___3 = get_buffer(section, (u8 )65536, (u8 )2048, (void **)(& buf));
  }
#line 270
  if (tmp___3 < 2048ULL) {
#line 271
    return;
  }
  {
#line 274
  tmp___4 = memcmp((void const   *)buf, (void const   *)"MICROSOFT*XBOX*MEDIA", (size_t )20);
  }
#line 274
  if (tmp___4 == 0) {
    {
#line 274
    tmp___5 = memcmp((void const   *)(buf + 2028), (void const   *)"MICROSOFT*XBOX*MEDIA",
                     (size_t )20);
    }
#line 274
    if (tmp___5 == 0) {
      {
#line 276
      print_line(level, "Xbox DVD file system");
      }
    }
  }
#line 278
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/disktype-9/global.h"
void analyze_source_special(SOURCE *s , int level , u8 pos , u8 size ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
void detect_compressed(SECTION *section , int level ) ;
#line 92
void detect_cdimage(SECTION *section , int level ) ;
#line 101
void detect_archive(SECTION *section , int level ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
DETECTOR detectors[43]  = 
#line 110
  {      & detect_vhd,      & detect_cdimage,      & detect_cloop,      & detect_udif, 
        & detect_linux_loader,      & detect_bsd_loader,      & detect_dos_loader,      & detect_beos_loader, 
        & detect_bsd_disklabel,      & detect_solaris_disklabel,      & detect_solaris_vtoc,      & detect_amiga_partmap, 
        & detect_apple_partmap,      & detect_atari_partmap,      & detect_dos_partmap,      & detect_gpt_partmap, 
        & detect_amiga_fs,      & detect_apple_volume,      & detect_fat,      & detect_ntfs, 
        & detect_hpfs,      & detect_udf,      & detect_cdrom_misc,      & detect_iso, 
        & detect_ext23,      & detect_reiser,      & detect_reiser4,      & detect_linux_raid, 
        & detect_linux_lvm,      & detect_linux_lvm2,      & detect_linux_swap,      & detect_linux_misc, 
        & detect_jfs,      & detect_xfs,      & detect_ufs,      & detect_sysv, 
        & detect_qnx,      & detect_vxfs,      & detect_bfs,      & detect_archive, 
        & detect_compressed,      & detect_blank,      (DETECTOR )((void *)0)};
#line 167
static void detect(SECTION *section , int level ) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
static int stop_flag  =    0;
#line 175 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
void analyze_source(SOURCE *s , int level ) 
{ 
  SECTION section ;
  int tmp ;

  {
#line 182
  if ((unsigned long )s->analyze != (unsigned long )((void *)0)) {
    {
#line 183
    tmp = (*(s->analyze))(s, level);
    }
#line 183
    if (tmp) {
#line 184
      return;
    }
  }
#line 187
  section.source = s;
#line 188
  section.pos = (u8 )0;
#line 189
  if (s->size_known) {
#line 189
    section.size = s->size;
  } else {
#line 189
    section.size = (u8 )0;
  }
  {
#line 190
  section.flags = 0;
#line 192
  detect(& section, level);
  }
#line 193
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
void analyze_source_special(SOURCE *s , int level , u8 pos , u8 size ) 
{ 
  SECTION section ;

  {
  {
#line 203
  section.source = s;
#line 204
  section.pos = pos;
#line 205
  section.size = size;
#line 206
  section.flags = 0;
#line 208
  detect(& section, level);
  }
#line 209
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
void analyze_recursive(SECTION *section , int level , u8 rel_pos , u8 size , int flags ) 
{ 
  SOURCE *s ;
  SECTION rs ;

  {
#line 222
  if (rel_pos == 0ULL) {
#line 222
    if ((flags & 1) == 0) {
#line 223
      return;
    }
  }
#line 224
  s = section->source;
#line 225
  if (s->size_known) {
#line 225
    if (section->pos + rel_pos >= s->size) {
#line 226
      return;
    }
  }
  {
#line 228
  rs.source = s;
#line 229
  rs.pos = section->pos + rel_pos;
#line 230
  rs.size = size;
#line 231
  rs.flags = section->flags | flags;
#line 233
  detect(& rs, level);
  }
#line 234
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
static void detect(SECTION *section , int level ) 
{ 
  int i ;

  {
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (detectors[i]) {
#line 245
      if (! (! stop_flag)) {
#line 245
        goto while_break;
      }
    } else {
#line 245
      goto while_break;
    }
    {
#line 246
    (*(detectors[i]))(section, level);
#line 245
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  stop_flag = 0;
#line 248
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/disktype-9/detect.c"
void stop_detect(void) 
{ 


  {
#line 256
  stop_flag = 1;
#line 257
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/disktype-9/archives.c"
void detect_archive(SECTION *section , int level ) 
{ 
  int fill ;
  int i ;
  int stored_sum ;
  int sum ;
  int en ;
  u4 magic ;
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u2 tmp___3 ;
  u2 tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 44
  tmp = get_buffer(section, (u8 )0, (u8 )512, (void **)(& buf));
#line 44
  fill = (int )tmp;
  }
#line 45
  if (fill < 512) {
#line 46
    return;
  }
#line 49
  sum = 0;
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < 148)) {
#line 50
      goto while_break;
    }
#line 51
    sum += (int )((char )*(buf + i));
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 52
    if (! (i < 156)) {
#line 52
      goto while_break___0;
    }
#line 53
    sum += 32;
#line 52
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 54
    if (! (i < 512)) {
#line 54
      goto while_break___1;
    }
#line 55
    sum += (int )((char )*(buf + i));
#line 54
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 56
  stored_sum = 0;
#line 57
  i = 148;
  {
#line 57
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 57
    if (! (i < 156)) {
#line 57
      goto while_break___2;
    }
#line 58
    if ((int )*(buf + i) == 0) {
#line 59
      goto while_break___2;
    } else
#line 60
    if ((int )*(buf + i) >= 48) {
#line 60
      if ((int )*(buf + i) <= 55) {
#line 61
        stored_sum = stored_sum * 8 + ((int )*(buf + i) - 48);
      } else {
#line 60
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 62
    if ((int )*(buf + i) != 32) {
#line 63
      stored_sum = -1;
#line 64
      goto while_break___2;
    }
#line 57
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 67
  if (sum == stored_sum) {
    {
#line 68
    tmp___1 = memcmp((void const   *)((char *)buf + 257), (void const   *)"ustar  \000",
                     (size_t )8);
    }
#line 68
    if (tmp___1 == 0) {
      {
#line 69
      print_line(level, "GNU tar archive");
      }
    } else {
      {
#line 70
      tmp___0 = memcmp((void const   *)((char *)buf + 257), (void const   *)"ustar\000",
                       (size_t )6);
      }
#line 70
      if (tmp___0 == 0) {
        {
#line 71
        print_line(level, "POSIX tar archive");
        }
      } else {
        {
#line 73
        print_line(level, "Pre-POSIX tar archive");
        }
      }
    }
  }
  {
#line 78
  tmp___4 = get_le_short((void *)buf);
  }
#line 78
  if ((int )tmp___4 == 29127) {
    {
#line 79
    print_line(level, "cpio archive, little-endian binary");
    }
  } else {
    {
#line 80
    tmp___3 = get_be_short((void *)buf);
    }
#line 80
    if ((int )tmp___3 == 29127) {
      {
#line 81
      print_line(level, "cpio archive, big-endian binary");
      }
    } else {
      {
#line 82
      tmp___2 = memcmp((void const   *)buf, (void const   *)"07070", (size_t )5);
      }
#line 82
      if (tmp___2 == 0) {
        {
#line 83
        print_line(level, "cpio archive, ascii");
        }
      }
    }
  }
  {
#line 87
  tmp___5 = memcmp((void const   *)(buf + 65), (void const   *)"V\000", (size_t )2);
  }
#line 87
  if (tmp___5 == 0) {
    {
#line 88
    print_line(level, "bar archive");
    }
  }
#line 92
  en = 0;
  {
#line 92
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 92
    if (! (en < 2)) {
#line 92
      goto while_break___3;
    }
    {
#line 93
    magic = get_ve_long(en, (void *)(buf + 24));
    }
#line 95
    if (magic == 60011UL) {
      {
#line 96
      tmp___6 = get_ve_name(en);
#line 96
      print_line(level, "dump: 4.1BSD (or older) or Sun OFS, %s", tmp___6);
      }
    } else
#line 97
    if (magic == 60012UL) {
      {
#line 98
      tmp___7 = get_ve_name(en);
#line 98
      print_line(level, "dump: 4.2BSD (or newer) without IDC or Sun NFS, %s", tmp___7);
      }
    } else
#line 99
    if (magic == 60013UL) {
      {
#line 100
      tmp___8 = get_ve_name(en);
#line 100
      print_line(level, "dump: 4.2BSD (or newer) with IDC, %s", tmp___8);
      }
    } else
#line 101
    if (magic == 60014UL) {
      {
#line 102
      tmp___9 = get_ve_name(en);
#line 102
      print_line(level, "dump: Convex Storage Manager, %s", tmp___9);
      }
    }
#line 92
    en ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
static SOURCE *init_cdimage_source(SOURCE *foundation , u8 offset ) ;
#line 44
static int read_block_cdimage(SOURCE *s , u8 pos , void *buf ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
static unsigned char syncbytes[12]  = 
#line 50
  {      (unsigned char)0,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0};
#line 54 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
void detect_cdimage(SECTION *section , int level ) 
{ 
  int mode ;
  int off ;
  unsigned char *buf ;
  SOURCE *s ;
  u8 tmp ;
  int tmp___0 ;

  {
  {
#line 60
  tmp = get_buffer(section, (u8 )0, (u8 )2352, (void **)(& buf));
  }
#line 60
  if (tmp < 2352ULL) {
#line 61
    return;
  }
  {
#line 64
  tmp___0 = memcmp((void const   *)buf, (void const   *)(syncbytes), (size_t )12);
  }
#line 64
  if (tmp___0 != 0) {
#line 65
    return;
  }
#line 68
  mode = (int )*(buf + 15);
#line 69
  if (mode == 1) {
    {
#line 71
    print_line(level, "Raw CD image, Mode 1");
#line 72
    off = 16;
    }
  } else
#line 73
  if (mode == 2) {
    {
#line 75
    print_line(level, "Raw CD image, Mode 2, assuming Form 1");
#line 76
    off = 24;
    }
  } else {
#line 78
    return;
  }
  {
#line 81
  s = init_cdimage_source(section->source, section->pos + (u8 )off);
#line 82
  analyze_source(s, level);
#line 83
  close_source(s);
#line 86
  stop_detect();
  }
#line 87
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
static SOURCE *init_cdimage_source(SOURCE *foundation , u8 offset ) 
{ 
  CDIMAGE_SOURCE *src ;
  void *tmp ;

  {
  {
#line 97
  tmp = malloc(sizeof(CDIMAGE_SOURCE ));
#line 97
  src = (CDIMAGE_SOURCE *)tmp;
  }
#line 98
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 99
    bailout("Out of memory");
    }
  }
  {
#line 100
  memset((void *)src, 0, sizeof(CDIMAGE_SOURCE ));
  }
#line 102
  if (foundation->size_known) {
#line 103
    src->c.size_known = 1;
#line 104
    src->c.size = (((foundation->size - offset) + 304ULL) / 2352ULL) * 2048ULL;
  }
#line 107
  src->c.blocksize = 2048;
#line 108
  src->c.foundation = foundation;
#line 109
  src->c.read_block = & read_block_cdimage;
#line 110
  src->c.close = (void (*)(struct source *s ))((void *)0);
#line 111
  src->off = offset;
#line 113
  return ((SOURCE *)src);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdimage.c"
static int read_block_cdimage(SOURCE *s , u8 pos , void *buf ) 
{ 
  SOURCE *fs ;
  u8 filepos ;
  u8 tmp ;

  {
  {
#line 122
  fs = s->foundation;
#line 126
  filepos = (pos / 2048ULL) * 2352ULL + ((CDIMAGE_SOURCE *)s)->off;
#line 129
  tmp = get_buffer_real(fs, filepos, (u8 )2048, buf, (void **)((void *)0));
  }
#line 129
  if (tmp < 2048ULL) {
#line 130
    return (0);
  }
#line 132
  return (1);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
static void handle_compressed(SECTION *section , int level , int off , char const   *program ) ;
#line 66
static SOURCE *init_compressed_source(SOURCE *foundation , u8 offset , u8 size , char const   *program ) ;
#line 68
static u8 read_compressed(SOURCE *s , u8 pos , u8 len , void *buf ) ;
#line 69
static void close_compressed(SOURCE *s ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
void detect_compressed(SECTION *section , int level ) 
{ 
  int fill ;
  int off ;
  int sector ;
  unsigned char *buf ;
  u8 tmp ;
  int tmp___0 ;

  {
  {
#line 81
  tmp = get_buffer(section, (u8 )0, (u8 )4096, (void **)(& buf));
#line 81
  fill = (int )tmp;
#line 84
  off = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (off + 512 <= fill)) {
#line 84
      goto while_break;
    }
#line 85
    sector = off >> 9;
#line 88
    if ((int )*(buf + off) == 31) {
#line 88
      if ((int )*(buf + (off + 1)) == 157) {
#line 89
        if (sector > 0) {
          {
#line 90
          print_line(level, "compress-compressed data at sector %d", sector);
          }
        } else {
          {
#line 92
          print_line(level, "compress-compressed data");
          }
        }
        {
#line 94
        handle_compressed(section, level, off, "gzip");
        }
#line 96
        goto while_break;
      }
    }
#line 100
    if ((int )*(buf + off) == 31) {
#line 100
      if ((int )*(buf + (off + 1)) == 139) {
#line 100
        goto _L;
      } else
#line 100
      if ((int )*(buf + (off + 1)) == 158) {
        _L: /* CIL Label */ 
#line 101
        if (sector > 0) {
          {
#line 102
          print_line(level, "gzip-compressed data at sector %d", sector);
          }
        } else {
          {
#line 104
          print_line(level, "gzip-compressed data");
          }
        }
        {
#line 106
        handle_compressed(section, level, off, "gzip");
        }
#line 108
        goto while_break;
      }
    }
    {
#line 112
    tmp___0 = memcmp((void const   *)(buf + off), (void const   *)"BZh", (size_t )3);
    }
#line 112
    if (tmp___0 == 0) {
#line 113
      if (sector > 0) {
        {
#line 114
        print_line(level, "bzip2-compressed data at sector %d", sector);
        }
      } else {
        {
#line 116
        print_line(level, "bzip2-compressed data");
        }
      }
      {
#line 118
      handle_compressed(section, level, off, "bzip2");
      }
#line 120
      goto while_break;
    }
#line 84
    off += 512;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
static void handle_compressed(SECTION *section , int level , int off , char const   *program ) 
{ 
  SOURCE *s ;
  u8 size ;

  {
#line 133
  size = section->size;
#line 134
  if (size > 0ULL) {
#line 135
    size -= (u8 )off;
  }
  {
#line 136
  s = init_compressed_source(section->source, section->pos + (u8 )off, size, program);
#line 138
  analyze_source(s, level + 1);
#line 139
  close_source(s);
  }
#line 143
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
static SOURCE *init_compressed_source(SOURCE *foundation , u8 offset , u8 size , char const   *program ) 
{ 
  COMPRESSED_SOURCE *cs ;
  int write_pipe[2] ;
  int read_pipe[2] ;
  int flags ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 157
  tmp = malloc(sizeof(COMPRESSED_SOURCE ));
#line 157
  cs = (COMPRESSED_SOURCE *)tmp;
  }
#line 158
  if ((unsigned long )cs == (unsigned long )((void *)0)) {
    {
#line 159
    bailout("Out of memory");
    }
  }
  {
#line 160
  memset((void *)cs, 0, sizeof(COMPRESSED_SOURCE ));
#line 162
  cs->c.sequential = 1;
#line 163
  cs->c.seq_pos = (u8 )0;
#line 164
  cs->c.foundation = foundation;
#line 165
  cs->c.read_bytes = & read_compressed;
#line 166
  cs->c.close = & close_compressed;
#line 169
  cs->offset = offset;
#line 170
  cs->write_pos = (u8 )0;
#line 171
  cs->write_max = size;
#line 174
  tmp___0 = pipe((int *)(write_pipe));
  }
#line 174
  if (tmp___0 < 0) {
    {
#line 175
    bailoute("pipe for decompression");
    }
  }
  {
#line 176
  tmp___1 = pipe((int *)(read_pipe));
  }
#line 176
  if (tmp___1 < 0) {
    {
#line 177
    bailoute("pipe for decompression");
    }
  }
  {
#line 178
  cs->write_pipe = write_pipe[1];
#line 179
  cs->read_pipe = read_pipe[0];
#line 181
  cs->pid = fork();
  }
#line 182
  if (cs->pid < 0) {
    {
#line 183
    bailoute("fork");
    }
  }
#line 185
  if (cs->pid == 0) {
    {
#line 187
    dup2(write_pipe[0], 0);
    }
#line 188
    if (write_pipe[0] > 2) {
      {
#line 189
      close(write_pipe[0]);
      }
    }
    {
#line 190
    close(write_pipe[1]);
#line 191
    close(read_pipe[0]);
#line 192
    dup2(read_pipe[1], 1);
    }
#line 193
    if (read_pipe[1] > 2) {
      {
#line 194
      close(read_pipe[1]);
      }
    }
    {
#line 197
    execlp(program, program, "-dc", (void *)0);
#line 198
    exit(0);
    }
  }
  {
#line 201
  close(write_pipe[0]);
#line 202
  close(read_pipe[1]);
#line 205
  flags = fcntl(cs->write_pipe, 3, 0);
  }
#line 205
  if (flags >= 0) {
    {
#line 206
    fcntl(cs->write_pipe, 4, flags | 2048);
    }
  } else {
    {
#line 208
    bailoute("set pipe flags");
    }
  }
  {
#line 209
  flags = fcntl(cs->read_pipe, 3, 0);
  }
#line 209
  if (flags >= 0) {
    {
#line 210
    fcntl(cs->read_pipe, 4, flags | 2048);
    }
  } else {
    {
#line 212
    bailoute("set pipe flags");
    }
  }
#line 213
  if (cs->read_pipe > cs->write_pipe) {
#line 213
    tmp___2 = cs->read_pipe;
  } else {
#line 213
    tmp___2 = cs->write_pipe;
  }
#line 213
  cs->nfds = tmp___2 + 1;
#line 216
  return ((SOURCE *)cs);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
static u8 read_compressed(SOURCE *s , u8 pos , u8 len , void *buf ) 
{ 
  COMPRESSED_SOURCE *cs ;
  SOURCE *fs ;
  char *p ;
  char *filebuf ;
  u8 got ;
  u8 fill ;
  int askfor ;
  int selresult ;
  ssize_t result ;
  fd_set read_set ;
  fd_set write_set ;
  int *tmp ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int *tmp___4 ;

  {
#line 225
  cs = (COMPRESSED_SOURCE *)s;
#line 226
  fs = s->foundation;
#line 238
  p = (char *)buf;
#line 239
  got = (u8 )0;
#line 241
  if (cs->read_pipe < 0) {
#line 242
    return (got);
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (got < len)) {
#line 244
      goto while_break;
    }
    {
#line 245
    result = read(cs->read_pipe, (void *)p, (size_t )(len - got));
    }
#line 249
    if (result == 0L) {
      {
#line 251
      s->size_known = 1;
#line 252
      s->size = s->seq_pos + got;
#line 254
      close(cs->read_pipe);
#line 255
      cs->read_pipe = -1;
      }
#line 257
      goto while_break;
    } else
#line 258
    if (result > 0L) {
#line 259
      p += result;
#line 260
      got += (u8 )result;
#line 261
      goto while_continue;
    } else {
      {
#line 263
      tmp = __errno_location();
      }
#line 263
      if (*tmp == 4) {
#line 264
        goto while_continue;
      }
      {
#line 265
      tmp___0 = __errno_location();
      }
#line 265
      if (*tmp___0 != 11) {
        {
#line 266
        errore("read from pipe");
        }
#line 267
        goto while_break;
      }
    }
#line 275
    askfor = 4096;
#line 276
    if (cs->write_max) {
#line 276
      if (cs->write_pos + (u8 )askfor > cs->write_max) {
#line 277
        askfor = (int )(cs->write_max - cs->write_pos);
      }
    }
#line 278
    if (askfor <= 0) {
#line 278
      if (cs->write_pipe >= 0) {
        {
#line 280
        close(cs->write_pipe);
#line 281
        cs->write_pipe = -1;
        }
      }
    }
#line 283
    if (cs->write_pipe < 0) {
      {
#line 285
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 285
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& read_set.__fds_bits[0]): "memory");
#line 285
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 286
      read_set.__fds_bits[cs->read_pipe / (8 * (int )sizeof(__fd_mask ))] |= 1L << cs->read_pipe % (8 * (int )sizeof(__fd_mask ));
#line 290
      selresult = select(cs->nfds, (fd_set */* __restrict  */)(& read_set), (fd_set */* __restrict  */)((void *)0),
                         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
#line 294
      if (selresult < 0) {
        {
#line 294
        tmp___1 = __errno_location();
        }
#line 294
        if (*tmp___1 != 4) {
          {
#line 295
          errore("select");
          }
#line 296
          goto while_break;
        }
      }
#line 298
      goto while_continue;
    }
    {
#line 302
    fill = get_buffer_real(fs, cs->offset + cs->write_pos, (u8 )askfor, (void *)0,
                           (void **)(& filebuf));
    }
#line 308
    if (fill < (u8 )askfor) {
#line 310
      cs->write_max = cs->write_pos + fill;
    }
#line 312
    if (fill <= 0ULL) {
#line 316
      goto while_continue;
    }
    {
#line 320
    result = write(cs->write_pipe, (void const   *)filebuf, (size_t )fill);
    }
#line 324
    if (result >= 0L) {
#line 325
      cs->write_pos += (u8 )result;
#line 326
      goto while_continue;
    } else {
      {
#line 328
      tmp___2 = __errno_location();
      }
#line 328
      if (*tmp___2 == 4) {
#line 329
        goto while_continue;
      }
      {
#line 330
      tmp___3 = __errno_location();
      }
#line 330
      if (*tmp___3 != 11) {
        {
#line 331
        errore("write to pipe");
        }
#line 332
        goto while_break;
      }
    }
    {
#line 337
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 337
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_set.__fds_bits[0]): "memory");
#line 337
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 338
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& write_set.__fds_bits[0]): "memory");
#line 338
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 339
    read_set.__fds_bits[cs->read_pipe / (8 * (int )sizeof(__fd_mask ))] |= 1L << cs->read_pipe % (8 * (int )sizeof(__fd_mask ));
#line 340
    write_set.__fds_bits[cs->write_pipe / (8 * (int )sizeof(__fd_mask ))] |= 1L << cs->write_pipe % (8 * (int )sizeof(__fd_mask ));
#line 344
    selresult = select(cs->nfds, (fd_set */* __restrict  */)(& read_set), (fd_set */* __restrict  */)(& write_set),
                       (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 348
    if (selresult < 0) {
      {
#line 348
      tmp___4 = __errno_location();
      }
#line 348
      if (*tmp___4 != 4) {
        {
#line 349
        errore("select");
        }
#line 350
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  return (got);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/disktype-9/compressed.c"
static void close_compressed(SOURCE *s ) 
{ 
  COMPRESSED_SOURCE *cs ;
  int status ;

  {
#line 363
  cs = (COMPRESSED_SOURCE *)s;
#line 366
  if (cs->write_pipe >= 0) {
    {
#line 367
    close(cs->write_pipe);
    }
  }
#line 368
  if (cs->read_pipe >= 0) {
    {
#line 369
    close(cs->read_pipe);
    }
  }
  {
#line 370
  kill(cs->pid, 1);
#line 371
  waitpid(cs->pid, & status, 0);
  }
#line 372
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdaccess.c"
static int cddb_sum(int n ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdaccess.c"
int analyze_cdaccess(int fd , SOURCE *s , int level ) 
{ 
  int i ;
  int first ;
  int last ;
  int ntracks ;
  int cksum ;
  int totaltime ;
  int seconds ;
  u4 diskid ;
  u1 ctrl[100] ;
  u4 lba[100] ;
  u4 length ;
  char human_readable_size[256] ;
  struct cdrom_tochdr tochdr ;
  struct cdrom_tocentry tocentry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 74
  tmp = ioctl(fd, 21253UL, & tochdr);
  }
#line 74
  if (tmp < 0) {
#line 75
    return (0);
  }
#line 77
  first = (int )tochdr.cdth_trk0;
#line 78
  last = (int )tochdr.cdth_trk1;
#line 81
  ntracks = (last + 1) - first;
#line 82
  if (ntracks > 99) {
#line 83
    return (0);
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i <= ntracks)) {
#line 86
      goto while_break;
    }
#line 88
    if (i == ntracks) {
#line 89
      tocentry.cdte_track = (__u8 )170;
    } else {
#line 91
      tocentry.cdte_track = (__u8 )(first + i);
    }
    {
#line 92
    tocentry.cdte_format = (__u8 )1;
#line 93
    tmp___0 = ioctl(fd, 21254UL, & tocentry);
    }
#line 93
    if (tmp___0 < 0) {
#line 95
      return (0);
    }
#line 97
    ctrl[i] = tocentry.cdte_ctrl;
#line 98
    lba[i] = (u4 )tocentry.cdte_addr.lba;
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  cksum = 0;
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i < ntracks)) {
#line 108
      goto while_break___0;
    }
    {
#line 109
    tmp___1 = cddb_sum((int )((lba[i] + 150UL) / 75UL));
#line 109
    cksum += tmp___1;
#line 108
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  totaltime = (int )((lba[ntracks] + 150UL) / 75UL - (lba[0] + 150UL) / 75UL);
#line 112
  diskid = (((u4 )(cksum % 255) << 24) | ((u4 )totaltime << 8)) | (u4 )ntracks;
#line 115
  if (ntracks != 1) {
#line 115
    tmp___2 = "s";
  } else {
#line 115
    tmp___2 = "";
  }
  {
#line 115
  print_line(level, "CD-ROM, %d track%s, CDDB disk ID %08lX", ntracks, tmp___2, diskid);
#line 119
  i = 0;
  }
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    if (! (i < ntracks)) {
#line 119
      goto while_break___1;
    }
#line 121
    length = lba[i + 1] - lba[i];
#line 123
    if (((int )ctrl[i] & 4) == 0) {
      {
#line 125
      seconds = (int )(length / 75UL);
#line 126
      format_size(human_readable_size, (u8 )length * 2352ULL);
#line 127
      print_line(level, "Track %d: Audio track, %s, %3d min %02d sec", first + i,
                 human_readable_size, seconds / 60, seconds % 60);
      }
    } else {
      {
#line 133
      format_size(human_readable_size, (u8 )(length * 2048UL));
#line 134
      print_line(level, "Track %d: Data track, %s", first + i, human_readable_size);
#line 139
      analyze_source_special(s, level + 1, (u8 )lba[i] * 2048ULL, (u8 )(length - 250UL) * 2048ULL);
      }
    }
#line 119
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 144
  return (1);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/disktype-9/cdaccess.c"
static int cddb_sum(int n ) 
{ 
  int ret ;

  {
#line 154
  ret = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (n > 0)) {
#line 156
      goto while_break;
    }
#line 157
    ret += n % 10;
#line 158
    n /= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (ret);
}
}
