/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 22 "../include/sg_pt.h"
struct sg_pt_base;
#line 44 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 20 "/usr/include/linux/bsg.h"
struct sg_io_v4 {
   __s32 guard ;
   __u32 protocol ;
   __u32 subprotocol ;
   __u32 request_len ;
   __u64 request ;
   __u64 request_tag ;
   __u32 request_attr ;
   __u32 request_priority ;
   __u32 request_extra ;
   __u32 max_response_len ;
   __u64 response ;
   __u32 dout_iovec_count ;
   __u32 dout_xfer_len ;
   __u32 din_iovec_count ;
   __u32 din_xfer_len ;
   __u64 dout_xferp ;
   __u64 din_xferp ;
   __u32 timeout ;
   __u32 flags ;
   __u64 usr_ptr ;
   __u32 spare_in ;
   __u32 driver_status ;
   __u32 transport_status ;
   __u32 device_status ;
   __u32 retry_delay ;
   __u32 info ;
   __u32 duration ;
   __u32 response_len ;
   __s32 din_resid ;
   __s32 dout_resid ;
   __u64 generated_tag ;
   __u32 spare_out ;
   __u32 padding ;
};
#line 491 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
struct sg_pt_linux_scsi {
   struct sg_io_v4 io_hdr ;
   int in_err ;
   int os_err ;
   unsigned char tmf_request[4] ;
};
#line 498 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
struct sg_pt_base {
   struct sg_pt_linux_scsi impl ;
};
#line 37 "../include/sg_lib_data.h"
struct sg_lib_value_name_t {
   int value ;
   int peri_dev_type ;
   char const   *name ;
};
#line 43 "../include/sg_lib_data.h"
struct sg_lib_asc_ascq_t {
   unsigned char asc ;
   unsigned char ascq ;
   char const   *text ;
};
#line 49 "../include/sg_lib_data.h"
struct sg_lib_asc_ascq_range_t {
   unsigned char asc ;
   unsigned char ascq_min ;
   unsigned char ascq_max ;
   char const   *text ;
};
#line 161 "../include/sg_cmds_basic.h"
struct sg_simple_inquiry_resp {
   unsigned char peripheral_qualifier ;
   unsigned char peripheral_type ;
   unsigned char rmb ;
   unsigned char version ;
   unsigned char byte_3 ;
   unsigned char byte_5 ;
   unsigned char byte_6 ;
   unsigned char byte_7 ;
   char vendor[9] ;
   char product[17] ;
   char revision[5] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 245 "/usr/include/unistd.h"
typedef __off64_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_17 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_17 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.h"
struct flags_t {
   int append ;
   int cdbsz ;
   int coe ;
   int direct ;
   int dpo ;
   int errblk ;
   int excl ;
   int fdatasync ;
   int flock ;
   int force ;
   int fsync ;
   int fua ;
   int fua_nv ;
   int pdt ;
   int nocache ;
   int norcap ;
   int nowrite ;
   int pt ;
   int resume ;
   int retries ;
   int self ;
   int sparing ;
   int sparse ;
   int ssync ;
   int strunc ;
   int sync ;
   int trunc ;
   int wsame16 ;
};
#line 146 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.h"
struct opts_t {
   int64_t skip ;
   int64_t seek ;
   int bs_given ;
   int ibs ;
   int ibs_given ;
   int obs ;
   int obs_given ;
   int bpt_i ;
   int bpt_given ;
   int obpc ;
   char inf[512] ;
   int in_type ;
   int infd ;
   char outf[512] ;
   int outf_given ;
   int out_type ;
   int outfd ;
   char out2f[512] ;
   int out2_type ;
   int out2fd ;
   int cdbsz_given ;
   struct flags_t *iflagp ;
   struct flags_t *oflagp ;
};
#line 178 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.h"
struct cp_state_t {
   int64_t if_filepos ;
   int64_t of_filepos ;
   int icbpt ;
   int ocbpt ;
   int bytes_read ;
   int bytes_of ;
   int bytes_of2 ;
   int leave_after_write ;
   int leave_reason ;
   int partial_write_bytes ;
};
#line 191 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.h"
struct signum_name_t {
   int num ;
   char *name ;
};
#line 138 "../include/sg_lib.h"
struct sg_scsi_sense_hdr {
   unsigned char response_code ;
   unsigned char sense_key ;
   unsigned char asc ;
   unsigned char ascq ;
   unsigned char byte4 ;
   unsigned char byte5 ;
   unsigned char byte6 ;
   unsigned char additional_length ;
};
#line 1368 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
union u_t {
   unsigned short s ;
   unsigned char c[sizeof(unsigned short )] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 32 "../include/sg_pt.h"
int scsi_pt_open_device(char const   *device_name , int read_only , int verbose___0 ) ;
#line 38
int scsi_pt_open_flags(char const   *device_name , int flags , int verbose___0 ) ;
#line 42
int scsi_pt_close_device(int device_fd ) ;
#line 49
struct sg_pt_base *construct_scsi_pt_obj(void) ;
#line 53
void clear_scsi_pt_obj(struct sg_pt_base *vp ) ;
#line 56
void set_scsi_pt_cdb(struct sg_pt_base *vp , unsigned char const   *cdb , int cdb_len ) ;
#line 59
void set_scsi_pt_sense(struct sg_pt_base *vp , unsigned char *sense , int max_sense_len ) ;
#line 62
void set_scsi_pt_data_in(struct sg_pt_base *vp , unsigned char *dxferp , int dxfer_len ) ;
#line 65
void set_scsi_pt_data_out(struct sg_pt_base *vp , unsigned char const   *dxferp ,
                          int dxfer_len ) ;
#line 68
void set_scsi_pt_packet_id(struct sg_pt_base *vp , int pack_id ) ;
#line 69
void set_scsi_pt_tag(struct sg_pt_base *vp , uint64_t tag ) ;
#line 70
void set_scsi_pt_task_management(struct sg_pt_base *vp , int tmf_code ) ;
#line 72
void set_scsi_pt_task_attr(struct sg_pt_base *vp , int attribute , int priority ) ;
#line 84
void set_scsi_pt_flags(struct sg_pt_base *vp , int flags ) ;
#line 95
int do_scsi_pt(struct sg_pt_base *vp , int fd , int time_secs , int verbose___0 ) ;
#line 104
int get_scsi_pt_result_category(struct sg_pt_base  const  *vp ) ;
#line 107
int get_scsi_pt_resid(struct sg_pt_base  const  *vp ) ;
#line 110
int get_scsi_pt_status_response(struct sg_pt_base  const  *vp ) ;
#line 113
int get_scsi_pt_sense_len(struct sg_pt_base  const  *vp ) ;
#line 115
int get_scsi_pt_os_err(struct sg_pt_base  const  *vp ) ;
#line 116
char *get_scsi_pt_os_err_str(struct sg_pt_base  const  *vp , int max_b_len , char *b ) ;
#line 119
int get_scsi_pt_transport_err(struct sg_pt_base  const  *vp ) ;
#line 120
char *get_scsi_pt_transport_err_str(struct sg_pt_base  const  *vp , int max_b_len ,
                                    char *b ) ;
#line 124
int get_scsi_pt_duration_ms(struct sg_pt_base  const  *vp ) ;
#line 130
void destruct_scsi_pt_obj(struct sg_pt_base *vp ) ;
#line 210 "../include/sg_lib.h"
FILE *sg_warnings_strm ;
#line 286
char *safe_strerror(int errnum ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static char const   *linux_host_bytes[14]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
  {      "DID_OK",      "DID_NO_CONNECT",      "DID_BUS_BUSY",      "DID_TIME_OUT", 
        "DID_BAD_TARGET",      "DID_ABORT",      "DID_PARITY",      "DID_ERROR", 
        "DID_RESET",      "DID_BAD_INTR",      "DID_PASSTHROUGH",      "DID_SOFT_ERROR", 
        "DID_IMM_RETRY",      "DID_REQUEUE"};
#line 42 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static char const   *linux_driver_bytes[9]  = 
#line 42
  {      "DRIVER_OK",      "DRIVER_BUSY",      "DRIVER_SOFT",      "DRIVER_MEDIA", 
        "DRIVER_ERROR",      "DRIVER_INVALID",      "DRIVER_TIMEOUT",      "DRIVER_HARD", 
        "DRIVER_SENSE"};
#line 51 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static char const   *linux_driver_suggests[9]  = 
#line 51
  {      "SUGGEST_OK",      "SUGGEST_RETRY",      "SUGGEST_ABORT",      "SUGGEST_REMAP", 
        "SUGGEST_DIE",      "UNKNOWN",      "UNKNOWN",      "UNKNOWN", 
        "SUGGEST_SENSE"};
#line 502 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static int bsg_major_checked  =    0;
#line 503 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static int bsg_major  =    0;
#line 507 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static void find_bsg_major(int verbose___0 ) 
{ 
  char const   *proc_devices ;
  FILE *fp ;
  char a[128] ;
  char b[128] ;
  char *cp ;
  int n ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 510
  proc_devices = "/proc/devices";
#line 517
  fp = fopen((char const   */* __restrict  */)proc_devices, (char const   */* __restrict  */)"r");
  }
#line 517
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 518
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 519
      sg_warnings_strm = stderr;
    }
#line 520
    if (verbose___0) {
      {
#line 521
      tmp = __errno_location();
#line 521
      tmp___0 = strerror(*tmp);
#line 521
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"fopen %s failed: %s\n",
              proc_devices, tmp___0);
      }
    }
#line 523
    return;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 525
    cp = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)fp);
    }
#line 525
    if (! cp) {
#line 525
      goto while_break;
    }
    {
#line 526
    tmp___1 = sscanf((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"%s",
                     a);
    }
#line 526
    if (1 == tmp___1) {
      {
#line 526
      tmp___2 = memcmp((void const   *)(a), (void const   *)"Character", (size_t )9);
      }
#line 526
      if (0 == tmp___2) {
#line 528
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (cp) {
      {
#line 530
      cp = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)fp);
      }
#line 530
      if (! cp) {
#line 530
        goto while_break___0;
      }
    } else {
#line 530
      goto while_break___0;
    }
    {
#line 531
    tmp___4 = sscanf((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"%d %s",
                     & n, a);
    }
#line 531
    if (2 == tmp___4) {
      {
#line 532
      tmp___3 = strcmp("bsg", (char const   *)(a));
      }
#line 532
      if (0 == tmp___3) {
#line 533
        bsg_major = n;
#line 534
        goto while_break___0;
      }
    } else {
#line 537
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 539
  if (verbose___0 > 3) {
#line 540
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 541
      sg_warnings_strm = stderr;
    }
#line 542
    if (cp) {
      {
#line 543
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"found bsg_major=%d\n",
              bsg_major);
      }
    } else {
      {
#line 545
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"found no bsg char device in %s\n",
              proc_devices);
      }
    }
  }
  {
#line 548
  fclose(fp);
  }
#line 549
  return;
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int scsi_pt_open_device(char const   *device_name , int read_only , int verbose___0 ) 
{ 
  int oflags ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  oflags = 2048;
#line 558
  if (read_only) {
#line 558
    tmp = 0;
  } else {
#line 558
    tmp = 2;
  }
  {
#line 558
  oflags |= tmp;
#line 559
  tmp___0 = scsi_pt_open_flags(device_name, oflags, verbose___0);
  }
#line 559
  return (tmp___0);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int scsi_pt_open_flags(char const   *device_name , int flags , int verbose___0 ) 
{ 
  int fd ;
  int *tmp ;

  {
#line 570
  if (! bsg_major_checked) {
    {
#line 571
    bsg_major_checked = 1;
#line 572
    find_bsg_major(verbose___0);
    }
  }
#line 574
  if (verbose___0 > 1) {
#line 575
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 576
      sg_warnings_strm = stderr;
    }
    {
#line 577
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"open %s with flags=0x%x\n",
            device_name, flags);
    }
  }
  {
#line 580
  fd = open(device_name, flags);
  }
#line 581
  if (fd < 0) {
    {
#line 582
    tmp = __errno_location();
#line 582
    fd = - *tmp;
    }
  }
#line 583
  return (fd);
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int scsi_pt_close_device(int device_fd ) 
{ 
  int res ;
  int *tmp ;

  {
  {
#line 592
  res = close(device_fd);
  }
#line 593
  if (res < 0) {
    {
#line 594
    tmp = __errno_location();
#line 594
    res = - *tmp;
    }
  }
#line 595
  return (res);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
struct sg_pt_base *construct_scsi_pt_obj(void) 
{ 
  struct sg_pt_linux_scsi *ptp ;
  void *tmp ;

  {
  {
#line 604
  tmp = calloc((size_t )1, sizeof(struct sg_pt_linux_scsi ));
#line 604
  ptp = (struct sg_pt_linux_scsi *)tmp;
  }
#line 606
  if (ptp) {
#line 607
    ptp->io_hdr.guard = 'Q';
#line 609
    ptp->io_hdr.protocol = (__u32 )0;
#line 612
    ptp->io_hdr.subprotocol = (__u32 )0;
  }
#line 615
  return ((struct sg_pt_base *)ptp);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void destruct_scsi_pt_obj(struct sg_pt_base *vp ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 621
  ptp = & vp->impl;
#line 623
  if (ptp) {
    {
#line 624
    free((void *)ptp);
    }
  }
#line 625
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void clear_scsi_pt_obj(struct sg_pt_base *vp ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 630
  ptp = & vp->impl;
#line 632
  if (ptp) {
    {
#line 633
    memset((void *)ptp, 0, sizeof(struct sg_pt_linux_scsi ));
#line 634
    ptp->io_hdr.guard = 'Q';
#line 636
    ptp->io_hdr.protocol = (__u32 )0;
#line 639
    ptp->io_hdr.subprotocol = (__u32 )0;
    }
  }
#line 642
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_cdb(struct sg_pt_base *vp , unsigned char const   *cdb , int cdb_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 648
  ptp = & vp->impl;
#line 650
  if (ptp->io_hdr.request) {
#line 651
    (ptp->in_err) ++;
  }
#line 653
  ptp->io_hdr.request = (__u64 )((long )cdb);
#line 654
  ptp->io_hdr.request_len = (__u32 )cdb_len;
#line 655
  return;
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_sense(struct sg_pt_base *vp , unsigned char *sense , int max_sense_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 661
  ptp = & vp->impl;
#line 663
  if (ptp->io_hdr.response) {
#line 664
    (ptp->in_err) ++;
  }
  {
#line 665
  memset((void *)sense, 0, (size_t )max_sense_len);
#line 666
  ptp->io_hdr.response = (__u64 )((long )sense);
#line 667
  ptp->io_hdr.max_response_len = (__u32 )max_sense_len;
  }
#line 668
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_data_in(struct sg_pt_base *vp , unsigned char *dxferp , int dxfer_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 675
  ptp = & vp->impl;
#line 677
  if (ptp->io_hdr.din_xferp) {
#line 678
    (ptp->in_err) ++;
  }
#line 679
  if (dxfer_len > 0) {
#line 680
    ptp->io_hdr.din_xferp = (__u64 )((long )dxferp);
#line 681
    ptp->io_hdr.din_xfer_len = (__u32 )dxfer_len;
  }
#line 683
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_data_out(struct sg_pt_base *vp , unsigned char const   *dxferp ,
                          int dxfer_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 690
  ptp = & vp->impl;
#line 692
  if (ptp->io_hdr.dout_xferp) {
#line 693
    (ptp->in_err) ++;
  }
#line 694
  if (dxfer_len > 0) {
#line 695
    ptp->io_hdr.dout_xferp = (__u64 )((long )dxferp);
#line 696
    ptp->io_hdr.dout_xfer_len = (__u32 )dxfer_len;
  }
#line 698
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_packet_id(struct sg_pt_base *vp , int pack_id ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 703
  ptp = & vp->impl;
#line 705
  ptp->io_hdr.spare_in = (__u32 )pack_id;
#line 706
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_tag(struct sg_pt_base *vp , uint64_t tag ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 711
  ptp = & vp->impl;
#line 713
  ptp->io_hdr.request_tag = (__u64 )tag;
#line 714
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_task_management(struct sg_pt_base *vp , int tmf_code ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 720
  ptp = & vp->impl;
#line 722
  ptp->io_hdr.subprotocol = (__u32 )1;
#line 723
  ptp->tmf_request[0] = (unsigned char )tmf_code;
#line 724
  ptp->io_hdr.request = (__u64 )((long )(& ptp->tmf_request[0]));
#line 725
  ptp->io_hdr.request_len = (__u32 )1;
#line 726
  return;
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_task_attr(struct sg_pt_base *vp , int attribute , int priority ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 731
  ptp = & vp->impl;
#line 733
  ptp->io_hdr.request_attr = (__u32 )attribute;
#line 734
  ptp->io_hdr.request_priority = (__u32 )priority;
#line 735
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
void set_scsi_pt_flags(struct sg_pt_base *vp , int flags ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 744
  ptp = & vp->impl;
#line 747
  if (16 & flags) {
#line 748
    ptp->io_hdr.flags |= 16U;
  }
#line 749
  if (32 & flags) {
#line 750
    ptp->io_hdr.flags &= 4294967279U;
  }
#line 751
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_resid(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 757
  ptp = & vp->impl;
#line 759
  return ((int )ptp->io_hdr.din_resid);
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_status_response(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 765
  ptp = & vp->impl;
#line 767
  return ((int )ptp->io_hdr.device_status);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_sense_len(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 773
  ptp = & vp->impl;
#line 775
  return ((int )ptp->io_hdr.response_len);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_duration_ms(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 781
  ptp = & vp->impl;
#line 783
  return ((int )ptp->io_hdr.duration);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_transport_err(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 789
  ptp = & vp->impl;
#line 791
  return ((int )ptp->io_hdr.transport_status);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
char *get_scsi_pt_transport_err_str(struct sg_pt_base  const  *vp , int max_b_len ,
                                    char *b ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;
  int ds ;
  int hs ;
  int n ;
  int m ;
  char *cp ;
  int driv ;
  int sugg ;
  char const   *driv_cp ;
  char const   *sugg_cp ;

  {
#line 799
  ptp = & vp->impl;
#line 800
  ds = (int )ptp->io_hdr.driver_status;
#line 801
  hs = (int )ptp->io_hdr.transport_status;
#line 803
  cp = b;
#line 805
  driv_cp = "invalid";
#line 806
  sugg_cp = "invalid";
#line 808
  m = max_b_len;
#line 809
  n = 0;
#line 810
  if (hs) {
#line 811
    if (hs < 0) {
      {
#line 812
      n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Host_status=0x%02x is invalid\n",
                   hs);
      }
    } else
#line 811
    if (hs >= (int )(sizeof(linux_host_bytes) / sizeof(linux_host_bytes[0]))) {
      {
#line 812
      n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Host_status=0x%02x is invalid\n",
                   hs);
      }
    } else {
      {
#line 814
      n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Host_status=0x%02x [%s]\n",
                   hs, linux_host_bytes[hs]);
      }
    }
  }
#line 817
  m -= n;
#line 818
  if (m < 1) {
#line 819
    *(b + (max_b_len - 1)) = (char )'\000';
#line 820
    return (b);
  }
#line 822
  cp += n;
#line 823
  driv = ds & 15;
#line 824
  if (driv < (int )(sizeof(linux_driver_bytes) / sizeof(linux_driver_bytes[0]))) {
#line 825
    driv_cp = linux_driver_bytes[driv];
  }
#line 826
  sugg = (ds & 240) >> 4;
#line 827
  if (sugg < (int )(sizeof(linux_driver_suggests) / sizeof(linux_driver_suggests[0]))) {
#line 828
    sugg_cp = linux_driver_suggests[sugg];
  }
  {
#line 829
  n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Driver_status=0x%02x [%s, %s]\n",
               ds, driv_cp, sugg_cp);
#line 831
  m -= n;
  }
#line 832
  if (m < 1) {
#line 833
    *(b + (max_b_len - 1)) = (char )'\000';
  }
#line 834
  return (b);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_result_category(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;
  int dr_st ;
  int scsi_st ;

  {
#line 840
  ptp = & vp->impl;
#line 841
  dr_st = (int )(ptp->io_hdr.driver_status & 15U);
#line 842
  scsi_st = (int )(ptp->io_hdr.device_status & 126U);
#line 844
  if (ptp->os_err) {
#line 845
    return (4);
  } else
#line 846
  if (ptp->io_hdr.transport_status) {
#line 847
    return (3);
  } else
#line 848
  if (dr_st) {
#line 848
    if (8 != dr_st) {
#line 849
      return (3);
    } else {
#line 848
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 850
  if (8 == dr_st) {
#line 853
    return (2);
  } else
#line 850
  if (2 == scsi_st) {
#line 853
    return (2);
  } else
#line 850
  if (34 == scsi_st) {
#line 853
    return (2);
  } else
#line 854
  if (scsi_st) {
#line 855
    return (1);
  } else {
#line 857
    return (0);
  }
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int get_scsi_pt_os_err(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 863
  ptp = & vp->impl;
#line 865
  return ((int )ptp->os_err);
}
}
#line 868 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
char *get_scsi_pt_os_err_str(struct sg_pt_base  const  *vp , int max_b_len , char *b ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;
  char const   *cp ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 871
  ptp = & vp->impl;
#line 874
  tmp = safe_strerror((int )ptp->os_err);
#line 874
  cp = (char const   *)tmp;
#line 875
  strncpy((char */* __restrict  */)b, (char const   */* __restrict  */)cp, (size_t )max_b_len);
#line 876
  tmp___0 = strlen(cp);
  }
#line 876
  if ((int )tmp___0 >= max_b_len) {
#line 877
    *(b + (max_b_len - 1)) = (char )'\000';
  }
#line 878
  return (b);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
static int do_scsi_pt_v3(struct sg_pt_linux_scsi *ptp , int fd , int time_secs , int verbose___0 ) 
{ 
  struct sg_io_hdr v3_hdr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 888
  memset((void *)(& v3_hdr), 0, sizeof(v3_hdr));
#line 890
  v3_hdr.interface_id = 'S';
#line 891
  v3_hdr.dxfer_direction = -1;
#line 892
  v3_hdr.cmdp = (unsigned char *)((void *)((long )ptp->io_hdr.request));
#line 893
  v3_hdr.cmd_len = (unsigned char )ptp->io_hdr.request_len;
  }
#line 894
  if (ptp->io_hdr.din_xfer_len > 0U) {
#line 895
    if (ptp->io_hdr.dout_xfer_len > 0U) {
#line 896
      if (verbose___0) {
        {
#line 897
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"sgv3 doesn\'t support bidi\n");
        }
      }
#line 898
      return (1);
    }
#line 900
    v3_hdr.dxferp = (void *)((long )ptp->io_hdr.din_xferp);
#line 901
    v3_hdr.dxfer_len = ptp->io_hdr.din_xfer_len;
#line 902
    v3_hdr.dxfer_direction = -3;
  } else
#line 903
  if (ptp->io_hdr.dout_xfer_len > 0U) {
#line 904
    v3_hdr.dxferp = (void *)((long )ptp->io_hdr.dout_xferp);
#line 905
    v3_hdr.dxfer_len = ptp->io_hdr.dout_xfer_len;
#line 906
    v3_hdr.dxfer_direction = -2;
  }
#line 908
  if (ptp->io_hdr.response) {
#line 908
    if (ptp->io_hdr.max_response_len > 0U) {
#line 909
      v3_hdr.sbp = (unsigned char *)((void *)((long )ptp->io_hdr.response));
#line 910
      v3_hdr.mx_sb_len = (unsigned char )ptp->io_hdr.max_response_len;
    }
  }
#line 912
  v3_hdr.pack_id = (int )ptp->io_hdr.spare_in;
#line 914
  if ((unsigned long )((void *)0) == (unsigned long )v3_hdr.cmdp) {
#line 915
    if (verbose___0) {
      {
#line 916
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"No SCSI command (cdb) given\n");
      }
    }
#line 917
    return (1);
  }
#line 920
  if (time_secs > 0) {
#line 920
    v3_hdr.timeout = (unsigned int )(time_secs * 1000);
  } else {
#line 920
    v3_hdr.timeout = 60000U;
  }
  {
#line 922
  tmp___1 = ioctl(fd, 8837UL, & v3_hdr);
  }
#line 922
  if (tmp___1 < 0) {
    {
#line 923
    tmp = __errno_location();
#line 923
    ptp->os_err = *tmp;
    }
#line 924
    if (verbose___0 > 1) {
      {
#line 925
      tmp___0 = strerror(ptp->os_err);
#line 925
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"ioctl(SG_IO v3) failed: %s (errno=%d)\n",
              tmp___0, ptp->os_err);
      }
    }
#line 927
    return (- ptp->os_err);
  }
#line 929
  ptp->io_hdr.device_status = (__u32 )v3_hdr.status;
#line 930
  ptp->io_hdr.driver_status = (__u32 )v3_hdr.driver_status;
#line 931
  ptp->io_hdr.transport_status = (__u32 )v3_hdr.host_status;
#line 932
  ptp->io_hdr.response_len = (__u32 )v3_hdr.sb_len_wr;
#line 933
  ptp->io_hdr.duration = v3_hdr.duration;
#line 934
  ptp->io_hdr.din_resid = v3_hdr.resid;
#line 936
  return (0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_linux.c"
int do_scsi_pt(struct sg_pt_base *vp , int fd , int time_secs , int verbose___0 ) 
{ 
  struct sg_pt_linux_scsi *ptp ;
  void *p ;
  int tmp ;
  struct stat a_stat ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 945
  ptp = & vp->impl;
#line 948
  if (! bsg_major_checked) {
    {
#line 949
    bsg_major_checked = 1;
#line 950
    find_bsg_major(verbose___0);
    }
  }
#line 952
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 953
    sg_warnings_strm = stderr;
  }
#line 954
  ptp->os_err = 0;
#line 955
  if (ptp->in_err) {
#line 956
    if (verbose___0) {
      {
#line 957
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Replicated or unused set_scsi_pt... functions\n");
      }
    }
#line 959
    return (1);
  }
#line 961
  if (bsg_major <= 0) {
    {
#line 962
    tmp = do_scsi_pt_v3(ptp, fd, time_secs, verbose___0);
    }
#line 962
    return (tmp);
  } else {
    {
#line 966
    tmp___2 = fstat(fd, & a_stat);
    }
#line 966
    if (tmp___2 < 0) {
      {
#line 967
      tmp___0 = __errno_location();
#line 967
      ptp->os_err = *tmp___0;
      }
#line 968
      if (verbose___0 > 1) {
        {
#line 969
        tmp___1 = strerror(ptp->os_err);
#line 969
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"fstat() failed: %s (errno=%d)\n",
                tmp___1, ptp->os_err);
        }
      }
#line 971
      return (- ptp->os_err);
    }
#line 978
    if (! ((a_stat.st_mode & 61440U) == 8192U)) {
      {
#line 980
      tmp___3 = do_scsi_pt_v3(ptp, fd, time_secs, verbose___0);
      }
#line 980
      return (tmp___3);
    } else {
      {
#line 978
      tmp___4 = gnu_dev_major((unsigned long long )a_stat.st_rdev);
      }
#line 978
      if (bsg_major != (int )tmp___4) {
        {
#line 980
        tmp___3 = do_scsi_pt_v3(ptp, fd, time_secs, verbose___0);
        }
#line 980
        return (tmp___3);
      }
    }
  }
#line 984
  if (! ptp->io_hdr.request) {
#line 985
    if (verbose___0) {
      {
#line 986
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"No SCSI command (cdb) given (v4)\n");
      }
    }
#line 987
    return (1);
  }
#line 990
  if (time_secs > 0) {
#line 990
    ptp->io_hdr.timeout = (__u32 )(time_secs * 1000);
  } else {
#line 990
    ptp->io_hdr.timeout = (__u32 )60000;
  }
#line 992
  if (ptp->io_hdr.response) {
#line 992
    if (ptp->io_hdr.max_response_len > 0U) {
      {
#line 993
      p = (void *)((long )ptp->io_hdr.response);
#line 994
      memset(p, 0, (size_t )ptp->io_hdr.max_response_len);
      }
    }
  }
  {
#line 996
  tmp___7 = ioctl(fd, 8837UL, & ptp->io_hdr);
  }
#line 996
  if (tmp___7 < 0) {
    {
#line 997
    tmp___5 = __errno_location();
#line 997
    ptp->os_err = *tmp___5;
    }
#line 998
    if (verbose___0 > 1) {
      {
#line 999
      tmp___6 = strerror(ptp->os_err);
#line 999
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"ioctl(SG_IO v4) failed: %s (errno=%d)\n",
              tmp___6, ptp->os_err);
      }
    }
#line 1001
    return (- ptp->os_err);
  }
#line 1003
  return (0);
}
}
#line 57 "../include/sg_lib_data.h"
char const   *sg_lib_version_str ;
#line 59
struct sg_lib_value_name_t sg_lib_normal_opcodes[181] ;
#line 60
struct sg_lib_value_name_t sg_lib_maint_in_arr[9] ;
#line 61
struct sg_lib_value_name_t sg_lib_maint_out_arr[7] ;
#line 62
struct sg_lib_value_name_t sg_lib_pr_in_arr[5] ;
#line 63
struct sg_lib_value_name_t sg_lib_pr_out_arr[9] ;
#line 64
struct sg_lib_value_name_t sg_lib_serv_in12_arr[2] ;
#line 65
struct sg_lib_value_name_t sg_lib_serv_out12_arr[2] ;
#line 66
struct sg_lib_value_name_t sg_lib_serv_in16_arr[5] ;
#line 67
struct sg_lib_value_name_t sg_lib_serv_out16_arr[3] ;
#line 68
struct sg_lib_value_name_t sg_lib_variable_length_arr[70] ;
#line 69
struct sg_lib_asc_ascq_range_t sg_lib_asc_ascq_range[7] ;
#line 70
struct sg_lib_asc_ascq_t sg_lib_asc_ascq[644] ;
#line 71
char const   *sg_lib_sense_key_desc[16] ;
#line 72
char const   *sg_lib_pdt_strs[32] ;
#line 73
char const   *sg_lib_transport_proto_strs[16] ;
#line 18 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
char const   *sg_lib_version_str  =    "1.65 20101205";
#line 20 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_normal_opcodes[181]  = 
#line 20
  {      {0, 0, "Test Unit Ready"}, 
        {1, 0, "Rezero Unit"}, 
        {1, 1, "Rewind"}, 
        {3, 0, "Request Sense"}, 
        {4, 0, "Format Unit"}, 
        {4, 1, "Format medium"}, 
        {4, 2, "Format"}, 
        {5, 0, "Read Block Limits"}, 
        {7, 0, "Reassign Blocks"}, 
        {7, 8, "Initialize element status"}, 
        {8, 0, "Read(6)"}, 
        {8, 3, "Receive"}, 
        {10, 0, "Write(6)"}, 
        {10, 2, "Print"}, 
        {10, 3, "Send"}, 
        {11, 0, "Seek(6)"}, 
        {11, 1, "Set capacity"}, 
        {11, 2, "Slew and print"}, 
        {15, 0, "Read reverse(6)"}, 
        {16, 0, "Write filemarks(6)"}, 
        {16, 2, "Synchronize buffer"}, 
        {17, 0, "Space(6)"}, 
        {18, 0, "Inquiry"}, 
        {19, 0, "Verify(6)"}, 
        {20, 0, "Recover buffered data"}, 
        {21, 0, "Mode select(6)"}, 
        {22, 0, "Reserve(6)"}, 
        {22, 8, "Reserve element(6)"}, 
        {23, 0, "Release(6)"}, 
        {23, 8, "Release element(6)"}, 
        {24, 0, "Copy"}, 
        {25, 0, "Erase(6)"}, 
        {26, 0, "Mode sense(6)"}, 
        {27, 0, "Start stop unit"}, 
        {27, 1, "Load unload"}, 
        {27, 18, "Load unload"}, 
        {27, 2, "Stop print"}, 
        {28, 0, "Receive diagnostic results"}, 
        {29, 0, "Send diagnostic"}, 
        {30, 0, "Prevent allow medium removal"}, 
        {35, 0, "Read Format capacities"}, 
        {36, 0, "Set window"}, 
        {37, 0, "Read capacity(10)"}, 
        {37, 15, "Read card capacity"}, 
        {40, 0, "Read(10)"}, 
        {41, 0, "Read generation"}, 
        {42, 0, "Write(10)"}, 
        {43, 0, "Seek(10)"}, 
        {43, 1, "Locate(10)"}, 
        {43, 8, "Position to element"}, 
        {44, 0, "Erase(10)"}, 
        {45, 0, "Read updated block"}, 
        {46, 0, "Write and verify(10)"}, 
        {47, 0, "Verify(10)"}, 
        {48, 0, "Search data high(10)"}, 
        {49, 0, "Search data equal(10)"}, 
        {50, 0, "Search data low(10)"}, 
        {51, 0, "Set limits(10)"}, 
        {52, 0, "Pre-fetch(10)"}, 
        {52, 1, "Read position"}, 
        {53, 0, "Synchronize cache(10)"}, 
        {54, 0, "Lock unlock cache(10)"}, 
        {55, 0, "Read defect data(10)"}, 
        {55, 8, "Initialize element status with range"}, 
        {56, 0, "Medium scan"}, 
        {57, 0, "Compare"}, 
        {58, 0, "Copy and verify"}, 
        {59, 0, "Write buffer"}, 
        {60, 0, "Read buffer"}, 
        {61, 0, "Update block"}, 
        {62, 0, "Read long(10)"}, 
        {63, 0, "Write long(10)"}, 
        {64, 0, "Change definition"}, 
        {65, 0, "Write same(10)"}, 
        {66, 0, "Unmap"}, 
        {66, 5, "Read sub-channel"}, 
        {67, 5, "Read TOC/PMA/ATIP"}, 
        {68, 0, "Report density support"}, 
        {69, 5, "Play audio(10)"}, 
        {70, 5, "Get configuration"}, 
        {71, 5, "Play audio msf"}, 
        {74, 5, "Get event status notification"}, 
        {75, 5, "Pause/resume"}, 
        {76, 0, "Log select"}, 
        {77, 0, "Log sense"}, 
        {78, 0, "Stop play/scan"}, 
        {80, 0, "Xdwrite(10)"}, 
        {81, 0, "Xpwrite(10)"}, 
        {81, 5, "Read disk information"}, 
        {82, 0, "Xdread(10)"}, 
        {82, 5, "Read track information"}, 
        {83, 0, "Reserve track"}, 
        {84, 0, "Send OPC information"}, 
        {85, 0, "Mode select(10)"}, 
        {86, 0, "Reserve(10)"}, 
        {86, 8, "Reserve element(10)"}, 
        {87, 0, "Release(10)"}, 
        {87, 8, "Release element(10)"}, 
        {88, 0, "Repair track"}, 
        {90, 0, "Mode sense(10)"}, 
        {91, 0, "Close track/session"}, 
        {92, 0, "Read buffer capacity"}, 
        {93, 0, "Send cue sheet"}, 
        {94, 0, "Persistent reserve in"}, 
        {95, 0, "Persistent reserve out"}, 
        {126, 0, "Extended cdb (XCBD)"}, 
        {128, 0, "Xdwrite extended(16)"}, 
        {128, 1, "Write filemarks(16)"}, 
        {129, 0, "Rebuild(16)"}, 
        {129, 1, "Read reverse(16)"}, 
        {130, 0, "Regenerate(16)"}, 
        {131, 0, "Extended copy"}, 
        {132, 0, "Receive copy results"}, 
        {133, 0, "ATA command pass through(16)"}, 
        {134, 0, "Access control in"}, 
        {135, 0, "Access control out"}, 
        {136, 0, "Read(16)"}, 
        {137, 0, "Compare and write"}, 
        {138, 0, "Write(16)"}, 
        {139, 0, "Orwrite(16)"}, 
        {140, 0, "Read attribute"}, 
        {141, 0, "Write attribute"}, 
        {142, 0, "Write and verify(16)"}, 
        {143, 0, "Verify(16)"}, 
        {144, 0, "Pre-fetch(16)"}, 
        {145, 0, "Synchronize cache(16)"}, 
        {145, 1, "Space(16)"}, 
        {146, 0, "Lock unlock cache(16)"}, 
        {146, 1, "Locate(16)"}, 
        {147, 0, "Write same(16)"}, 
        {147, 1, "Erase(16)"}, 
        {158, 0, "Service action in(16)"}, 
        {159, 0, "Service action out(16)"}, 
        {160, 0, "Report luns"}, 
        {161, 0, "ATA command pass through(12)"}, 
        {161, 5, "Blank"}, 
        {162, 0, "Security protocol in"}, 
        {163, 0, "Maintenance in"}, 
        {163, 5, "Send key"}, 
        {164, 0, "Maintenance out"}, 
        {164, 5, "Report key"}, 
        {165, 0, "Move medium"}, 
        {165, 5, "Play audio(12)"}, 
        {166, 0, "Exchange medium"}, 
        {166, 5, "Load/unload medium"}, 
        {167, 0, "Move medium attached"}, 
        {167, 5, "Set read ahead"}, 
        {168, 0, "Read(12)"}, 
        {169, 0, "Service action out(12)"}, 
        {170, 0, "Write(12)"}, 
        {171, 0, "Service action in(12)"}, 
        {172, 0, "erase(12)"}, 
        {172, 5, "Get performance"}, 
        {173, 5, "Read DVD/BD structure"}, 
        {174, 0, "Write and verify(12)"}, 
        {175, 0, "Verify(12)"}, 
        {176, 0, "Search data high(12)"}, 
        {177, 0, "Search data equal(12)"}, 
        {177, 8, "Open/close import/export element"}, 
        {178, 0, "Search data low(12)"}, 
        {179, 0, "Set limits(12)"}, 
        {180, 0, "Read element status attached"}, 
        {181, 0, "Security protocol out"}, 
        {181, 8, "Request volume element address"}, 
        {182, 0, "Send volume tag"}, 
        {182, 5, "Set streaming"}, 
        {183, 0, "Read defect data(12)"}, 
        {184, 0, "Read element status"}, 
        {185, 0, "Read CD msf"}, 
        {186, 0, "Redundancy group in"}, 
        {186, 5, "Scan"}, 
        {187, 0, "Redundancy group out"}, 
        {187, 5, "Set CD speed"}, 
        {188, 0, "Spare in"}, 
        {189, 0, "Spare out"}, 
        {189, 5, "Mechanism status"}, 
        {190, 0, "Volume set in"}, 
        {190, 5, "Read CD"}, 
        {191, 0, "Volume set out"}, 
        {191, 5, "Send DVD/BD structure"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 204 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_maint_in_arr[9]  = 
#line 204
  {      {5, 0, "Report identifying information"}, 
        {10, 0, "Report target port groups"}, 
        {11, 0, "Report aliases"}, 
        {12, 0, "Report supported operation codes"}, 
        {13, 0, "Report supported task management functions"}, 
        {14, 0, "Report priority"}, 
        {15, 0, "Report timestamp"}, 
        {16, 0, "Maintenance in"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 217 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_maint_out_arr[7]  = {      {6, 0, "Set identifying information"}, 
        {10, 0, "Set target port groups"}, 
        {11, 0, "Change aliases"}, 
        {14, 0, "Set priority"}, 
        {15, 0, "Set timestamp"}, 
        {16, 0, "Maintenance out"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 228 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_in12_arr[2]  = {      {1, 0, "Read media serial number"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 233 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_out12_arr[2]  = {      {255, 0, "Impossible command name"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 238 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_in16_arr[5]  = {      {16, 0, "Read capacity(16)"}, 
        {17, 0, "Read long(16)"}, 
        {18, 0, "Get LBA status"}, 
        {19, 0, "Report referrals"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 246 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_out16_arr[3]  = {      {17, 0, "Write long(16)"}, 
        {31, 18, "Notify data transfer device(16)"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 252 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_pr_in_arr[5]  = {      {0, 0, "Persistent reserve in, read keys"}, 
        {1, 0, "Persistent reserve in, read reservation"}, 
        {2, 0, "Persistent reserve in, report capabilities"}, 
        {3, 0, "Persistent reserve in, read full status"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 260 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_pr_out_arr[9]  = 
#line 260
  {      {0, 0, "Persistent reserve out, register"}, 
        {1, 0, "Persistent reserve out, reserve"}, 
        {2, 0, "Persistent reserve out, release"}, 
        {3, 0, "Persistent reserve out, clear"}, 
        {4, 0, "Persistent reserve out, preempt"}, 
        {5, 0, "Persistent reserve out, preempt and abort"}, 
        {6, 0, "Persistent reserve out, register and ignore existing key"}, 
        {7, 0, "Persistent reserve out, register and move"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 272 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_variable_length_arr[70]  = 
#line 272
  {      {1, 0, "Rebuild(32)"}, 
        {2, 0, "Regenerate(32)"}, 
        {3, 0, "Xdread(32)"}, 
        {4, 0, "Xdwrite(32)"}, 
        {5, 0, "Xdwrite extended(32)"}, 
        {6, 0, "Xpwrite(32)"}, 
        {7, 0, "Xdwriteread(32)"}, 
        {8, 0, "Xdwrite extended(64)"}, 
        {9, 0, "Read(32)"}, 
        {10, 0, "Verify(32)"}, 
        {11, 0, "Write(32)"}, 
        {12, 0, "Write an verify(32)"}, 
        {13, 0, "Write same(32)"}, 
        {14, 0, "Orwrite(32)"}, 
        {6144, 0, "Receive credential"}, 
        {34817, 0, "Format OSD (osd)"}, 
        {34818, 0, "Create (osd)"}, 
        {34819, 0, "List (osd)"}, 
        {34821, 0, "Read (osd)"}, 
        {34822, 0, "Write (osd)"}, 
        {34823, 0, "Append (osd)"}, 
        {34824, 0, "Flush (osd)"}, 
        {34826, 0, "Remove (osd)"}, 
        {34827, 0, "Create partition (osd)"}, 
        {34828, 0, "Remove partition (osd)"}, 
        {34830, 0, "Get attributes (osd)"}, 
        {34831, 0, "Set attributes (osd)"}, 
        {34834, 0, "Create and write (osd)"}, 
        {34837, 0, "Create collection (osd)"}, 
        {34838, 0, "Remove collection (osd)"}, 
        {34839, 0, "List collection (osd)"}, 
        {34840, 0, "Set key (osd)"}, 
        {34841, 0, "Set master key (osd)"}, 
        {34842, 0, "Flush collection (osd)"}, 
        {34843, 0, "Flush partition (osd)"}, 
        {34844, 0, "Flush OSD (osd)"}, 
        {34944, 0, "Object structure check (osd-2)"}, 
        {34945, 0, "Format OSD (osd-2)"}, 
        {34946, 0, "Create (osd-2)"}, 
        {34947, 0, "List (osd-2)"}, 
        {34948, 0, "Punch (osd-2)"}, 
        {34949, 0, "Read (osd-2)"}, 
        {34950, 0, "Write (osd-2)"}, 
        {34951, 0, "Append (osd-2)"}, 
        {34952, 0, "Flush (osd-2)"}, 
        {34953, 0, "Clear (osd-2)"}, 
        {34954, 0, "Remove (osd-2)"}, 
        {34955, 0, "Create partition (osd-2)"}, 
        {34956, 0, "Remove partition (osd-2)"}, 
        {34958, 0, "Get attributes (osd-2)"}, 
        {34959, 0, "Set attributes (osd-2)"}, 
        {34962, 0, "Create and write (osd-2)"}, 
        {34965, 0, "Create collection (osd-2)"}, 
        {34966, 0, "Remove collection (osd-2)"}, 
        {34967, 0, "List collection (osd-2)"}, 
        {34968, 0, "Set key (osd-2)"}, 
        {34969, 0, "Set master key (osd-2)"}, 
        {34970, 0, "Flush collection (osd-2)"}, 
        {34971, 0, "Flush partition (osd-2)"}, 
        {34972, 0, "Flush OSD (osd-2)"}, 
        {34976, 0, "Query (osd-2)"}, 
        {34977, 0, "Remove member objects (osd-2)"}, 
        {34978, 0, "Get member attributes (osd-2)"}, 
        {34979, 0, "Set member attributes (osd-2)"}, 
        {34993, 0, "Read map (osd-2)"}, 
        {36732, 0, "Perform SCSI command (osd-2)"}, 
        {36733, 0, "Perform task management function (osd-2)"}, 
        {36734, 0, "Perform SCSI command (osd)"}, 
        {36735, 0, "Perform task management function (osd)"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 348 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_asc_ascq_range_t sg_lib_asc_ascq_range[7]  = {      {(unsigned char)64, (unsigned char)1, (unsigned char)127, "Ram failure [0x%x]"}, 
        {(unsigned char)64,
      (unsigned char)128, (unsigned char)255, "Diagnostic failure on component [0x%x]"}, 
        {(unsigned char)65,
      (unsigned char)1, (unsigned char)255, "Data path failure [0x%x]"}, 
        {(unsigned char)66, (unsigned char)1, (unsigned char)255, "Power-on or self-test failure [0x%x]"}, 
        {(unsigned char)77,
      (unsigned char)0, (unsigned char)255, "Tagged overlapped commands [0x%x]"}, 
        {(unsigned char)112, (unsigned char)0, (unsigned char)255, "Decompression exception short algorithm id of 0x%x"}, 
        {(unsigned char)0,
      (unsigned char)0, (unsigned char)0, (char const   *)((void *)0)}};
#line 359 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
struct sg_lib_asc_ascq_t sg_lib_asc_ascq[644]  = 
#line 359
  {      {(unsigned char)0, (unsigned char)0, "No additional sense information"}, 
        {(unsigned char)0, (unsigned char)1, "Filemark detected"}, 
        {(unsigned char)0, (unsigned char)2, "End-of-partition/medium detected"}, 
        {(unsigned char)0, (unsigned char)3, "Setmark detected"}, 
        {(unsigned char)0, (unsigned char)4, "Beginning-of-partition/medium detected"}, 
        {(unsigned char)0,
      (unsigned char)5, "End-of-data detected"}, 
        {(unsigned char)0, (unsigned char)6, "I/O process terminated"}, 
        {(unsigned char)0, (unsigned char)7, "Programmable early warning detected"}, 
        {(unsigned char)0, (unsigned char)17, "Audio play operation in progress"}, 
        {(unsigned char)0, (unsigned char)18, "Audio play operation paused"}, 
        {(unsigned char)0, (unsigned char)19, "Audio play operation successfully completed"}, 
        {(unsigned char)0,
      (unsigned char)20, "Audio play operation stopped due to error"}, 
        {(unsigned char)0, (unsigned char)21, "No current audio status to return"}, 
        {(unsigned char)0, (unsigned char)22, "operation in progress"}, 
        {(unsigned char)0, (unsigned char)23, "Cleaning requested"}, 
        {(unsigned char)0, (unsigned char)24, "Erase operation in progress"}, 
        {(unsigned char)0, (unsigned char)25, "Locate operation in progress"}, 
        {(unsigned char)0, (unsigned char)26, "Rewind operation in progress"}, 
        {(unsigned char)0, (unsigned char)27, "Set capacity operation in progress"}, 
        {(unsigned char)0, (unsigned char)28, "Verify operation in progress"}, 
        {(unsigned char)0, (unsigned char)29, "ATA pass through information available"}, 
        {(unsigned char)0,
      (unsigned char)30, "Conflicting SA creation request"}, 
        {(unsigned char)0, (unsigned char)31, "Logical unit transitioning to another power condition"}, 
        {(unsigned char)1,
      (unsigned char)0, "No index/sector signal"}, 
        {(unsigned char)2, (unsigned char)0, "No seek complete"}, 
        {(unsigned char)3, (unsigned char)0, "Peripheral device write fault"}, 
        {(unsigned char)3, (unsigned char)1, "No write current"}, 
        {(unsigned char)3, (unsigned char)2, "Excessive write errors"}, 
        {(unsigned char)4, (unsigned char)0, "Logical unit not ready, cause not reportable"}, 
        {(unsigned char)4,
      (unsigned char)1, "Logical unit is in process of becoming ready"}, 
        {(unsigned char)4, (unsigned char)2, "Logical unit not ready, initializing command required"}, 
        {(unsigned char)4,
      (unsigned char)3, "Logical unit not ready, manual intervention required"}, 
        {(unsigned char)4, (unsigned char)4, "Logical unit not ready, format in progress"}, 
        {(unsigned char)4,
      (unsigned char)5, "Logical unit not ready, rebuild in progress"}, 
        {(unsigned char)4, (unsigned char)6, "Logical unit not ready, recalculation in progress"}, 
        {(unsigned char)4,
      (unsigned char)7, "Logical unit not ready, operation in progress"}, 
        {(unsigned char)4, (unsigned char)8, "Logical unit not ready, long write in progress"}, 
        {(unsigned char)4,
      (unsigned char)9, "Logical unit not ready, self-test in progress"}, 
        {(unsigned char)4, (unsigned char)10, "Logical unit not accessible, asymmetric access state transition"}, 
        {(unsigned char)4,
      (unsigned char)11, "Logical unit not accessible, target port in standby state"}, 
        {(unsigned char)4,
      (unsigned char)12, "Logical unit not accessible, target port in unavailable state"}, 
        {(unsigned char)4,
      (unsigned char)13, "Logical unit not ready, structure check required"}, 
        {(unsigned char)4, (unsigned char)16, "Logical unit not ready, auxiliary memory not accessible"}, 
        {(unsigned char)4,
      (unsigned char)17, "Logical unit not ready, notify (enable spinup) required"}, 
        {(unsigned char)4,
      (unsigned char)18, "Logical unit not ready, offline"}, 
        {(unsigned char)4, (unsigned char)19, "Logical unit not ready, SA creation in progress"}, 
        {(unsigned char)4,
      (unsigned char)20, "Logical unit not ready, space allocation in progress"}, 
        {(unsigned char)4, (unsigned char)21, "Logical unit not ready, robotics disabled"}, 
        {(unsigned char)4,
      (unsigned char)22, "Logical unit not ready, configuration required"}, 
        {(unsigned char)4, (unsigned char)23, "Logical unit not ready, calibration required"}, 
        {(unsigned char)4,
      (unsigned char)24, "Logical unit not ready, a door is open"}, 
        {(unsigned char)4, (unsigned char)25, "Logical unit not ready, operating in sequential mode"}, 
        {(unsigned char)4,
      (unsigned char)26, "Logical unit not ready, start stop unit command in progress"}, 
        {(unsigned char)5,
      (unsigned char)0, "Logical unit does not respond to selection"}, 
        {(unsigned char)6, (unsigned char)0, "No reference position found"}, 
        {(unsigned char)7, (unsigned char)0, "Multiple peripheral devices selected"}, 
        {(unsigned char)8,
      (unsigned char)0, "Logical unit communication failure"}, 
        {(unsigned char)8, (unsigned char)1, "Logical unit communication time-out"}, 
        {(unsigned char)8, (unsigned char)2, "Logical unit communication parity error"}, 
        {(unsigned char)8,
      (unsigned char)3, "Logical unit communication CRC error (Ultra-DMA/32)"}, 
        {(unsigned char)8, (unsigned char)4, "Unreachable copy target"}, 
        {(unsigned char)9, (unsigned char)0, "Track following error"}, 
        {(unsigned char)9, (unsigned char)1, "Tracking servo failure"}, 
        {(unsigned char)9, (unsigned char)2, "Focus servo failure"}, 
        {(unsigned char)9, (unsigned char)3, "Spindle servo failure"}, 
        {(unsigned char)9, (unsigned char)4, "Head select fault"}, 
        {(unsigned char)10, (unsigned char)0, "Error log overflow"}, 
        {(unsigned char)11, (unsigned char)0, "Warning"}, 
        {(unsigned char)11, (unsigned char)1, "Warning - specified temperature exceeded"}, 
        {(unsigned char)11,
      (unsigned char)2, "Warning - enclosure degraded"}, 
        {(unsigned char)11, (unsigned char)3, "Warning - background self-test failed"}, 
        {(unsigned char)11,
      (unsigned char)4, "Warning - background pre-scan detected medium error"}, 
        {(unsigned char)11, (unsigned char)5, "Warning - background medium scan detected medium error"}, 
        {(unsigned char)11,
      (unsigned char)6, "Warning - non-volatile cache now volatile"}, 
        {(unsigned char)11, (unsigned char)7, "Warning - degraded power to non-volatile cache"}, 
        {(unsigned char)11,
      (unsigned char)8, "Warning - power loss expected"}, 
        {(unsigned char)12, (unsigned char)0, "Write error"}, 
        {(unsigned char)12, (unsigned char)1, "Write error - recovered with auto reallocation"}, 
        {(unsigned char)12,
      (unsigned char)2, "Write error - auto reallocation failed"}, 
        {(unsigned char)12, (unsigned char)3, "Write error - recommend reassignment"}, 
        {(unsigned char)12,
      (unsigned char)4, "Compression check miscompare error"}, 
        {(unsigned char)12, (unsigned char)5, "Data expansion occurred during compression"}, 
        {(unsigned char)12,
      (unsigned char)6, "Block not compressible"}, 
        {(unsigned char)12, (unsigned char)7, "Write error - recovery needed"}, 
        {(unsigned char)12, (unsigned char)8, "Write error - recovery failed"}, 
        {(unsigned char)12, (unsigned char)9, "Write error - loss of streaming"}, 
        {(unsigned char)12, (unsigned char)10, "Write error - padding blocks added"}, 
        {(unsigned char)12,
      (unsigned char)11, "Auxiliary memory write error"}, 
        {(unsigned char)12, (unsigned char)12, "Write error - unexpected unsolicited data"}, 
        {(unsigned char)12,
      (unsigned char)13, "Write error - not enough unsolicited data"}, 
        {(unsigned char)12, (unsigned char)15, "Defects in error window"}, 
        {(unsigned char)13, (unsigned char)0, "Error detected by third party temporary initiator"}, 
        {(unsigned char)13,
      (unsigned char)1, "Third party device failure"}, 
        {(unsigned char)13, (unsigned char)2, "Copy target device not reachable"}, 
        {(unsigned char)13, (unsigned char)3, "Incorrect copy target device type"}, 
        {(unsigned char)13, (unsigned char)4, "Copy target device data underrun"}, 
        {(unsigned char)13, (unsigned char)5, "Copy target device data overrun"}, 
        {(unsigned char)14, (unsigned char)0, "Invalid information unit"}, 
        {(unsigned char)14, (unsigned char)1, "Information unit too short"}, 
        {(unsigned char)14, (unsigned char)2, "Information unit too long"}, 
        {(unsigned char)14, (unsigned char)3, "Invalid field in command information unit"}, 
        {(unsigned char)16,
      (unsigned char)0, "Id CRC or ECC error"}, 
        {(unsigned char)16, (unsigned char)1, "Logical block guard check failed"}, 
        {(unsigned char)16, (unsigned char)2, "Logical block application tag check failed"}, 
        {(unsigned char)16,
      (unsigned char)3, "Logical block reference tag check failed"}, 
        {(unsigned char)16, (unsigned char)4, "Logical block protection error on recover buffered data"}, 
        {(unsigned char)16,
      (unsigned char)5, "Logical block protection method error"}, 
        {(unsigned char)17, (unsigned char)0, "Unrecovered read error"}, 
        {(unsigned char)17, (unsigned char)1, "Read retries exhausted"}, 
        {(unsigned char)17, (unsigned char)2, "Error too long to correct"}, 
        {(unsigned char)17, (unsigned char)3, "Multiple read errors"}, 
        {(unsigned char)17, (unsigned char)4, "Unrecovered read error - auto reallocate failed"}, 
        {(unsigned char)17,
      (unsigned char)5, "L-EC uncorrectable error"}, 
        {(unsigned char)17, (unsigned char)6, "CIRC unrecovered error"}, 
        {(unsigned char)17, (unsigned char)7, "Data re-synchronization error"}, 
        {(unsigned char)17, (unsigned char)8, "Incomplete block read"}, 
        {(unsigned char)17, (unsigned char)9, "No gap found"}, 
        {(unsigned char)17, (unsigned char)10, "Miscorrected error"}, 
        {(unsigned char)17, (unsigned char)11, "Unrecovered read error - recommend reassignment"}, 
        {(unsigned char)17,
      (unsigned char)12, "Unrecovered read error - recommend rewrite the data"}, 
        {(unsigned char)17, (unsigned char)13, "De-compression CRC error"}, 
        {(unsigned char)17, (unsigned char)14, "Cannot decompress using declared algorithm"}, 
        {(unsigned char)17,
      (unsigned char)15, "Error reading UPC/EAN number"}, 
        {(unsigned char)17, (unsigned char)16, "Error reading ISRC number"}, 
        {(unsigned char)17, (unsigned char)17, "Read error - loss of streaming"}, 
        {(unsigned char)17, (unsigned char)18, "Auxiliary memory read error"}, 
        {(unsigned char)17, (unsigned char)19, "Read error - failed retransmission request"}, 
        {(unsigned char)17,
      (unsigned char)20, "Read error - LBA marked bad by application client"}, 
        {(unsigned char)18, (unsigned char)0, "Address mark not found for id field"}, 
        {(unsigned char)19,
      (unsigned char)0, "Address mark not found for data field"}, 
        {(unsigned char)20, (unsigned char)0, "Recorded entity not found"}, 
        {(unsigned char)20, (unsigned char)1, "Record not found"}, 
        {(unsigned char)20, (unsigned char)2, "Filemark or setmark not found"}, 
        {(unsigned char)20, (unsigned char)3, "End-of-data not found"}, 
        {(unsigned char)20, (unsigned char)4, "Block sequence error"}, 
        {(unsigned char)20, (unsigned char)5, "Record not found - recommend reassignment"}, 
        {(unsigned char)20,
      (unsigned char)6, "Record not found - data auto-reallocated"}, 
        {(unsigned char)20, (unsigned char)7, "Locate operation failure"}, 
        {(unsigned char)21, (unsigned char)0, "Random positioning error"}, 
        {(unsigned char)21, (unsigned char)1, "Mechanical positioning error"}, 
        {(unsigned char)21, (unsigned char)2, "Positioning error detected by read of medium"}, 
        {(unsigned char)22,
      (unsigned char)0, "Data synchronization mark error"}, 
        {(unsigned char)22, (unsigned char)1, "Data sync error - data rewritten"}, 
        {(unsigned char)22, (unsigned char)2, "Data sync error - recommend rewrite"}, 
        {(unsigned char)22,
      (unsigned char)3, "Data sync error - data auto-reallocated"}, 
        {(unsigned char)22, (unsigned char)4, "Data sync error - recommend reassignment"}, 
        {(unsigned char)23,
      (unsigned char)0, "Recovered data with no error correction applied"}, 
        {(unsigned char)23, (unsigned char)1, "Recovered data with retries"}, 
        {(unsigned char)23, (unsigned char)2, "Recovered data with positive head offset"}, 
        {(unsigned char)23,
      (unsigned char)3, "Recovered data with negative head offset"}, 
        {(unsigned char)23, (unsigned char)4, "Recovered data with retries and/or circ applied"}, 
        {(unsigned char)23,
      (unsigned char)5, "Recovered data using previous sector id"}, 
        {(unsigned char)23, (unsigned char)6, "Recovered data without ECC - data auto-reallocated"}, 
        {(unsigned char)23,
      (unsigned char)7, "Recovered data without ECC - recommend reassignment"}, 
        {(unsigned char)23, (unsigned char)8, "Recovered data without ECC - recommend rewrite"}, 
        {(unsigned char)23,
      (unsigned char)9, "Recovered data without ECC - data rewritten"}, 
        {(unsigned char)24, (unsigned char)0, "Recovered data with error correction applied"}, 
        {(unsigned char)24,
      (unsigned char)1, "Recovered data with error corr. & retries applied"}, 
        {(unsigned char)24, (unsigned char)2, "Recovered data - data auto-reallocated"}, 
        {(unsigned char)24,
      (unsigned char)3, "Recovered data with CIRC"}, 
        {(unsigned char)24, (unsigned char)4, "Recovered data with L-EC"}, 
        {(unsigned char)24, (unsigned char)5, "Recovered data - recommend reassignment"}, 
        {(unsigned char)24,
      (unsigned char)6, "Recovered data - recommend rewrite"}, 
        {(unsigned char)24, (unsigned char)7, "Recovered data with ECC - data rewritten"}, 
        {(unsigned char)24,
      (unsigned char)8, "Recovered data with linking"}, 
        {(unsigned char)25, (unsigned char)0, "Defect list error"}, 
        {(unsigned char)25, (unsigned char)1, "Defect list not available"}, 
        {(unsigned char)25, (unsigned char)2, "Defect list error in primary list"}, 
        {(unsigned char)25, (unsigned char)3, "Defect list error in grown list"}, 
        {(unsigned char)26, (unsigned char)0, "Parameter list length error"}, 
        {(unsigned char)27, (unsigned char)0, "Synchronous data transfer error"}, 
        {(unsigned char)28, (unsigned char)0, "Defect list not found"}, 
        {(unsigned char)28, (unsigned char)1, "Primary defect list not found"}, 
        {(unsigned char)28, (unsigned char)2, "Grown defect list not found"}, 
        {(unsigned char)29, (unsigned char)0, "Miscompare during verify operation"}, 
        {(unsigned char)29, (unsigned char)1, "Miscompare verify of unmapped lba"}, 
        {(unsigned char)30, (unsigned char)0, "Recovered id with ECC correction"}, 
        {(unsigned char)31, (unsigned char)0, "Partial defect list transfer"}, 
        {(unsigned char)32, (unsigned char)0, "Invalid command operation code"}, 
        {(unsigned char)32, (unsigned char)1, "Access denied - initiator pending-enrolled"}, 
        {(unsigned char)32,
      (unsigned char)2, "Access denied - no access rights"}, 
        {(unsigned char)32, (unsigned char)3, "Access denied - invalid mgmt id key"}, 
        {(unsigned char)32,
      (unsigned char)4, "Illegal command while in write capable state"}, 
        {(unsigned char)32, (unsigned char)5, "Write type operation while in read capable state (obs)"}, 
        {(unsigned char)32,
      (unsigned char)6, "Illegal command while in explicit address mode"}, 
        {(unsigned char)32, (unsigned char)7, "Illegal command while in implicit address mode"}, 
        {(unsigned char)32,
      (unsigned char)8, "Access denied - enrollment conflict"}, 
        {(unsigned char)32, (unsigned char)9, "Access denied - invalid LU identifier"}, 
        {(unsigned char)32,
      (unsigned char)10, "Access denied - invalid proxy token"}, 
        {(unsigned char)32, (unsigned char)11, "Access denied - ACL LUN conflict"}, 
        {(unsigned char)32, (unsigned char)12, "Illegal command when not in append-only mode"}, 
        {(unsigned char)33,
      (unsigned char)0, "Logical block address out of range"}, 
        {(unsigned char)33, (unsigned char)1, "Invalid element address"}, 
        {(unsigned char)33, (unsigned char)2, "Invalid address for write"}, 
        {(unsigned char)33, (unsigned char)3, "Invalid write crossing layer jump"}, 
        {(unsigned char)34, (unsigned char)0, "Illegal function (use 20 00, 24 00, or 26 00)"}, 
        {(unsigned char)36,
      (unsigned char)0, "Invalid field in cdb"}, 
        {(unsigned char)36, (unsigned char)1, "CDB decryption error"}, 
        {(unsigned char)36, (unsigned char)2, "Invalid cdb field while in explicit block model (obs)"}, 
        {(unsigned char)36,
      (unsigned char)3, "Invalid cdb field while in implicit block model (obs)"}, 
        {(unsigned char)36, (unsigned char)4, "Security audit value frozen"}, 
        {(unsigned char)36, (unsigned char)5, "Security working key frozen"}, 
        {(unsigned char)36, (unsigned char)6, "Nonce not unique"}, 
        {(unsigned char)36, (unsigned char)7, "Nonce timestamp out of range"}, 
        {(unsigned char)36, (unsigned char)8, "Invalid xcdb"}, 
        {(unsigned char)37, (unsigned char)0, "Logical unit not supported"}, 
        {(unsigned char)38, (unsigned char)0, "Invalid field in parameter list"}, 
        {(unsigned char)38, (unsigned char)1, "Parameter not supported"}, 
        {(unsigned char)38, (unsigned char)2, "Parameter value invalid"}, 
        {(unsigned char)38, (unsigned char)3, "Threshold parameters not supported"}, 
        {(unsigned char)38, (unsigned char)4, "Invalid release of persistent reservation"}, 
        {(unsigned char)38,
      (unsigned char)5, "Data decryption error"}, 
        {(unsigned char)38, (unsigned char)6, "Too many target descriptors"}, 
        {(unsigned char)38, (unsigned char)7, "Unsupported target descriptor type code"}, 
        {(unsigned char)38,
      (unsigned char)8, "Too many segment descriptors"}, 
        {(unsigned char)38, (unsigned char)9, "Unsupported segment descriptor type code"}, 
        {(unsigned char)38,
      (unsigned char)10, "Unexpected inexact segment"}, 
        {(unsigned char)38, (unsigned char)11, "Inline data length exceeded"}, 
        {(unsigned char)38, (unsigned char)12, "Invalid operation for copy source or destination"}, 
        {(unsigned char)38,
      (unsigned char)13, "Copy segment granularity violation"}, 
        {(unsigned char)38, (unsigned char)14, "Invalid parameter while port is enabled"}, 
        {(unsigned char)38,
      (unsigned char)15, "Invalid data-out buffer integrity check value"}, 
        {(unsigned char)38, (unsigned char)16, "Data decryption key fail limit reached"}, 
        {(unsigned char)38,
      (unsigned char)17, "Incomplete key-associated data set"}, 
        {(unsigned char)38, (unsigned char)18, "Vendor specific key reference not found"}, 
        {(unsigned char)39,
      (unsigned char)0, "Write protected"}, 
        {(unsigned char)39, (unsigned char)1, "Hardware write protected"}, 
        {(unsigned char)39, (unsigned char)2, "Logical unit software write protected"}, 
        {(unsigned char)39,
      (unsigned char)3, "Associated write protect"}, 
        {(unsigned char)39, (unsigned char)4, "Persistent write protect"}, 
        {(unsigned char)39, (unsigned char)5, "Permanent write protect"}, 
        {(unsigned char)39, (unsigned char)6, "Conditional write protect"}, 
        {(unsigned char)39, (unsigned char)7, "Space allocation failed write protect"}, 
        {(unsigned char)40,
      (unsigned char)0, "Not ready to ready change, medium may have changed"}, 
        {(unsigned char)40, (unsigned char)1, "Import or export element accessed"}, 
        {(unsigned char)40, (unsigned char)2, "Format-layer may have changed"}, 
        {(unsigned char)40, (unsigned char)3, "Import/export element accessed, medium changed"}, 
        {(unsigned char)41,
      (unsigned char)0, "Power on, reset, or bus device reset occurred"}, 
        {(unsigned char)41, (unsigned char)1, "Power on occurred"}, 
        {(unsigned char)41, (unsigned char)2, "SCSI bus reset occurred"}, 
        {(unsigned char)41, (unsigned char)3, "Bus device reset function occurred"}, 
        {(unsigned char)41, (unsigned char)4, "Device internal reset"}, 
        {(unsigned char)41, (unsigned char)5, "Transceiver mode changed to single-ended"}, 
        {(unsigned char)41,
      (unsigned char)6, "Transceiver mode changed to lvd"}, 
        {(unsigned char)41, (unsigned char)7, "I_T nexus loss occurred"}, 
        {(unsigned char)42, (unsigned char)0, "Parameters changed"}, 
        {(unsigned char)42, (unsigned char)1, "Mode parameters changed"}, 
        {(unsigned char)42, (unsigned char)2, "Log parameters changed"}, 
        {(unsigned char)42, (unsigned char)3, "Reservations preempted"}, 
        {(unsigned char)42, (unsigned char)4, "Reservations released"}, 
        {(unsigned char)42, (unsigned char)5, "Registrations preempted"}, 
        {(unsigned char)42, (unsigned char)6, "Asymmetric access state changed"}, 
        {(unsigned char)42, (unsigned char)7, "Implicit asymmetric access state transition failed"}, 
        {(unsigned char)42,
      (unsigned char)8, "Priority changed"}, 
        {(unsigned char)42, (unsigned char)9, "Capacity data has changed"}, 
        {(unsigned char)42, (unsigned char)12, "Error recovery attributes have changed"}, 
        {(unsigned char)42,
      (unsigned char)13, "Data encryption capabilities changed"}, 
        {(unsigned char)42, (unsigned char)16, "Timestamp changed"}, 
        {(unsigned char)42, (unsigned char)17, "Data encryption parameters changed by another i_t nexus"}, 
        {(unsigned char)42,
      (unsigned char)18, "Data encryption parameters changed by vendor specific event"}, 
        {(unsigned char)42,
      (unsigned char)19, "Data encryption key instance counter has changed"}, 
        {(unsigned char)42, (unsigned char)10, "Error history i_t nexus cleared"}, 
        {(unsigned char)42, (unsigned char)11, "Error history snapshot released"}, 
        {(unsigned char)42, (unsigned char)20, "SA creation capabilities data has changed"}, 
        {(unsigned char)43,
      (unsigned char)0, "Copy cannot execute since host cannot disconnect"}, 
        {(unsigned char)44, (unsigned char)0, "Command sequence error"}, 
        {(unsigned char)44, (unsigned char)1, "Too many windows specified"}, 
        {(unsigned char)44, (unsigned char)2, "Invalid combination of windows specified"}, 
        {(unsigned char)44,
      (unsigned char)3, "Current program area is not empty"}, 
        {(unsigned char)44, (unsigned char)4, "Current program area is empty"}, 
        {(unsigned char)44, (unsigned char)5, "Illegal power condition request"}, 
        {(unsigned char)44, (unsigned char)6, "Persistent prevent conflict"}, 
        {(unsigned char)44, (unsigned char)7, "Previous busy status"}, 
        {(unsigned char)44, (unsigned char)8, "Previous task set full status"}, 
        {(unsigned char)44, (unsigned char)9, "Previous reservation conflict status"}, 
        {(unsigned char)44,
      (unsigned char)10, "Partition or collection contains user objects"}, 
        {(unsigned char)44, (unsigned char)11, "Not reserved"}, 
        {(unsigned char)44, (unsigned char)12, "ORWRITE generation does not match"}, 
        {(unsigned char)45, (unsigned char)0, "Overwrite error on update in place"}, 
        {(unsigned char)46, (unsigned char)0, "Insufficient time for operation"}, 
        {(unsigned char)47, (unsigned char)0, "Commands cleared by another initiator"}, 
        {(unsigned char)47,
      (unsigned char)1, "Commands cleared by power loss notification"}, 
        {(unsigned char)47, (unsigned char)2, "Commands cleared by device server"}, 
        {(unsigned char)48, (unsigned char)0, "Incompatible medium installed"}, 
        {(unsigned char)48, (unsigned char)1, "Cannot read medium - unknown format"}, 
        {(unsigned char)48,
      (unsigned char)2, "Cannot read medium - incompatible format"}, 
        {(unsigned char)48, (unsigned char)3, "Cleaning cartridge installed"}, 
        {(unsigned char)48, (unsigned char)4, "Cannot write medium - unknown format"}, 
        {(unsigned char)48,
      (unsigned char)5, "Cannot write medium - incompatible format"}, 
        {(unsigned char)48, (unsigned char)6, "Cannot format medium - incompatible medium"}, 
        {(unsigned char)48,
      (unsigned char)7, "Cleaning failure"}, 
        {(unsigned char)48, (unsigned char)8, "Cannot write - application code mismatch"}, 
        {(unsigned char)48,
      (unsigned char)9, "Current session not fixated for append"}, 
        {(unsigned char)48, (unsigned char)10, "Cleaning request rejected"}, 
        {(unsigned char)48, (unsigned char)11, "Cleaning tape expired"}, 
        {(unsigned char)48, (unsigned char)12, "WORM medium - overwrite attempted"}, 
        {(unsigned char)48, (unsigned char)13, "WORM medium - integrity check"}, 
        {(unsigned char)48, (unsigned char)16, "Medium not formatted"}, 
        {(unsigned char)48, (unsigned char)17, "Incompatible volume type"}, 
        {(unsigned char)48, (unsigned char)18, "Incompatible volume qualifier"}, 
        {(unsigned char)48, (unsigned char)19, "Cleaning volume expired"}, 
        {(unsigned char)49, (unsigned char)0, "Medium format corrupted"}, 
        {(unsigned char)49, (unsigned char)1, "Format command failed"}, 
        {(unsigned char)49, (unsigned char)2, "Zoned formatting failed due to spare linking"}, 
        {(unsigned char)50,
      (unsigned char)0, "No defect spare location available"}, 
        {(unsigned char)50, (unsigned char)1, "Defect list update failure"}, 
        {(unsigned char)51, (unsigned char)0, "Tape length error"}, 
        {(unsigned char)52, (unsigned char)0, "Enclosure failure"}, 
        {(unsigned char)53, (unsigned char)0, "Enclosure services failure"}, 
        {(unsigned char)53, (unsigned char)1, "Unsupported enclosure function"}, 
        {(unsigned char)53, (unsigned char)2, "Enclosure services unavailable"}, 
        {(unsigned char)53, (unsigned char)3, "Enclosure services transfer failure"}, 
        {(unsigned char)53,
      (unsigned char)4, "Enclosure services transfer refused"}, 
        {(unsigned char)53, (unsigned char)5, "Enclosure services checksum error"}, 
        {(unsigned char)54, (unsigned char)0, "Ribbon, ink, or toner failure"}, 
        {(unsigned char)55, (unsigned char)0, "Rounded parameter"}, 
        {(unsigned char)56, (unsigned char)0, "Event status notification"}, 
        {(unsigned char)56, (unsigned char)2, "Esn - power management class event"}, 
        {(unsigned char)56, (unsigned char)4, "Esn - media class event"}, 
        {(unsigned char)56, (unsigned char)6, "Esn - device busy class event"}, 
        {(unsigned char)56, (unsigned char)7, "Thin provisioning soft threshold reached"}, 
        {(unsigned char)57,
      (unsigned char)0, "Saving parameters not supported"}, 
        {(unsigned char)58, (unsigned char)0, "Medium not present"}, 
        {(unsigned char)58, (unsigned char)1, "Medium not present - tray closed"}, 
        {(unsigned char)58, (unsigned char)2, "Medium not present - tray open"}, 
        {(unsigned char)58, (unsigned char)3, "Medium not present - loadable"}, 
        {(unsigned char)58, (unsigned char)4, "Medium not present - medium auxiliary memory accessible"}, 
        {(unsigned char)59,
      (unsigned char)0, "Sequential positioning error"}, 
        {(unsigned char)59, (unsigned char)1, "Tape position error at beginning-of-medium"}, 
        {(unsigned char)59,
      (unsigned char)2, "Tape position error at end-of-medium"}, 
        {(unsigned char)59, (unsigned char)3, "Tape or electronic vertical forms unit not ready"}, 
        {(unsigned char)59,
      (unsigned char)4, "Slew failure"}, 
        {(unsigned char)59, (unsigned char)5, "Paper jam"}, 
        {(unsigned char)59, (unsigned char)6, "Failed to sense top-of-form"}, 
        {(unsigned char)59, (unsigned char)7, "Failed to sense bottom-of-form"}, 
        {(unsigned char)59, (unsigned char)8, "Reposition error"}, 
        {(unsigned char)59, (unsigned char)9, "Read past end of medium"}, 
        {(unsigned char)59, (unsigned char)10, "Read past beginning of medium"}, 
        {(unsigned char)59, (unsigned char)11, "Position past end of medium"}, 
        {(unsigned char)59, (unsigned char)12, "Position past beginning of medium"}, 
        {(unsigned char)59, (unsigned char)13, "Medium destination element full"}, 
        {(unsigned char)59, (unsigned char)14, "Medium source element empty"}, 
        {(unsigned char)59, (unsigned char)15, "End of medium reached"}, 
        {(unsigned char)59, (unsigned char)17, "Medium magazine not accessible"}, 
        {(unsigned char)59, (unsigned char)18, "Medium magazine removed"}, 
        {(unsigned char)59, (unsigned char)19, "Medium magazine inserted"}, 
        {(unsigned char)59, (unsigned char)20, "Medium magazine locked"}, 
        {(unsigned char)59, (unsigned char)21, "Medium magazine unlocked"}, 
        {(unsigned char)59, (unsigned char)22, "Mechanical positioning or changer error"}, 
        {(unsigned char)59,
      (unsigned char)23, "Read past end of user object"}, 
        {(unsigned char)59, (unsigned char)24, "Element disabled"}, 
        {(unsigned char)59, (unsigned char)25, "Element enabled"}, 
        {(unsigned char)59, (unsigned char)26, "Data transfer device removed"}, 
        {(unsigned char)59, (unsigned char)27, "Data transfer device inserted"}, 
        {(unsigned char)61, (unsigned char)0, "Invalid bits in identify message"}, 
        {(unsigned char)62, (unsigned char)0, "Logical unit has not self-configured yet"}, 
        {(unsigned char)62,
      (unsigned char)1, "Logical unit failure"}, 
        {(unsigned char)62, (unsigned char)2, "Timeout on logical unit"}, 
        {(unsigned char)62, (unsigned char)3, "Logical unit failed self-test"}, 
        {(unsigned char)62, (unsigned char)4, "Logical unit unable to update self-test log"}, 
        {(unsigned char)63,
      (unsigned char)0, "Target operating conditions have changed"}, 
        {(unsigned char)63, (unsigned char)1, "Microcode has been changed"}, 
        {(unsigned char)63, (unsigned char)2, "Changed operating definition"}, 
        {(unsigned char)63, (unsigned char)3, "Inquiry data has changed"}, 
        {(unsigned char)63, (unsigned char)4, "Component device attached"}, 
        {(unsigned char)63, (unsigned char)5, "Device identifier changed"}, 
        {(unsigned char)63, (unsigned char)6, "Redundancy group created or modified"}, 
        {(unsigned char)63,
      (unsigned char)7, "Redundancy group deleted"}, 
        {(unsigned char)63, (unsigned char)8, "Spare created or modified"}, 
        {(unsigned char)63, (unsigned char)9, "Spare deleted"}, 
        {(unsigned char)63, (unsigned char)10, "Volume set created or modified"}, 
        {(unsigned char)63, (unsigned char)11, "Volume set deleted"}, 
        {(unsigned char)63, (unsigned char)12, "Volume set deassigned"}, 
        {(unsigned char)63, (unsigned char)13, "Volume set reassigned"}, 
        {(unsigned char)63, (unsigned char)14, "Reported luns data has changed"}, 
        {(unsigned char)63, (unsigned char)15, "Echo buffer overwritten"}, 
        {(unsigned char)63, (unsigned char)16, "Medium loadable"}, 
        {(unsigned char)63, (unsigned char)17, "Medium auxiliary memory accessible"}, 
        {(unsigned char)63,
      (unsigned char)18, "iSCSI IP address added"}, 
        {(unsigned char)63, (unsigned char)19, "iSCSI IP address removed"}, 
        {(unsigned char)63, (unsigned char)20, "iSCSI IP address changed"}, 
        {(unsigned char)64, (unsigned char)0, "Ram failure (should use 40 nn)"}, 
        {(unsigned char)65, (unsigned char)0, "Data path failure (should use 40 nn)"}, 
        {(unsigned char)66,
      (unsigned char)0, "Power-on or self-test failure (should use 40 nn)"}, 
        {(unsigned char)67, (unsigned char)0, "Message error"}, 
        {(unsigned char)68, (unsigned char)0, "Internal target failure"}, 
        {(unsigned char)68, (unsigned char)113, "ATA device failed Set Features"}, 
        {(unsigned char)69, (unsigned char)0, "Select or reselect failure"}, 
        {(unsigned char)70, (unsigned char)0, "Unsuccessful soft reset"}, 
        {(unsigned char)71, (unsigned char)0, "SCSI parity error"}, 
        {(unsigned char)71, (unsigned char)1, "Data phase CRC error detected"}, 
        {(unsigned char)71, (unsigned char)2, "SCSI parity error detected during st data phase"}, 
        {(unsigned char)71,
      (unsigned char)3, "Information unit iuCRC error detected"}, 
        {(unsigned char)71, (unsigned char)4, "Asynchronous information protection error detected"}, 
        {(unsigned char)71,
      (unsigned char)5, "Protocol service CRC error"}, 
        {(unsigned char)71, (unsigned char)6, "Phy test function in progress"}, 
        {(unsigned char)71, (unsigned char)127, "Some commands cleared by iSCSI protocol event"}, 
        {(unsigned char)72,
      (unsigned char)0, "Initiator detected error message received"}, 
        {(unsigned char)73, (unsigned char)0, "Invalid message error"}, 
        {(unsigned char)74, (unsigned char)0, "Command phase error"}, 
        {(unsigned char)75, (unsigned char)0, "Data phase error"}, 
        {(unsigned char)75, (unsigned char)1, "Invalid target port transfer tag received"}, 
        {(unsigned char)75,
      (unsigned char)2, "Too much write data"}, 
        {(unsigned char)75, (unsigned char)3, "Ack/nak timeout"}, 
        {(unsigned char)75, (unsigned char)4, "Nak received"}, 
        {(unsigned char)75, (unsigned char)5, "Data offset error"}, 
        {(unsigned char)75, (unsigned char)6, "Initiator response timeout"}, 
        {(unsigned char)75, (unsigned char)7, "Connection lost"}, 
        {(unsigned char)76, (unsigned char)0, "Logical unit failed self-configuration"}, 
        {(unsigned char)78,
      (unsigned char)0, "Overlapped commands attempted"}, 
        {(unsigned char)80, (unsigned char)0, "Write append error"}, 
        {(unsigned char)80, (unsigned char)1, "Write append position error"}, 
        {(unsigned char)80, (unsigned char)2, "Position error related to timing"}, 
        {(unsigned char)81, (unsigned char)0, "Erase failure"}, 
        {(unsigned char)81, (unsigned char)1, "Erase failure - incomplete erase operation detected"}, 
        {(unsigned char)82,
      (unsigned char)0, "Cartridge fault"}, 
        {(unsigned char)83, (unsigned char)0, "Media load or eject failed"}, 
        {(unsigned char)83, (unsigned char)1, "Unload tape failure"}, 
        {(unsigned char)83, (unsigned char)2, "Medium removal prevented"}, 
        {(unsigned char)83, (unsigned char)3, "Medium removal prevented by data transfer element"}, 
        {(unsigned char)83,
      (unsigned char)4, "Medium thread or unthread failure"}, 
        {(unsigned char)83, (unsigned char)5, "Volume identifier invalid"}, 
        {(unsigned char)83, (unsigned char)6, "Volume identifier missing"}, 
        {(unsigned char)83, (unsigned char)7, "Duplicate volume identifier"}, 
        {(unsigned char)83, (unsigned char)8, "Element status unknown"}, 
        {(unsigned char)84, (unsigned char)0, "SCSI to host system interface failure"}, 
        {(unsigned char)85,
      (unsigned char)0, "System resource failure"}, 
        {(unsigned char)85, (unsigned char)1, "System buffer full"}, 
        {(unsigned char)85, (unsigned char)2, "Insufficient reservation resources"}, 
        {(unsigned char)85, (unsigned char)3, "Insufficient resources"}, 
        {(unsigned char)85, (unsigned char)4, "Insufficient registration resources"}, 
        {(unsigned char)85,
      (unsigned char)5, "Insufficient access control resources"}, 
        {(unsigned char)85, (unsigned char)6, "Auxiliary memory out of space"}, 
        {(unsigned char)85, (unsigned char)7, "Quota error"}, 
        {(unsigned char)85, (unsigned char)8, "Maximum number of supplemental decryption keys exceeded"}, 
        {(unsigned char)85,
      (unsigned char)9, "Medium auxiliary memory not accessible"}, 
        {(unsigned char)85, (unsigned char)10, "Data currently unavailable"}, 
        {(unsigned char)85, (unsigned char)11, "Insufficient power for operation"}, 
        {(unsigned char)87, (unsigned char)0, "Unable to recover table-of-contents"}, 
        {(unsigned char)88,
      (unsigned char)0, "Generation does not exist"}, 
        {(unsigned char)89, (unsigned char)0, "Updated block read"}, 
        {(unsigned char)90, (unsigned char)0, "Operator request or state change input"}, 
        {(unsigned char)90,
      (unsigned char)1, "Operator medium removal request"}, 
        {(unsigned char)90, (unsigned char)2, "Operator selected write protect"}, 
        {(unsigned char)90, (unsigned char)3, "Operator selected write permit"}, 
        {(unsigned char)91, (unsigned char)0, "Log exception"}, 
        {(unsigned char)91, (unsigned char)1, "Threshold condition met"}, 
        {(unsigned char)91, (unsigned char)2, "Log counter at maximum"}, 
        {(unsigned char)91, (unsigned char)3, "Log list codes exhausted"}, 
        {(unsigned char)92, (unsigned char)0, "Rpl status change"}, 
        {(unsigned char)92, (unsigned char)1, "Spindles synchronized"}, 
        {(unsigned char)92, (unsigned char)2, "Spindles not synchronized"}, 
        {(unsigned char)93, (unsigned char)0, "Failure prediction threshold exceeded"}, 
        {(unsigned char)93,
      (unsigned char)1, "Media failure prediction threshold exceeded"}, 
        {(unsigned char)93, (unsigned char)2, "Logical unit failure prediction threshold exceeded"}, 
        {(unsigned char)93,
      (unsigned char)3, "spare area exhaustion prediction threshold exceeded"}, 
        {(unsigned char)93, (unsigned char)16, "Hardware impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)17, "Hardware impending failure drive error rate too high"}, 
        {(unsigned char)93, (unsigned char)18, "Hardware impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)19, "Hardware impending failure seek error rate too high"}, 
        {(unsigned char)93, (unsigned char)20, "Hardware impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)21, "Hardware impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)22, "Hardware impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)23, "Hardware impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)24, "Hardware impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)25, "Hardware impending failure throughput performance"}, 
        {(unsigned char)93, (unsigned char)26, "Hardware impending failure seek time performance"}, 
        {(unsigned char)93,
      (unsigned char)27, "Hardware impending failure spin-up retry count"}, 
        {(unsigned char)93, (unsigned char)28, "Hardware impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)32, "Controller impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)33, "Controller impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)34, "Controller impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)35, "Controller impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)36, "Controller impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)37, "Controller impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)38, "Controller impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)39, "Controller impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)40, "Controller impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)41, "Controller impending failure throughput performance"}, 
        {(unsigned char)93, (unsigned char)42, "Controller impending failure seek time performance"}, 
        {(unsigned char)93,
      (unsigned char)43, "Controller impending failure spin-up retry count"}, 
        {(unsigned char)93, (unsigned char)44, "Controller impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)48, "Data channel impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)49, "Data channel impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)50, "Data channel impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)51, "Data channel impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)52, "Data channel impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)53, "Data channel impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)54, "Data channel impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)55, "Data channel impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)56, "Data channel impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)57, "Data channel impending failure throughput performance"}, 
        {(unsigned char)93,
      (unsigned char)58, "Data channel impending failure seek time performance"}, 
        {(unsigned char)93, (unsigned char)59, "Data channel impending failure spin-up retry count"}, 
        {(unsigned char)93,
      (unsigned char)60, "Data channel impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)64, "Servo impending failure general hard drive failure"}, 
        {(unsigned char)93, (unsigned char)65, "Servo impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)66, "Servo impending failure data error rate too high"}, 
        {(unsigned char)93, (unsigned char)67, "Servo impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)68, "Servo impending failure too many block reassigns"}, 
        {(unsigned char)93, (unsigned char)69, "Servo impending failure access times too high"}, 
        {(unsigned char)93,
      (unsigned char)70, "Servo impending failure start unit times too high"}, 
        {(unsigned char)93, (unsigned char)71, "Servo impending failure channel parametrics"}, 
        {(unsigned char)93,
      (unsigned char)72, "Servo impending failure controller detected"}, 
        {(unsigned char)93, (unsigned char)73, "Servo impending failure throughput performance"}, 
        {(unsigned char)93,
      (unsigned char)74, "Servo impending failure seek time performance"}, 
        {(unsigned char)93, (unsigned char)75, "Servo impending failure spin-up retry count"}, 
        {(unsigned char)93,
      (unsigned char)76, "Servo impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)80, "Spindle impending failure general hard drive failure"}, 
        {(unsigned char)93, (unsigned char)81, "Spindle impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)82, "Spindle impending failure data error rate too high"}, 
        {(unsigned char)93, (unsigned char)83, "Spindle impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)84, "Spindle impending failure too many block reassigns"}, 
        {(unsigned char)93, (unsigned char)85, "Spindle impending failure access times too high"}, 
        {(unsigned char)93,
      (unsigned char)86, "Spindle impending failure start unit times too high"}, 
        {(unsigned char)93, (unsigned char)87, "Spindle impending failure channel parametrics"}, 
        {(unsigned char)93,
      (unsigned char)88, "Spindle impending failure controller detected"}, 
        {(unsigned char)93, (unsigned char)89, "Spindle impending failure throughput performance"}, 
        {(unsigned char)93,
      (unsigned char)90, "Spindle impending failure seek time performance"}, 
        {(unsigned char)93, (unsigned char)91, "Spindle impending failure spin-up retry count"}, 
        {(unsigned char)93,
      (unsigned char)92, "Spindle impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)96, "Firmware impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)97, "Firmware impending failure drive error rate too high"}, 
        {(unsigned char)93, (unsigned char)98, "Firmware impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)99, "Firmware impending failure seek error rate too high"}, 
        {(unsigned char)93, (unsigned char)100, "Firmware impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)101, "Firmware impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)102, "Firmware impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)103, "Firmware impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)104, "Firmware impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)105, "Firmware impending failure throughput performance"}, 
        {(unsigned char)93, (unsigned char)106, "Firmware impending failure seek time performance"}, 
        {(unsigned char)93,
      (unsigned char)107, "Firmware impending failure spin-up retry count"}, 
        {(unsigned char)93, (unsigned char)108, "Firmware impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)255, "Failure prediction threshold exceeded (false)"}, 
        {(unsigned char)94, (unsigned char)0, "Low power condition on"}, 
        {(unsigned char)94, (unsigned char)1, "Idle condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)2, "Standby condition activated by timer"}, 
        {(unsigned char)94,
      (unsigned char)3, "Idle condition activated by command"}, 
        {(unsigned char)94, (unsigned char)4, "Standby condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)5, "Idle_b condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)6, "Idle_b condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)7, "Idle_c condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)8, "Idle_c condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)9, "Standby_y condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)10, "Standby_y condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)65, "Power state change to active"}, 
        {(unsigned char)94, (unsigned char)66, "Power state change to idle"}, 
        {(unsigned char)94, (unsigned char)67, "Power state change to standby"}, 
        {(unsigned char)94, (unsigned char)69, "Power state change to sleep"}, 
        {(unsigned char)94, (unsigned char)71, "Power state change to device control"}, 
        {(unsigned char)96,
      (unsigned char)0, "Lamp failure"}, 
        {(unsigned char)97, (unsigned char)0, "Video acquisition error"}, 
        {(unsigned char)97, (unsigned char)1, "Unable to acquire video"}, 
        {(unsigned char)97, (unsigned char)2, "Out of focus"}, 
        {(unsigned char)98, (unsigned char)0, "Scan head positioning error"}, 
        {(unsigned char)99, (unsigned char)0, "End of user area encountered on this track"}, 
        {(unsigned char)99,
      (unsigned char)1, "Packet does not fit in available space"}, 
        {(unsigned char)100, (unsigned char)0, "Illegal mode for this track"}, 
        {(unsigned char)100, (unsigned char)1, "Invalid packet size"}, 
        {(unsigned char)101, (unsigned char)0, "Voltage fault"}, 
        {(unsigned char)102, (unsigned char)0, "Automatic document feeder cover up"}, 
        {(unsigned char)102,
      (unsigned char)1, "Automatic document feeder lift up"}, 
        {(unsigned char)102, (unsigned char)2, "Document jam in automatic document feeder"}, 
        {(unsigned char)102,
      (unsigned char)3, "Document miss feed automatic in document feeder"}, 
        {(unsigned char)103, (unsigned char)0, "Configuration failure"}, 
        {(unsigned char)103, (unsigned char)1, "Configuration of incapable logical units failed"}, 
        {(unsigned char)103,
      (unsigned char)2, "Add logical unit failed"}, 
        {(unsigned char)103, (unsigned char)3, "Modification of logical unit failed"}, 
        {(unsigned char)103,
      (unsigned char)4, "Exchange of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)5, "Remove of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)6, "Attachment of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)7, "Creation of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)8, "Assign failure occurred"}, 
        {(unsigned char)103, (unsigned char)9, "Multiply assigned logical unit"}, 
        {(unsigned char)103, (unsigned char)10, "Set target port groups command failed"}, 
        {(unsigned char)103,
      (unsigned char)11, "ATA device feature not enabled"}, 
        {(unsigned char)104, (unsigned char)0, "Logical unit not configured"}, 
        {(unsigned char)105, (unsigned char)0, "Data loss on logical unit"}, 
        {(unsigned char)105, (unsigned char)1, "Multiple logical unit failures"}, 
        {(unsigned char)105, (unsigned char)2, "Parity/data mismatch"}, 
        {(unsigned char)106, (unsigned char)0, "Informational, refer to log"}, 
        {(unsigned char)107, (unsigned char)0, "State change has occurred"}, 
        {(unsigned char)107, (unsigned char)1, "Redundancy level got better"}, 
        {(unsigned char)107, (unsigned char)2, "Redundancy level got worse"}, 
        {(unsigned char)108, (unsigned char)0, "Rebuild failure occurred"}, 
        {(unsigned char)109, (unsigned char)0, "Recalculate failure occurred"}, 
        {(unsigned char)110, (unsigned char)0, "Command to logical unit failed"}, 
        {(unsigned char)111, (unsigned char)0, "Copy protection key exchange failure - authentication failure"}, 
        {(unsigned char)111,
      (unsigned char)1, "Copy protection key exchange failure - key not present"}, 
        {(unsigned char)111,
      (unsigned char)2, "Copy protection key exchange failure - key not established"}, 
        {(unsigned char)111,
      (unsigned char)3, "Read of scrambled sector without authentication"}, 
        {(unsigned char)111, (unsigned char)4, "Media region code is mismatched to logical unit region"}, 
        {(unsigned char)111,
      (unsigned char)5, "Drive region must be permanent/region reset count error"}, 
        {(unsigned char)111,
      (unsigned char)6, "Insufficient block count for binding nonce recording"}, 
        {(unsigned char)111, (unsigned char)7, "Conflict in binding nonce recording"}, 
        {(unsigned char)113,
      (unsigned char)0, "Decompression exception long algorithm id"}, 
        {(unsigned char)114, (unsigned char)0, "Session fixation error"}, 
        {(unsigned char)114, (unsigned char)1, "Session fixation error writing lead-in"}, 
        {(unsigned char)114,
      (unsigned char)2, "Session fixation error writing lead-out"}, 
        {(unsigned char)114, (unsigned char)3, "Session fixation error - incomplete track in session"}, 
        {(unsigned char)114,
      (unsigned char)4, "Empty or partially written reserved track"}, 
        {(unsigned char)114, (unsigned char)5, "No more track reservations allowed"}, 
        {(unsigned char)114,
      (unsigned char)6, "RMZ extension is not allowed"}, 
        {(unsigned char)114, (unsigned char)7, "No more test zone extensions are allowed"}, 
        {(unsigned char)115,
      (unsigned char)0, "CD control error"}, 
        {(unsigned char)115, (unsigned char)1, "Power calibration area almost full"}, 
        {(unsigned char)115,
      (unsigned char)2, "Power calibration area is full"}, 
        {(unsigned char)115, (unsigned char)3, "Power calibration area error"}, 
        {(unsigned char)115, (unsigned char)4, "Program memory area update failure"}, 
        {(unsigned char)115,
      (unsigned char)5, "Program memory area is full"}, 
        {(unsigned char)115, (unsigned char)6, "RMA/PMA is almost full"}, 
        {(unsigned char)115, (unsigned char)16, "Current power calibration area almost full"}, 
        {(unsigned char)115,
      (unsigned char)17, "Current power calibration area is full"}, 
        {(unsigned char)115, (unsigned char)23, "RDZ is full"}, 
        {(unsigned char)116, (unsigned char)0, "Security error"}, 
        {(unsigned char)116, (unsigned char)1, "Unable to decrypt data"}, 
        {(unsigned char)116, (unsigned char)2, "Unencrypted data encountered while decrypting"}, 
        {(unsigned char)116,
      (unsigned char)3, "Incorrect data encryption key"}, 
        {(unsigned char)116, (unsigned char)4, "Cryptographic integrity validation failed"}, 
        {(unsigned char)116,
      (unsigned char)5, "Error decrypting data"}, 
        {(unsigned char)116, (unsigned char)6, "Unknown signature verification key"}, 
        {(unsigned char)116,
      (unsigned char)7, "Encryption parameters not useable"}, 
        {(unsigned char)116, (unsigned char)8, "Digital signature validation failure"}, 
        {(unsigned char)116,
      (unsigned char)9, "Encryption mode mismatch on read"}, 
        {(unsigned char)116, (unsigned char)10, "Encrypted block not raw read enabled"}, 
        {(unsigned char)116,
      (unsigned char)11, "Incorrect Encryption parameters"}, 
        {(unsigned char)116, (unsigned char)12, "Unable to decrypt parameter list"}, 
        {(unsigned char)116, (unsigned char)13, "Encryption algorithm disabled"}, 
        {(unsigned char)116, (unsigned char)16, "SA creation parameter value invalid"}, 
        {(unsigned char)116,
      (unsigned char)17, "SA creation parameter value rejected"}, 
        {(unsigned char)116, (unsigned char)18, "Invalid SA usage"}, 
        {(unsigned char)116, (unsigned char)33, "Data encryption configuration prevented"}, 
        {(unsigned char)116,
      (unsigned char)48, "SA creation parameter not supported"}, 
        {(unsigned char)116, (unsigned char)64, "Authentication failed"}, 
        {(unsigned char)116, (unsigned char)97, "External data encryption key manager access error"}, 
        {(unsigned char)116,
      (unsigned char)98, "External data encryption key manager error"}, 
        {(unsigned char)116, (unsigned char)99, "External data encryption key not found"}, 
        {(unsigned char)116,
      (unsigned char)100, "External data encryption request not authorized"}, 
        {(unsigned char)116, (unsigned char)110, "External data encryption control timeout"}, 
        {(unsigned char)116,
      (unsigned char)111, "External data encryption control error"}, 
        {(unsigned char)116, (unsigned char)113, "Logical unit access not authorized"}, 
        {(unsigned char)116,
      (unsigned char)121, "Security conflict in translated device"}, 
        {(unsigned char)0, (unsigned char)0, (char const   *)((void *)0)}};
#line 1034 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
char const   *sg_lib_sense_key_desc[16]  = 
#line 1034
  {      "No Sense",      "Recovered Error",      "Not Ready",      "Medium Error", 
        "Hardware Error",      "Illegal Request",      "Unit Attention",      "Data Protect", 
        "Blank Check",      "Key=9",      "Copy Aborted",      "Aborted Command", 
        "Equal",      "Volume Overflow",      "Miscompare",      "Completed"};
#line 1059 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
char const   *sg_lib_pdt_strs[32]  = 
#line 1059
  {      "disk",      "tape",      "printer",      "processor", 
        "write once optical disk",      "cd/dvd",      "scanner",      "optical memory device", 
        "medium changer",      "communications",      "graphics [0xa]",      "graphics [0xb]", 
        "storage array controller",      "enclosure services device",      "simplified direct access device",      "optical card reader/writer device", 
        "bridge controller commands",      "object based storage",      "automation/driver interface",      "security manager device", 
        "0x14",      "0x15",      "0x16",      "0x17", 
        "0x18",      "0x19",      "0x1a",      "0x1b", 
        "0x1c",      "0x1d",      "well known logical unit",      "no physical device on this lu"};
#line 1086 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib_data.c"
char const   *sg_lib_transport_proto_strs[16]  = 
#line 1086
  {      "Fibre Channel (FCP-2)",      "Parallel SCSI (SPI-5)",      "SSA (SSA-S3P)",      "IEEE 1394 (SBP-3)", 
        "Remote Direct Memory Access (RDMA)",      "Internet SCSI (iSCSI)",      "Serial Attached SCSI (SAS)",      "Automation/Drive Interface (ADT-2)", 
        "ATA Packet Interface (ATA/ATAPI-7)",      "Ox9",      "Oxa",      "Oxb", 
        "Oxc",      "Oxd",      "Oxe",      "No specific protocol"};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 130 "../include/sg_lib.h"
void sg_get_scsi_status_str(int scsi_status , int buff_len , char *buff ) ;
#line 192
int sg_get_sense_progress_fld(unsigned char const   *sensep , int sb_len , int *progress_outp ) ;
#line 198
void sg_get_sense_str(char const   *leadin , unsigned char const   *sense_buffer ,
                      int sb_len , int raw_sinfo , int buff_len , char *buff ) ;
#line 254
int sg_err_category_sense(unsigned char const   *sense_buffer , int sb_len ) ;
#line 297
void dStrHex(char const   *str , int len , int no_ascii ) ;
#line 20 "../include/sg_cmds_basic.h"
int sg_ll_inquiry(int sg_fd , int cmddt , int evpd , int pg_op , void *resp , int mx_resp_len ,
                  int noisy , int verbose___0 ) ;
#line 29
int sg_ll_log_select(int sg_fd , int pcr , int sp , int pc , int pg_code , int subpg_code ,
                     unsigned char *paramp , int param_len , int noisy , int verbose___0 ) ;
#line 39
int sg_ll_log_sense(int sg_fd , int ppc , int sp , int pc , int pg_code , int subpg_code ,
                    int paramp , unsigned char *resp , int mx_resp_len , int noisy ,
                    int verbose___0 ) ;
#line 48
int sg_ll_mode_select6(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                       int noisy , int verbose___0 ) ;
#line 56
int sg_ll_mode_select10(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                        int noisy , int verbose___0 ) ;
#line 64
int sg_ll_mode_sense6(int sg_fd , int dbd , int pc , int pg_code , int sub_pg_code ,
                      void *resp , int mx_resp_len , int noisy , int verbose___0 ) ;
#line 73
int sg_ll_mode_sense10(int sg_fd , int llbaa , int dbd , int pc , int pg_code , int sub_pg_code ,
                       void *resp , int mx_resp_len , int noisy , int verbose___0 ) ;
#line 84
int sg_ll_prevent_allow(int sg_fd , int prevent , int noisy , int verbose___0 ) ;
#line 92
int sg_ll_readcap_10(int sg_fd , int pmi , unsigned int lba , void *resp , int mx_resp_len ,
                     int noisy , int verbose___0 ) ;
#line 101
int sg_ll_readcap_16(int sg_fd , int pmi , uint64_t llba , void *resp , int mx_resp_len ,
                     int noisy , int verbose___0 ) ;
#line 108
int sg_ll_report_luns(int sg_fd , int select_report , void *resp , int mx_resp_len ,
                      int noisy , int verbose___0 ) ;
#line 115
int sg_ll_request_sense(int sg_fd , int desc , void *resp , int mx_resp_len , int noisy ,
                        int verbose___0 ) ;
#line 128
int sg_ll_start_stop_unit(int sg_fd , int immed , int pc_mod__fl_num , int power_cond ,
                          int noflush__fl , int loej , int start , int noisy , int verbose___0 ) ;
#line 137
int sg_ll_sync_cache_10(int sg_fd , int sync_nv , int immed , int group , unsigned int lba ,
                        unsigned int count , int noisy , int verbose___0 ) ;
#line 146
int sg_ll_test_unit_ready(int sg_fd , int pack_id , int noisy , int verbose___0 ) ;
#line 156
int sg_ll_test_unit_ready_progress(int sg_fd , int pack_id , int *progress , int noisy ,
                                   int verbose___0 ) ;
#line 179
int sg_simple_inquiry(int sg_fd , struct sg_simple_inquiry_resp *inq_data , int noisy ,
                      int verbose___0 ) ;
#line 189
int sg_mode_page_offset(unsigned char const   *resp , int resp_len , int mode_sense_6 ,
                        char *err_buff , int err_buff_len ) ;
#line 210
int sg_get_mode_page_controls(int sg_fd , int mode6 , int pg_code , int sub_pg_code ,
                              int dbd , int flexible , int mx_mpage_len , int *success_mask ,
                              void **pcontrol_arr , int *reported_len , int verbose___0 ) ;
#line 218
int sg_cmds_open_device(char const   *device_name , int read_only , int verbose___0 ) ;
#line 223
int sg_cmds_open_flags(char const   *device_name , int flags , int verbose___0 ) ;
#line 228
int sg_cmds_close_device(int device_fd ) ;
#line 230
char const   *sg_cmds_version(void) ;
#line 243
int sg_cmds_process_resp(struct sg_pt_base *ptvp , char const   *leadin , int res ,
                         int mx_di_len , unsigned char const   *sense_b , int noisy ,
                         int verbose___0 , int *o_sense_cat ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
static char *version_str  =    (char *)"1.51 20110207";
#line 79 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
char const   *sg_cmds_version(void) 
{ 


  {
#line 82
  return ((char const   *)version_str);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_cmds_open_device(char const   *device_name , int read_only , int verbose___0 ) 
{ 
  int tmp ;

  {
  {
#line 90
  tmp = scsi_pt_open_device(device_name, read_only, verbose___0);
  }
#line 90
  return (tmp);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_cmds_open_flags(char const   *device_name , int flags , int verbose___0 ) 
{ 
  int tmp ;

  {
  {
#line 98
  tmp = scsi_pt_open_flags(device_name, flags, verbose___0);
  }
#line 98
  return (tmp);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_cmds_close_device(int device_fd ) 
{ 
  int tmp ;

  {
  {
#line 105
  tmp = scsi_pt_close_device(device_fd);
  }
#line 105
  return (tmp);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_cmds_process_resp(struct sg_pt_base *ptvp , char const   *leadin , int res ,
                         int mx_di_len , unsigned char const   *sense_b , int noisy ,
                         int verbose___0 , int *o_sense_cat ) 
{ 
  int got ;
  int cat ;
  int duration ;
  int slen ;
  int scat ;
  int n ;
  int resid ;
  int check_data_in ;
  char b[1024] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 123
  check_data_in = 0;
#line 126
  if ((unsigned long )((void *)0) == (unsigned long )leadin) {
#line 127
    leadin = "";
  }
#line 128
  if (res < 0) {
#line 129
    if (noisy) {
      {
#line 130
      tmp = safe_strerror(- res);
#line 130
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: pass through os error: %s\n",
              leadin, tmp);
      }
    } else
#line 129
    if (verbose___0) {
      {
#line 130
      tmp = safe_strerror(- res);
#line 130
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: pass through os error: %s\n",
              leadin, tmp);
      }
    }
#line 132
    return (-1);
  } else
#line 133
  if (1 == res) {
    {
#line 134
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: bad pass through setup\n",
            leadin);
    }
#line 135
    return (-1);
  } else
#line 136
  if (2 == res) {
    {
#line 137
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: pass through timeout\n",
            leadin);
    }
#line 138
    return (-1);
  }
#line 140
  if (verbose___0 > 2) {
    {
#line 140
    duration = get_scsi_pt_duration_ms((struct sg_pt_base  const  *)ptvp);
    }
#line 140
    if (duration >= 0) {
      {
#line 141
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"      duration=%d ms\n",
              duration);
      }
    }
  }
#line 142
  if (mx_di_len > 0) {
    {
#line 142
    tmp___0 = get_scsi_pt_resid((struct sg_pt_base  const  *)ptvp);
#line 142
    resid = tmp___0;
    }
  } else {
#line 142
    resid = 0;
  }
  {
#line 143
  cat = get_scsi_pt_result_category((struct sg_pt_base  const  *)ptvp);
  }
  {
#line 144
  if (cat == 0) {
#line 144
    goto case_0;
  }
#line 153
  if (cat == 1) {
#line 153
    goto case_1;
  }
#line 160
  if (cat == 2) {
#line 160
    goto case_2;
  }
#line 193
  if (cat == 3) {
#line 193
    goto case_3___0;
  }
#line 199
  if (cat == 4) {
#line 199
    goto case_4;
  }
#line 205
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 145
  if (mx_di_len > 0) {
#line 146
    got = mx_di_len - resid;
#line 147
    if (verbose___0) {
#line 147
      if (resid > 0) {
        {
#line 148
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    %s: requested %d bytes but got %d bytes\n",
                leadin, mx_di_len, got);
        }
      }
    }
#line 150
    return (got);
  } else {
#line 152
    return (0);
  }
  case_1: /* CIL Label */ 
#line 154
  if (verbose___0) {
    {
#line 155
    tmp___1 = get_scsi_pt_status_response((struct sg_pt_base  const  *)ptvp);
#line 155
    sg_get_scsi_status_str(tmp___1, (int )sizeof(b), b);
#line 157
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: scsi status: %s\n",
            leadin, b);
    }
  } else
#line 154
  if (noisy) {
    {
#line 155
    tmp___1 = get_scsi_pt_status_response((struct sg_pt_base  const  *)ptvp);
#line 155
    sg_get_scsi_status_str(tmp___1, (int )sizeof(b), b);
#line 157
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: scsi status: %s\n",
            leadin, b);
    }
  }
#line 159
  return (-1);
  case_2: /* CIL Label */ 
  {
#line 161
  slen = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 162
  scat = sg_err_category_sense(sense_b, slen);
  }
  {
#line 169
  if (scat == 20) {
#line 169
    goto case_20;
  }
#line 169
  if (scat == 11) {
#line 169
    goto case_20;
  }
#line 169
  if (scat == 5) {
#line 169
    goto case_20;
  }
#line 169
  if (scat == 9) {
#line 169
    goto case_20;
  }
#line 169
  if (scat == 6) {
#line 169
    goto case_20;
  }
#line 169
  if (scat == 2) {
#line 169
    goto case_20;
  }
#line 173
  if (scat == 3) {
#line 173
    goto case_3;
  }
#line 173
  if (scat == 21) {
#line 173
    goto case_3;
  }
#line 175
  goto switch_default;
  case_20: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 170
  n = 0;
#line 171
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 174
  check_data_in ++;
  switch_default: /* CIL Label */ 
#line 176
  n = noisy;
#line 177
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 179
  if (verbose___0) {
#line 179
    goto _L;
  } else
#line 179
  if (n) {
    _L: /* CIL Label */ 
    {
#line 180
    sg_get_sense_str(leadin, sense_b, slen, verbose___0 > 1, (int )sizeof(b), b);
#line 182
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s",
            b);
    }
#line 183
    if (mx_di_len > 0) {
#line 183
      if (resid > 0) {
#line 184
        got = mx_di_len - resid;
#line 185
        if (verbose___0 > 2) {
          {
#line 186
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    requested %d bytes but got %d bytes\n",
                  mx_di_len, got);
          }
        } else
#line 185
        if (check_data_in) {
          {
#line 186
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    requested %d bytes but got %d bytes\n",
                  mx_di_len, got);
          }
        } else
#line 185
        if (got > 0) {
          {
#line 186
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    requested %d bytes but got %d bytes\n",
                  mx_di_len, got);
          }
        }
      }
    }
  }
#line 190
  if (o_sense_cat) {
#line 191
    *o_sense_cat = scat;
  }
#line 192
  return (-2);
  case_3___0: /* CIL Label */ 
#line 194
  if (verbose___0) {
    {
#line 195
    get_scsi_pt_transport_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b),
                                  b);
#line 196
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: transport: %s\n",
            leadin, b);
    }
  } else
#line 194
  if (noisy) {
    {
#line 195
    get_scsi_pt_transport_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b),
                                  b);
#line 196
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: transport: %s\n",
            leadin, b);
    }
  }
#line 198
  return (-1);
  case_4: /* CIL Label */ 
#line 200
  if (verbose___0) {
    {
#line 201
    get_scsi_pt_os_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b), b);
#line 202
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: os: %s\n",
            leadin, b);
    }
  } else
#line 200
  if (noisy) {
    {
#line 201
    get_scsi_pt_os_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b), b);
#line 202
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: os: %s\n",
            leadin, b);
    }
  }
#line 204
  return (-1);
  switch_default___0: /* CIL Label */ 
  {
#line 206
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: unknown pass through result category (%d)\n",
          leadin, cat);
  }
#line 208
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_inquiry(int sg_fd , int cmddt , int evpd , int pg_op , void *resp , int mx_resp_len ,
                  int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char inqCmdBlk[6] ;
  unsigned char sense_b[32] ;
  unsigned char *up ;
  struct sg_pt_base *ptvp ;

  {
#line 221
  inqCmdBlk[0] = (unsigned char)18;
#line 221
  inqCmdBlk[1] = (unsigned char)0;
#line 221
  inqCmdBlk[2] = (unsigned char)0;
#line 221
  inqCmdBlk[3] = (unsigned char)0;
#line 221
  inqCmdBlk[4] = (unsigned char)0;
#line 221
  inqCmdBlk[5] = (unsigned char)0;
#line 226
  if (cmddt) {
#line 227
    inqCmdBlk[1] = (unsigned char )((int )inqCmdBlk[1] | 2);
  }
#line 228
  if (evpd) {
#line 229
    inqCmdBlk[1] = (unsigned char )((int )inqCmdBlk[1] | 1);
  }
#line 230
  inqCmdBlk[2] = (unsigned char )pg_op;
#line 232
  inqCmdBlk[3] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 233
  inqCmdBlk[4] = (unsigned char )(mx_resp_len & 255);
#line 234
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 235
    sg_warnings_strm = stderr;
  }
#line 236
  if (verbose___0) {
    {
#line 237
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    inquiry cdb: ");
#line 238
    k = 0;
    }
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 238
      if (! (k < 6)) {
#line 238
        goto while_break;
      }
      {
#line 239
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )inqCmdBlk[k]);
#line 238
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 240
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 242
  if (resp) {
#line 242
    if (mx_resp_len > 0) {
#line 243
      up = (unsigned char *)resp;
#line 244
      *(up + 0) = (unsigned char)127;
#line 245
      if (mx_resp_len > 4) {
#line 246
        *(up + 4) = (unsigned char)0;
      }
    }
  }
  {
#line 248
  ptvp = construct_scsi_pt_obj();
  }
#line 249
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 250
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: out of memory\n");
    }
#line 251
    return (-1);
  }
  {
#line 253
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(inqCmdBlk), (int )sizeof(inqCmdBlk));
#line 254
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 255
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 256
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 257
  ret = sg_cmds_process_resp(ptvp, "inquiry", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
#line 259
  destruct_scsi_pt_obj(ptvp);
  }
#line 260
  if (! (-1 == ret)) {
#line 262
    if (-2 == ret) {
      {
#line 266
      if (sense_cat == 11) {
#line 266
        goto case_11;
      }
#line 266
      if (sense_cat == 5) {
#line 266
        goto case_11;
      }
#line 266
      if (sense_cat == 9) {
#line 266
        goto case_11;
      }
#line 270
      if (sense_cat == 20) {
#line 270
        goto case_20;
      }
#line 270
      if (sense_cat == 21) {
#line 270
        goto case_20;
      }
#line 273
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 267
      ret = sense_cat;
#line 268
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 271
      ret = 0;
#line 272
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 274
      ret = -1;
#line 275
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 277
    if (ret < 4) {
#line 278
      if (verbose___0) {
        {
#line 279
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: got too few bytes (%d)\n",
                ret);
        }
      }
#line 281
      ret = 97;
    } else {
#line 283
      ret = 0;
    }
  }
#line 285
  return (ret);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_simple_inquiry(int sg_fd , struct sg_simple_inquiry_resp *inq_data , int noisy ,
                      int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char inqCmdBlk[6] ;
  unsigned char sense_b[32] ;
  unsigned char inq_resp[36] ;
  struct sg_pt_base *ptvp ;

  {
#line 297
  inqCmdBlk[0] = (unsigned char)18;
#line 297
  inqCmdBlk[1] = (unsigned char)0;
#line 297
  inqCmdBlk[2] = (unsigned char)0;
#line 297
  inqCmdBlk[3] = (unsigned char)0;
#line 297
  inqCmdBlk[4] = (unsigned char)0;
#line 297
  inqCmdBlk[5] = (unsigned char)0;
#line 302
  if (inq_data) {
    {
#line 303
    memset((void *)inq_data, 0, sizeof(*inq_data));
#line 304
    inq_data->peripheral_qualifier = (unsigned char)3;
#line 305
    inq_data->peripheral_type = (unsigned char)31;
    }
  }
#line 307
  inqCmdBlk[4] = (unsigned char )sizeof(inq_resp);
#line 308
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 309
    sg_warnings_strm = stderr;
  }
#line 310
  if (verbose___0) {
    {
#line 311
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    inquiry cdb: ");
#line 312
    k = 0;
    }
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! (k < 6)) {
#line 312
        goto while_break;
      }
      {
#line 313
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )inqCmdBlk[k]);
#line 312
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 314
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 316
  memset((void *)(inq_resp), 0, sizeof(inq_resp));
#line 317
  inq_resp[0] = (unsigned char)127;
#line 318
  ptvp = construct_scsi_pt_obj();
  }
#line 319
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 320
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: out of memory\n");
    }
#line 321
    return (-1);
  }
  {
#line 323
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(inqCmdBlk), (int )sizeof(inqCmdBlk));
#line 324
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 325
  set_scsi_pt_data_in(ptvp, inq_resp, (int )sizeof(inq_resp));
#line 326
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 327
  ret = sg_cmds_process_resp(ptvp, "inquiry", res, (int )sizeof(inq_resp), (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 329
  if (! (-1 == ret)) {
#line 331
    if (-2 == ret) {
      {
#line 335
      if (sense_cat == 11) {
#line 335
        goto case_11;
      }
#line 335
      if (sense_cat == 5) {
#line 335
        goto case_11;
      }
#line 335
      if (sense_cat == 9) {
#line 335
        goto case_11;
      }
#line 339
      if (sense_cat == 20) {
#line 339
        goto case_20;
      }
#line 339
      if (sense_cat == 21) {
#line 339
        goto case_20;
      }
#line 342
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 336
      ret = sense_cat;
#line 337
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 340
      ret = 0;
#line 341
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 343
      ret = -1;
#line 344
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 346
    if (ret < 4) {
#line 347
      if (verbose___0) {
        {
#line 348
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: got too few bytes (%d)\n",
                ret);
        }
      }
#line 350
      ret = 97;
    } else {
#line 352
      ret = 0;
    }
  }
#line 354
  if (0 == ret) {
#line 355
    inq_data->peripheral_qualifier = (unsigned char )(((int )inq_resp[0] >> 5) & 7);
#line 356
    inq_data->peripheral_type = (unsigned char )((int )inq_resp[0] & 31);
#line 357
    if ((int )inq_resp[1] & 128) {
#line 357
      inq_data->rmb = (unsigned char)1;
    } else {
#line 357
      inq_data->rmb = (unsigned char)0;
    }
    {
#line 358
    inq_data->version = inq_resp[2];
#line 359
    inq_data->byte_3 = inq_resp[3];
#line 360
    inq_data->byte_5 = inq_resp[5];
#line 361
    inq_data->byte_6 = inq_resp[6];
#line 362
    inq_data->byte_7 = inq_resp[7];
#line 363
    memcpy((void */* __restrict  */)(inq_data->vendor), (void const   */* __restrict  */)(inq_resp + 8),
           (size_t )8);
#line 364
    memcpy((void */* __restrict  */)(inq_data->product), (void const   */* __restrict  */)(inq_resp + 16),
           (size_t )16);
#line 365
    memcpy((void */* __restrict  */)(inq_data->revision), (void const   */* __restrict  */)(inq_resp + 32),
           (size_t )4);
    }
  }
  {
#line 367
  destruct_scsi_pt_obj(ptvp);
  }
#line 368
  return (ret);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_test_unit_ready_progress(int sg_fd , int pack_id , int *progress , int noisy ,
                                   int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char turCmdBlk[6] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  int slen ;
  int tmp ;
  int tmp___0 ;

  {
#line 383
  turCmdBlk[0] = (unsigned char)0;
#line 383
  turCmdBlk[1] = (unsigned char)0;
#line 383
  turCmdBlk[2] = (unsigned char)0;
#line 383
  turCmdBlk[3] = (unsigned char)0;
#line 383
  turCmdBlk[4] = (unsigned char)0;
#line 383
  turCmdBlk[5] = (unsigned char)0;
#line 387
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 388
    sg_warnings_strm = stderr;
  }
#line 389
  if (verbose___0) {
    {
#line 390
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    test unit ready cdb: ");
#line 391
    k = 0;
    }
    {
#line 391
    while (1) {
      while_continue: /* CIL Label */ ;
#line 391
      if (! (k < 6)) {
#line 391
        goto while_break;
      }
      {
#line 392
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )turCmdBlk[k]);
#line 391
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 393
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 396
  ptvp = construct_scsi_pt_obj();
  }
#line 397
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 398
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"test unit ready: out of memory\n");
    }
#line 399
    return (-1);
  }
  {
#line 401
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(turCmdBlk), (int )sizeof(turCmdBlk));
#line 402
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 403
  set_scsi_pt_packet_id(ptvp, pack_id);
#line 404
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 405
  ret = sg_cmds_process_resp(ptvp, "test unit ready", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 407
  if (! (-1 == ret)) {
#line 409
    if (-2 == ret) {
#line 410
      if (progress) {
        {
#line 411
        tmp = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 411
        slen = tmp;
#line 413
        tmp___0 = sg_get_sense_progress_fld((unsigned char const   *)(sense_b), slen,
                                            progress);
        }
#line 413
        if (! tmp___0) {
#line 414
          *progress = -1;
        }
      }
      {
#line 419
      if (sense_cat == 11) {
#line 419
        goto case_11;
      }
#line 419
      if (sense_cat == 2) {
#line 419
        goto case_11;
      }
#line 419
      if (sense_cat == 6) {
#line 419
        goto case_11;
      }
#line 423
      if (sense_cat == 20) {
#line 423
        goto case_20;
      }
#line 423
      if (sense_cat == 21) {
#line 423
        goto case_20;
      }
#line 428
      goto switch_default;
      case_11: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_6: /* CIL Label */ 
#line 420
      ret = sense_cat;
#line 421
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 424
      ret = 0;
#line 425
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 429
      ret = -1;
#line 430
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 433
      ret = 0;
    }
  }
  {
#line 435
  destruct_scsi_pt_obj(ptvp);
  }
#line 436
  return (ret);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_test_unit_ready(int sg_fd , int pack_id , int noisy , int verbose___0 ) 
{ 
  int tmp ;

  {
  {
#line 447
  tmp = sg_ll_test_unit_ready_progress(sg_fd, pack_id, (int *)((void *)0), noisy,
                                       verbose___0);
  }
#line 447
  return (tmp);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_sync_cache_10(int sg_fd , int sync_nv , int immed , int group , unsigned int lba ,
                        unsigned int count , int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char scCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 462
  scCmdBlk[0] = (unsigned char)53;
#line 462
  scCmdBlk[1] = (unsigned char)0;
#line 462
  scCmdBlk[2] = (unsigned char)0;
#line 462
  scCmdBlk[3] = (unsigned char)0;
#line 462
  scCmdBlk[4] = (unsigned char)0;
#line 462
  scCmdBlk[5] = (unsigned char)0;
#line 462
  scCmdBlk[6] = (unsigned char)0;
#line 462
  scCmdBlk[7] = (unsigned char)0;
#line 462
  scCmdBlk[8] = (unsigned char)0;
#line 462
  scCmdBlk[9] = (unsigned char)0;
#line 467
  if (sync_nv) {
#line 468
    scCmdBlk[1] = (unsigned char )((int )scCmdBlk[1] | 4);
  }
#line 469
  if (immed) {
#line 470
    scCmdBlk[1] = (unsigned char )((int )scCmdBlk[1] | 2);
  }
#line 471
  scCmdBlk[2] = (unsigned char )((lba >> 24) & 255U);
#line 472
  scCmdBlk[3] = (unsigned char )((lba >> 16) & 255U);
#line 473
  scCmdBlk[4] = (unsigned char )((lba >> 8) & 255U);
#line 474
  scCmdBlk[5] = (unsigned char )(lba & 255U);
#line 475
  scCmdBlk[6] = (unsigned char )(group & 31);
#line 476
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 477
    sg_warnings_strm = stderr;
  }
#line 478
  if (count > 65535U) {
    {
#line 479
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"count too big\n");
    }
#line 480
    return (-1);
  }
#line 482
  scCmdBlk[7] = (unsigned char )((count >> 8) & 255U);
#line 483
  scCmdBlk[8] = (unsigned char )(count & 255U);
#line 485
  if (verbose___0) {
    {
#line 486
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    synchronize cache(10) cdb: ");
#line 487
    k = 0;
    }
    {
#line 487
    while (1) {
      while_continue: /* CIL Label */ ;
#line 487
      if (! (k < 10)) {
#line 487
        goto while_break;
      }
      {
#line 488
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )scCmdBlk[k]);
#line 487
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 489
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 491
  ptvp = construct_scsi_pt_obj();
  }
#line 492
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 493
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"synchronize cache(10): out of memory\n");
    }
#line 494
    return (-1);
  }
  {
#line 496
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(scCmdBlk), (int )sizeof(scCmdBlk));
#line 497
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 498
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 499
  ret = sg_cmds_process_resp(ptvp, "synchronize cache(10)", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 501
  if (! (-1 == ret)) {
#line 503
    if (-2 == ret) {
      {
#line 509
      if (sense_cat == 11) {
#line 509
        goto case_11;
      }
#line 509
      if (sense_cat == 5) {
#line 509
        goto case_11;
      }
#line 509
      if (sense_cat == 9) {
#line 509
        goto case_11;
      }
#line 509
      if (sense_cat == 6) {
#line 509
        goto case_11;
      }
#line 509
      if (sense_cat == 2) {
#line 509
        goto case_11;
      }
#line 513
      if (sense_cat == 20) {
#line 513
        goto case_20;
      }
#line 513
      if (sense_cat == 21) {
#line 513
        goto case_20;
      }
#line 516
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 510
      ret = sense_cat;
#line 511
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 514
      ret = 0;
#line 515
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 517
      ret = -1;
#line 518
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 521
      ret = 0;
    }
  }
  {
#line 523
  destruct_scsi_pt_obj(ptvp);
  }
#line 524
  return (ret);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_readcap_16(int sg_fd , int pmi , uint64_t llba , void *resp , int mx_resp_len ,
                     int noisy , int verbose___0 ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rcCmdBlk[16] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 537
  rcCmdBlk[0] = (unsigned char)158;
#line 537
  rcCmdBlk[1] = (unsigned char)16;
#line 537
  rcCmdBlk[2] = (unsigned char)0;
#line 537
  rcCmdBlk[3] = (unsigned char)0;
#line 537
  rcCmdBlk[4] = (unsigned char)0;
#line 537
  rcCmdBlk[5] = (unsigned char)0;
#line 537
  rcCmdBlk[6] = (unsigned char)0;
#line 537
  rcCmdBlk[7] = (unsigned char)0;
#line 537
  rcCmdBlk[8] = (unsigned char)0;
#line 537
  rcCmdBlk[9] = (unsigned char)0;
#line 537
  rcCmdBlk[10] = (unsigned char)0;
#line 537
  rcCmdBlk[11] = (unsigned char)0;
#line 537
  rcCmdBlk[12] = (unsigned char)0;
#line 537
  rcCmdBlk[13] = (unsigned char)0;
#line 537
  rcCmdBlk[14] = (unsigned char)0;
#line 537
  rcCmdBlk[15] = (unsigned char)0;
#line 543
  if (pmi) {
#line 544
    rcCmdBlk[14] = (unsigned char )((int )rcCmdBlk[14] | 1);
#line 545
    rcCmdBlk[2] = (unsigned char )((llba >> 56) & 255UL);
#line 546
    rcCmdBlk[3] = (unsigned char )((llba >> 48) & 255UL);
#line 547
    rcCmdBlk[4] = (unsigned char )((llba >> 40) & 255UL);
#line 548
    rcCmdBlk[5] = (unsigned char )((llba >> 32) & 255UL);
#line 549
    rcCmdBlk[6] = (unsigned char )((llba >> 24) & 255UL);
#line 550
    rcCmdBlk[7] = (unsigned char )((llba >> 16) & 255UL);
#line 551
    rcCmdBlk[8] = (unsigned char )((llba >> 8) & 255UL);
#line 552
    rcCmdBlk[9] = (unsigned char )(llba & 255UL);
  }
#line 555
  rcCmdBlk[10] = (unsigned char )((mx_resp_len >> 24) & 255);
#line 556
  rcCmdBlk[11] = (unsigned char )((mx_resp_len >> 16) & 255);
#line 557
  rcCmdBlk[12] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 558
  rcCmdBlk[13] = (unsigned char )(mx_resp_len & 255);
#line 559
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 560
    sg_warnings_strm = stderr;
  }
#line 561
  if (verbose___0) {
    {
#line 562
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    read capacity (16) cdb: ");
#line 563
    k = 0;
    }
    {
#line 563
    while (1) {
      while_continue: /* CIL Label */ ;
#line 563
      if (! (k < 16)) {
#line 563
        goto while_break;
      }
      {
#line 564
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rcCmdBlk[k]);
#line 563
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 565
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 567
  ptvp = construct_scsi_pt_obj();
  }
#line 568
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 569
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"read capacity (16): out of memory\n");
    }
#line 570
    return (-1);
  }
  {
#line 572
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rcCmdBlk), (int )sizeof(rcCmdBlk));
#line 573
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 574
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 575
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 576
  ret = sg_cmds_process_resp(ptvp, "read capacity (16)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 578
  if (! (-1 == ret)) {
#line 580
    if (-2 == ret) {
      {
#line 586
      if (sense_cat == 11) {
#line 586
        goto case_11;
      }
#line 586
      if (sense_cat == 5) {
#line 586
        goto case_11;
      }
#line 586
      if (sense_cat == 9) {
#line 586
        goto case_11;
      }
#line 586
      if (sense_cat == 6) {
#line 586
        goto case_11;
      }
#line 586
      if (sense_cat == 2) {
#line 586
        goto case_11;
      }
#line 590
      if (sense_cat == 20) {
#line 590
        goto case_20;
      }
#line 590
      if (sense_cat == 21) {
#line 590
        goto case_20;
      }
#line 593
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 587
      ret = sense_cat;
#line 588
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 591
      ret = 0;
#line 592
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 594
      ret = -1;
#line 595
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 598
      ret = 0;
    }
  }
  {
#line 600
  destruct_scsi_pt_obj(ptvp);
  }
#line 601
  return (ret);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_readcap_10(int sg_fd , int pmi , unsigned int lba , void *resp , int mx_resp_len ,
                     int noisy , int verbose___0 ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rcCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 614
  rcCmdBlk[0] = (unsigned char)37;
#line 614
  rcCmdBlk[1] = (unsigned char)0;
#line 614
  rcCmdBlk[2] = (unsigned char)0;
#line 614
  rcCmdBlk[3] = (unsigned char)0;
#line 614
  rcCmdBlk[4] = (unsigned char)0;
#line 614
  rcCmdBlk[5] = (unsigned char)0;
#line 614
  rcCmdBlk[6] = (unsigned char)0;
#line 614
  rcCmdBlk[7] = (unsigned char)0;
#line 614
  rcCmdBlk[8] = (unsigned char)0;
#line 614
  rcCmdBlk[9] = (unsigned char)0;
#line 619
  if (pmi) {
#line 620
    rcCmdBlk[8] = (unsigned char )((int )rcCmdBlk[8] | 1);
#line 621
    rcCmdBlk[2] = (unsigned char )((lba >> 24) & 255U);
#line 622
    rcCmdBlk[3] = (unsigned char )((lba >> 16) & 255U);
#line 623
    rcCmdBlk[4] = (unsigned char )((lba >> 8) & 255U);
#line 624
    rcCmdBlk[5] = (unsigned char )(lba & 255U);
  }
#line 626
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 627
    sg_warnings_strm = stderr;
  }
#line 628
  if (verbose___0) {
    {
#line 629
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    read capacity (10) cdb: ");
#line 630
    k = 0;
    }
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! (k < 10)) {
#line 630
        goto while_break;
      }
      {
#line 631
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rcCmdBlk[k]);
#line 630
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 632
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 634
  ptvp = construct_scsi_pt_obj();
  }
#line 635
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 636
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"read capacity (10): out of memory\n");
    }
#line 637
    return (-1);
  }
  {
#line 639
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rcCmdBlk), (int )sizeof(rcCmdBlk));
#line 640
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 641
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 642
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 643
  ret = sg_cmds_process_resp(ptvp, "read capacity (10)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 645
  if (! (-1 == ret)) {
#line 647
    if (-2 == ret) {
      {
#line 653
      if (sense_cat == 11) {
#line 653
        goto case_11;
      }
#line 653
      if (sense_cat == 5) {
#line 653
        goto case_11;
      }
#line 653
      if (sense_cat == 9) {
#line 653
        goto case_11;
      }
#line 653
      if (sense_cat == 6) {
#line 653
        goto case_11;
      }
#line 653
      if (sense_cat == 2) {
#line 653
        goto case_11;
      }
#line 657
      if (sense_cat == 20) {
#line 657
        goto case_20;
      }
#line 657
      if (sense_cat == 21) {
#line 657
        goto case_20;
      }
#line 660
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 654
      ret = sense_cat;
#line 655
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 658
      ret = 0;
#line 659
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 661
      ret = -1;
#line 662
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 665
      ret = 0;
    }
  }
  {
#line 667
  destruct_scsi_pt_obj(ptvp);
  }
#line 668
  return (ret);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_sense6(int sg_fd , int dbd , int pc , int pg_code , int sub_pg_code ,
                      void *resp , int mx_resp_len , int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[6] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 681
  modesCmdBlk[0] = (unsigned char)26;
#line 681
  modesCmdBlk[1] = (unsigned char)0;
#line 681
  modesCmdBlk[2] = (unsigned char)0;
#line 681
  modesCmdBlk[3] = (unsigned char)0;
#line 681
  modesCmdBlk[4] = (unsigned char)0;
#line 681
  modesCmdBlk[5] = (unsigned char)0;
#line 686
  if (dbd) {
#line 686
    tmp = 8;
  } else {
#line 686
    tmp = 0;
  }
#line 686
  modesCmdBlk[1] = (unsigned char )tmp;
#line 687
  modesCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 688
  modesCmdBlk[3] = (unsigned char )(sub_pg_code & 255);
#line 689
  modesCmdBlk[4] = (unsigned char )(mx_resp_len & 255);
#line 690
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 691
    sg_warnings_strm = stderr;
  }
#line 692
  if (mx_resp_len > 255) {
    {
#line 693
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len too big\n");
    }
#line 694
    return (-1);
  }
#line 696
  if (verbose___0) {
    {
#line 697
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (6) cdb: ");
#line 698
    k = 0;
    }
    {
#line 698
    while (1) {
      while_continue: /* CIL Label */ ;
#line 698
      if (! (k < 6)) {
#line 698
        goto while_break;
      }
      {
#line 699
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 698
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 700
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 702
  ptvp = construct_scsi_pt_obj();
  }
#line 703
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 704
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode sense (6): out of memory\n");
    }
#line 705
    return (-1);
  }
  {
#line 707
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 708
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 709
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 710
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 711
  ret = sg_cmds_process_resp(ptvp, "mode sense (6)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 713
  if (! (-1 == ret)) {
#line 715
    if (-2 == ret) {
      {
#line 721
      if (sense_cat == 11) {
#line 721
        goto case_11;
      }
#line 721
      if (sense_cat == 6) {
#line 721
        goto case_11;
      }
#line 721
      if (sense_cat == 5) {
#line 721
        goto case_11;
      }
#line 721
      if (sense_cat == 9) {
#line 721
        goto case_11;
      }
#line 721
      if (sense_cat == 2) {
#line 721
        goto case_11;
      }
#line 725
      if (sense_cat == 20) {
#line 725
        goto case_20;
      }
#line 725
      if (sense_cat == 21) {
#line 725
        goto case_20;
      }
#line 728
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 722
      ret = sense_cat;
#line 723
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 726
      ret = 0;
#line 727
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 729
      ret = -1;
#line 730
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 733
      if (verbose___0 > 2) {
#line 733
        if (ret > 0) {
#line 734
          if (ret > 256) {
#line 734
            tmp___0 = ", first 256 bytes";
          } else {
#line 734
            tmp___0 = "";
          }
          {
#line 734
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (6): response%s\n",
                  tmp___0);
          }
#line 736
          if (ret > 256) {
#line 736
            tmp___1 = 256;
          } else {
#line 736
            tmp___1 = ret;
          }
          {
#line 736
          dStrHex((char const   *)resp, tmp___1, -1);
          }
        }
      }
#line 738
      ret = 0;
    }
  }
  {
#line 740
  destruct_scsi_pt_obj(ptvp);
  }
#line 741
  return (ret);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_sense10(int sg_fd , int llbaa , int dbd , int pc , int pg_code , int sub_pg_code ,
                       void *resp , int mx_resp_len , int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 755
  modesCmdBlk[0] = (unsigned char)90;
#line 755
  modesCmdBlk[1] = (unsigned char)0;
#line 755
  modesCmdBlk[2] = (unsigned char)0;
#line 755
  modesCmdBlk[3] = (unsigned char)0;
#line 755
  modesCmdBlk[4] = (unsigned char)0;
#line 755
  modesCmdBlk[5] = (unsigned char)0;
#line 755
  modesCmdBlk[6] = (unsigned char)0;
#line 755
  modesCmdBlk[7] = (unsigned char)0;
#line 755
  modesCmdBlk[8] = (unsigned char)0;
#line 755
  modesCmdBlk[9] = (unsigned char)0;
#line 760
  if (dbd) {
#line 760
    tmp = 8;
  } else {
#line 760
    tmp = 0;
  }
#line 760
  if (llbaa) {
#line 760
    tmp___0 = 16;
  } else {
#line 760
    tmp___0 = 0;
  }
#line 760
  modesCmdBlk[1] = (unsigned char )(tmp | tmp___0);
#line 761
  modesCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 762
  modesCmdBlk[3] = (unsigned char )(sub_pg_code & 255);
#line 763
  modesCmdBlk[7] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 764
  modesCmdBlk[8] = (unsigned char )(mx_resp_len & 255);
#line 765
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 766
    sg_warnings_strm = stderr;
  }
#line 767
  if (mx_resp_len > 65535) {
    {
#line 768
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len too big\n");
    }
#line 769
    return (-1);
  }
#line 771
  if (verbose___0) {
    {
#line 772
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (10) cdb: ");
#line 773
    k = 0;
    }
    {
#line 773
    while (1) {
      while_continue: /* CIL Label */ ;
#line 773
      if (! (k < 10)) {
#line 773
        goto while_break;
      }
      {
#line 774
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 773
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 775
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 777
  ptvp = construct_scsi_pt_obj();
  }
#line 778
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 779
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode sense (10): out of memory\n");
    }
#line 780
    return (-1);
  }
  {
#line 782
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 783
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 784
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 785
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 786
  ret = sg_cmds_process_resp(ptvp, "mode sense (10)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 788
  if (! (-1 == ret)) {
#line 790
    if (-2 == ret) {
      {
#line 796
      if (sense_cat == 11) {
#line 796
        goto case_11;
      }
#line 796
      if (sense_cat == 6) {
#line 796
        goto case_11;
      }
#line 796
      if (sense_cat == 5) {
#line 796
        goto case_11;
      }
#line 796
      if (sense_cat == 9) {
#line 796
        goto case_11;
      }
#line 796
      if (sense_cat == 2) {
#line 796
        goto case_11;
      }
#line 800
      if (sense_cat == 20) {
#line 800
        goto case_20;
      }
#line 800
      if (sense_cat == 21) {
#line 800
        goto case_20;
      }
#line 803
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 797
      ret = sense_cat;
#line 798
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 801
      ret = 0;
#line 802
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 804
      ret = -1;
#line 805
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 808
      if (verbose___0 > 2) {
#line 808
        if (ret > 0) {
#line 809
          if (ret > 256) {
#line 809
            tmp___1 = ", first 256 bytes";
          } else {
#line 809
            tmp___1 = "";
          }
          {
#line 809
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (10): response%s\n",
                  tmp___1);
          }
#line 811
          if (ret > 256) {
#line 811
            tmp___2 = 256;
          } else {
#line 811
            tmp___2 = ret;
          }
          {
#line 811
          dStrHex((char const   *)resp, tmp___2, -1);
          }
        }
      }
#line 813
      ret = 0;
    }
  }
  {
#line 815
  destruct_scsi_pt_obj(ptvp);
  }
#line 816
  return (ret);
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_select6(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                       int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[6] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 829
  modesCmdBlk[0] = (unsigned char)21;
#line 829
  modesCmdBlk[1] = (unsigned char)0;
#line 829
  modesCmdBlk[2] = (unsigned char)0;
#line 829
  modesCmdBlk[3] = (unsigned char)0;
#line 829
  modesCmdBlk[4] = (unsigned char)0;
#line 829
  modesCmdBlk[5] = (unsigned char)0;
#line 834
  modesCmdBlk[1] = (unsigned char )(((pf << 4) & 16) | (sp & 1));
#line 835
  modesCmdBlk[4] = (unsigned char )(param_len & 255);
#line 836
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 837
    sg_warnings_strm = stderr;
  }
#line 838
  if (param_len > 255) {
    {
#line 839
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (6): param_len too big\n");
    }
#line 840
    return (-1);
  }
#line 842
  if (verbose___0) {
    {
#line 843
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (6) cdb: ");
#line 844
    k = 0;
    }
    {
#line 844
    while (1) {
      while_continue: /* CIL Label */ ;
#line 844
      if (! (k < 6)) {
#line 844
        goto while_break;
      }
      {
#line 845
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 844
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 846
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 848
  if (verbose___0 > 1) {
    {
#line 849
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (6) parameter list\n");
#line 850
    dStrHex((char const   *)paramp, param_len, -1);
    }
  }
  {
#line 853
  ptvp = construct_scsi_pt_obj();
  }
#line 854
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 855
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (6): out of memory\n");
    }
#line 856
    return (-1);
  }
  {
#line 858
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 859
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 860
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)((unsigned char *)paramp), param_len);
#line 861
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 862
  ret = sg_cmds_process_resp(ptvp, "mode select (6)", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 864
  if (! (-1 == ret)) {
#line 866
    if (-2 == ret) {
      {
#line 872
      if (sense_cat == 11) {
#line 872
        goto case_11;
      }
#line 872
      if (sense_cat == 6) {
#line 872
        goto case_11;
      }
#line 872
      if (sense_cat == 5) {
#line 872
        goto case_11;
      }
#line 872
      if (sense_cat == 9) {
#line 872
        goto case_11;
      }
#line 872
      if (sense_cat == 2) {
#line 872
        goto case_11;
      }
#line 876
      if (sense_cat == 20) {
#line 876
        goto case_20;
      }
#line 876
      if (sense_cat == 21) {
#line 876
        goto case_20;
      }
#line 879
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 873
      ret = sense_cat;
#line 874
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 877
      ret = 0;
#line 878
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 880
      ret = -1;
#line 881
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 884
      ret = 0;
    }
  }
  {
#line 886
  destruct_scsi_pt_obj(ptvp);
  }
#line 887
  return (ret);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_select10(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                        int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 900
  modesCmdBlk[0] = (unsigned char)85;
#line 900
  modesCmdBlk[1] = (unsigned char)0;
#line 900
  modesCmdBlk[2] = (unsigned char)0;
#line 900
  modesCmdBlk[3] = (unsigned char)0;
#line 900
  modesCmdBlk[4] = (unsigned char)0;
#line 900
  modesCmdBlk[5] = (unsigned char)0;
#line 900
  modesCmdBlk[6] = (unsigned char)0;
#line 900
  modesCmdBlk[7] = (unsigned char)0;
#line 900
  modesCmdBlk[8] = (unsigned char)0;
#line 900
  modesCmdBlk[9] = (unsigned char)0;
#line 905
  modesCmdBlk[1] = (unsigned char )(((pf << 4) & 16) | (sp & 1));
#line 906
  modesCmdBlk[7] = (unsigned char )((param_len >> 8) & 255);
#line 907
  modesCmdBlk[8] = (unsigned char )(param_len & 255);
#line 908
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 909
    sg_warnings_strm = stderr;
  }
#line 910
  if (param_len > 65535) {
    {
#line 911
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (10): param_len too big\n");
    }
#line 912
    return (-1);
  }
#line 914
  if (verbose___0) {
    {
#line 915
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (10) cdb: ");
#line 916
    k = 0;
    }
    {
#line 916
    while (1) {
      while_continue: /* CIL Label */ ;
#line 916
      if (! (k < 10)) {
#line 916
        goto while_break;
      }
      {
#line 917
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 916
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 918
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 920
  if (verbose___0 > 1) {
    {
#line 921
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (10) parameter list\n");
#line 922
    dStrHex((char const   *)paramp, param_len, -1);
    }
  }
  {
#line 925
  ptvp = construct_scsi_pt_obj();
  }
#line 926
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 927
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (10): out of memory\n");
    }
#line 928
    return (-1);
  }
  {
#line 930
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 931
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 932
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)((unsigned char *)paramp), param_len);
#line 933
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 934
  ret = sg_cmds_process_resp(ptvp, "mode select (10)", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 936
  if (! (-1 == ret)) {
#line 938
    if (-2 == ret) {
      {
#line 944
      if (sense_cat == 11) {
#line 944
        goto case_11;
      }
#line 944
      if (sense_cat == 6) {
#line 944
        goto case_11;
      }
#line 944
      if (sense_cat == 5) {
#line 944
        goto case_11;
      }
#line 944
      if (sense_cat == 9) {
#line 944
        goto case_11;
      }
#line 944
      if (sense_cat == 2) {
#line 944
        goto case_11;
      }
#line 948
      if (sense_cat == 20) {
#line 948
        goto case_20;
      }
#line 948
      if (sense_cat == 21) {
#line 948
        goto case_20;
      }
#line 951
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 945
      ret = sense_cat;
#line 946
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 949
      ret = 0;
#line 950
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 952
      ret = -1;
#line 953
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 956
      ret = 0;
    }
  }
  {
#line 958
  destruct_scsi_pt_obj(ptvp);
  }
#line 959
  return (ret);
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_mode_page_offset(unsigned char const   *resp , int resp_len , int mode_sense_6 ,
                        char *err_buff , int err_buff_len ) 
{ 
  int bd_len ;
  int calc_len ;
  int offset ;

  {
#line 976
  if ((unsigned long )((void *)0) == (unsigned long )resp) {
    {
#line 978
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too short: %d\n",
             resp_len);
    }
#line 980
    return (-1);
  } else
#line 976
  if (resp_len < 4) {
    {
#line 978
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too short: %d\n",
             resp_len);
    }
#line 980
    return (-1);
  } else
#line 976
  if (! mode_sense_6) {
#line 976
    if (resp_len < 8) {
      {
#line 978
      snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too short: %d\n",
               resp_len);
      }
#line 980
      return (-1);
    }
  }
#line 982
  if (mode_sense_6) {
#line 983
    calc_len = (int )((int const   )*(resp + 0) + 1);
#line 984
    bd_len = (int )*(resp + 3);
#line 985
    offset = bd_len + 4;
  } else {
#line 987
    calc_len = (int )((((int const   )*(resp + 0) << 8) + (int const   )*(resp + 1)) + 2);
#line 988
    bd_len = (int )(((int const   )*(resp + 6) << 8) + (int const   )*(resp + 7));
#line 990
    offset = bd_len + 8;
  }
#line 992
  if (offset + 2 > resp_len) {
    {
#line 993
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too small, offset=%d given_len=%d bd_len=%d\n",
             offset, resp_len, bd_len);
#line 996
    offset = -1;
    }
  } else
#line 997
  if (offset + 2 > calc_len) {
    {
#line 998
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"calculated response length too small, offset=%d calc_len=%d bd_len=%d\n",
             offset, calc_len, bd_len);
#line 1001
    offset = -1;
    }
  }
#line 1003
  return (offset);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_get_mode_page_controls(int sg_fd , int mode6 , int pg_code , int sub_pg_code ,
                              int dbd , int flexible , int mx_mpage_len , int *success_mask ,
                              void **pcontrol_arr , int *reported_len , int verbose___0 ) 
{ 
  int k ;
  int n ;
  int res ;
  int offset ;
  int calc_len ;
  int xfer_len ;
  int resp_mode6 ;
  unsigned char buff[1024] ;
  char ebuff[256] ;
  int first_err ;
  int tmp ;

  {
#line 1032
  first_err = 0;
#line 1034
  if (success_mask) {
#line 1035
    *success_mask = 0;
  }
#line 1036
  if (reported_len) {
#line 1037
    *reported_len = 0;
  }
#line 1038
  if (mx_mpage_len < 4) {
#line 1039
    return (0);
  }
#line 1040
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1041
    sg_warnings_strm = stderr;
  }
  {
#line 1042
  memset((void *)(ebuff), 0, sizeof(ebuff));
#line 1044
  memset((void *)(buff), 0, (size_t )8);
  }
#line 1045
  if (mode6) {
    {
#line 1046
    res = sg_ll_mode_sense6(sg_fd, dbd, 0, pg_code, sub_pg_code, (void *)(buff), 8,
                            0, verbose___0);
    }
  } else {
    {
#line 1050
    res = sg_ll_mode_sense10(sg_fd, 0, dbd, 0, pg_code, sub_pg_code, (void *)(buff),
                             8, 0, verbose___0);
    }
  }
#line 1053
  if (0 != res) {
#line 1054
    return (res);
  }
#line 1055
  n = (int )buff[0];
#line 1056
  if (reported_len) {
#line 1057
    if (mode6) {
#line 1057
      *reported_len = n + 1;
    } else {
#line 1057
      *reported_len = ((n << 8) + (int )buff[1]) + 2;
    }
  }
#line 1058
  resp_mode6 = mode6;
#line 1059
  if (flexible) {
#line 1060
    if (mode6) {
#line 1060
      if (n < 3) {
#line 1061
        resp_mode6 = 0;
#line 1062
        if (verbose___0) {
          {
#line 1063
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)">>> msense(6) but resp[0]=%d so try msense(10) response processing\n",
                  n);
          }
        }
      }
    }
#line 1066
    if (0 == mode6) {
#line 1066
      if (n > 5) {
#line 1067
        if (n > 11) {
#line 1067
          if (0 == n % 2) {
#line 1067
            if (0 == (int )buff[4]) {
#line 1067
              if (0 == (int )buff[5]) {
#line 1067
                if (0 == (int )buff[6]) {
#line 1069
                  buff[1] = (unsigned char )n;
#line 1070
                  buff[0] = (unsigned char)0;
#line 1071
                  if (verbose___0) {
                    {
#line 1072
                    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)">>> msense(10) but resp[0]=%d and not msense(6) response so fix length\n",
                            n);
                    }
                  }
                } else {
#line 1075
                  resp_mode6 = 1;
                }
              } else {
#line 1075
                resp_mode6 = 1;
              }
            } else {
#line 1075
              resp_mode6 = 1;
            }
          } else {
#line 1075
            resp_mode6 = 1;
          }
        } else {
#line 1075
          resp_mode6 = 1;
        }
      }
    }
  }
#line 1078
  if (verbose___0) {
#line 1078
    if (resp_mode6 != mode6) {
#line 1079
      if (mode6) {
#line 1079
        tmp = 6;
      } else {
#line 1079
        tmp = 10;
      }
      {
#line 1079
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)">>> msense(%d) but resp[0]=%d so switch response processing\n",
              tmp, (int )buff[0]);
      }
    }
  }
#line 1082
  if (resp_mode6) {
#line 1082
    calc_len = (int )buff[0] + 1;
  } else {
#line 1082
    calc_len = (((int )buff[0] << 8) + (int )buff[1]) + 2;
  }
#line 1083
  if (calc_len > 1024) {
#line 1084
    calc_len = 1024;
  }
  {
#line 1085
  offset = sg_mode_page_offset((unsigned char const   *)(buff), calc_len, resp_mode6,
                               ebuff, 256);
  }
#line 1087
  if (offset < 0) {
#line 1088
    if (0 != (int )ebuff[0]) {
#line 1088
      if (verbose___0 > 0) {
        {
#line 1089
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"sg_get_mode_page_controls: %s\n",
                ebuff);
        }
      }
    }
#line 1091
    return (97);
  }
#line 1093
  xfer_len = calc_len - offset;
#line 1094
  if (xfer_len > mx_mpage_len) {
#line 1095
    xfer_len = mx_mpage_len;
  }
#line 1097
  k = 0;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! (k < 4)) {
#line 1097
      goto while_break;
    }
#line 1098
    if ((unsigned long )((void *)0) == (unsigned long )*(pcontrol_arr + k)) {
#line 1099
      goto __Cont;
    }
    {
#line 1100
    memset(*(pcontrol_arr + k), 0, (size_t )mx_mpage_len);
    }
#line 1101
    if (mode6) {
      {
#line 1102
      res = sg_ll_mode_sense6(sg_fd, dbd, k, pg_code, sub_pg_code, (void *)(buff),
                              calc_len, 0, verbose___0);
      }
    } else {
      {
#line 1106
      res = sg_ll_mode_sense10(sg_fd, 0, dbd, k, pg_code, sub_pg_code, (void *)(buff),
                               calc_len, 0, verbose___0);
      }
    }
#line 1109
    if (0 != res) {
#line 1110
      if (0 == first_err) {
#line 1111
        first_err = res;
      }
#line 1112
      if (0 == k) {
#line 1113
        goto while_break;
      } else {
#line 1115
        goto __Cont;
      }
    }
#line 1117
    if (xfer_len > 0) {
      {
#line 1118
      memcpy((void */* __restrict  */)*(pcontrol_arr + k), (void const   */* __restrict  */)(buff + offset),
             (size_t )xfer_len);
      }
    }
#line 1119
    if (success_mask) {
#line 1120
      *success_mask |= 1 << k;
    }
    __Cont: /* CIL Label */ 
#line 1097
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  return (first_err);
}
}
#line 1129 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_request_sense(int sg_fd , int desc , void *resp , int mx_resp_len , int noisy ,
                        int verbose___0 ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rsCmdBlk[6] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 1134
  rsCmdBlk[0] = (unsigned char)3;
#line 1134
  rsCmdBlk[1] = (unsigned char)0;
#line 1134
  rsCmdBlk[2] = (unsigned char)0;
#line 1134
  rsCmdBlk[3] = (unsigned char)0;
#line 1134
  rsCmdBlk[4] = (unsigned char)0;
#line 1134
  rsCmdBlk[5] = (unsigned char)0;
#line 1139
  if (desc) {
#line 1140
    rsCmdBlk[1] = (unsigned char )((int )rsCmdBlk[1] | 1);
  }
#line 1141
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1142
    sg_warnings_strm = stderr;
  }
#line 1143
  if (mx_resp_len > 255) {
    {
#line 1144
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len cannot exceed 255\n");
    }
#line 1145
    return (-1);
  }
#line 1147
  rsCmdBlk[4] = (unsigned char )(mx_resp_len & 255);
#line 1148
  if (verbose___0) {
    {
#line 1149
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Request Sense cmd: ");
#line 1150
    k = 0;
    }
    {
#line 1150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1150
      if (! (k < 6)) {
#line 1150
        goto while_break;
      }
      {
#line 1151
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rsCmdBlk[k]);
#line 1150
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1152
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1155
  ptvp = construct_scsi_pt_obj();
  }
#line 1156
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1157
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"request sense: out of memory\n");
    }
#line 1158
    return (-1);
  }
  {
#line 1160
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rsCmdBlk), (int )sizeof(rsCmdBlk));
#line 1161
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1162
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 1163
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 1164
  ret = sg_cmds_process_resp(ptvp, "request sense", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 1166
  if (! (-1 == ret)) {
#line 1168
    if (-2 == ret) {
      {
#line 1172
      if (sense_cat == 11) {
#line 1172
        goto case_11;
      }
#line 1172
      if (sense_cat == 5) {
#line 1172
        goto case_11;
      }
#line 1172
      if (sense_cat == 9) {
#line 1172
        goto case_11;
      }
#line 1176
      if (sense_cat == 20) {
#line 1176
        goto case_20;
      }
#line 1176
      if (sense_cat == 21) {
#line 1176
        goto case_20;
      }
#line 1180
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1173
      ret = sense_cat;
#line 1174
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1177
      ret = 0;
#line 1178
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1181
      ret = -1;
#line 1182
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 1185
    if (mx_resp_len >= 8) {
#line 1185
      if (ret < 8) {
#line 1186
        if (verbose___0) {
          {
#line 1187
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    request sense: got %d bytes in response, too short\n",
                  ret);
          }
        }
#line 1189
        ret = -1;
      } else {
#line 1191
        ret = 0;
      }
    } else {
#line 1191
      ret = 0;
    }
  }
  {
#line 1193
  destruct_scsi_pt_obj(ptvp);
  }
#line 1194
  return (ret);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_report_luns(int sg_fd , int select_report , void *resp , int mx_resp_len ,
                      int noisy , int verbose___0 ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rlCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 1207
  rlCmdBlk[0] = (unsigned char)160;
#line 1207
  rlCmdBlk[1] = (unsigned char)0;
#line 1207
  rlCmdBlk[2] = (unsigned char)0;
#line 1207
  rlCmdBlk[3] = (unsigned char)0;
#line 1207
  rlCmdBlk[4] = (unsigned char)0;
#line 1207
  rlCmdBlk[5] = (unsigned char)0;
#line 1207
  rlCmdBlk[6] = (unsigned char)0;
#line 1207
  rlCmdBlk[7] = (unsigned char)0;
#line 1207
  rlCmdBlk[8] = (unsigned char)0;
#line 1207
  rlCmdBlk[9] = (unsigned char)0;
#line 1207
  rlCmdBlk[10] = (unsigned char)0;
#line 1207
  rlCmdBlk[11] = (unsigned char)0;
#line 1212
  rlCmdBlk[2] = (unsigned char )(select_report & 255);
#line 1213
  rlCmdBlk[6] = (unsigned char )((mx_resp_len >> 24) & 255);
#line 1214
  rlCmdBlk[7] = (unsigned char )((mx_resp_len >> 16) & 255);
#line 1215
  rlCmdBlk[8] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 1216
  rlCmdBlk[9] = (unsigned char )(mx_resp_len & 255);
#line 1217
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1218
    sg_warnings_strm = stderr;
  }
#line 1219
  if (verbose___0) {
    {
#line 1220
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    report luns cdb: ");
#line 1221
    k = 0;
    }
    {
#line 1221
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1221
      if (! (k < 12)) {
#line 1221
        goto while_break;
      }
      {
#line 1222
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rlCmdBlk[k]);
#line 1221
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1223
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1226
  ptvp = construct_scsi_pt_obj();
  }
#line 1227
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1228
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"report luns: out of memory\n");
    }
#line 1229
    return (-1);
  }
  {
#line 1231
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rlCmdBlk), (int )sizeof(rlCmdBlk));
#line 1232
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1233
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 1234
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 1235
  ret = sg_cmds_process_resp(ptvp, "report luns", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 1237
  if (! (-1 == ret)) {
#line 1239
    if (-2 == ret) {
      {
#line 1244
      if (sense_cat == 2) {
#line 1244
        goto case_2;
      }
#line 1244
      if (sense_cat == 11) {
#line 1244
        goto case_2;
      }
#line 1244
      if (sense_cat == 5) {
#line 1244
        goto case_2;
      }
#line 1244
      if (sense_cat == 9) {
#line 1244
        goto case_2;
      }
#line 1248
      if (sense_cat == 20) {
#line 1248
        goto case_20;
      }
#line 1248
      if (sense_cat == 21) {
#line 1248
        goto case_20;
      }
#line 1251
      goto switch_default;
      case_2: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1245
      ret = sense_cat;
#line 1246
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1249
      ret = 0;
#line 1250
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1252
      ret = -1;
#line 1253
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1256
      ret = 0;
    }
  }
  {
#line 1257
  destruct_scsi_pt_obj(ptvp);
  }
#line 1258
  return (ret);
}
}
#line 1266 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_log_sense(int sg_fd , int ppc , int sp , int pc , int pg_code , int subpg_code ,
                    int paramp , unsigned char *resp , int mx_resp_len , int noisy ,
                    int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char logsCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1272
  logsCmdBlk[0] = (unsigned char)77;
#line 1272
  logsCmdBlk[1] = (unsigned char)0;
#line 1272
  logsCmdBlk[2] = (unsigned char)0;
#line 1272
  logsCmdBlk[3] = (unsigned char)0;
#line 1272
  logsCmdBlk[4] = (unsigned char)0;
#line 1272
  logsCmdBlk[5] = (unsigned char)0;
#line 1272
  logsCmdBlk[6] = (unsigned char)0;
#line 1272
  logsCmdBlk[7] = (unsigned char)0;
#line 1272
  logsCmdBlk[8] = (unsigned char)0;
#line 1272
  logsCmdBlk[9] = (unsigned char)0;
#line 1277
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1278
    sg_warnings_strm = stderr;
  }
#line 1279
  if (mx_resp_len > 65535) {
    {
#line 1280
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len too big\n");
    }
#line 1281
    return (-1);
  }
#line 1283
  if (ppc) {
#line 1283
    tmp = 2;
  } else {
#line 1283
    tmp = 0;
  }
#line 1283
  if (sp) {
#line 1283
    tmp___0 = 1;
  } else {
#line 1283
    tmp___0 = 0;
  }
#line 1283
  logsCmdBlk[1] = (unsigned char )(tmp | tmp___0);
#line 1284
  logsCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 1285
  logsCmdBlk[3] = (unsigned char )(subpg_code & 255);
#line 1286
  logsCmdBlk[5] = (unsigned char )((paramp >> 8) & 255);
#line 1287
  logsCmdBlk[6] = (unsigned char )(paramp & 255);
#line 1288
  logsCmdBlk[7] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 1289
  logsCmdBlk[8] = (unsigned char )(mx_resp_len & 255);
#line 1290
  if (verbose___0) {
    {
#line 1291
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    log sense cdb: ");
#line 1292
    k = 0;
    }
    {
#line 1292
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1292
      if (! (k < 10)) {
#line 1292
        goto while_break;
      }
      {
#line 1293
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )logsCmdBlk[k]);
#line 1292
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1294
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1297
  ptvp = construct_scsi_pt_obj();
  }
#line 1298
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1299
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"log sense: out of memory\n");
    }
#line 1300
    return (-1);
  }
  {
#line 1302
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(logsCmdBlk), (int )sizeof(logsCmdBlk));
#line 1303
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1304
  set_scsi_pt_data_in(ptvp, resp, mx_resp_len);
#line 1305
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 1306
  ret = sg_cmds_process_resp(ptvp, "log sense", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 1308
  if (! (-1 == ret)) {
#line 1310
    if (-2 == ret) {
      {
#line 1316
      if (sense_cat == 11) {
#line 1316
        goto case_11;
      }
#line 1316
      if (sense_cat == 6) {
#line 1316
        goto case_11;
      }
#line 1316
      if (sense_cat == 5) {
#line 1316
        goto case_11;
      }
#line 1316
      if (sense_cat == 9) {
#line 1316
        goto case_11;
      }
#line 1316
      if (sense_cat == 2) {
#line 1316
        goto case_11;
      }
#line 1320
      if (sense_cat == 20) {
#line 1320
        goto case_20;
      }
#line 1320
      if (sense_cat == 21) {
#line 1320
        goto case_20;
      }
#line 1323
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1317
      ret = sense_cat;
#line 1318
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1321
      ret = 0;
#line 1322
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1324
      ret = -1;
#line 1325
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1328
      ret = 0;
    }
  }
  {
#line 1329
  destruct_scsi_pt_obj(ptvp);
  }
#line 1330
  return (ret);
}
}
#line 1338 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_log_select(int sg_fd , int pcr , int sp , int pc , int pg_code , int subpg_code ,
                     unsigned char *paramp , int param_len , int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char logsCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1344
  logsCmdBlk[0] = (unsigned char)76;
#line 1344
  logsCmdBlk[1] = (unsigned char)0;
#line 1344
  logsCmdBlk[2] = (unsigned char)0;
#line 1344
  logsCmdBlk[3] = (unsigned char)0;
#line 1344
  logsCmdBlk[4] = (unsigned char)0;
#line 1344
  logsCmdBlk[5] = (unsigned char)0;
#line 1344
  logsCmdBlk[6] = (unsigned char)0;
#line 1344
  logsCmdBlk[7] = (unsigned char)0;
#line 1344
  logsCmdBlk[8] = (unsigned char)0;
#line 1344
  logsCmdBlk[9] = (unsigned char)0;
#line 1349
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1350
    sg_warnings_strm = stderr;
  }
#line 1351
  if (param_len > 65535) {
    {
#line 1352
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"log select: param_len too big\n");
    }
#line 1353
    return (-1);
  }
#line 1355
  if (pcr) {
#line 1355
    tmp = 2;
  } else {
#line 1355
    tmp = 0;
  }
#line 1355
  if (sp) {
#line 1355
    tmp___0 = 1;
  } else {
#line 1355
    tmp___0 = 0;
  }
#line 1355
  logsCmdBlk[1] = (unsigned char )(tmp | tmp___0);
#line 1356
  logsCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 1357
  logsCmdBlk[3] = (unsigned char )(subpg_code & 255);
#line 1358
  logsCmdBlk[7] = (unsigned char )((param_len >> 8) & 255);
#line 1359
  logsCmdBlk[8] = (unsigned char )(param_len & 255);
#line 1360
  if (verbose___0) {
    {
#line 1361
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    log select cdb: ");
#line 1362
    k = 0;
    }
    {
#line 1362
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1362
      if (! (k < 10)) {
#line 1362
        goto while_break;
      }
      {
#line 1363
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )logsCmdBlk[k]);
#line 1362
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1364
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 1366
  if (verbose___0 > 1) {
#line 1366
    if (param_len > 0) {
      {
#line 1367
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    log select parameter list\n");
#line 1368
      dStrHex((char const   *)paramp, param_len, -1);
      }
    }
  }
  {
#line 1371
  ptvp = construct_scsi_pt_obj();
  }
#line 1372
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1373
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"log select: out of memory\n");
    }
#line 1374
    return (-1);
  }
  {
#line 1376
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(logsCmdBlk), (int )sizeof(logsCmdBlk));
#line 1377
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1378
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)paramp, param_len);
#line 1379
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 1380
  ret = sg_cmds_process_resp(ptvp, "log select", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 1382
  if (! (-1 == ret)) {
#line 1384
    if (-2 == ret) {
      {
#line 1390
      if (sense_cat == 11) {
#line 1390
        goto case_11;
      }
#line 1390
      if (sense_cat == 6) {
#line 1390
        goto case_11;
      }
#line 1390
      if (sense_cat == 5) {
#line 1390
        goto case_11;
      }
#line 1390
      if (sense_cat == 9) {
#line 1390
        goto case_11;
      }
#line 1390
      if (sense_cat == 2) {
#line 1390
        goto case_11;
      }
#line 1394
      if (sense_cat == 20) {
#line 1394
        goto case_20;
      }
#line 1394
      if (sense_cat == 21) {
#line 1394
        goto case_20;
      }
#line 1397
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1391
      ret = sense_cat;
#line 1392
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1395
      ret = 0;
#line 1396
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1398
      ret = -1;
#line 1399
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1402
      ret = 0;
    }
  }
  {
#line 1404
  destruct_scsi_pt_obj(ptvp);
  }
#line 1405
  return (ret);
}
}
#line 1419 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_start_stop_unit(int sg_fd , int immed , int pc_mod__fl_num , int power_cond ,
                          int noflush__fl , int loej , int start , int noisy , int verbose___0 ) 
{ 
  unsigned char ssuBlk[6] ;
  unsigned char sense_b[32] ;
  int k ;
  int res ;
  int ret ;
  int sense_cat ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1424
  ssuBlk[0] = (unsigned char)27;
#line 1424
  ssuBlk[1] = (unsigned char)0;
#line 1424
  ssuBlk[2] = (unsigned char)0;
#line 1424
  ssuBlk[3] = (unsigned char)0;
#line 1424
  ssuBlk[4] = (unsigned char)0;
#line 1424
  ssuBlk[5] = (unsigned char)0;
#line 1429
  ssuBlk[1] = (unsigned char )(immed & 1);
#line 1430
  ssuBlk[3] = (unsigned char )(pc_mod__fl_num & 15);
#line 1431
  if (noflush__fl) {
#line 1431
    tmp = 4;
  } else {
#line 1431
    tmp = 0;
  }
#line 1431
  if (loej) {
#line 1431
    tmp___0 = 2;
  } else {
#line 1431
    tmp___0 = 0;
  }
#line 1431
  if (start) {
#line 1431
    tmp___1 = 1;
  } else {
#line 1431
    tmp___1 = 0;
  }
#line 1431
  ssuBlk[4] = (unsigned char )(((((power_cond & 15) << 4) | tmp) | tmp___0) | tmp___1);
#line 1433
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1434
    sg_warnings_strm = stderr;
  }
#line 1435
  if (verbose___0) {
    {
#line 1436
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Start stop unit command:");
#line 1437
    k = 0;
    }
    {
#line 1437
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1437
      if (! (k < (int )sizeof(ssuBlk))) {
#line 1437
        goto while_break;
      }
      {
#line 1438
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)" %02x",
              (int )ssuBlk[k]);
#line 1437
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1439
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1442
  ptvp = construct_scsi_pt_obj();
  }
#line 1443
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1444
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"start stop unit: out of memory\n");
    }
#line 1445
    return (-1);
  }
  {
#line 1447
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(ssuBlk), (int )sizeof(ssuBlk));
#line 1448
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1449
  res = do_scsi_pt(ptvp, sg_fd, 120, verbose___0);
#line 1450
  ret = sg_cmds_process_resp(ptvp, "start stop unit", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 1452
  if (! (-1 == ret)) {
#line 1454
    if (-2 == ret) {
      {
#line 1460
      if (sense_cat == 11) {
#line 1460
        goto case_11;
      }
#line 1460
      if (sense_cat == 6) {
#line 1460
        goto case_11;
      }
#line 1460
      if (sense_cat == 5) {
#line 1460
        goto case_11;
      }
#line 1460
      if (sense_cat == 9) {
#line 1460
        goto case_11;
      }
#line 1460
      if (sense_cat == 2) {
#line 1460
        goto case_11;
      }
#line 1464
      if (sense_cat == 20) {
#line 1464
        goto case_20;
      }
#line 1464
      if (sense_cat == 21) {
#line 1464
        goto case_20;
      }
#line 1467
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1461
      ret = sense_cat;
#line 1462
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1465
      ret = 0;
#line 1466
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1468
      ret = -1;
#line 1469
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1472
      ret = 0;
    }
  }
  {
#line 1473
  destruct_scsi_pt_obj(ptvp);
  }
#line 1474
  return (ret);
}
}
#line 1485 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_basic.c"
int sg_ll_prevent_allow(int sg_fd , int prevent , int noisy , int verbose___0 ) 
{ 
  int k ;
  int res ;
  int ret ;
  int sense_cat ;
  unsigned char pCmdBlk[6] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 1489
  pCmdBlk[0] = (unsigned char)30;
#line 1489
  pCmdBlk[1] = (unsigned char)0;
#line 1489
  pCmdBlk[2] = (unsigned char)0;
#line 1489
  pCmdBlk[3] = (unsigned char)0;
#line 1489
  pCmdBlk[4] = (unsigned char)0;
#line 1489
  pCmdBlk[5] = (unsigned char)0;
#line 1494
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1495
    sg_warnings_strm = stderr;
  }
#line 1496
  if (prevent < 0) {
    {
#line 1497
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"prevent argument should be 0, 1, 2 or 3\n");
    }
#line 1498
    return (-1);
  } else
#line 1496
  if (prevent > 3) {
    {
#line 1497
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"prevent argument should be 0, 1, 2 or 3\n");
    }
#line 1498
    return (-1);
  }
#line 1500
  pCmdBlk[4] = (unsigned char )((int )pCmdBlk[4] | (prevent & 3));
#line 1501
  if (verbose___0) {
    {
#line 1502
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Prevent allow medium removal cdb: ");
#line 1503
    k = 0;
    }
    {
#line 1503
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1503
      if (! (k < 6)) {
#line 1503
        goto while_break;
      }
      {
#line 1504
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )pCmdBlk[k]);
#line 1503
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1505
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1508
  ptvp = construct_scsi_pt_obj();
  }
#line 1509
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1510
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"prevent allow medium removal: out of memory\n");
    }
#line 1512
    return (-1);
  }
  {
#line 1514
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(pCmdBlk), (int )sizeof(pCmdBlk));
#line 1515
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1516
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 1517
  ret = sg_cmds_process_resp(ptvp, "prevent allow medium removal", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 1519
  if (! (-1 == ret)) {
#line 1521
    if (-2 == ret) {
      {
#line 1527
      if (sense_cat == 11) {
#line 1527
        goto case_11;
      }
#line 1527
      if (sense_cat == 6) {
#line 1527
        goto case_11;
      }
#line 1527
      if (sense_cat == 5) {
#line 1527
        goto case_11;
      }
#line 1527
      if (sense_cat == 9) {
#line 1527
        goto case_11;
      }
#line 1527
      if (sense_cat == 2) {
#line 1527
        goto case_11;
      }
#line 1531
      if (sense_cat == 20) {
#line 1531
        goto case_20;
      }
#line 1531
      if (sense_cat == 21) {
#line 1531
        goto case_20;
      }
#line 1534
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1528
      ret = sense_cat;
#line 1529
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1532
      ret = 0;
#line 1533
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1535
      ret = -1;
#line 1536
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1539
      ret = 0;
    }
  }
  {
#line 1540
  destruct_scsi_pt_obj(ptvp);
  }
#line 1541
  return (ret);
}
}
#line 28 "../include/sg_pt.h"
char const   *scsi_pt_version(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_common.c"
static char const   *scsi_pt_version_str  =    "2.08 20110207";
#line 19 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_pt_common.c"
char const   *scsi_pt_version(void) 
{ 


  {
#line 22
  return (scsi_pt_version_str);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static char *version_str___0  =    (char *)"0.92 20110217 [svn: r157]";
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 956
extern int fsync(int __fd ) ;
#line 1019
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off64_t __length )  __asm__("ftruncate64")  ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 286 "/usr/include/stdio.h"
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream )  __asm__("freopen64")  ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 30 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 242 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    __off64_t __len ,
                                                                                    int __advise )  __asm__("posix_fadvise64")  ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 156 "../include/sg_lib.h"
int sg_scsi_normalize_sense(unsigned char const   *sensep , int sb_len , struct sg_scsi_sense_hdr *sshp ) ;
#line 176
int sg_get_sense_info_fld(unsigned char const   *sensep , int sb_len , uint64_t *info_outp ) ;
#line 183
int sg_get_sense_filemark_eom_ili(unsigned char const   *sensep , int sb_len , int *filemark_p ,
                                  int *eom_p , int *ili_p ) ;
#line 334
int sg_get_num(char const   *buf ) ;
#line 347
int64_t sg_get_llnum(char const   *buf ) ;
#line 359
int sg_set_binary_mode(int fd ) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int64_t dd_count  =    (int64_t )-1;
#line 124 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int64_t in_full  =    (int64_t )0;
#line 125 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int in_partial  =    0;
#line 126 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int64_t out_full  =    (int64_t )0;
#line 127 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int out_partial  =    0;
#line 128 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int out_sparse_active  =    0;
#line 129 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int out_sparing_active  =    0;
#line 130 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int out_trim_active  =    0;
#line 131 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int64_t out_sparse  =    (int64_t )0;
#line 132 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int out_sparse_partial  =    0;
#line 133 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int recovered_errs  =    0;
#line 134 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int unrecovered_errs  =    0;
#line 135 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int wr_recovered_errs  =    0;
#line 136 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int wr_unrecovered_errs  =    0;
#line 137 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int trim_errs  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int64_t lowest_unrecovered  =    (int64_t )0;
#line 139 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int64_t highest_unrecovered  =    (int64_t )-1;
#line 140 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int num_retries  =    0;
#line 141 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int sum_of_resids  =    0;
#line 142 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int interrupted_retries  =    0;
#line 143 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int err_to_report  =    0;
#line 144 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int reading_fifo  =    0;
#line 146 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static struct sg_pt_base *if_ptvp  =    (struct sg_pt_base *)((void *)0);
#line 147 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static struct sg_pt_base *of_ptvp  =    (struct sg_pt_base *)((void *)0);
#line 149 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int do_time  =    1;
#line 150 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int verbose  =    0;
#line 151 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int quiet  =    0;
#line 153 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int start_tm_valid  =    0;
#line 154 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static struct timespec start_tm  ;
#line 159 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int read1_or_transfer  =    0;
#line 160 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int ibs_hold  =    0;
#line 161 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int out_type_hold  =    0;
#line 162 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int max_uas  =    10;
#line 163 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int max_aborted  =    16;
#line 164 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int coe_limit  =    0;
#line 165 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int coe_count  =    0;
#line 170 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static unsigned char *zeros_buff  =    (unsigned char *)((void *)0);
#line 173 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static char const   *errblk_file  =    "errblk.txt";
#line 174 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static FILE *errblk_fp  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static struct signum_name_t signum_name_arr[5]  = {      {2, (char *)"SIGINT"}, 
        {3, (char *)"SIGQUIT"}, 
        {13, (char *)"SIGPIPE"}, 
        {10, (char *)"SIGUSR1"}, 
        {0, (char *)((void *)0)}};
#line 189
static void calc_duration_throughput(char const   *leadin , int contin ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void usage(void) 
{ 


  {
  {
#line 195
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: ddpt  [bpt=BPT[,OBPC]] [bs=BS] [cdbsz=6|10|12|16] [coe=0|1]\n             [coe_limit=CL] [conv=CONVS] [count=COUNT] [ibs=IBS] if=IFILE\n             [iflag=FLAGS] [obs=OBS] [of=OFILE] [of2=OFILE2] [oflag=FLAGS]\n             [retries=RETR] [seek=SEEK] [skip=SKIP] [status=STAT]\n             [verbose=VERB] [--help] [--verbose] [--version]\n  where:\n    bpt         input Blocks Per Transfer (BPT) (def: 128 when IBS is 512)\n                Output Blocks Per Check (OBPC) (def: 0 implies BPT*IBS/OBS)\n    bs          block size for input and output (overrides ibs and obs)\n");
#line 216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    cdbsz       size of SCSI READ or WRITE cdb (default is 10)\n    coe         0->exit on error (def), 1->continue on pt error (zero fill)\n    coe_limit   limit consecutive \'bad\' blocks on reads to CL times\n                when coe=1 (default: 0 which is no limit)\n    conv        conversions, comma separated list of CONVS (see below)\n    count       number of input blocks to copy (def: (remaining)\n                device size)\n    ibs         input block size (default 512 bytes)\n    if          file or device to read from (for stdin use \'-\')\n    iflag       input flags, comma separated list from FLAGS (see below)\n    obs         output block size (def: 512), when IBS is not equal OBS\n                [ (((IBS * BPT) %% OBS) == 0) is required\n    of          file or device to write to (def: /dev/null)\n");
#line 238
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    of2         additional output file (def: /dev/null), OFILE2 should be\n                normal file or pipe\n    oflag       output flags, comma separated list from FLAGS (see below)\n    retries     retry pass-through errors RETR times (def: 0)\n    seek        block position to start writing to OFILE\n    skip        block position to start reading from IFILE\n    status      value: \'noxfer\' suppresses throughput calculation\n    verbose     0->normal(def), 1->some noise, 2->more noise, etc\n                -1->quiet (stderr->/dev/null)\n    --help      print out this usage message then exit\n    --verbose   equivalent to verbose=1\n    --version   print version information then exit\n\nCopy all or part of IFILE to OFILE, IBS*BPT bytes at a time. Similar to\ndd command. Support for block devices, especially those accessed via\na SCSI pass-through.\nFLAGS: append(o),coe,direct,dpo,errblk(i),excl,fdatasync(o),flock,force\nfsync(o),fua,fua_nv,nocache,norcap,nowrite(o),null,pt,resume(o),self\nsparing(o),sparse(o),ssync(o),strunc(o),sync,trim(o),trunc(o),unmap(o).\nCONVS: fdatasync,fsync,noerror,null,resume,sparing,sparse,sync,trunc\n");
  }
#line 271
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void print_stats(char const   *str ) 
{ 
  char const   *cp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 277
  if (0L != dd_count) {
#line 277
    if (! reading_fifo) {
      {
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  remaining block count=%ld\n",
              dd_count);
      }
    }
  }
  {
#line 279
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%ld+%d records in\n",
          str, in_full, in_partial);
#line 280
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%ld+%d records out\n",
          str, out_full, out_partial);
  }
#line 282
  if (out_sparse_active) {
#line 282
    goto _L;
  } else
#line 282
  if (out_sparing_active) {
    _L: /* CIL Label */ 
#line 283
    if (out_trim_active) {
#line 286
      if (trim_errs) {
#line 286
        cp = "attempted trim";
      } else {
#line 286
        cp = "trimmed";
      }
#line 287
      if (out_sparse_partial > 0) {
        {
#line 288
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%ld+%d %s records out\n",
                str, out_sparse, out_sparse_partial, cp);
        }
      } else {
        {
#line 291
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%ld %s records out\n",
                str, out_sparse, cp);
        }
      }
    } else
#line 293
    if (out_sparse_partial > 0) {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%ld+%d bypassed records out\n",
              str, out_sparse, out_sparse_partial);
      }
    } else {
      {
#line 297
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%ld bypassed records out\n",
              str, out_sparse);
      }
    }
  }
#line 300
  if (recovered_errs > 0) {
    {
#line 301
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d recovered read errors\n",
            str, recovered_errs);
    }
  }
#line 302
  if (num_retries > 0) {
    {
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d retries attempted\n",
            str, num_retries);
    }
  }
#line 304
  if (unrecovered_errs > 0) {
#line 305
    if (1 == unrecovered_errs) {
#line 305
      tmp = "";
    } else {
#line 305
      tmp = "s";
    }
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d unrecovered read error%s\n",
            str, unrecovered_errs, tmp);
    }
  }
#line 307
  if (unrecovered_errs) {
#line 307
    if (highest_unrecovered >= 0L) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lowest unrecovered read lba=%ld, highest unrecovered lba=%ld\n",
              lowest_unrecovered, highest_unrecovered);
      }
    }
  }
#line 311
  if (wr_recovered_errs > 0) {
    {
#line 312
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d recovered write errors\n",
            str, wr_recovered_errs);
    }
  }
#line 314
  if (wr_unrecovered_errs > 0) {
#line 315
    if (1 == wr_unrecovered_errs) {
#line 315
      tmp___0 = "";
    } else {
#line 315
      tmp___0 = "s";
    }
    {
#line 315
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d unrecovered write error%s\n",
            str, wr_unrecovered_errs, tmp___0);
    }
  }
#line 317
  if (trim_errs) {
    {
#line 318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d trim errors\n",
            str, trim_errs);
    }
  }
#line 319
  if (interrupted_retries > 0) {
#line 320
    if (1 == interrupted_retries) {
#line 320
      tmp___1 = "retry";
    } else {
#line 320
      tmp___1 = "retries";
    }
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%d %s after interrupted system call(s)\n",
            str, interrupted_retries, tmp___1);
    }
  }
#line 323
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static char const   *get_signal_name(int signum , char *b , int blen ) 
{ 
  struct signum_name_t  const  *sp ;

  {
#line 331
  sp = (struct signum_name_t  const  *)(signum_name_arr);
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! sp->num) {
#line 331
      goto while_break;
    }
#line 332
    if (signum == (int )sp->num) {
#line 333
      goto while_break;
    }
#line 331
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  *(b + (blen - 1)) = (char )'\000';
#line 336
  if (sp->num) {
    {
#line 337
    strncpy((char */* __restrict  */)b, (char const   */* __restrict  */)sp->name,
            (size_t )(blen - 1));
    }
  } else {
    {
#line 339
    snprintf((char */* __restrict  */)b, (size_t )(blen - 1), (char const   */* __restrict  */)"%d",
             signum);
    }
  }
#line 340
  return ((char const   *)b);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void register_handler(int sig_num , void (*sig_handler)(int sig ) ) 
{ 
  struct sigaction sigact ;

  {
  {
#line 355
  sigaction(sig_num, (struct sigaction  const  */* __restrict  */)((void *)0), (struct sigaction */* __restrict  */)(& sigact));
  }
#line 356
  if (2 != sig_num) {
#line 356
    if (3 != sig_num) {
      {
#line 358
      sigact.__sigaction_handler.sa_handler = sig_handler;
#line 359
      sigemptyset(& sigact.sa_mask);
#line 360
      sigact.sa_flags = 0;
#line 361
      sigaction(sig_num, (struct sigaction  const  */* __restrict  */)(& sigact),
                (struct sigaction */* __restrict  */)((void *)0));
      }
    } else {
#line 356
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 356
  if ((unsigned long )sigact.__sigaction_handler.sa_handler != (unsigned long )((void (*)(int  ))1)) {
    {
#line 358
    sigact.__sigaction_handler.sa_handler = sig_handler;
#line 359
    sigemptyset(& sigact.sa_mask);
#line 360
    sigact.sa_flags = 0;
#line 361
    sigaction(sig_num, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)((void *)0));
    }
  }
#line 364
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void interrupt_handler(int sig ) 
{ 
  char b[32] ;
  struct sigaction sigact ;
  char const   *tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 386
  sigact.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 387
  sigemptyset(& sigact.sa_mask);
#line 388
  sigact.sa_flags = 0;
#line 389
  sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)((void *)0));
#line 390
  tmp = get_signal_name(sig, b, (int )sizeof(b));
#line 390
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Interrupted by signal %s,",
          tmp);
#line 392
  print_stats("");
  }
#line 393
  if (do_time) {
    {
#line 394
    calc_duration_throughput("", 0);
    }
  }
#line 395
  if (4 & out_type_hold) {
    {
#line 396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"To resume, invoke with same arguments plus oflag=resume\n");
    }
  }
  {
#line 398
  tmp___0 = getpid();
#line 398
  kill(tmp___0, sig);
  }
#line 400
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void siginfo_handler(int sig ) 
{ 


  {
  {
#line 406
  sig = sig;
#line 407
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Progress report:\n");
#line 408
  print_stats("  ");
  }
#line 409
  if (do_time) {
    {
#line 410
    calc_duration_throughput("  ", 1);
    }
  }
  {
#line 411
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  continuing ...\n");
  }
#line 412
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void open_errblk(void) 
{ 
  time_t t ;
  char b[64] ;
  struct tm *tmp ;

  {
  {
#line 420
  errblk_fp = fopen((char const   */* __restrict  */)errblk_file, (char const   */* __restrict  */)"a");
  }
#line 421
  if ((unsigned long )((void *)0) == (unsigned long )errblk_fp) {
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to open or create %s\n",
            errblk_file);
    }
  } else {
    {
#line 429
    t = time((time_t *)((void *)0));
#line 430
    tmp = localtime((time_t const   *)(& t));
#line 430
    strftime((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"# start: %Y-%m-%d %H:%M:%S\n",
             (struct tm  const  */* __restrict  */)tmp);
#line 432
    fputs((char const   */* __restrict  */)(b), (FILE */* __restrict  */)errblk_fp);
    }
  }
#line 438
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void put_errblk(uint64_t lba ) 
{ 


  {
#line 443
  if (errblk_fp) {
    {
#line 444
    fprintf((FILE */* __restrict  */)errblk_fp, (char const   */* __restrict  */)"0x%lx\n",
            lba);
    }
  }
#line 445
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void put_range_errblk(uint64_t lba , int num ) 
{ 


  {
#line 450
  if (errblk_fp) {
#line 451
    if (1 == num) {
      {
#line 452
      put_errblk(lba);
      }
    } else
#line 453
    if (num > 1) {
      {
#line 454
      fprintf((FILE */* __restrict  */)errblk_fp, (char const   */* __restrict  */)"0x%lx-0x%lx\n",
              lba, lba + (uint64_t )(num - 1));
      }
    }
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void close_errblk(void) 
{ 
  time_t t ;
  char b[64] ;
  struct tm *tmp ;

  {
#line 462
  if (errblk_fp) {
    {
#line 468
    t = time((time_t *)((void *)0));
#line 469
    tmp = localtime((time_t const   *)(& t));
#line 469
    strftime((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"# stop: %Y-%m-%d %H:%M:%S\n",
             (struct tm  const  */* __restrict  */)tmp);
#line 471
    fputs((char const   */* __restrict  */)(b), (FILE */* __restrict  */)errblk_fp);
#line 476
    fclose(errblk_fp);
#line 477
    errblk_fp = (FILE *)((void *)0);
    }
  }
#line 479
  return;
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int process_conv(char const   *arg , struct flags_t *ifp , struct flags_t *ofp ) 
{ 
  char buff[256] ;
  char *cp ;
  char *np ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 491
  strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)arg, sizeof(buff));
#line 492
  buff[sizeof(buff) - 1UL] = (char )'\000';
  }
#line 493
  if (0 == (int )buff[0]) {
    {
#line 494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no conversions found\n");
    }
#line 495
    return (1);
  }
#line 497
  cp = buff;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 499
    np = strchr((char const   *)cp, ',');
    }
#line 500
    if (np) {
#line 501
      tmp = np;
#line 501
      np ++;
#line 501
      *tmp = (char )'\000';
    }
    {
#line 502
    tmp___8 = strcmp((char const   *)cp, "fdatasync");
    }
#line 502
    if (0 == tmp___8) {
#line 503
      (ofp->fdatasync) ++;
    } else {
      {
#line 504
      tmp___7 = strcmp((char const   *)cp, "fsync");
      }
#line 504
      if (0 == tmp___7) {
#line 505
        (ofp->fsync) ++;
      } else {
        {
#line 506
        tmp___6 = strcmp((char const   *)cp, "noerror");
        }
#line 506
        if (0 == tmp___6) {
#line 507
          (ifp->coe) ++;
        } else {
          {
#line 508
          tmp___5 = strcmp((char const   *)cp, "null");
          }
#line 508
          if (! (0 == tmp___5)) {
            {
#line 510
            tmp___4 = strcmp((char const   *)cp, "resume");
            }
#line 510
            if (0 == tmp___4) {
#line 511
              (ofp->resume) ++;
            } else {
              {
#line 512
              tmp___3 = strcmp((char const   *)cp, "sparing");
              }
#line 512
              if (0 == tmp___3) {
#line 513
                (ofp->sparing) ++;
              } else {
                {
#line 514
                tmp___2 = strcmp((char const   *)cp, "sparse");
                }
#line 514
                if (0 == tmp___2) {
#line 515
                  (ofp->sparse) ++;
                } else {
                  {
#line 516
                  tmp___1 = strcmp((char const   *)cp, "sync");
                  }
#line 516
                  if (! (0 == tmp___1)) {
                    {
#line 519
                    tmp___0 = strcmp((char const   *)cp, "trunc");
                    }
#line 519
                    if (0 == tmp___0) {
#line 520
                      (ofp->trunc) ++;
                    } else {
                      {
#line 522
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognised flag: %s\n",
                              cp);
                      }
#line 523
                      return (1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 525
    cp = np;
#line 498
    if (! cp) {
#line 498
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  return (0);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int process_flags(char const   *arg , struct flags_t *fp ) 
{ 
  char buff[256] ;
  char *cp ;
  char *np ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 539
  strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)arg, sizeof(buff));
#line 540
  buff[sizeof(buff) - 1UL] = (char )'\000';
  }
#line 541
  if (0 == (int )buff[0]) {
    {
#line 542
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no flag found\n");
    }
#line 543
    return (1);
  }
#line 545
  cp = buff;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 547
    np = strchr((char const   *)cp, ',');
    }
#line 548
    if (np) {
#line 549
      tmp = np;
#line 549
      np ++;
#line 549
      *tmp = (char )'\000';
    }
    {
#line 550
    tmp___26 = strcmp((char const   *)cp, "append");
    }
#line 550
    if (0 == tmp___26) {
#line 551
      (fp->append) ++;
    } else {
      {
#line 552
      tmp___25 = strcmp((char const   *)cp, "coe");
      }
#line 552
      if (0 == tmp___25) {
#line 553
        (fp->coe) ++;
      } else {
        {
#line 554
        tmp___24 = strcmp((char const   *)cp, "direct");
        }
#line 554
        if (0 == tmp___24) {
#line 555
          (fp->direct) ++;
        } else {
          {
#line 556
          tmp___23 = strcmp((char const   *)cp, "dpo");
          }
#line 556
          if (0 == tmp___23) {
#line 557
            (fp->dpo) ++;
          } else {
            {
#line 559
            tmp___22 = strcmp((char const   *)cp, "errblk");
            }
#line 559
            if (0 == tmp___22) {
#line 560
              (fp->errblk) ++;
            } else {
              {
#line 562
              tmp___21 = strcmp((char const   *)cp, "excl");
              }
#line 562
              if (0 == tmp___21) {
#line 563
                (fp->excl) ++;
              } else {
                {
#line 564
                tmp___20 = strcmp((char const   *)cp, "fdatasync");
                }
#line 564
                if (0 == tmp___20) {
#line 565
                  (fp->fdatasync) ++;
                } else {
                  {
#line 566
                  tmp___19 = strcmp((char const   *)cp, "flock");
                  }
#line 566
                  if (0 == tmp___19) {
#line 567
                    (fp->flock) ++;
                  } else {
                    {
#line 568
                    tmp___18 = strcmp((char const   *)cp, "force");
                    }
#line 568
                    if (0 == tmp___18) {
#line 569
                      (fp->force) ++;
                    } else {
                      {
#line 570
                      tmp___17 = strcmp((char const   *)cp, "fsync");
                      }
#line 570
                      if (0 == tmp___17) {
#line 571
                        (fp->fsync) ++;
                      } else {
                        {
#line 572
                        tmp___16 = strcmp((char const   *)cp, "fua_nv");
                        }
#line 572
                        if (0 == tmp___16) {
#line 573
                          (fp->fua_nv) ++;
                        } else {
                          {
#line 574
                          tmp___15 = strcmp((char const   *)cp, "fua");
                          }
#line 574
                          if (0 == tmp___15) {
#line 575
                            (fp->fua) ++;
                          } else {
                            {
#line 576
                            tmp___14 = strcmp((char const   *)cp, "nocache");
                            }
#line 576
                            if (0 == tmp___14) {
#line 577
                              (fp->nocache) ++;
                            } else {
                              {
#line 578
                              tmp___13 = strcmp((char const   *)cp, "norcap");
                              }
#line 578
                              if (0 == tmp___13) {
#line 579
                                (fp->norcap) ++;
                              } else {
                                {
#line 580
                                tmp___12 = strcmp((char const   *)cp, "nowrite");
                                }
#line 580
                                if (0 == tmp___12) {
#line 581
                                  (fp->nowrite) ++;
                                } else {
                                  {
#line 582
                                  tmp___11 = strcmp((char const   *)cp, "null");
                                  }
#line 582
                                  if (! (0 == tmp___11)) {
                                    {
#line 584
                                    tmp___10 = strcmp((char const   *)cp, "pt");
                                    }
#line 584
                                    if (0 == tmp___10) {
#line 585
                                      (fp->pt) ++;
                                    } else {
                                      {
#line 586
                                      tmp___9 = strcmp((char const   *)cp, "resume");
                                      }
#line 586
                                      if (0 == tmp___9) {
#line 587
                                        (fp->resume) ++;
                                      } else {
                                        {
#line 588
                                        tmp___8 = strcmp((char const   *)cp, "self");
                                        }
#line 588
                                        if (0 == tmp___8) {
#line 589
                                          (fp->self) ++;
                                        } else {
                                          {
#line 590
                                          tmp___7 = strcmp((char const   *)cp, "sparing");
                                          }
#line 590
                                          if (0 == tmp___7) {
#line 591
                                            (fp->sparing) ++;
                                          } else {
                                            {
#line 592
                                            tmp___6 = strcmp((char const   *)cp, "sparse");
                                            }
#line 592
                                            if (0 == tmp___6) {
#line 593
                                              (fp->sparse) ++;
                                            } else {
                                              {
#line 594
                                              tmp___5 = strcmp((char const   *)cp,
                                                               "ssync");
                                              }
#line 594
                                              if (0 == tmp___5) {
#line 595
                                                (fp->ssync) ++;
                                              } else {
                                                {
#line 596
                                                tmp___4 = strcmp((char const   *)cp,
                                                                 "strunc");
                                                }
#line 596
                                                if (0 == tmp___4) {
#line 597
                                                  (fp->strunc) ++;
                                                } else {
                                                  {
#line 598
                                                  tmp___3 = strcmp((char const   *)cp,
                                                                   "sync");
                                                  }
#line 598
                                                  if (0 == tmp___3) {
#line 599
                                                    (fp->sync) ++;
                                                  } else {
                                                    {
#line 600
                                                    tmp___1 = strcmp((char const   *)cp,
                                                                     "trim");
                                                    }
#line 600
                                                    if (0 == tmp___1) {
#line 602
                                                      (fp->wsame16) ++;
                                                    } else {
                                                      {
#line 600
                                                      tmp___2 = strcmp((char const   *)cp,
                                                                       "unmap");
                                                      }
#line 600
                                                      if (0 == tmp___2) {
#line 602
                                                        (fp->wsame16) ++;
                                                      } else {
                                                        {
#line 603
                                                        tmp___0 = strcmp((char const   *)cp,
                                                                         "trunc");
                                                        }
#line 603
                                                        if (0 == tmp___0) {
#line 604
                                                          (fp->trunc) ++;
                                                        } else {
                                                          {
#line 606
                                                          fprintf((FILE */* __restrict  */)stderr,
                                                                  (char const   */* __restrict  */)"unrecognised flag: %s\n",
                                                                  cp);
                                                          }
#line 607
                                                          return (1);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 609
    cp = np;
#line 546
    if (! cp) {
#line 546
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  return (0);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cl_sanity_defaults(struct opts_t *optsp ) 
{ 
  int64_t l ;

  {
#line 619
  if (0 == optsp->ibs) {
#line 619
    if (0 == optsp->obs) {
#line 620
      optsp->ibs = 512;
#line 621
      optsp->obs = 512;
#line 622
      if (optsp->inf[0]) {
        {
#line 623
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Assume block size of %d bytes for both input and output\n",
                512);
        }
      }
    } else {
#line 619
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 625
  if (0 == optsp->obs) {
#line 626
    optsp->obs = 512;
#line 627
    if (optsp->ibs != 512) {
#line 627
      if (optsp->outf[0]) {
        {
#line 628
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Neither obs nor bs given so set obs=%d (default block size)\n",
                optsp->obs);
        }
      }
    }
  } else
#line 630
  if (0 == optsp->ibs) {
#line 631
    optsp->ibs = 512;
#line 632
    if (optsp->obs != 512) {
      {
#line 633
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Neither ibs nor bs given so set ibs=%d (default block size)\n",
              optsp->ibs);
      }
    }
  }
#line 636
  ibs_hold = optsp->ibs;
#line 641
  if (0 == optsp->bpt_given) {
#line 642
    if (optsp->ibs < 8) {
#line 643
      optsp->bpt_i = 8192;
    } else
#line 644
    if (optsp->ibs < 64) {
#line 645
      optsp->bpt_i = 1024;
    } else
#line 646
    if (optsp->ibs < 1024) {
#line 647
      optsp->bpt_i = 128;
    } else
#line 648
    if (optsp->ibs < 8192) {
#line 649
      optsp->bpt_i = 16;
    } else
#line 650
    if (optsp->ibs < 31768) {
#line 651
      optsp->bpt_i = 4;
    } else {
#line 653
      optsp->bpt_i = 1;
    }
  }
#line 656
  if (optsp->ibs != optsp->obs) {
#line 656
    if (0 != (optsp->ibs * optsp->bpt_i) % optsp->obs) {
      {
#line 658
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"when \'ibs\' and \'obs\' differ, ((ibs*bpt)/obs) must have no remainder (bpt=%d)\n",
              optsp->bpt_i);
      }
#line 660
      return (1);
    }
  }
#line 662
  if (optsp->skip < 0L) {
    {
#line 663
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"neither skip nor seek can be negative\n");
    }
#line 664
    return (1);
  } else
#line 662
  if (optsp->seek < 0L) {
    {
#line 663
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"neither skip nor seek can be negative\n");
    }
#line 664
    return (1);
  }
#line 666
  if ((optsp->oflagp)->append > 0) {
#line 666
    if (optsp->seek > 0L) {
      {
#line 667
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t use both append and seek switches\n");
      }
#line 668
      return (1);
    }
  }
#line 670
  if (optsp->bpt_i < 1) {
    {
#line 671
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bpt must be greater than 0\n");
    }
#line 672
    return (1);
  }
#line 674
  if ((optsp->iflagp)->append) {
    {
#line 675
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"append flag ignored on input\n");
    }
  }
#line 676
  if ((optsp->iflagp)->sparing) {
    {
#line 677
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sparing flag ignored on input\n");
    }
  }
#line 678
  if ((optsp->iflagp)->ssync) {
    {
#line 679
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ssync flag ignored on input\n");
    }
  }
#line 680
  if ((optsp->oflagp)->trunc) {
#line 681
    if ((optsp->oflagp)->resume) {
#line 682
      (optsp->oflagp)->trunc = 0;
#line 683
      if (verbose) {
        {
#line 684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trunc ignored due to resume flag, otherwise open_of() truncates too early\n");
        }
      }
    } else
#line 686
    if ((optsp->oflagp)->append) {
      {
#line 687
      (optsp->oflagp)->trunc = 0;
#line 688
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trunc ignored due to append flag\n");
      }
    } else
#line 689
    if ((optsp->oflagp)->sparing) {
      {
#line 690
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trunc flag conflicts with sparing\n");
      }
#line 691
      return (1);
    }
  }
#line 694
  if ((optsp->iflagp)->self) {
#line 694
    goto _L___1;
  } else
#line 694
  if ((optsp->oflagp)->self) {
    _L___1: /* CIL Label */ 
#line 695
    if (! (optsp->oflagp)->self) {
#line 696
      ((optsp->oflagp)->self) ++;
    }
#line 697
    if ((optsp->iflagp)->wsame16) {
#line 697
      goto _L___0;
    } else
#line 697
    if ((optsp->oflagp)->wsame16) {
      _L___0: /* CIL Label */ 
#line 698
      if (! (optsp->oflagp)->wsame16) {
#line 699
        ((optsp->oflagp)->wsame16) ++;
      }
#line 700
      if (! (optsp->oflagp)->nowrite) {
#line 701
        ((optsp->oflagp)->nowrite) ++;
      }
    }
#line 703
    if (0 == (int )optsp->outf[0]) {
      {
#line 704
      strcpy((char */* __restrict  */)(optsp->outf), (char const   */* __restrict  */)(optsp->inf));
      }
    }
#line 705
    if (0L == optsp->seek) {
#line 705
      if (optsp->skip > 0L) {
#line 706
        if (optsp->ibs == optsp->obs) {
#line 707
          optsp->seek = optsp->skip;
        } else
#line 708
        if (optsp->obs > 0) {
#line 711
          l = optsp->skip * (int64_t )optsp->ibs;
#line 712
          optsp->seek = l / (int64_t )optsp->obs;
#line 713
          if (optsp->seek * (int64_t )optsp->obs != l) {
            {
#line 714
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"self cannot translate skip to seek properly, try different skip value\n");
            }
#line 716
            return (1);
          }
        }
#line 719
        if (verbose) {
          {
#line 720
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"self: set seek=%ld\n",
                  optsp->seek);
          }
        }
      }
    }
  }
#line 723
  if ((optsp->oflagp)->wsame16) {
#line 724
    (optsp->oflagp)->sparse += 2;
  }
#line 725
  if ((optsp->oflagp)->strunc) {
#line 725
    if (0 == (optsp->oflagp)->sparse) {
#line 726
      ((optsp->oflagp)->sparse) ++;
    }
  }
#line 752
  return (0);
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int process_cl(struct opts_t *optsp , int argc , char **argv ) 
{ 
  char str[1024] ;
  char *key ;
  char *buf ;
  char *cp ;
  int k ;
  int n ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 766
  k = 1;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (k < argc)) {
#line 766
      goto while_break;
    }
#line 767
    if (*(argv + k)) {
      {
#line 768
      strncpy((char */* __restrict  */)(str), (char const   */* __restrict  */)*(argv + k),
              (size_t )1024);
#line 769
      str[1023] = (char )'\000';
      }
    } else {
#line 771
      goto __Cont;
    }
#line 773
    key = str;
#line 773
    buf = key;
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (*buf) {
#line 773
        if (! ((int )*buf != 61)) {
#line 773
          goto while_break___0;
        }
      } else {
#line 773
        goto while_break___0;
      }
#line 774
      buf ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 775
    if (*buf) {
#line 776
      tmp = buf;
#line 776
      buf ++;
#line 776
      *tmp = (char )'\000';
    }
    {
#line 778
    tmp___35 = strcmp((char const   *)key, "bpt");
    }
#line 778
    if (0 == tmp___35) {
      {
#line 779
      cp = strchr((char const   *)buf, ',');
      }
#line 780
      if (cp) {
#line 781
        *cp = (char )'\000';
      }
      {
#line 782
      n = sg_get_num((char const   *)buf);
      }
#line 782
      if (n < 0) {
        {
#line 783
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad BPT argument to \'bpt=\'\n");
        }
#line 784
        return (1);
      }
#line 786
      if (n > 0) {
#line 787
        optsp->bpt_i = n;
#line 788
        optsp->bpt_given = 1;
      }
#line 790
      if (cp) {
        {
#line 791
        n = sg_get_num((char const   *)(cp + 1));
        }
#line 792
        if (n < 0) {
          {
#line 793
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad OBPC argument to \'bpt=\'\n");
          }
#line 794
          return (1);
        }
#line 796
        optsp->obpc = n;
      }
    } else {
      {
#line 798
      tmp___34 = strcmp((char const   *)key, "bs");
      }
#line 798
      if (0 == tmp___34) {
        {
#line 799
        n = sg_get_num((char const   *)buf);
        }
#line 800
        if (n < 0) {
          {
#line 801
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'bs=\'\n");
          }
#line 802
          return (1);
        }
#line 804
        if (optsp->bs_given) {
          {
#line 805
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"second \'bs=\' option given, dangerous\n");
          }
#line 806
          return (1);
        } else {
#line 808
          optsp->bs_given = 1;
        }
#line 809
        if (optsp->ibs_given) {
          {
#line 810
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'bs=\' option cannot be combined with \'ibs=\' or \'obs=\'\n");
          }
#line 812
          return (1);
        } else
#line 809
        if (optsp->obs_given) {
          {
#line 810
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'bs=\' option cannot be combined with \'ibs=\' or \'obs=\'\n");
          }
#line 812
          return (1);
        }
#line 814
        optsp->ibs = n;
#line 815
        optsp->obs = n;
      } else {
        {
#line 816
        tmp___33 = strcmp((char const   *)key, "cbs");
        }
#line 816
        if (0 == tmp___33) {
          {
#line 817
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the cbs= option is ignored\n");
          }
        } else {
          {
#line 818
          tmp___32 = strcmp((char const   *)key, "cdbsz");
          }
#line 818
          if (0 == tmp___32) {
            {
#line 819
            (optsp->iflagp)->cdbsz = sg_get_num((char const   *)buf);
#line 820
            (optsp->oflagp)->cdbsz = (optsp->iflagp)->cdbsz;
#line 821
            optsp->cdbsz_given = 1;
            }
          } else {
            {
#line 822
            tmp___31 = strcmp((char const   *)key, "coe");
            }
#line 822
            if (0 == tmp___31) {
              {
#line 823
              (optsp->iflagp)->coe = sg_get_num((char const   *)buf);
#line 824
              (optsp->oflagp)->coe = (optsp->iflagp)->coe;
              }
            } else {
              {
#line 825
              tmp___30 = strcmp((char const   *)key, "coe_limit");
              }
#line 825
              if (0 == tmp___30) {
                {
#line 826
                coe_limit = sg_get_num((char const   *)buf);
                }
#line 827
                if (-1 == coe_limit) {
                  {
#line 828
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'coe_limit=\'\n");
                  }
#line 829
                  return (1);
                }
              } else {
                {
#line 831
                tmp___29 = strcmp((char const   *)key, "conv");
                }
#line 831
                if (0 == tmp___29) {
                  {
#line 832
                  tmp___0 = process_conv((char const   *)buf, optsp->iflagp, optsp->oflagp);
                  }
#line 832
                  if (tmp___0) {
                    {
#line 833
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'conv=\'\n");
                    }
#line 834
                    return (1);
                  }
                } else {
                  {
#line 836
                  tmp___28 = strcmp((char const   *)key, "count");
                  }
#line 836
                  if (0 == tmp___28) {
                    {
#line 837
                    tmp___1 = strcmp("-1", (char const   *)buf);
                    }
#line 837
                    if (0 != tmp___1) {
                      {
#line 838
                      dd_count = sg_get_llnum((char const   *)buf);
                      }
#line 839
                      if (-1LL == (long long )dd_count) {
                        {
#line 840
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'count=\'\n");
                        }
#line 841
                        return (1);
                      }
                    }
                  } else {
                    {
#line 844
                    tmp___27 = strcmp((char const   *)key, "ibs");
                    }
#line 844
                    if (0 == tmp___27) {
                      {
#line 845
                      n = sg_get_num((char const   *)buf);
                      }
#line 846
                      if (n < 0) {
                        {
#line 847
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'ibs=\'\n");
                        }
#line 848
                        return (1);
                      }
#line 850
                      if (optsp->bs_given) {
                        {
#line 851
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'ibs=\' option cannot be combined with \'bs=\'; try \'obs=\' instead\n");
                        }
#line 853
                        return (1);
                      }
#line 855
                      (optsp->ibs_given) ++;
#line 856
                      optsp->ibs = n;
                    } else {
                      {
#line 857
                      tmp___26 = strcmp((char const   *)key, "if");
                      }
#line 857
                      if (tmp___26 == 0) {
#line 858
                        if (0 != (int )optsp->inf[0]) {
                          {
#line 859
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Second IFILE argument??\n");
                          }
#line 860
                          return (1);
                        } else {
                          {
#line 862
                          strncpy((char */* __restrict  */)(optsp->inf), (char const   */* __restrict  */)buf,
                                  (size_t )512);
                          }
                        }
                      } else {
                        {
#line 863
                        tmp___25 = strcmp((char const   *)key, "iflag");
                        }
#line 863
                        if (0 == tmp___25) {
                          {
#line 864
                          tmp___2 = process_flags((char const   *)buf, optsp->iflagp);
                          }
#line 864
                          if (tmp___2) {
                            {
#line 865
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'iflag=\'\n");
                            }
#line 866
                            return (1);
                          }
                        } else {
                          {
#line 868
                          tmp___24 = strcmp((char const   *)key, "obs");
                          }
#line 868
                          if (0 == tmp___24) {
                            {
#line 869
                            n = sg_get_num((char const   *)buf);
                            }
#line 870
                            if (n < 0) {
                              {
#line 871
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'obs=\'\n");
                              }
#line 872
                              return (1);
                            }
#line 874
                            if (optsp->bs_given) {
                              {
#line 875
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'obs=\' option cannot be combined with \'bs=\'; try \'ibs=\' instead\n");
                              }
#line 877
                              return (1);
                            }
#line 879
                            (optsp->obs_given) ++;
#line 880
                            optsp->obs = n;
                          } else {
                            {
#line 881
                            tmp___23 = strcmp((char const   *)key, "of");
                            }
#line 881
                            if (tmp___23 == 0) {
#line 882
                              if (0 != (int )optsp->outf[0]) {
                                {
#line 883
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Second OFILE argument??\n");
                                }
#line 884
                                return (1);
                              }
                              {
#line 886
                              strncpy((char */* __restrict  */)(optsp->outf), (char const   */* __restrict  */)buf,
                                      (size_t )512);
#line 887
                              (optsp->outf_given) ++;
                              }
                            } else {
                              {
#line 888
                              tmp___22 = strcmp((char const   *)key, "of2");
                              }
#line 888
                              if (tmp___22 == 0) {
#line 889
                                if (0 != (int )optsp->out2f[0]) {
                                  {
#line 890
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Second OFILE2 argument??\n");
                                  }
#line 891
                                  return (1);
                                } else {
                                  {
#line 893
                                  strncpy((char */* __restrict  */)(optsp->out2f),
                                          (char const   */* __restrict  */)buf, (size_t )512);
                                  }
                                }
                              } else {
                                {
#line 894
                                tmp___21 = strcmp((char const   *)key, "oflag");
                                }
#line 894
                                if (0 == tmp___21) {
                                  {
#line 895
                                  tmp___3 = process_flags((char const   *)buf, optsp->oflagp);
                                  }
#line 895
                                  if (tmp___3) {
                                    {
#line 896
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'oflag=\'\n");
                                    }
#line 897
                                    return (1);
                                  }
                                } else {
                                  {
#line 899
                                  tmp___20 = strcmp((char const   *)key, "retries");
                                  }
#line 899
                                  if (0 == tmp___20) {
                                    {
#line 900
                                    (optsp->iflagp)->retries = sg_get_num((char const   *)buf);
#line 901
                                    (optsp->oflagp)->retries = (optsp->iflagp)->retries;
                                    }
#line 902
                                    if (-1 == (optsp->iflagp)->retries) {
                                      {
#line 903
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'retries=\'\n");
                                      }
#line 904
                                      return (1);
                                    }
                                  } else {
                                    {
#line 906
                                    tmp___19 = strcmp((char const   *)key, "seek");
                                    }
#line 906
                                    if (0 == tmp___19) {
                                      {
#line 907
                                      optsp->seek = sg_get_llnum((char const   *)buf);
                                      }
#line 908
                                      if (-1LL == (long long )optsp->seek) {
                                        {
#line 909
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad argument to \'seek=\'\n");
                                        }
#line 910
                                        return (1);
                                      }
                                    } else {
                                      {
#line 912
                                      tmp___18 = strcmp((char const   *)key, "skip");
                                      }
#line 912
                                      if (0 == tmp___18) {
                                        {
#line 913
                                        optsp->skip = sg_get_llnum((char const   *)buf);
                                        }
#line 914
                                        if (-1LL == (long long )optsp->skip) {
                                          {
#line 915
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"bad argument to \'skip=\'\n");
                                          }
#line 916
                                          return (1);
                                        }
                                      } else {
                                        {
#line 918
                                        tmp___17 = strcmp((char const   *)key, "status");
                                        }
#line 918
                                        if (0 == tmp___17) {
                                          {
#line 919
                                          tmp___5 = strncmp((char const   *)buf, "null",
                                                            (size_t )4);
                                          }
#line 919
                                          if (! (0 == tmp___5)) {
                                            {
#line 921
                                            tmp___4 = strncmp((char const   *)buf,
                                                              "noxfer", (size_t )6);
                                            }
#line 921
                                            if (0 == tmp___4) {
#line 922
                                              do_time = 0;
                                            } else {
                                              {
#line 924
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"\'status=\' expects \'noxfer\' or \'null\'\n");
                                              }
#line 925
                                              return (1);
                                            }
                                          }
                                        } else {
                                          {
#line 927
                                          tmp___16 = strncmp((char const   *)key,
                                                             "verb", (size_t )4);
                                          }
#line 927
                                          if (0 == tmp___16) {
                                            {
#line 928
                                            verbose = sg_get_num((char const   *)buf);
                                            }
#line 929
                                            if (-1 == verbose) {
#line 929
                                              if (45 != (int )*(buf + 0)) {
                                                {
#line 930
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"bad argument to \'verbose=\'\n");
                                                }
#line 931
                                                return (1);
                                              }
                                            }
#line 933
                                            if (verbose < 0) {
#line 934
                                              quiet ++;
#line 935
                                              verbose = 0;
                                            }
                                          } else {
                                            {
#line 937
                                            tmp___15 = strncmp((char const   *)key,
                                                               "--verb", (size_t )6);
                                            }
#line 937
                                            if (0 == tmp___15) {
#line 938
                                              verbose ++;
                                            } else {
                                              {
#line 939
                                              tmp___14 = strncmp((char const   *)key,
                                                                 "-vvvv", (size_t )5);
                                              }
#line 939
                                              if (0 == tmp___14) {
#line 940
                                                verbose += 4;
                                              } else {
                                                {
#line 941
                                                tmp___13 = strncmp((char const   *)key,
                                                                   "-vvv", (size_t )4);
                                                }
#line 941
                                                if (0 == tmp___13) {
#line 942
                                                  verbose += 3;
                                                } else {
                                                  {
#line 943
                                                  tmp___12 = strncmp((char const   *)key,
                                                                     "-vv", (size_t )3);
                                                  }
#line 943
                                                  if (0 == tmp___12) {
#line 944
                                                    verbose += 2;
                                                  } else {
                                                    {
#line 945
                                                    tmp___11 = strncmp((char const   *)key,
                                                                       "-v", (size_t )2);
                                                    }
#line 945
                                                    if (0 == tmp___11) {
#line 946
                                                      verbose ++;
                                                    } else {
                                                      {
#line 947
                                                      tmp___8 = strncmp((char const   *)key,
                                                                        "--help",
                                                                        (size_t )7);
                                                      }
#line 947
                                                      if (0 == tmp___8) {
                                                        {
#line 950
                                                        usage();
                                                        }
#line 951
                                                        return (-1);
                                                      } else {
                                                        {
#line 947
                                                        tmp___9 = strncmp((char const   *)key,
                                                                          "-h", (size_t )2);
                                                        }
#line 947
                                                        if (0 == tmp___9) {
                                                          {
#line 950
                                                          usage();
                                                          }
#line 951
                                                          return (-1);
                                                        } else {
                                                          {
#line 947
                                                          tmp___10 = strcmp((char const   *)key,
                                                                            "-?");
                                                          }
#line 947
                                                          if (0 == tmp___10) {
                                                            {
#line 950
                                                            usage();
                                                            }
#line 951
                                                            return (-1);
                                                          } else {
                                                            {
#line 952
                                                            tmp___6 = strncmp((char const   *)key,
                                                                              "--vers",
                                                                              (size_t )6);
                                                            }
#line 952
                                                            if (0 == tmp___6) {
                                                              {
#line 954
                                                              fprintf((FILE */* __restrict  */)stderr,
                                                                      (char const   */* __restrict  */)"%s\n",
                                                                      version_str___0);
                                                              }
#line 955
                                                              return (-1);
                                                            } else {
                                                              {
#line 952
                                                              tmp___7 = strncmp((char const   *)key,
                                                                                "-V",
                                                                                (size_t )2);
                                                              }
#line 952
                                                              if (0 == tmp___7) {
                                                                {
#line 954
                                                                fprintf((FILE */* __restrict  */)stderr,
                                                                        (char const   */* __restrict  */)"%s\n",
                                                                        version_str___0);
                                                                }
#line 955
                                                                return (-1);
                                                              } else {
                                                                {
#line 970
                                                                fprintf((FILE */* __restrict  */)stderr,
                                                                        (char const   */* __restrict  */)"Unrecognized option \'%s\'\n",
                                                                        key);
#line 971
                                                                fprintf((FILE */* __restrict  */)stderr,
                                                                        (char const   */* __restrict  */)"For more information use \'--help\'\n");
                                                                }
#line 972
                                                                return (1);
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 766
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 975
  tmp___36 = cl_sanity_defaults(optsp);
  }
#line 975
  return (tmp___36);
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int bsg_major_checked___0  =    0;
#line 985 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int bsg_major___0  =    0;
#line 989 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void find_bsg_major___0(void) 
{ 
  char const   *proc_devices ;
  FILE *fp ;
  char a[128] ;
  char b[128] ;
  char *cp ;
  int n ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 992
  proc_devices = "/proc/devices";
#line 999
  fp = fopen((char const   */* __restrict  */)proc_devices, (char const   */* __restrict  */)"r");
  }
#line 999
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 1000
    if (verbose) {
      {
#line 1001
      tmp = __errno_location();
#line 1001
      tmp___0 = strerror(*tmp);
#line 1001
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fopen %s failed: %s\n",
              proc_devices, tmp___0);
      }
    }
#line 1003
    return;
  }
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1005
    cp = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)fp);
    }
#line 1005
    if (! cp) {
#line 1005
      goto while_break;
    }
    {
#line 1006
    tmp___1 = sscanf((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"%s",
                     a);
    }
#line 1006
    if (1 == tmp___1) {
      {
#line 1006
      tmp___2 = memcmp((void const   *)(a), (void const   *)"Character", (size_t )9);
      }
#line 1006
      if (0 == tmp___2) {
#line 1008
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1010
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1010
    if (cp) {
      {
#line 1010
      cp = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)fp);
      }
#line 1010
      if (! cp) {
#line 1010
        goto while_break___0;
      }
    } else {
#line 1010
      goto while_break___0;
    }
    {
#line 1011
    tmp___4 = sscanf((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"%d %s",
                     & n, a);
    }
#line 1011
    if (2 == tmp___4) {
      {
#line 1012
      tmp___3 = strcmp("bsg", (char const   *)(a));
      }
#line 1012
      if (0 == tmp___3) {
#line 1013
        bsg_major___0 = n;
#line 1014
        goto while_break___0;
      }
    } else {
#line 1017
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1019
  if (verbose > 5) {
#line 1020
    if (cp) {
      {
#line 1021
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found bsg_major=%d\n",
              bsg_major___0);
      }
    } else {
      {
#line 1023
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found no bsg char device in %s\n",
              proc_devices);
      }
    }
  }
  {
#line 1025
  fclose(fp);
  }
#line 1026
  return;
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int dd_filetype(char const   *filename ) 
{ 
  struct stat st ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 1037
  tmp = strlen(filename);
#line 1037
  len = tmp;
  }
#line 1039
  if (1UL == len) {
#line 1039
    if (46 == (int )*(filename + 0)) {
#line 1040
      return (8);
    }
  }
  {
#line 1041
  tmp___0 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 1041
  if (tmp___0 < 0) {
#line 1042
    return (256);
  }
#line 1043
  if ((st.st_mode & 61440U) == 32768U) {
#line 1046
    return (4);
  } else
#line 1047
  if ((st.st_mode & 61440U) == 8192U) {
    {
#line 1050
    tmp___1 = gnu_dev_major((unsigned long long )st.st_rdev);
    }
#line 1050
    if (1U == tmp___1) {
      {
#line 1050
      tmp___2 = gnu_dev_minor((unsigned long long )st.st_rdev);
      }
#line 1050
      if (3U == tmp___2) {
#line 1052
        return (8);
      }
    }
    {
#line 1053
    tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
    }
#line 1053
    if (21U == tmp___3) {
#line 1054
      return (2);
    }
    {
#line 1055
    tmp___4 = gnu_dev_major((unsigned long long )st.st_rdev);
    }
#line 1055
    if (9U == tmp___4) {
#line 1056
      return (16);
    }
#line 1057
    if (! bsg_major_checked___0) {
      {
#line 1058
      bsg_major_checked___0 = 1;
#line 1059
      find_bsg_major___0();
      }
    }
    {
#line 1061
    tmp___5 = gnu_dev_major((unsigned long long )st.st_rdev);
    }
#line 1061
    if (bsg_major___0 == (int )tmp___5) {
#line 1062
      return (2);
    }
#line 1063
    return (128);
  } else
#line 1085
  if ((st.st_mode & 61440U) == 24576U) {
#line 1086
    return (32);
  } else
#line 1087
  if ((st.st_mode & 61440U) == 4096U) {
#line 1088
    return (64);
  }
#line 1089
  return (1);
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static char *dd_filetype_str(int ft , char *buff , int max_bufflen , char const   *fname ) 
{ 
  int off ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1096
  off = 0;
#line 1098
  if (8 & ft) {
    {
#line 1099
    tmp = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                   (char const   */* __restrict  */)"null device ");
#line 1099
    off += tmp;
    }
  }
#line 1100
  if (2 & ft) {
    {
#line 1101
    tmp___0 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"pass-through [pt] device ");
#line 1101
    off += tmp___0;
    }
  }
#line 1103
  if (32 & ft) {
    {
#line 1104
    tmp___1 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"block device ");
#line 1104
    off += tmp___1;
    }
  }
#line 1105
  if (64 & ft) {
    {
#line 1106
    tmp___2 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"fifo [stdin, stdout, named pipe] ");
#line 1106
    off += tmp___2;
    }
  }
#line 1108
  if (16 & ft) {
    {
#line 1109
    tmp___3 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"SCSI tape device ");
#line 1109
    off += tmp___3;
    }
  }
#line 1110
  if (4 & ft) {
    {
#line 1111
    tmp___4 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"regular file ");
#line 1111
    off += tmp___4;
    }
  }
#line 1112
  if (128 & ft) {
    {
#line 1113
    tmp___5 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"char device ");
#line 1113
    off += tmp___5;
    }
  }
#line 1114
  if (1 & ft) {
    {
#line 1115
    tmp___6 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                       (char const   */* __restrict  */)"other file type ");
#line 1115
    off += tmp___6;
    }
  }
#line 1116
  if (256 & ft) {
#line 1117
    if (fname) {
      {
#line 1118
      tmp___7 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                         (char const   */* __restrict  */)"unable to \'stat\' %s ",
                         fname);
#line 1118
      off += tmp___7;
      }
    } else {
      {
#line 1121
      tmp___8 = snprintf((char */* __restrict  */)(buff + off), (size_t )(max_bufflen - off),
                         (char const   */* __restrict  */)"unable to \'stat\' file ");
#line 1121
      off += tmp___8;
      }
    }
  }
#line 1124
  return (buff);
}
}
#line 1129 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int scsi_read_capacity(int sg_fd , int64_t *num_sect , int *sect_sz ) 
{ 
  int k ;
  int res ;
  unsigned int ui ;
  unsigned char rcBuff[32] ;
  int verb ;
  int64_t ls ;

  {
#line 1137
  if (verbose) {
#line 1137
    verb = verbose - 1;
  } else {
#line 1137
    verb = 0;
  }
  {
#line 1138
  res = sg_ll_readcap_10(sg_fd, 0, 0U, (void *)(rcBuff), 8, 0, verb);
  }
#line 1139
  if (0 != res) {
#line 1140
    return (res);
  }
#line 1142
  if (255 == (int )rcBuff[0]) {
#line 1142
    if (255 == (int )rcBuff[1]) {
#line 1142
      if (255 == (int )rcBuff[2]) {
#line 1142
        if (255 == (int )rcBuff[3]) {
#line 1146
          if (verb) {
            {
#line 1147
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    READ CAPACITY (10) response cannot represent this capacity\n");
            }
          }
          {
#line 1149
          res = sg_ll_readcap_16(sg_fd, 0, (uint64_t )0, (void *)(rcBuff), 32, 0,
                                 verb);
          }
#line 1151
          if (0 != res) {
#line 1152
            return (res);
          }
#line 1153
          k = 0;
#line 1153
          ls = (int64_t )0;
          {
#line 1153
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1153
            if (! (k < 8)) {
#line 1153
              goto while_break;
            }
#line 1154
            ls <<= 8;
#line 1155
            ls |= (long )rcBuff[k];
#line 1153
            k ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 1157
          *num_sect = ls + 1L;
#line 1158
          *sect_sz = ((((int )rcBuff[8] << 24) | ((int )rcBuff[9] << 16)) | ((int )rcBuff[10] << 8)) | (int )rcBuff[11];
        } else {
#line 1161
          ui = (unsigned int )(((((int )rcBuff[0] << 24) | ((int )rcBuff[1] << 16)) | ((int )rcBuff[2] << 8)) | (int )rcBuff[3]);
#line 1164
          *num_sect = (int64_t )ui + 1L;
#line 1165
          *sect_sz = ((((int )rcBuff[4] << 24) | ((int )rcBuff[5] << 16)) | ((int )rcBuff[6] << 8)) | (int )rcBuff[7];
        }
      } else {
#line 1161
        ui = (unsigned int )(((((int )rcBuff[0] << 24) | ((int )rcBuff[1] << 16)) | ((int )rcBuff[2] << 8)) | (int )rcBuff[3]);
#line 1164
        *num_sect = (int64_t )ui + 1L;
#line 1165
        *sect_sz = ((((int )rcBuff[4] << 24) | ((int )rcBuff[5] << 16)) | ((int )rcBuff[6] << 8)) | (int )rcBuff[7];
      }
    } else {
#line 1161
      ui = (unsigned int )(((((int )rcBuff[0] << 24) | ((int )rcBuff[1] << 16)) | ((int )rcBuff[2] << 8)) | (int )rcBuff[3]);
#line 1164
      *num_sect = (int64_t )ui + 1L;
#line 1165
      *sect_sz = ((((int )rcBuff[4] << 24) | ((int )rcBuff[5] << 16)) | ((int )rcBuff[6] << 8)) | (int )rcBuff[7];
    }
  } else {
#line 1161
    ui = (unsigned int )(((((int )rcBuff[0] << 24) | ((int )rcBuff[1] << 16)) | ((int )rcBuff[2] << 8)) | (int )rcBuff[3]);
#line 1164
    *num_sect = (int64_t )ui + 1L;
#line 1165
    *sect_sz = ((((int )rcBuff[4] << 24) | ((int )rcBuff[5] << 16)) | ((int )rcBuff[6] << 8)) | (int )rcBuff[7];
  }
#line 1168
  return (0);
}
}
#line 1178 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int get_blkdev_capacity(struct opts_t *optsp , int which_arg , int64_t *num_sect ,
                               int *sect_sz , int verb ) 
{ 
  int blk_fd ;
  char const   *fname ;
  uint64_t ull ;
  int tmp ;
  int tmp___0 ;

  {
#line 1185
  if (0 == which_arg) {
#line 1185
    blk_fd = optsp->infd;
  } else {
#line 1185
    blk_fd = optsp->outfd;
  }
#line 1186
  if (0 == which_arg) {
#line 1186
    fname = (char const   *)(optsp->inf);
  } else {
#line 1186
    fname = (char const   *)(optsp->outf);
  }
#line 1187
  if (verb > 2) {
    {
#line 1188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"get_blkdev_capacity: for %s\n",
            fname);
    }
  }
  {
#line 1192
  tmp___0 = ioctl(blk_fd, (unsigned long )((unsigned int )(18 << 8) | 104U), sect_sz);
  }
#line 1192
  if (tmp___0 < 0) {
#line 1192
    if (*sect_sz > 0) {
      {
#line 1193
      perror("BLKSSZGET ioctl error");
      }
#line 1194
      return (-1);
    } else {
#line 1192
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1199
    tmp = ioctl(blk_fd, (unsigned long )(((2U << 30) | (unsigned int )(18 << 8)) | 114U) | (sizeof(size_t ) << 16),
                & ull);
    }
#line 1199
    if (tmp < 0) {
      {
#line 1201
      perror("BLKGETSIZE64 ioctl error");
      }
#line 1202
      return (-1);
    }
#line 1204
    *num_sect = (int64_t )ull / (int64_t )*sect_sz;
#line 1205
    if (verb > 5) {
      {
#line 1206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Used Linux BLKGETSIZE64 ioctl\n");
      }
    }
  }
#line 1219
  return (0);
}
}
#line 1297 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int pt_build_scsi_cdb(unsigned char *cdbp , int cdb_sz , unsigned int blocks ,
                             int64_t start_block , int write_true , int fua , int fua_nv ,
                             int dpo ) 
{ 
  int rd_opcode[4] ;
  int wr_opcode[4] ;
  int sz_ind ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1302
  rd_opcode[0] = 8;
#line 1302
  rd_opcode[1] = 40;
#line 1302
  rd_opcode[2] = 168;
#line 1302
  rd_opcode[3] = 136;
#line 1303
  wr_opcode[0] = 10;
#line 1303
  wr_opcode[1] = 42;
#line 1303
  wr_opcode[2] = 170;
#line 1303
  wr_opcode[3] = 138;
#line 1306
  memset((void *)cdbp, 0, (size_t )cdb_sz);
  }
#line 1307
  if (dpo) {
#line 1308
    *(cdbp + 1) = (unsigned char )((int )*(cdbp + 1) | 16);
  }
#line 1309
  if (fua) {
#line 1310
    *(cdbp + 1) = (unsigned char )((int )*(cdbp + 1) | 8);
  }
#line 1311
  if (fua_nv) {
#line 1312
    *(cdbp + 1) = (unsigned char )((int )*(cdbp + 1) | 2);
  }
  {
#line 1315
  if (cdb_sz == 6) {
#line 1315
    goto case_6;
  }
#line 1340
  if (cdb_sz == 10) {
#line 1340
    goto case_10;
  }
#line 1356
  if (cdb_sz == 12) {
#line 1356
    goto case_12;
  }
#line 1369
  if (cdb_sz == 16) {
#line 1369
    goto case_16;
  }
#line 1386
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1316
  sz_ind = 0;
#line 1317
  if (write_true) {
#line 1317
    tmp = wr_opcode[sz_ind];
  } else {
#line 1317
    tmp = rd_opcode[sz_ind];
  }
#line 1317
  *(cdbp + 0) = (unsigned char )tmp;
#line 1320
  *(cdbp + 1) = (unsigned char )((start_block >> 16) & 31L);
#line 1321
  *(cdbp + 2) = (unsigned char )((start_block >> 8) & 255L);
#line 1322
  *(cdbp + 3) = (unsigned char )(start_block & 255L);
#line 1323
  if (256U == blocks) {
#line 1323
    *(cdbp + 4) = (unsigned char)0;
  } else {
#line 1323
    *(cdbp + 4) = (unsigned char )blocks;
  }
#line 1324
  if (blocks > 256U) {
    {
#line 1325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for 6 byte commands, maximum number of blocks is 256\n");
    }
#line 1327
    return (1);
  }
#line 1329
  if (((start_block + (int64_t )blocks) - 1L) & -2097152L) {
    {
#line 1330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for 6 byte commands, can\'t address blocks beyond %d\n",
            2097151);
    }
#line 1332
    return (1);
  }
#line 1334
  if (dpo) {
    {
#line 1335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for 6 byte commands, neither dpo nor fua bits supported\n");
    }
#line 1337
    return (1);
  } else
#line 1334
  if (fua) {
    {
#line 1335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for 6 byte commands, neither dpo nor fua bits supported\n");
    }
#line 1337
    return (1);
  }
#line 1339
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1341
  sz_ind = 1;
#line 1342
  if (write_true) {
#line 1342
    tmp___0 = wr_opcode[sz_ind];
  } else {
#line 1342
    tmp___0 = rd_opcode[sz_ind];
  }
#line 1342
  *(cdbp + 0) = (unsigned char )tmp___0;
#line 1344
  *(cdbp + 2) = (unsigned char )((start_block >> 24) & 255L);
#line 1345
  *(cdbp + 3) = (unsigned char )((start_block >> 16) & 255L);
#line 1346
  *(cdbp + 4) = (unsigned char )((start_block >> 8) & 255L);
#line 1347
  *(cdbp + 5) = (unsigned char )(start_block & 255L);
#line 1348
  *(cdbp + 7) = (unsigned char )((blocks >> 8) & 255U);
#line 1349
  *(cdbp + 8) = (unsigned char )(blocks & 255U);
#line 1350
  if (blocks & 4294901760U) {
    {
#line 1351
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for 10 byte commands, maximum number of blocks is %d\n",
            65535);
    }
#line 1353
    return (1);
  }
#line 1355
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1357
  sz_ind = 2;
#line 1358
  if (write_true) {
#line 1358
    tmp___1 = wr_opcode[sz_ind];
  } else {
#line 1358
    tmp___1 = rd_opcode[sz_ind];
  }
#line 1358
  *(cdbp + 0) = (unsigned char )tmp___1;
#line 1360
  *(cdbp + 2) = (unsigned char )((start_block >> 24) & 255L);
#line 1361
  *(cdbp + 3) = (unsigned char )((start_block >> 16) & 255L);
#line 1362
  *(cdbp + 4) = (unsigned char )((start_block >> 8) & 255L);
#line 1363
  *(cdbp + 5) = (unsigned char )(start_block & 255L);
#line 1364
  *(cdbp + 6) = (unsigned char )((blocks >> 24) & 255U);
#line 1365
  *(cdbp + 7) = (unsigned char )((blocks >> 16) & 255U);
#line 1366
  *(cdbp + 8) = (unsigned char )((blocks >> 8) & 255U);
#line 1367
  *(cdbp + 9) = (unsigned char )(blocks & 255U);
#line 1368
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1370
  sz_ind = 3;
#line 1371
  if (write_true) {
#line 1371
    tmp___2 = wr_opcode[sz_ind];
  } else {
#line 1371
    tmp___2 = rd_opcode[sz_ind];
  }
#line 1371
  *(cdbp + 0) = (unsigned char )tmp___2;
#line 1373
  *(cdbp + 2) = (unsigned char )((start_block >> 56) & 255L);
#line 1374
  *(cdbp + 3) = (unsigned char )((start_block >> 48) & 255L);
#line 1375
  *(cdbp + 4) = (unsigned char )((start_block >> 40) & 255L);
#line 1376
  *(cdbp + 5) = (unsigned char )((start_block >> 32) & 255L);
#line 1377
  *(cdbp + 6) = (unsigned char )((start_block >> 24) & 255L);
#line 1378
  *(cdbp + 7) = (unsigned char )((start_block >> 16) & 255L);
#line 1379
  *(cdbp + 8) = (unsigned char )((start_block >> 8) & 255L);
#line 1380
  *(cdbp + 9) = (unsigned char )(start_block & 255L);
#line 1381
  *(cdbp + 10) = (unsigned char )((blocks >> 24) & 255U);
#line 1382
  *(cdbp + 11) = (unsigned char )((blocks >> 16) & 255U);
#line 1383
  *(cdbp + 12) = (unsigned char )((blocks >> 8) & 255U);
#line 1384
  *(cdbp + 13) = (unsigned char )(blocks & 255U);
#line 1385
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1387
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected cdb size of 6, 10, 12, or 16 but got %d\n",
          cdb_sz);
  }
#line 1389
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 1391
  return (0);
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int pt_low_read(int sg_fd , int in0_out1 , unsigned char *buff , int blocks ,
                       int64_t from_block , int bs , struct flags_t  const  *ifp ,
                       uint64_t *io_addrp ) 
{ 
  unsigned char rdCmd[16] ;
  unsigned char sense_b[32] ;
  int res ;
  int k ;
  int info_valid ;
  int slen ;
  int sense_cat ;
  int ret ;
  int vt ;
  struct sg_pt_base *ptvp ;
  struct sg_pt_base *tmp ;
  int tmp___0 ;
  struct sg_scsi_sense_hdr ssh ;
  int ili ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1410
  if (in0_out1) {
#line 1410
    tmp = of_ptvp;
  } else {
#line 1410
    tmp = if_ptvp;
  }
  {
#line 1410
  ptvp = tmp;
#line 1412
  tmp___0 = pt_build_scsi_cdb(rdCmd, (int )ifp->cdbsz, (unsigned int )blocks, from_block,
                              0, (int )ifp->fua, (int )ifp->fua_nv, (int )ifp->dpo);
  }
#line 1412
  if (tmp___0) {
    {
#line 1414
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad rd cdb build, from_block=%ld, blocks=%d\n",
            from_block, blocks);
    }
#line 1416
    return (1);
  }
#line 1418
  if (verbose > 2) {
    {
#line 1419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    READ cdb: ");
#line 1420
    k = 0;
    }
    {
#line 1420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1420
      if (! (k < (int )ifp->cdbsz)) {
#line 1420
        goto while_break;
      }
      {
#line 1421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )rdCmd[k]);
#line 1420
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1425
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pt_low_read: if_ptvp NULL?\n");
    }
#line 1427
    return (-1);
  }
  {
#line 1429
  clear_scsi_pt_obj(ptvp);
#line 1430
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rdCmd), (int )ifp->cdbsz);
#line 1431
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1432
  set_scsi_pt_data_in(ptvp, buff, bs * blocks);
#line 1434
  set_scsi_pt_flags(ptvp, 16);
  }
#line 1436
  if (verbose) {
#line 1436
    vt = verbose - 1;
  } else {
#line 1436
    vt = 0;
  }
  {
#line 1437
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1437
    res = do_scsi_pt(ptvp, sg_fd, 60000, vt);
    }
#line 1437
    if (res < 0) {
#line 1437
      if (! (-4 == res)) {
#line 1437
        goto while_break___0;
      }
    } else {
#line 1437
      goto while_break___0;
    }
#line 1439
    interrupted_retries ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1441
  if (verbose > 1) {
#line 1441
    vt = verbose - 1;
  } else {
#line 1441
    vt = verbose;
  }
  {
#line 1442
  ret = sg_cmds_process_resp(ptvp, "READ", res, bs * blocks, (unsigned char const   *)(sense_b),
                             0, vt, & sense_cat);
  }
#line 1444
  if (! (-1 == ret)) {
#line 1446
    if (-2 == ret) {
      {
#line 1447
      slen = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 1448
      ret = sense_cat;
      }
      {
#line 1452
      if (sense_cat == 9) {
#line 1452
        goto case_9;
      }
#line 1452
      if (sense_cat == 2) {
#line 1452
        goto case_9;
      }
#line 1456
      if (sense_cat == 11) {
#line 1456
        goto case_11;
      }
#line 1456
      if (sense_cat == 6) {
#line 1456
        goto case_11;
      }
#line 1458
      if (sense_cat == 21) {
#line 1458
        goto case_21;
      }
#line 1468
      if (sense_cat == 3) {
#line 1468
        goto case_3;
      }
#line 1479
      if (sense_cat == 20) {
#line 1479
        goto case_20;
      }
#line 1482
      if (sense_cat == 5) {
#line 1482
        goto case_5;
      }
#line 1504
      goto switch_default;
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1453
      unrecovered_errs ++;
#line 1454
      goto switch_break;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
#line 1457
      goto switch_break;
      case_21: /* CIL Label */ 
      {
#line 1459
      recovered_errs ++;
#line 1460
      info_valid = sg_get_sense_info_fld((unsigned char const   *)(sense_b), slen,
                                         io_addrp);
      }
#line 1461
      if (info_valid) {
        {
#line 1462
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    lba of last recovered error in this READ=0x%lx\n",
                *io_addrp);
        }
      } else {
        {
#line 1465
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Recovered error: [no info] reading from block=0x%lx, num=%d\n",
                from_block, blocks);
        }
      }
#line 1467
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 1469
      unrecovered_errs ++;
#line 1470
      info_valid = sg_get_sense_info_fld((unsigned char const   *)(sense_b), slen,
                                         io_addrp);
      }
#line 1472
      if (info_valid) {
#line 1474
        ret = 18;
      } else
#line 1472
      if (*io_addrp > 0UL) {
#line 1472
        if (5 == (int )ifp->pdt) {
#line 1474
          ret = 18;
        } else
#line 1472
        if (7 == (int )ifp->pdt) {
#line 1474
          ret = 18;
        } else {
          {
#line 1476
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Medium, hardware or blank check error but no lba of failure in sense data\n");
          }
        }
      } else {
        {
#line 1476
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Medium, hardware or blank check error but no lba of failure in sense data\n");
        }
      }
#line 1478
      goto switch_break;
      case_20: /* CIL Label */ 
#line 1480
      ret = 0;
#line 1481
      goto switch_break;
      case_5: /* CIL Label */ 
#line 1483
      if (5 == (int )ifp->pdt) {
        {
#line 1487
        tmp___2 = sg_scsi_normalize_sense((unsigned char const   *)(sense_b), slen,
                                          & ssh);
        }
#line 1487
        if (tmp___2) {
#line 1487
          if (100 == (int )ssh.asc) {
#line 1487
            if (0 == (int )ssh.ascq) {
              {
#line 1489
              tmp___1 = sg_get_sense_filemark_eom_ili((unsigned char const   *)(sense_b),
                                                      slen, (int *)((void *)0), (int *)((void *)0),
                                                      & ili);
              }
#line 1489
              if (tmp___1) {
#line 1489
                if (ili) {
                  {
#line 1491
                  info_valid = sg_get_sense_info_fld((unsigned char const   *)(sense_b),
                                                     slen, io_addrp);
                  }
#line 1493
                  if (*io_addrp > 0UL) {
#line 1494
                    unrecovered_errs ++;
#line 1495
                    ret = 18;
                  } else {
                    {
#line 1497
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MMC READ gave \'illegal mode for this track\' and ILI but no LBA of failure\n");
                    }
                  }
                }
              }
#line 1500
              unrecovered_errs ++;
#line 1501
              ret = 3;
            }
          }
        }
      }
      switch_default: /* CIL Label */ 
#line 1505
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1508
      ret = 0;
    }
  }
#line 1511
  if (18 != ret) {
    {
#line 1512
    tmp___3 = get_scsi_pt_resid((struct sg_pt_base  const  *)ptvp);
#line 1512
    sum_of_resids += tmp___3;
    }
  }
#line 1513
  return (ret);
}
}
#line 1516 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
void zero_coe_limit_count(void) 
{ 


  {
#line 1519
  if (coe_limit > 0) {
#line 1520
    coe_count = 0;
  }
#line 1521
  return;
}
}
#line 1532 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int pt_read(int sg_fd , int in0_out1 , unsigned char *buff , int blocks , int64_t from_block ,
                   int bs , struct flags_t *ifp , int *blks_readp ) 
{ 
  uint64_t io_addr ;
  int64_t lba ;
  int res ;
  int blks ;
  int use_io_addr ;
  int xferred ;
  unsigned char *bp ;
  int retries_tmp ;
  int ret ;
  int may_coe ;
  int tmp ;
  int tmp___0 ;

  {
#line 1541
  ret = 0;
#line 1542
  may_coe = 0;
#line 1544
  retries_tmp = ifp->retries;
#line 1545
  xferred = 0;
#line 1545
  blks = blocks;
#line 1545
  lba = from_block;
#line 1545
  bp = buff;
  {
#line 1545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1545
    if (! (blks > 0)) {
#line 1545
      goto while_break;
    }
    {
#line 1547
    io_addr = (uint64_t )0;
#line 1548
    use_io_addr = 0;
#line 1549
    may_coe = 0;
#line 1550
    res = pt_low_read(sg_fd, in0_out1, bp, blks, lba, bs, (struct flags_t  const  *)ifp,
                      & io_addr);
    }
    {
#line 1552
    if (res == 0) {
#line 1552
      goto case_0;
    }
#line 1557
    if (res == -2) {
#line 1557
      goto case_neg_2;
    }
#line 1559
    if (res == 2) {
#line 1559
      goto case_2;
    }
#line 1562
    if (res == 11) {
#line 1562
      goto case_11;
    }
#line 1570
    if (res == 6) {
#line 1570
      goto case_6;
    }
#line 1578
    if (res == 18) {
#line 1578
      goto case_18;
    }
#line 1591
    if (res == 1) {
#line 1591
      goto case_1;
    }
#line 1595
    if (res == -1) {
#line 1595
      goto case_neg_1;
    }
#line 1598
    if (res == 3) {
#line 1598
      goto case_3;
    }
#line 1606
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1553
    if (blks_readp) {
#line 1554
      *blks_readp = xferred + blks;
    }
    {
#line 1555
    zero_coe_limit_count();
    }
#line 1556
    return (0);
    case_neg_2: /* CIL Label */ 
#line 1558
    return (res);
    case_2: /* CIL Label */ 
    {
#line 1560
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Device (r) not ready\n");
    }
#line 1561
    return (res);
    case_11: /* CIL Label */ 
#line 1563
    max_aborted --;
#line 1563
    if (max_aborted > 0) {
      {
#line 1564
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command, continuing (r)\n");
      }
    } else {
      {
#line 1566
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command, too many (r)\n");
      }
#line 1567
      return (res);
    }
#line 1569
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1571
    max_uas --;
#line 1571
    if (max_uas > 0) {
      {
#line 1572
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention, continuing (r)\n");
      }
    } else {
      {
#line 1574
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention, too many (r)\n");
      }
#line 1575
      return (res);
    }
#line 1577
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1579
    if (retries_tmp > 0) {
      {
#line 1580
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> retrying pt read: starting lba=%ld [0x%lx] blocks=%d\n",
              lba, (uint64_t )lba, blks);
#line 1583
      retries_tmp --;
#line 1584
      num_retries ++;
      }
#line 1585
      if (unrecovered_errs > 0) {
#line 1586
        unrecovered_errs --;
      }
    } else {
#line 1588
      use_io_addr = 1;
    }
#line 1589
    ret = 3;
#line 1590
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1592
    ifp->coe = 0;
#line 1593
    ret = res;
#line 1594
    goto err_out;
    case_neg_1: /* CIL Label */ 
#line 1596
    ret = res;
#line 1597
    goto err_out;
    case_3: /* CIL Label */ 
#line 1599
    may_coe = 1;
#line 1602
    if (0 == retries_tmp) {
      {
#line 1603
      put_range_errblk((uint64_t )lba, blks);
      }
    }
    switch_default: /* CIL Label */ 
#line 1607
    if (retries_tmp > 0) {
      {
#line 1608
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> retrying pt read: starting lba=%ld [0x%lx] blocks=%d\n",
              lba, (uint64_t )lba, blks);
#line 1611
      retries_tmp --;
#line 1612
      num_retries ++;
      }
#line 1613
      if (unrecovered_errs > 0) {
#line 1614
        unrecovered_errs --;
      }
#line 1615
      goto switch_break;
    }
#line 1617
    ret = res;
#line 1618
    goto err_out;
    switch_break: /* CIL Label */ ;
    }
#line 1620
    if (! use_io_addr) {
#line 1621
      goto __Cont;
    }
#line 1622
    if (io_addr < (uint64_t )lba) {
      {
#line 1624
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Unrecovered error lba 0x%lx not in correct range:\n\t[0x%lx,0x%lx]\n",
              io_addr, (uint64_t )lba, (uint64_t )((lba + (int64_t )blks) - 1L));
#line 1628
      may_coe = 1;
      }
#line 1629
      goto err_out;
    } else
#line 1622
    if (io_addr >= (uint64_t )(lba + (int64_t )blks)) {
      {
#line 1624
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Unrecovered error lba 0x%lx not in correct range:\n\t[0x%lx,0x%lx]\n",
              io_addr, (uint64_t )lba, (uint64_t )((lba + (int64_t )blks) - 1L));
#line 1628
      may_coe = 1;
      }
#line 1629
      goto err_out;
    }
#line 1631
    if (highest_unrecovered < 0L) {
#line 1632
      highest_unrecovered = (int64_t )io_addr;
#line 1633
      lowest_unrecovered = (int64_t )io_addr;
    } else {
#line 1635
      if ((int64_t )io_addr < lowest_unrecovered) {
#line 1636
        lowest_unrecovered = (int64_t )io_addr;
      }
#line 1637
      if ((int64_t )io_addr > highest_unrecovered) {
#line 1638
        highest_unrecovered = (int64_t )io_addr;
      }
    }
    {
#line 1641
    put_errblk(io_addr);
    }
#line 1643
    if (ifp->coe) {
#line 1644
      in_partial ++;
#line 1645
      in_full --;
    }
#line 1647
    blks = (int )(io_addr - (uint64_t )lba);
#line 1648
    if (blks > 0) {
#line 1649
      if (verbose) {
        {
#line 1650
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  partial re-read of %d blocks prior to medium error\n",
                blks);
        }
      }
      {
#line 1652
      res = pt_low_read(sg_fd, in0_out1, bp, blks, lba, bs, (struct flags_t  const  *)ifp,
                        & io_addr);
      }
      {
#line 1655
      if (res == 0) {
#line 1655
        goto case_0___0;
      }
#line 1657
      if (res == -1) {
#line 1657
        goto case_neg_1___0;
      }
#line 1661
      if (res == -2) {
#line 1661
        goto case_neg_2___0;
      }
#line 1664
      if (res == 2) {
#line 1664
        goto case_2___0;
      }
#line 1667
      if (res == 6) {
#line 1667
        goto case_6___0;
      }
#line 1670
      if (res == 11) {
#line 1670
        goto case_11___0;
      }
#line 1674
      if (res == 3) {
#line 1674
        goto case_3___0;
      }
#line 1674
      if (res == 18) {
#line 1674
        goto case_3___0;
      }
#line 1678
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
#line 1656
      goto switch_break___0;
      case_neg_1___0: /* CIL Label */ 
#line 1658
      ifp->coe = 0;
#line 1659
      ret = res;
#line 1660
      goto err_out;
      case_neg_2___0: /* CIL Label */ 
      {
#line 1662
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ENOMEM again, unexpected (r)\n");
      }
#line 1663
      return (-1);
      case_2___0: /* CIL Label */ 
      {
#line 1665
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"device (r) not ready\n");
      }
#line 1666
      return (res);
      case_6___0: /* CIL Label */ 
      {
#line 1668
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention, unexpected (r)\n");
      }
#line 1669
      return (res);
      case_11___0: /* CIL Label */ 
      {
#line 1671
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command, unexpected (r)\n");
      }
#line 1672
      return (res);
      case_3___0: /* CIL Label */ 
      case_18___0: /* CIL Label */ 
#line 1675
      ret = 3;
#line 1676
      goto err_out;
      switch_default___0: /* CIL Label */ 
      {
#line 1679
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> unexpected result=%d from pt_low_read() 2\n",
              res);
#line 1681
      ret = res;
      }
#line 1682
      goto err_out;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1685
    xferred += blks;
#line 1686
    if (0 == ifp->coe) {
#line 1688
      if (blks_readp) {
#line 1689
        *blks_readp = xferred;
      }
#line 1690
      return (ret);
    }
    {
#line 1692
    bp += blks * bs;
#line 1693
    lba += (int64_t )blks;
#line 1694
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> unrecovered read error at blk=%ld, substitute zeros\n",
            lba);
#line 1696
    memset((void *)bp, 0, (size_t )bs);
#line 1697
    xferred ++;
#line 1698
    bp += bs;
#line 1699
    lba ++;
    }
#line 1700
    if (coe_limit > 0) {
#line 1700
      coe_count ++;
#line 1700
      if (coe_count > coe_limit) {
#line 1701
        if (blks_readp) {
#line 1702
          *blks_readp = xferred + blks;
        }
        {
#line 1703
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> coe_limit on consecutive reads exceeded\n");
        }
#line 1704
        return (3);
      }
    }
#line 1706
    retries_tmp = ifp->retries;
    __Cont: /* CIL Label */ 
#line 1545
    blks = blocks - xferred;
  }
  while_break: /* CIL Label */ ;
  }
#line 1708
  if (blks_readp) {
#line 1709
    *blks_readp = xferred;
  }
#line 1710
  return (0);
  err_out: 
#line 1713
  if (ifp->coe) {
    {
#line 1714
    memset((void *)bp, 0, (size_t )(bs * blks));
#line 1715
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> unable to read at blk=%ld for %d bytes, use zeros\n",
            lba, bs * blks);
    }
#line 1717
    if (blks > 1) {
      {
#line 1718
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>   try reducing bpt to limit number of zeros written near bad block(s)\n");
      }
    }
#line 1721
    if (blks_readp) {
#line 1722
      *blks_readp = xferred + blks;
    }
#line 1723
    if (coe_limit > 0) {
#line 1723
      coe_count ++;
#line 1723
      if (coe_count > coe_limit) {
        {
#line 1724
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> coe_limit on consecutive reads exceeded\n");
        }
#line 1725
        return (ret);
      }
    }
#line 1727
    if (may_coe) {
#line 1727
      tmp = 0;
    } else {
#line 1727
      tmp = ret;
    }
#line 1727
    return (tmp);
  } else {
#line 1729
    if (ret) {
#line 1729
      tmp___0 = ret;
    } else {
#line 1729
      tmp___0 = -1;
    }
#line 1729
    return (tmp___0);
  }
}
}
#line 1738 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int pt_low_write(int sg_fd , unsigned char *buff , int blocks , int64_t to_block ,
                        int bs , struct flags_t  const  *ofp ) 
{ 
  unsigned char wrCmd[16] ;
  unsigned char sense_b[32] ;
  int res ;
  int k ;
  int info_valid ;
  int ret ;
  int sense_cat ;
  int slen ;
  int vt ;
  uint64_t io_addr ;
  struct sg_pt_base *ptvp ;
  int tmp ;

  {
  {
#line 1745
  io_addr = (uint64_t )0;
#line 1746
  ptvp = of_ptvp;
#line 1748
  tmp = pt_build_scsi_cdb(wrCmd, (int )ofp->cdbsz, (unsigned int )blocks, to_block,
                          1, (int )ofp->fua, (int )ofp->fua_nv, (int )ofp->dpo);
  }
#line 1748
  if (tmp) {
    {
#line 1750
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad wr cdb build, to_block=%ld, blocks=%d\n",
            to_block, blocks);
    }
#line 1752
    return (1);
  }
#line 1754
  if (verbose > 2) {
    {
#line 1755
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    WRITE cdb: ");
#line 1756
    k = 0;
    }
    {
#line 1756
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1756
      if (! (k < (int )ofp->cdbsz)) {
#line 1756
        goto while_break;
      }
      {
#line 1757
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )wrCmd[k]);
#line 1756
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1758
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 1761
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1762
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pt_low_write: of_ptvp NULL?\n");
    }
#line 1763
    return (-1);
  }
  {
#line 1765
  clear_scsi_pt_obj(ptvp);
#line 1766
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(wrCmd), (int )ofp->cdbsz);
#line 1767
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1768
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)buff, bs * blocks);
  }
#line 1769
  if (verbose) {
#line 1769
    vt = verbose - 1;
  } else {
#line 1769
    vt = 0;
  }
  {
#line 1770
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1770
    res = do_scsi_pt(ptvp, sg_fd, 60000, vt);
    }
#line 1770
    if (res < 0) {
#line 1770
      if (! (-4 == res)) {
#line 1770
        goto while_break___0;
      }
    } else {
#line 1770
      goto while_break___0;
    }
#line 1772
    interrupted_retries ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1774
  if (verbose > 1) {
#line 1774
    vt = verbose - 1;
  } else {
#line 1774
    vt = verbose;
  }
  {
#line 1775
  ret = sg_cmds_process_resp(ptvp, "WRITE", res, bs * blocks, (unsigned char const   *)(sense_b),
                             0, vt, & sense_cat);
  }
#line 1777
  if (! (-1 == ret)) {
#line 1779
    if (-2 == ret) {
      {
#line 1780
      slen = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 1781
      ret = sense_cat;
      }
      {
#line 1784
      if (sense_cat == 21) {
#line 1784
        goto case_21;
      }
#line 1795
      if (sense_cat == 6) {
#line 1795
        goto case_6;
      }
#line 1795
      if (sense_cat == 11) {
#line 1795
        goto case_6;
      }
#line 1797
      if (sense_cat == 2) {
#line 1797
        goto case_2;
      }
#line 1801
      goto switch_default;
      case_21: /* CIL Label */ 
      {
#line 1785
      wr_recovered_errs ++;
#line 1786
      info_valid = sg_get_sense_info_fld((unsigned char const   *)(sense_b), slen,
                                         & io_addr);
      }
#line 1787
      if (info_valid) {
        {
#line 1788
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    lba of last recovered error in this WRITE=0x%lx\n",
                io_addr);
        }
      } else {
        {
#line 1791
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Recovered error: [no info] writing to block=0x%lx, num=%d\n",
                to_block, blocks);
        }
      }
#line 1793
      goto switch_break;
      case_6: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 1796
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1798
      wr_unrecovered_errs ++;
#line 1799
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1802
      wr_unrecovered_errs ++;
#line 1803
      if (ofp->coe) {
        {
#line 1804
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> ignored errors for out blk=%ld for %d bytes\n",
                to_block, bs * blocks);
#line 1806
        ret = 0;
        }
      }
#line 1808
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1811
      ret = 0;
    }
  }
#line 1813
  return (ret);
}
}
#line 1822 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int pt_write(int sg_fd , unsigned char *buff , int blocks , int64_t to_block ,
                    int bs , struct flags_t *ofp ) 
{ 
  int retries_tmp ;
  int first ;
  int ret ;

  {
#line 1827
  first = 1;
#line 1828
  ret = 0;
#line 1830
  retries_tmp = ofp->retries;
  {
#line 1831
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1832
    ret = pt_low_write(sg_fd, buff, blocks, to_block, bs, (struct flags_t  const  *)ofp);
    }
#line 1833
    if (0 == ret) {
#line 1834
      goto while_break;
    }
#line 1835
    if (2 == ret) {
#line 1837
      goto while_break;
    } else
#line 1835
    if (1 == ret) {
#line 1837
      goto while_break;
    } else
#line 1838
    if (6 == ret) {
#line 1838
      if (first) {
#line 1839
        max_uas --;
#line 1839
        if (max_uas > 0) {
          {
#line 1840
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention, continuing (w)\n");
          }
        } else {
          {
#line 1842
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention, too many (w)\n");
          }
#line 1843
          goto while_break;
        }
      } else {
#line 1838
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1845
    if (11 == ret) {
#line 1845
      if (first) {
#line 1846
        max_aborted --;
#line 1846
        if (max_aborted > 0) {
          {
#line 1847
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command, continuing (w)\n");
          }
        } else {
          {
#line 1849
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command, too many (w)\n");
          }
#line 1850
          goto while_break;
        }
      } else {
#line 1845
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1852
    if (ret < 0) {
#line 1853
      goto while_break;
    } else
#line 1854
    if (retries_tmp > 0) {
      {
#line 1855
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> retrying pt write: starting lba=%ld [0x%lx] blocks=%d\n",
              to_block, (uint64_t )to_block, blocks);
#line 1858
      retries_tmp --;
#line 1859
      num_retries ++;
      }
#line 1860
      if (wr_unrecovered_errs > 0) {
#line 1861
        wr_unrecovered_errs --;
      }
    } else {
#line 1863
      goto while_break;
    }
#line 1864
    first = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1866
  return (ret);
}
}
#line 1874 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int pt_write_same16(int sg_fd , int in0_out1 , unsigned char *buff , int bs ,
                           int blocks , int64_t start_block ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  int vt ;
  uint64_t llba ;
  uint32_t unum ;
  unsigned char wsCmdBlk[16] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  struct sg_pt_base *tmp ;
  int valid ;
  int slen ;
  uint64_t ull ;

  {
#line 1883
  if (in0_out1) {
#line 1883
    tmp = of_ptvp;
  } else {
#line 1883
    tmp = if_ptvp;
  }
  {
#line 1883
  ptvp = tmp;
#line 1885
  memset((void *)(wsCmdBlk), 0, sizeof(wsCmdBlk));
#line 1886
  wsCmdBlk[0] = (unsigned char)147;
#line 1888
  wsCmdBlk[1] = (unsigned char)8;
#line 1889
  llba = (uint64_t )start_block;
#line 1890
  k = 7;
  }
  {
#line 1890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1890
    if (! (k >= 0)) {
#line 1890
      goto while_break;
    }
#line 1891
    wsCmdBlk[2 + k] = (unsigned char )(llba & 255UL);
#line 1892
    llba >>= 8;
#line 1890
    k --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1894
  unum = (uint32_t )blocks;
#line 1895
  k = 3;
  {
#line 1895
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1895
    if (! (k >= 0)) {
#line 1895
      goto while_break___0;
    }
#line 1896
    wsCmdBlk[10 + k] = (unsigned char )(unum & 255U);
#line 1897
    unum >>= 8;
#line 1895
    k --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1899
  if (verbose > 2) {
    {
#line 1900
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    WRITE SAME(16) cdb: ");
#line 1901
    k = 0;
    }
    {
#line 1901
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1901
      if (! (k < (int )sizeof(wsCmdBlk))) {
#line 1901
        goto while_break___1;
      }
      {
#line 1902
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x ",
              (int )wsCmdBlk[k]);
#line 1901
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1903
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 1904
    if (verbose > 4) {
      {
#line 1905
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Data-out buffer length=%d\n",
              bs);
      }
    }
  }
#line 1909
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1910
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pt_write_same16: ptvp NULL?\n");
    }
#line 1911
    return (-1);
  }
  {
#line 1913
  clear_scsi_pt_obj(ptvp);
#line 1914
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(wsCmdBlk), (int )sizeof(wsCmdBlk));
#line 1915
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1916
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)buff, bs);
  }
#line 1917
  if (verbose > 1) {
#line 1917
    vt = verbose - 1;
  } else {
#line 1917
    vt = 0;
  }
  {
#line 1918
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1918
    res = do_scsi_pt(ptvp, sg_fd, 180000, vt);
    }
#line 1918
    if (res < 0) {
#line 1918
      if (! (-4 == res)) {
#line 1918
        goto while_break___2;
      }
    } else {
#line 1918
      goto while_break___2;
    }
#line 1920
    interrupted_retries ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1921
  ret = sg_cmds_process_resp(ptvp, "Write same(16)", res, 0, (unsigned char const   *)(sense_b),
                             1, vt, & sense_cat);
  }
#line 1923
  if (! (-1 == ret)) {
#line 1925
    if (-2 == ret) {
      {
#line 1931
      if (sense_cat == 11) {
#line 1931
        goto case_11;
      }
#line 1931
      if (sense_cat == 5) {
#line 1931
        goto case_11;
      }
#line 1931
      if (sense_cat == 9) {
#line 1931
        goto case_11;
      }
#line 1931
      if (sense_cat == 6) {
#line 1931
        goto case_11;
      }
#line 1931
      if (sense_cat == 2) {
#line 1931
        goto case_11;
      }
#line 1935
      if (sense_cat == 20) {
#line 1935
        goto case_20;
      }
#line 1935
      if (sense_cat == 21) {
#line 1935
        goto case_20;
      }
#line 1938
      if (sense_cat == 3) {
#line 1938
        goto case_3;
      }
#line 1951
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1932
      ret = sense_cat;
#line 1933
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1936
      ret = 0;
#line 1937
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 1941
      ull = (uint64_t )0;
#line 1943
      slen = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 1944
      valid = sg_get_sense_info_fld((unsigned char const   *)(sense_b), slen, & ull);
      }
#line 1945
      if (valid) {
        {
#line 1946
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Medium or hardware error starting at lba=%lu [0x%lx]\n",
                ull, ull);
        }
      }
#line 1949
      ret = sense_cat;
#line 1950
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1952
      ret = -1;
#line 1953
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1956
      ret = 0;
    }
  }
#line 1958
  return (ret);
}
}
#line 1963 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void print_blk_sizes(char const   *fname , char const   *access_typ , int64_t num_sect ,
                            int sect_sz ) 
{ 
  int mb ;
  int gb ;
  size_t len ;
  int64_t n ;
  char b[32] ;
  char dec[4] ;
  char const   *tmp ;

  {
#line 1973
  mb = 0;
#line 1974
  if (num_sect > 0L) {
#line 1974
    if (sect_sz > 0) {
#line 1975
      n = num_sect * (int64_t )sect_sz;
#line 1976
      mb = (int )(n / 1000000L);
    }
  }
#line 1979
  if (mb > 999999) {
    {
#line 1980
    gb = mb / 1000;
#line 1981
    snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%d",
             gb);
#line 1982
    len = strlen((char const   *)(b));
#line 1983
    dec[0] = b[len - 3UL];
#line 1984
    dec[1] = b[len - 2UL];
#line 1985
    dec[2] = (char )'\000';
#line 1986
    b[len - 3UL] = (char )'\000';
#line 1987
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s [%s]: blocks=%ld [0x%lx], _bs=%d, %s.%s TB\n",
            fname, access_typ, num_sect, num_sect, sect_sz, b, dec);
    }
  } else
#line 1990
  if (mb > 99999) {
    {
#line 1991
    gb = mb / 1000;
#line 1992
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s [%s]: blocks=%ld [0x%lx], _bs=%d, %d GB\n",
            fname, access_typ, num_sect, num_sect, sect_sz, gb);
    }
  } else
#line 1995
  if (mb > 999) {
    {
#line 1996
    snprintf((char */* __restrict  */)(b), sizeof(b), (char const   */* __restrict  */)"%d",
             mb);
#line 1997
    len = strlen((char const   *)(b));
#line 1998
    dec[0] = b[len - 3UL];
#line 1999
    dec[1] = b[len - 2UL];
#line 2000
    dec[2] = (char )'\000';
#line 2001
    b[len - 3UL] = (char )'\000';
#line 2002
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s [%s]: blocks=%ld [0x%lx], _bs=%d, %s.%s GB\n",
            fname, access_typ, num_sect, num_sect, sect_sz, b, dec);
    }
  } else
#line 2005
  if (mb > 0) {
#line 2006
    if (mb < 10) {
#line 2006
      tmp = " approx";
    } else {
#line 2006
      tmp = "";
    }
    {
#line 2006
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s [%s]: blocks=%ld [0x%lx], _bs=%d, %d MB%s\n",
            fname, access_typ, num_sect, num_sect, sect_sz, mb, tmp);
    }
  } else {
    {
#line 2010
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s [%s]: blocks=%ld [0x%lx], _bs=%d\n",
            fname, access_typ, num_sect, num_sect, sect_sz);
    }
  }
#line 2013
  return;
}
}
#line 2022 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void calc_duration_throughput(char const   *leadin , int contin ) 
{ 
  struct timespec end_tm ;
  struct timespec res_tm ;
  double a ;
  double b ;
  double r ;
  int secs ;
  int h ;
  int m ;
  int64_t blks ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 2031
  if (start_tm_valid) {
#line 2031
    if (start_tm.tv_sec) {
#line 2031
      goto _L;
    } else
#line 2031
    if (start_tm.tv_nsec) {
      _L: /* CIL Label */ 
      {
#line 2032
      blks = in_full;
#line 2033
      clock_gettime(1, & end_tm);
#line 2034
      res_tm.tv_sec = end_tm.tv_sec - start_tm.tv_sec;
#line 2035
      res_tm.tv_nsec = end_tm.tv_nsec - start_tm.tv_nsec;
      }
#line 2036
      if (res_tm.tv_nsec < 0L) {
#line 2037
        (res_tm.tv_sec) --;
#line 2038
        res_tm.tv_nsec += 1000000000L;
      }
#line 2040
      a = (double )res_tm.tv_sec;
#line 2041
      a += 0.000001 * (double )(res_tm.tv_nsec / 1000L);
#line 2042
      b = (double )ibs_hold * (double )blks;
#line 2043
      if (contin) {
#line 2043
        tmp = " so far";
      } else {
#line 2043
        tmp = "";
      }
#line 2043
      if (read1_or_transfer) {
#line 2043
        tmp___0 = "read";
      } else {
#line 2043
        tmp___0 = "transfer";
      }
      {
#line 2043
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%stime to %s data%s: %d.%06d secs",
              leadin, tmp___0, tmp, (int )res_tm.tv_sec, (int )(res_tm.tv_nsec / 1000L));
#line 2047
      r = 0.0;
      }
#line 2048
      if (a > 0.00001) {
#line 2048
        if (b > (double )511) {
          {
#line 2049
          r = b / (a * 1000000.0);
#line 2050
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" at %.2f MB/sec\n",
                  r);
          }
        } else {
          {
#line 2052
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 2052
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 2053
      if (contin) {
#line 2053
        if (! reading_fifo) {
#line 2053
          if (r > 0.01) {
#line 2053
            if (dd_count > 100L) {
#line 2055
              secs = (int )(((double )ibs_hold * (double )dd_count) / (r * (double )1000000));
#line 2056
              if (secs > 10) {
#line 2057
                h = secs / 3600;
#line 2058
                secs -= h * 3600;
#line 2059
                m = secs / 60;
#line 2060
                secs -= m * 60;
#line 2061
                if (h > 0) {
                  {
#line 2062
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sestimated time remaining: %d:%02d:%02d\n",
                          leadin, h, m, secs);
                  }
                } else {
                  {
#line 2065
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%sestimated time remaining: %d:%02d\n",
                          leadin, m, secs);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2119
  return;
}
}
#line 2124 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int open_if(struct opts_t *optsp , int verbose___0 ) 
{ 
  int flags ;
  int fl ;
  int verb ;
  int fd ;
  char ebuff[512] ;
  struct sg_simple_inquiry_resp sir ;
  struct flags_t *ifp ;
  char const   *inf ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int rt ;
  int res ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 2128
  fd = -15;
#line 2131
  ifp = optsp->iflagp;
#line 2132
  inf = (char const   *)(optsp->inf);
#line 2134
  if (verbose___0) {
#line 2134
    verb = verbose___0 - 1;
  } else {
#line 2134
    verb = 0;
  }
  {
#line 2135
  optsp->in_type = dd_filetype(inf);
  }
#line 2136
  if (256 & optsp->in_type) {
    {
#line 2137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to access %s\n",
            inf);
    }
#line 2138
    goto file_err;
  } else
#line 2139
  if (33 & optsp->in_type) {
#line 2139
    if (ifp->pt) {
#line 2140
      optsp->in_type |= 2;
    }
  }
#line 2141
  if (verbose___0) {
    {
#line 2142
    tmp = dd_filetype_str(optsp->in_type, ebuff, 512, inf);
#line 2142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> Input file type: %s\n",
            tmp);
    }
  }
#line 2144
  if (64 & optsp->in_type) {
#line 2145
    reading_fifo ++;
  } else
#line 2144
  if (128 & optsp->in_type) {
#line 2145
    reading_fifo ++;
  }
#line 2147
  if (16 & optsp->in_type) {
    {
#line 2148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to use scsi tape device %s\n",
            inf);
    }
#line 2149
    goto file_err;
  } else
#line 2150
  if (2 & optsp->in_type) {
#line 2151
    flags = 2048;
#line 2152
    if (ifp->direct) {
#line 2153
      flags |= 16384;
    }
#line 2154
    if (ifp->excl) {
#line 2155
      flags |= 128;
    }
#line 2156
    if (ifp->sync) {
#line 2157
      flags |= 1052672;
    }
    {
#line 2158
    fl = 2;
#line 2159
    fd = scsi_pt_open_flags(inf, fl | flags, verbose___0);
    }
#line 2159
    if (fd < 0) {
      {
#line 2160
      fl = 0;
#line 2161
      fd = scsi_pt_open_flags(inf, fl | flags, verbose___0);
      }
#line 2161
      if (fd < 0) {
        {
#line 2162
        tmp___0 = safe_strerror(- fd);
#line 2162
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open %s for pt reading: %s\n",
                inf, tmp___0);
        }
#line 2164
        goto file_err;
      }
    }
    {
#line 2167
    tmp___1 = sg_simple_inquiry(fd, & sir, 0, verb);
    }
#line 2167
    if (tmp___1) {
      {
#line 2168
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INQUIRY failed on %s\n",
              inf);
      }
#line 2169
      goto other_err;
    }
#line 2171
    ifp->pdt = (int )sir.peripheral_type;
#line 2172
    if (verbose___0) {
      {
#line 2173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s: %.8s  %.16s  %.4s  [pdt=%d]\n",
              inf, sir.vendor, sir.product, sir.revision, ifp->pdt);
      }
    }
  } else {
#line 2184
    flags = 0;
#line 2185
    if (ifp->direct) {
#line 2186
      flags |= 16384;
    }
#line 2187
    if (ifp->excl) {
#line 2188
      flags |= 128;
    }
#line 2189
    if (ifp->sync) {
#line 2190
      flags |= 1052672;
    }
    {
#line 2191
    fd = open(inf, flags);
    }
#line 2192
    if (fd < 0) {
      {
#line 2193
      tmp___2 = __errno_location();
#line 2193
      tmp___3 = safe_strerror(*tmp___2);
#line 2193
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open %s for reading: %s\n",
              inf, tmp___3);
      }
#line 2195
      goto file_err;
    } else {
      {
#line 2197
      tmp___4 = sg_set_binary_mode(fd);
      }
#line 2197
      if (tmp___4 < 0) {
        {
#line 2198
        perror("sg_set_binary_mode");
        }
      }
#line 2199
      if (verbose___0) {
        {
#line 2200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        open %s, flags=0x%x\n",
                inf, flags);
        }
      }
#line 2203
      if (ifp->nocache) {
        {
#line 2206
        rt = posix_fadvise(fd, (__off64_t )0, (__off64_t )0, 2);
        }
#line 2207
        if (rt) {
          {
#line 2208
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"open_if: posix_fadvise(SEQUENTIAL), err=%d\n",
                  rt);
          }
        }
      }
    }
  }
#line 2215
  if (ifp->flock) {
    {
#line 2218
    res = flock(fd, 6);
    }
#line 2219
    if (res < 0) {
      {
#line 2220
      close(fd);
#line 2221
      tmp___5 = __errno_location();
#line 2221
      tmp___6 = safe_strerror(*tmp___5);
#line 2221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"flock(LOCK_EX | LOCK_NB) on %s failed: %s\n",
              inf, tmp___6);
      }
#line 2223
      return (-90);
    }
  }
#line 2227
  return (fd);
  file_err: 
#line 2230
  return (-15);
  other_err: 
#line 2232
  return (-99);
}
}
#line 2239 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int open_of(struct opts_t *optsp , int verbose___0 ) 
{ 
  int flags ;
  int verb ;
  int fd ;
  int outf_exists ;
  char ebuff[512] ;
  struct sg_simple_inquiry_resp sir ;
  struct stat st ;
  struct flags_t *ofp ;
  char const   *outf ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int needs_ftruncate ;
  int64_t offset ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int res ;
  int *tmp___10 ;
  char *tmp___11 ;

  {
#line 2243
  fd = -15;
#line 2244
  outf_exists = 0;
#line 2248
  ofp = optsp->oflagp;
#line 2249
  outf = (char const   *)(optsp->outf);
#line 2251
  if (verbose___0) {
#line 2251
    verb = verbose___0 - 1;
  } else {
#line 2251
    verb = 0;
  }
  {
#line 2252
  optsp->out_type = dd_filetype(outf);
  }
#line 2253
  if (33 & optsp->out_type) {
#line 2253
    if (ofp->pt) {
#line 2254
      optsp->out_type |= 2;
    }
  }
#line 2255
  out_type_hold = optsp->out_type;
#line 2256
  if (verbose___0) {
    {
#line 2257
    tmp = dd_filetype_str(optsp->out_type, ebuff, 512, outf);
#line 2257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> Output file type: %s\n",
            tmp);
    }
  }
#line 2260
  if (16 & optsp->out_type) {
    {
#line 2261
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to use scsi tape device %s\n",
            outf);
    }
#line 2262
    goto file_err;
  } else
#line 2263
  if (2 & optsp->out_type) {
#line 2264
    flags = 2050;
#line 2265
    if (ofp->direct) {
#line 2266
      flags |= 16384;
    }
#line 2267
    if (ofp->excl) {
#line 2268
      flags |= 128;
    }
#line 2269
    if (ofp->sync) {
#line 2270
      flags |= 1052672;
    }
    {
#line 2271
    fd = scsi_pt_open_flags(outf, flags, verbose___0);
    }
#line 2271
    if (fd < 0) {
      {
#line 2272
      tmp___0 = safe_strerror(- fd);
#line 2272
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open %s for pt writing: %s\n",
              outf, tmp___0);
      }
#line 2274
      goto file_err;
    }
    {
#line 2276
    tmp___1 = sg_simple_inquiry(fd, & sir, 0, verb);
    }
#line 2276
    if (tmp___1) {
      {
#line 2277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INQUIRY failed on %s\n",
              outf);
      }
#line 2278
      goto other_err;
    }
#line 2280
    ofp->pdt = (int )sir.peripheral_type;
#line 2281
    if (verbose___0) {
      {
#line 2282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s: %.8s  %.16s  %.4s  [pdt=%d]\n",
              outf, sir.vendor, sir.product, sir.revision, ofp->pdt);
      }
    }
  } else
#line 2284
  if (8 & optsp->out_type) {
#line 2285
    fd = -1;
  } else {
    {
#line 2295
    needs_ftruncate = 0;
#line 2296
    offset = (int64_t )0;
#line 2298
    memset((void *)(& st), 0, sizeof(st));
#line 2299
    tmp___2 = stat((char const   */* __restrict  */)outf, (struct stat */* __restrict  */)(& st));
    }
#line 2299
    if (0 == tmp___2) {
#line 2300
      outf_exists = 1;
    }
#line 2301
    if (ofp->sparing) {
#line 2301
      flags = 2;
    } else {
#line 2301
      flags = 1;
    }
#line 2302
    if (0 == outf_exists) {
#line 2303
      flags |= 64;
    }
#line 2304
    if (ofp->direct) {
#line 2305
      flags |= 16384;
    }
#line 2306
    if (ofp->excl) {
#line 2307
      flags |= 128;
    }
#line 2308
    if (ofp->sync) {
#line 2309
      flags |= 1052672;
    }
#line 2310
    if (ofp->append) {
#line 2311
      flags |= 1024;
    }
#line 2312
    if (4 & optsp->out_type) {
#line 2312
      if (outf_exists) {
#line 2312
        if (ofp->trunc) {
#line 2312
          if (! ofp->nowrite) {
#line 2314
            if (optsp->seek > 0L) {
#line 2315
              offset = optsp->seek * (int64_t )optsp->obs;
#line 2316
              if (st.st_size > offset) {
#line 2317
                needs_ftruncate ++;
              }
            } else {
#line 2319
              flags |= 512;
            }
          }
        }
      }
    }
    {
#line 2321
    fd = open(outf, flags, 438);
    }
#line 2321
    if (fd < 0) {
      {
#line 2322
      tmp___3 = __errno_location();
#line 2322
      tmp___4 = safe_strerror(*tmp___3);
#line 2322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open %s for writing: %s\n",
              outf, tmp___4);
      }
#line 2324
      goto file_err;
    }
#line 2326
    if (needs_ftruncate) {
#line 2326
      if (offset > 0L) {
        {
#line 2327
        tmp___7 = ftruncate(fd, offset);
        }
#line 2327
        if (tmp___7 < 0) {
          {
#line 2328
          tmp___5 = __errno_location();
#line 2328
          tmp___6 = safe_strerror(*tmp___5);
#line 2328
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not ftruncate %s after open (seek): %s\n",
                  outf, tmp___6);
          }
#line 2330
          goto file_err;
        }
      }
    }
#line 2334
    if (! outf_exists) {
#line 2334
      if (256 & optsp->out_type) {
#line 2335
        optsp->out_type = 4;
#line 2336
        out_type_hold = optsp->out_type;
      }
    }
    {
#line 2338
    tmp___8 = sg_set_binary_mode(fd);
    }
#line 2338
    if (tmp___8 < 0) {
      {
#line 2339
      perror("sg_set_binary_mode");
      }
    }
#line 2340
    if (verbose___0) {
#line 2341
      if (outf_exists) {
#line 2341
        tmp___9 = "open";
      } else {
#line 2341
        tmp___9 = "create";
      }
      {
#line 2341
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %s %s, flags=0x%x\n",
              tmp___9, outf, flags);
      }
#line 2343
      if (needs_ftruncate) {
#line 2343
        if (offset > 0L) {
          {
#line 2344
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        truncated file at byte offset %ld \n",
                  offset);
          }
        }
      }
    }
  }
#line 2349
  if (ofp->flock) {
    {
#line 2352
    res = flock(fd, 6);
    }
#line 2353
    if (res < 0) {
      {
#line 2354
      close(fd);
#line 2355
      tmp___10 = __errno_location();
#line 2355
      tmp___11 = safe_strerror(*tmp___10);
#line 2355
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"flock(LOCK_EX | LOCK_NB) on %s failed: %s\n",
              outf, tmp___11);
      }
#line 2357
      return (-90);
    }
  }
#line 2361
  return (fd);
  file_err: 
#line 2364
  return (-15);
  other_err: 
#line 2366
  return (-99);
}
}
#line 2371 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int calc_count_in(struct opts_t *optsp , int64_t *in_num_sectp , int *in_sect_szp ) 
{ 
  int res ;
  struct stat st ;
  int64_t num_sect ;
  int64_t t ;
  int sect_sz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2380
  *in_num_sectp = (int64_t )-1;
#line 2381
  *in_sect_szp = -1;
#line 2382
  if (2 & optsp->in_type) {
#line 2383
    if ((optsp->iflagp)->norcap) {
#line 2384
      if (32 & optsp->in_type) {
#line 2384
        if (0 == (optsp->iflagp)->force) {
          {
#line 2385
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: norcap on input block device accessed via pt is risky.\n");
#line 2387
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Abort copy, use iflag=force to override.\n");
          }
#line 2389
          return (-1);
        }
      }
#line 2391
      return (0);
    }
    {
#line 2393
    res = scsi_read_capacity(optsp->infd, in_num_sectp, in_sect_szp);
    }
#line 2394
    if (6 == res) {
      {
#line 2395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention (readcap in), continuing\n");
#line 2396
      res = scsi_read_capacity(optsp->infd, in_num_sectp, in_sect_szp);
      }
    } else
#line 2397
    if (11 == res) {
      {
#line 2398
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command (readcap in), continuing\n");
#line 2399
      res = scsi_read_capacity(optsp->infd, in_num_sectp, in_sect_szp);
      }
    }
#line 2401
    if (0 != res) {
#line 2402
      if (res == 9) {
        {
#line 2403
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read capacity not supported on %s\n",
                optsp->inf);
        }
      } else
#line 2405
      if (res == 2) {
        {
#line 2406
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read capacity failed on %s - not ready\n",
                optsp->inf);
        }
      } else {
        {
#line 2409
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to read capacity on %s\n",
                optsp->inf);
        }
      }
#line 2410
      *in_num_sectp = (int64_t )-1;
#line 2411
      return (res);
    } else {
#line 2413
      if (verbose) {
        {
#line 2414
        print_blk_sizes((char const   *)(optsp->inf), "pt", *in_num_sectp, *in_sect_szp);
        }
      }
#line 2415
      if (*in_sect_szp != optsp->ibs) {
        {
#line 2416
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: %s block size confusion: ibs=%d, device claims=%d\n",
                optsp->inf, optsp->ibs, *in_sect_szp);
        }
#line 2419
        if (0 == (optsp->iflagp)->force) {
          {
#line 2420
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> abort copy, use iflag=force to override\n");
          }
#line 2422
          return (-1);
        }
      }
    }
#line 2426
    if (32 & optsp->in_type) {
#line 2426
      if (0 == (optsp->iflagp)->force) {
        {
#line 2426
        tmp = get_blkdev_capacity(optsp, 0, & num_sect, & sect_sz, verbose);
        }
#line 2426
        if (0 == tmp) {
#line 2429
          t = *in_num_sectp * (int64_t )*in_sect_szp;
#line 2430
          if (t != num_sect * (int64_t )sect_sz) {
            {
#line 2431
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: Size of input block device is different from pt size.\n>> Pass-through on block partition can give unexpected offsets.\n");
#line 2434
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Abort copy, use iflag=force to override.\n");
            }
#line 2436
            return (-1);
          }
        }
      }
    }
  } else
#line 2439
  if (dd_count > 0L) {
#line 2439
    if (0 == (optsp->oflagp)->resume) {
#line 2440
      return (0);
    } else {
#line 2439
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2441
  if (32 & optsp->in_type) {
    {
#line 2442
    tmp___0 = get_blkdev_capacity(optsp, 0, in_num_sectp, in_sect_szp, verbose);
    }
#line 2442
    if (0 != tmp___0) {
      {
#line 2444
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to read block capacity on %s\n",
              optsp->inf);
#line 2446
      *in_num_sectp = (int64_t )-1;
      }
    }
#line 2448
    if (verbose) {
      {
#line 2449
      print_blk_sizes((char const   *)(optsp->inf), "blk", *in_num_sectp, *in_sect_szp);
      }
    }
#line 2450
    if (optsp->ibs != *in_sect_szp) {
      {
#line 2451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: %s block size confusion: bs=%d, device claims=%d\n",
              optsp->inf, optsp->ibs, *in_sect_szp);
#line 2454
      *in_num_sectp = (int64_t )-1;
      }
    }
  } else
#line 2456
  if (4 & optsp->in_type) {
    {
#line 2457
    tmp___1 = fstat(optsp->infd, & st);
    }
#line 2457
    if (tmp___1 < 0) {
      {
#line 2458
      perror("fstat(infd) error");
#line 2459
      *in_num_sectp = (int64_t )-1;
      }
    } else {
#line 2461
      *in_num_sectp = st.st_size / (__off_t )optsp->ibs;
#line 2462
      if (0L != st.st_size % (long )optsp->ibs) {
#line 2463
        (*in_num_sectp) ++;
      }
    }
  }
#line 2466
  return (0);
}
}
#line 2471 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int calc_count_out(struct opts_t *optsp , int64_t *out_num_sectp , int *out_sect_szp ) 
{ 
  int res ;
  struct stat st ;
  int64_t num_sect ;
  int64_t t ;
  int sect_sz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2480
  *out_num_sectp = (int64_t )-1;
#line 2481
  *out_sect_szp = -1;
#line 2482
  if (2 & optsp->out_type) {
#line 2483
    if ((optsp->oflagp)->norcap) {
#line 2484
      if (32 & optsp->out_type) {
#line 2484
        if (0 == (optsp->oflagp)->force) {
          {
#line 2485
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: norcap on output block device accessed via pt is risky.\n");
#line 2487
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Abort copy, use oflag=force to override.\n");
          }
#line 2489
          return (-1);
        }
      }
#line 2491
      return (0);
    }
    {
#line 2493
    res = scsi_read_capacity(optsp->outfd, out_num_sectp, out_sect_szp);
    }
#line 2494
    if (6 == res) {
      {
#line 2495
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention (readcap out), continuing\n");
#line 2496
      res = scsi_read_capacity(optsp->outfd, out_num_sectp, out_sect_szp);
      }
    } else
#line 2498
    if (11 == res) {
      {
#line 2499
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborted command (readcap out), continuing\n");
#line 2500
      res = scsi_read_capacity(optsp->outfd, out_num_sectp, out_sect_szp);
      }
    }
#line 2503
    if (0 != res) {
#line 2504
      if (res == 9) {
        {
#line 2505
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read capacity not supported on %s\n",
                optsp->outf);
        }
      } else {
        {
#line 2508
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to read capacity on %s\n",
                optsp->outf);
        }
      }
#line 2510
      *out_num_sectp = (int64_t )-1;
#line 2511
      return (res);
    } else {
#line 2513
      if (verbose) {
        {
#line 2514
        print_blk_sizes((char const   *)(optsp->outf), "pt", *out_num_sectp, *out_sect_szp);
        }
      }
#line 2516
      if (optsp->obs != *out_sect_szp) {
        {
#line 2517
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: %s block size confusion: obs=%d, device claims=%d\n",
                optsp->outf, optsp->obs, *out_sect_szp);
        }
#line 2520
        if (0 == (optsp->oflagp)->force) {
          {
#line 2521
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> abort copy, use oflag=force to override\n");
          }
#line 2523
          return (-1);
        }
      }
    }
#line 2527
    if (32 & optsp->out_type) {
#line 2527
      if (0 == (optsp->oflagp)->force) {
        {
#line 2527
        tmp = get_blkdev_capacity(optsp, 1, & num_sect, & sect_sz, verbose);
        }
#line 2527
        if (0 == tmp) {
#line 2530
          t = *out_num_sectp * (int64_t )*out_sect_szp;
#line 2531
          if (t != num_sect * (int64_t )sect_sz) {
            {
#line 2532
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: size of output block device is different from pt size.\n>> Pass-through on block partition can give unexpected results.\n");
#line 2535
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> abort copy, use oflag=force to override\n");
            }
#line 2537
            return (-1);
          }
        }
      }
    }
  } else
#line 2540
  if (dd_count > 0L) {
#line 2540
    if (0 == (optsp->oflagp)->resume) {
#line 2541
      return (0);
    } else {
#line 2540
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2542
  if (32 & optsp->out_type) {
    {
#line 2543
    tmp___0 = get_blkdev_capacity(optsp, 1, out_num_sectp, out_sect_szp, verbose);
    }
#line 2543
    if (0 != tmp___0) {
      {
#line 2545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to read block capacity on %s\n",
              optsp->outf);
#line 2547
      *out_num_sectp = (int64_t )-1;
      }
    } else {
#line 2549
      if (verbose) {
        {
#line 2550
        print_blk_sizes((char const   *)(optsp->outf), "blk", *out_num_sectp, *out_sect_szp);
        }
      }
#line 2552
      if (optsp->obs != *out_sect_szp) {
        {
#line 2553
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: %s block size confusion: obs=%d, device claims=%d\n",
                optsp->outf, optsp->obs, *out_sect_szp);
#line 2556
        *out_num_sectp = (int64_t )-1;
        }
      }
    }
  } else
#line 2559
  if (4 & optsp->out_type) {
    {
#line 2560
    tmp___1 = fstat(optsp->outfd, & st);
    }
#line 2560
    if (tmp___1 < 0) {
      {
#line 2561
      perror("fstat(outfd) error");
#line 2562
      *out_num_sectp = (int64_t )-1;
      }
    } else {
#line 2564
      *out_num_sectp = st.st_size / (__off_t )optsp->obs;
#line 2565
      if (0L != st.st_size % (long )optsp->obs) {
#line 2566
        (*out_num_sectp) ++;
      }
    }
  }
#line 2569
  return (0);
}
}
#line 2577 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int calc_count(struct opts_t *optsp , int64_t *in_num_sectp , int *in_sect_szp ,
                      int64_t *out_num_sectp , int *out_sect_szp ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 2583
  res = calc_count_in(optsp, in_num_sectp, in_sect_szp);
  }
#line 2584
  if (res) {
#line 2585
    *out_num_sectp = (int64_t )-1;
#line 2586
    *out_sect_szp = -1;
#line 2587
    return (res);
  }
  {
#line 2589
  tmp = calc_count_out(optsp, out_num_sectp, out_sect_szp);
  }
#line 2589
  return (tmp);
}
}
#line 2601
static void do_fadvise(struct opts_t *op , int bytes_if , int bytes_of , int bytes_of2 ) ;
#line 2601 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static off_t lowest_skip  =    (off_t )-1;
#line 2602 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static off_t lowest_seek  =    (off_t )-1;
#line 2597 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void do_fadvise(struct opts_t *op , int bytes_if , int bytes_of , int bytes_of2 ) 
{ 
  int rt ;
  int in_valid ;
  int out2_valid ;
  int out_valid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2604
  if (4 == op->in_type) {
#line 2604
    tmp = 1;
  } else
#line 2604
  if (32 == op->in_type) {
#line 2604
    tmp = 1;
  } else {
#line 2604
    tmp = 0;
  }
#line 2604
  in_valid = tmp;
#line 2605
  if (4 == op->out2_type) {
#line 2605
    tmp___0 = 1;
  } else
#line 2605
  if (32 == op->out2_type) {
#line 2605
    tmp___0 = 1;
  } else {
#line 2605
    tmp___0 = 0;
  }
#line 2605
  out2_valid = tmp___0;
#line 2606
  if (4 == op->out_type) {
#line 2606
    tmp___1 = 1;
  } else
#line 2606
  if (32 == op->out_type) {
#line 2606
    tmp___1 = 1;
  } else {
#line 2606
    tmp___1 = 0;
  }
#line 2606
  out_valid = tmp___1;
#line 2607
  if ((op->iflagp)->nocache) {
#line 2607
    if (bytes_if > 0) {
#line 2607
      if (in_valid) {
#line 2608
        if (lowest_skip < 0L) {
#line 2609
          lowest_skip = op->skip;
        } else
#line 2608
        if (op->skip > lowest_skip) {
#line 2609
          lowest_skip = op->skip;
        }
        {
#line 2610
        rt = posix_fadvise(op->infd, lowest_skip * (off_t )op->ibs, (op->skip - lowest_skip) * (int64_t )op->ibs + (int64_t )bytes_if,
                           4);
        }
#line 2613
        if (rt) {
          {
#line 2614
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"posix_fadvise on read, skip=%ld ,err=%d\n",
                  op->skip, rt);
          }
        }
      }
    }
  }
#line 2617
  if ((op->oflagp)->nocache & 2) {
#line 2617
    if (bytes_of2 > 0) {
#line 2617
      if (out2_valid) {
        {
#line 2618
        rt = posix_fadvise(op->out2fd, (__off64_t )0, (__off64_t )0, 4);
        }
#line 2619
        if (rt) {
          {
#line 2620
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"posix_fadvise on of2, seek=%ld ,err=%d\n",
                  op->seek, rt);
          }
        }
      }
    }
  }
#line 2623
  if ((op->oflagp)->nocache & 1) {
#line 2623
    if (bytes_of > 0) {
#line 2623
      if (out_valid) {
#line 2624
        if (lowest_seek < 0L) {
#line 2625
          lowest_seek = op->seek;
        } else
#line 2624
        if (op->seek > lowest_seek) {
#line 2625
          lowest_seek = op->seek;
        }
        {
#line 2626
        rt = posix_fadvise(op->outfd, lowest_seek * (off_t )op->obs, (op->seek - lowest_seek) * (int64_t )op->obs + (int64_t )bytes_of,
                           4);
        }
#line 2629
        if (rt) {
          {
#line 2630
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"posix_fadvise on output, seek=%ld , err=%d\n",
                  op->seek, rt);
          }
        }
      }
    }
  }
#line 2633
  return;
}
}
#line 2638 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_read_pt(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *wrkPos ) 
{ 
  int res ;
  int blks_read ;
  char const   *tmp ;

  {
  {
#line 2643
  blks_read = 0;
#line 2645
  res = pt_read(optsp->infd, 0, wrkPos, csp->icbpt, optsp->skip, optsp->ibs, optsp->iflagp,
                & blks_read);
  }
#line 2647
  if (res) {
#line 2648
    if (0 == blks_read) {
#line 2649
      if (-2 == res) {
#line 2649
        tmp = " try reducing bpt,";
      } else {
#line 2649
        tmp = "";
      }
      {
#line 2649
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pt_read failed,%s at or after lba=%ld [0x%lx]\n",
              tmp, optsp->skip, optsp->skip);
      }
#line 2653
      return (res);
    }
#line 2656
    err_to_report = res;
  }
#line 2658
  if (blks_read < csp->icbpt) {
#line 2660
    if (verbose > 1) {
      {
#line 2661
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"short read, requested %d blocks, got %d blocks\n",
              csp->icbpt, blks_read);
      }
    }
#line 2663
    (csp->leave_after_write) ++;
#line 2665
    csp->icbpt = blks_read;
#line 2667
    csp->ocbpt = (blks_read * optsp->ibs) / optsp->obs;
  }
#line 2669
  in_full += (int64_t )csp->icbpt;
#line 2670
  return (0);
}
}
#line 2675 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
int coe_process_eio(int64_t skip ) 
{ 


  {
#line 2678
  if (coe_limit > 0) {
#line 2678
    coe_count ++;
#line 2678
    if (coe_count > coe_limit) {
      {
#line 2679
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> coe_limit on consecutive reads exceeded\n");
      }
#line 2681
      return (3);
    }
  }
#line 2683
  if (highest_unrecovered < 0L) {
#line 2684
    highest_unrecovered = skip;
#line 2685
    lowest_unrecovered = skip;
  } else {
#line 2687
    if (skip < lowest_unrecovered) {
#line 2688
      lowest_unrecovered = skip;
    }
#line 2689
    if (skip > highest_unrecovered) {
#line 2690
      highest_unrecovered = skip;
    }
  }
  {
#line 2692
  unrecovered_errs ++;
#line 2693
  in_partial ++;
#line 2694
  in_full --;
#line 2695
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> unrecovered read error at blk=%ld, substitute zeros\n",
          skip);
  }
#line 2697
  return (0);
}
}
#line 2706 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int coe_cp_read_block_reg(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *wrkPos ,
                                 int numread_errno ) 
{ 
  int res ;
  int res2 ;
  int k ;
  int total_read ;
  int num_read ;
  int ibs ;
  int64_t offset ;
  int64_t off_res ;
  int64_t my_skip ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 2711
  ibs = optsp->ibs;
#line 2714
  if (0 == numread_errno) {
#line 2715
    csp->icbpt = 0;
#line 2716
    csp->ocbpt = 0;
#line 2717
    (csp->leave_after_write) ++;
#line 2718
    csp->leave_reason = 0;
#line 2719
    return (0);
  } else
#line 2720
  if (numread_errno < 0) {
#line 2721
    if (-5 == numread_errno) {
#line 2721
      goto _L;
    } else
#line 2721
    if (-121 == numread_errno) {
      _L: /* CIL Label */ 
#line 2722
      num_read = 0;
#line 2723
      if (1 == csp->icbpt) {
        {
#line 2725
        memset((void *)wrkPos, 0, (size_t )ibs);
#line 2726
        res2 = coe_process_eio(optsp->skip);
        }
#line 2726
        if (res2) {
#line 2727
          return (res2);
        }
#line 2728
        in_full ++;
#line 2729
        csp->bytes_read += ibs;
#line 2730
        return (0);
      }
    } else {
#line 2733
      return (99);
    }
  } else {
#line 2735
    num_read = (numread_errno / ibs) * ibs;
  }
#line 2737
  k = num_read / ibs;
#line 2738
  if (k > 0) {
    {
#line 2739
    in_full += (int64_t )k;
#line 2740
    zero_coe_limit_count();
    }
  }
#line 2742
  csp->bytes_read = num_read;
#line 2743
  my_skip = optsp->skip + (int64_t )k;
#line 2744
  offset = my_skip * (int64_t )ibs;
#line 2745
  wrkPos += num_read;
  {
#line 2746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2746
    if (! (k < csp->icbpt)) {
#line 2746
      goto while_break;
    }
#line 2747
    if (offset != csp->if_filepos) {
#line 2748
      if (verbose > 2) {
        {
#line 2749
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"moving if filepos: new_pos=%ld\n",
                offset);
        }
      }
      {
#line 2751
      off_res = lseek(optsp->infd, offset, 0);
      }
#line 2752
      if (off_res < 0L) {
        {
#line 2753
        tmp = __errno_location();
#line 2753
        tmp___0 = safe_strerror(*tmp);
#line 2753
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed moving if filepos: new_pos=%ld\nlseek on input: %s\n",
                offset, tmp___0);
        }
#line 2756
        return (15);
      }
#line 2758
      csp->if_filepos = offset;
    }
    {
#line 2760
    memset((void *)wrkPos, 0, (size_t )ibs);
    }
    {
#line 2761
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2761
      tmp___1 = read(optsp->infd, (void *)wrkPos, (size_t )ibs);
#line 2761
      res = (int )tmp___1;
      }
#line 2761
      if (res < 0) {
        {
#line 2761
        tmp___2 = __errno_location();
        }
#line 2761
        if (! (4 == *tmp___2)) {
#line 2761
          goto while_break___0;
        }
      } else {
#line 2761
        goto while_break___0;
      }
#line 2763
      interrupted_retries ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2764
    if (0 == res) {
#line 2765
      csp->leave_reason = 0;
#line 2766
      goto short_read;
    } else
#line 2767
    if (res < 0) {
      {
#line 2768
      tmp___5 = __errno_location();
      }
#line 2768
      if (5 == *tmp___5) {
#line 2768
        goto _L___0;
      } else {
        {
#line 2768
        tmp___6 = __errno_location();
        }
#line 2768
        if (121 == *tmp___6) {
          _L___0: /* CIL Label */ 
          {
#line 2769
          res2 = coe_process_eio(my_skip);
          }
#line 2769
          if (res2) {
#line 2770
            return (res2);
          }
        } else {
          {
#line 2772
          tmp___3 = __errno_location();
#line 2772
          tmp___4 = safe_strerror(*tmp___3);
#line 2772
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading 1 block, skip=%ld : %s\n",
                  my_skip, tmp___4);
#line 2774
          csp->leave_reason = 99;
          }
#line 2775
          goto short_read;
        }
      }
    } else
#line 2777
    if (res < ibs) {
#line 2778
      if (verbose) {
        {
#line 2779
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"short read at skip=%ld , wanted=%d, got=%d bytes\n",
                my_skip, ibs, res);
        }
      }
#line 2781
      csp->leave_reason = 0;
#line 2782
      goto short_read;
    } else {
      {
#line 2784
      zero_coe_limit_count();
#line 2785
      csp->if_filepos += (int64_t )ibs;
      }
#line 2786
      if (verbose > 2) {
        {
#line 2787
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading 1 block, skip=%ld : okay\n",
                my_skip);
        }
      }
    }
#line 2790
    in_full ++;
#line 2791
    csp->bytes_read += ibs;
#line 2746
    k ++;
#line 2746
    my_skip ++;
#line 2746
    wrkPos += ibs;
#line 2746
    offset += (int64_t )ibs;
  }
  while_break: /* CIL Label */ ;
  }
#line 2793
  return (0);
  short_read: 
#line 2796
  if (res > 0) {
#line 2796
    tmp___7 = res;
  } else {
#line 2796
    tmp___7 = 0;
  }
#line 2796
  total_read = ibs * k + tmp___7;
#line 2797
  csp->icbpt = total_read / optsp->ibs;
#line 2798
  if (total_read % optsp->ibs > 0) {
#line 2799
    (csp->icbpt) ++;
#line 2800
    in_partial ++;
  }
#line 2802
  csp->ocbpt = total_read / optsp->obs;
#line 2803
  (csp->leave_after_write) ++;
#line 2804
  if (0 == csp->leave_reason) {
#line 2805
    csp->partial_write_bytes = total_read % optsp->obs;
  } else
#line 2808
  if (total_read % optsp->obs > 0) {
#line 2809
    (csp->ocbpt) ++;
  }
#line 2811
  return (0);
}
}
#line 2817 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_read_block_reg(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *wrkPos ) 
{ 
  int res ;
  int res2 ;
  int64_t offset ;
  int numbytes ;
  int64_t off_res ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  ssize_t tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 2822
  offset = optsp->skip * (int64_t )optsp->ibs;
#line 2823
  numbytes = csp->icbpt * optsp->ibs;
#line 2836
  if (offset != csp->if_filepos) {
#line 2839
    if (verbose > 2) {
      {
#line 2840
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"moving if filepos: new_pos=%ld\n",
              offset);
      }
    }
    {
#line 2842
    off_res = lseek(optsp->infd, offset, 0);
    }
#line 2843
    if (off_res < 0L) {
      {
#line 2844
      tmp = __errno_location();
#line 2844
      tmp___0 = safe_strerror(*tmp);
#line 2844
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed moving if filepos: new_pos=%ld\nlseek on input: %s\n",
              offset, tmp___0);
      }
#line 2847
      return (15);
    }
#line 2849
    csp->if_filepos = offset;
  }
  {
#line 2851
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2851
    tmp___1 = read(optsp->infd, (void *)wrkPos, (size_t )numbytes);
#line 2851
    res = (int )tmp___1;
    }
#line 2851
    if (res < 0) {
      {
#line 2851
      tmp___2 = __errno_location();
      }
#line 2851
      if (! (4 == *tmp___2)) {
#line 2851
        goto while_break;
      }
    } else {
#line 2851
      goto while_break;
    }
#line 2853
    interrupted_retries ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2855
  if (verbose > 2) {
    {
#line 2856
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read(unix): requested bytes=%d, res=%d\n",
            numbytes, res);
    }
  }
#line 2858
  if ((optsp->iflagp)->coe) {
#line 2858
    if (res < numbytes) {
#line 2859
      if (res >= 0) {
#line 2859
        res2 = res;
      } else {
        {
#line 2859
        tmp___3 = __errno_location();
#line 2859
        res2 = - *tmp___3;
        }
      }
#line 2860
      if (res < 0) {
#line 2860
        if (verbose) {
          {
#line 2861
          tmp___4 = __errno_location();
#line 2861
          tmp___5 = safe_strerror(*tmp___4);
#line 2861
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading, skip=%ld : %s, go to coe\n",
                  optsp->skip, tmp___5);
          }
        } else {
#line 2860
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2863
      if (verbose) {
        {
#line 2864
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading, skip=%ld : short read, go to coe\n",
                optsp->skip);
        }
      }
#line 2866
      if (res2 > 0) {
#line 2867
        csp->if_filepos += (int64_t )res2;
      }
      {
#line 2868
      tmp___6 = coe_cp_read_block_reg(optsp, csp, wrkPos, res2);
      }
#line 2868
      return (tmp___6);
    }
  }
#line 2870
  if (res < 0) {
    {
#line 2871
    tmp___7 = __errno_location();
#line 2871
    tmp___8 = safe_strerror(*tmp___7);
#line 2871
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reading, skip=%ld : %s\n",
            optsp->skip, tmp___8);
#line 2873
    tmp___9 = __errno_location();
    }
#line 2873
    if (5 == *tmp___9) {
#line 2874
      return (3);
    } else {
      {
#line 2873
      tmp___10 = __errno_location();
      }
#line 2873
      if (121 == *tmp___10) {
#line 2874
        return (3);
      } else {
#line 2876
        return (99);
      }
    }
  } else
#line 2877
  if (res < numbytes) {
#line 2878
    csp->icbpt = res / optsp->ibs;
#line 2879
    if (res % optsp->ibs > 0) {
#line 2880
      (csp->icbpt) ++;
#line 2881
      in_partial ++;
#line 2882
      in_full --;
    }
#line 2884
    csp->ocbpt = res / optsp->obs;
#line 2885
    (csp->leave_after_write) ++;
#line 2886
    csp->leave_reason = 0;
#line 2887
    if (verbose > 1) {
#line 2888
      if (32 & optsp->in_type) {
        {
#line 2889
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"short read at skip=%ld, requested %d blocks, got %d blocks\n",
                optsp->skip, numbytes / optsp->ibs, csp->icbpt);
        }
      } else {
        {
#line 2893
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"short read, requested %d bytes, got %d bytes\n",
                numbytes, res);
        }
      }
    }
#line 2896
    res2 = 0;
#line 2897
    if (res >= optsp->ibs) {
#line 2897
      if (res <= numbytes - optsp->ibs) {
        {
#line 2899
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 2899
          tmp___11 = read(optsp->infd, (void *)(wrkPos + res), (size_t )optsp->ibs);
#line 2899
          res2 = (int )tmp___11;
          }
#line 2899
          if (res2 < 0) {
            {
#line 2899
            tmp___12 = __errno_location();
            }
#line 2899
            if (! (4 == *tmp___12)) {
#line 2899
              goto while_break___0;
            }
          } else {
#line 2899
            goto while_break___0;
          }
#line 2901
          interrupted_retries ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2902
        if (res2 < 0) {
          {
#line 2903
          tmp___13 = __errno_location();
          }
#line 2903
          if (5 == *tmp___13) {
#line 2904
            csp->leave_reason = 3;
#line 2905
            unrecovered_errs ++;
          } else {
            {
#line 2903
            tmp___14 = __errno_location();
            }
#line 2903
            if (121 == *tmp___14) {
#line 2904
              csp->leave_reason = 3;
#line 2905
              unrecovered_errs ++;
            } else {
#line 2907
              csp->leave_reason = 99;
            }
          }
#line 2908
          if (verbose) {
            {
#line 2909
            tmp___15 = __errno_location();
#line 2909
            tmp___16 = safe_strerror(*tmp___15);
#line 2909
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"after short read, read at skip=%ld: %s\n",
                    optsp->skip + (int64_t )csp->icbpt, tmp___16);
            }
          }
        } else {
#line 2913
          csp->if_filepos += (int64_t )res2;
#line 2914
          if (verbose > 1) {
            {
#line 2915
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"extra read after short read, res=%d\n",
                    res2);
            }
          }
        }
      }
    }
#line 2919
    if (0 == csp->leave_reason) {
#line 2920
      csp->partial_write_bytes = (res + res2) % optsp->obs;
    } else
#line 2921
    if (res % optsp->obs > 0) {
#line 2922
      (csp->ocbpt) ++;
    }
  }
#line 2924
  csp->if_filepos += (int64_t )res;
#line 2925
  csp->bytes_read = res;
#line 2926
  in_full += (int64_t )csp->icbpt;
#line 2927
  return (0);
}
}
#line 2932 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_write_of2(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *wrkPos ) 
{ 
  int res ;
  int off ;
  int part ;
  int numbytes ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 2937
  numbytes = csp->ocbpt * optsp->obs + csp->partial_write_bytes;
#line 2940
  off = 0;
#line 2941
  part = 0;
  {
#line 2942
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2943
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2943
      tmp = write(optsp->out2fd, (void const   *)(wrkPos + off), (size_t )(numbytes - off));
#line 2943
      res = (int )tmp;
      }
#line 2943
      if (res < 0) {
        {
#line 2943
        tmp___0 = __errno_location();
        }
#line 2943
        if (! (4 == *tmp___0)) {
#line 2943
          goto while_break___0;
        }
      } else {
#line 2943
        goto while_break___0;
      }
#line 2945
      interrupted_retries ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2946
    if (res > 0) {
#line 2946
      if (res < numbytes - off) {
#line 2947
        part ++;
      }
    }
#line 2942
    if (64 & optsp->out2_type) {
#line 2942
      if (res > 0) {
#line 2942
        off += res;
#line 2942
        if (! (off < numbytes)) {
#line 2942
          goto while_break;
        }
      } else {
#line 2942
        goto while_break;
      }
    } else {
#line 2942
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2950
  if (off >= numbytes) {
#line 2951
    res = numbytes;
#line 2952
    if (part) {
#line 2952
      if (verbose) {
        {
#line 2953
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write to of2 splintered\n");
        }
      }
    }
  } else
#line 2954
  if (off > 0) {
    {
#line 2955
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write to of2 fifo problem: count=%d, off=%d, res=%d\n",
            numbytes, off, res);
    }
  }
#line 2957
  if (verbose > 2) {
#line 2957
    if (0 == off) {
      {
#line 2958
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write to of2: count=%d, res=%d\n",
              numbytes, res);
      }
    }
  }
#line 2959
  if (res < 0) {
    {
#line 2960
    tmp___1 = __errno_location();
#line 2960
    tmp___2 = safe_strerror(*tmp___1);
#line 2960
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writing to of2, seek=%ld : %s\n",
            optsp->seek, tmp___2);
    }
#line 2962
    return (-1);
  }
#line 2964
  csp->bytes_of2 = res;
#line 2965
  return (0);
}
}
#line 2970 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_read_of_pt(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *wrkPos2 ) 
{ 
  int res ;
  int blks_read ;

  {
  {
#line 2976
  res = pt_read(optsp->outfd, 1, wrkPos2, csp->ocbpt, optsp->seek, optsp->obs, optsp->oflagp,
                & blks_read);
  }
#line 2978
  if (res) {
    {
#line 2979
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pt_read(sparing) failed, at or after lba=%ld [0x%lx]\n",
            optsp->seek, optsp->seek);
    }
#line 2982
    return (res);
  } else
#line 2983
  if (blks_read != csp->ocbpt) {
#line 2984
    return (1);
  }
#line 2985
  return (0);
}
}
#line 2991 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_read_of_block_reg(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *wrkPos2 ) 
{ 
  int res ;
  int64_t offset ;
  int numbytes ;
  int64_t off_res ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 2996
  offset = optsp->seek * (int64_t )optsp->obs;
#line 2997
  numbytes = csp->ocbpt * optsp->obs;
#line 3028
  if (offset != csp->of_filepos) {
#line 3031
    if (verbose > 2) {
      {
#line 3032
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"moving of filepos: new_pos=%ld\n",
              offset);
      }
    }
    {
#line 3034
    off_res = lseek(optsp->outfd, offset, 0);
    }
#line 3035
    if (off_res < 0L) {
      {
#line 3036
      tmp = __errno_location();
#line 3036
      tmp___0 = safe_strerror(*tmp);
#line 3036
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed moving of filepos: new_pos=%ld\nlseek on output: %s\n",
              offset, tmp___0);
      }
#line 3039
      return (15);
    }
#line 3041
    csp->of_filepos = offset;
  }
#line 3043
  if (csp->partial_write_bytes > 0) {
#line 3044
    numbytes += csp->partial_write_bytes;
#line 3045
    if (verbose) {
      {
#line 3046
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read(sparing): %d bytes extra to fetch due to partial read\n",
              csp->partial_write_bytes);
      }
    }
  }
  {
#line 3049
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3049
    tmp___1 = read(optsp->outfd, (void *)wrkPos2, (size_t )numbytes);
#line 3049
    res = (int )tmp___1;
    }
#line 3049
    if (res < 0) {
      {
#line 3049
      tmp___2 = __errno_location();
      }
#line 3049
      if (! (4 == *tmp___2)) {
#line 3049
        goto while_break;
      }
    } else {
#line 3049
      goto while_break;
    }
#line 3051
    interrupted_retries ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3052
  if (verbose > 2) {
    {
#line 3053
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read(sparing): requested bytes=%d, res=%d\n",
            numbytes, res);
    }
  }
#line 3055
  if (res < 0) {
    {
#line 3056
    tmp___3 = __errno_location();
#line 3056
    tmp___4 = safe_strerror(*tmp___3);
#line 3056
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read(sparing), seek=%ld : %s\n",
            optsp->seek, tmp___4);
    }
#line 3058
    return (-1);
  } else
#line 3059
  if (res == numbytes) {
#line 3060
    csp->of_filepos += (int64_t )numbytes;
#line 3061
    return (0);
  } else {
#line 3063
    if (verbose > 2) {
      {
#line 3064
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"short read\n");
      }
    }
#line 3065
    return (1);
  }
}
}
#line 3073 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_write_pt(struct opts_t *optsp , struct cp_state_t *csp , int seek_delta ,
                       int blks , unsigned char *wrkPos ) 
{ 
  int res ;
  int64_t aseek ;
  char const   *tmp ;

  {
#line 3078
  aseek = optsp->seek + (int64_t )seek_delta;
#line 3080
  if ((optsp->oflagp)->nowrite) {
#line 3081
    return (0);
  }
#line 3082
  if (csp->partial_write_bytes > 0) {
    {
#line 3083
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> ignore partial write of %d bytes to pt device\n",
            csp->partial_write_bytes);
    }
  }
  {
#line 3085
  res = pt_write(optsp->outfd, wrkPos, blks, aseek, optsp->obs, optsp->oflagp);
  }
#line 3087
  if (0 != res) {
#line 3088
    if (-2 == res) {
#line 3088
      tmp = " try reducing bpt,";
    } else {
#line 3088
      tmp = "";
    }
    {
#line 3088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pt_write failed,%s seek=%ld\n",
            tmp, aseek);
    }
#line 3090
    return (res);
  } else {
#line 3092
    out_full += (int64_t )blks;
  }
#line 3093
  return (0);
}
}
#line 3099 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_write_block_reg(struct opts_t *optsp , struct cp_state_t *csp , int seek_delta ,
                              int blks , unsigned char *wrkPos ) 
{ 
  int res ;
  int off ;
  int part ;
  int numbytes ;
  int64_t offset ;
  int64_t aseek ;
  int64_t off_res ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 3104
  numbytes = blks * optsp->obs;
#line 3106
  aseek = optsp->seek + (int64_t )seek_delta;
#line 3108
  if ((optsp->oflagp)->nowrite) {
#line 3109
    return (0);
  }
#line 3110
  offset = aseek * (int64_t )optsp->obs;
#line 3147
  if (csp->partial_write_bytes > 0) {
#line 3148
    if (32 & optsp->out_type) {
      {
#line 3149
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> ignore partial write of %d bytes to block device\n",
              csp->partial_write_bytes);
      }
    } else {
#line 3152
      numbytes += csp->partial_write_bytes;
#line 3153
      out_partial ++;
#line 3154
      out_full ++;
    }
  }
#line 3157
  if (offset != csp->of_filepos) {
#line 3160
    if (verbose > 2) {
      {
#line 3161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"moving of filepos: new_pos=%ld\n",
              offset);
      }
    }
    {
#line 3163
    off_res = lseek(optsp->outfd, offset, 0);
    }
#line 3164
    if (off_res < 0L) {
      {
#line 3165
      tmp = __errno_location();
#line 3165
      tmp___0 = safe_strerror(*tmp);
#line 3165
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed moving of filepos: new_pos=%ld\nlseek on output: %s\n",
              offset, tmp___0);
      }
#line 3168
      return (15);
    }
#line 3170
    csp->of_filepos = offset;
  }
#line 3173
  off = 0;
#line 3174
  part = 0;
  {
#line 3175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3176
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3176
      tmp___1 = write(optsp->outfd, (void const   *)(wrkPos + off), (size_t )(numbytes - off));
#line 3176
      res = (int )tmp___1;
      }
#line 3176
      if (res < 0) {
        {
#line 3176
        tmp___2 = __errno_location();
        }
#line 3176
        if (! (4 == *tmp___2)) {
#line 3176
          goto while_break___0;
        }
      } else {
#line 3176
        goto while_break___0;
      }
#line 3178
      interrupted_retries ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3179
    if (res > 0) {
#line 3179
      if (res < numbytes - off) {
#line 3180
        part ++;
      }
    }
#line 3175
    if (64 & optsp->out_type) {
#line 3175
      if (res > 0) {
#line 3175
        off += res;
#line 3175
        if (! (off < numbytes)) {
#line 3175
          goto while_break;
        }
      } else {
#line 3175
        goto while_break;
      }
    } else {
#line 3175
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3183
  if (off >= numbytes) {
#line 3184
    res = numbytes;
#line 3185
    if (part) {
#line 3185
      if (verbose) {
        {
#line 3186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write to output file splintered\n");
        }
      }
    }
  } else
#line 3187
  if (off > 0) {
    {
#line 3188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write to of fifo problem: count=%d, off=%d, res=%d\n",
            numbytes, off, res);
    }
  }
#line 3190
  if (verbose > 2) {
#line 3190
    if (0 == off) {
      {
#line 3191
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"write(unix): requested bytes=%d, res=%d\n",
              numbytes, res);
      }
    }
  }
#line 3193
  if (res < 0) {
    {
#line 3194
    tmp___3 = __errno_location();
#line 3194
    tmp___4 = safe_strerror(*tmp___3);
#line 3194
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writing, seek=%ld : %s\n",
            aseek, tmp___4);
    }
#line 3196
    return (-1);
  } else
#line 3197
  if (res < numbytes) {
    {
#line 3198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output file probably full, seek=%ld\n",
            aseek);
#line 3200
    out_full += (int64_t )(res / optsp->obs);
    }
#line 3202
    if (res % optsp->obs > 0) {
#line 3203
      out_partial ++;
#line 3204
      out_full ++;
    }
#line 3206
    return (-1);
  } else {
#line 3208
    csp->of_filepos += (int64_t )numbytes;
#line 3209
    csp->bytes_of = numbytes;
#line 3210
    out_full += (int64_t )blks;
  }
#line 3212
  return (0);
}
}
#line 3218 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void cp_sparse_cleanup(struct opts_t *optsp , struct cp_state_t *csp ) 
{ 
  int64_t offset ;
  struct stat a_st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3221
  offset = optsp->seek * (int64_t )optsp->obs;
#line 3224
  if (offset > csp->of_filepos) {
#line 3225
    if (0 == (optsp->oflagp)->strunc) {
#line 3225
      if ((optsp->oflagp)->sparse > 1) {
#line 3226
        if (verbose > 1) {
          {
#line 3227
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"asked to bypass writing sparse last block zeros\n");
          }
        }
#line 3229
        return;
      }
    }
    {
#line 3231
    tmp___1 = fstat(optsp->outfd, & a_st);
    }
#line 3231
    if (tmp___1 < 0) {
      {
#line 3232
      tmp = __errno_location();
#line 3232
      tmp___0 = safe_strerror(*tmp);
#line 3232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cp_sparse_cleanup: fstat: %s\n",
              tmp___0);
      }
#line 3234
      return;
    }
#line 3236
    if (offset == a_st.st_size) {
#line 3237
      if (verbose > 1) {
        {
#line 3238
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cp_sparse_cleanup: OFILE already correct length\n");
        }
      }
#line 3240
      return;
    }
#line 3242
    if (offset < a_st.st_size) {
#line 3243
      if (verbose > 1) {
        {
#line 3244
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cp_sparse_cleanup: OFILE longer than required, do nothing\n");
        }
      }
#line 3246
      return;
    }
#line 3248
    if ((optsp->oflagp)->strunc) {
#line 3249
      if (verbose > 1) {
        {
#line 3250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"About to truncate %s to byte offset %ld\n",
                optsp->outf, offset);
        }
      }
      {
#line 3252
      tmp___4 = ftruncate(optsp->outfd, offset);
      }
#line 3252
      if (tmp___4 < 0) {
        {
#line 3253
        tmp___2 = __errno_location();
#line 3253
        tmp___3 = safe_strerror(*tmp___2);
#line 3253
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not ftruncate after copy: %s\n",
                tmp___3);
        }
#line 3255
        return;
      }
    } else
#line 3258
    if (1 == (optsp->oflagp)->sparse) {
#line 3259
      if (verbose > 1) {
        {
#line 3260
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writing sparse last block zeros\n");
        }
      }
      {
#line 3261
      tmp___5 = cp_write_block_reg(optsp, csp, -1, 1, zeros_buff);
      }
#line 3261
      if (tmp___5 < 0) {
        {
#line 3262
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"writing sparse last block zeros error, seek=%ld\n",
                optsp->seek - 1L);
        }
      } else {
#line 3265
        out_sparse --;
      }
    }
  }
#line 3268
  return;
}
}
#line 3272 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_finer_comp_wr(struct opts_t *optsp , struct cp_state_t *csp , unsigned char *b1p ,
                            unsigned char *b2p ) 
{ 
  int res ;
  int k ;
  int n ;
  int oblks ;
  int numbytes ;
  int chunk ;
  int need_wr ;
  int wr_len ;
  int wr_k ;
  int obs ;
  int trim_check ;
  int need_tr ;
  int tr_len ;
  int tr_k ;
  int tmp ;
  int tmp___0 ;

  {
#line 3279
  oblks = csp->ocbpt;
#line 3280
  obs = optsp->obs;
#line 3281
  if (optsp->obpc >= oblks) {
#line 3282
    if (! (8 & optsp->out_type)) {
#line 3284
      if (2 & optsp->out_type) {
        {
#line 3285
        res = cp_write_pt(optsp, csp, 0, oblks, b1p);
        }
#line 3285
        if (res) {
#line 3286
          return (res);
        }
      } else {
        {
#line 3287
        res = cp_write_block_reg(optsp, csp, 0, oblks, b1p);
        }
#line 3287
        if (res) {
#line 3288
          return (res);
        }
      }
    }
#line 3289
    return (0);
  }
#line 3291
  numbytes = oblks * obs;
#line 3292
  if (4 & optsp->out_type) {
#line 3292
    if (csp->partial_write_bytes > 0) {
#line 3293
      numbytes += csp->partial_write_bytes;
    }
  }
#line 3294
  chunk = optsp->obpc * obs;
#line 3295
  if ((optsp->oflagp)->sparse) {
#line 3295
    if ((optsp->oflagp)->wsame16) {
#line 3295
      if (2 & optsp->out_type) {
#line 3295
        tmp = 1;
      } else {
#line 3295
        tmp = 0;
      }
    } else {
#line 3295
      tmp = 0;
    }
  } else {
#line 3295
    tmp = 0;
  }
#line 3295
  trim_check = tmp;
#line 3297
  need_tr = 0;
#line 3298
  tr_len = 0;
#line 3299
  tr_k = 0;
#line 3300
  k = 0;
#line 3300
  need_wr = 0;
#line 3300
  wr_len = 0;
#line 3300
  wr_k = 0;
  {
#line 3300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3300
    if (! (k < numbytes)) {
#line 3300
      goto while_break;
    }
#line 3301
    if (k + chunk < numbytes) {
#line 3301
      n = chunk;
    } else {
#line 3301
      n = numbytes - k;
    }
    {
#line 3302
    tmp___0 = memcmp((void const   *)(b1p + k), (void const   *)(b2p + k), (size_t )n);
    }
#line 3302
    if (0 == tmp___0) {
#line 3303
      if (need_wr) {
#line 3304
        if (! (8 & optsp->out_type)) {
#line 3306
          if (2 & optsp->out_type) {
            {
#line 3307
            res = cp_write_pt(optsp, csp, wr_k / obs, wr_len / obs, b1p + wr_k);
            }
#line 3307
            if (res) {
#line 3309
              return (res);
            }
          } else {
            {
#line 3310
            res = cp_write_block_reg(optsp, csp, wr_k / obs, wr_len / obs, b1p + wr_k);
            }
#line 3310
            if (res) {
#line 3312
              return (res);
            }
          }
        }
#line 3313
        need_wr = 0;
      }
#line 3315
      if (need_tr) {
#line 3316
        tr_len += n;
      } else
#line 3317
      if (trim_check) {
#line 3318
        need_tr = 1;
#line 3319
        tr_len = n;
#line 3320
        tr_k = k;
      }
#line 3322
      out_sparse += (int64_t )(n / obs);
    } else {
#line 3324
      if (need_wr) {
#line 3325
        wr_len += n;
      } else {
#line 3327
        need_wr = 1;
#line 3328
        wr_len = n;
#line 3329
        wr_k = k;
      }
#line 3331
      if (need_tr) {
        {
#line 3332
        res = pt_write_same16(optsp->outfd, 1, b2p, obs, tr_len / obs, optsp->seek + (int64_t )(tr_k / obs));
        }
#line 3334
        if (res) {
#line 3335
          trim_errs ++;
        }
#line 3337
        need_tr = 0;
      }
    }
#line 3300
    k += chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 3341
  if (need_wr) {
#line 3342
    if (! (8 & optsp->out_type)) {
#line 3344
      if (2 & optsp->out_type) {
        {
#line 3345
        res = cp_write_pt(optsp, csp, wr_k / obs, wr_len / obs, b1p + wr_k);
        }
#line 3345
        if (res) {
#line 3347
          return (res);
        }
      } else {
        {
#line 3348
        res = cp_write_block_reg(optsp, csp, wr_k / obs, wr_len / obs, b1p + wr_k);
        }
#line 3348
        if (res) {
#line 3350
          return (res);
        }
      }
    }
  }
#line 3352
  if (need_tr) {
    {
#line 3353
    res = pt_write_same16(optsp->outfd, 1, b2p, obs, tr_len / obs, optsp->seek + (int64_t )(tr_k / obs));
    }
#line 3355
    if (res) {
#line 3356
      trim_errs ++;
    }
  }
#line 3359
  return (0);
}
}
#line 3362 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int cp_construct_pt_zero_buff(struct opts_t *optsp , int obpt ) 
{ 
  void *tmp ;

  {
#line 3365
  if (2 & optsp->in_type) {
#line 3365
    if ((unsigned long )((void *)0) == (unsigned long )if_ptvp) {
      {
#line 3366
      if_ptvp = construct_scsi_pt_obj();
      }
#line 3367
      if ((unsigned long )((void *)0) == (unsigned long )if_ptvp) {
        {
#line 3368
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"if construct_scsi_pt_obj: out of memory\n");
        }
#line 3369
        return (-1);
      }
    }
  }
#line 3372
  if (2 & optsp->out_type) {
#line 3372
    if ((unsigned long )((void *)0) == (unsigned long )of_ptvp) {
      {
#line 3373
      of_ptvp = construct_scsi_pt_obj();
      }
#line 3374
      if ((unsigned long )((void *)0) == (unsigned long )of_ptvp) {
        {
#line 3375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"of construct_scsi_pt_obj: out of memory\n");
        }
#line 3376
        return (-1);
      }
    }
  }
#line 3379
  if ((optsp->oflagp)->sparse) {
#line 3379
    if ((unsigned long )((void *)0) == (unsigned long )zeros_buff) {
      {
#line 3380
      tmp = calloc((size_t )(obpt * optsp->obs), (size_t )1);
#line 3380
      zeros_buff = (unsigned char *)tmp;
      }
#line 3381
      if ((unsigned long )((void *)0) == (unsigned long )zeros_buff) {
        {
#line 3382
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"zeros_buff calloc failed\n");
        }
#line 3383
        return (-1);
      }
    }
  }
#line 3386
  return (0);
}
}
#line 3389 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static void cp_destruct_pt(void) 
{ 


  {
#line 3392
  if (if_ptvp) {
    {
#line 3393
    destruct_scsi_pt_obj(if_ptvp);
#line 3394
    if_ptvp = (struct sg_pt_base *)((void *)0);
    }
  }
#line 3396
  if (of_ptvp) {
    {
#line 3397
    destruct_scsi_pt_obj(of_ptvp);
#line 3398
    of_ptvp = (struct sg_pt_base *)((void *)0);
    }
  }
#line 3400
  return;
}
}
#line 3406 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int count_calculate(struct opts_t *op ) 
{ 
  int64_t in_num_sect ;
  int64_t out_num_sect ;
  int64_t ibytes ;
  int64_t obytes ;
  int64_t ibk ;
  int valid_resume ;
  int in_sect_sz ;
  int out_sect_sz ;
  int res ;

  {
  {
#line 3409
  in_num_sect = (int64_t )-1;
#line 3410
  out_num_sect = (int64_t )-1;
#line 3412
  valid_resume = 0;
#line 3415
  res = calc_count(op, & in_num_sect, & in_sect_sz, & out_num_sect, & out_sect_sz);
  }
#line 3415
  if (res) {
#line 3417
    return (res);
  }
#line 3418
  if (0 == (op->oflagp)->resume) {
#line 3418
    if (dd_count > 0L) {
#line 3419
      return (0);
    }
  }
#line 3420
  if (verbose > 2) {
    {
#line 3421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"calc_count: in_num_sect=%ld, out_num_sect=%ld\n",
            in_num_sect, out_num_sect);
    }
  }
#line 3423
  if (op->skip) {
#line 3423
    if (4 == op->in_type) {
#line 3423
      if (op->skip > in_num_sect) {
        {
#line 3425
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot skip to specified offset on %s\n",
                op->inf);
#line 3427
        dd_count = (int64_t )0;
        }
#line 3428
        return (-1);
      }
    }
  }
#line 3430
  if ((op->oflagp)->resume) {
#line 3431
    if (4 == op->out_type) {
#line 3432
      if (out_num_sect < 0L) {
        {
#line 3433
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"resume cannot determine size of OFILE, ignore\n");
        }
      } else {
#line 3436
        valid_resume = 1;
      }
    } else {
      {
#line 3438
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"resume expects OFILE to be regular, ignore\n");
      }
    }
  }
#line 3440
  if (dd_count < 0L) {
#line 3440
    if (! valid_resume) {
#line 3442
      if (op->skip) {
#line 3442
        if (in_num_sect > op->skip) {
#line 3443
          in_num_sect -= op->skip;
        }
      }
#line 3445
      if (op->seek) {
#line 3445
        if (out_num_sect > op->seek) {
#line 3446
          out_num_sect -= op->seek;
        }
      }
#line 3447
      if (out_num_sect < 0L) {
#line 3447
        if (in_num_sect > 0L) {
#line 3448
          dd_count = in_num_sect;
        } else {
#line 3447
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3449
      if (! reading_fifo) {
#line 3451
        if (out_num_sect < 0L) {
#line 3451
          if (! (in_num_sect <= 0L)) {
#line 3451
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 3454
          if (in_num_sect > 0L) {
#line 3454
            ibytes = (int64_t )op->ibs * in_num_sect;
          } else {
#line 3454
            ibytes = (int64_t )0;
          }
#line 3455
          obytes = (int64_t )op->obs * out_num_sect;
#line 3456
          if (0L == ibytes) {
#line 3457
            dd_count = obytes / (int64_t )op->ibs;
          } else
#line 3458
          if (ibytes > obytes) {
#line 3458
            if (4 != op->out_type) {
#line 3459
              dd_count = obytes / (int64_t )op->ibs;
            } else {
#line 3461
              dd_count = in_num_sect;
            }
          } else {
#line 3461
            dd_count = in_num_sect;
          }
        }
      }
    }
  }
#line 3464
  if (valid_resume) {
#line 3465
    if (dd_count < 0L) {
#line 3466
      dd_count = in_num_sect - op->skip;
    }
#line 3467
    if (out_num_sect <= op->seek) {
      {
#line 3468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"resume finds no previous copy, restarting\n");
      }
    } else {
#line 3470
      obytes = (int64_t )op->obs * (out_num_sect - op->seek);
#line 3471
      ibk = obytes / (int64_t )op->ibs;
#line 3472
      if (ibk >= dd_count) {
        {
#line 3473
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"resume finds copy complete, exiting\n");
#line 3474
        dd_count = (int64_t )0;
        }
#line 3475
        return (-1);
      }
      {
#line 3478
      ibk = (ibk / (int64_t )op->bpt_i) * (int64_t )op->bpt_i;
#line 3479
      op->skip += ibk;
#line 3480
      op->seek += (ibk * (int64_t )op->ibs) / (int64_t )op->obs;
#line 3481
      dd_count -= ibk;
#line 3482
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"resume adjusting skip=%ld, seek=%ld, and count=%ld\n",
              op->skip, op->seek, dd_count);
      }
    }
  }
#line 3487
  return (0);
}
}
#line 3493 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
static int do_copy(struct opts_t *optsp , unsigned char *wrkPos , unsigned char *wrkPos2 ) 
{ 
  int ibpt ;
  int obpt ;
  int res ;
  int n ;
  int sparse_skip ;
  int sparing_skip ;
  int continual_read ;
  int ret ;
  int out_type ;
  struct cp_state_t cp_st ;
  struct cp_state_t *csp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3498
  ret = 0;
#line 3499
  out_type = optsp->out_type;
#line 3503
  if (dd_count <= 0L) {
#line 3503
    if (! reading_fifo) {
#line 3504
      return (0);
    }
  }
#line 3505
  if (reading_fifo) {
#line 3505
    if (dd_count < 0L) {
#line 3505
      tmp = 1;
    } else {
#line 3505
      tmp = 0;
    }
  } else {
#line 3505
    tmp = 0;
  }
  {
#line 3505
  continual_read = tmp;
#line 3506
  csp = & cp_st;
#line 3507
  memset((void *)csp, 0, sizeof(struct cp_state_t ));
#line 3508
  ibpt = optsp->bpt_i;
#line 3509
  obpt = (optsp->ibs * optsp->bpt_i) / optsp->obs;
#line 3510
  ret = cp_construct_pt_zero_buff(optsp, obpt);
  }
#line 3510
  if (ret) {
#line 3511
    goto copy_end;
  }
  {
#line 3515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3515
    if (! (dd_count > 0L)) {
#line 3515
      if (! continual_read) {
#line 3515
        goto while_break;
      }
    }
#line 3516
    csp->bytes_read = 0;
#line 3517
    csp->bytes_of = 0;
#line 3518
    csp->bytes_of2 = 0;
#line 3519
    sparing_skip = 0;
#line 3520
    sparse_skip = 0;
#line 3521
    if (dd_count >= (int64_t )ibpt) {
#line 3522
      csp->icbpt = ibpt;
#line 3523
      csp->ocbpt = obpt;
    } else
#line 3521
    if (continual_read) {
#line 3522
      csp->icbpt = ibpt;
#line 3523
      csp->ocbpt = obpt;
    } else {
#line 3525
      csp->icbpt = (int )dd_count;
#line 3526
      res = (int )dd_count;
#line 3527
      n = res * optsp->ibs;
#line 3528
      csp->ocbpt = n / optsp->obs;
#line 3529
      if (n % optsp->obs) {
        {
#line 3530
        (csp->ocbpt) ++;
#line 3531
        memset((void *)wrkPos, 0, (size_t )(optsp->ibs * ibpt));
        }
      }
    }
#line 3536
    if (2 & optsp->in_type) {
      {
#line 3537
      ret = cp_read_pt(optsp, csp, wrkPos);
      }
#line 3537
      if (ret) {
#line 3538
        goto while_break;
      }
    } else {
      {
#line 3540
      ret = cp_read_block_reg(optsp, csp, wrkPos);
      }
#line 3540
      if (ret) {
#line 3541
        goto while_break;
      }
    }
#line 3543
    if (0 == csp->icbpt) {
#line 3544
      goto while_break;
    }
#line 3546
    if (optsp->out2fd >= 0) {
      {
#line 3546
      ret = cp_write_of2(optsp, csp, wrkPos);
      }
#line 3546
      if (ret) {
#line 3548
        goto while_break;
      }
    }
#line 3550
    if ((optsp->oflagp)->sparse) {
      {
#line 3551
      n = csp->ocbpt * optsp->obs + csp->partial_write_bytes;
#line 3552
      tmp___0 = memcmp((void const   *)wrkPos, (void const   *)zeros_buff, (size_t )n);
      }
#line 3552
      if (0 == tmp___0) {
#line 3553
        sparse_skip = 1;
#line 3554
        if ((optsp->oflagp)->wsame16) {
#line 3554
          if (2 & out_type) {
            {
#line 3555
            res = pt_write_same16(optsp->outfd, 1, zeros_buff, optsp->obs, csp->ocbpt,
                                  optsp->seek);
            }
#line 3557
            if (res) {
#line 3558
              trim_errs ++;
            }
          }
        }
      } else
#line 3560
      if (optsp->obpc) {
        {
#line 3561
        ret = cp_finer_comp_wr(optsp, csp, wrkPos, zeros_buff);
        }
#line 3562
        if (ret) {
#line 3563
          goto while_break;
        }
#line 3564
        goto bypass_write;
      }
    }
#line 3567
    if ((optsp->oflagp)->sparing) {
#line 3567
      if (! sparse_skip) {
#line 3569
        if (2 & out_type) {
          {
#line 3570
          res = cp_read_of_pt(optsp, csp, wrkPos2);
          }
        } else {
          {
#line 3572
          res = cp_read_of_block_reg(optsp, csp, wrkPos2);
          }
        }
#line 3573
        if (0 == res) {
          {
#line 3574
          n = csp->ocbpt * optsp->obs + csp->partial_write_bytes;
#line 3575
          tmp___1 = memcmp((void const   *)wrkPos, (void const   *)wrkPos2, (size_t )n);
          }
#line 3575
          if (0 == tmp___1) {
#line 3576
            sparing_skip = 1;
          } else
#line 3577
          if (optsp->obpc) {
            {
#line 3578
            ret = cp_finer_comp_wr(optsp, csp, wrkPos, wrkPos2);
            }
#line 3579
            if (ret) {
#line 3580
              goto while_break;
            }
#line 3581
            goto bypass_write;
          }
        } else {
#line 3584
          ret = res;
#line 3585
          goto while_break;
        }
      }
    }
#line 3589
    if (sparing_skip) {
#line 3589
      goto _L;
    } else
#line 3589
    if (sparse_skip) {
      _L: /* CIL Label */ 
#line 3590
      out_sparse += (int64_t )csp->ocbpt;
#line 3591
      if (csp->partial_write_bytes > 0) {
#line 3592
        out_sparse_partial ++;
      }
    } else
#line 3594
    if (2 & out_type) {
      {
#line 3595
      ret = cp_write_pt(optsp, csp, 0, csp->ocbpt, wrkPos);
      }
#line 3595
      if (ret) {
#line 3596
        goto while_break;
      }
    } else
#line 3597
    if (! (8 & out_type)) {
      {
#line 3599
      ret = cp_write_block_reg(optsp, csp, 0, csp->ocbpt, wrkPos);
      }
#line 3599
      if (ret) {
#line 3601
        goto while_break;
      }
    }
    bypass_write: 
    {
#line 3605
    do_fadvise(optsp, csp->bytes_read, csp->bytes_of, csp->bytes_of2);
    }
#line 3607
    if (dd_count > 0L) {
#line 3608
      dd_count -= (int64_t )csp->icbpt;
    }
#line 3609
    optsp->skip += (int64_t )csp->icbpt;
#line 3610
    optsp->seek += (int64_t )csp->ocbpt;
#line 3611
    if (csp->leave_after_write) {
#line 3612
      ret = csp->leave_reason;
#line 3613
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3618
  if (4 & out_type) {
#line 3618
    if (0 == (optsp->oflagp)->nowrite) {
#line 3618
      if ((optsp->oflagp)->sparse) {
        {
#line 3620
        cp_sparse_cleanup(optsp, csp);
        }
      }
    }
  }
#line 3622
  if (! (2 & out_type)) {
#line 3622
    if (! (8 & out_type)) {
#line 3622
      if (! (64 & out_type)) {
#line 3622
        if (! (128 & out_type)) {
#line 3627
          if ((optsp->oflagp)->fdatasync) {
            {
#line 3628
            tmp___2 = fdatasync(optsp->outfd);
            }
#line 3628
            if (tmp___2 < 0) {
              {
#line 3629
              perror("fdatasync() error");
              }
            }
#line 3630
            if (verbose) {
              {
#line 3631
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Called fdatasync() on %s successfully\n",
                      optsp->outf);
              }
            }
          } else
#line 3636
          if ((optsp->oflagp)->fsync) {
            {
#line 3637
            tmp___3 = fsync(optsp->outfd);
            }
#line 3637
            if (tmp___3 < 0) {
              {
#line 3638
              perror("fsync() error");
              }
            }
#line 3639
            if (verbose) {
              {
#line 3640
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Called fsync() on %s successfully\n",
                      optsp->outf);
              }
            }
          }
        }
      }
    }
  }
  copy_end: 
  {
#line 3646
  cp_destruct_pt();
  }
#line 3647
  return (ret);
}
}
#line 3651 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/ddpt.c"
int main(int argc , char **argv ) 
{ 
  int res ;
  int fd ;
  unsigned char *wrkBuff ;
  unsigned char *wrkPos ;
  unsigned char *wrkBuff2 ;
  unsigned char *wrkPos2 ;
  int ret ;
  int started_copy ;
  struct opts_t opts ;
  struct flags_t iflag ;
  struct flags_t oflag ;
  int *tmp ;
  char *tmp___0 ;
  FILE *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t psz ;
  long tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 3655
  wrkBuff = (unsigned char *)((void *)0);
#line 3657
  wrkBuff2 = (unsigned char *)((void *)0);
#line 3658
  wrkPos2 = (unsigned char *)((void *)0);
#line 3659
  ret = 0;
#line 3660
  started_copy = 0;
#line 3665
  memset((void *)(& opts), 0, sizeof(opts));
#line 3666
  opts.bpt_i = 128;
#line 3667
  opts.out_type = 1;
#line 3668
  opts.in_type = 1;
#line 3669
  memset((void *)(& iflag), 0, sizeof(iflag));
#line 3670
  memset((void *)(& oflag), 0, sizeof(oflag));
#line 3671
  opts.iflagp = & iflag;
#line 3672
  opts.oflagp = & oflag;
#line 3673
  opts.infd = -1;
#line 3674
  opts.outfd = -1;
#line 3675
  opts.out2fd = -1;
#line 3676
  iflag.cdbsz = 10;
#line 3677
  oflag.cdbsz = 10;
#line 3678
  res = process_cl(& opts, argc, argv);
  }
#line 3679
  if (res < 0) {
#line 3680
    return (0);
  } else
#line 3681
  if (res > 0) {
#line 3682
    return (res);
  }
#line 3689
  if (quiet) {
    {
#line 3690
    tmp___1 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                      (FILE */* __restrict  */)stderr);
    }
#line 3690
    if ((unsigned long )((void *)0) == (unsigned long )tmp___1) {
      {
#line 3691
      tmp = __errno_location();
#line 3691
      tmp___0 = safe_strerror(*tmp);
#line 3691
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"freopen: failed to redirect stderr to /dev/null : %s\n",
              tmp___0);
      }
    }
  }
  {
#line 3695
  register_handler(2, & interrupt_handler);
#line 3696
  register_handler(3, & interrupt_handler);
#line 3697
  register_handler(13, & interrupt_handler);
#line 3698
  register_handler(10, & siginfo_handler);
#line 3717
  (opts.iflagp)->pdt = -1;
#line 3718
  (opts.oflagp)->pdt = -1;
  }
#line 3719
  if (opts.inf[0]) {
#line 3720
    if (45 == (int )opts.inf[0]) {
#line 3720
      if (0 == (int )opts.inf[1]) {
#line 3721
        fd = 0;
#line 3722
        opts.in_type = 64;
#line 3723
        reading_fifo ++;
#line 3724
        if (verbose) {
          {
#line 3725
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> Input file type: fifo [stdin, stdout, named pipe]\n");
          }
        }
      } else {
#line 3720
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 3728
      fd = open_if(& opts, verbose);
      }
#line 3729
      if (fd < 0) {
#line 3730
        return (- fd);
      }
    }
#line 3732
    opts.infd = fd;
  } else {
    {
#line 3734
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'if=IFILE\' option must be given. For stdin as input use \'if=-\'\n");
#line 3736
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For more information use \'--help\'\n");
    }
#line 3737
    return (1);
  }
#line 3740
  if (0 == (int )opts.outf[0]) {
    {
#line 3741
    strcpy((char */* __restrict  */)(opts.outf), (char const   */* __restrict  */)".");
    }
  }
#line 3742
  if (45 == (int )opts.outf[0]) {
#line 3742
    if (0 == (int )opts.outf[1]) {
#line 3743
      fd = 1;
#line 3744
      opts.out_type = 64;
#line 3745
      out_type_hold = opts.out_type;
#line 3746
      if (verbose) {
        {
#line 3747
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> Output file type: fifo [stdin, stdout, named pipe]\n");
        }
      }
    } else {
#line 3742
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3750
    fd = open_of(& opts, verbose);
    }
#line 3751
    if (fd < -1) {
#line 3752
      return (- fd);
    }
  }
#line 3754
  opts.outfd = fd;
#line 3756
  if (opts.out2f[0]) {
#line 3757
    if (45 == (int )opts.out2f[0]) {
#line 3757
      if (0 == (int )opts.out2f[1]) {
#line 3758
        fd = 1;
#line 3759
        opts.out2_type = 64;
#line 3760
        if (verbose) {
          {
#line 3761
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> Output 2 file type: fifo  [stdin, stdout, named pipe]\n");
          }
        }
      } else {
#line 3757
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 3764
      opts.out2_type = dd_filetype((char const   *)(opts.out2f));
      }
#line 3765
      if (8 & opts.out2_type) {
#line 3766
        fd = -1;
      } else
#line 3767
      if (4 & opts.out2_type) {
#line 3767
        goto _L___1;
      } else
#line 3767
      if (64 & opts.out2_type) {
        _L___1: /* CIL Label */ 
        {
#line 3773
        fd = open((char const   *)(opts.out2f), 65, 438);
        }
#line 3773
        if (fd < 0) {
          {
#line 3774
          tmp___2 = __errno_location();
#line 3774
          res = *tmp___2;
#line 3775
          tmp___3 = __errno_location();
#line 3775
          tmp___4 = safe_strerror(*tmp___3);
#line 3775
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open %s for writing: %s\n",
                  opts.out2f, tmp___4);
          }
#line 3777
          return (res);
        }
        {
#line 3779
        tmp___5 = sg_set_binary_mode(fd);
        }
#line 3779
        if (tmp___5 < 0) {
          {
#line 3780
          perror("sg_set_binary_mode");
          }
        }
#line 3781
        if (verbose) {
          {
#line 3782
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> Output 2 file type: regular\n");
          }
        }
      } else {
        {
#line 3769
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: output 2 file type must be regular file or fifo\n");
        }
#line 3771
        return (15);
      }
    }
  } else {
#line 3786
    fd = -1;
  }
#line 3787
  opts.out2fd = fd;
#line 3789
  if ((opts.iflagp)->sparse) {
#line 3789
    if (! (opts.oflagp)->sparse) {
#line 3790
      if (8 & opts.out_type) {
        {
#line 3791
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sparse flag usually ignored on input; set it on output in this case\n");
#line 3793
        ((opts.oflagp)->sparse) ++;
        }
      } else {
        {
#line 3795
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sparse flag ignored on input\n");
        }
      }
    }
  }
#line 3797
  if (oflag.sparse) {
#line 3798
    if (64 & opts.out_type) {
      {
#line 3799
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oflag=sparse needs seekable output file, ignore\n");
#line 3801
      oflag.sparse = 0;
      }
    } else {
#line 3803
      out_sparse_active = 1;
#line 3804
      if (oflag.wsame16) {
#line 3805
        out_trim_active = 1;
      }
    }
  }
#line 3808
  if (oflag.sparing) {
#line 3809
    if (8 & opts.out_type) {
      {
#line 3810
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oflag=sparing needs a readable and seekable output file, ignore\n");
#line 3812
      oflag.sparing = 0;
      }
    } else
#line 3809
    if (64 & opts.out_type) {
      {
#line 3810
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oflag=sparing needs a readable and seekable output file, ignore\n");
#line 3812
      oflag.sparing = 0;
      }
    } else {
#line 3814
      out_sparing_active = 1;
    }
  }
  {
#line 3817
  ret = count_calculate(& opts);
  }
#line 3817
  if (ret) {
#line 3818
    goto cleanup;
  }
#line 3819
  if (dd_count < 0L) {
#line 3819
    if (! reading_fifo) {
      {
#line 3820
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t calculate count, please give one\n");
      }
#line 3821
      return (99);
    }
  }
#line 3823
  if (! opts.cdbsz_given) {
#line 3824
    if (2 & opts.in_type) {
#line 3824
      if (16 != (opts.iflagp)->cdbsz) {
#line 3824
        if (dd_count + opts.skip > 4294967295L) {
#line 3824
          goto _L___3;
        } else
#line 3824
        if (opts.bpt_i > 65535) {
          _L___3: /* CIL Label */ 
#line 3827
          if (verbose > 0) {
            {
#line 3828
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SCSI command size increased from 10 to 16 bytes on %s\n",
                    opts.inf);
            }
          }
#line 3830
          (opts.iflagp)->cdbsz = 16;
        }
      }
    }
#line 3832
    if (2 & opts.out_type) {
#line 3832
      if (16 != (opts.oflagp)->cdbsz) {
#line 3832
        if (dd_count + opts.seek > 4294967295L) {
#line 3832
          goto _L___4;
        } else
#line 3832
        if ((opts.ibs * opts.bpt_i) / opts.obs > 65535) {
          _L___4: /* CIL Label */ 
#line 3836
          if (verbose) {
            {
#line 3837
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SCSI command size increased from 12 to 16 bytes on %s\n",
                    opts.outf);
            }
          }
#line 3839
          (opts.oflagp)->cdbsz = 16;
        }
      }
    }
  }
#line 3843
  if ((opts.iflagp)->direct) {
#line 3843
    goto _L___5;
  } else
#line 3843
  if ((opts.oflagp)->direct) {
    _L___5: /* CIL Label */ 
    {
#line 3849
    tmp___6 = sysconf(30);
#line 3849
    psz = (size_t )tmp___6;
#line 3852
    tmp___7 = calloc((size_t )(opts.ibs * opts.bpt_i) + psz, (size_t )1);
#line 3852
    wrkBuff = (unsigned char *)tmp___7;
    }
#line 3853
    if ((unsigned long )((unsigned char *)0) == (unsigned long )wrkBuff) {
      {
#line 3854
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough user memory for aligned usage\n");
      }
#line 3855
      return (99);
    }
#line 3858
    wrkPos = (unsigned char *)((((unsigned long )wrkBuff + psz) - 1UL) & ~ (psz - 1UL));
#line 3860
    if ((opts.oflagp)->sparing) {
      {
#line 3861
      tmp___8 = calloc((size_t )(opts.ibs * opts.bpt_i) + psz, (size_t )1);
#line 3861
      wrkBuff2 = (unsigned char *)tmp___8;
      }
#line 3862
      if ((unsigned long )((unsigned char *)0) == (unsigned long )wrkBuff2) {
        {
#line 3863
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough user memory for aligned usage(2)\n");
        }
#line 3865
        return (99);
      }
#line 3867
      wrkPos2 = (unsigned char *)((((unsigned long )wrkBuff2 + psz) - 1UL) & ~ (psz - 1UL));
    }
  } else {
    {
#line 3871
    tmp___9 = calloc((size_t )(opts.ibs * opts.bpt_i), (size_t )1);
#line 3871
    wrkBuff = (unsigned char *)tmp___9;
    }
#line 3872
    if ((unsigned long )((unsigned char *)0) == (unsigned long )wrkBuff) {
      {
#line 3873
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough user memory\n");
      }
#line 3874
      return (99);
    }
#line 3876
    wrkPos = wrkBuff;
#line 3877
    if ((opts.oflagp)->sparing) {
      {
#line 3878
      tmp___10 = calloc((size_t )(opts.ibs * opts.bpt_i), (size_t )1);
#line 3878
      wrkBuff2 = (unsigned char *)tmp___10;
      }
#line 3879
      if ((unsigned long )((unsigned char *)0) == (unsigned long )wrkBuff2) {
        {
#line 3880
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough user memory(2)\n");
        }
#line 3881
        return (99);
      }
#line 3883
      wrkPos2 = wrkBuff2;
    }
  }
#line 3887
  if (verbose) {
    {
#line 3888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skip=%ld (blocks on input), seek=%ld (blocks on output)\n",
            opts.skip, opts.seek);
    }
#line 3890
    if (verbose > 1) {
      {
#line 3891
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ibs=%d bytes, obs=%d bytes, OBPC=%d\n",
              opts.ibs, opts.obs, opts.obpc);
      }
    }
    {
#line 3893
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  initial count=%ld (blocks of input), blocks_per_transfer=%d\n",
            dd_count, opts.bpt_i);
    }
  }
#line 3896
  read1_or_transfer = ! (! (8 & opts.out_type));
#line 3897
  if (read1_or_transfer) {
#line 3897
    if (! opts.outf_given) {
#line 3897
      if (dd_count > 0L) {
        {
#line 3899
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output file not specified so no copy, just reading input\n");
        }
      } else
#line 3897
      if (reading_fifo) {
        {
#line 3899
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output file not specified so no copy, just reading input\n");
        }
      }
    }
  }
#line 3903
  if (do_time) {
    {
#line 3904
    start_tm.tv_sec = (__time_t )0;
#line 3905
    start_tm.tv_nsec = (__syscall_slong_t )0;
#line 3906
    tmp___11 = clock_gettime(1, & start_tm);
    }
#line 3906
    if (0 == tmp___11) {
#line 3907
      start_tm_valid = 1;
    }
  }
#line 3919
  if ((opts.iflagp)->errblk) {
    {
#line 3920
    open_errblk();
    }
  }
  {
#line 3924
  started_copy ++;
#line 3925
  ret = do_copy(& opts, wrkPos, wrkPos2);
  }
#line 3928
  if ((opts.iflagp)->errblk) {
    {
#line 3929
    close_errblk();
    }
  }
  {
#line 3932
  print_stats("");
  }
#line 3933
  if (sum_of_resids) {
    {
#line 3934
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Non-zero sum of residual counts=%d\n",
            sum_of_resids);
    }
  }
#line 3936
  if (do_time) {
    {
#line 3937
    calc_duration_throughput("", 0);
    }
  }
#line 3939
  if ((opts.oflagp)->ssync) {
#line 3939
    if (2 & opts.out_type) {
      {
#line 3940
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> SCSI synchronizing cache on %s\n",
              opts.outf);
#line 3941
      res = sg_ll_sync_cache_10(opts.outfd, 0, 0, 0, 0U, 0U, 0, 0);
      }
#line 3942
      if (6 == res) {
        {
#line 3943
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unit attention (out, sync cache), continuing\n");
#line 3945
        res = sg_ll_sync_cache_10(opts.outfd, 0, 0, 0, 0U, 0U, 0, 0);
        }
      }
#line 3947
      if (0 != res) {
        {
#line 3948
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to do SCSI synchronize cache\n");
        }
      }
    }
  }
  cleanup: 
#line 3952
  if (wrkBuff) {
    {
#line 3953
    free((void *)wrkBuff);
    }
  }
#line 3954
  if (wrkBuff2) {
    {
#line 3955
    free((void *)wrkBuff2);
    }
  }
#line 3956
  if (zeros_buff) {
    {
#line 3957
    free((void *)zeros_buff);
    }
  }
#line 3958
  if (2 & opts.in_type) {
    {
#line 3959
    scsi_pt_close_device(opts.infd);
    }
  } else
#line 3960
  if (opts.infd >= 0) {
#line 3960
    if (0 != opts.infd) {
      {
#line 3961
      close(opts.infd);
      }
    }
  }
#line 3962
  if (2 & opts.out_type) {
    {
#line 3963
    scsi_pt_close_device(opts.outfd);
    }
  }
#line 3964
  if (opts.outfd >= 0) {
#line 3964
    if (1 != opts.outfd) {
#line 3964
      if (! (8 & opts.out_type)) {
        {
#line 3966
        close(opts.outfd);
        }
      }
    }
  }
#line 3967
  if (opts.out2fd >= 0) {
#line 3967
    if (1 != opts.out2fd) {
      {
#line 3968
      close(opts.out2fd);
      }
    }
  }
#line 3969
  if (0 == ret) {
#line 3969
    if (err_to_report) {
#line 3970
      ret = err_to_report;
    }
  }
#line 3971
  if (started_copy) {
#line 3971
    if (0L != dd_count) {
#line 3971
      if (! reading_fifo) {
#line 3972
        if (0 == ret) {
          {
#line 3973
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Early termination, EOF on input?\n");
          }
        } else
#line 3974
        if (3 == ret) {
          {
#line 3975
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Early termination, medium error occurred\n");
          }
        } else {
          {
#line 3977
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Early termination, some error occurred\n");
          }
        }
      }
    }
  }
#line 3979
  if (ret >= 0) {
#line 3979
    tmp___12 = ret;
  } else {
#line 3979
    tmp___12 = 99;
  }
#line 3979
  return (tmp___12);
}
}
#line 20 "../include/sg_cmds_mmc.h"
int sg_ll_get_config(int sg_fd , int rt , int starting , void *resp , int mx_resp_len ,
                     int noisy , int verbose___0 ) ;
#line 27
int sg_ll_get_performance(int sg_fd , int data_type , unsigned int starting_lba ,
                          int max_num_desc , int ttype , void *resp , int mx_resp_len ,
                          int noisy , int verbose___0 ) ;
#line 37
int sg_ll_set_cd_speed(int sg_fd , int rot_control , int drv_read_speed , int drv_write_speed ,
                       int noisy , int verbose___0 ) ;
#line 45
int sg_ll_set_streaming(int sg_fd , int type , void *paramp , int param_len , int noisy ,
                        int verbose___0 ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_mmc.c"
int sg_ll_set_cd_speed(int sg_fd , int rot_control , int drv_read_speed , int drv_write_speed ,
                       int noisy , int verbose___0 ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char scsCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 49
  scsCmdBlk[0] = (unsigned char)187;
#line 49
  scsCmdBlk[1] = (unsigned char)0;
#line 49
  scsCmdBlk[2] = (unsigned char)0;
#line 49
  scsCmdBlk[3] = (unsigned char)0;
#line 49
  scsCmdBlk[4] = (unsigned char)0;
#line 49
  scsCmdBlk[5] = (unsigned char)0;
#line 49
  scsCmdBlk[6] = (unsigned char)0;
#line 49
  scsCmdBlk[7] = (unsigned char)0;
#line 49
  scsCmdBlk[8] = (unsigned char)0;
#line 49
  scsCmdBlk[9] = (unsigned char)0;
#line 49
  scsCmdBlk[10] = (unsigned char)0;
#line 49
  scsCmdBlk[11] = (unsigned char)0;
#line 54
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 55
    sg_warnings_strm = stderr;
  }
#line 56
  scsCmdBlk[1] = (unsigned char )((int )scsCmdBlk[1] | (rot_control & 3));
#line 57
  scsCmdBlk[2] = (unsigned char )((drv_read_speed >> 8) & 255);
#line 58
  scsCmdBlk[3] = (unsigned char )(drv_read_speed & 255);
#line 59
  scsCmdBlk[4] = (unsigned char )((drv_write_speed >> 8) & 255);
#line 60
  scsCmdBlk[5] = (unsigned char )(drv_write_speed & 255);
#line 62
  if (verbose___0) {
    {
#line 63
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    set cd speed cdb: ");
#line 64
    k = 0;
    }
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! (k < 12)) {
#line 64
        goto while_break;
      }
      {
#line 65
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )scsCmdBlk[k]);
#line 64
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 66
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 68
  ptvp = construct_scsi_pt_obj();
  }
#line 69
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 70
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"set cd speed: out of memory\n");
    }
#line 71
    return (-1);
  }
  {
#line 73
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(scsCmdBlk), (int )sizeof(scsCmdBlk));
#line 74
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 75
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 76
  ret = sg_cmds_process_resp(ptvp, "set cd speed", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 78
  if (! (-1 == ret)) {
#line 80
    if (-2 == ret) {
      {
#line 86
      if (sense_cat == 11) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 5) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 9) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 6) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 2) {
#line 86
        goto case_11;
      }
#line 90
      if (sense_cat == 20) {
#line 90
        goto case_20;
      }
#line 90
      if (sense_cat == 21) {
#line 90
        goto case_20;
      }
#line 93
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 87
      ret = sense_cat;
#line 88
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 91
      ret = 0;
#line 92
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 94
      ret = -1;
#line 95
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 98
      ret = 0;
    }
  }
  {
#line 100
  destruct_scsi_pt_obj(ptvp);
  }
#line 101
  return (ret);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_mmc.c"
int sg_ll_get_config(int sg_fd , int rt , int starting , void *resp , int mx_resp_len ,
                     int noisy , int verbose___0 ) 
{ 
  int res ;
  int k ;
  int ret ;
  int sense_cat ;
  unsigned char gcCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  unsigned char *ucp ;
  int len ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 113
  gcCmdBlk[0] = (unsigned char)70;
#line 113
  gcCmdBlk[1] = (unsigned char)0;
#line 113
  gcCmdBlk[2] = (unsigned char)0;
#line 113
  gcCmdBlk[3] = (unsigned char)0;
#line 113
  gcCmdBlk[4] = (unsigned char)0;
#line 113
  gcCmdBlk[5] = (unsigned char)0;
#line 113
  gcCmdBlk[6] = (unsigned char)0;
#line 113
  gcCmdBlk[7] = (unsigned char)0;
#line 113
  gcCmdBlk[8] = (unsigned char)0;
#line 113
  gcCmdBlk[9] = (unsigned char)0;
#line 118
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 119
    sg_warnings_strm = stderr;
  }
#line 120
  if (rt < 0) {
    {
#line 121
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad rt value: %d\n",
            rt);
    }
#line 122
    return (-1);
  } else
#line 120
  if (rt > 3) {
    {
#line 121
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad rt value: %d\n",
            rt);
    }
#line 122
    return (-1);
  }
#line 124
  gcCmdBlk[1] = (unsigned char )(rt & 3);
#line 125
  if (starting < 0) {
    {
#line 126
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad starting field number: 0x%x\n",
            starting);
    }
#line 128
    return (-1);
  } else
#line 125
  if (starting > 65535) {
    {
#line 126
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad starting field number: 0x%x\n",
            starting);
    }
#line 128
    return (-1);
  }
#line 130
  gcCmdBlk[2] = (unsigned char )((starting >> 8) & 255);
#line 131
  gcCmdBlk[3] = (unsigned char )(starting & 255);
#line 132
  if (mx_resp_len < 0) {
    {
#line 133
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad mx_resp_len: 0x%x\n",
            starting);
    }
#line 134
    return (-1);
  } else
#line 132
  if (mx_resp_len > 65535) {
    {
#line 133
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad mx_resp_len: 0x%x\n",
            starting);
    }
#line 134
    return (-1);
  }
#line 136
  gcCmdBlk[7] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 137
  gcCmdBlk[8] = (unsigned char )(mx_resp_len & 255);
#line 139
  if (verbose___0) {
    {
#line 140
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Get Configuration cdb: ");
#line 141
    k = 0;
    }
    {
#line 141
    while (1) {
      while_continue: /* CIL Label */ ;
#line 141
      if (! (k < 10)) {
#line 141
        goto while_break;
      }
      {
#line 142
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )gcCmdBlk[k]);
#line 141
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 143
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 146
  ptvp = construct_scsi_pt_obj();
  }
#line 147
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 148
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"get configuration: out of memory\n");
    }
#line 149
    return (-1);
  }
  {
#line 151
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(gcCmdBlk), (int )sizeof(gcCmdBlk));
#line 152
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 153
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 154
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 155
  ret = sg_cmds_process_resp(ptvp, "get configuration", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 157
  if (! (-1 == ret)) {
#line 159
    if (-2 == ret) {
      {
#line 164
      if (sense_cat == 11) {
#line 164
        goto case_11;
      }
#line 164
      if (sense_cat == 6) {
#line 164
        goto case_11;
      }
#line 164
      if (sense_cat == 5) {
#line 164
        goto case_11;
      }
#line 164
      if (sense_cat == 9) {
#line 164
        goto case_11;
      }
#line 168
      if (sense_cat == 20) {
#line 168
        goto case_20;
      }
#line 168
      if (sense_cat == 21) {
#line 168
        goto case_20;
      }
#line 171
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 165
      ret = sense_cat;
#line 166
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 169
      ret = 0;
#line 170
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 172
      ret = -1;
#line 173
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 176
      if (verbose___0 > 2) {
#line 176
        if (ret > 3) {
#line 180
          ucp = (unsigned char *)resp;
#line 181
          len = (((((int )*(ucp + 0) << 24) + ((int )*(ucp + 1) << 16)) + ((int )*(ucp + 2) << 8)) + (int )*(ucp + 3)) + 4;
#line 183
          if (len < 0) {
#line 184
            len = 0;
          }
#line 185
          if (ret < len) {
#line 185
            len = ret;
          } else {
#line 185
            len = len;
          }
#line 186
          if (len > 256) {
#line 186
            tmp = ", first 256 bytes";
          } else {
#line 186
            tmp = "";
          }
          {
#line 186
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    get configuration: response%s\n",
                  tmp);
          }
#line 188
          if (len > 256) {
#line 188
            tmp___0 = 256;
          } else {
#line 188
            tmp___0 = len;
          }
          {
#line 188
          dStrHex((char const   *)resp, tmp___0, -1);
          }
        }
      }
#line 190
      ret = 0;
    }
  }
  {
#line 192
  destruct_scsi_pt_obj(ptvp);
  }
#line 193
  return (ret);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_mmc.c"
int sg_ll_get_performance(int sg_fd , int data_type , unsigned int starting_lba ,
                          int max_num_desc , int ttype , void *resp , int mx_resp_len ,
                          int noisy , int verbose___0 ) 
{ 
  int res ;
  int k ;
  int ret ;
  int sense_cat ;
  unsigned char gpCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  unsigned char *ucp ;
  int len ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 206
  gpCmdBlk[0] = (unsigned char)172;
#line 206
  gpCmdBlk[1] = (unsigned char)0;
#line 206
  gpCmdBlk[2] = (unsigned char)0;
#line 206
  gpCmdBlk[3] = (unsigned char)0;
#line 206
  gpCmdBlk[4] = (unsigned char)0;
#line 206
  gpCmdBlk[5] = (unsigned char)0;
#line 206
  gpCmdBlk[6] = (unsigned char)0;
#line 206
  gpCmdBlk[7] = (unsigned char)0;
#line 206
  gpCmdBlk[8] = (unsigned char)0;
#line 206
  gpCmdBlk[9] = (unsigned char)0;
#line 206
  gpCmdBlk[10] = (unsigned char)0;
#line 206
  gpCmdBlk[11] = (unsigned char)0;
#line 211
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 212
    sg_warnings_strm = stderr;
  }
#line 213
  if (data_type < 0) {
    {
#line 214
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad data_type value: %d\n",
            data_type);
    }
#line 215
    return (-1);
  } else
#line 213
  if (data_type > 31) {
    {
#line 214
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad data_type value: %d\n",
            data_type);
    }
#line 215
    return (-1);
  }
#line 217
  gpCmdBlk[1] = (unsigned char )(data_type & 31);
#line 218
  gpCmdBlk[2] = (unsigned char )((starting_lba >> 24) & 255U);
#line 219
  gpCmdBlk[3] = (unsigned char )((starting_lba >> 16) & 255U);
#line 220
  gpCmdBlk[4] = (unsigned char )((starting_lba >> 8) & 255U);
#line 221
  gpCmdBlk[3] = (unsigned char )(starting_lba & 255U);
#line 222
  if (max_num_desc < 0) {
    {
#line 223
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad max_num_desc: 0x%x\n",
            max_num_desc);
    }
#line 224
    return (-1);
  } else
#line 222
  if (max_num_desc > 65535) {
    {
#line 223
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad max_num_desc: 0x%x\n",
            max_num_desc);
    }
#line 224
    return (-1);
  }
#line 226
  gpCmdBlk[8] = (unsigned char )((max_num_desc >> 8) & 255);
#line 227
  gpCmdBlk[9] = (unsigned char )(max_num_desc & 255);
#line 228
  if (ttype < 0) {
    {
#line 229
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad type: 0x%x\n",
            ttype);
    }
#line 230
    return (-1);
  } else
#line 228
  if (ttype > 255) {
    {
#line 229
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad type: 0x%x\n",
            ttype);
    }
#line 230
    return (-1);
  }
#line 232
  gpCmdBlk[10] = (unsigned char )ttype;
#line 234
  if (verbose___0) {
    {
#line 235
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Get Performance cdb: ");
#line 236
    k = 0;
    }
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (k < 12)) {
#line 236
        goto while_break;
      }
      {
#line 237
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )gpCmdBlk[k]);
#line 236
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 238
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 241
  ptvp = construct_scsi_pt_obj();
  }
#line 242
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 243
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"get performance: out of memory\n");
    }
#line 244
    return (-1);
  }
  {
#line 246
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(gpCmdBlk), (int )sizeof(gpCmdBlk));
#line 247
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 248
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 249
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 250
  ret = sg_cmds_process_resp(ptvp, "get performance", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 252
  if (! (-1 == ret)) {
#line 254
    if (-2 == ret) {
      {
#line 259
      if (sense_cat == 11) {
#line 259
        goto case_11;
      }
#line 259
      if (sense_cat == 6) {
#line 259
        goto case_11;
      }
#line 259
      if (sense_cat == 5) {
#line 259
        goto case_11;
      }
#line 259
      if (sense_cat == 9) {
#line 259
        goto case_11;
      }
#line 263
      if (sense_cat == 20) {
#line 263
        goto case_20;
      }
#line 263
      if (sense_cat == 21) {
#line 263
        goto case_20;
      }
#line 266
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 260
      ret = sense_cat;
#line 261
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 264
      ret = 0;
#line 265
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 267
      ret = -1;
#line 268
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 271
      if (verbose___0 > 2) {
#line 271
        if (ret > 3) {
#line 275
          ucp = (unsigned char *)resp;
#line 276
          len = (((((int )*(ucp + 0) << 24) + ((int )*(ucp + 1) << 16)) + ((int )*(ucp + 2) << 8)) + (int )*(ucp + 3)) + 4;
#line 278
          if (len < 0) {
#line 279
            len = 0;
          }
#line 280
          if (ret < len) {
#line 280
            len = ret;
          } else {
#line 280
            len = len;
          }
#line 281
          if (len > 256) {
#line 281
            tmp = ", first 256 bytes";
          } else {
#line 281
            tmp = "";
          }
          {
#line 281
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    get performance:: response%s\n",
                  tmp);
          }
#line 283
          if (len > 256) {
#line 283
            tmp___0 = 256;
          } else {
#line 283
            tmp___0 = len;
          }
          {
#line 283
          dStrHex((char const   *)resp, tmp___0, -1);
          }
        }
      }
#line 285
      ret = 0;
    }
  }
  {
#line 287
  destruct_scsi_pt_obj(ptvp);
  }
#line 288
  return (ret);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_cmds_mmc.c"
int sg_ll_set_streaming(int sg_fd , int type , void *paramp , int param_len , int noisy ,
                        int verbose___0 ) 
{ 
  int k ;
  int res ;
  int ret ;
  int sense_cat ;
  unsigned char ssCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 301
  ssCmdBlk[0] = (unsigned char)182;
#line 301
  ssCmdBlk[1] = (unsigned char)0;
#line 301
  ssCmdBlk[2] = (unsigned char)0;
#line 301
  ssCmdBlk[3] = (unsigned char)0;
#line 301
  ssCmdBlk[4] = (unsigned char)0;
#line 301
  ssCmdBlk[5] = (unsigned char)0;
#line 301
  ssCmdBlk[6] = (unsigned char)0;
#line 301
  ssCmdBlk[7] = (unsigned char)0;
#line 301
  ssCmdBlk[8] = (unsigned char)0;
#line 301
  ssCmdBlk[9] = (unsigned char)0;
#line 301
  ssCmdBlk[10] = (unsigned char)0;
#line 301
  ssCmdBlk[11] = (unsigned char)0;
#line 306
  ssCmdBlk[8] = (unsigned char )type;
#line 307
  ssCmdBlk[9] = (unsigned char )((param_len >> 8) & 255);
#line 308
  ssCmdBlk[10] = (unsigned char )(param_len & 255);
#line 309
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 310
    sg_warnings_strm = stderr;
  }
#line 311
  if (verbose___0) {
    {
#line 312
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    set streaming cdb: ");
#line 313
    k = 0;
    }
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! (k < 12)) {
#line 313
        goto while_break;
      }
      {
#line 314
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )ssCmdBlk[k]);
#line 313
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 315
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
#line 316
    if (verbose___0 > 1) {
#line 316
      if (paramp) {
#line 316
        if (param_len) {
          {
#line 317
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    set streaming parameter list:\n");
#line 319
          dStrHex((char const   *)paramp, param_len, -1);
          }
        }
      }
    }
  }
  {
#line 323
  ptvp = construct_scsi_pt_obj();
  }
#line 324
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 325
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"set streaming: out of memory\n");
    }
#line 326
    return (-1);
  }
  {
#line 328
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(ssCmdBlk), (int )sizeof(ssCmdBlk));
#line 329
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 330
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)((unsigned char *)paramp), param_len);
#line 331
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose___0);
#line 332
  ret = sg_cmds_process_resp(ptvp, "set streaming", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose___0, & sense_cat);
  }
#line 334
  if (! (-1 == ret)) {
#line 336
    if (-2 == ret) {
      {
#line 342
      if (sense_cat == 11) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 6) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 5) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 9) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 2) {
#line 342
        goto case_11;
      }
#line 346
      if (sense_cat == 20) {
#line 346
        goto case_20;
      }
#line 346
      if (sense_cat == 21) {
#line 346
        goto case_20;
      }
#line 349
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 343
      ret = sense_cat;
#line 344
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 347
      ret = 0;
#line 348
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 350
      ret = -1;
#line 351
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 354
      ret = 0;
    }
  }
  {
#line 355
  destruct_scsi_pt_obj(ptvp);
  }
#line 356
  return (ret);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 106 "../include/sg_lib.h"
char const   *sg_lib_version(void) ;
#line 111
int sg_get_command_size(unsigned char opcode ) ;
#line 116
void sg_get_command_name(unsigned char const   *cmdp , int peri_type , int buff_len ,
                         char *buff ) ;
#line 121
void sg_get_opcode_name(unsigned char cmd_byte0 , int peri_type , int buff_len , char *buff ) ;
#line 126
void sg_get_opcode_sa_name(unsigned char cmd_byte0 , int service_action , int peri_type ,
                           int buff_len , char *buff ) ;
#line 163
unsigned char const   *sg_scsi_sense_desc_find(unsigned char const   *sensep , int sense_len ,
                                               int desc_type ) ;
#line 167
char *sg_get_sense_key_str(int sense_key , int buff_len , char *buff ) ;
#line 170
char *sg_get_asc_ascq_str(int asc , int ascq , int buff_len , char *buff ) ;
#line 204
char *sg_get_pdt_str(int pdt , int buff_len , char *buff ) ;
#line 208
char *sg_get_trans_proto_str(int tpi , int buff_len , char *buff ) ;
#line 212
void sg_set_warnings_strm(FILE *warnings_strm ) ;
#line 216
void sg_print_command(unsigned char const   *command ) ;
#line 217
void sg_print_sense(char const   *leadin , unsigned char const   *sense_buffer , int sb_len ,
                    int raw_sinfo ) ;
#line 220
void sg_print_scsi_status(int scsi_status ) ;
#line 277
int sg_vpd_dev_id_iter(unsigned char const   *initial_desig_desc , int page_len ,
                       int *off , int m_assoc , int m_desig_type , int m_code_set ) ;
#line 303
int sg_is_big_endian(void) ;
#line 309
int sg_ata_get_chars(unsigned short const   *word_arr , int start_word , int num_words ,
                     int is_big_endian , char *ochars ) ;
#line 325
void dWordHex(unsigned short const   *words , int num , int no_ascii , int swapb ) ;
#line 340
int sg_get_num_nomult(char const   *buf ) ;
#line 355
int sg_set_text_mode(int fd ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
FILE *sg_warnings_strm  =    (FILE *)((void *)0);
#line 60
static void dStrHexErr(char const   *str , int len , int b_len , char *b ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static struct sg_lib_value_name_t  const  *get_value_name(struct sg_lib_value_name_t  const  *arr ,
                                                          int value , int peri_type ) 
{ 
  struct sg_lib_value_name_t  const  *vp ;
  struct sg_lib_value_name_t  const  *holdp ;

  {
#line 70
  vp = arr;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! vp->name) {
#line 73
      goto while_break;
    }
#line 74
    if (value == (int )vp->value) {
#line 75
      if (peri_type == (int )vp->peri_dev_type) {
#line 76
        return (vp);
      }
#line 77
      holdp = vp;
      {
#line 78
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 78
        if ((vp + 1)->name) {
#line 78
          if (! (value == (int )(vp + 1)->value)) {
#line 78
            goto while_break___0;
          }
        } else {
#line 78
          goto while_break___0;
        }
#line 79
        vp ++;
#line 80
        if (peri_type == (int )vp->peri_dev_type) {
#line 81
          return (vp);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 83
      return (holdp);
    }
#line 73
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return ((struct sg_lib_value_name_t  const  *)((void *)0));
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_set_warnings_strm(FILE *warnings_strm ) 
{ 


  {
#line 92
  sg_warnings_strm = warnings_strm;
#line 93
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_print_command(unsigned char const   *command ) 
{ 
  int k ;
  int sz ;
  char buff[128] ;

  {
  {
#line 103
  sg_get_command_name(command, 0, 128, buff);
#line 104
  buff[127] = (char )'\000';
  }
#line 106
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 107
    sg_warnings_strm = stderr;
  }
  {
#line 108
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s [",
          buff);
  }
#line 109
  if (127 == (int )*(command + 0)) {
#line 110
    sz = (int )((int const   )*(command + 7) + 8);
  } else {
    {
#line 112
    sz = sg_get_command_size((unsigned char )*(command + 0));
    }
  }
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (k < sz)) {
#line 113
      goto while_break;
    }
    {
#line 114
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
            (int const   )*(command + k));
#line 113
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"]\n");
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_get_scsi_status_str(int scsi_status , int buff_len , char *buff ) 
{ 
  char const   *ccp ;

  {
#line 123
  scsi_status &= 126;
  {
#line 125
  if (scsi_status == 0) {
#line 125
    goto case_0;
  }
#line 126
  if (scsi_status == 2) {
#line 126
    goto case_2;
  }
#line 127
  if (scsi_status == 4) {
#line 127
    goto case_4;
  }
#line 128
  if (scsi_status == 8) {
#line 128
    goto case_8;
  }
#line 129
  if (scsi_status == 16) {
#line 129
    goto case_16;
  }
#line 130
  if (scsi_status == 20) {
#line 130
    goto case_20;
  }
#line 131
  if (scsi_status == 24) {
#line 131
    goto case_24;
  }
#line 132
  if (scsi_status == 34) {
#line 132
    goto case_34;
  }
#line 133
  if (scsi_status == 40) {
#line 133
    goto case_40;
  }
#line 134
  if (scsi_status == 48) {
#line 134
    goto case_48;
  }
#line 135
  if (scsi_status == 64) {
#line 135
    goto case_64;
  }
#line 136
  goto switch_default;
  case_0: /* CIL Label */ 
#line 125
  ccp = "Good";
#line 125
  goto switch_break;
  case_2: /* CIL Label */ 
#line 126
  ccp = "Check Condition";
#line 126
  goto switch_break;
  case_4: /* CIL Label */ 
#line 127
  ccp = "Condition Met";
#line 127
  goto switch_break;
  case_8: /* CIL Label */ 
#line 128
  ccp = "Busy";
#line 128
  goto switch_break;
  case_16: /* CIL Label */ 
#line 129
  ccp = "Intermediate (obsolete)";
#line 129
  goto switch_break;
  case_20: /* CIL Label */ 
#line 130
  ccp = "Intermediate-Condition Met (obs)";
#line 130
  goto switch_break;
  case_24: /* CIL Label */ 
#line 131
  ccp = "Reservation Conflict";
#line 131
  goto switch_break;
  case_34: /* CIL Label */ 
#line 132
  ccp = "Command Terminated (obsolete)";
#line 132
  goto switch_break;
  case_40: /* CIL Label */ 
#line 133
  ccp = "Task set Full";
#line 133
  goto switch_break;
  case_48: /* CIL Label */ 
#line 134
  ccp = "ACA Active";
#line 134
  goto switch_break;
  case_64: /* CIL Label */ 
#line 135
  ccp = "Task Aborted";
#line 135
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 136
  ccp = "Unknown status";
#line 136
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 138
  strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)ccp, (size_t )buff_len);
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_print_scsi_status(int scsi_status ) 
{ 
  char buff[128] ;

  {
  {
#line 146
  sg_get_scsi_status_str(scsi_status, (int )(sizeof(buff) - 1UL), buff);
#line 147
  buff[sizeof(buff) - 1UL] = (char )'\000';
  }
#line 148
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 149
    sg_warnings_strm = stderr;
  }
  {
#line 150
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s ",
          buff);
  }
#line 151
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
char *sg_get_sense_key_str(int sense_key , int buff_len , char *buff ) 
{ 


  {
#line 157
  if (sense_key >= 0) {
#line 157
    if (sense_key < 16) {
      {
#line 158
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
               sg_lib_sense_key_desc[sense_key]);
      }
    } else {
      {
#line 160
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"invalid value: 0x%x",
               sense_key);
      }
    }
  } else {
    {
#line 160
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"invalid value: 0x%x",
             sense_key);
    }
  }
#line 161
  return (buff);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
char *sg_get_asc_ascq_str(int asc , int ascq , int buff_len , char *buff ) 
{ 
  int k ;
  int num ;
  int rlen ;
  int found ;
  struct sg_lib_asc_ascq_t *eip ;
  struct sg_lib_asc_ascq_range_t *ei2p ;
  int tmp ;
  int tmp___0 ;

  {
#line 168
  found = 0;
#line 172
  k = 0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! sg_lib_asc_ascq_range[k].text) {
#line 172
      goto while_break;
    }
#line 173
    ei2p = & sg_lib_asc_ascq_range[k];
#line 174
    if ((int )ei2p->asc == asc) {
#line 174
      if (ascq >= (int )ei2p->ascq_min) {
#line 174
        if (ascq <= (int )ei2p->ascq_max) {
          {
#line 177
          found = 1;
#line 178
          num = snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Additional sense: ");
#line 179
          rlen = buff_len - num;
          }
#line 180
          if (rlen > 0) {
#line 180
            tmp = rlen;
          } else {
#line 180
            tmp = 0;
          }
          {
#line 180
          tmp___0 = snprintf((char */* __restrict  */)(buff + num), (size_t )tmp,
                             (char const   */* __restrict  */)ei2p->text, ascq);
#line 180
          num += tmp___0;
          }
        }
      }
    }
#line 172
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (found) {
#line 185
    return (buff);
  }
#line 187
  k = 0;
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! sg_lib_asc_ascq[k].text) {
#line 187
      goto while_break___0;
    }
#line 188
    eip = & sg_lib_asc_ascq[k];
#line 189
    if ((int )eip->asc == asc) {
#line 189
      if ((int )eip->ascq == ascq) {
        {
#line 191
        found = 1;
#line 192
        snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Additional sense: %s",
                 eip->text);
        }
      }
    }
#line 187
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 195
  if (! found) {
#line 196
    if (asc >= 128) {
      {
#line 197
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"vendor specific ASC=%2x, ASCQ=%2x",
               asc, ascq);
      }
    } else
#line 199
    if (ascq >= 128) {
      {
#line 200
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"ASC=%2x, vendor specific qualification ASCQ=%2x",
               asc, ascq);
      }
    } else {
      {
#line 203
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"ASC=%2x, ASCQ=%2x",
               asc, ascq);
      }
    }
  }
#line 205
  return (buff);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
unsigned char const   *sg_scsi_sense_desc_find(unsigned char const   *sensep , int sense_len ,
                                               int desc_type ) 
{ 
  int add_sen_len ;
  int add_len ;
  int desc_len ;
  int k ;
  unsigned char const   *descp ;

  {
#line 215
  if (sense_len < 8) {
#line 216
    return ((unsigned char const   *)((void *)0));
  } else {
#line 215
    add_sen_len = (int )*(sensep + 7);
#line 215
    if (0 == add_sen_len) {
#line 216
      return ((unsigned char const   *)((void *)0));
    }
  }
#line 217
  if ((int const   )*(sensep + 0) < 114) {
#line 218
    return ((unsigned char const   *)((void *)0));
  } else
#line 217
  if ((int const   )*(sensep + 0) > 115) {
#line 218
    return ((unsigned char const   *)((void *)0));
  }
#line 219
  if (add_sen_len < sense_len - 8) {
#line 219
    add_sen_len = add_sen_len;
  } else {
#line 219
    add_sen_len = sense_len - 8;
  }
#line 221
  descp = sensep + 8;
#line 222
  desc_len = 0;
#line 222
  k = 0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (k < add_sen_len)) {
#line 222
      goto while_break;
    }
#line 223
    descp += desc_len;
#line 224
    if (k < add_sen_len - 1) {
#line 224
      add_len = (int )*(descp + 1);
    } else {
#line 224
      add_len = -1;
    }
#line 225
    desc_len = add_len + 2;
#line 226
    if ((int const   )*(descp + 0) == (int const   )desc_type) {
#line 227
      return (descp);
    }
#line 228
    if (add_len < 0) {
#line 229
      goto while_break;
    }
#line 222
    k += desc_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return ((unsigned char const   *)((void *)0));
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_get_sense_info_fld(unsigned char const   *sensep , int sb_len , uint64_t *info_outp ) 
{ 
  int j ;
  unsigned char const   *ucp ;
  uint64_t ull ;
  int tmp ;

  {
#line 242
  if (info_outp) {
#line 243
    *info_outp = (uint64_t )0;
  }
#line 244
  if (sb_len < 7) {
#line 245
    return (0);
  }
  {
#line 248
  if (((int const   )*(sensep + 0) & 127) == 113) {
#line 248
    goto case_113;
  }
#line 248
  if (((int const   )*(sensep + 0) & 127) == 112) {
#line 248
    goto case_113;
  }
#line 254
  if (((int const   )*(sensep + 0) & 127) == 115) {
#line 254
    goto case_115;
  }
#line 254
  if (((int const   )*(sensep + 0) & 127) == 114) {
#line 254
    goto case_115;
  }
#line 268
  goto switch_default;
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 249
  if (info_outp) {
#line 250
    *info_outp = (uint64_t )(((((unsigned int )*(sensep + 3) << 24) + (unsigned int )((int const   )*(sensep + 4) << 16)) + (unsigned int )((int const   )*(sensep + 5) << 8)) + (unsigned int )*(sensep + 6));
  }
#line 252
  if ((int const   )*(sensep + 0) & 128) {
#line 252
    tmp = 1;
  } else {
#line 252
    tmp = 0;
  }
#line 252
  return (tmp);
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 255
  ucp = sg_scsi_sense_desc_find(sensep, sb_len, 0);
  }
#line 256
  if (ucp) {
#line 256
    if (10 == (int )*(ucp + 1)) {
#line 257
      ull = (uint64_t )0;
#line 258
      j = 0;
      {
#line 258
      while (1) {
        while_continue: /* CIL Label */ ;
#line 258
        if (! (j < 8)) {
#line 258
          goto while_break;
        }
#line 259
        if (j > 0) {
#line 260
          ull <<= 8;
        }
#line 261
        ull |= (unsigned long )*(ucp + (4 + j));
#line 258
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 263
      if (info_outp) {
#line 264
        *info_outp = ull;
      }
#line 265
      return (! (! ((int const   )*(ucp + 2) & 128)));
    } else {
#line 267
      return (0);
    }
  } else {
#line 267
    return (0);
  }
  switch_default: /* CIL Label */ 
#line 269
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_get_sense_filemark_eom_ili(unsigned char const   *sensep , int sb_len , int *filemark_p ,
                                  int *eom_p , int *ili_p ) 
{ 
  unsigned char const   *ucp ;

  {
#line 279
  if (sb_len < 7) {
#line 280
    return (0);
  }
  {
#line 283
  if (((int const   )*(sensep + 0) & 127) == 113) {
#line 283
    goto case_113;
  }
#line 283
  if (((int const   )*(sensep + 0) & 127) == 112) {
#line 283
    goto case_113;
  }
#line 295
  if (((int const   )*(sensep + 0) & 127) == 115) {
#line 295
    goto case_115;
  }
#line 295
  if (((int const   )*(sensep + 0) & 127) == 114) {
#line 295
    goto case_115;
  }
#line 310
  goto switch_default;
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 284
  if ((int const   )*(sensep + 2) & 224) {
#line 285
    if (filemark_p) {
#line 286
      *filemark_p = ! (! ((int const   )*(sensep + 2) & 128));
    }
#line 287
    if (eom_p) {
#line 288
      *eom_p = ! (! ((int const   )*(sensep + 2) & 64));
    }
#line 289
    if (ili_p) {
#line 290
      *ili_p = ! (! ((int const   )*(sensep + 2) & 32));
    }
#line 291
    return (1);
  } else {
#line 293
    return (0);
  }
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 297
  ucp = sg_scsi_sense_desc_find(sensep, sb_len, 4);
  }
#line 298
  if (ucp) {
#line 298
    if ((int const   )*(ucp + 1) >= 2) {
#line 299
      if ((int const   )*(ucp + 3) & 224) {
#line 300
        if (filemark_p) {
#line 301
          *filemark_p = ! (! ((int const   )*(ucp + 3) & 128));
        }
#line 302
        if (eom_p) {
#line 303
          *eom_p = ! (! ((int const   )*(ucp + 3) & 64));
        }
#line 304
        if (ili_p) {
#line 305
          *ili_p = ! (! ((int const   )*(ucp + 3) & 32));
        }
#line 306
        return (1);
      }
    }
  }
#line 309
  return (0);
  switch_default: /* CIL Label */ 
#line 311
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_get_sense_progress_fld(unsigned char const   *sensep , int sb_len , int *progress_outp ) 
{ 
  unsigned char const   *ucp ;
  int sk ;
  int sk_pr ;
  int tmp ;

  {
#line 322
  if (sb_len < 7) {
#line 323
    return (0);
  }
  {
#line 326
  if (((int const   )*(sensep + 0) & 127) == 113) {
#line 326
    goto case_113;
  }
#line 326
  if (((int const   )*(sensep + 0) & 127) == 112) {
#line 326
    goto case_113;
  }
#line 338
  if (((int const   )*(sensep + 0) & 127) == 115) {
#line 338
    goto case_115;
  }
#line 338
  if (((int const   )*(sensep + 0) & 127) == 114) {
#line 338
    goto case_115;
  }
#line 354
  goto switch_default;
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 327
  sk = (int )((int const   )*(sensep + 2) & 15);
#line 328
  if (sb_len < 18) {
#line 330
    return (0);
  } else
#line 328
  if (0 != sk) {
#line 328
    if (2 != sk) {
#line 330
      return (0);
    }
  }
#line 331
  if ((int const   )*(sensep + 15) & 128) {
#line 332
    if (progress_outp) {
#line 333
      *progress_outp = (int )(((int const   )*(sensep + 16) << 8) + (int const   )*(sensep + 17));
    }
#line 334
    return (1);
  } else {
#line 336
    return (0);
  }
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
#line 340
  sk = (int )((int const   )*(sensep + 1) & 15);
#line 341
  if (0 == sk) {
#line 341
    tmp = 1;
  } else
#line 341
  if (2 == sk) {
#line 341
    tmp = 1;
  } else {
#line 341
    tmp = 0;
  }
#line 341
  sk_pr = tmp;
#line 342
  if (sk_pr) {
    {
#line 342
    ucp = sg_scsi_sense_desc_find(sensep, sb_len, 2);
    }
#line 342
    if (ucp) {
#line 342
      if (6 == (int )*(ucp + 1)) {
#line 342
        if (128 & (int )*(ucp + 4)) {
#line 344
          if (progress_outp) {
#line 345
            *progress_outp = (int )(((int const   )*(ucp + 5) << 8) + (int const   )*(ucp + 6));
          }
#line 346
          return (1);
        } else {
#line 342
          goto _L___1;
        }
      } else {
#line 342
        goto _L___1;
      }
    } else {
#line 342
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 347
    ucp = sg_scsi_sense_desc_find(sensep, sb_len, 10);
    }
#line 347
    if (ucp) {
#line 347
      if (6 == (int )*(ucp + 1)) {
#line 349
        if (progress_outp) {
#line 350
          *progress_outp = (int )(((int const   )*(ucp + 6) << 8) + (int const   )*(ucp + 7));
        }
#line 351
        return (1);
      } else {
#line 353
        return (0);
      }
    } else {
#line 353
      return (0);
    }
  }
  switch_default: /* CIL Label */ 
#line 355
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
char *sg_get_pdt_str(int pdt , int buff_len , char *buff ) 
{ 


  {
#line 362
  if (pdt < 0) {
    {
#line 363
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad pdt");
    }
  } else
#line 362
  if (pdt > 31) {
    {
#line 363
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad pdt");
    }
  } else {
    {
#line 365
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
             sg_lib_pdt_strs[pdt]);
    }
  }
#line 366
  return (buff);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
char *sg_get_trans_proto_str(int tpi , int buff_len , char *buff ) 
{ 


  {
#line 372
  if (tpi < 0) {
    {
#line 373
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad tpi");
    }
  } else
#line 372
  if (tpi > 15) {
    {
#line 373
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad tpi");
    }
  } else {
    {
#line 375
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
             sg_lib_transport_proto_strs[tpi]);
    }
  }
#line 376
  return (buff);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static int decode_tpgs_state(int st , char *b , int blen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 390
  if (st == 0) {
#line 390
    goto case_0;
  }
#line 392
  if (st == 1) {
#line 392
    goto case_1;
  }
#line 394
  if (st == 2) {
#line 394
    goto case_2;
  }
#line 396
  if (st == 3) {
#line 396
    goto case_3;
  }
#line 398
  if (st == 14) {
#line 398
    goto case_14;
  }
#line 400
  if (st == 15) {
#line 400
    goto case_15;
  }
#line 402
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 391
  tmp = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"active/optimized");
  }
#line 391
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 393
  tmp___0 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"active/non optimized");
  }
#line 393
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 395
  tmp___1 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"standby");
  }
#line 395
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 397
  tmp___2 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"unavailable");
  }
#line 397
  return (tmp___2);
  case_14: /* CIL Label */ 
  {
#line 399
  tmp___3 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"offline");
  }
#line 399
  return (tmp___3);
  case_15: /* CIL Label */ 
  {
#line 401
  tmp___4 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"transitioning between states");
  }
#line 401
  return (tmp___4);
  switch_default: /* CIL Label */ 
  {
#line 403
  tmp___5 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"unknown: 0x%x",
                     st);
  }
#line 403
  return (tmp___5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static int uds_referral_descriptor_str(char *sp , unsigned char const   *dp , int alen ) 
{ 
  int n ;
  int dlen ;
  int k ;
  int j ;
  int g ;
  int f ;
  int tpgd ;
  unsigned char const   *tp ;
  uint64_t ull ;
  char c[40] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 410
  n = 0;
#line 411
  dlen = alen - 2;
#line 417
  tmp = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"   Not all referrals: %d\n",
                ! (! ((int const   )*(dp + 2) & 1)));
#line 417
  n += tmp;
#line 418
  dp += 4;
#line 419
  k = 0;
#line 419
  f = 1;
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (k + 4 < dlen)) {
#line 419
      goto while_break;
    }
    {
#line 420
    tpgd = (int )*(dp + 3);
#line 421
    g = tpgd * 4 + 20;
#line 422
    tmp___0 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"    Descriptor %d\n",
                      f);
#line 422
    n += tmp___0;
    }
#line 423
    if (k + g > dlen) {
      {
#line 424
      tmp___1 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"      truncated descriptor, stop\n");
#line 424
      n += tmp___1;
      }
#line 425
      return (n);
    }
#line 427
    ull = (uint64_t )0;
#line 428
    j = 0;
    {
#line 428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 428
      if (! (j < 8)) {
#line 428
        goto while_break___0;
      }
#line 429
      if (j > 0) {
#line 430
        ull <<= 8;
      }
#line 431
      ull |= (unsigned long )*(dp + (4 + j));
#line 428
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 433
    tmp___2 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"      first uds LBA: 0x%lx\n",
                      ull);
#line 433
    n += tmp___2;
#line 434
    ull = (uint64_t )0;
#line 435
    j = 0;
    }
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 435
      if (! (j < 8)) {
#line 435
        goto while_break___1;
      }
#line 436
      if (j > 0) {
#line 437
        ull <<= 8;
      }
#line 438
      ull |= (unsigned long )*(dp + (12 + j));
#line 435
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 440
    tmp___3 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"      last uds LBA:  0x%lx\n",
                      ull);
#line 440
    n += tmp___3;
#line 441
    j = 0;
    }
    {
#line 441
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 441
      if (! (j < tpgd)) {
#line 441
        goto while_break___2;
      }
      {
#line 442
      tp = (dp + 20) + j * 4;
#line 443
      decode_tpgs_state((int )((int const   )*(tp + 0) & 15), c, (int )sizeof(c));
#line 444
      tmp___4 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"        tpg: %d  state: %s\n",
                        ((int const   )*(tp + 2) << 8) + (int const   )*(tp + 3),
                        c);
#line 444
      n += tmp___4;
#line 441
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 419
    k += g;
#line 419
    dp += g;
#line 419
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return (n);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static char const   *sdata_src[3]  = {      "unknown",      "Extended Copy command source device",      "Extended Copy command destination device"};
#line 460 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static void sg_get_sense_descriptors_str(unsigned char const   *sense_buffer , int sb_len ,
                                         int buff_len , char *buff ) 
{ 
  int add_sen_len ;
  int add_len ;
  int desc_len ;
  int k ;
  int j ;
  int sense_key ;
  int processed ;
  int n ;
  int progress ;
  int pr ;
  int rem ;
  unsigned char const   *descp ;
  char const   *dtsp ;
  char b[2048] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int extend ;
  int sector_count ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char c[200] ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  size_t tmp___78 ;

  {
#line 467
  dtsp = "   >> descriptor too short";
#line 470
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 471
    return;
  } else
#line 470
  if (buff_len <= 0) {
#line 471
    return;
  }
#line 472
  *(buff + 0) = (char )'\000';
#line 473
  if (sb_len < 8) {
#line 474
    return;
  } else {
#line 473
    add_sen_len = (int )*(sense_buffer + 7);
#line 473
    if (0 == add_sen_len) {
#line 474
      return;
    }
  }
#line 475
  if (add_sen_len < sb_len - 8) {
#line 475
    add_sen_len = add_sen_len;
  } else {
#line 475
    add_sen_len = sb_len - 8;
  }
#line 476
  descp = sense_buffer + 8;
#line 477
  sense_key = (int )((int const   )*(sense_buffer + 1) & 15);
#line 478
  desc_len = 0;
#line 478
  k = 0;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (k < add_sen_len)) {
#line 478
      goto while_break;
    }
#line 479
    descp += desc_len;
#line 480
    if (k < add_sen_len - 1) {
#line 480
      add_len = (int )*(descp + 1);
    } else {
#line 480
      add_len = -1;
    }
#line 481
    if ((k + add_len) + 2 > add_sen_len) {
#line 482
      add_len = (add_sen_len - k) - 2;
    }
    {
#line 483
    desc_len = add_len + 2;
#line 484
    n = 0;
#line 485
    tmp = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"  Descriptor type: ");
#line 485
    n += tmp;
#line 486
    processed = 1;
    }
    {
#line 488
    if ((int const   )*(descp + 0) == 0) {
#line 488
      goto case_0;
    }
#line 500
    if ((int const   )*(descp + 0) == 1) {
#line 500
      goto case_1;
    }
#line 512
    if ((int const   )*(descp + 0) == 2) {
#line 512
      goto case_2;
    }
#line 583
    if ((int const   )*(descp + 0) == 3) {
#line 583
      goto case_3___0;
    }
#line 592
    if ((int const   )*(descp + 0) == 4) {
#line 592
      goto case_4___0;
    }
#line 608
    if ((int const   )*(descp + 0) == 5) {
#line 608
      goto case_5___0;
    }
#line 618
    if ((int const   )*(descp + 0) == 6) {
#line 618
      goto case_6___0;
    }
#line 622
    if ((int const   )*(descp + 0) == 7) {
#line 622
      goto case_7;
    }
#line 626
    if ((int const   )*(descp + 0) == 8) {
#line 626
      goto case_8;
    }
#line 630
    if ((int const   )*(descp + 0) == 9) {
#line 630
      goto case_9;
    }
#line 654
    if ((int const   )*(descp + 0) == 10) {
#line 654
      goto case_10___0;
    }
#line 668
    if ((int const   )*(descp + 0) == 11) {
#line 668
      goto case_11;
    }
#line 677
    if ((int const   )*(descp + 0) == 12) {
#line 677
      goto case_12;
    }
#line 709
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 489
    tmp___0 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Information\n");
#line 489
    n += tmp___0;
    }
#line 490
    if (add_len >= 10) {
#line 490
      if (128 & (int )*(descp + 2)) {
        {
#line 491
        tmp___1 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    0x");
#line 491
        n += tmp___1;
#line 492
        j = 0;
        }
        {
#line 492
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 492
          if (! (j < 8)) {
#line 492
            goto while_break___0;
          }
          {
#line 493
          tmp___2 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%02x",
                            (int const   )*(descp + (4 + j)));
#line 493
          n += tmp___2;
#line 492
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 494
        tmp___3 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 494
        n += tmp___3;
        }
      } else {
        {
#line 496
        tmp___4 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                          dtsp);
#line 496
        n += tmp___4;
#line 497
        processed = 0;
        }
      }
    } else {
      {
#line 496
      tmp___4 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                        dtsp);
#line 496
      n += tmp___4;
#line 497
      processed = 0;
      }
    }
#line 499
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 501
    tmp___5 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Command specific\n");
#line 501
    n += tmp___5;
    }
#line 502
    if (add_len >= 10) {
      {
#line 503
      tmp___6 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    0x");
#line 503
      n += tmp___6;
#line 504
      j = 0;
      }
      {
#line 504
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 504
        if (! (j < 8)) {
#line 504
          goto while_break___1;
        }
        {
#line 505
        tmp___7 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%02x",
                          (int const   )*(descp + (4 + j)));
#line 505
        n += tmp___7;
#line 504
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 506
      tmp___8 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 506
      n += tmp___8;
      }
    } else {
      {
#line 508
      tmp___9 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                        dtsp);
#line 508
      n += tmp___9;
#line 509
      processed = 0;
      }
    }
#line 511
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 513
    tmp___10 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Sense key specific:");
#line 513
    n += tmp___10;
    }
    {
#line 515
    if (sense_key == 5) {
#line 515
      goto case_5;
    }
#line 532
    if (sense_key == 1) {
#line 532
      goto case_1___0;
    }
#line 532
    if (sense_key == 3) {
#line 532
      goto case_1___0;
    }
#line 532
    if (sense_key == 4) {
#line 532
      goto case_1___0;
    }
#line 543
    if (sense_key == 2) {
#line 543
      goto case_2___0;
    }
#line 543
    if (sense_key == 0) {
#line 543
      goto case_2___0;
    }
#line 555
    if (sense_key == 10) {
#line 555
      goto case_10;
    }
#line 571
    if (sense_key == 6) {
#line 571
      goto case_6;
    }
#line 576
    goto switch_default;
    case_5: /* CIL Label */ 
    {
#line 516
    tmp___11 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Field pointer\n");
#line 516
    n += tmp___11;
    }
#line 517
    if (add_len < 6) {
      {
#line 518
      tmp___12 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 518
      n += tmp___12;
#line 519
      processed = 0;
      }
#line 520
      goto switch_break___0;
    }
#line 522
    if ((int const   )*(descp + 4) & 64) {
#line 522
      tmp___13 = "Command";
    } else {
#line 522
      tmp___13 = "Data";
    }
    {
#line 522
    tmp___14 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Error in %s byte %d",
                       tmp___13, ((int const   )*(descp + 5) << 8) | (int const   )*(descp + 6));
#line 522
    n += tmp___14;
    }
#line 525
    if ((int const   )*(descp + 4) & 8) {
      {
#line 526
      tmp___15 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" bit %d\n",
                         (int const   )*(descp + 4) & 7);
#line 526
      n += tmp___15;
      }
    } else {
      {
#line 528
      tmp___16 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 528
      n += tmp___16;
      }
    }
#line 529
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 533
    tmp___17 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Actual retry count\n");
#line 533
    n += tmp___17;
    }
#line 534
    if (add_len < 6) {
      {
#line 535
      tmp___18 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 535
      n += tmp___18;
#line 536
      processed = 0;
      }
#line 537
      goto switch_break___0;
    }
    {
#line 539
    tmp___19 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    0x%02x%02x\n",
                       (int const   )*(descp + 5), (int const   )*(descp + 6));
#line 539
    n += tmp___19;
    }
#line 541
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 544
    tmp___20 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Progress indication: ");
#line 544
    n += tmp___20;
    }
#line 545
    if (add_len < 6) {
      {
#line 546
      tmp___21 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 546
      n += tmp___21;
#line 547
      processed = 0;
      }
#line 548
      goto switch_break___0;
    }
    {
#line 550
    progress = (int )(((int const   )*(descp + 5) << 8) + (int const   )*(descp + 6));
#line 551
    pr = (progress * 100) / 65536;
#line 552
    rem = ((progress * 100) % 65536) / 655;
#line 553
    tmp___22 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%d.%02d%%\n",
                       pr, rem);
#line 553
    n += tmp___22;
    }
#line 554
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 556
    tmp___23 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Segment pointer\n");
#line 556
    n += tmp___23;
    }
#line 557
    if (add_len < 6) {
      {
#line 558
      tmp___24 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 558
      n += tmp___24;
#line 559
      processed = 0;
      }
#line 560
      goto switch_break___0;
    }
#line 562
    if ((int const   )*(descp + 4) & 32) {
#line 562
      tmp___25 = "segment descriptor";
    } else {
#line 562
      tmp___25 = "parameter list";
    }
    {
#line 562
    tmp___26 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Relative to start of %s, byte %d",
                       tmp___25, ((int const   )*(descp + 5) << 8) | (int const   )*(descp + 6));
#line 562
    n += tmp___26;
    }
#line 566
    if ((int const   )*(descp + 4) & 8) {
      {
#line 567
      tmp___27 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" bit %d\n",
                         (int const   )*(descp + 4) & 7);
#line 567
      n += tmp___27;
      }
    } else {
      {
#line 569
      tmp___28 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 569
      n += tmp___28;
      }
    }
#line 570
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 572
    tmp___29 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Unit attention condition queue: ");
#line 572
    n += tmp___29;
#line 573
    tmp___30 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"overflow flag is %d\n",
                       ! (! ((int const   )*(descp + 4) & 1)));
#line 573
    n += tmp___30;
    }
#line 575
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 577
    tmp___31 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Sense_key: 0x%x unexpected\n",
                       sense_key);
#line 577
    n += tmp___31;
#line 579
    processed = 0;
    }
#line 580
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 582
    goto switch_break;
    case_3___0: /* CIL Label */ 
    {
#line 584
    tmp___32 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Field replaceable unit\n");
#line 584
    n += tmp___32;
    }
#line 585
    if (add_len >= 2) {
      {
#line 586
      tmp___33 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    code=0x%x\n",
                         (int const   )*(descp + 3));
#line 586
      n += tmp___33;
      }
    } else {
      {
#line 588
      tmp___34 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 588
      n += tmp___34;
#line 589
      processed = 0;
      }
    }
#line 591
    goto switch_break;
    case_4___0: /* CIL Label */ 
    {
#line 593
    tmp___35 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Stream commands\n");
#line 593
    n += tmp___35;
    }
#line 594
    if (add_len >= 2) {
#line 595
      if ((int const   )*(descp + 3) & 128) {
        {
#line 596
        tmp___36 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    FILEMARK");
#line 596
        n += tmp___36;
        }
      }
#line 597
      if ((int const   )*(descp + 3) & 64) {
        {
#line 598
        tmp___37 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    End Of Medium (EOM)");
#line 598
        n += tmp___37;
        }
      }
#line 599
      if ((int const   )*(descp + 3) & 32) {
        {
#line 600
        tmp___38 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Incorrect Length Indicator (ILI)");
#line 600
        n += tmp___38;
        }
      }
      {
#line 602
      tmp___39 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 602
      n += tmp___39;
      }
    } else {
      {
#line 604
      tmp___40 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 604
      n += tmp___40;
#line 605
      processed = 0;
      }
    }
#line 607
    goto switch_break;
    case_5___0: /* CIL Label */ 
    {
#line 609
    tmp___41 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Block commands\n");
#line 609
    n += tmp___41;
    }
#line 610
    if (add_len >= 2) {
#line 611
      if ((int const   )*(descp + 3) & 32) {
#line 611
        tmp___42 = "set";
      } else {
#line 611
        tmp___42 = "clear";
      }
      {
#line 611
      tmp___43 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Incorrect Length Indicator (ILI) %s\n",
                         tmp___42);
#line 611
      n += tmp___43;
      }
    } else {
      {
#line 614
      tmp___44 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 614
      n += tmp___44;
#line 615
      processed = 0;
      }
    }
#line 617
    goto switch_break;
    case_6___0: /* CIL Label */ 
    {
#line 619
    tmp___45 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"OSD object identification\n");
#line 619
    n += tmp___45;
#line 620
    processed = 0;
    }
#line 621
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 623
    tmp___46 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"OSD response integrity check value\n");
#line 623
    n += tmp___46;
#line 624
    processed = 0;
    }
#line 625
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 627
    tmp___47 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"OSD attribute identification\n");
#line 627
    n += tmp___47;
#line 628
    processed = 0;
    }
#line 629
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 631
    tmp___48 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"ATA Status Return\n");
#line 631
    n += tmp___48;
    }
#line 632
    if (add_len >= 12) {
#line 635
      extend = (int )((int const   )*(descp + 2) & 1);
#line 636
      if (extend) {
#line 636
        tmp___49 = (int const   )*(descp + 4) << 8;
      } else {
#line 636
        tmp___49 = (int const   )0;
      }
      {
#line 636
      sector_count = (int )((int const   )*(descp + 5) + tmp___49);
#line 637
      tmp___50 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    extend=%d  error=0x%x  sector_count=0x%x\n",
                         extend, (int const   )*(descp + 3), sector_count);
#line 637
      n += tmp___50;
      }
#line 640
      if (extend) {
        {
#line 641
        tmp___51 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    lba=0x%02x%02x%02x%02x%02x%02x\n",
                           (int const   )*(descp + 10), (int const   )*(descp + 8),
                           (int const   )*(descp + 6), (int const   )*(descp + 11),
                           (int const   )*(descp + 9), (int const   )*(descp + 7));
#line 641
        n += tmp___51;
        }
      } else {
        {
#line 645
        tmp___52 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    lba=0x%02x%02x%02x\n",
                           (int const   )*(descp + 11), (int const   )*(descp + 9),
                           (int const   )*(descp + 7));
#line 645
        n += tmp___52;
        }
      }
      {
#line 647
      tmp___53 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    device=0x%x  status=0x%x\n",
                         (int const   )*(descp + 12), (int const   )*(descp + 13));
#line 647
      n += tmp___53;
      }
    } else {
      {
#line 650
      tmp___54 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 650
      n += tmp___54;
#line 651
      processed = 0;
      }
    }
#line 653
    goto switch_break;
    case_10___0: /* CIL Label */ 
    {
#line 655
    tmp___55 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Progress indication\n");
#line 655
    n += tmp___55;
    }
#line 656
    if (add_len < 6) {
      {
#line 657
      tmp___56 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 657
      n += tmp___56;
#line 658
      processed = 0;
      }
#line 659
      goto switch_break;
    }
    {
#line 661
    progress = (int )(((int const   )*(descp + 6) << 8) + (int const   )*(descp + 7));
#line 662
    pr = (progress * 100) / 65536;
#line 663
    rem = ((progress * 100) % 65536) / 655;
#line 664
    tmp___57 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    %d.02%d%%",
                       pr, rem);
#line 664
    n += tmp___57;
#line 665
    tmp___58 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" [sense_key=0x%x asc,ascq=0x%x,0x%x]\n",
                       (int const   )*(descp + 2), (int const   )*(descp + 3), (int const   )*(descp + 4));
#line 665
    n += tmp___58;
    }
#line 667
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 669
    tmp___59 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"User data segment referral\n");
#line 669
    n += tmp___59;
    }
#line 670
    if (add_len < 2) {
      {
#line 671
      tmp___60 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 671
      n += tmp___60;
#line 672
      processed = 0;
      }
#line 673
      goto switch_break;
    }
    {
#line 675
    tmp___61 = uds_referral_descriptor_str(b + n, descp, add_len);
#line 675
    n += tmp___61;
    }
#line 676
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 678
    tmp___62 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Forwarded sense data\n");
#line 678
    n += tmp___62;
    }
#line 679
    if (add_len < 2) {
      {
#line 680
      tmp___63 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 680
      n += tmp___63;
#line 681
      processed = 0;
      }
#line 682
      goto switch_break;
    }
#line 684
    if ((int const   )*(descp + 2) & 128) {
#line 684
      tmp___64 = "set";
    } else {
#line 684
      tmp___64 = "clear";
    }
    {
#line 684
    tmp___65 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    FSDT: %s\n",
                       tmp___64);
#line 684
    n += tmp___65;
#line 686
    j = (int )((int const   )*(descp + 2) & 15);
    }
#line 687
    if (j < 3) {
      {
#line 688
      tmp___66 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Sense data source: %s\n",
                         sdata_src[j]);
#line 688
      n += tmp___66;
      }
    } else {
      {
#line 691
      tmp___67 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Sense data source: reserved [%d]\n",
                         j);
#line 691
      n += tmp___67;
      }
    }
    {
#line 696
    sg_get_scsi_status_str((int )*(descp + 3), (int )(sizeof(c) - 1UL), c);
#line 697
    c[sizeof(c) - 1UL] = (char )'\000';
#line 698
    tmp___68 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Forwarded status: %s\n",
                       c);
#line 698
    n += tmp___68;
    }
#line 699
    if (add_len > 2) {
      {
#line 701
      tmp___69 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" vvvvvvvvvvvvvvvv\n");
#line 701
      n += tmp___69;
#line 702
      sg_get_sense_str((char const   *)((void *)0), descp + 4, add_len - 2, 0, (int )sizeof(c),
                       c);
#line 704
      tmp___70 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s",
                         c);
#line 704
      n += tmp___70;
#line 705
      tmp___71 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" ^^^^^^^^^^^^^^^^\n");
#line 705
      n += tmp___71;
      }
    }
#line 708
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 710
    tmp___72 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Unknown or vendor specific [0x%x]\n",
                       (int const   )*(descp + 0));
#line 710
    n += tmp___72;
#line 712
    processed = 0;
    }
#line 713
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 715
    if (! processed) {
#line 716
      if (add_len > 0) {
        {
#line 717
        tmp___73 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    ");
#line 717
        n += tmp___73;
#line 718
        j = 0;
        }
        {
#line 718
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 718
          if (! (j < add_len)) {
#line 718
            goto while_break___2;
          }
#line 719
          if (j > 0) {
#line 719
            if (0 == j % 24) {
              {
#line 720
              tmp___74 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n    ");
#line 720
              n += tmp___74;
              }
            }
          }
          {
#line 721
          tmp___75 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%02x ",
                             (int const   )*(descp + (j + 2)));
#line 721
          n += tmp___75;
#line 718
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 723
        tmp___76 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 723
        n += tmp___76;
        }
      }
    }
#line 726
    if (add_len < 0) {
      {
#line 727
      tmp___77 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    short descriptor\n");
#line 727
      n += tmp___77;
      }
    }
    {
#line 728
    tmp___78 = strlen((char const   *)buff);
#line 728
    j = (int )tmp___78;
    }
#line 729
    if (n + j >= buff_len) {
      {
#line 730
      strncpy((char */* __restrict  */)(buff + j), (char const   */* __restrict  */)(b),
              (size_t )(buff_len - j));
#line 731
      *(buff + (buff_len - 1)) = (char )'\000';
      }
#line 732
      goto while_break;
    }
    {
#line 734
    strcpy((char */* __restrict  */)(buff + j), (char const   */* __restrict  */)(b));
    }
#line 735
    if (add_len < 0) {
#line 736
      goto while_break;
    }
#line 478
    k += desc_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_get_sense_str(char const   *leadin , unsigned char const   *sense_buffer ,
                      int sb_len , int raw_sinfo , int buff_len , char *buff ) 
{ 
  int len ;
  int valid ;
  int progress ;
  int n ;
  int r ;
  int pr ;
  int rem ;
  unsigned int info ;
  int descriptor_format ;
  char const   *error ;
  char error_buff[64] ;
  char b[256] ;
  struct sg_scsi_sense_hdr ssh ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 747
  descriptor_format = 0;
#line 748
  error = (char const   *)((void *)0);
#line 753
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 754
    return;
  } else
#line 753
  if (buff_len <= 0) {
#line 754
    return;
  }
#line 755
  *(buff + (buff_len - 1)) = (char )'\000';
#line 756
  buff_len --;
#line 757
  n = 0;
#line 758
  if (sb_len < 1) {
    {
#line 759
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"sense buffer empty\n");
    }
#line 760
    return;
  }
#line 762
  if (leadin) {
    {
#line 763
    tmp = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n), (char const   */* __restrict  */)"%s: ",
                   leadin);
#line 763
    n += tmp;
    }
#line 764
    if (n >= buff_len) {
#line 765
      return;
    }
  }
  {
#line 767
  len = sb_len;
#line 768
  tmp___35 = sg_scsi_normalize_sense(sense_buffer, sb_len, & ssh);
  }
#line 768
  if (tmp___35) {
    {
#line 770
    if ((int )ssh.response_code == 112) {
#line 770
      goto case_112;
    }
#line 775
    if ((int )ssh.response_code == 113) {
#line 775
      goto case_113;
    }
#line 781
    if ((int )ssh.response_code == 114) {
#line 781
      goto case_114;
    }
#line 785
    if ((int )ssh.response_code == 115) {
#line 785
      goto case_115;
    }
#line 789
    if ((int )ssh.response_code == 0) {
#line 789
      goto case_0;
    }
#line 792
    goto switch_default;
    case_112: /* CIL Label */ 
#line 771
    error = "Fixed format, current";
#line 772
    if (sb_len > 7) {
#line 772
      len = (int )((int const   )*(sense_buffer + 7) + 8);
    } else {
#line 772
      len = sb_len;
    }
#line 773
    if (len > sb_len) {
#line 773
      len = sb_len;
    } else {
#line 773
      len = len;
    }
#line 774
    goto switch_break;
    case_113: /* CIL Label */ 
#line 777
    error = "Fixed format, <<<deferred>>>";
#line 778
    if (sb_len > 7) {
#line 778
      len = (int )((int const   )*(sense_buffer + 7) + 8);
    } else {
#line 778
      len = sb_len;
    }
#line 779
    if (len > sb_len) {
#line 779
      len = sb_len;
    } else {
#line 779
      len = len;
    }
#line 780
    goto switch_break;
    case_114: /* CIL Label */ 
#line 782
    descriptor_format = 1;
#line 783
    error = "Descriptor format, current";
#line 784
    goto switch_break;
    case_115: /* CIL Label */ 
#line 786
    descriptor_format = 1;
#line 787
    error = "Descriptor format, <<<deferred>>>";
#line 788
    goto switch_break;
    case_0: /* CIL Label */ 
#line 790
    error = "Response code: 0x0 (?)";
#line 791
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 793
    snprintf((char */* __restrict  */)(error_buff), sizeof(error_buff), (char const   */* __restrict  */)"Unknown response code: 0x%x",
             (int )ssh.response_code);
#line 795
    error = (char const   *)(error_buff);
    }
#line 796
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 798
    tmp___0 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                       (char const   */* __restrict  */)" %s;  Sense key: %s\n ",
                       error, sg_lib_sense_key_desc[ssh.sense_key]);
#line 798
    n += tmp___0;
    }
#line 800
    if (n >= buff_len) {
#line 801
      return;
    }
#line 802
    if (descriptor_format) {
      {
#line 803
      tmp___1 = sg_get_asc_ascq_str((int )ssh.asc, (int )ssh.ascq, (int )sizeof(b),
                                    b);
#line 803
      tmp___2 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                         (char const   */* __restrict  */)"%s\n", tmp___1);
#line 803
      n += tmp___2;
      }
#line 806
      if (n >= buff_len) {
#line 807
        return;
      }
      {
#line 808
      sg_get_sense_descriptors_str(sense_buffer, len, buff_len - n, buff + n);
#line 810
      tmp___3 = strlen((char const   *)buff);
#line 810
      n = (int )tmp___3;
      }
#line 811
      if (n >= buff_len) {
#line 812
        return;
      }
    } else
#line 813
    if (len > 2) {
#line 814
      if (len > 12) {
        {
#line 815
        tmp___4 = sg_get_asc_ascq_str((int )ssh.asc, (int )ssh.ascq, (int )sizeof(b),
                                      b);
#line 815
        tmp___5 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                           (char const   */* __restrict  */)"%s\n", tmp___4);
#line 815
        n += tmp___5;
        }
#line 818
        if (n >= buff_len) {
#line 819
          return;
        }
      }
#line 821
      r = 0;
#line 822
      valid = (int )((int const   )*(sense_buffer + 0) & 128);
#line 823
      if (len > 6) {
#line 824
        info = (unsigned int )(((((int const   )*(sense_buffer + 3) << 24) | ((int const   )*(sense_buffer + 4) << 16)) | ((int const   )*(sense_buffer + 5) << 8)) | (int const   )*(sense_buffer + 6));
#line 827
        if (valid) {
          {
#line 828
          tmp___6 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Info fld=0x%x [%u] ",
                            info, info);
#line 828
          r += tmp___6;
          }
        } else
#line 830
        if (info > 0U) {
          {
#line 831
          tmp___7 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Valid=0, Info fld=0x%x [%u] ",
                            info, info);
#line 831
          r += tmp___7;
          }
        }
      } else {
#line 834
        info = 0U;
      }
#line 835
      if ((int const   )*(sense_buffer + 2) & 224) {
#line 836
        if ((int const   )*(sense_buffer + 2) & 128) {
          {
#line 837
          tmp___8 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" FMK");
#line 837
          r += tmp___8;
          }
        }
#line 839
        if ((int const   )*(sense_buffer + 2) & 64) {
          {
#line 840
          tmp___9 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" EOM");
#line 840
          r += tmp___9;
          }
        }
#line 842
        if ((int const   )*(sense_buffer + 2) & 32) {
          {
#line 843
          tmp___10 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" ILI");
#line 843
          r += tmp___10;
          }
        }
        {
#line 845
        tmp___11 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 845
        r += tmp___11;
        }
      } else
#line 846
      if (valid) {
        {
#line 847
        tmp___12 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 847
        r += tmp___12;
        }
      } else
#line 846
      if (info > 0U) {
        {
#line 847
        tmp___12 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 847
        r += tmp___12;
        }
      }
#line 848
      if (len >= 14) {
#line 848
        if (*(sense_buffer + 14)) {
          {
#line 849
          tmp___13 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Field replaceable unit code: %d\n",
                             (int const   )*(sense_buffer + 14));
#line 849
          r += tmp___13;
          }
        }
      }
#line 851
      if (len >= 18) {
#line 851
        if ((int const   )*(sense_buffer + 15) & 128) {
          {
#line 854
          if ((int )ssh.sense_key == 5) {
#line 854
            goto case_5;
          }
#line 866
          if ((int )ssh.sense_key == 2) {
#line 866
            goto case_2;
          }
#line 866
          if ((int )ssh.sense_key == 0) {
#line 866
            goto case_2;
          }
#line 875
          if ((int )ssh.sense_key == 1) {
#line 875
            goto case_1;
          }
#line 875
          if ((int )ssh.sense_key == 3) {
#line 875
            goto case_1;
          }
#line 875
          if ((int )ssh.sense_key == 4) {
#line 875
            goto case_1;
          }
#line 880
          if ((int )ssh.sense_key == 10) {
#line 880
            goto case_10;
          }
#line 892
          if ((int )ssh.sense_key == 6) {
#line 892
            goto case_6;
          }
#line 897
          goto switch_default___0;
          case_5: /* CIL Label */ 
#line 855
          if ((int const   )*(sense_buffer + 15) & 64) {
#line 855
            tmp___14 = "Command";
          } else {
#line 855
            tmp___14 = "Data";
          }
          {
#line 855
          tmp___15 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Sense Key Specific: Error in %s byte %d",
                             tmp___14, ((int const   )*(sense_buffer + 16) << 8) | (int const   )*(sense_buffer + 17));
#line 855
          r += tmp___15;
          }
#line 859
          if ((int const   )*(sense_buffer + 15) & 8) {
            {
#line 860
            tmp___16 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" bit %d\n",
                               (int const   )*(sense_buffer + 15) & 7);
#line 860
            r += tmp___16;
            }
          } else {
            {
#line 863
            tmp___17 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 863
            r += tmp___17;
            }
          }
#line 864
          goto switch_break___0;
          case_2: /* CIL Label */ 
          case_0___0: /* CIL Label */ 
          {
#line 867
          progress = (int )(((int const   )*(sense_buffer + 16) << 8) + (int const   )*(sense_buffer + 17));
#line 868
          pr = (progress * 100) / 65536;
#line 869
          rem = ((progress * 100) % 65536) / 655;
#line 870
          tmp___18 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Progress indication: %d.%02d%%\n",
                             pr, rem);
#line 870
          r += tmp___18;
          }
#line 872
          goto switch_break___0;
          case_1: /* CIL Label */ 
          case_3: /* CIL Label */ 
          case_4: /* CIL Label */ 
          {
#line 876
          tmp___19 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Actual retry count: 0x%02x%02x\n",
                             (int const   )*(sense_buffer + 16), (int const   )*(sense_buffer + 17));
#line 876
          r += tmp___19;
          }
#line 879
          goto switch_break___0;
          case_10: /* CIL Label */ 
          {
#line 881
          tmp___20 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Segment pointer: ");
#line 881
          r += tmp___20;
          }
#line 882
          if ((int const   )*(sense_buffer + 15) & 32) {
#line 882
            tmp___21 = "segment descriptor";
          } else {
#line 882
            tmp___21 = "parameter list";
          }
          {
#line 882
          tmp___22 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"Relative to start of %s, byte %d",
                             tmp___21, ((int const   )*(sense_buffer + 16) << 8) + (int const   )*(sense_buffer + 17));
#line 882
          r += tmp___22;
          }
#line 886
          if ((int const   )*(sense_buffer + 15) & 8) {
            {
#line 887
            tmp___23 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" bit %d\n",
                               (int const   )*(sense_buffer + 15) & 7);
#line 887
            r += tmp___23;
            }
          } else {
            {
#line 890
            tmp___24 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 890
            r += tmp___24;
            }
          }
#line 891
          goto switch_break___0;
          case_6: /* CIL Label */ 
          {
#line 893
          tmp___25 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Unit attention condition queue: ");
#line 893
          r += tmp___25;
#line 894
          tmp___26 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"overflow flag is %d\n",
                             ! (! ((int const   )*(sense_buffer + 15) & 1)));
#line 894
          r += tmp___26;
          }
#line 896
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 898
          tmp___27 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Sense_key: 0x%x unexpected\n",
                             (int )ssh.sense_key);
#line 898
          r += tmp___27;
          }
#line 900
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 903
      if (r > 0) {
        {
#line 904
        tmp___28 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                            (char const   */* __restrict  */)"%s", b);
#line 904
        n += tmp___28;
        }
#line 905
        if (n >= buff_len) {
#line 906
          return;
        }
      }
    } else {
      {
#line 909
      tmp___29 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                          (char const   */* __restrict  */)" fixed descriptor length too short, len=%d\n",
                          len);
#line 909
      n += tmp___29;
      }
#line 911
      if (n >= buff_len) {
#line 912
        return;
      }
    }
  } else {
#line 915
    if (sb_len < 4) {
      {
#line 916
      tmp___30 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                          (char const   */* __restrict  */)"sense buffer too short (4 byte minimum)\n");
#line 916
      n += tmp___30;
      }
#line 918
      return;
    }
    {
#line 920
    r = 0;
#line 921
    tmp___31 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"Probably uninitialized data.\n  Try to view as SCSI-1 non-extended sense:\n");
#line 921
    r += tmp___31;
#line 923
    tmp___32 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  AdValid=%d  Error class=%d  Error code=%d\n",
                       ! (! ((int const   )*(sense_buffer + 0) & 128)), ((int const   )*(sense_buffer + 0) >> 4) & 7,
                       (int const   )*(sense_buffer + 0) & 15);
#line 923
    r += tmp___32;
    }
#line 927
    if ((int const   )*(sense_buffer + 0) & 128) {
      {
#line 928
      tmp___33 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  lba=0x%x\n",
                         ((((int const   )*(sense_buffer + 1) & 31) << 16) + ((int const   )*(sense_buffer + 2) << 8)) + (int const   )*(sense_buffer + 3));
#line 928
      r += tmp___33;
      }
    }
    {
#line 931
    tmp___34 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                        (char const   */* __restrict  */)"%s\n", b);
#line 931
    n += tmp___34;
    }
#line 932
    if (n >= buff_len) {
#line 933
      return;
    }
#line 934
    len = sb_len;
#line 935
    if (len > 32) {
#line 936
      len = 32;
    }
  }
#line 938
  if (raw_sinfo) {
    {
#line 939
    tmp___36 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                        (char const   */* __restrict  */)" Raw sense data (in hex):\n");
#line 939
    n += tmp___36;
    }
#line 940
    if (n >= buff_len) {
#line 941
      return;
    }
    {
#line 942
    dStrHexErr((char const   *)sense_buffer, len, buff_len - n, buff + n);
    }
  }
#line 944
  return;
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_print_sense(char const   *leadin , unsigned char const   *sense_buffer , int sb_len ,
                    int raw_sinfo ) 
{ 
  char b[1024] ;

  {
  {
#line 953
  sg_get_sense_str(leadin, sense_buffer, sb_len, raw_sinfo, (int )sizeof(b), b);
  }
#line 954
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 955
    sg_warnings_strm = stderr;
  }
  {
#line 956
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s",
          b);
  }
#line 957
  return;
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_scsi_normalize_sense(unsigned char const   *sensep , int sb_len , struct sg_scsi_sense_hdr *sshp ) 
{ 


  {
#line 963
  if (sshp) {
    {
#line 964
    memset((void *)sshp, 0, sizeof(struct sg_scsi_sense_hdr ));
    }
  }
#line 965
  if ((unsigned long )((void *)0) == (unsigned long )sensep) {
#line 966
    return (0);
  } else
#line 965
  if (0 == sb_len) {
#line 966
    return (0);
  } else
#line 965
  if (112 != (112 & (int )*(sensep + 0))) {
#line 966
    return (0);
  }
#line 967
  if (sshp) {
#line 968
    sshp->response_code = (unsigned char )(127 & (int )*(sensep + 0));
#line 969
    if ((int )sshp->response_code >= 114) {
#line 970
      if (sb_len > 1) {
#line 971
        sshp->sense_key = (unsigned char )(15 & (int )*(sensep + 1));
      }
#line 972
      if (sb_len > 2) {
#line 973
        sshp->asc = (unsigned char )*(sensep + 2);
      }
#line 974
      if (sb_len > 3) {
#line 975
        sshp->ascq = (unsigned char )*(sensep + 3);
      }
#line 976
      if (sb_len > 7) {
#line 977
        sshp->additional_length = (unsigned char )*(sensep + 7);
      }
    } else {
#line 979
      if (sb_len > 2) {
#line 980
        sshp->sense_key = (unsigned char )(15 & (int )*(sensep + 2));
      }
#line 981
      if (sb_len > 7) {
#line 982
        if (sb_len < (int )((int const   )*(sensep + 7) + 8)) {
#line 982
          sb_len = sb_len;
        } else {
#line 982
          sb_len = (int )((int const   )*(sensep + 7) + 8);
        }
#line 984
        if (sb_len > 12) {
#line 985
          sshp->asc = (unsigned char )*(sensep + 12);
        }
#line 986
        if (sb_len > 13) {
#line 987
          sshp->ascq = (unsigned char )*(sensep + 13);
        }
      }
    }
  }
#line 991
  return (1);
}
}
#line 994 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_err_category_sense(unsigned char const   *sense_buffer , int sb_len ) 
{ 
  struct sg_scsi_sense_hdr ssh ;
  int tmp ;

  {
#line 999
  if (sense_buffer) {
#line 999
    if (sb_len > 2) {
      {
#line 999
      tmp = sg_scsi_normalize_sense(sense_buffer, sb_len, & ssh);
      }
#line 999
      if (tmp) {
        {
#line 1002
        if ((int )ssh.sense_key == 0) {
#line 1002
          goto case_0;
        }
#line 1004
        if ((int )ssh.sense_key == 1) {
#line 1004
          goto case_1;
        }
#line 1006
        if ((int )ssh.sense_key == 2) {
#line 1006
          goto case_2;
        }
#line 1010
        if ((int )ssh.sense_key == 8) {
#line 1010
          goto case_8;
        }
#line 1010
        if ((int )ssh.sense_key == 4) {
#line 1010
          goto case_8;
        }
#line 1010
        if ((int )ssh.sense_key == 3) {
#line 1010
          goto case_8;
        }
#line 1012
        if ((int )ssh.sense_key == 6) {
#line 1012
          goto case_6;
        }
#line 1015
        if ((int )ssh.sense_key == 5) {
#line 1015
          goto case_5;
        }
#line 1021
        if ((int )ssh.sense_key == 11) {
#line 1021
          goto case_11;
        }
#line 1001
        goto switch_break;
        case_0: /* CIL Label */ 
#line 1003
        return (20);
        case_1: /* CIL Label */ 
#line 1005
        return (21);
        case_2: /* CIL Label */ 
#line 1007
        return (2);
        case_8: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 1011
        return (3);
        case_6: /* CIL Label */ 
#line 1013
        return (6);
        case_5: /* CIL Label */ 
#line 1016
        if (32 == (int )ssh.asc) {
#line 1016
          if (0 == (int )ssh.ascq) {
#line 1017
            return (9);
          } else {
#line 1019
            return (5);
          }
        } else {
#line 1019
          return (5);
        }
#line 1020
        goto switch_break;
        case_11: /* CIL Label */ 
#line 1022
        return (11);
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1025
  return (98);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_get_command_size(unsigned char opcode ) 
{ 


  {
  {
#line 1033
  if ((((int )opcode >> 5) & 7) == 0) {
#line 1033
    goto case_0;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 7) {
#line 1035
    goto case_7;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 6) {
#line 1035
    goto case_7;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 2) {
#line 1035
    goto case_7;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 1) {
#line 1035
    goto case_7;
  }
#line 1037
  if ((((int )opcode >> 5) & 7) == 5) {
#line 1037
    goto case_5;
  }
#line 1037
  if ((((int )opcode >> 5) & 7) == 3) {
#line 1037
    goto case_5;
  }
#line 1040
  if ((((int )opcode >> 5) & 7) == 4) {
#line 1040
    goto case_4;
  }
#line 1042
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1034
  return (6);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1036
  return (10);
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1038
  return (12);
#line 1039
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1041
  return (16);
  switch_default: /* CIL Label */ 
#line 1043
  return (10);
  switch_break: /* CIL Label */ ;
  }
#line 1045
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_get_command_name(unsigned char const   *cmdp , int peri_type , int buff_len ,
                         char *buff ) 
{ 
  int service_action ;

  {
#line 1053
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 1054
    return;
  } else
#line 1053
  if (buff_len < 1) {
#line 1054
    return;
  }
#line 1055
  if ((unsigned long )((void *)0) == (unsigned long )cmdp) {
    {
#line 1056
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)"<null> command pointer",
            (size_t )buff_len);
    }
#line 1057
    return;
  }
#line 1059
  if (127 == (int )*(cmdp + 0)) {
#line 1059
    service_action = (int )((int const   )*(cmdp + 1) & 31);
  } else {
#line 1059
    service_action = (int )(((int const   )*(cmdp + 8) << 8) | (int const   )*(cmdp + 9));
  }
  {
#line 1061
  sg_get_opcode_sa_name((unsigned char )*(cmdp + 0), service_action, peri_type, buff_len,
                        buff);
  }
#line 1062
  return;
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_get_opcode_sa_name(unsigned char cmd_byte0 , int service_action , int peri_type ,
                           int buff_len , char *buff ) 
{ 
  struct sg_lib_value_name_t  const  *vnp ;

  {
#line 1071
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 1072
    return;
  } else
#line 1071
  if (buff_len < 1) {
#line 1072
    return;
  }
  {
#line 1074
  if ((int )cmd_byte0 == 127) {
#line 1074
    goto case_127;
  }
#line 1083
  if ((int )cmd_byte0 == 163) {
#line 1083
    goto case_163;
  }
#line 1091
  if ((int )cmd_byte0 == 164) {
#line 1091
    goto case_164;
  }
#line 1099
  if ((int )cmd_byte0 == 171) {
#line 1099
    goto case_171;
  }
#line 1107
  if ((int )cmd_byte0 == 169) {
#line 1107
    goto case_169;
  }
#line 1115
  if ((int )cmd_byte0 == 158) {
#line 1115
    goto case_158;
  }
#line 1123
  if ((int )cmd_byte0 == 159) {
#line 1123
    goto case_159;
  }
#line 1131
  if ((int )cmd_byte0 == 94) {
#line 1131
    goto case_94;
  }
#line 1139
  if ((int )cmd_byte0 == 95) {
#line 1139
    goto case_95;
  }
#line 1147
  goto switch_default;
  case_127: /* CIL Label */ 
  {
#line 1075
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_variable_length_arr),
                       service_action, peri_type);
  }
#line 1077
  if (vnp) {
    {
#line 1078
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1080
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Variable length service action=0x%x",
             service_action);
    }
  }
#line 1082
  goto switch_break;
  case_163: /* CIL Label */ 
  {
#line 1084
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_maint_in_arr),
                       service_action, peri_type);
  }
#line 1085
  if (vnp) {
    {
#line 1086
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1088
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Maintenance in service action=0x%x",
             service_action);
    }
  }
#line 1090
  goto switch_break;
  case_164: /* CIL Label */ 
  {
#line 1092
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_maint_out_arr),
                       service_action, peri_type);
  }
#line 1093
  if (vnp) {
    {
#line 1094
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1096
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Maintenance out service action=0x%x",
             service_action);
    }
  }
#line 1098
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 1100
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_in12_arr),
                       service_action, peri_type);
  }
#line 1101
  if (vnp) {
    {
#line 1102
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1104
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action in(12)=0x%x",
             service_action);
    }
  }
#line 1106
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 1108
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_out12_arr),
                       service_action, peri_type);
  }
#line 1109
  if (vnp) {
    {
#line 1110
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1112
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action out(12)=0x%x",
             service_action);
    }
  }
#line 1114
  goto switch_break;
  case_158: /* CIL Label */ 
  {
#line 1116
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_in16_arr),
                       service_action, peri_type);
  }
#line 1117
  if (vnp) {
    {
#line 1118
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1120
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action in(16)=0x%x",
             service_action);
    }
  }
#line 1122
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 1124
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_out16_arr),
                       service_action, peri_type);
  }
#line 1125
  if (vnp) {
    {
#line 1126
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1128
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action out(16)=0x%x",
             service_action);
    }
  }
#line 1130
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 1132
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_pr_in_arr), service_action,
                       peri_type);
  }
#line 1133
  if (vnp) {
    {
#line 1134
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1136
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Persistent reserve in, service action=0x%x",
             service_action);
    }
  }
#line 1138
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 1140
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_pr_out_arr),
                       service_action, peri_type);
  }
#line 1141
  if (vnp) {
    {
#line 1142
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1144
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Persistent reserve out, service action=0x%x",
             service_action);
    }
  }
#line 1146
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1148
  sg_get_opcode_name(cmd_byte0, peri_type, buff_len, buff);
  }
#line 1149
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1151
  return;
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void sg_get_opcode_name(unsigned char cmd_byte0 , int peri_type , int buff_len , char *buff ) 
{ 
  struct sg_lib_value_name_t  const  *vnp ;
  int grp ;

  {
#line 1160
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 1161
    return;
  } else
#line 1160
  if (buff_len < 1) {
#line 1161
    return;
  }
#line 1162
  if (127 == (int )cmd_byte0) {
    {
#line 1163
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)"Variable length",
            (size_t )buff_len);
    }
#line 1164
    return;
  }
#line 1166
  grp = ((int )cmd_byte0 >> 5) & 7;
  {
#line 1172
  if (grp == 5) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 4) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 2) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 1) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 0) {
#line 1172
    goto case_5;
  }
#line 1179
  if (grp == 3) {
#line 1179
    goto case_3;
  }
#line 1183
  if (grp == 7) {
#line 1183
    goto case_7;
  }
#line 1183
  if (grp == 6) {
#line 1183
    goto case_7;
  }
#line 1186
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1173
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_normal_opcodes),
                       (int )cmd_byte0, peri_type);
  }
#line 1174
  if (vnp) {
    {
#line 1175
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1177
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Opcode=0x%x",
             (int )cmd_byte0);
    }
  }
#line 1178
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1180
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Reserved [0x%x]",
           (int )cmd_byte0);
  }
#line 1181
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 1184
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Vendor specific [0x%x]",
           (int )cmd_byte0);
  }
#line 1185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1187
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Opcode=0x%x",
           (int )cmd_byte0);
  }
#line 1188
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1190
  return;
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_vpd_dev_id_iter(unsigned char const   *initial_desig_desc , int page_len ,
                       int *off , int m_assoc , int m_desig_type , int m_code_set ) 
{ 
  unsigned char const   *ucp ;
  int k ;
  int c_set ;
  int assoc ;
  int desig_type ;
  int tmp ;

  {
#line 1199
  k = *off;
#line 1199
  ucp = initial_desig_desc;
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1199
    if (! (k + 3 < page_len)) {
#line 1199
      goto while_break;
    }
#line 1200
    if (k < 0) {
#line 1200
      k = 0;
    } else {
#line 1200
      k = (k + (int )*(ucp + (k + 3))) + 4;
    }
#line 1201
    if (k + 4 > page_len) {
#line 1202
      goto while_break;
    }
#line 1203
    c_set = (int )((int const   )*(ucp + k) & 15);
#line 1204
    if (m_code_set >= 0) {
#line 1204
      if (m_code_set != c_set) {
#line 1205
        goto __Cont;
      }
    }
#line 1206
    assoc = (int )(((int const   )*(ucp + (k + 1)) >> 4) & 3);
#line 1207
    if (m_assoc >= 0) {
#line 1207
      if (m_assoc != assoc) {
#line 1208
        goto __Cont;
      }
    }
#line 1209
    desig_type = (int )((int const   )*(ucp + (k + 1)) & 15);
#line 1210
    if (m_desig_type >= 0) {
#line 1210
      if (m_desig_type != desig_type) {
#line 1211
        goto __Cont;
      }
    }
#line 1212
    *off = k;
#line 1213
    return (0);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1215
  if (k == page_len) {
#line 1215
    tmp = -1;
  } else {
#line 1215
    tmp = -2;
  }
#line 1215
  return (tmp);
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static char safe_errbuf[64]  = 
#line 1224
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 1227 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
char *safe_strerror(int errnum ) 
{ 
  size_t len ;
  char *errstr ;

  {
#line 1233
  if (errnum < 0) {
#line 1234
    errnum = - errnum;
  }
  {
#line 1235
  errstr = strerror(errnum);
  }
#line 1236
  if ((unsigned long )((void *)0) == (unsigned long )errstr) {
    {
#line 1237
    len = strlen((char const   *)(safe_errbuf));
#line 1238
    snprintf((char */* __restrict  */)(safe_errbuf + len), sizeof(safe_errbuf) - len,
             (char const   */* __restrict  */)"%i", errnum);
#line 1239
    safe_errbuf[sizeof(safe_errbuf) - 1UL] = (char )'\000';
    }
#line 1240
    return (safe_errbuf);
  }
#line 1242
  return (errstr);
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void dStrHex(char const   *str , int len , int no_ascii ) 
{ 
  char const   *p ;
  char const   *formatstr ;
  unsigned char c ;
  char buff[82] ;
  int a ;
  int bpstart ;
  int cpstart ;
  int cpos ;
  int bpos ;
  int i ;
  int k ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1255
  p = str;
#line 1259
  a = 0;
#line 1260
  bpstart = 5;
#line 1261
  cpstart = 60;
#line 1262
  cpos = cpstart;
#line 1263
  bpos = bpstart;
#line 1266
  if (len <= 0) {
#line 1267
    return;
  }
#line 1268
  if (0 == no_ascii) {
#line 1268
    formatstr = "%.76s\n";
  } else {
#line 1268
    formatstr = "%.56s\n";
  }
  {
#line 1269
  memset((void *)(buff), ' ', (size_t )80);
#line 1270
  buff[80] = (char )'\000';
  }
#line 1271
  if (no_ascii < 0) {
#line 1272
    k = 0;
    {
#line 1272
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1272
      if (! (k < len)) {
#line 1272
        goto while_break;
      }
#line 1273
      tmp = p;
#line 1273
      p ++;
#line 1273
      c = (unsigned char )*tmp;
#line 1274
      bpos += 3;
#line 1275
      if (bpos == bpstart + 27) {
#line 1276
        bpos ++;
      }
      {
#line 1277
      sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
              (int )c);
#line 1278
      buff[bpos + 2] = (char )' ';
      }
#line 1279
      if (k > 0) {
#line 1279
        if (0 == (k + 1) % 16) {
          {
#line 1280
          printf((char const   */* __restrict  */)formatstr, buff);
#line 1281
          bpos = bpstart;
#line 1282
          memset((void *)(buff), ' ', (size_t )80);
          }
        }
      }
#line 1272
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1285
    if (bpos > bpstart) {
      {
#line 1286
      buff[bpos + 2] = (char )'\000';
#line 1287
      printf((char const   */* __restrict  */)"%s\n", buff);
      }
    }
#line 1289
    return;
  }
  {
#line 1292
  k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
              a);
#line 1293
  buff[k + 1] = (char )' ';
#line 1295
  i = 0;
  }
  {
#line 1295
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1295
    if (! (i < len)) {
#line 1295
      goto while_break___0;
    }
#line 1296
    tmp___0 = p;
#line 1296
    p ++;
#line 1296
    c = (unsigned char )*tmp___0;
#line 1297
    bpos += 3;
#line 1298
    if (bpos == bpstart + 27) {
#line 1299
      bpos ++;
    }
    {
#line 1300
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
            (int )c);
#line 1301
    buff[bpos + 2] = (char )' ';
    }
#line 1302
    if (no_ascii) {
#line 1303
      tmp___1 = cpos;
#line 1303
      cpos ++;
#line 1303
      buff[tmp___1] = (char )' ';
    } else {
#line 1305
      if ((int )c < 32) {
#line 1306
        c = (unsigned char )'.';
      } else
#line 1305
      if ((int )c >= 127) {
#line 1306
        c = (unsigned char )'.';
      }
#line 1307
      tmp___2 = cpos;
#line 1307
      cpos ++;
#line 1307
      buff[tmp___2] = (char )c;
    }
#line 1309
    if (cpos > cpstart + 15) {
      {
#line 1310
      printf((char const   */* __restrict  */)formatstr, buff);
#line 1311
      bpos = bpstart;
#line 1312
      cpos = cpstart;
#line 1313
      a += 16;
#line 1314
      memset((void *)(buff), ' ', (size_t )80);
#line 1315
      k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
                  a);
#line 1316
      buff[k + 1] = (char )' ';
      }
    }
#line 1295
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1319
  if (cpos > cpstart) {
    {
#line 1320
    buff[cpos] = (char )'\000';
#line 1321
    printf((char const   */* __restrict  */)"%s\n", buff);
    }
  }
#line 1323
  return;
}
}
#line 1327 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static void dStrHexErr(char const   *str , int len , int b_len , char *b ) 
{ 
  char const   *p ;
  unsigned char c ;
  char buff[82] ;
  int bpstart ;
  int bpos ;
  int k ;
  int n ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1330
  p = str;
#line 1333
  bpstart = 5;
#line 1334
  bpos = bpstart;
#line 1337
  if (len <= 0) {
#line 1338
    return;
  }
  {
#line 1339
  n = 0;
#line 1340
  memset((void *)(buff), ' ', (size_t )80);
#line 1341
  buff[80] = (char )'\000';
#line 1342
  k = 0;
  }
  {
#line 1342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1342
    if (! (k < len)) {
#line 1342
      goto while_break;
    }
#line 1343
    tmp = p;
#line 1343
    p ++;
#line 1343
    c = (unsigned char )*tmp;
#line 1344
    bpos += 3;
#line 1345
    if (bpos == bpstart + 27) {
#line 1346
      bpos ++;
    }
    {
#line 1347
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
            (int )c);
#line 1348
    buff[bpos + 2] = (char )' ';
    }
#line 1349
    if (k > 0) {
#line 1349
      if (0 == (k + 1) % 16) {
        {
#line 1350
        tmp___0 = snprintf((char */* __restrict  */)(b + n), (size_t )(b_len - n),
                           (char const   */* __restrict  */)"%.60s\n", buff);
#line 1350
        n += tmp___0;
        }
#line 1351
        if (n >= b_len) {
#line 1352
          return;
        }
        {
#line 1353
        bpos = bpstart;
#line 1354
        memset((void *)(buff), ' ', (size_t )80);
        }
      }
    }
#line 1342
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1357
  if (bpos > bpstart) {
    {
#line 1358
    tmp___1 = snprintf((char */* __restrict  */)(b + n), (size_t )(b_len - n), (char const   */* __restrict  */)"%.60s\n",
                       buff);
#line 1358
    n += tmp___1;
    }
  }
#line 1359
  return;
}
}
#line 1365 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_is_big_endian(void) 
{ 
  union u_t u ;

  {
#line 1373
  u.s = (unsigned short)258;
#line 1374
  return ((int )u.c[0] == 1);
}
}
#line 1378 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
static unsigned short swapb_ushort(unsigned short u ) 
{ 
  unsigned short r ;

  {
#line 1383
  r = (unsigned short )(((int )u >> 8) & 255);
#line 1384
  r = (unsigned short )((int )r | (((int )u & 255) << 8));
#line 1385
  return (r);
}
}
#line 1398 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
void dWordHex(unsigned short const   *words , int num , int no_ascii , int swapb ) 
{ 
  unsigned short const   *p ;
  unsigned short c ;
  char buff[82] ;
  unsigned char upp ;
  unsigned char low ;
  int a ;
  int bpstart ;
  int cpstart ;
  int cpos ;
  int bpos ;
  int i ;
  int k ;
  unsigned short const   *tmp ;
  unsigned short const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1401
  p = words;
#line 1405
  a = 0;
#line 1406
  bpstart = 3;
#line 1407
  cpstart = 52;
#line 1408
  cpos = cpstart;
#line 1409
  bpos = bpstart;
#line 1412
  if (num <= 0) {
#line 1413
    return;
  }
  {
#line 1414
  memset((void *)(buff), ' ', (size_t )80);
#line 1415
  buff[80] = (char )'\000';
  }
#line 1416
  if (no_ascii < 0) {
#line 1417
    k = 0;
    {
#line 1417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1417
      if (! (k < num)) {
#line 1417
        goto while_break;
      }
#line 1418
      tmp = p;
#line 1418
      p ++;
#line 1418
      c = (unsigned short )*tmp;
#line 1419
      if (swapb) {
        {
#line 1420
        c = swapb_ushort(c);
        }
      }
      {
#line 1421
      bpos += 5;
#line 1422
      sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.4x",
              (unsigned int )c);
#line 1423
      buff[bpos + 4] = (char )' ';
      }
#line 1424
      if (k > 0) {
#line 1424
        if (0 == (k + 1) % 8) {
#line 1425
          if (-2 == no_ascii) {
            {
#line 1426
            printf((char const   */* __restrict  */)"%.39s\n", buff + 8);
            }
          } else {
            {
#line 1428
            printf((char const   */* __restrict  */)"%.47s\n", buff);
            }
          }
          {
#line 1429
          bpos = bpstart;
#line 1430
          memset((void *)(buff), ' ', (size_t )80);
          }
        }
      }
#line 1417
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1433
    if (bpos > bpstart) {
#line 1434
      if (-2 == no_ascii) {
        {
#line 1435
        printf((char const   */* __restrict  */)"%.39s\n", buff + 8);
        }
      } else {
        {
#line 1437
        printf((char const   */* __restrict  */)"%.47s\n", buff);
        }
      }
    }
#line 1439
    return;
  }
  {
#line 1442
  k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
              a);
#line 1443
  buff[k + 1] = (char )' ';
#line 1445
  i = 0;
  }
  {
#line 1445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1445
    if (! (i < num)) {
#line 1445
      goto while_break___0;
    }
#line 1446
    tmp___0 = p;
#line 1446
    p ++;
#line 1446
    c = (unsigned short )*tmp___0;
#line 1447
    if (swapb) {
      {
#line 1448
      c = swapb_ushort(c);
      }
    }
    {
#line 1449
    bpos += 5;
#line 1450
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.4x",
            (unsigned int )c);
#line 1451
    buff[bpos + 4] = (char )' ';
    }
#line 1452
    if (no_ascii) {
#line 1453
      tmp___1 = cpos;
#line 1453
      cpos ++;
#line 1453
      buff[tmp___1] = (char )' ';
#line 1454
      tmp___2 = cpos;
#line 1454
      cpos ++;
#line 1454
      buff[tmp___2] = (char )' ';
#line 1455
      tmp___3 = cpos;
#line 1455
      cpos ++;
#line 1455
      buff[tmp___3] = (char )' ';
    } else {
#line 1457
      upp = (unsigned char )(((int )c >> 8) & 255);
#line 1458
      low = (unsigned char )((int )c & 255);
#line 1459
      if ((int )upp < 32) {
#line 1460
        upp = (unsigned char )'.';
      } else
#line 1459
      if ((int )upp >= 127) {
#line 1460
        upp = (unsigned char )'.';
      }
#line 1461
      tmp___4 = cpos;
#line 1461
      cpos ++;
#line 1461
      buff[tmp___4] = (char )upp;
#line 1462
      if ((int )low < 32) {
#line 1463
        low = (unsigned char )'.';
      } else
#line 1462
      if ((int )low >= 127) {
#line 1463
        low = (unsigned char )'.';
      }
#line 1464
      tmp___5 = cpos;
#line 1464
      cpos ++;
#line 1464
      buff[tmp___5] = (char )low;
#line 1465
      tmp___6 = cpos;
#line 1465
      cpos ++;
#line 1465
      buff[tmp___6] = (char )' ';
    }
#line 1467
    if (cpos > cpstart + 23) {
      {
#line 1468
      printf((char const   */* __restrict  */)"%.76s\n", buff);
#line 1469
      bpos = bpstart;
#line 1470
      cpos = cpstart;
#line 1471
      a += 8;
#line 1472
      memset((void *)(buff), ' ', (size_t )80);
#line 1473
      k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
                  a);
#line 1474
      buff[k + 1] = (char )' ';
      }
    }
#line 1445
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1477
  if (cpos > cpstart) {
    {
#line 1478
    printf((char const   */* __restrict  */)"%.76s\n", buff);
    }
  }
#line 1479
  return;
}
}
#line 1485 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_get_num(char const   *buf ) 
{ 
  int res ;
  int num ;
  int n ;
  int len ;
  unsigned int unum ;
  char *cp ;
  char c ;
  char c2 ;
  char c3 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1491
  c = (char )'c';
#line 1494
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1495
    return (-1);
  } else
#line 1494
  if (0 == (int )*(buf + 0)) {
#line 1495
    return (-1);
  }
  {
#line 1496
  tmp = strlen(buf);
#line 1496
  len = (int )tmp;
  }
#line 1497
  if (48 == (int )*(buf + 0)) {
#line 1497
    if (120 == (int )*(buf + 1)) {
      {
#line 1498
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1499
      num = (int )unum;
      }
    } else
#line 1497
    if (88 == (int )*(buf + 1)) {
      {
#line 1498
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1499
      num = (int )unum;
      }
    } else {
#line 1497
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1500
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 1500
    if (72 == tmp___0) {
      {
#line 1501
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 1502
      num = (int )unum;
      }
    } else {
      {
#line 1504
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d%c%c%c",
                   & num, & c, & c2, & c3);
      }
    }
  }
#line 1505
  if (res < 1) {
#line 1506
    return (-1);
  } else
#line 1507
  if (1 == res) {
#line 1508
    return (num);
  } else {
#line 1510
    if (res > 2) {
      {
#line 1511
      tmp___1 = toupper((int )c2);
#line 1511
      c2 = (char )tmp___1;
      }
    }
#line 1512
    if (res > 3) {
      {
#line 1513
      tmp___2 = toupper((int )c3);
#line 1513
      c3 = (char )tmp___2;
      }
    }
    {
#line 1514
    tmp___3 = toupper((int )c);
    }
    {
#line 1515
    if (tmp___3 == 67) {
#line 1515
      goto case_67;
    }
#line 1517
    if (tmp___3 == 87) {
#line 1517
      goto case_87;
    }
#line 1519
    if (tmp___3 == 66) {
#line 1519
      goto case_66;
    }
#line 1521
    if (tmp___3 == 75) {
#line 1521
      goto case_75;
    }
#line 1529
    if (tmp___3 == 77) {
#line 1529
      goto case_77;
    }
#line 1537
    if (tmp___3 == 71) {
#line 1537
      goto case_71;
    }
#line 1545
    if (tmp___3 == 88) {
#line 1545
      goto case_88;
    }
#line 1555
    goto switch_default;
    case_67: /* CIL Label */ 
#line 1516
    return (num);
    case_87: /* CIL Label */ 
#line 1518
    return (num * 2);
    case_66: /* CIL Label */ 
#line 1520
    return (num * 512);
    case_75: /* CIL Label */ 
#line 1522
    if (2 == res) {
#line 1523
      return (num * 1024);
    }
#line 1524
    if (66 == (int )c2) {
#line 1525
      return (num * 1000);
    } else
#line 1524
    if (68 == (int )c2) {
#line 1525
      return (num * 1000);
    }
#line 1526
    if (73 == (int )c2) {
#line 1526
      if (4 == res) {
#line 1526
        if (66 == (int )c3) {
#line 1527
          return (num * 1024);
        }
      }
    }
#line 1528
    return (-1);
    case_77: /* CIL Label */ 
#line 1530
    if (2 == res) {
#line 1531
      return (num * 1048576);
    }
#line 1532
    if (66 == (int )c2) {
#line 1533
      return (num * 1000000);
    } else
#line 1532
    if (68 == (int )c2) {
#line 1533
      return (num * 1000000);
    }
#line 1534
    if (73 == (int )c2) {
#line 1534
      if (4 == res) {
#line 1534
        if (66 == (int )c3) {
#line 1535
          return (num * 1048576);
        }
      }
    }
#line 1536
    return (-1);
    case_71: /* CIL Label */ 
#line 1538
    if (2 == res) {
#line 1539
      return (num * 1073741824);
    }
#line 1540
    if (66 == (int )c2) {
#line 1541
      return (num * 1000000000);
    } else
#line 1540
    if (68 == (int )c2) {
#line 1541
      return (num * 1000000000);
    }
#line 1542
    if (73 == (int )c2) {
#line 1542
      if (4 == res) {
#line 1542
        if (66 == (int )c3) {
#line 1543
          return (num * 1073741824);
        }
      }
    }
#line 1544
    return (-1);
    case_88: /* CIL Label */ 
    {
#line 1546
    cp = strchr(buf, 'x');
    }
#line 1547
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 1548
      cp = strchr(buf, 'X');
      }
    }
#line 1549
    if (cp) {
      {
#line 1550
      n = sg_get_num((char const   *)(cp + 1));
      }
#line 1551
      if (-1 != n) {
#line 1552
        return (num * n);
      }
    }
#line 1554
    return (-1);
    switch_default: /* CIL Label */ 
#line 1556
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1557
      sg_warnings_strm = stderr;
    }
    {
#line 1558
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"unrecognized multiplier\n");
    }
#line 1559
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 1568 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_get_num_nomult(char const   *buf ) 
{ 
  int res ;
  int len ;
  int num ;
  unsigned int unum ;
  char const   *commap ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1575
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1576
    return (-1);
  } else
#line 1575
  if (0 == (int )*(buf + 0)) {
#line 1576
    return (-1);
  }
  {
#line 1577
  tmp = strlen(buf);
#line 1577
  len = (int )tmp;
#line 1578
  tmp___0 = strchr(buf + 1, ',');
#line 1578
  commap = (char const   *)tmp___0;
  }
#line 1579
  if (48 == (int )*(buf + 0)) {
#line 1579
    if (120 == (int )*(buf + 1)) {
      {
#line 1580
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1581
      num = (int )unum;
      }
    } else
#line 1579
    if (88 == (int )*(buf + 1)) {
      {
#line 1580
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1581
      num = (int )unum;
      }
    } else {
#line 1579
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1582
  if (commap) {
    {
#line 1582
    tmp___2 = toupper((int )*(commap - 1));
    }
#line 1582
    if (72 == tmp___2) {
      {
#line 1583
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 1584
      num = (int )unum;
      }
    } else {
#line 1582
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1585
  if ((unsigned long )((void *)0) == (unsigned long )commap) {
    {
#line 1585
    tmp___1 = toupper((int )*(buf + (len - 1)));
    }
#line 1585
    if (72 == tmp___1) {
      {
#line 1586
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 1587
      num = (int )unum;
      }
    } else {
      {
#line 1589
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d",
                   & num);
      }
    }
  } else {
    {
#line 1589
    res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d",
                 & num);
    }
  }
#line 1590
  if (1 == res) {
#line 1591
    return (num);
  } else {
#line 1593
    return (-1);
  }
}
}
#line 1600 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int64_t sg_get_llnum(char const   *buf ) 
{ 
  int res ;
  int len ;
  int64_t num ;
  int64_t ll ;
  uint64_t unum ;
  char *cp ;
  char c ;
  char c2 ;
  char c3 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1607
  c = (char )'c';
#line 1610
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1611
    return ((int64_t )-1LL);
  } else
#line 1610
  if (0 == (int )*(buf + 0)) {
#line 1611
    return ((int64_t )-1LL);
  }
  {
#line 1612
  tmp = strlen(buf);
#line 1612
  len = (int )tmp;
  }
#line 1613
  if (48 == (int )*(buf + 0)) {
#line 1613
    if (120 == (int )*(buf + 1)) {
      {
#line 1614
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1615
      num = (int64_t )unum;
      }
    } else
#line 1613
    if (88 == (int )*(buf + 1)) {
      {
#line 1614
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1615
      num = (int64_t )unum;
      }
    } else {
#line 1613
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1616
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 1616
    if (72 == tmp___0) {
      {
#line 1617
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1618
      num = (int64_t )unum;
      }
    } else {
      {
#line 1620
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%ld%c%c%c",
                   & num, & c, & c2, & c3);
      }
    }
  }
#line 1621
  if (res < 1) {
#line 1622
    return ((int64_t )-1LL);
  } else
#line 1623
  if (1 == res) {
#line 1624
    return (num);
  } else {
#line 1626
    if (res > 2) {
      {
#line 1627
      tmp___1 = toupper((int )c2);
#line 1627
      c2 = (char )tmp___1;
      }
    }
#line 1628
    if (res > 3) {
      {
#line 1629
      tmp___2 = toupper((int )c3);
#line 1629
      c3 = (char )tmp___2;
      }
    }
    {
#line 1630
    tmp___3 = toupper((int )c);
    }
    {
#line 1631
    if (tmp___3 == 67) {
#line 1631
      goto case_67;
    }
#line 1633
    if (tmp___3 == 87) {
#line 1633
      goto case_87;
    }
#line 1635
    if (tmp___3 == 66) {
#line 1635
      goto case_66;
    }
#line 1637
    if (tmp___3 == 75) {
#line 1637
      goto case_75;
    }
#line 1645
    if (tmp___3 == 77) {
#line 1645
      goto case_77;
    }
#line 1653
    if (tmp___3 == 71) {
#line 1653
      goto case_71;
    }
#line 1661
    if (tmp___3 == 84) {
#line 1661
      goto case_84;
    }
#line 1669
    if (tmp___3 == 80) {
#line 1669
      goto case_80;
    }
#line 1677
    if (tmp___3 == 88) {
#line 1677
      goto case_88;
    }
#line 1687
    goto switch_default;
    case_67: /* CIL Label */ 
#line 1632
    return (num);
    case_87: /* CIL Label */ 
#line 1634
    return (num * 2L);
    case_66: /* CIL Label */ 
#line 1636
    return (num * 512L);
    case_75: /* CIL Label */ 
#line 1638
    if (2 == res) {
#line 1639
      return (num * 1024L);
    }
#line 1640
    if (66 == (int )c2) {
#line 1641
      return (num * 1000L);
    } else
#line 1640
    if (68 == (int )c2) {
#line 1641
      return (num * 1000L);
    }
#line 1642
    if (73 == (int )c2) {
#line 1642
      if (4 == res) {
#line 1642
        if (66 == (int )c3) {
#line 1643
          return (num * 1024L);
        }
      }
    }
#line 1644
    return ((int64_t )-1LL);
    case_77: /* CIL Label */ 
#line 1646
    if (2 == res) {
#line 1647
      return (num * 1048576L);
    }
#line 1648
    if (66 == (int )c2) {
#line 1649
      return (num * 1000000L);
    } else
#line 1648
    if (68 == (int )c2) {
#line 1649
      return (num * 1000000L);
    }
#line 1650
    if (73 == (int )c2) {
#line 1650
      if (4 == res) {
#line 1650
        if (66 == (int )c3) {
#line 1651
          return (num * 1048576L);
        }
      }
    }
#line 1652
    return ((int64_t )-1LL);
    case_71: /* CIL Label */ 
#line 1654
    if (2 == res) {
#line 1655
      return (num * 1073741824L);
    }
#line 1656
    if (66 == (int )c2) {
#line 1657
      return (num * 1000000000L);
    } else
#line 1656
    if (68 == (int )c2) {
#line 1657
      return (num * 1000000000L);
    }
#line 1658
    if (73 == (int )c2) {
#line 1658
      if (4 == res) {
#line 1658
        if (66 == (int )c3) {
#line 1659
          return (num * 1073741824L);
        }
      }
    }
#line 1660
    return ((int64_t )-1LL);
    case_84: /* CIL Label */ 
#line 1662
    if (2 == res) {
#line 1663
      return ((int64_t )((long long )num * 1099511627776LL));
    }
#line 1664
    if (66 == (int )c2) {
#line 1665
      return ((int64_t )((long long )num * 1000000000000LL));
    } else
#line 1664
    if (68 == (int )c2) {
#line 1665
      return ((int64_t )((long long )num * 1000000000000LL));
    }
#line 1666
    if (73 == (int )c2) {
#line 1666
      if (4 == res) {
#line 1666
        if (66 == (int )c3) {
#line 1667
          return ((int64_t )((long long )num * 1099511627776LL));
        }
      }
    }
#line 1668
    return ((int64_t )-1LL);
    case_80: /* CIL Label */ 
#line 1670
    if (2 == res) {
#line 1671
      return ((int64_t )(((long long )num * 1099511627776LL) * 1024LL));
    }
#line 1672
    if (66 == (int )c2) {
#line 1673
      return ((int64_t )(((long long )num * 1000000000000LL) * 1000LL));
    } else
#line 1672
    if (68 == (int )c2) {
#line 1673
      return ((int64_t )(((long long )num * 1000000000000LL) * 1000LL));
    }
#line 1674
    if (73 == (int )c2) {
#line 1674
      if (4 == res) {
#line 1674
        if (66 == (int )c3) {
#line 1675
          return ((int64_t )(((long long )num * 1099511627776LL) * 1024LL));
        }
      }
    }
#line 1676
    return ((int64_t )-1LL);
    case_88: /* CIL Label */ 
    {
#line 1678
    cp = strchr(buf, 'x');
    }
#line 1679
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 1680
      cp = strchr(buf, 'X');
      }
    }
#line 1681
    if (cp) {
      {
#line 1682
      ll = sg_get_llnum((char const   *)(cp + 1));
      }
#line 1683
      if (-1LL != (long long )ll) {
#line 1684
        return (num * ll);
      }
    }
#line 1686
    return ((int64_t )-1LL);
    switch_default: /* CIL Label */ 
#line 1688
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1689
      sg_warnings_strm = stderr;
    }
    {
#line 1690
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"unrecognized multiplier\n");
    }
#line 1691
    return ((int64_t )-1LL);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 1700 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_ata_get_chars(unsigned short const   *word_arr , int start_word , int num_words ,
                     int is_big_endian , char *ochars ) 
{ 
  int k ;
  unsigned short s ;
  char a ;
  char b ;
  char *op ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1707
  op = ochars;
#line 1709
  k = start_word;
  {
#line 1709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1709
    if (! (k < start_word + num_words)) {
#line 1709
      goto while_break;
    }
#line 1710
    s = (unsigned short )*(word_arr + k);
#line 1711
    if (is_big_endian) {
#line 1712
      a = (char )((int )s & 255);
#line 1713
      b = (char )(((int )s >> 8) & 255);
    } else {
#line 1715
      a = (char )(((int )s >> 8) & 255);
#line 1716
      b = (char )((int )s & 255);
    }
#line 1718
    if ((int )a == 0) {
#line 1719
      goto while_break;
    }
#line 1720
    tmp = op;
#line 1720
    op ++;
#line 1720
    *tmp = a;
#line 1721
    if ((int )b == 0) {
#line 1722
      goto while_break;
    }
#line 1723
    tmp___0 = op;
#line 1723
    op ++;
#line 1723
    *tmp___0 = b;
#line 1709
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1725
  return ((int )(op - ochars));
}
}
#line 1728 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
char const   *sg_lib_version(void) 
{ 


  {
#line 1731
  return (sg_lib_version_str);
}
}
#line 1759 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_set_text_mode(int fd ) 
{ 


  {
#line 1762
  return (fd);
}
}
#line 1765 "/home/june/repo/benchmarks/collector/temp/ddpt-0.92/src/../lib/sg_lib.c"
int sg_set_binary_mode(int fd ) 
{ 


  {
#line 1768
  return (fd);
}
}
