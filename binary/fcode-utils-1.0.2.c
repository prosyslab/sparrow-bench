/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 45 "../shared/types.h"
typedef u_int8_t u8;
#line 58
enum boolean {
    FALSE = 0,
    TRUE = -1
} ;
#line 58 "../shared/types.h"
typedef enum boolean bool;
#line 52 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/strsubvocab.h"
struct str_sub_vocab {
   u8 *name ;
   u8 *alias ;
   struct str_sub_vocab *next ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/strsubvocab.h"
typedef struct str_sub_vocab str_sub_vocab_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
struct incl_list {
   char *dir_path ;
   struct incl_list *next ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
typedef struct incl_list incl_list_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 48 "../shared/types.h"
typedef u_int16_t u16;
#line 156 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
struct fcode_range {
   u16 fcr_start ;
   u16 fcr_end ;
   char *fcr_infile ;
   int fcr_linenum ;
   bool fcr_not_lapped ;
   struct fcode_range *fcr_next ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
typedef struct fcode_range fcode_range_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.h"
enum fword_token {
    UNSPECIFIED = 3131953165U,
    COMMON_FWORD = 3236806878U,
    BI_FWRD_DEFN = 2985574557U,
    COLON = 1,
    SEMICOLON = 2,
    TICK = 3,
    AGAIN = 4,
    ALIAS = 5,
    BRACK_TICK = 6,
    F_BRACK_TICK = 7,
    ASCII = 8,
    BEGIN = 9,
    BUFFER = 10,
    CASE = 11,
    CONST = 12,
    CONTROL = 13,
    CREATE = 14,
    DECIMAL = 15,
    DEFER = 16,
    DEFINED = 17,
    CDO = 18,
    DO = 19,
    ELSE = 20,
    ENDCASE = 21,
    ENDOF = 22,
    EXTERNAL = 23,
    INSTANCE = 24,
    FIELD = 25,
    NEW_DEVICE = 26,
    FINISH_DEVICE = 27,
    FLITERAL = 28,
    HEADERLESS = 29,
    HEADERS = 30,
    HEX = 31,
    IF = 32,
    UNLOOP = 33,
    LEAVE = 34,
    LOOP_I = 35,
    LOOP_J = 36,
    LOOP = 37,
    PLUS_LOOP = 38,
    OCTAL = 39,
    OF = 40,
    REPEAT = 41,
    THEN = 42,
    TO = 43,
    IS = 44,
    UNTIL = 45,
    VALUE = 46,
    VARIABLE = 47,
    WHILE = 48,
    OFFSET16 = 49,
    ESCAPETOK = 50,
    EMITBYTE = 51,
    FLOAD = 52,
    STRING = 53,
    PSTRING = 54,
    PBSTRING = 55,
    SSTRING = 56,
    RECURSIVE = 57,
    RECURSE = 58,
    RET_STK_FETCH = 59,
    RET_STK_FROM = 60,
    RET_STK_TO = 61,
    HEXVAL = 62,
    DECVAL = 63,
    OCTVAL = 64,
    ret_stk_from = 65,
    ASC_NUM = 66,
    ASC_LEFT_NUM = 67,
    CONDL_ENDER = 68,
    CONDL_ELSE = 69,
    PUSH_FCODE = 70,
    POP_FCODE = 71,
    RESET_FCODE = 72,
    CURLY_BRACE = 73,
    DASH_ARROW = 74,
    LOCAL_VAL = 75,
    EXIT = 76,
    FUNC_NAME = 77,
    IFILE_NAME = 78,
    ILINE_NUM = 79,
    CL_FLAG = 80,
    SHOW_CL_FLAGS = 81,
    OVERLOAD = 82,
    ALLOW_MULTI_LINE = 83,
    MACRO_DEF = 84,
    GLOB_SCOPE = 85,
    DEV_SCOPE = 86,
    END0 = 215,
    END1 = 216,
    CHAR = 217,
    CCHAR = 218,
    ABORTTXT = 219,
    NEXTFCODE = 220,
    ENCODEFILE = 221,
    FCODE_V1 = 222,
    FCODE_V3 = 223,
    NOTLAST = 224,
    ISLAST = 225,
    SETLAST = 226,
    PCIREV = 227,
    PCIHDR = 228,
    PCIEND = 229,
    RESETSYMBS = 230,
    SAVEIMG = 231,
    START0 = 232,
    START1 = 233,
    START2 = 234,
    START4 = 235,
    VERSION1 = 236,
    FCODE_TIME = 237,
    FCODE_DATE = 238,
    FCODE_V2 = 239,
    FCODE_END = 255
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.h"
typedef enum fword_token fwtoken;
#line 160 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
union tic_param {
   long deflt_elem ;
   long long_val ;
   fwtoken fw_token ;
   bool *bool_ptr ;
   char *chr_ptr ;
};
#line 160 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef union tic_param tic_param_t;
#line 178 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
struct tic_hdr {
   char *name ;
   struct tic_hdr *next ;
   void (*funct)() ;
   tic_param_t pfield ;
   fwtoken fword_defr ;
   bool is_token ;
   void (*ign_func)() ;
   int pfld_size ;
   bool tracing ;
};
#line 178 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef struct tic_hdr tic_hdr_t;
#line 198 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
union tic_fwt_param {
   fwtoken deflt_elem ;
   long long_val ;
   fwtoken fw_token ;
   bool *bool_ptr ;
   char *chr_ptr ;
};
#line 198 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef union tic_fwt_param tic_fwt_param_t;
#line 207 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
struct tic_fwt_hdr {
   char *name ;
   struct tic_fwt_hdr *next ;
   void (*funct)() ;
   tic_fwt_param_t pfield ;
   fwtoken fword_defr ;
   bool is_token ;
   void (*ign_func)() ;
   int pfld_size ;
   bool tracing ;
};
#line 207 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef struct tic_fwt_hdr tic_fwt_hdr_t;
#line 264 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
union tic_bool_param {
   bool *deflt_elem ;
   long long_val ;
   fwtoken fw_token ;
   bool *bool_ptr ;
   char *chr_ptr ;
};
#line 264 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef union tic_bool_param tic_bool_param_t;
#line 273 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
struct tic_bool_hdr {
   char *name ;
   struct tic_bool_hdr *next ;
   void (*funct)() ;
   tic_bool_param_t pfield ;
   fwtoken fword_defr ;
   bool is_token ;
   void (*ign_func)() ;
   int pfld_size ;
   bool tracing ;
};
#line 273 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef struct tic_bool_hdr tic_bool_hdr_t;
#line 56 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.h"
struct device_node {
   struct device_node *parent_node ;
   char *ifile_name ;
   unsigned int line_no ;
   tic_hdr_t *tokens_vocab ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.h"
typedef struct device_node device_node_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 44 "../shared/types.h"
typedef int8_t s8;
#line 47 "../shared/types.h"
typedef int16_t s16;
#line 286 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
struct cstag_group {
   unsigned long cs_tag ;
   char *cs_inp_fil ;
   unsigned int cs_line_num ;
   unsigned int cs_abs_token_num ;
   char *cs_word ;
   bool cs_not_dup ;
   unsigned long cs_datum ;
   struct cstag_group *prev ;
};
#line 286 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
typedef struct cstag_group cstag_group_t;
#line 94 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.h"
struct cl_flag {
   char *clflag_name ;
   bool *flag_var ;
   char *clflag_tabs ;
   char *clflag_expln ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.h"
typedef struct cl_flag cl_flag_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 51 "../shared/types.h"
typedef u_int32_t u32;
#line 65 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
enum headeredness_t {
    FLAG_HEADERLESS = 0,
    FLAG_EXTERNAL = 1,
    FLAG_HEADERS = 2
} ;
#line 65 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
typedef enum headeredness_t headeredness;
#line 336 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
struct source_state {
   struct source_state *next ;
   u8 *old_start ;
   u8 *old_pc ;
   u8 *old_end ;
   char *old_iname ;
   unsigned int old_lineno ;
   bool pause_before_pop ;
   bool sav_rep_multlin ;
   void (*resump_func)() ;
   void *resump_param ;
};
#line 336 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
typedef struct source_state source_state_t;
#line 145 "../shared/pcihdr.h"
struct __anonstruct_rom_header_t_28 {
   u8 signature[2] ;
   u8 reserved[22] ;
   u8 data_ptr[2] ;
   u8 padd[2] ;
};
#line 145 "../shared/pcihdr.h"
typedef struct __anonstruct_rom_header_t_28 rom_header_t;
#line 153 "../shared/pcihdr.h"
struct __anonstruct_pci_data_t_29 {
   u8 signature[4] ;
   u8 vendor[2] ;
   u8 device[2] ;
   u8 vpd[2] ;
   u8 dlen[2] ;
   u8 drevision ;
   u8 class_code[3] ;
   u8 ilen[2] ;
   u8 irevision[2] ;
   u8 code_type ;
   u8 last_image_flag ;
   u16 reserved_2 ;
};
#line 153 "../shared/pcihdr.h"
typedef struct __anonstruct_pci_data_t_29 pci_data_t;
#line 53 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
struct __anonstruct_fcode_header_t_30 {
   u8 format ;
   u8 checksum[2] ;
   u8 length[4] ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
typedef struct __anonstruct_fcode_header_t_30 fcode_header_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 190 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
struct __anonstruct_err_category_26 {
   int type_bit ;
   char *category_name ;
   char *single ;
   char *plural ;
   int *counter ;
   bool new_line ;
};
#line 190 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
typedef struct __anonstruct_err_category_26 err_category;
#line 53 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
struct __anonstruct_num_to_name_table_21 {
   u32 const   classcode ;
   char const   *classname ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
typedef struct __anonstruct_num_to_name_table_21 num_to_name_table;
#line 234 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
union tic_mac_param {
   char *deflt_elem ;
   long long_val ;
   fwtoken fw_token ;
   bool *bool_ptr ;
   char *chr_ptr ;
};
#line 234 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef union tic_mac_param tic_mac_param_t;
#line 243 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
struct tic_mac_hdr {
   char *name ;
   struct tic_mac_hdr *next ;
   void (*funct)() ;
   tic_mac_param_t pfield ;
   fwtoken fword_defr ;
   bool is_token ;
   void (*ign_func)() ;
   int pfld_size ;
   bool tracing ;
};
#line 243 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
typedef struct tic_mac_hdr tic_mac_hdr_t;
#line 137 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
struct trace_entry {
   char *tracee ;
   struct trace_entry *next ;
};
#line 137 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
typedef struct trace_entry trace_entry_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat___0 {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
struct token {
   char *name ;
   u16 fcode ;
   struct token *prev ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
typedef struct token token_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
void tokenization_error(int err_type , char *msg  , ...) ;
#line 60
void *safe_malloc(size_t size , char *phrase ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/strsubvocab.h"
void add_str_sub_entry(char *ename , char *subst_str , str_sub_vocab_t **str_sub_vocab ) ;
#line 62
str_sub_vocab_t *lookup_str_sub(char *tname , str_sub_vocab_t *str_sub_vocab ) ;
#line 63
bool exists_in_str_sub(char *tname , str_sub_vocab_t *str_sub_vocab ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.h"
void add_user_symbol(char *raw_symb ) ;
#line 41
bool exists_as_user_symbol(char *symb_nam ) ;
#line 42
void eval_user_symbol(char *symb_nam ) ;
#line 43
void list_user_symbols(void) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
void eval_string(char *inp_bufr ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.c"
static str_sub_vocab_t *user_symbol_list  =    (str_sub_vocab_t *)((void *)0);
#line 130 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.c"
static int user_symbol_count  =    0;
#line 165 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.c"
void add_user_symbol(char *raw_symb ) 
{ 
  char *symb_nam ;
  char *symb_valu ;

  {
  {
#line 170
  symb_nam = strdup((char const   *)raw_symb);
#line 171
  symb_valu = strchr((char const   *)symb_nam, '=');
  }
#line 172
  if ((unsigned long )symb_valu != (unsigned long )((void *)0)) {
#line 174
    *symb_valu = (char)0;
#line 175
    symb_valu ++;
  }
  {
#line 177
  add_str_sub_entry(symb_nam, symb_valu, & user_symbol_list);
#line 178
  user_symbol_count ++;
  }
#line 179
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.c"
bool exists_as_user_symbol(char *symb_nam ) 
{ 
  bool retval ;

  {
  {
#line 203
  retval = exists_in_str_sub(symb_nam, user_symbol_list);
  }
#line 204
  return (retval);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.c"
void eval_user_symbol(char *symb_nam ) 
{ 
  str_sub_vocab_t *found ;
  char *symb_valu ;

  {
  {
#line 255
  found = (str_sub_vocab_t *)((void *)0);
#line 258
  found = lookup_str_sub(symb_nam, user_symbol_list);
  }
#line 259
  if ((unsigned long )found == (unsigned long )((void *)0)) {
    {
#line 261
    tokenization_error(67108864, (char *)"Command-line symbol %s is not defined.\n",
                       symb_nam);
    }
  } else {
#line 264
    symb_valu = (char *)found->alias;
#line 266
    if ((unsigned long )symb_valu == (unsigned long )((void *)0)) {
      {
#line 268
      tokenization_error(2097152, (char *)"No value assigned to command-line symbol %s\n",
                         symb_nam);
      }
    } else {
      {
#line 271
      eval_string(symb_valu);
      }
    }
  }
#line 275
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/usersymbols.c"
void list_user_symbols(void) 
{ 
  str_sub_vocab_t *curr ;
  str_sub_vocab_t **symb_ptr ;
  int indx ;
  int maxlen ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  bool is_dup ;
  int dup_srch_indx ;
  str_sub_vocab_t *dup_cand ;
  int tmp___2 ;
  int strindx ;
  size_t tmp___3 ;

  {
#line 327
  if ((unsigned long )user_symbol_list != (unsigned long )((void *)0)) {
    {
#line 331
    indx = 0;
#line 332
    maxlen = 0;
#line 334
    tmp = safe_malloc(sizeof(str_sub_vocab_t *) * (unsigned long )user_symbol_count,
                      (char *)"collecting user-symbol pointers");
#line 334
    symb_ptr = (str_sub_vocab_t **)tmp;
#line 338
    curr = user_symbol_list;
    }
    {
#line 338
    while (1) {
      while_continue: /* CIL Label */ ;
#line 338
      if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 338
        goto while_break;
      }
      {
#line 340
      *(symb_ptr + indx) = curr;
#line 341
      indx ++;
#line 342
      tmp___1 = strlen((char const   *)curr->name);
      }
#line 342
      if (tmp___1 > (size_t )maxlen) {
        {
#line 342
        tmp___0 = strlen((char const   *)curr->name);
#line 342
        maxlen = (int )tmp___0;
        }
      }
#line 338
      curr = curr->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 346
    printf((char const   */* __restrict  */)"\nUser-Defined Symbols:\n");
    }
    {
#line 347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 347
      if (! (indx > 0)) {
#line 347
        goto while_break___0;
      }
#line 351
      indx --;
#line 352
      curr = *(symb_ptr + indx);
#line 355
      dup_srch_indx = indx;
#line 356
      is_dup = (bool )0;
      {
#line 357
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 357
        if (! (dup_srch_indx > 0)) {
#line 357
          goto while_break___1;
        }
        {
#line 360
        dup_srch_indx --;
#line 361
        dup_cand = *(symb_ptr + dup_srch_indx);
#line 362
        tmp___2 = strcmp((char const   *)curr->name, (char const   *)dup_cand->name);
        }
#line 362
        if (tmp___2 == 0) {
#line 364
          is_dup = (bool )-1;
#line 365
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 369
      printf((char const   */* __restrict  */)"\t%s", curr->name);
      }
#line 371
      if ((unsigned long )curr->alias != (unsigned long )((void *)0)) {
#line 371
        goto _L;
      } else
#line 371
      if (is_dup) {
        _L: /* CIL Label */ 
        {
#line 374
        tmp___3 = strlen((char const   *)curr->name);
#line 374
        strindx = (int )tmp___3;
        }
        {
#line 374
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 374
          if (! (strindx < maxlen)) {
#line 374
            goto while_break___2;
          }
          {
#line 378
          printf((char const   */* __restrict  */)" ");
#line 374
          strindx ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 381
      if ((unsigned long )curr->alias != (unsigned long )((void *)0)) {
        {
#line 383
        printf((char const   */* __restrict  */)" = %s", curr->alias);
        }
      }
#line 385
      if (is_dup) {
        {
#line 387
        printf((char const   */* __restrict  */)" *** Over-ridden");
        }
      }
      {
#line 389
      printf((char const   */* __restrict  */)"\n");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 391
    free((void *)symb_ptr);
    }
  }
#line 393
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 209
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tmpnam)(char *__s ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 717
extern int system(char const   *__command ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
unsigned int opc ;
#line 45 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.h"
u8 *start ;
#line 46 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.h"
u8 *pc  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.h"
u8 *end  ;
#line 48
char *iname ;
#line 49
unsigned int lineno ;
#line 50
unsigned int abs_token_no ;
#line 53
char *oname ;
#line 84
void add_to_include_list(char *dir_compt ) ;
#line 85
void display_include_list(void) ;
#line 86
FILE *open_expanded_file(char const   *path_name , char *mode , char *for_what ) ;
#line 87
enum boolean init_stream(char const   *name ) ;
#line 88
void close_stream(void *dummy ) ;
#line 89
void init_output(char const   *in_name , char const   *out_name ) ;
#line 90
bool close_output(void) ;
#line 91
void init_inbuf(char *inbuf , unsigned int buflen ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
bool error_summary(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.h"
bool verbose ;
#line 48
bool fload_list ;
#line 49
bool dependency_list ;
#line 88 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
u8 *start  =    (u8 *)((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
char *iname  =    (char *)((void *)0);
#line 92 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
unsigned int lineno  =    0U;
#line 93 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
unsigned int abs_token_no  =    0U;
#line 98 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static unsigned int ilen  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
u8 *ostart  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
char *oname  =    (char *)((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
unsigned int olen  ;
#line 108
void init_emit(void) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char *load_list_name  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static FILE *load_list_file  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char *depncy_list_name  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static FILE *depncy_file  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char *missing_list_name  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static FILE *missing_list_file  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static bool no_files_missing  =    (bool )-1;
#line 155 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static incl_list_t *include_list_start  =    (incl_list_t *)((void *)0);
#line 156 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static incl_list_t *include_list_next  =    (incl_list_t *)((void *)0);
#line 157 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static unsigned int max_dir_path_len  =    0U;
#line 158 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char *include_list_full_path  =    (char *)((void *)0);
#line 199 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
void add_to_include_list(char *dir_compt ) 
{ 
  unsigned int new_path_len ;
  size_t tmp ;
  incl_list_t *new_i_l_e ;
  void *tmp___0 ;

  {
  {
#line 201
  tmp = strlen((char const   *)dir_compt);
#line 201
  new_path_len = (unsigned int )tmp;
#line 202
  tmp___0 = safe_malloc(sizeof(incl_list_t ), (char *)"adding to include-list");
#line 202
  new_i_l_e = (incl_list_t *)tmp___0;
#line 205
  new_i_l_e->dir_path = strdup((char const   *)dir_compt);
#line 206
  new_i_l_e->next = (struct incl_list *)((void *)0);
  }
#line 208
  if ((unsigned long )include_list_start == (unsigned long )((void *)0)) {
#line 210
    include_list_start = new_i_l_e;
  } else {
#line 212
    include_list_next->next = new_i_l_e;
  }
#line 215
  include_list_next = new_i_l_e;
#line 216
  if (new_path_len > max_dir_path_len) {
#line 216
    max_dir_path_len = new_path_len;
  }
#line 217
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
void display_include_list(void) 
{ 
  int curr_wid ;
  int this_wid ;
  size_t tmp ;
  char *separator ;

  {
#line 252
  if ((unsigned long )include_list_start != (unsigned long )((void *)0)) {
    {
#line 254
    curr_wid = 80;
#line 255
    printf((char const   */* __restrict  */)"\nInclude-List:");
#line 256
    include_list_next = include_list_start;
    }
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      if (! ((unsigned long )include_list_next != (unsigned long )((void *)0))) {
#line 257
        goto while_break;
      }
      {
#line 259
      tmp = strlen((char const   *)include_list_next->dir_path);
#line 259
      this_wid = (int )(tmp + 1UL);
#line 260
      separator = (char *)" ";
      }
#line 261
      if (curr_wid + this_wid > 80) {
#line 263
        separator = (char *)"\n\t";
#line 264
        curr_wid = 7;
      }
      {
#line 266
      printf((char const   */* __restrict  */)"%s%s", separator, include_list_next->dir_path);
#line 267
      curr_wid += this_wid;
#line 268
      include_list_next = include_list_next->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 270
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 272
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void init_incl_list_scan(char *base_name ) 
{ 
  unsigned int new_path_len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 329
  if ((unsigned long )include_list_start != (unsigned long )((void *)0)) {
    {
#line 335
    tmp = strlen((char const   *)base_name);
#line 335
    new_path_len = (unsigned int )(((size_t )max_dir_path_len + tmp) + 2UL);
#line 336
    tmp___0 = safe_malloc((size_t )new_path_len, (char *)"scanning include-list");
#line 336
    include_list_full_path = (char *)tmp___0;
#line 338
    include_list_next = include_list_start;
    }
  }
#line 340
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static bool scan_incl_list(char *base_name ) 
{ 
  bool retval ;
  size_t tmp ;

  {
#line 402
  retval = (bool )0;
#line 404
  if ((unsigned long )include_list_full_path == (unsigned long )((void *)0)) {
#line 406
    include_list_full_path = base_name;
#line 407
    retval = (bool )-1;
  } else
#line 409
  if ((unsigned long )include_list_next != (unsigned long )((void *)0)) {
    {
#line 420
    tmp = strlen((char const   *)include_list_next->dir_path);
    }
#line 420
    if (tmp == 0UL) {
      {
#line 422
      sprintf((char */* __restrict  */)include_list_full_path, (char const   */* __restrict  */)"%s",
              base_name);
      }
    } else {
      {
#line 424
      sprintf((char */* __restrict  */)include_list_full_path, (char const   */* __restrict  */)"%s/%s",
              include_list_next->dir_path, base_name);
      }
    }
#line 427
    include_list_next = include_list_next->next;
#line 428
    retval = (bool )-1;
  }
#line 432
  return (retval);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void finish_incl_list_scan(bool op_succeeded ) 
{ 


  {
#line 462
  if ((unsigned long )include_list_start != (unsigned long )((void *)0)) {
#line 464
    if (op_succeeded) {
      {
#line 466
      tokenization_error(65536, (char *)"File was found in %s\n", include_list_full_path);
      }
    }
    {
#line 469
    free((void *)include_list_full_path);
    }
  }
#line 471
  include_list_full_path = (char *)((void *)0);
#line 472
  include_list_next = (incl_list_t *)((void *)0);
#line 473
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static FILE *open_incl_list_file(char *base_name , char *mode ) 
{ 
  FILE *retval ;
  bool tmp ;

  {
  {
#line 505
  retval = (FILE *)((void *)0);
#line 507
  init_incl_list_scan(base_name);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 508
    tmp = scan_incl_list(base_name);
    }
#line 508
    if (! tmp) {
#line 508
      goto while_break;
    }
    {
#line 510
    retval = fopen((char const   */* __restrict  */)include_list_full_path, (char const   */* __restrict  */)mode);
    }
#line 511
    if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 513
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return (retval);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static bool stat_incl_list_file(char *base_name , struct stat *file_info ) 
{ 
  bool retval ;
  int stat_reslt ;
  bool tmp ;

  {
  {
#line 553
  retval = (bool )0;
#line 554
  stat_reslt = -1;
#line 556
  init_incl_list_scan(base_name);
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 557
    tmp = scan_incl_list(base_name);
    }
#line 557
    if (! tmp) {
#line 557
      goto while_break;
    }
    {
#line 559
    stat_reslt = stat((char const   */* __restrict  */)include_list_full_path, (struct stat */* __restrict  */)file_info);
    }
#line 560
    if (stat_reslt == 0) {
#line 562
      retval = (bool )-1;
#line 563
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  return (retval);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
void init_inbuf(char *inbuf , unsigned int buflen ) 
{ 


  {
#line 591
  start = (u8 *)inbuf;
#line 592
  pc = start;
#line 593
  end = pc + buflen;
#line 594
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void could_not_open(int severity , char *fle_nam , char *for_what ) 
{ 


  {
  {
#line 619
  tokenization_error(severity, (char *)"Could not open file %s for %s.\n", fle_nam,
                     for_what);
  }
#line 622
  return;
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void file_is_missing(char *fle_nam ) 
{ 


  {
#line 650
  if ((unsigned long )missing_list_file != (unsigned long )((void *)0)) {
    {
#line 652
    fprintf((FILE */* __restrict  */)missing_list_file, (char const   */* __restrict  */)"%s\n",
            fle_nam);
#line 653
    no_files_missing = (bool )0;
    }
  }
#line 655
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void add_to_load_lists(char const   *in_name ) 
{ 


  {
#line 688
  if ((unsigned long )load_list_file != (unsigned long )((void *)0)) {
    {
#line 690
    fprintf((FILE */* __restrict  */)load_list_file, (char const   */* __restrict  */)"%s\n",
            in_name);
    }
  }
#line 692
  if ((unsigned long )depncy_file != (unsigned long )((void *)0)) {
    {
#line 694
    fprintf((FILE */* __restrict  */)depncy_file, (char const   */* __restrict  */)"%s\n",
            include_list_full_path);
    }
  }
#line 696
  return;
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char expansion_buffer[2048]  ;
#line 712 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static bool was_expanded  ;
#line 713 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static int expansion_msg_severity  =    65536;
#line 737 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void expanded_name(void) 
{ 


  {
#line 739
  if (was_expanded) {
    {
#line 741
    tokenization_error(expansion_msg_severity, (char *)"File name expanded to:  %s\n",
                       expansion_buffer);
    }
  }
#line 744
  return;
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static void expansion_error(void) 
{ 
  int tmp ;

  {
#line 788
  if (verbose) {
#line 788
    tmp = 0;
  } else {
#line 788
    tmp = -1;
  }
#line 788
  if (tmp) {
    {
#line 790
    expansion_msg_severity |= 1;
#line 791
    expanded_name();
#line 792
    expansion_msg_severity ^= 1;
    }
  }
#line 794
  return;
}
}
#line 902
static char *expand_pathname(char const   *input_pathname ) ;
#line 902 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static int const   buffer_max  =    (int const   )2048;
#line 900 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char *expand_pathname(char const   *input_pathname ) 
{ 
  char *retval ;
  FILE *temp_file ;
  int syst_stat ;
  char const   *temp_file_name ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 904
  retval = (char *)input_pathname;
#line 905
  was_expanded = (bool )0;
#line 908
  tmp___1 = strchr(input_pathname, '$');
  }
#line 908
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    {
#line 912
    tmp = tmpnam((char *)((void *)0));
#line 912
    temp_file_name = (char const   *)tmp;
#line 915
    sprintf((char */* __restrict  */)(expansion_buffer), (char const   */* __restrict  */)"echo %s>%s\n",
            input_pathname, temp_file_name);
#line 917
    syst_stat = system((char const   *)(expansion_buffer));
    }
#line 918
    if (syst_stat != 0) {
      {
#line 920
      tokenization_error(67108864, (char *)"Expansion Syntax.\n");
      }
#line 923
      return ((char *)((void *)0));
    }
    {
#line 926
    temp_file = fopen((char const   */* __restrict  */)temp_file_name, (char const   */* __restrict  */)"r");
#line 927
    tmp___0 = fread((void */* __restrict  */)(expansion_buffer), (size_t )1, (size_t )buffer_max,
                    (FILE */* __restrict  */)temp_file);
#line 927
    syst_stat = (int )tmp___0;
    }
#line 932
    if ((int )expansion_buffer[syst_stat - 1] != 10) {
      {
#line 934
      tokenization_error(67108864, (char *)"Expansion buffer overflow.  Max length is %d.\n",
                         buffer_max);
#line 937
      retval = (char *)((void *)0);
      }
    } else {
      {
#line 939
      expansion_buffer[syst_stat - 1] = (char)0;
#line 940
      was_expanded = (bool )-1;
#line 941
      retval = expansion_buffer;
#line 942
      expanded_name();
      }
    }
    {
#line 945
    fclose(temp_file);
#line 946
    remove(temp_file_name);
    }
  }
#line 949
  return (retval);
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
FILE *open_expanded_file(char const   *path_name , char *mode , char *for_what ) 
{ 
  FILE *retval ;
  char *infile_name ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 981
  retval = (FILE *)((void *)0);
#line 983
  tmp = expand_pathname(path_name);
#line 983
  infile_name = tmp;
  }
#line 984
  if ((unsigned long )infile_name != (unsigned long )((void *)0)) {
    {
#line 986
    retval = open_incl_list_file(infile_name, mode);
    }
  }
#line 989
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
    {
#line 991
    expansion_error();
#line 992
    tokenization_error(67108864, (char *)"Failed to open file %s for %s\n", path_name,
                       for_what);
    }
  }
#line 996
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 996
    tmp___0 = -1;
  } else {
#line 996
    tmp___0 = 0;
  }
  {
#line 996
  finish_incl_list_scan((bool )tmp___0);
  }
#line 998
  return (retval);
}
}
#line 1078 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
enum boolean init_stream(char const   *name ) 
{ 
  FILE *infile ;
  u8 *newbuf ;
  struct stat finfo ;
  bool stat_succ ;
  bool tried_stat ;
  bool retval ;
  bool inp_fil_acc_err ;
  bool inp_fil_open_err ;
  bool inp_fil_read_err ;
  char *infile_name ;
  char *tmp ;
  void *tmp___0 ;
  unsigned int i ;
  char test_c ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1083
  stat_succ = (bool )0;
#line 1084
  tried_stat = (bool )0;
#line 1085
  retval = (bool )0;
#line 1086
  inp_fil_acc_err = (bool )0;
#line 1087
  inp_fil_open_err = (bool )0;
#line 1088
  inp_fil_read_err = (bool )0;
#line 1090
  tmp = expand_pathname(name);
#line 1090
  infile_name = tmp;
  }
#line 1092
  if ((unsigned long )infile_name != (unsigned long )((void *)0)) {
    {
#line 1094
    tried_stat = (bool )-1;
#line 1095
    stat_succ = stat_incl_list_file(infile_name, & finfo);
    }
  }
#line 1098
  if (stat_succ) {
#line 1098
    tmp___2 = 0;
  } else {
#line 1098
    tmp___2 = -1;
  }
#line 1098
  if (tmp___2) {
#line 1100
    inp_fil_acc_err = (bool )-1;
  } else {
    {
#line 1103
    infile = fopen((char const   */* __restrict  */)include_list_full_path, (char const   */* __restrict  */)"r");
    }
#line 1104
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
#line 1106
      inp_fil_open_err = (bool )-1;
    } else {
      {
#line 1109
      ilen = (unsigned int )finfo.st_size;
#line 1110
      tmp___0 = safe_malloc((size_t )(ilen + 1U), (char *)"initting stream");
#line 1110
      newbuf = (u8 *)tmp___0;
#line 1112
      tmp___1 = fread((void */* __restrict  */)newbuf, (size_t )ilen, (size_t )1,
                      (FILE */* __restrict  */)infile);
      }
#line 1112
      if (tmp___1 != 1UL) {
        {
#line 1114
        inp_fil_read_err = (bool )-1;
#line 1115
        free((void *)newbuf);
        }
      } else {
#line 1119
        retval = (bool )-1;
#line 1122
        i = 0U;
        {
#line 1122
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1122
          if (! (i < ilen)) {
#line 1122
            goto while_break;
          }
#line 1124
          test_c = (char )*(newbuf + i);
#line 1125
          if ((int )test_c == 0) {
#line 1125
            *(newbuf + i) = (u8 )10;
          }
#line 1126
          if ((int )test_c == 13) {
#line 1126
            *(newbuf + i) = (u8 )' ';
          }
#line 1122
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1128
        *(newbuf + ilen) = (u8 )0;
#line 1130
        init_inbuf((char *)newbuf, ilen);
#line 1151
        add_to_load_lists(name);
        }
#line 1164
        if ((unsigned long )oname == (unsigned long )((void *)0)) {
#line 1167
          tried_stat = (bool )0;
        }
      }
      {
#line 1170
      fclose(infile);
      }
    }
  }
  {
#line 1174
  fflush(stdout);
  }
#line 1176
  if (retval) {
#line 1176
    tmp___3 = 0;
  } else {
#line 1176
    tmp___3 = -1;
  }
#line 1176
  if (tmp___3) {
    {
#line 1178
    file_is_missing((char *)name);
    }
#line 1179
    if (inp_fil_acc_err) {
      {
#line 1181
      expansion_error();
#line 1182
      tokenization_error(67108864, (char *)"Could not access input file %s\n", name);
      }
    } else
#line 1185
    if (inp_fil_open_err) {
      {
#line 1187
      expansion_error();
#line 1188
      could_not_open(67108864, (char *)name, (char *)"input");
      }
    } else
#line 1190
    if (inp_fil_read_err) {
      {
#line 1192
      expansion_error();
#line 1193
      tokenization_error(67108864, (char *)"Could not read input file %s\n", name);
      }
    }
  }
#line 1200
  if (tried_stat) {
    {
#line 1202
    finish_incl_list_scan(stat_succ);
    }
  }
#line 1208
  if (retval) {
    {
#line 1210
    iname = strdup(name);
#line 1211
    lineno = 1U;
    }
  }
#line 1214
  return (retval);
}
}
#line 1256 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
static char *extend_filename(char const   *base_name , char const   *new_ext ) 
{ 
  char *retval ;
  char *ext ;
  unsigned int len ;
  char const   *root ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1263
  tmp = strrchr(base_name, '/');
#line 1263
  root = (char const   *)tmp;
  }
#line 1264
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 1264
    root = base_name;
  }
  {
#line 1266
  ext = strrchr(root, '.');
  }
#line 1267
  if ((unsigned long )ext != (unsigned long )((void *)0)) {
    {
#line 1269
    tmp___0 = strcasecmp((char const   *)ext, new_ext);
    }
#line 1269
    if (tmp___0 == 0) {
#line 1271
      ext = (char *)((void *)0);
    }
  }
#line 1275
  if (ext) {
#line 1275
    len = (unsigned int )(ext - (char *)base_name);
  } else {
    {
#line 1275
    tmp___1 = strlen(base_name);
#line 1275
    len = (unsigned int )tmp___1;
    }
  }
  {
#line 1276
  tmp___2 = strlen(new_ext);
#line 1276
  tmp___3 = safe_malloc(((size_t )len + tmp___2) + 1UL, (char *)"extending file-name");
#line 1276
  retval = (char *)tmp___3;
#line 1277
  memcpy((void */* __restrict  */)retval, (void const   */* __restrict  */)base_name,
         (size_t )len);
#line 1278
  *(retval + len) = (char)0;
#line 1279
  strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)new_ext);
  }
#line 1281
  return (retval);
}
}
#line 1373 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
void init_output(char const   *in_name , char const   *out_name ) 
{ 
  void *tmp ;
  char *temp_iname ;

  {
#line 1377
  if ((unsigned long )out_name != (unsigned long )((void *)0)) {
    {
#line 1379
    oname = strdup(out_name);
    }
  } else {
    {
#line 1381
    oname = extend_filename(in_name, ".fc");
    }
  }
  {
#line 1387
  olen = 131072U;
#line 1388
  tmp = safe_malloc((size_t )olen, (char *)"initting output buffer");
#line 1388
  ostart = (u8 *)tmp;
#line 1390
  init_emit();
#line 1392
  printf((char const   */* __restrict  */)"Binary output to %s ", oname);
  }
#line 1393
  if (fload_list) {
    {
#line 1395
    load_list_name = extend_filename((char const   *)oname, ".fl");
#line 1396
    load_list_file = fopen((char const   */* __restrict  */)load_list_name, (char const   */* __restrict  */)"w");
#line 1397
    printf((char const   */* __restrict  */)"  FLoad-list to %s ", load_list_name);
    }
  }
#line 1399
  if (dependency_list) {
    {
#line 1401
    depncy_list_name = extend_filename((char const   *)oname, ".P");
#line 1402
    depncy_file = fopen((char const   */* __restrict  */)depncy_list_name, (char const   */* __restrict  */)"w");
#line 1403
    printf((char const   */* __restrict  */)"  Dependency-list to %s ", depncy_list_name);
    }
  }
  {
#line 1405
  printf((char const   */* __restrict  */)"\n");
#line 1407
  add_to_load_lists(in_name);
#line 1410
  fflush(stdout);
#line 1416
  temp_iname = iname;
#line 1417
  iname = (char *)((void *)0);
#line 1419
  finish_incl_list_scan((bool )-1);
  }
#line 1421
  if (fload_list) {
#line 1421
    if ((unsigned long )load_list_file == (unsigned long )((void *)0)) {
      {
#line 1423
      could_not_open(67108864, load_list_name, (char *)"Load-List");
#line 1424
      free((void *)load_list_name);
      }
    }
  }
#line 1426
  if (dependency_list) {
#line 1426
    if ((unsigned long )depncy_file == (unsigned long )((void *)0)) {
      {
#line 1428
      could_not_open(67108864, depncy_list_name, (char *)"Dependency-List");
#line 1430
      free((void *)depncy_list_name);
      }
    }
  }
#line 1433
  if (fload_list) {
#line 1433
    goto _L;
  } else
#line 1433
  if (dependency_list) {
    _L: /* CIL Label */ 
    {
#line 1435
    missing_list_name = extend_filename((char const   *)oname, ".fl.missing");
#line 1436
    missing_list_file = fopen((char const   */* __restrict  */)missing_list_name,
                              (char const   */* __restrict  */)"w");
#line 1437
    no_files_missing = (bool )-1;
    }
#line 1439
    if ((unsigned long )missing_list_file == (unsigned long )((void *)0)) {
      {
#line 1441
      could_not_open(2097152, missing_list_name, (char *)"Missing-Files List");
#line 1443
      free((void *)missing_list_name);
      }
    }
  }
#line 1446
  iname = temp_iname;
#line 1448
  abs_token_no = 1U;
#line 1449
  return;
}
}
#line 1497
void increase_output_buffer(void) ;
#line 1498 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
void increase_output_buffer(void) 
{ 
  u8 *newout ;
  unsigned int rea_len ;
  void *tmp ;

  {
#line 1502
  if (olen == 0U) {
    {
#line 1504
    tokenization_error((-0x7FFFFFFF-1), (char *)"Output Buffer reallocation overflow.");
    }
  } else {
#line 1508
    olen *= 2U;
#line 1509
    rea_len = olen;
#line 1510
    if (rea_len == 0U) {
#line 1512
      rea_len = 4294967295U;
    }
    {
#line 1514
    tokenization_error(65536, (char *)"Output Buffer overflow.  Relocating and increasing to %d bytes.\n",
                       rea_len);
#line 1518
    tmp = realloc((void *)ostart, (size_t )rea_len);
#line 1518
    newout = (u8 *)tmp;
    }
#line 1519
    if ((unsigned long )newout == (unsigned long )((void *)0)) {
      {
#line 1521
      tokenization_error((-0x7FFFFFFF-1), (char *)"Could not reallocate %d bytes for Output Buffer",
                         rea_len);
      }
    }
#line 1525
    ostart = newout;
  }
#line 1527
  return;
}
}
#line 1542 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
void close_stream(void *dummy ) 
{ 


  {
  {
#line 1544
  free((void *)start);
#line 1545
  free((void *)iname);
#line 1546
  start = (u8 *)((void *)0);
#line 1547
  iname = (char *)((void *)0);
#line 1548
  lineno = 0U;
  }
#line 1549
  return;
}
}
#line 1560 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stream.c"
bool close_output(void) 
{ 
  bool retval ;
  FILE *outfile ;
  size_t tmp ;
  bool tmp___0 ;

  {
  {
#line 1562
  retval = (bool )-1;
#line 1563
  tmp___0 = error_summary();
  }
#line 1563
  if (tmp___0) {
#line 1565
    if (opc == 0U) {
#line 1567
      retval = (bool )0;
    } else {
      {
#line 1571
      outfile = fopen((char const   */* __restrict  */)oname, (char const   */* __restrict  */)"w");
      }
#line 1572
      if (! outfile) {
        {
#line 1577
        printf((char const   */* __restrict  */)"Could not open file %s for output.\n",
               oname);
        }
      } else {
        {
#line 1580
        tmp = fwrite((void const   */* __restrict  */)ostart, (size_t )opc, (size_t )1,
                     (FILE */* __restrict  */)outfile);
        }
#line 1580
        if (tmp != 1UL) {
          {
#line 1582
          tokenization_error((-0x7FFFFFFF-1), (char *)"While writing output.");
          }
        }
        {
#line 1585
        fclose(outfile);
#line 1587
        printf((char const   */* __restrict  */)"toke: wrote %d bytes to bytecode file \'%s\'\n",
               opc, oname);
#line 1589
        retval = (bool )0;
        }
      }
    }
  }
  {
#line 1594
  free((void *)oname);
#line 1595
  free((void *)ostart);
#line 1596
  oname = (char *)((void *)0);
#line 1597
  ostart = (u8 *)((void *)0);
#line 1598
  opc = 0U;
#line 1599
  olen = 131072U;
  }
#line 1601
  if ((unsigned long )load_list_file != (unsigned long )((void *)0)) {
    {
#line 1603
    fclose(load_list_file);
#line 1604
    free((void *)load_list_name);
    }
  }
#line 1606
  if ((unsigned long )depncy_file != (unsigned long )((void *)0)) {
    {
#line 1608
    fclose(depncy_file);
#line 1609
    free((void *)depncy_list_name);
    }
  }
#line 1611
  if ((unsigned long )missing_list_file != (unsigned long )((void *)0)) {
    {
#line 1613
    fclose(missing_list_file);
    }
#line 1614
    if (no_files_missing) {
      {
#line 1616
      remove((char const   *)missing_list_name);
      }
    }
    {
#line 1618
    free((void *)missing_list_name);
    }
  }
#line 1621
  load_list_file = (FILE *)((void *)0);
#line 1622
  load_list_name = (char *)((void *)0);
#line 1623
  missing_list_file = (FILE *)((void *)0);
#line 1624
  missing_list_name = (char *)((void *)0);
#line 1625
  depncy_file = (FILE *)((void *)0);
#line 1626
  depncy_list_name = (char *)((void *)0);
#line 1628
  return (retval);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.h"
u16 nextfcode  ;
#line 56
void reset_fcode_ranges(void) ;
#line 57
void list_fcode_ranges(bool final_tally ) ;
#line 58
void set_next_fcode(u16 new_fcode ) ;
#line 59
void assigning_fcode(void) ;
#line 60
void bump_fcode(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
void started_at(char *saved_ifile , unsigned int saved_lineno ) ;
#line 55
void print_started_at(char *saved_ifile , unsigned int saved_lineno ) ;
#line 197 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static bool ranges_exist  =    (bool )0;
#line 198 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static bool changes_listed  =    (bool )0;
#line 200 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static u16 range_start  =    (u16 )2048;
#line 201 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static u16 range_end  =    (u16 )0;
#line 202 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static char *first_fcr_infile  =    (char *)((void *)0);
#line 203 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static int first_fcr_linenum  =    0;
#line 205 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static fcode_range_t *first_fc_range  =    (fcode_range_t *)((void *)0);
#line 206 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static fcode_range_t *current_fc_range  =    (fcode_range_t *)((void *)0);
#line 261 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
void reset_fcode_ranges(void) 
{ 
  int tmp ;

  {
#line 263
  if (ranges_exist) {
    {
#line 265
    while (1) {
      while_continue: /* CIL Label */ ;
#line 265
      if (! ((unsigned long )current_fc_range != (unsigned long )((void *)0))) {
#line 265
        goto while_break;
      }
      {
#line 267
      current_fc_range = first_fc_range->fcr_next;
#line 268
      free((void *)first_fc_range->fcr_infile);
#line 269
      free((void *)first_fc_range);
#line 270
      first_fc_range = current_fc_range;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 272
    ranges_exist = (bool )0;
  } else
#line 274
  if ((unsigned long )first_fcr_infile != (unsigned long )((void *)0)) {
    {
#line 276
    tmp = strcmp((char const   *)first_fcr_infile, (char const   *)iname);
    }
#line 276
    if (tmp != 0) {
      {
#line 278
      free((void *)first_fcr_infile);
#line 279
      first_fcr_infile = (char *)((void *)0);
      }
    }
  }
#line 284
  changes_listed = (bool )0;
#line 285
  range_start = (u16 )2048;
#line 286
  range_end = (u16 )0;
#line 288
  if ((unsigned long )first_fcr_infile == (unsigned long )((void *)0)) {
    {
#line 290
    first_fcr_infile = strdup((char const   *)iname);
    }
  }
#line 292
  first_fcr_linenum = (int )lineno;
#line 293
  nextfcode = (u16 )2048;
#line 294
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
void list_fcode_ranges(bool final_tally ) 
{ 
  FILE *message_dest___0 ;
  struct _IO_FILE *tmp ;
  void (*start_at_funct)() ;
  void (*tmp___0)(char *saved_ifile , unsigned int saved_lineno ) ;
  fcode_range_t *next_range ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 343
  if (verbose) {
#line 345
    if (final_tally) {
#line 345
      tmp = stdout;
    } else {
#line 345
      tmp = stderr;
    }
#line 345
    message_dest___0 = tmp;
#line 346
    if (changes_listed) {
      {
#line 348
      fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"\n");
      }
    } else {
#line 350
      changes_listed = (bool )-1;
#line 352
      if (ranges_exist) {
#line 352
        tmp___2 = 0;
      } else {
#line 352
        tmp___2 = -1;
      }
#line 352
      if (tmp___2) {
#line 354
        if ((int )range_end == 0) {
          {
#line 356
          fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"No FCodes assigned.\n");
          }
        } else
#line 358
        if ((int )range_start == 2048) {
          {
#line 360
          fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"Last assigned FCode = 0x%x\n",
                  (int )range_end);
          }
        } else {
          {
#line 363
          fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"FCodes assigned:  0x%x to 0x%x\n",
                  (int )range_start, (int )range_end);
          }
        }
      } else {
#line 375
        if (final_tally) {
#line 375
          tmp___0 = & print_started_at;
        } else {
#line 375
          tmp___0 = & started_at;
        }
        {
#line 375
        start_at_funct = (void (*)())tmp___0;
#line 379
        next_range = first_fc_range;
#line 381
        fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"FCodes assigned:\n");
        }
        {
#line 383
        while (1) {
          while_continue: /* CIL Label */ ;
#line 383
          if (! ((unsigned long )next_range != (unsigned long )((void *)0))) {
#line 383
            goto while_break;
          }
#line 385
          if ((int )next_range->fcr_end == 0) {
            {
#line 387
            fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"    None assigned");
            }
          } else {
            {
#line 389
            fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)"    From 0x%x to 0x%x",
                    (int )next_range->fcr_start, (int )next_range->fcr_end);
            }
#line 391
            if (next_range->fcr_not_lapped) {
#line 391
              tmp___1 = 0;
            } else {
#line 391
              tmp___1 = -1;
            }
#line 391
            if (tmp___1) {
              {
#line 393
              fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)" ***Overlap***");
              }
            }
          }
          {
#line 396
          fprintf((FILE */* __restrict  */)message_dest___0, (char const   */* __restrict  */)" in the range");
#line 397
          (*start_at_funct)(next_range->fcr_infile, next_range->fcr_linenum);
#line 400
          next_range = next_range->fcr_next;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 405
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
void set_next_fcode(u16 new_fcode ) 
{ 
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 490
  if (ranges_exist) {
#line 490
    tmp___0 = 0;
  } else {
#line 490
    tmp___0 = -1;
  }
#line 490
  if (tmp___0) {
#line 493
    if ((int )new_fcode == (int )nextfcode) {
#line 496
      return;
    }
#line 499
    if ((int )range_end == 0) {
      {
#line 503
      reset_fcode_ranges();
#line 504
      range_start = new_fcode;
#line 505
      nextfcode = new_fcode;
      }
#line 508
      return;
    } else {
      {
#line 511
      tmp = safe_malloc(sizeof(fcode_range_t ), (char *)"creating first FCode Range");
#line 511
      first_fc_range = (fcode_range_t *)tmp;
#line 513
      first_fc_range->fcr_start = range_start;
#line 514
      first_fc_range->fcr_end = range_end;
#line 515
      first_fc_range->fcr_infile = first_fcr_infile;
#line 516
      first_fc_range->fcr_linenum = first_fcr_linenum;
#line 517
      first_fc_range->fcr_not_lapped = (bool )-1;
#line 518
      first_fc_range->fcr_next = (struct fcode_range *)((void *)0);
#line 520
      first_fcr_infile = (char *)((void *)0);
#line 521
      first_fcr_linenum = 0;
#line 522
      range_start = (u16 )2048;
#line 523
      range_end = (u16 )0;
#line 525
      current_fc_range = first_fc_range;
#line 527
      ranges_exist = (bool )-1;
      }
    }
  }
  {
#line 532
  tmp___1 = safe_malloc(sizeof(fcode_range_t ), (char *)"creating new FCode Range");
#line 532
  current_fc_range->fcr_next = (struct fcode_range *)tmp___1;
#line 534
  current_fc_range = current_fc_range->fcr_next;
#line 536
  nextfcode = new_fcode;
#line 537
  current_fc_range->fcr_start = nextfcode;
#line 538
  current_fc_range->fcr_end = (u16 )0;
#line 540
  current_fc_range->fcr_infile = strdup((char const   *)iname);
#line 541
  current_fc_range->fcr_linenum = (int )lineno;
#line 542
  current_fc_range->fcr_not_lapped = (bool )-1;
#line 543
  current_fc_range->fcr_next = (struct fcode_range *)((void *)0);
#line 545
  changes_listed = (bool )0;
  }
#line 546
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
static fcode_range_t *find_overlap(u16 test_fcode ) 
{ 
  fcode_range_t *retval ;
  fcode_range_t *test_range ;

  {
#line 581
  retval = (fcode_range_t *)((void *)0);
#line 582
  if (ranges_exist) {
#line 584
    test_range = first_fc_range;
    {
#line 585
    while (1) {
      while_continue: /* CIL Label */ ;
#line 585
      if (! ((unsigned long )test_range != (unsigned long )current_fc_range)) {
#line 585
        goto while_break;
      }
#line 587
      if ((int )test_fcode <= (int )test_range->fcr_end) {
#line 587
        if ((int )test_fcode >= (int )test_range->fcr_start) {
#line 590
          retval = test_range;
#line 591
          goto while_break;
        }
      }
#line 593
      test_range = test_range->fcr_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 597
  return (retval);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
void assigning_fcode(void) 
{ 
  fcode_range_t *found_lap ;
  fcode_range_t *tmp ;
  int tmp___0 ;

  {
#line 635
  if ((int )nextfcode > 4095) {
    {
#line 638
    tokenization_error(65536, (char *)"");
#line 639
    list_fcode_ranges((bool )0);
#line 641
    tokenization_error((-0x7FFFFFFF-1), (char *)"Too many definitions.  Assigned FCode exceeds limit specified by IEEE-1275.");
    }
  }
#line 651
  changes_listed = (bool )0;
#line 653
  if (ranges_exist) {
#line 653
    tmp___0 = 0;
  } else {
#line 653
    tmp___0 = -1;
  }
#line 653
  if (tmp___0) {
#line 655
    range_end = nextfcode;
  } else {
#line 657
    current_fc_range->fcr_end = nextfcode;
#line 660
    if (current_fc_range->fcr_not_lapped) {
      {
#line 662
      tmp = find_overlap(nextfcode);
#line 662
      found_lap = tmp;
      }
#line 663
      if ((unsigned long )found_lap != (unsigned long )((void *)0)) {
        {
#line 665
        tokenization_error(67108864, (char *)"Assigning FCode of 0x%x, which overlaps the range",
                           (int )nextfcode);
#line 668
        started_at(found_lap->fcr_infile, (unsigned int )found_lap->fcr_linenum);
#line 670
        current_fc_range->fcr_not_lapped = (bool )0;
        }
      }
    }
  }
#line 675
  return;
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/nextfcode.c"
void bump_fcode(void) 
{ 


  {
#line 704
  nextfcode = (u16 )((int )nextfcode + 1);
#line 705
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 80
extern int optopt ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.h"
bool noerrors ;
#line 66 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.h"
void init_stack(void) ;
#line 121 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
void finish_headers(void) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/vocabfuncts.h"
void init_dictionary(void) ;
#line 86
void reset_vocabs(void) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
void init_scanner(void) ;
#line 91
void exit_scanner(void) ;
#line 92
void init_scan_state(void) ;
#line 119
void tokenize(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
void init_error_handler(void) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.h"
bool clflag_help ;
#line 137
bool set_cl_flag(char *flag_name , bool from_src ) ;
#line 138
void cl_flags_help(void) ;
#line 139
void list_cl_flag_names(void) ;
#line 141
void list_cl_flag_settings(void) ;
#line 142
void save_cl_flags(void) ;
#line 143
void reset_cl_flags(void) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.h"
void add_to_trace_list(char *trace_symb ) ;
#line 65
void show_trace_list(void) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
bool verbose  =    (bool )0;
#line 79 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
bool noerrors  =    (bool )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
bool fload_list  =    (bool )0;
#line 81 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
bool dependency_list  =    (bool )0;
#line 94 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
static char *outputname  =    (char *)((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
static void print_copyright(void) 
{ 


  {
  {
#line 103
  printf((char const   */* __restrict  */)"Welcome to toke - OpenBIOS tokenizer v1.0.2\n(C) Copyright 2001-2006 Stefan Reinauer.\n(C) Copyright 2006 coresystems GmbH <info@coresystems.de>\n(C) Copyright 2005 IBM Corporation.  All Rights Reserved.\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License v2. This program has absolutely no warranty.\n\n");
  }
#line 113
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
static void usage(char *name ) 
{ 


  {
  {
#line 124
  printf((char const   */* __restrict  */)"usage: %s [-v] [-i] [-l] [-P] [-o target] <[-d name[=value]]> <[-f [no]flagname]> <[-I dir-path]> <[-T symbol]> <forth-file>\n\n",
         name);
#line 127
  printf((char const   */* __restrict  */)"  -v|--verbose          print Advisory messages\n");
#line 128
  printf((char const   */* __restrict  */)"  -i|--ignore-errors    don\'t suppress output after errors\n");
#line 129
  printf((char const   */* __restrict  */)"  -l|--load-list        create list of FLoaded file names\n");
#line 130
  printf((char const   */* __restrict  */)"  -P|--dependencies     create dePendency-list file\n");
#line 131
  printf((char const   */* __restrict  */)"  -o|--output-name      send output to filename given\n");
#line 132
  printf((char const   */* __restrict  */)"  -d|--define           create user-defined symbol\n");
#line 133
  printf((char const   */* __restrict  */)"  -f|--flag             set (or clear) Special-Feature flag\n");
#line 134
  printf((char const   */* __restrict  */)"  -I|--Include          add a directory to the Include-List\n");
#line 135
  printf((char const   */* __restrict  */)"  -T|--Trace            add a symbol to the Trace List\n");
#line 136
  printf((char const   */* __restrict  */)"  -h|--help             print this help message\n\n");
#line 137
  printf((char const   */* __restrict  */)"  -f|--flag    help     Help for Special-Feature flags\n");
  }
#line 138
  return;
}
}
#line 241
static void get_args(int argc , char **argv ) ;
#line 241 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
static struct option long_options[11]  = 
#line 241
  {      {"verbose", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"ignore-errors", 0, (int *)0, 'i'}, 
        {"load-list", 0, (int *)0, 'l'}, 
        {"dependencies", 0, (int *)0, 'P'}, 
        {"output-name", 1, (int *)0, 'o'}, 
        {"define", 1, (int *)0, 'd'}, 
        {"flag", 1, (int *)0, 'f'}, 
        {"Include", 1, (int *)0, 'I'}, 
        {"Trace", 1, (int *)0, 'T'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 229 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
static void get_args(int argc , char **argv ) 
{ 
  char const   *optstring ;
  int c ;
  int argindx ;
  bool inval_opt ;
  bool help_mssg ;
  bool cl_flag_error ;
  int option_index ;
  char *user_symb ;
  char *incl_list_elem ;

  {
#line 231
  optstring = "vhilPo:d:f:I:T:?";
#line 233
  argindx = 0;
#line 234
  inval_opt = (bool )0;
#line 235
  help_mssg = (bool )0;
#line 236
  cl_flag_error = (bool )0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 240
    option_index = 0;
#line 255
    c = getopt_long(argc, (char * const  *)argv, optstring, (struct option  const  *)(long_options),
                    & option_index);
    }
#line 260
    if (c == -1) {
#line 261
      goto while_break;
    }
#line 263
    argindx ++;
    {
#line 265
    if (c == 118) {
#line 265
      goto case_118;
    }
#line 268
    if (c == 111) {
#line 268
      goto case_111;
    }
#line 271
    if (c == 105) {
#line 271
      goto case_105;
    }
#line 274
    if (c == 108) {
#line 274
      goto case_108;
    }
#line 277
    if (c == 80) {
#line 277
      goto case_80;
    }
#line 280
    if (c == 100) {
#line 280
      goto case_100;
    }
#line 286
    if (c == 102) {
#line 286
      goto case_102;
    }
#line 289
    if (c == 73) {
#line 289
      goto case_73;
    }
#line 295
    if (c == 84) {
#line 295
      goto case_84;
    }
#line 298
    if (c == 63) {
#line 298
      goto case_63;
    }
#line 308
    if (c == 72) {
#line 308
      goto case_72;
    }
#line 308
    if (c == 104) {
#line 308
      goto case_72;
    }
#line 311
    goto switch_default;
    case_118: /* CIL Label */ 
#line 266
    verbose = (bool )-1;
#line 267
    goto switch_break;
    case_111: /* CIL Label */ 
#line 269
    outputname = optarg;
#line 270
    goto switch_break;
    case_105: /* CIL Label */ 
#line 272
    noerrors = (bool )-1;
#line 273
    goto switch_break;
    case_108: /* CIL Label */ 
#line 275
    fload_list = (bool )-1;
#line 276
    goto switch_break;
    case_80: /* CIL Label */ 
#line 278
    dependency_list = (bool )-1;
#line 279
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 282
    user_symb = optarg;
#line 283
    add_user_symbol(user_symb);
    }
#line 285
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 287
    cl_flag_error = set_cl_flag(optarg, (bool )0);
    }
#line 288
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 291
    incl_list_elem = optarg;
#line 292
    add_to_include_list(incl_list_elem);
    }
#line 294
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 296
    add_to_trace_list(optarg);
    }
#line 297
    goto switch_break;
    case_63: /* CIL Label */ 
#line 302
    if (optopt) {
#line 304
      inval_opt = (bool )-1;
#line 305
      goto switch_break;
    }
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 309
    help_mssg = (bool )-1;
#line 310
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 317
    printf((char const   */* __restrict  */)"%s: unknown options.\n", *(argv + 0));
#line 318
    usage(*(argv + 0));
#line 319
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  if (help_mssg) {
    {
#line 325
    usage(*(argv + 0));
    }
#line 326
    if (! clflag_help) {
      {
#line 328
      list_cl_flag_names();
      }
    }
  }
#line 331
  if (clflag_help) {
    {
#line 331
    cl_flags_help();
    }
  }
#line 332
  if (help_mssg) {
    {
#line 334
    exit(0);
    }
  } else
#line 332
  if (clflag_help) {
    {
#line 334
    exit(0);
    }
  }
#line 337
  if (inval_opt) {
    {
#line 337
    printf((char const   */* __restrict  */)"unknown options.\n");
    }
  }
#line 338
  if (optind >= argc) {
    {
#line 338
    printf((char const   */* __restrict  */)"Input file name missing.\n");
    }
  }
#line 339
  if (inval_opt) {
    {
#line 341
    usage(*(argv + 0));
    }
  } else
#line 339
  if (optind >= argc) {
    {
#line 341
    usage(*(argv + 0));
    }
  }
#line 343
  if (cl_flag_error) {
    {
#line 343
    list_cl_flag_names();
    }
  }
#line 345
  if (inval_opt) {
    {
#line 347
    exit(1);
    }
  } else
#line 345
  if (optind >= argc) {
    {
#line 347
    exit(1);
    }
  } else
#line 345
  if (cl_flag_error) {
    {
#line 347
    exit(1);
    }
  }
#line 350
  if (verbose) {
    {
#line 352
    list_user_symbols();
#line 353
    list_cl_flag_settings();
#line 354
    display_include_list();
    }
  }
  {
#line 356
  show_trace_list();
#line 357
  save_cl_flags();
  }
#line 358
  return;
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/toke.c"
int main(int argc , char **argv ) 
{ 
  int retval ;
  bool stream_ok ;
  bool tmp ;

  {
  {
#line 378
  retval = 0;
#line 380
  print_copyright();
#line 381
  get_args(argc, argv);
#line 383
  init_error_handler();
#line 385
  init_stack();
#line 386
  init_dictionary();
#line 388
  init_scanner();
  }
#line 390
  if ((unsigned long )outputname != (unsigned long )((void *)0)) {
#line 392
    if (argc > optind + 1) {
      {
#line 396
      printf((char const   */* __restrict  */)"Cannot specify single output file name with multiple input file names.\nPlease either remove output-file-name specification,\nor use multiple commands.\n");
#line 400
      exit(-2);
      }
    }
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (optind < argc)) {
#line 404
      goto while_break;
    }
    {
#line 408
    printf((char const   */* __restrict  */)"\nTokenizing  %s   ", *(argv + optind));
#line 409
    init_error_handler();
#line 410
    stream_ok = init_stream((char const   *)*(argv + optind));
    }
#line 411
    if (stream_ok) {
      {
#line 413
      init_output((char const   *)*(argv + optind), (char const   *)outputname);
#line 415
      init_scan_state();
#line 417
      reset_vocabs();
#line 418
      reset_cl_flags();
#line 420
      tokenize();
#line 421
      finish_headers();
#line 423
      close_stream((void *)0);
#line 424
      tmp = close_output();
      }
#line 424
      if (tmp) {
#line 424
        retval = 1;
      }
    }
#line 404
    optind ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  exit_scanner();
  }
#line 429
  return (retval);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
tic_hdr_t *tic_found ;
#line 486
void init_tic_vocab(tic_hdr_t *tic_vocab_tbl , int max_indx , tic_hdr_t **tic_vocab_ptr ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
u8 *statbuf ;
#line 97
long get_word(void) ;
#line 98
bool get_word_in_line(char *func_nam ) ;
#line 112
tic_hdr_t *lookup_word(char *stat_name , char **where_pt1 , char **where_pt2 ) ;
#line 115
void tokenize_one_word(long wlen ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
void just_started_at(char *saved_ifile , unsigned int saved_lineno ) ;
#line 58
void just_where_started(char *saved_ifile , unsigned int saved_lineno ) ;
#line 101
char *strupper(char *strung ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.h"
void init_conditionals_vocab(tic_hdr_t **tic_vocab_ptr ) ;
#line 42
void skip_a_word(tic_bool_param_t pfield ) ;
#line 43
void skip_a_word_in_line(tic_bool_param_t pfield ) ;
#line 44
void skip_two_words_in_line(tic_bool_param_t pfield ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.h"
long dpop(void) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/vocabfuncts.h"
bool exists_in_current(char *tname ) ;
#line 82
tic_hdr_t *lookup_shared_f_exec_word(char *tname ) ;
#line 122 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.h"
bool trace_conditionals ;
#line 132 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static bool is_a_type(char *tname , fwtoken fw_type ) 
{ 
  bool retval ;
  tic_fwt_hdr_t *found ;
  tic_hdr_t *tmp ;

  {
  {
#line 134
  retval = (bool )0;
#line 135
  tmp = lookup_shared_f_exec_word(tname);
#line 135
  found = (tic_fwt_hdr_t *)tmp;
  }
#line 136
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 138
    if ((unsigned int )found->pfield.fw_token == (unsigned int )fw_type) {
#line 138
      retval = (bool )-1;
    }
  }
#line 140
  return (retval);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static bool is_a_then(char *a_word ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 145
  tmp = is_a_type(a_word, (fwtoken )68);
#line 145
  retval = tmp;
  }
#line 146
  return (retval);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static bool is_an_else(char *a_word ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 151
  tmp = is_a_type(a_word, (fwtoken )69);
#line 151
  retval = tmp;
  }
#line 152
  return (retval);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static bool already_ignoring  =    (bool )0;
#line 213 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
void skip_a_word(tic_bool_param_t pfield ) 
{ 


  {
  {
#line 215
  get_word();
  }
#line 216
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
void skip_a_word_in_line(tic_bool_param_t pfield ) 
{ 


  {
  {
#line 243
  get_word_in_line((char *)statbuf);
  }
#line 244
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
void skip_two_words_in_line(tic_bool_param_t pfield ) 
{ 
  char *func_cpy ;
  char *tmp ;
  char *tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 276
  tmp = strdup((char const   *)statbuf);
#line 276
  tmp___0 = strupper(tmp);
#line 276
  func_cpy = tmp___0;
#line 277
  tmp___1 = get_word_in_line(func_cpy);
  }
#line 277
  if (tmp___1) {
    {
#line 279
    get_word_in_line(func_cpy);
    }
  }
  {
#line 281
  free((void *)func_cpy);
  }
#line 282
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void ignore_one_word(char *tname ) 
{ 
  tic_bool_hdr_t *found ;
  tic_hdr_t *tmp ;
  bool save_already_ignoring ;

  {
  {
#line 324
  tmp = lookup_word(tname, (char **)((void *)0), (char **)((void *)0));
#line 324
  found = (tic_bool_hdr_t *)tmp;
  }
#line 325
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 327
    if ((unsigned long )found->ign_func != (unsigned long )((void *)0)) {
      {
#line 329
      save_already_ignoring = already_ignoring;
#line 330
      already_ignoring = (bool )-1;
#line 331
      tic_found = (tic_hdr_t *)found;
#line 333
      (*(found->ign_func))(found->pfield);
#line 335
      already_ignoring = save_already_ignoring;
      }
    }
  }
#line 338
  return;
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void conditionally_tokenize(bool cond , bool alr_ign ) 
{ 
  long wlen ;
  bool ignoring ;
  bool first_else ;
  bool not_done ;
  unsigned int cond_strt_lineno ;
  char *cond_strt_ifile_nam ;
  char *tmp ;
  char *cond_val ;
  char const   *tmp___0 ;
  char *cond_junct ;
  char const   *tmp___1 ;
  char *processg ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  int severity ;
  int tmp___4 ;
  char *the_scop ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *when_enc ;
  char const   *tmp___7 ;
  char *processg___0 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *enc ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  bool tmp___12 ;

  {
  {
#line 436
  first_else = (bool )-1;
#line 437
  not_done = (bool )-1;
#line 438
  cond_strt_lineno = lineno;
#line 439
  tmp = strdup((char const   *)iname);
#line 439
  cond_strt_ifile_nam = tmp;
  }
#line 441
  if ((int )cond == 0) {
#line 441
    ignoring = (bool )-1;
  } else
#line 441
  if ((int )alr_ign != 0) {
#line 441
    ignoring = (bool )-1;
  } else {
#line 441
    ignoring = (bool )0;
  }
#line 443
  if (trace_conditionals) {
#line 445
    if (cond) {
#line 445
      tmp___0 = "True";
    } else {
#line 445
      tmp___0 = "False";
    }
#line 445
    cond_val = (char *)tmp___0;
#line 446
    if (alr_ign) {
#line 446
      tmp___1 = ", but Already ";
    } else {
#line 446
      tmp___1 = "; ";
    }
#line 446
    cond_junct = (char *)tmp___1;
#line 447
    if (ignoring) {
#line 447
      tmp___2 = "Ignoring";
    } else {
#line 447
      tmp___2 = "Processing";
    }
    {
#line 447
    processg = (char *)tmp___2;
#line 448
    tokenization_error(65536, (char *)"Tokenization-Condition is %s%s%s.\n", cond_val,
                       cond_junct, processg);
    }
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! not_done) {
#line 453
      goto while_break;
    }
    {
#line 455
    wlen = get_word();
    }
#line 456
    if (wlen == 0L) {
#line 458
      goto while_continue;
    }
#line 461
    if (wlen < 0L) {
      {
#line 463
      tokenization_error(67108864, (char *)"Conditional without conclusion; started");
#line 465
      just_where_started(cond_strt_ifile_nam, cond_strt_lineno);
#line 466
      not_done = (bool )0;
      }
#line 467
      goto while_continue;
    }
    {
#line 470
    tmp___3 = is_a_then((char *)statbuf);
    }
#line 470
    if (tmp___3) {
#line 472
      if (trace_conditionals) {
        {
#line 474
        tokenization_error(65536, (char *)"Concluding Conditional");
#line 476
        just_started_at(cond_strt_ifile_nam, cond_strt_lineno);
        }
      }
#line 478
      not_done = (bool )0;
#line 479
      goto while_continue;
    }
    {
#line 482
    tmp___12 = is_an_else((char *)statbuf);
    }
#line 482
    if (tmp___12) {
#line 484
      if (! alr_ign) {
#line 486
        if (first_else) {
#line 488
          if (ignoring) {
#line 488
            ignoring = (bool )0;
          } else {
#line 488
            ignoring = (bool )-1;
          }
        }
      }
#line 492
      if (! first_else) {
#line 494
        if (ignoring) {
#line 494
          tmp___4 = 2097152;
        } else {
#line 494
          tmp___4 = 67108864;
        }
#line 494
        severity = tmp___4;
#line 495
        if (ignoring) {
#line 495
          tmp___5 = "(ignored)";
        } else {
#line 495
          tmp___5 = "the";
        }
        {
#line 495
        the_scop = (char *)tmp___5;
#line 496
        tmp___6 = strupper((char *)statbuf);
#line 496
        tokenization_error(severity, (char *)"Multiple %s directives within %s scope of the Conditional",
                           tmp___6, the_scop);
#line 499
        just_started_at(cond_strt_ifile_nam, cond_strt_lineno);
        }
      } else {
#line 501
        first_else = (bool )0;
#line 502
        if (trace_conditionals) {
#line 504
          if (alr_ign) {
#line 504
            tmp___7 = "While already";
          } else {
#line 504
            tmp___7 = "Now";
          }
#line 504
          when_enc = (char *)tmp___7;
#line 505
          if (alr_ign) {
#line 505
            tmp___9 = "ignoring";
          } else {
#line 505
            if (ignoring) {
#line 505
              tmp___8 = "Ignoring";
            } else {
#line 505
              tmp___8 = "Processing";
            }
#line 505
            tmp___9 = tmp___8;
          }
#line 505
          processg___0 = (char *)tmp___9;
#line 507
          if (alr_ign) {
#line 507
            tmp___10 = ", e";
          } else {
#line 507
            tmp___10 = ".  E";
          }
          {
#line 507
          enc = (char *)tmp___10;
#line 509
          tmp___11 = strupper((char *)statbuf);
#line 509
          tokenization_error(65536, (char *)"%s %s%sncountered %s belonging to Conditional",
                             when_enc, processg___0, enc, tmp___11);
#line 512
          just_started_at(cond_strt_ifile_nam, cond_strt_lineno);
          }
        }
      }
#line 516
      goto while_continue;
    }
#line 523
    if (ignoring) {
      {
#line 525
      ignore_one_word((char *)statbuf);
      }
    } else {
      {
#line 528
      tokenize_one_word(wlen);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  return;
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void conditional_word_in_line(bool alr_ign , bool exist_test , bool (*exist_funct)() ) 
{ 
  bool cond ;
  bool exists ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 599
  tmp___1 = get_word_in_line((char *)statbuf);
  }
#line 599
  if (tmp___1) {
#line 601
    cond = (bool )0;
#line 602
    if (alr_ign) {
#line 602
      tmp___0 = 0;
    } else {
#line 602
      tmp___0 = -1;
    }
#line 602
    if (tmp___0) {
      {
#line 604
      tmp = (*exist_funct)(statbuf);
#line 604
      exists = tmp;
      }
#line 605
      if ((int )exists == (int )exist_test) {
#line 605
        cond = (bool )-1;
      } else {
#line 605
        cond = (bool )0;
      }
    }
    {
#line 607
    conditionally_tokenize(cond, alr_ign);
    }
  }
#line 609
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void if_exists(tic_param_t pfield ) 
{ 
  bool alr_ign ;

  {
  {
#line 629
  alr_ign = *(pfield.bool_ptr);
#line 630
  conditional_word_in_line(alr_ign, (bool )-1, (bool (*)())(& exists_in_current));
  }
#line 631
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void if_not_exist(tic_bool_param_t pfield ) 
{ 
  bool alr_ign ;

  {
  {
#line 651
  alr_ign = *(pfield.bool_ptr);
#line 652
  conditional_word_in_line(alr_ign, (bool )0, (bool (*)())(& exists_in_current));
  }
#line 653
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void if_defined(tic_bool_param_t pfield ) 
{ 
  bool alr_ign ;

  {
  {
#line 668
  alr_ign = *(pfield.bool_ptr);
#line 669
  conditional_word_in_line(alr_ign, (bool )-1, (bool (*)())(& exists_as_user_symbol));
  }
#line 670
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void if_not_defined(tic_bool_param_t pfield ) 
{ 
  bool alr_ign ;

  {
  {
#line 685
  alr_ign = *(pfield.bool_ptr);
#line 686
  conditional_word_in_line(alr_ign, (bool )0, (bool (*)())(& exists_as_user_symbol));
  }
#line 687
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static void if_from_stack(tic_bool_param_t pfield ) 
{ 
  bool alr_ign ;
  bool cond ;
  long num ;
  long tmp ;

  {
#line 709
  alr_ign = *(pfield.bool_ptr);
#line 710
  cond = (bool )0;
#line 712
  if (! alr_ign) {
    {
#line 714
    tmp = dpop();
#line 714
    num = tmp;
    }
#line 715
    if (num != 0L) {
#line 717
      cond = (bool )-1;
    }
  }
  {
#line 720
  conditionally_tokenize(cond, alr_ign);
  }
#line 721
  return;
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static tic_bool_hdr_t conditionals_vocab_tbl[16]  = 
#line 734
  {      {(char *)"[ifexist]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_exists),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_exists),
      0, (bool )0}, 
        {(char *)"[ifexists]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_exists),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_exists),
      0, (bool )0}, 
        {(char *)"#ifexist", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_exists),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_exists),
      0, (bool )0}, 
        {(char *)"#ifexists", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_exists),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_exists),
      0, (bool )0}, 
        {(char *)"[#ifexist]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_exists),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_exists),
      0, (bool )0}, 
        {(char *)"[#ifexists]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_exists),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_exists),
      0, (bool )0}, 
        {(char *)"[ifnexist]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_not_exist),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_not_exist),
      0, (bool )0}, 
        {(char *)"#ifnexist", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_not_exist),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_not_exist),
      0, (bool )0}, 
        {(char *)"[#ifnexist]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_not_exist),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_not_exist),
      0, (bool )0}, 
        {(char *)"[ifdef]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_defined),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_defined),
      0, (bool )0}, 
        {(char *)"#ifdef", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_defined),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_defined),
      0, (bool )0}, 
        {(char *)"[#ifdef]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_defined),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_defined),
      0, (bool )0}, 
        {(char *)"[ifndef]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_not_defined),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_not_defined),
      0, (bool )0}, 
        {(char *)"#ifndef", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_not_defined),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_not_defined),
      0, (bool )0}, 
        {(char *)"[#ifndef]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_not_defined),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_not_defined),
      0, (bool )0}, 
        {(char *)"[if]", (tic_bool_hdr_t *)((void *)0), (void (*)())(& if_from_stack),
      {& already_ignoring}, (fwtoken )3236806878U, (bool )0, (void (*)())(& if_from_stack),
      0, (bool )0}};
#line 765 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
static int const   conditionals_vocab_max_indx  =    (int const   )(sizeof(conditionals_vocab_tbl) / sizeof(tic_bool_hdr_t ));
#line 763 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/conditl.c"
void init_conditionals_vocab(tic_hdr_t **tic_vocab_ptr ) 
{ 


  {
  {
#line 768
  init_tic_vocab((tic_hdr_t *)(conditionals_vocab_tbl), (int )conditionals_vocab_max_indx,
                 tic_vocab_ptr);
  }
#line 771
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 497 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
tic_hdr_t *lookup_tic_entry(char *tname , tic_hdr_t *tic_vocab ) ;
#line 503
void reset_tic_vocab(tic_hdr_t **tic_vocab , tic_hdr_t *reset_position ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.h"
char default_top_dev_ifile_name[22] ;
#line 71
device_node_t *current_device_node ;
#line 72
tic_hdr_t **current_definitions ;
#line 79
void new_device_vocab(void) ;
#line 80
void delete_device_vocab(void) ;
#line 81
void finish_device_vocab(void) ;
#line 82
char *in_what_node(device_node_t *the_node ) ;
#line 83
void show_node_start(void) ;
#line 84
bool exists_in_ancestor(char *m_name ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
bool as_a_what(fwtoken definer , char *as_what ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/vocabfuncts.h"
bool scope_is_global ;
#line 68 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.h"
void announce_control_structs(int severity , char *call_cond , unsigned int abs_token_limit ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
char default_top_dev_ifile_name[22]  = 
#line 103 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
  {      (char )'S',      (char )'t',      (char )'a',      (char )'r', 
        (char )'t',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'o',      (char )'k', 
        (char )'e',      (char )'n',      (char )'i',      (char )'z', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'\000'};
#line 105 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static device_node_t top_level_dev_node  =    {(struct device_node *)((void *)0), default_top_dev_ifile_name, 0U, (tic_hdr_t *)((void *)0)};
#line 123 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
device_node_t *current_device_node  =    & top_level_dev_node;
#line 124 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
tic_hdr_t **current_definitions  =    & top_level_dev_node.tokens_vocab;
#line 143 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static char in_what_buffr[50]  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static bool show_where  =    (bool )0;
#line 145 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static bool show_which  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static int in_what_line  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static char *in_what_file  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
static void dev_vocab_control_struct_check(void) 
{ 
  char *ccs_messg ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = strlen((char const   *)statbuf);
#line 180
  tmp___0 = safe_malloc(tmp + 32UL, (char *)"Device-Node control-structure check");
#line 180
  ccs_messg = (char *)tmp___0;
#line 183
  strcpy((char */* __restrict  */)ccs_messg, (char const   */* __restrict  */)statbuf);
#line 184
  strupper(ccs_messg);
#line 185
  strcat((char */* __restrict  */)ccs_messg, (char const   */* __restrict  */)" encountered");
#line 186
  announce_control_structs(2097152, ccs_messg, 0U);
#line 187
  free((void *)ccs_messg);
  }
#line 188
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
void new_device_vocab(void) 
{ 
  device_node_t *new_node_data ;
  void *tmp ;

  {
  {
#line 236
  dev_vocab_control_struct_check();
  }
#line 243
  if ((unsigned long )current_device_node == (unsigned long )(& top_level_dev_node)) {
    {
#line 245
    tokenization_error(65536, (char *)"Encountered %s.  Starting new device-node.\n",
                       statbuf);
    }
  } else {
    {
#line 247
    tokenization_error(65536, (char *)"Encountered %s.  Starting new device-node.  Suspending definitions of parent-device node",
                       statbuf);
#line 249
    started_at(current_device_node->ifile_name, current_device_node->line_no);
    }
  }
  {
#line 254
  tmp = safe_malloc(sizeof(device_node_t ), (char *)"creating new-device vocab data");
#line 254
  new_node_data = (device_node_t *)tmp;
#line 256
  new_node_data->parent_node = current_device_node;
#line 257
  new_node_data->ifile_name = strdup((char const   *)iname);
#line 258
  new_node_data->line_no = lineno;
#line 259
  new_node_data->tokens_vocab = (tic_hdr_t *)((void *)0);
#line 261
  current_device_node = new_node_data;
#line 263
  current_definitions = & current_device_node->tokens_vocab;
  }
#line 264
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
void delete_device_vocab(void) 
{ 
  device_node_t *temp_node ;

  {
  {
#line 300
  reset_tic_vocab(current_definitions, (tic_hdr_t *)((void *)0));
  }
#line 302
  if ((unsigned long )current_device_node != (unsigned long )(& top_level_dev_node)) {
    {
#line 304
    temp_node = current_device_node;
#line 305
    current_device_node = current_device_node->parent_node;
#line 306
    free((void *)temp_node->ifile_name);
#line 307
    free((void *)temp_node);
    }
  }
#line 310
  current_definitions = & current_device_node->tokens_vocab;
#line 311
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
void finish_device_vocab(void) 
{ 
  bool at_top_level ;
  int tmp ;

  {
  {
#line 353
  dev_vocab_control_struct_check();
  }
#line 359
  if ((unsigned long )current_device_node == (unsigned long )(& top_level_dev_node)) {
#line 359
    at_top_level = (bool )-1;
  } else {
#line 359
    at_top_level = (bool )0;
  }
#line 360
  if (at_top_level) {
    {
#line 362
    tokenization_error(67108864, (char *)"Encountered %s without corresponding NEW-DEVICE.  Resetting definitions since start of tokenization.\n",
                       statbuf);
    }
  } else {
    {
#line 367
    tokenization_error(65536, (char *)"Encountered %s.  Resetting definitions of device node",
                       statbuf);
#line 370
    started_at(current_device_node->ifile_name, current_device_node->line_no);
    }
  }
  {
#line 375
  delete_device_vocab();
  }
#line 380
  if (at_top_level) {
#line 380
    tmp = 0;
  } else {
#line 380
    tmp = -1;
  }
#line 380
  if (tmp) {
#line 382
    if ((unsigned long )current_device_node == (unsigned long )(& top_level_dev_node)) {
      {
#line 384
      tokenization_error(65536, (char *)"Resuming definitions since start of tokenization.\n");
      }
    } else {
      {
#line 387
      tokenization_error(65536, (char *)"Resuming definitions of parent device-node");
#line 389
      started_at(current_device_node->ifile_name, current_device_node->line_no);
      }
    }
  }
#line 393
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
char *in_what_node(device_node_t *the_node ) 
{ 
  bool top_node ;
  int tmp ;
  bool curr_node ;
  int tmp___0 ;
  bool known_node ;
  int tmp___1 ;
  bool no_line ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 459
  if ((unsigned long )the_node == (unsigned long )(& top_level_dev_node)) {
#line 459
    tmp = -1;
  } else {
#line 459
    tmp = 0;
  }
#line 459
  top_node = (bool )tmp;
#line 460
  if ((unsigned long )the_node == (unsigned long )current_device_node) {
#line 460
    tmp___0 = -1;
  } else {
#line 460
    tmp___0 = 0;
  }
#line 460
  curr_node = (bool )tmp___0;
#line 461
  if (top_node) {
#line 461
    tmp___1 = -1;
  } else
#line 461
  if (curr_node) {
#line 461
    tmp___1 = -1;
  } else {
#line 461
    tmp___1 = 0;
  }
#line 461
  known_node = (bool )tmp___1;
#line 462
  if (the_node->line_no == 0U) {
#line 462
    tmp___2 = -1;
  } else {
#line 462
    tmp___2 = 0;
  }
#line 462
  no_line = (bool )tmp___2;
#line 464
  if (no_line) {
#line 464
    show_where = (bool )0;
  } else {
#line 464
    show_where = (bool )-1;
  }
#line 465
  show_which = known_node;
#line 466
  in_what_line = (int )the_node->line_no;
#line 467
  in_what_file = the_node->ifile_name;
#line 469
  if (no_line) {
#line 469
    tmp___4 = ".\n";
  } else {
#line 469
    if (known_node) {
#line 469
      tmp___3 = ", which began";
    } else {
#line 469
      tmp___3 = "";
    }
#line 469
    tmp___4 = tmp___3;
  }
#line 469
  if (known_node) {
#line 469
    tmp___8 = 0;
  } else {
#line 469
    tmp___8 = -1;
  }
#line 469
  if (tmp___8) {
#line 469
    tmp___7 = "";
  } else {
#line 469
    if (top_node) {
#line 469
      tmp___6 = " top-level";
    } else {
#line 469
      tmp___6 = " current";
    }
#line 469
    tmp___7 = tmp___6;
  }
  {
#line 469
  sprintf((char */* __restrict  */)(in_what_buffr), (char const   */* __restrict  */)"in the%s device-node%s",
          tmp___7, tmp___4);
  }
#line 477
  return (in_what_buffr);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
void show_node_start(void) 
{ 


  {
#line 515
  if (show_where) {
#line 517
    if (show_which) {
      {
#line 519
      just_where_started(in_what_file, (unsigned int )in_what_line);
      }
    } else {
      {
#line 521
      just_started_at(in_what_file, (unsigned int )in_what_line);
      }
    }
#line 523
    show_where = (bool )0;
  }
#line 525
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/devnode.c"
bool exists_in_ancestor(char *m_name ) 
{ 
  tic_hdr_t *found ;
  bool retval ;
  device_node_t *grandpa ;
  char as_what_buf[32] ;
  unsigned int tmp ;
  bool tmp___0 ;
  char *tmp___1 ;

  {
#line 565
  retval = (bool )0;
#line 566
  if ((unsigned long )current_device_node != (unsigned long )((void *)0)) {
#line 568
    grandpa = current_device_node->parent_node;
#line 570
    if (scope_is_global) {
#line 570
      grandpa = current_device_node;
    }
    {
#line 572
    while (1) {
      while_continue: /* CIL Label */ ;
#line 572
      if (! ((unsigned long )grandpa != (unsigned long )((void *)0))) {
#line 572
        goto while_break;
      }
      {
#line 574
      found = lookup_tic_entry(m_name, grandpa->tokens_vocab);
      }
#line 575
      if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 577
        retval = (bool )-1;
#line 578
        goto while_break;
      }
#line 572
      grandpa = grandpa->parent_node;
    }
    while_break: /* CIL Label */ ;
    }
#line 581
    if ((unsigned long )grandpa != (unsigned long )((void *)0)) {
#line 583
      as_what_buf[0] = (char )'\000';
#line 583
      tmp = 1U;
      {
#line 583
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 583
        if (tmp >= 32U) {
#line 583
          goto while_break___0;
        }
#line 583
        as_what_buf[tmp] = (char)0;
#line 583
        tmp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 584
      tmp___0 = as_a_what(found->fword_defr, as_what_buf);
      }
#line 584
      if (tmp___0) {
        {
#line 586
        strcat((char */* __restrict  */)(as_what_buf), (char const   */* __restrict  */)" ");
        }
      }
      {
#line 588
      tmp___1 = in_what_node(grandpa);
#line 588
      tokenization_error(65536, (char *)"%s is defined %s%s", m_name, as_what_buf,
                         tmp___1);
#line 590
      show_node_start();
      }
    }
  }
#line 594
  return (retval);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
void emit_offset(s16 offs ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/vocabfuncts.h"
void emit_token(char const   *fc_name ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
bool offs16 ;
#line 62
int do_loop_depth ;
#line 57 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
void where_started(char *saved_ifile , unsigned int saved_lineno ) ;
#line 59
void in_last_colon(bool say_in ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.h"
int control_stack_depth ;
#line 53
void emit_if(void) ;
#line 54
void emit_then(void) ;
#line 55
void emit_else(void) ;
#line 56
void emit_begin(void) ;
#line 57
void emit_again(void) ;
#line 58
void emit_until(void) ;
#line 59
void emit_while(void) ;
#line 60
void emit_repeat(void) ;
#line 61
void mark_do(void) ;
#line 62
void resolve_loop(void) ;
#line 63
void emit_case(void) ;
#line 64
void emit_of(void) ;
#line 65
void emit_endof(void) ;
#line 66
void emit_endcase(void) ;
#line 70
void clear_control_structs_to_limit(char *call_cond , unsigned int abs_token_limit ) ;
#line 72
void clear_control_structs(char *call_cond ) ;
#line 133 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
int control_stack_depth  =    0;
#line 308 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static cstag_group_t *control_stack  =    (cstag_group_t *)((void *)0);
#line 321 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static bool not_cs_underflow  ;
#line 340 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static bool not_consuming_two  =    (bool )-1;
#line 341 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static bool didnt_print_otl  =    (bool )-1;
#line 379 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void push_cstag(unsigned long cstag , unsigned long datum ) 
{ 
  cstag_group_t *cs_temp ;
  void *tmp ;

  {
  {
#line 383
  cs_temp = control_stack;
#line 384
  tmp = safe_malloc(sizeof(cstag_group_t ), (char *)"pushing CSTag");
#line 384
  control_stack = (cstag_group_t *)tmp;
#line 386
  control_stack->cs_tag = cstag;
#line 387
  control_stack->cs_inp_fil = strdup((char const   *)iname);
#line 388
  control_stack->cs_line_num = lineno;
#line 389
  control_stack->cs_abs_token_num = abs_token_no;
#line 390
  control_stack->cs_word = strdup((char const   *)statbuf);
#line 391
  control_stack->cs_not_dup = (bool )-1;
#line 392
  control_stack->cs_datum = datum;
#line 393
  control_stack->prev = cs_temp;
#line 395
  control_stack_depth ++;
  }
#line 397
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void pop_cstag(void) 
{ 
  cstag_group_t *cs_temp ;

  {
#line 432
  if ((unsigned long )control_stack != (unsigned long )((void *)0)) {
    {
#line 436
    cs_temp = control_stack->prev;
#line 437
    free((void *)control_stack->cs_word);
#line 438
    free((void *)control_stack->cs_inp_fil);
#line 439
    free((void *)control_stack);
#line 440
    control_stack = cs_temp;
#line 442
    control_stack_depth --;
    }
  }
#line 444
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static bool control_stack_size_test(int min_depth ) 
{ 
  bool retval ;
  char *tmp ;

  {
#line 475
  retval = (bool )-1;
#line 477
  if (control_stack_depth < min_depth) {
    {
#line 479
    retval = (bool )0;
#line 480
    tmp = strupper((char *)statbuf);
#line 480
    tokenization_error(67108864, (char *)"Control-Stack underflow at %s", tmp);
#line 482
    in_last_colon((bool )-1);
#line 484
    not_cs_underflow = (bool )0;
    }
  }
#line 487
  return (retval);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void control_structure_mismatch(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 526
  if (control_stack->cs_not_dup) {
    {
#line 528
    tmp = strupper(control_stack->cs_word);
#line 528
    tmp___0 = strupper((char *)statbuf);
#line 528
    tokenization_error(67108864, (char *)"The %s is mismatched with the %s", tmp___0,
                       tmp);
#line 531
    where_started(control_stack->cs_inp_fil, control_stack->cs_line_num);
    }
  } else
#line 526
  if (not_consuming_two) {
    {
#line 528
    tmp = strupper(control_stack->cs_word);
#line 528
    tmp___0 = strupper((char *)statbuf);
#line 528
    tokenization_error(67108864, (char *)"The %s is mismatched with the %s", tmp___0,
                       tmp);
#line 531
    where_started(control_stack->cs_inp_fil, control_stack->cs_line_num);
    }
  }
#line 533
  return;
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void offset_too_large(bool too_large_for_16 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 584
  if (control_stack->cs_not_dup) {
#line 584
    goto _L;
  } else
#line 584
  if (didnt_print_otl) {
    _L: /* CIL Label */ 
    {
#line 586
    tmp = strupper(control_stack->cs_word);
#line 586
    tmp___0 = strupper((char *)statbuf);
#line 586
    tokenization_error(67108864, (char *)"Branch offset is too large between %s and the %s",
                       tmp___0, tmp);
#line 589
    where_started(control_stack->cs_inp_fil, control_stack->cs_line_num);
    }
#line 590
    if (offs16) {
#line 590
      tmp___1 = 0;
    } else {
#line 590
      tmp___1 = -1;
    }
#line 590
    if (tmp___1) {
#line 592
      if (too_large_for_16) {
        {
#line 594
        tokenization_error(65536, (char *)"Offset would be too large even if 16-bit offsets were in effect.\n");
        }
      } else {
        {
#line 598
        tokenization_error(65536, (char *)"Offset might fit if 16-bit offsets (e.g., fcode-version2) were used.\n");
        }
      }
    }
  }
#line 604
  didnt_print_otl = (bool )0;
#line 605
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void emit_fc_offset(int fc_offset ) 
{ 
  int fc_offs_s16 ;
  int fc_offs_s8 ;
  bool too_large_for_8 ;
  int tmp ;
  bool too_large_for_16 ;
  int tmp___0 ;
  int coded_as ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 643
  fc_offs_s16 = (int )((s16 )fc_offset);
#line 644
  fc_offs_s8 = (int )((s8 )fc_offset);
#line 645
  if (fc_offset != fc_offs_s8) {
#line 645
    tmp = -1;
  } else {
#line 645
    tmp = 0;
  }
#line 645
  too_large_for_8 = (bool )tmp;
#line 646
  if (fc_offset != fc_offs_s16) {
#line 646
    tmp___0 = -1;
  } else {
#line 646
    tmp___0 = 0;
  }
#line 646
  too_large_for_16 = (bool )tmp___0;
#line 648
  if (too_large_for_16) {
#line 648
    goto _L;
  } else {
#line 648
    if (offs16) {
#line 648
      tmp___2 = 0;
    } else {
#line 648
      tmp___2 = -1;
    }
#line 648
    if (tmp___2) {
#line 648
      if (too_large_for_8) {
        _L: /* CIL Label */ 
        {
#line 650
        offset_too_large(too_large_for_16);
        }
#line 651
        if (noerrors) {
#line 653
          if (offs16) {
#line 653
            tmp___1 = fc_offs_s16;
          } else {
#line 653
            tmp___1 = fc_offs_s8;
          }
          {
#line 653
          coded_as = tmp___1;
#line 654
          tokenization_error(2097152, (char *)"Actual offset is 0x%x (=dec %d), but it will be coded as 0x%x (=dec %d).\n",
                             fc_offset, fc_offset, coded_as, coded_as);
          }
        }
      }
    }
  }
  {
#line 661
  emit_offset((s16 )fc_offs_s16);
  }
#line 662
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static bool matchup_control_structure(unsigned long cstag ) 
{ 
  bool retval ;
  int tmp ;
  bool tmp___0 ;

  {
  {
#line 728
  retval = (bool )0;
#line 730
  tmp___0 = control_stack_size_test(1);
  }
#line 730
  if (tmp___0) {
#line 732
    retval = (bool )-1;
#line 734
    if (control_stack->cs_tag != cstag) {
      {
#line 736
      control_structure_mismatch();
      }
#line 738
      if (noerrors) {
#line 738
        tmp = 0;
      } else {
#line 738
        tmp = -1;
      }
#line 738
      if (tmp) {
#line 743
        retval = (bool )0;
      } else
#line 738
      if (cstag == 3313158750UL) {
#line 743
        retval = (bool )0;
      } else
#line 738
      if (control_stack->cs_tag == 3313158750UL) {
#line 743
        retval = (bool )0;
      }
    }
  }
#line 748
  return (retval);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void control_structure_swap(void) 
{ 
  cstag_group_t *cs_temp ;
  bool tmp ;

  {
  {
#line 798
  tmp = control_stack_size_test(2);
  }
#line 798
  if (tmp) {
#line 802
    cs_temp = control_stack->prev;
#line 804
    control_stack->prev = cs_temp->prev;
#line 805
    cs_temp->prev = control_stack;
#line 806
    control_stack = cs_temp;
  }
#line 808
  return;
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static bool matchup_two_control_structures(unsigned long top_cstag , unsigned long next_cstag ) 
{ 
  bool retval ;
  bool topmatch ;
  bool nextmatch ;
  bool sav_noerrors ;
  int tmp ;

  {
  {
#line 859
  nextmatch = (bool )0;
#line 860
  sav_noerrors = noerrors;
#line 861
  noerrors = (bool )0;
#line 862
  not_consuming_two = (bool )0;
#line 864
  not_cs_underflow = (bool )-1;
#line 865
  topmatch = matchup_control_structure(top_cstag);
  }
#line 866
  if (not_cs_underflow) {
    {
#line 868
    control_structure_swap();
    }
#line 869
    if (not_cs_underflow) {
      {
#line 871
      nextmatch = matchup_control_structure(next_cstag);
#line 872
      control_structure_swap();
      }
    }
  }
#line 876
  if (topmatch) {
#line 876
    if (nextmatch) {
#line 876
      retval = (bool )-1;
    } else {
#line 876
      retval = (bool )0;
    }
  } else {
#line 876
    retval = (bool )0;
  }
#line 878
  if (retval) {
#line 878
    tmp = 0;
  } else {
#line 878
    tmp = -1;
  }
#line 878
  if (tmp) {
    {
#line 880
    pop_cstag();
#line 881
    pop_cstag();
    }
  }
#line 884
  not_consuming_two = (bool )-1;
#line 885
  noerrors = sav_noerrors;
#line 886
  return (retval);
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void mark_backward_target(unsigned long cstag ) 
{ 


  {
  {
#line 922
  push_cstag(cstag, (unsigned long )opc);
  }
#line 923
  return;
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void mark_forward_branch(unsigned long cstag ) 
{ 


  {
  {
#line 966
  mark_backward_target(cstag);
#line 967
  emit_offset((s16 )0);
  }
#line 968
  return;
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void resolve_backward(unsigned long cstag ) 
{ 
  unsigned long targ_opc ;
  int fc_offset ;
  bool tmp ;

  {
  {
#line 1021
  fc_offset = 0;
#line 1023
  tmp = matchup_control_structure(cstag);
  }
#line 1023
  if (tmp) {
#line 1025
    targ_opc = control_stack->cs_datum;
#line 1026
    fc_offset = (int )(targ_opc - (unsigned long )opc);
  }
  {
#line 1029
  emit_fc_offset(fc_offset);
#line 1030
  pop_cstag();
  }
#line 1031
  return;
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void resolve_forward(unsigned long cstag ) 
{ 
  unsigned long resvd_opc ;
  bool sav_noerrors ;
  bool cs_match_result ;
  int saved_opc ;
  int fc_offset ;

  {
  {
#line 1092
  sav_noerrors = noerrors;
#line 1094
  noerrors = (bool )0;
#line 1098
  cs_match_result = matchup_control_structure(cstag);
#line 1099
  noerrors = sav_noerrors;
  }
#line 1101
  if (cs_match_result) {
    {
#line 1106
    resvd_opc = control_stack->cs_datum;
#line 1107
    fc_offset = (int )((unsigned long )opc - resvd_opc);
#line 1109
    saved_opc = (int )opc;
#line 1110
    opc = (unsigned int )resvd_opc;
#line 1113
    emit_fc_offset(fc_offset);
#line 1114
    opc = (unsigned int )saved_opc;
    }
  }
  {
#line 1116
  pop_cstag();
  }
#line 1117
  return;
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_if(void) 
{ 


  {
  {
#line 1157
  emit_token("b?branch");
#line 1158
  mark_forward_branch(3313143839UL);
  }
#line 1159
  return;
}
}
#line 1196 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_then(void) 
{ 


  {
  {
#line 1198
  emit_token("b(>resolve)");
  }
#line 1199
  if ((unsigned long )control_stack != (unsigned long )((void *)0)) {
#line 1201
    if (control_stack->cs_tag == 3312664878UL) {
#line 1203
      control_stack->cs_tag = 3313143839UL;
    }
  }
  {
#line 1206
  resolve_forward(3313143839UL);
  }
#line 1207
  return;
}
}
#line 1258 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_else(void) 
{ 


  {
#line 1260
  if (control_stack_depth > 0) {
    {
#line 1262
    emit_token("bbranch");
#line 1263
    mark_forward_branch(3313143839UL);
    }
  }
  {
#line 1265
  not_cs_underflow = (bool )-1;
#line 1266
  control_structure_swap();
  }
#line 1267
  if (not_cs_underflow) {
    {
#line 1269
    emit_then();
    }
  }
#line 1271
  return;
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_begin(void) 
{ 


  {
  {
#line 1296
  emit_token("b(<mark)");
#line 1297
  mark_backward_target(3313232150UL);
  }
#line 1298
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_again(void) 
{ 


  {
  {
#line 1330
  emit_token("bbranch");
#line 1331
  resolve_backward(3313232150UL);
  }
#line 1332
  return;
}
}
#line 1347 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_until(void) 
{ 


  {
  {
#line 1349
  emit_token("b?branch");
#line 1350
  resolve_backward(3313232150UL);
  }
#line 1351
  return;
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_while(void) 
{ 


  {
#line 1404
  if (control_stack_depth > 0) {
    {
#line 1406
    emit_token("b?branch");
#line 1407
    mark_forward_branch(3312664878UL);
    }
  }
  {
#line 1409
  control_structure_swap();
  }
#line 1410
  return;
}
}
#line 1452 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_repeat(void) 
{ 
  bool tmp ;

  {
  {
#line 1454
  tmp = matchup_two_control_structures(3313232150UL, 3312664878UL);
  }
#line 1454
  if (tmp) {
    {
#line 1456
    not_cs_underflow = (bool )-1;
#line 1457
    not_consuming_two = (bool )0;
#line 1458
    emit_again();
    }
#line 1459
    if (not_cs_underflow) {
      {
#line 1461
      emit_token("b(>resolve)");
#line 1462
      resolve_forward(3312664878UL);
      }
    }
#line 1464
    not_consuming_two = (bool )-1;
  }
#line 1466
  return;
}
}
#line 1518 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void mark_do(void) 
{ 


  {
  {
#line 1520
  mark_forward_branch(3313144016UL);
#line 1521
  control_stack->cs_not_dup = (bool )0;
#line 1522
  mark_backward_target(3313144016UL);
#line 1523
  do_loop_depth ++;
  }
#line 1524
  return;
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void resolve_loop(void) 
{ 
  int tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 1601
  tmp___1 = matchup_two_control_structures(3313144016UL, 3313144016UL);
  }
#line 1601
  if (tmp___1) {
#line 1601
    tmp___0 = 0;
  } else {
#line 1601
    tmp___0 = -1;
  }
#line 1601
  if (tmp___0) {
    {
#line 1603
    emit_offset((s16 )0);
    }
  } else {
    {
#line 1605
    not_cs_underflow = (bool )-1;
#line 1606
    didnt_print_otl = (bool )-1;
#line 1607
    not_consuming_two = (bool )0;
#line 1608
    resolve_backward(3313144016UL);
    }
#line 1609
    if (not_cs_underflow) {
      {
#line 1611
      resolve_forward(3313144016UL);
      }
    }
#line 1613
    if (do_loop_depth > 0) {
#line 1613
      do_loop_depth --;
    }
#line 1614
    not_consuming_two = (bool )-1;
#line 1615
    didnt_print_otl = (bool )-1;
  }
#line 1617
  return;
}
}
#line 1640 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_case(void) 
{ 


  {
  {
#line 1642
  push_cstag(3313158750UL, 0UL);
#line 1643
  emit_token("b(case)");
  }
#line 1644
  return;
}
}
#line 1692 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_of(void) 
{ 
  bool tmp ;

  {
  {
#line 1695
  tmp = matchup_control_structure(3313158750UL);
  }
#line 1695
  if (tmp) {
    {
#line 1697
    emit_token("b(of)");
#line 1708
    (control_stack->cs_datum) ++;
#line 1712
    mark_forward_branch(3313144048UL);
    }
  }
#line 1717
  return;
}
}
#line 1760 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_endof(void) 
{ 
  bool tmp ;

  {
  {
#line 1762
  tmp = control_stack_size_test(2);
  }
#line 1762
  if (tmp) {
    {
#line 1764
    emit_token("b(endof)");
#line 1773
    mark_forward_branch(3313397007UL);
#line 1778
    control_structure_swap();
#line 1783
    resolve_forward(3313144048UL);
#line 1788
    control_structure_swap();
    }
  }
#line 1805
  return;
}
}
#line 1845 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void emit_endcase(void) 
{ 
  unsigned long n_endofs ;
  int indx ;
  bool tmp ;

  {
  {
#line 1848
  tmp = matchup_control_structure(3313158750UL);
  }
#line 1848
  if (tmp) {
    {
#line 1852
    emit_token("b(endcase)");
#line 1853
    n_endofs = control_stack->cs_datum;
#line 1854
    indx = 0;
    }
    {
#line 1854
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1854
      if (! ((unsigned long )indx < n_endofs)) {
#line 1854
        goto while_break;
      }
      {
#line 1864
      control_structure_swap();
#line 1865
      resolve_forward(3313397007UL);
#line 1854
      indx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1868
  pop_cstag();
  }
#line 1869
  return;
}
}
#line 1898 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
static void control_struct_incomplete(int severity , char *call_cond , cstag_group_t *c_s_entry ) 
{ 
  char *tmp ;

  {
  {
#line 1903
  tmp = strupper(c_s_entry->cs_word);
#line 1903
  tokenization_error(severity, (char *)"%s before completion of %s", call_cond, tmp);
#line 1906
  where_started(c_s_entry->cs_inp_fil, c_s_entry->cs_line_num);
  }
#line 1907
  return;
}
}
#line 1934 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void announce_control_structs(int severity , char *call_cond , unsigned int abs_token_limit ) 
{ 
  cstag_group_t *cs_temp ;

  {
#line 1937
  cs_temp = control_stack;
  {
#line 1938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1938
    if (! ((unsigned long )cs_temp != (unsigned long )((void *)0))) {
#line 1938
      goto while_break;
    }
#line 1940
    if (cs_temp->cs_abs_token_num < abs_token_limit) {
#line 1942
      goto while_break;
    }
#line 1944
    if (cs_temp->cs_not_dup) {
      {
#line 1946
      control_struct_incomplete(severity, call_cond, cs_temp);
      }
    }
#line 1948
    cs_temp = cs_temp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 1950
  return;
}
}
#line 2012 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void clear_control_structs_to_limit(char *call_cond , unsigned int abs_token_limit ) 
{ 


  {
  {
#line 2015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2015
    if (! (control_stack_depth > 0)) {
#line 2015
      goto while_break;
    }
#line 2017
    if (control_stack->cs_abs_token_num < abs_token_limit) {
#line 2019
      goto while_break;
    }
#line 2021
    if (control_stack->cs_not_dup) {
      {
#line 2023
      control_struct_incomplete(67108864, call_cond, control_stack);
      }
#line 2024
      if (control_stack->cs_tag == 3313144016UL) {
#line 2024
        do_loop_depth --;
      }
    }
    {
#line 2026
    pop_cstag();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2028
  return;
}
}
#line 2077 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/flowcontrol.c"
void clear_control_structs(char *call_cond ) 
{ 


  {
  {
#line 2079
  clear_control_structs_to_limit(call_cond, 0U);
  }
#line 2080
  return;
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.h"
tic_hdr_t *tic_found  ;
#line 489
void add_tic_entry(char *tname , void (*tfunct)() , long tparam , fwtoken fw_defr ,
                   int pfldsiz , bool is_single , void (*ign_fnc)() , tic_hdr_t **tic_vocab ) ;
#line 498
bool exists_in_tic_vocab(char *tname , tic_hdr_t *tic_vocab ) ;
#line 499
bool handle_tic_vocab(char *tname , tic_hdr_t *tic_vocab ) ;
#line 500
bool create_split_alias(char *new_name , char *old_name , tic_hdr_t **src_vocab ,
                        tic_hdr_t **dest_vocab ) ;
#line 502
bool create_tic_alias(char *new_name , char *old_name , tic_hdr_t **tic_vocab ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.h"
bool is_on_trace_list(char *symb_name ) ;
#line 58
void trace_creation(tic_hdr_t *trace_entry , char *nu_name , bool is_global ) ;
#line 66
void trace_builtin(tic_hdr_t *trace_entry ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
void warn_if_duplicate(char *stat_name ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
void init_tic_vocab(tic_hdr_t *tic_vocab_tbl , int max_indx , tic_hdr_t **tic_vocab_ptr ) 
{ 
  int indx ;

  {
#line 153
  indx = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (indx < max_indx)) {
#line 153
      goto while_break;
    }
    {
#line 155
    (tic_vocab_tbl + indx)->next = *tic_vocab_ptr;
#line 156
    *tic_vocab_ptr = tic_vocab_tbl + indx;
#line 157
    trace_builtin(tic_vocab_tbl + indx);
#line 153
    indx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
static tic_hdr_t *make_tic_entry(char *tname , void (*tfunct)() , long tparam , fwtoken fw_defr ,
                                 int pfldsiz , bool is_single , void (*ign_fnc)() ,
                                 bool trace_this , tic_hdr_t **tic_vocab ) 
{ 
  tic_hdr_t *new_entry ;
  void *tmp ;

  {
  {
#line 222
  tmp = safe_malloc(sizeof(tic_hdr_t ), (char *)"adding tic_entry");
#line 222
  new_entry = (tic_hdr_t *)tmp;
#line 223
  new_entry->name = tname;
#line 224
  new_entry->next = *tic_vocab;
#line 225
  new_entry->funct = tfunct;
#line 226
  new_entry->pfield.deflt_elem = tparam;
#line 227
  new_entry->fword_defr = fw_defr;
#line 228
  new_entry->is_token = is_single;
#line 229
  new_entry->ign_func = ign_fnc;
#line 230
  new_entry->pfld_size = pfldsiz;
#line 231
  new_entry->tracing = trace_this;
  }
#line 233
  return (new_entry);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
void add_tic_entry(char *tname , void (*tfunct)() , long tparam , fwtoken fw_defr ,
                   int pfldsiz , bool is_single , void (*ign_fnc)() , tic_hdr_t **tic_vocab ) 
{ 
  bool trace_this ;
  bool tmp ;
  tic_hdr_t *new_entry ;
  tic_hdr_t *tmp___0 ;

  {
  {
#line 296
  tmp = is_on_trace_list(tname);
#line 296
  trace_this = tmp;
#line 297
  tmp___0 = make_tic_entry(tname, tfunct, tparam, fw_defr, pfldsiz, is_single, ign_fnc,
                           trace_this, tic_vocab);
#line 297
  new_entry = tmp___0;
  }
#line 306
  if (trace_this) {
    {
#line 308
    trace_creation(new_entry, (char *)((void *)0), scope_is_global);
    }
  }
  {
#line 310
  warn_if_duplicate(tname);
#line 311
  *tic_vocab = new_entry;
  }
#line 313
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
tic_hdr_t *lookup_tic_entry(char *tname , tic_hdr_t *tic_vocab ) 
{ 
  tic_hdr_t *curr ;
  int tmp ;

  {
#line 342
  curr = tic_vocab;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 342
      goto while_break;
    }
    {
#line 344
    tmp = strcasecmp((char const   *)tname, (char const   *)curr->name);
    }
#line 344
    if (tmp == 0) {
#line 346
      goto while_break;
    }
#line 342
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (curr);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
bool exists_in_tic_vocab(char *tname , tic_hdr_t *tic_vocab ) 
{ 
  tic_hdr_t *found ;
  bool retval ;

  {
  {
#line 372
  retval = (bool )0;
#line 374
  found = lookup_tic_entry(tname, tic_vocab);
  }
#line 375
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 377
    retval = (bool )-1;
  }
#line 380
  return (retval);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
bool create_split_alias(char *new_name , char *old_name , tic_hdr_t **src_vocab ,
                        tic_hdr_t **dest_vocab ) 
{ 
  tic_hdr_t *found ;
  bool retval ;
  bool trace_it ;
  bool old_is_global ;
  int tmp ;

  {
  {
#line 446
  retval = (bool )0;
#line 448
  found = lookup_tic_entry(old_name, *src_vocab);
  }
#line 449
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 451
    trace_it = found->tracing;
#line 452
    if (! trace_it) {
      {
#line 454
      trace_it = is_on_trace_list(new_name);
      }
    }
#line 456
    if (trace_it) {
#line 458
      if ((unsigned long )src_vocab != (unsigned long )dest_vocab) {
#line 458
        tmp = -1;
      } else {
#line 458
        tmp = 0;
      }
      {
#line 458
      old_is_global = (bool )tmp;
#line 459
      trace_creation(found, new_name, old_is_global);
      }
    }
    {
#line 461
    warn_if_duplicate(new_name);
#line 463
    *dest_vocab = make_tic_entry(new_name, found->funct, found->pfield.deflt_elem,
                                 found->fword_defr, 0, found->is_token, found->ign_func,
                                 trace_it, dest_vocab);
#line 471
    retval = (bool )-1;
    }
  }
#line 474
  return (retval);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
bool create_tic_alias(char *new_name , char *old_name , tic_hdr_t **tic_vocab ) 
{ 
  bool tmp ;

  {
  {
#line 509
  tmp = create_split_alias(new_name, old_name, tic_vocab, tic_vocab);
  }
#line 509
  return (tmp);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
bool handle_tic_vocab(char *tname , tic_hdr_t *tic_vocab ) 
{ 
  bool retval ;

  {
  {
#line 542
  retval = (bool )0;
#line 544
  tic_found = lookup_tic_entry(tname, tic_vocab);
  }
#line 545
  if ((unsigned long )tic_found != (unsigned long )((void *)0)) {
    {
#line 547
    (*(tic_found->funct))(tic_found->pfield);
#line 548
    retval = (bool )-1;
    }
  }
#line 551
  return (retval);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/ticvocab.c"
void reset_tic_vocab(tic_hdr_t **tic_vocab , tic_hdr_t *reset_position ) 
{ 
  tic_hdr_t *next_t ;

  {
#line 587
  next_t = *tic_vocab;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! ((unsigned long )next_t != (unsigned long )reset_position)) {
#line 588
      goto while_break;
    }
    {
#line 590
    next_t = (*tic_vocab)->next;
#line 592
    free((void *)(*tic_vocab)->name);
    }
#line 593
    if ((*tic_vocab)->pfld_size != 0) {
      {
#line 595
      free((void *)(*tic_vocab)->pfield.chr_ptr);
      }
    }
    {
#line 597
    free((void *)*tic_vocab);
#line 598
    *tic_vocab = next_t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/strsubvocab.c"
void add_str_sub_entry(char *ename , char *subst_str , str_sub_vocab_t **str_sub_vocab ) 
{ 
  str_sub_vocab_t *new_entry ;
  void *tmp ;

  {
  {
#line 114
  tmp = safe_malloc(sizeof(str_sub_vocab_t ), (char *)"adding str_sub_entry");
#line 114
  new_entry = (str_sub_vocab_t *)tmp;
#line 115
  new_entry->name = (u8 *)ename;
#line 116
  new_entry->alias = (u8 *)subst_str;
#line 117
  new_entry->next = *str_sub_vocab;
#line 119
  *str_sub_vocab = new_entry;
  }
#line 121
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/strsubvocab.c"
str_sub_vocab_t *lookup_str_sub(char *tname , str_sub_vocab_t *str_sub_vocab ) 
{ 
  str_sub_vocab_t *curr ;
  str_sub_vocab_t *retval ;
  int tmp ;

  {
#line 144
  retval = (str_sub_vocab_t *)((void *)0);
#line 146
  curr = str_sub_vocab;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 146
      goto while_break;
    }
    {
#line 148
    tmp = strcasecmp((char const   *)tname, (char const   *)curr->name);
    }
#line 148
    if (tmp == 0) {
#line 150
      retval = curr;
#line 151
      goto while_break;
    }
#line 146
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (retval);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/strsubvocab.c"
bool exists_in_str_sub(char *tname , str_sub_vocab_t *str_sub_vocab ) 
{ 
  bool retval ;
  str_sub_vocab_t *found ;

  {
  {
#line 175
  retval = (bool )0;
#line 176
  found = (str_sub_vocab_t *)((void *)0);
#line 178
  found = lookup_str_sub(tname, str_sub_vocab);
  }
#line 179
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 181
    retval = (bool )-1;
  }
#line 183
  return (retval);
}
}
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.h"
bool ibm_locals ;
#line 110
bool ibm_locals_legacy_separator ;
#line 111
bool ibm_legacy_separator_message ;
#line 112
bool enable_abort_quote ;
#line 113
bool sun_style_abort_quote ;
#line 114
bool abort_quote_throw ;
#line 115
bool string_remark_escape ;
#line 116
bool hex_remark_escape ;
#line 117
bool c_style_string_escape ;
#line 118
bool always_headers ;
#line 119
bool always_external ;
#line 120
bool verbose_dup_warning ;
#line 121
bool obso_fcode_warning ;
#line 123
bool big_end_pci_image_rev ;
#line 125
bool force_tokens_case ;
#line 126
bool force_lower_case_tokens ;
#line 127
bool allow_ret_stk_interp ;
#line 140
void show_all_cl_flag_settings(bool from_src ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool ibm_locals  =    (bool )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool ibm_locals_legacy_separator  =    (bool )-1;
#line 94 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool ibm_legacy_separator_message  =    (bool )-1;
#line 95 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool enable_abort_quote  =    (bool )-1;
#line 96 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool sun_style_abort_quote  =    (bool )-1;
#line 97 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool abort_quote_throw  =    (bool )-1;
#line 98 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool string_remark_escape  =    (bool )-1;
#line 99 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool hex_remark_escape  =    (bool )-1;
#line 100 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool c_style_string_escape  =    (bool )-1;
#line 101 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool always_headers  =    (bool )0;
#line 102 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool always_external  =    (bool )0;
#line 103 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool verbose_dup_warning  =    (bool )-1;
#line 104 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool obso_fcode_warning  =    (bool )-1;
#line 105 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool trace_conditionals  =    (bool )0;
#line 106 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool big_end_pci_image_rev  =    (bool )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool allow_ret_stk_interp  =    (bool )-1;
#line 110 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool clflag_help  =    (bool )0;
#line 120 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool force_tokens_case  =    (bool )0;
#line 121 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool force_lower_case_tokens  =    (bool )0;
#line 129 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool upper_case_tokens  =    (bool )0;
#line 130 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool lower_case_tokens  =    (bool )0;
#line 131 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool was_upper_case_tk  =    (bool )0;
#line 132 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool was_lower_case_tk  =    (bool )0;
#line 143 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool cl_flag_change  =    (bool )0;
#line 145 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static cl_flag_t const   cl_flags_list[19]  = 
#line 145
  {      {(char *)"Local-Values", & ibm_locals, (char *)"\t\t", (char *)"Support IBM-style Local Values (\"LV\"s)"}, 
        {(char *)"LV-Legacy-Separator",
      & ibm_locals_legacy_separator, (char *)"\t", (char *)"Allow Semicolon for Local Values Separator (\"Legacy\")"}, 
        {(char *)"LV-Legacy-Message",
      & ibm_legacy_separator_message, (char *)"\t", (char *)"Display a Message when Semicolon is used as the Local Values Separator"}, 
        {(char *)"ABORT-Quote",
      & enable_abort_quote, (char *)"\t\t", (char *)"Allow ABORT\" macro"}, 
        {(char *)"Sun-ABORT-Quote", & sun_style_abort_quote, (char *)"\t\t", (char *)"ABORT\" with implicit IF ... THEN"}, 
        {(char *)"ABORT-Quote-Throw",
      & abort_quote_throw, (char *)"\t", (char *)"Use -2 THROW in an Abort\" phrase, rather than ABORT"}, 
        {(char *)"String-remark-escape",
      & string_remark_escape, (char *)"\t", (char *)"Allow \"\\ (Quote-Backslash) to interrupt string parsing"}, 
        {(char *)"Hex-remark-escape",
      & hex_remark_escape, (char *)"\t", (char *)"Allow \\ (Backslash) to interrupt hex-sequence parsing within a string"}, 
        {(char *)"C-Style-string-escape",
      & c_style_string_escape, (char *)"\t", (char *)"Allow \\n \\t and \\xx\\ for special chars in string parsing"}, 
        {(char *)"Always-Headers",
      & always_headers, (char *)"\t\t", (char *)"Override \"headerless\" and force to \"headers\""}, 
        {(char *)"Always-External",
      & always_external, (char *)"\t\t", (char *)"Override \"headerless\" and \"headers\" and force to \"external\""}, 
        {(char *)"Warn-if-Duplicate",
      & verbose_dup_warning, (char *)"\t", (char *)"Display a WARNING message when a duplicate definition is made"}, 
        {(char *)"Obsolete-FCode-Warning",
      & obso_fcode_warning, (char *)"\t", (char *)"Display a WARNING message when an \"obsolete\" (per the Standard) FCode is used"}, 
        {(char *)"Trace-Conditionals",
      & trace_conditionals, (char *)"\t", (char *)"Display ADVISORY messages about the state of Conditional Tokenization"}, 
        {(char *)"Upper-Case-Token-Names",
      & upper_case_tokens, (char *)"\t", (char *)"Convert Token-Names to UPPER-Case"}, 
        {(char *)"Lower-Case-Token-Names",
      & lower_case_tokens, (char *)"\t", (char *)"Convert Token-Names to lower-Case"}, 
        {(char *)"Big-End-PCI-Rev-Level",
      & big_end_pci_image_rev, (char *)"\t", (char *)"Save the Vendor\'s Rev Level field of the PCI Header in Big-Endian format"}, 
        {(char *)"Ret-Stk-Interp",
      & allow_ret_stk_interp, (char *)"\t\t", (char *)"Allow Return-Stack Operations during Interpretation"}, 
        {(char *)"help",
      & clflag_help, (char *)"\t\t\t", (char *)"Print this \"Help\" message for the Special-Feature Flags"}};
#line 261 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static int const   number_of_cl_flags  =    (int const   )(sizeof(cl_flags_list) / sizeof(cl_flag_t ));
#line 278 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static long cl_flags_bit_map  ;
#line 326
static void adjust_case_flags(void) ;
#line 326 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool *case_tokens[2]  = {      & upper_case_tokens,      & lower_case_tokens};
#line 327 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool *was_case_tk[2]  = {      & was_upper_case_tk,      & was_lower_case_tk};
#line 324 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static void adjust_case_flags(void) 
{ 
  int the_one ;
  int the_other ;

  {
#line 328
  the_one = 0;
#line 329
  the_other = 1;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (the_one < 2)) {
#line 331
      goto while_break;
    }
#line 334
    if ((int )*(case_tokens[the_one]) != (int )*(was_case_tk[the_one])) {
#line 336
      if (*(case_tokens[the_one])) {
#line 339
        *(case_tokens[the_other]) = (bool )0;
#line 341
        force_tokens_case = (bool )-1;
      } else {
#line 344
        force_tokens_case = (bool )0;
      }
#line 346
      if (force_tokens_case) {
#line 348
        force_lower_case_tokens = lower_case_tokens;
      }
#line 350
      goto while_break;
    }
#line 331
    the_one ++;
#line 331
    the_other --;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
static bool first_err_msg  =    (bool )-1;
#line 406 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
bool set_cl_flag(char *flag_name , bool from_src ) 
{ 
  bool retval ;
  int indx ;
  bool flagval ;
  char *compar ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char const   *msg_txt ;

  {
  {
#line 408
  retval = (bool )-1;
#line 410
  was_upper_case_tk = upper_case_tokens;
#line 411
  was_lower_case_tk = lower_case_tokens;
#line 413
  tmp___2 = strlen((char const   *)flag_name);
  }
#line 413
  if (tmp___2 > 3UL) {
    {
#line 416
    flagval = (bool )-1;
#line 417
    compar = flag_name;
#line 419
    tmp = strncasecmp((char const   *)flag_name, "no", (size_t )2);
    }
#line 419
    if (tmp == 0) {
#line 421
      flagval = (bool )0;
#line 422
      compar += 2;
    }
#line 424
    indx = 0;
    {
#line 424
    while (1) {
      while_continue: /* CIL Label */ ;
#line 424
      if (! (indx < (int )number_of_cl_flags)) {
#line 424
        goto while_break;
      }
      {
#line 426
      tmp___1 = strcasecmp((char const   *)compar, (char const   *)cl_flags_list[indx].clflag_name);
      }
#line 426
      if (tmp___1 == 0) {
#line 428
        retval = (bool )0;
#line 429
        *(cl_flags_list[indx].flag_var) = flagval;
#line 432
        if (indx != (int )(number_of_cl_flags - 1)) {
#line 434
          cl_flag_change = (bool )-1;
        }
#line 436
        if (from_src) {
#line 438
          if (flagval) {
#line 438
            tmp___0 = "En";
          } else {
#line 438
            tmp___0 = "Dis";
          }
          {
#line 438
          tokenization_error(65536, (char *)"%sabling:  %s\n", tmp___0, cl_flags_list[indx].clflag_expln);
          }
        }
#line 442
        goto while_break;
      }
#line 424
      indx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 447
  if (retval) {
#line 449
    msg_txt = "Unknown Special-Feature Flag:  %s\n";
#line 450
    if (from_src) {
      {
#line 452
      tokenization_error(67108864, (char *)msg_txt, flag_name);
      }
    } else {
#line 454
      if (first_err_msg) {
        {
#line 456
        printf((char const   */* __restrict  */)"\n");
#line 457
        first_err_msg = (bool )0;
        }
      }
      {
#line 459
      printf((char const   */* __restrict  */)msg_txt, flag_name);
      }
    }
  }
  {
#line 463
  adjust_case_flags();
  }
#line 465
  return (retval);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
void show_all_cl_flag_settings(bool from_src ) 
{ 
  char const   *hdr_txt ;
  int indx ;
  char const   *tmp ;
  struct _IO_FILE *tmp___0 ;

  {
#line 507
  hdr_txt = "Special-Feature Flag settings:";
#line 510
  if (from_src) {
    {
#line 512
    tokenization_error(2048, (char *)hdr_txt);
    }
  } else {
    {
#line 514
    printf((char const   */* __restrict  */)"\n%s\n", hdr_txt);
    }
  }
#line 517
  indx = 0;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! (indx < (int )(number_of_cl_flags - 1))) {
#line 517
      goto while_break;
    }
#line 519
    if (*(cl_flags_list[indx].flag_var)) {
#line 519
      tmp = "  ";
    } else {
#line 519
      tmp = "No";
    }
#line 519
    if (from_src) {
#line 519
      tmp___0 = stderr;
    } else {
#line 519
      tmp___0 = stdout;
    }
    {
#line 519
    fprintf((FILE */* __restrict  */)tmp___0, (char const   */* __restrict  */)"\t%s%s\n",
            tmp, cl_flags_list[indx].clflag_name);
#line 517
    indx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  if (from_src) {
    {
#line 524
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 525
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
void list_cl_flag_settings(void) 
{ 


  {
#line 551
  if (cl_flag_change) {
    {
#line 553
    show_all_cl_flag_settings((bool )0);
    }
  }
#line 555
  return;
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
void list_cl_flag_names(void) 
{ 
  int indx ;

  {
  {
#line 581
  printf((char const   */* __restrict  */)"Valid Special-Feature Flags are:\n");
#line 582
  indx = 0;
  }
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! (indx < (int )number_of_cl_flags)) {
#line 582
      goto while_break;
    }
    {
#line 584
    printf((char const   */* __restrict  */)"\t%s\n", cl_flags_list[indx].clflag_name);
#line 582
    indx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return;
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
void cl_flags_help(void) 
{ 
  int indx ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 633
  if (cl_flag_change) {
#line 633
    tmp = "Setting";
  } else {
#line 633
    tmp = "Default";
  }
  {
#line 633
  printf((char const   */* __restrict  */)"\nSpecial-Feature Flags usage:\n  -f   FlagName   to enable the feature associated with FlagName,\nor\n  -f noFlagName   to disable the feature.\n\n%s   Flag-Name\t\t  Feature:\n\n",
         tmp);
#line 641
  indx = 0;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (indx < (int )number_of_cl_flags)) {
#line 641
      goto while_break;
    }
#line 643
    if (*(cl_flags_list[indx].flag_var)) {
#line 643
      tmp___0 = "  ";
    } else {
#line 643
      tmp___0 = "no";
    }
    {
#line 643
    printf((char const   */* __restrict  */)"  %s    %s%s%s\n", tmp___0, cl_flags_list[indx].clflag_name,
           cl_flags_list[indx].clflag_tabs, cl_flags_list[indx].clflag_expln);
#line 641
    indx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  return;
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
void save_cl_flags(void) 
{ 
  int indx ;
  long moving_bit ;

  {
#line 684
  moving_bit = 1L;
#line 686
  cl_flags_bit_map = 0L;
#line 687
  indx = 0;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (indx < (int )(number_of_cl_flags - 1))) {
#line 687
      goto while_break;
    }
#line 689
    if (*(cl_flags_list[indx].flag_var)) {
#line 691
      cl_flags_bit_map |= moving_bit;
    }
#line 693
    moving_bit <<= 1;
#line 687
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 695
  return;
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/clflags.c"
void reset_cl_flags(void) 
{ 
  int indx ;
  long moving_bit ;

  {
#line 727
  moving_bit = 1L;
#line 729
  indx = 0;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (indx < (int )(number_of_cl_flags - 1))) {
#line 729
      goto while_break;
    }
#line 731
    if (cl_flags_bit_map & moving_bit) {
#line 731
      *(cl_flags_list[indx].flag_var) = (bool )-1;
    } else {
#line 731
      *(cl_flags_list[indx].flag_var) = (bool )0;
    }
#line 733
    moving_bit <<= 1;
#line 729
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.h"
long *dstack  ;
#line 61
void dpush(long data ) ;
#line 63
long dget(void) ;
#line 65
void clear_stack(void) ;
#line 68
bool min_stack_depth(int mindep ) ;
#line 69
long stackdepth(void) ;
#line 70
void swap(void) ;
#line 71
void two_swap(void) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
static long *startdstack  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
static long *enddstack  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
void clear_stack(void) 
{ 


  {
#line 71
  dstack = enddstack;
#line 72
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
void init_stack(void) 
{ 
  void *tmp ;

  {
  {
#line 78
  tmp = safe_malloc(1024UL * sizeof(long ), (char *)"initting stack");
#line 78
  startdstack = (long *)tmp;
#line 79
  enddstack = startdstack + 1024;
#line 80
  dstack = enddstack;
  }
#line 81
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
static void stackerror(bool stat___0 ) 
{ 
  char const   *tmp ;

  {
#line 91
  if (stat___0) {
#line 91
    tmp = "under";
  } else {
#line 91
    tmp = "over";
  }
  {
#line 91
  tokenization_error(67108864, (char *)"stack %sflow at or near  %s \n", tmp, statbuf);
  }
#line 93
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
bool min_stack_depth(int mindep ) 
{ 
  bool retval ;
  long *stack_result ;

  {
#line 101
  retval = (bool )-1;
#line 104
  stack_result = dstack + mindep;
#line 117
  if ((unsigned long )stack_result > (unsigned long )enddstack) {
    {
#line 119
    retval = (bool )0;
#line 120
    stackerror((bool )-1);
    }
  }
#line 123
  return (retval);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
static bool room_on_stack_for(int newdep ) 
{ 
  bool retval ;
  long *stack_result ;

  {
#line 131
  retval = (bool )-1;
#line 134
  stack_result = dstack - newdep;
#line 137
  if ((unsigned long )stack_result < (unsigned long )startdstack) {
    {
#line 139
    retval = (bool )0;
#line 140
    stackerror((bool )0);
    }
  }
#line 143
  return (retval);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
void dpush(long data ) 
{ 
  bool tmp ;

  {
  {
#line 151
  tmp = room_on_stack_for(1);
  }
#line 151
  if (tmp) {
#line 153
    dstack --;
#line 154
    *dstack = data;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
long dpop(void) 
{ 
  long val ;
  bool tmp ;

  {
  {
#line 160
  val = 0L;
#line 164
  tmp = min_stack_depth(1);
  }
#line 164
  if (tmp) {
#line 166
    val = *dstack;
#line 167
    dstack ++;
  }
#line 169
  return (val);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
long dget(void) 
{ 
  long val ;
  bool tmp ;

  {
  {
#line 174
  val = 0L;
#line 175
  tmp = min_stack_depth(1);
  }
#line 175
  if (tmp) {
#line 177
    val = *dstack;
  }
#line 179
  return (val);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
long stackdepth(void) 
{ 
  long depth ;

  {
#line 186
  depth = enddstack - dstack;
#line 198
  return (depth);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
void swap(void) 
{ 
  long nos_temp ;
  bool tmp ;

  {
  {
#line 204
  tmp = min_stack_depth(2);
  }
#line 204
  if (tmp) {
#line 206
    nos_temp = *(dstack + 1);
#line 207
    *(dstack + 1) = *(dstack + 0);
#line 208
    *(dstack + 0) = nos_temp;
  }
#line 210
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/stack.c"
void two_swap(void) 
{ 
  long two_deep ;
  long three_deep ;
  bool tmp ;

  {
  {
#line 215
  tmp = min_stack_depth(4);
  }
#line 215
  if (tmp) {
#line 217
    two_deep = *(dstack + 2);
#line 218
    three_deep = *(dstack + 3);
#line 219
    *(dstack + 2) = *(dstack + 0);
#line 220
    *(dstack + 3) = *(dstack + 1);
#line 221
    *(dstack + 1) = three_deep;
#line 222
    *(dstack + 0) = two_deep;
  }
#line 224
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
void emit_fcode(u16 tok ) ;
#line 116
void emit_string(u8 *string , int cnt ) ;
#line 117
void emit_fcodehdr(char const   *starter_name ) ;
#line 118
void finish_fcodehdr(void) ;
#line 119
void emit_pcihdr(void) ;
#line 120
void finish_pcihdr(void) ;
#line 123
void emit_literal(u32 num ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/vocabfuncts.h"
bool define_token ;
#line 60
tic_hdr_t *lookup_core_word(char *tname ) ;
#line 61
bool create_core_alias(char *new_name , char *old_name ) ;
#line 63
void enter_global_scope(void) ;
#line 64
void resume_device_scope(void) ;
#line 66
tic_hdr_t *lookup_current(char *tname ) ;
#line 68
tic_hdr_t *lookup_in_dev_node(char *tname ) ;
#line 69
void add_to_current(char *name , long fc_token , fwtoken definer ) ;
#line 72
void hide_last_colon(void) ;
#line 73
void reveal_last_colon(void) ;
#line 74
bool create_current_alias(char *new_name , char *old_name ) ;
#line 77
tic_hdr_t *lookup_token(char *tname ) ;
#line 78
bool entry_is_token(tic_hdr_t *test_entry ) ;
#line 79
void token_entry_warning(tic_hdr_t *t_entry ) ;
#line 81
tic_hdr_t *lookup_shared_word(char *tname ) ;
#line 85
void reset_normal_vocabs(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
u8 base ;
#line 52
bool pci_is_last_image ;
#line 53
u16 pci_image_rev ;
#line 54
u16 pci_vpd ;
#line 59
bool in_tokz_esc ;
#line 60
bool incolon ;
#line 61
bool haveend ;
#line 69
headeredness hdr_flag ;
#line 72 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
int lastcolon  ;
#line 74
char *last_colon_defname ;
#line 75
char *last_colon_filename ;
#line 76 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
unsigned int last_colon_lineno  ;
#line 77
bool report_multiline ;
#line 78 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.h"
unsigned int last_colon_abs_token_no  ;
#line 81
char *in_tkz_esc_mode ;
#line 82
char *wh_defined ;
#line 93
void fcode_ender(void) ;
#line 95
bool skip_until(char lim_ch ) ;
#line 96
void push_source(void (*res_func)() , void *res_parm , bool file_chg ) ;
#line 99
bool get_rest_of_line(void) ;
#line 100
void warn_unterm(int severity , char *something , unsigned int saved_lineno ) ;
#line 103
void warn_if_multiline(char *something , unsigned int start_lineno ) ;
#line 104
void user_message(tic_param_t pfield ) ;
#line 105
void skip_user_message(tic_param_t pfield ) ;
#line 106
bool get_number(long *result ) ;
#line 109
void process_remark(tic_param_t pfield ) ;
#line 110
bool filter_comments(u8 *inword ) ;
#line 113
bool word_exists(char *stat_name , char **where_pt1 , char **where_pt2 ) ;
#line 116
void check_name_length(long wlen ) ;
#line 117
bool definer_name(fwtoken definer , char **reslt_ptr ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.h"
char *strlower(char *strung ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.h"
bool create_tokz_esc_alias(char *new_name , char *old_name ) ;
#line 43
void enter_tokz_esc(void) ;
#line 44
tic_hdr_t *lookup_tokz_esc(char *name ) ;
#line 45
void reset_tokz_esc(void) ;
#line 46
void pop_next_fcode(void) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.h"
void trace_create_failure(char *new_name , char *old_name , u16 fc_tokn ) ;
#line 62
void traced_name_error(char *trace_name ) ;
#line 63
void invoking_traced_name(tic_hdr_t *trace_entry ) ;
#line 64
void handle_invocation(tic_hdr_t *trace_entry ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.h"
void declare_locals(bool ignoring ) ;
#line 41
tic_hdr_t *lookup_local(char *lname ) ;
#line 42
bool exists_as_local(char *stat_name ) ;
#line 43
bool create_local_alias(char *new_name , char *old_name ) ;
#line 44
void assign_local(void) ;
#line 45
void finish_locals(void) ;
#line 46
void forget_locals(void) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
u8 *statbuf  =    (u8 *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
u8 base  =    (u8 )10;
#line 73 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool pci_is_last_image  =    (bool )-1;
#line 74 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
u16 pci_image_rev  =    (u16 )1;
#line 75 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
u16 pci_vpd  =    (u16 )0;
#line 79 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool offs16  =    (bool )-1;
#line 80 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool in_tokz_esc  =    (bool )0;
#line 81 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool incolon  =    (bool )0;
#line 82 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool haveend  =    (bool )0;
#line 83 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
int do_loop_depth  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
headeredness hdr_flag  =    (headeredness )0;
#line 92 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
char *last_colon_defname  =    (char *)((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
char *last_colon_filename  =    (char *)((void *)0);
#line 95 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool report_multiline  =    (bool )-1;
#line 99 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
char *in_tkz_esc_mode  =    (char *)"in Tokenizer-Escape mode.\n";
#line 100 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
char *wh_defined  =    (char *)", which is defined as a ";
#line 105 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static u16 last_colon_fcode  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool do_not_overload  =    (bool )-1;
#line 109 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool got_until_eof  =    (bool )0;
#line 111 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static unsigned int last_colon_do_depth  =    0U;
#line 115 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool is_instance  =    (bool )0;
#line 116 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static char *instance_filename  =    (char *)((void *)0);
#line 117 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static unsigned int instance_lineno  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool fcode_started  =    (bool )0;
#line 119 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool first_fc_starter  =    (bool )-1;
#line 122 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool need_to_pop_source  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static int ret_stk_depth  =    0;
#line 131 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool dev_change_instance_warning  =    (bool )-1;
#line 134 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool instance_definer_gap  =    (bool )0;
#line 162 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool skip_ws(void) 
{ 
  bool retval ;
  char ch_tmp ;

  {
#line 164
  retval = (bool )-1;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! ((unsigned long )pc < (unsigned long )end)) {
#line 167
      goto while_break;
    }
#line 169
    ch_tmp = (char )*pc;
#line 170
    if ((int )ch_tmp != 9) {
#line 170
      if ((int )ch_tmp != 32) {
#line 170
        if ((int )ch_tmp != 10) {
#line 172
          retval = (bool )0;
#line 173
          goto while_break;
        }
      }
    }
#line 175
    if ((int )ch_tmp == 10) {
#line 175
      lineno ++;
    }
#line 167
    pc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (retval);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool skip_until(char lim_ch ) 
{ 
  bool retval ;
  char ch_tmp ;

  {
#line 209
  retval = (bool )-1;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )pc < (unsigned long )end)) {
#line 212
      goto while_break;
    }
#line 214
    ch_tmp = (char )*pc;
#line 215
    if ((int )ch_tmp == (int )lim_ch) {
#line 217
      retval = (bool )0;
#line 218
      goto while_break;
    }
#line 220
    if ((int )ch_tmp == 10) {
#line 220
      lineno ++;
    }
#line 212
    pc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (retval);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static long get_until(char needle ) 
{ 
  u8 *safe ;
  unsigned long len ;
  int tmp ;

  {
  {
#line 277
  len = 0UL;
#line 279
  safe = pc;
#line 281
  got_until_eof = skip_until(needle);
#line 283
  len = (unsigned long )(pc - safe);
  }
#line 284
  if (len >= 1024UL) {
    {
#line 286
    tokenization_error(67108864, (char *)"get_until buffer overflow.  Max is %d.\n",
                       1023);
#line 288
    len = 1023UL;
    }
  }
  {
#line 291
  memcpy((void */* __restrict  */)statbuf, (void const   */* __restrict  */)safe,
         len);
#line 292
  *(statbuf + len) = (u8 )0;
  }
#line 294
  if (got_until_eof) {
#line 294
    tmp = 0;
  } else {
#line 294
    tmp = -1;
  }
#line 294
  if (tmp) {
#line 296
    if ((int )needle != 10) {
#line 296
      pc ++;
    }
  }
#line 298
  return ((long )len);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static source_state_t *saved_source  =    (source_state_t *)((void *)0);
#line 391 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void push_source(void (*res_func)() , void *res_parm , bool file_chg ) 
{ 
  source_state_t *new_sav_src ;
  void *tmp ;

  {
  {
#line 395
  tmp = safe_malloc(sizeof(source_state_t ), (char *)"pushing Source state");
#line 395
  new_sav_src = (source_state_t *)tmp;
#line 397
  new_sav_src->next = saved_source;
#line 398
  new_sav_src->old_start = start;
#line 399
  new_sav_src->old_pc = pc;
#line 400
  new_sav_src->old_end = end;
#line 401
  new_sav_src->old_iname = iname;
#line 402
  new_sav_src->old_lineno = lineno;
#line 403
  new_sav_src->pause_before_pop = file_chg;
#line 404
  new_sav_src->sav_rep_multlin = report_multiline;
#line 405
  new_sav_src->resump_func = res_func;
#line 406
  new_sav_src->resump_param = res_parm;
#line 408
  saved_source = new_sav_src;
  }
#line 409
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void drop_source(void) 
{ 
  source_state_t *former_sav_src ;

  {
  {
#line 437
  former_sav_src = saved_source;
#line 439
  saved_source = saved_source->next;
#line 440
  free((void *)former_sav_src);
  }
#line 441
  return;
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool pop_source(void) 
{ 
  bool retval ;

  {
#line 486
  retval = (bool )-1;
#line 488
  if ((unsigned long )saved_source != (unsigned long )((void *)0)) {
#line 490
    retval = (bool )0;
#line 491
    if (need_to_pop_source) {
#line 493
      need_to_pop_source = (bool )0;
    } else
#line 495
    if (saved_source->pause_before_pop) {
#line 497
      need_to_pop_source = (bool )-1;
#line 498
      return (retval);
    }
#line 502
    if ((unsigned long )saved_source->resump_func != (unsigned long )((void *)0)) {
      {
#line 504
      (*(saved_source->resump_func))(saved_source->resump_param);
      }
    }
    {
#line 506
    report_multiline = saved_source->sav_rep_multlin;
#line 507
    lineno = saved_source->old_lineno;
#line 508
    iname = saved_source->old_iname;
#line 509
    end = saved_source->old_end;
#line 510
    pc = saved_source->old_pc;
#line 511
    start = saved_source->old_start;
#line 513
    drop_source();
    }
  }
#line 515
  return (retval);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
long get_word(void) 
{ 
  size_t len ;
  u8 *str ;
  bool keep_skipping ;
  bool pop_result ;

  {
#line 599
  if (need_to_pop_source) {
    {
#line 601
    pop_result = pop_source();
    }
  }
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 605
    keep_skipping = skip_ws();
    }
#line 606
    if (keep_skipping) {
      {
#line 608
      pop_result = pop_source();
      }
#line 609
      if (pop_result) {
#line 609
        goto _L;
      } else
#line 609
      if (need_to_pop_source) {
        _L: /* CIL Label */ 
#line 611
        *(statbuf + 0) = (u8 )0;
#line 612
        if (pop_result) {
#line 614
          return (-1L);
        }
#line 616
        return (0L);
      }
    }
#line 604
    if (! keep_skipping) {
#line 604
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  str = pc;
  {
#line 622
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 622
    if ((unsigned long )str < (unsigned long )end) {
#line 622
      if (*str) {
#line 622
        if ((int )*str != 10) {
#line 622
          if ((int )*str != 9) {
#line 622
            if (! ((int )*str != 32)) {
#line 622
              goto while_break___0;
            }
          } else {
#line 622
            goto while_break___0;
          }
        } else {
#line 622
          goto while_break___0;
        }
      } else {
#line 622
        goto while_break___0;
      }
    } else {
#line 622
      goto while_break___0;
    }
#line 623
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 625
  len = (size_t )(str - pc);
#line 626
  if (len >= 1024UL) {
    {
#line 628
    tokenization_error((-0x7FFFFFFF-1), (char *)"get_word buffer overflow.  Max is %d.",
                       1023);
    }
  }
  {
#line 632
  memcpy((void */* __restrict  */)statbuf, (void const   */* __restrict  */)pc, len);
#line 633
  *(statbuf + len) = (u8 )0;
#line 639
  pc += len;
#line 640
  abs_token_no ++;
  }
#line 641
  return ((long )len);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool get_word_in_line(char *func_nam ) 
{ 
  long wlen ;
  bool retval ;
  u8 *save_pc ;
  unsigned int save_lineno ;
  unsigned int save_abs_token_no ;
  char func_cpy[41] ;
  char *tmp ;

  {
#line 681
  retval = (bool )-1;
#line 682
  save_pc = pc;
#line 683
  save_lineno = lineno;
#line 684
  save_abs_token_no = abs_token_no;
#line 690
  if ((unsigned long )func_nam != (unsigned long )((void *)0)) {
    {
#line 692
    strncpy((char */* __restrict  */)(func_cpy), (char const   */* __restrict  */)func_nam,
            (size_t )40);
#line 693
    func_cpy[40] = (char)0;
    }
  }
  {
#line 696
  wlen = get_word();
  }
#line 697
  if (lineno != save_lineno) {
#line 697
    goto _L;
  } else
#line 697
  if (wlen <= 0L) {
    _L: /* CIL Label */ 
#line 699
    abs_token_no = save_abs_token_no;
#line 700
    lineno = save_lineno;
#line 701
    pc = save_pc;
#line 702
    retval = (bool )0;
#line 703
    if ((unsigned long )func_nam != (unsigned long )((void *)0)) {
      {
#line 705
      tmp = strupper(func_cpy);
#line 705
      tokenization_error(67108864, (char *)"Operator %s expects its target on the same line\n",
                         tmp);
      }
    }
  }
#line 710
  return (retval);
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool get_rest_of_line(void) 
{ 
  bool retval ;
  u8 *save_pc ;
  unsigned int save_lineno ;
  unsigned int save_abs_token_no ;
  long wlen ;
  long tmp ;
  int tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 744
  retval = (bool )0;
#line 745
  save_pc = pc;
#line 746
  save_lineno = lineno;
#line 747
  save_abs_token_no = abs_token_no;
#line 749
  tmp___2 = skip_ws();
  }
#line 749
  if (tmp___2) {
#line 749
    tmp___1 = 0;
  } else {
#line 749
    tmp___1 = -1;
  }
#line 749
  if (tmp___1) {
#line 751
    if (lineno == save_lineno) {
      {
#line 753
      tmp = get_until((char )'\n');
#line 753
      wlen = tmp;
      }
#line 754
      if (wlen > 0L) {
#line 754
        retval = (bool )-1;
      }
    } else {
#line 756
      abs_token_no = save_abs_token_no;
#line 757
      lineno = save_lineno;
#line 758
      pc = save_pc;
    }
  }
#line 761
  return (retval);
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool unterm_is_colon  =    (bool )0;
#line 810 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void warn_unterm(int severity , char *something , unsigned int saved_lineno ) 
{ 
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 812
  tmp = lineno;
#line 813
  lineno = saved_lineno;
#line 814
  if (unterm_is_colon) {
    {
#line 816
    tmp___0 = strupper(last_colon_defname);
#line 816
    tokenization_error(severity, (char *)"Unterminated %s of %s\n", something, tmp___0);
#line 818
    unterm_is_colon = (bool )0;
    }
  } else {
    {
#line 820
    tokenization_error(severity, (char *)"Unterminated %s", something);
#line 821
    in_last_colon((bool )-1);
    }
  }
#line 823
  lineno = tmp;
#line 824
  return;
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void warn_if_multiline(char *something , unsigned int start_lineno ) 
{ 


  {
#line 861
  if (report_multiline) {
#line 861
    if (start_lineno != lineno) {
      {
#line 863
      tokenization_error(2097152, (char *)"Multi-line %s, started", something);
#line 864
      where_started(iname, start_lineno);
      }
    }
  }
#line 866
  report_multiline = (bool )-1;
#line 867
  return;
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void string_remark(char *errmsg_txt ) 
{ 
  unsigned int sav_lineno ;
  bool eof ;
  bool tmp ;

  {
  {
#line 896
  sav_lineno = lineno;
#line 897
  tmp = skip_until((char )'\n');
#line 897
  eof = tmp;
  }
#line 898
  if (! eof) {
    {
#line 900
    eof = skip_ws();
    }
  }
#line 902
  if (eof) {
    {
#line 904
    warn_unterm(2097152, errmsg_txt, sav_lineno);
    }
  }
#line 907
  return;
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static long parse_number(u8 *start___0 , u8 **endptr , int lbase ) 
{ 
  long val ;
  bool negative ;
  int curr ;
  u8 *nptr ;

  {
#line 922
  val = 0L;
#line 923
  negative = (bool )0;
#line 925
  nptr = start___0;
#line 927
  curr = (int )*nptr;
#line 928
  if (curr == 45) {
#line 930
    negative = (bool )-1;
#line 931
    nptr ++;
  }
#line 934
  curr = (int )*nptr;
  {
#line 934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 934
    curr = (int )*nptr;
#line 934
    if (! curr) {
#line 934
      goto while_break;
    }
#line 935
    if (curr == 46) {
#line 936
      goto __Cont;
    }
#line 937
    if (curr >= 48) {
#line 937
      if (curr <= 57) {
#line 938
        curr -= 48;
      } else {
#line 937
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 939
    if (curr >= 97) {
#line 939
      if (curr <= 102) {
#line 940
        curr += -87;
      } else {
#line 939
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 941
    if (curr >= 65) {
#line 941
      if (curr <= 70) {
#line 942
        curr += -55;
      } else {
#line 944
        goto while_break;
      }
    } else {
#line 944
      goto while_break;
    }
#line 946
    if (curr >= lbase) {
#line 947
      goto while_break;
    }
#line 949
    val *= (long )lbase;
#line 950
    val += (long )curr;
    __Cont: /* CIL Label */ 
#line 934
    nptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  if (endptr) {
#line 960
    *endptr = nptr;
  }
#line 962
  if (negative) {
#line 964
    val = - val;
  }
#line 966
  return (val);
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void add_byte_to_string(u8 nu_byte , u8 **walk ) 
{ 


  {
#line 1002
  if (*walk - statbuf < 1024L) {
#line 1004
    *(*walk) = nu_byte;
  }
#line 1006
  (*walk) ++;
#line 1007
  return;
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void c_string_escape(u8 **walk ) 
{ 
  char c ;
  u8 val ;
  bool write_val ;
  long lval ;
  u8 *sav_pc ;

  {
#line 1059
  c = (char )*pc;
#line 1065
  write_val = (bool )-1;
  {
#line 1069
  if ((int )c == 110) {
#line 1069
    goto case_110;
  }
#line 1073
  if ((int )c == 116) {
#line 1073
    goto case_116;
  }
#line 1077
  goto switch_default;
  case_110: /* CIL Label */ 
#line 1071
  val = (u8 )'\n';
#line 1072
  goto switch_break;
  case_116: /* CIL Label */ 
#line 1075
  val = (u8 )'\t';
#line 1076
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1095
  sav_pc = pc;
#line 1096
  lval = parse_number(pc, & pc, (int )base);
#line 1097
  val = (u8 )lval;
  }
#line 1103
  if (lval > 255L) {
    {
#line 1105
    tokenization_error(2097152, (char *)"Numeric String after \\ overflows byte.  Using 0x%02x.\n",
                       (int )val);
    }
  }
#line 1110
  if ((unsigned long )pc == (unsigned long )sav_pc) {
#line 1117
    if ((unsigned long )pc >= (unsigned long )end) {
#line 1121
      write_val = (bool )0;
    } else
#line 1117
    if ((int )c == 34) {
#line 1121
      write_val = (bool )0;
    } else {
#line 1127
      if ((int )c > 32) {
#line 1127
        if ((int )c <= 126) {
          {
#line 1129
          tokenization_error(2097152, (char *)"Unrecognized character, %c, after \\ in string.  Using it literally.\n",
                             (int )c);
          }
        } else {
          {
#line 1134
          tokenization_error(2097152, (char *)"Unrecognized character, 0x%02x, after \\ in string.  Using it literally.\n",
                             (int )c);
          }
        }
      } else {
        {
#line 1134
        tokenization_error(2097152, (char *)"Unrecognized character, 0x%02x, after \\ in string.  Using it literally.\n",
                           (int )c);
        }
      }
#line 1139
      val = (u8 )c;
    }
  }
#line 1144
  if ((int )*pc == 34) {
#line 1146
    pc --;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1152
  if (write_val) {
    {
#line 1152
    add_byte_to_string(val, walk);
    }
  }
#line 1154
  return;
}
}
#line 1241 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool get_sequence(u8 **walk ) 
{ 
  int pv_indx ;
  bool retval ;
  bool ready_to_parse ;
  char next_ch ;
  char pval[3] ;
  unsigned short const   **tmp ;
  u8 val ;
  long tmp___0 ;
  u8 *tmp___1 ;

  {
#line 1243
  pv_indx = 0;
#line 1244
  retval = (bool )0;
#line 1245
  ready_to_parse = (bool )0;
#line 1252
  pval[2] = (char)0;
  {
#line 1254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1254
    if (! ((unsigned long )pc < (unsigned long )end)) {
#line 1254
      goto while_break;
    }
#line 1256
    next_ch = (char )*pc;
#line 1257
    if ((int )next_ch == 41) {
#line 1259
      retval = (bool )-1;
#line 1260
      goto while_break;
    }
#line 1262
    if (hex_remark_escape) {
#line 1264
      if ((int )next_ch == 92) {
        {
#line 1266
        string_remark((char *)"string hex-sequence remark");
        }
#line 1267
        goto while_continue;
      }
    }
    {
#line 1270
    tmp = __ctype_b_loc();
    }
#line 1270
    if ((int const   )*(*tmp + (int )next_ch) & 4096) {
#line 1272
      pval[pv_indx] = next_ch;
#line 1273
      if (pv_indx == 0) {
#line 1275
        pv_indx ++;
      } else {
#line 1277
        ready_to_parse = (bool )-1;
      }
    } else {
#line 1280
      if ((int )next_ch == 10) {
#line 1280
        lineno ++;
      }
#line 1281
      if (pv_indx != 0) {
#line 1283
        pval[1] = (char)0;
#line 1284
        ready_to_parse = (bool )-1;
      }
    }
#line 1287
    if (ready_to_parse) {
      {
#line 1289
      tmp___0 = parse_number((u8 *)(pval), (u8 **)((void *)0), 16);
#line 1289
      val = (u8 )tmp___0;
#line 1290
      tmp___1 = *walk;
#line 1290
      (*walk) ++;
#line 1290
      *tmp___1 = val;
#line 1294
      pv_indx = 0;
#line 1295
      ready_to_parse = (bool )0;
      }
    }
#line 1297
    pc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1302
  return (retval);
}
}
#line 1334 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static long get_string___0(bool pack_str ) 
{ 
  u8 *walk ;
  unsigned long len ;
  char c ;
  bool run ;
  unsigned long start_lineno ;

  {
#line 1339
  run = (bool )-1;
#line 1340
  start_lineno = (unsigned long )lineno;
#line 1349
  if ((int )*pc == 10) {
#line 1349
    lineno ++;
  }
#line 1350
  pc ++;
#line 1352
  got_until_eof = (bool )-1;
#line 1354
  walk = statbuf;
  {
#line 1355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1355
    if (! run) {
#line 1355
      goto while_break;
    }
#line 1356
    c = (char )*pc;
    {
#line 1359
    if ((int )c == 34) {
#line 1359
      goto case_34;
    }
#line 1438
    if ((int )c == 10) {
#line 1438
      goto case_10___0;
    }
#line 1443
    goto switch_default___0;
    case_34: /* CIL Label */ 
#line 1361
    pc ++;
#line 1363
    if ((unsigned long )pc >= (unsigned long )end) {
#line 1365
      run = (bool )0;
#line 1366
      got_until_eof = (bool )0;
#line 1367
      goto switch_break;
    }
#line 1370
    c = (char )*pc;
    {
#line 1373
    if ((int )c == 40) {
#line 1373
      goto case_40;
    }
#line 1378
    if ((int )c == 110) {
#line 1378
      goto case_110;
    }
#line 1381
    if ((int )c == 114) {
#line 1381
      goto case_114;
    }
#line 1384
    if ((int )c == 116) {
#line 1384
      goto case_116;
    }
#line 1387
    if ((int )c == 102) {
#line 1387
      goto case_102;
    }
#line 1390
    if ((int )c == 108) {
#line 1390
      goto case_108;
    }
#line 1393
    if ((int )c == 98) {
#line 1393
      goto case_98;
    }
#line 1396
    if ((int )c == 33) {
#line 1396
      goto case_33;
    }
#line 1399
    if ((int )c == 94) {
#line 1399
      goto case_94;
    }
#line 1407
    if ((int )c == 9) {
#line 1407
      goto case_9;
    }
#line 1407
    if ((int )c == 32) {
#line 1407
      goto case_9;
    }
#line 1413
    if ((int )c == 10) {
#line 1413
      goto case_10;
    }
#line 1417
    goto switch_default;
    case_40: /* CIL Label */ 
    {
#line 1374
    pc ++;
#line 1375
    run = get_sequence(& walk);
    }
#line 1376
    goto switch_break___0;
    case_110: /* CIL Label */ 
    {
#line 1379
    add_byte_to_string((u8 )'\n', & walk);
    }
#line 1380
    goto switch_break___0;
    case_114: /* CIL Label */ 
    {
#line 1382
    add_byte_to_string((u8 )'\r', & walk);
    }
#line 1383
    goto switch_break___0;
    case_116: /* CIL Label */ 
    {
#line 1385
    add_byte_to_string((u8 )'\t', & walk);
    }
#line 1386
    goto switch_break___0;
    case_102: /* CIL Label */ 
    {
#line 1388
    add_byte_to_string((u8 )'\f', & walk);
    }
#line 1389
    goto switch_break___0;
    case_108: /* CIL Label */ 
    {
#line 1391
    add_byte_to_string((u8 )'\n', & walk);
    }
#line 1392
    goto switch_break___0;
    case_98: /* CIL Label */ 
    {
#line 1394
    add_byte_to_string((u8 )8, & walk);
    }
#line 1395
    goto switch_break___0;
    case_33: /* CIL Label */ 
    {
#line 1397
    add_byte_to_string((u8 )7, & walk);
    }
#line 1398
    goto switch_break___0;
    case_94: /* CIL Label */ 
    {
#line 1400
    pc ++;
#line 1401
    add_byte_to_string((u8 )((int )*pc & 31), & walk);
    }
#line 1402
    goto switch_break___0;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1412
    pc ++;
    case_10: /* CIL Label */ 
#line 1414
    run = (bool )0;
#line 1415
    got_until_eof = (bool )0;
#line 1416
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1422
    if (string_remark_escape) {
#line 1424
      if ((int )c == 92) {
        {
#line 1426
        string_remark((char *)"string-escape remark");
#line 1431
        pc --;
        }
#line 1432
        goto switch_break___0;
      }
    }
    {
#line 1435
    add_byte_to_string((u8 )c, & walk);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1437
    goto switch_break;
    case_10___0: /* CIL Label */ 
#line 1442
    lineno ++;
    switch_default___0: /* CIL Label */ 
#line 1447
    if (c_style_string_escape) {
#line 1449
      if ((int )c == 92) {
        {
#line 1451
        pc ++;
#line 1452
        c_string_escape(& walk);
        }
#line 1453
        goto switch_break;
      }
    }
    {
#line 1456
    add_byte_to_string((u8 )c, & walk);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1459
    if (run) {
#line 1459
      pc ++;
    }
#line 1461
    if ((unsigned long )pc >= (unsigned long )end) {
#line 1463
      run = (bool )0;
#line 1464
      if (got_until_eof) {
        {
#line 1466
        warn_unterm(2097152, (char *)"string", (unsigned int )start_lineno);
#line 1468
        got_until_eof = (bool )0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1473
  warn_if_multiline((char *)"string", (unsigned int )start_lineno);
#line 1475
  len = (unsigned long )(walk - statbuf);
  }
#line 1476
  if (len >= 1024UL) {
    {
#line 1478
    tokenization_error(67108864, (char *)"get_string buffer overflow.  Max is %d\n.",
                       1023);
#line 1480
    len = 1023UL;
    }
  }
#line 1487
  if (pack_str) {
#line 1487
    if (len > 255UL) {
      {
#line 1489
      tokenization_error(2097152, (char *)"String length being truncated to %d.\n",
                         255);
#line 1491
      len = 255UL;
      }
    }
  }
#line 1493
  *(statbuf + len) = (u8 )0;
#line 1495
  return ((long )len);
}
}
#line 1540 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void handle_user_message(char delim , bool print_it ) 
{ 
  long wlen ;
  unsigned int start_lineno ;
  unsigned int multiline_start ;
  bool check_multiline ;
  char const   *ug_msg ;
  unsigned int tmp_lineno ;

  {
#line 1543
  start_lineno = lineno;
#line 1544
  multiline_start = lineno;
#line 1545
  check_multiline = (bool )0;
#line 1546
  ug_msg = "user-generated message";
#line 1548
  if ((int )delim == 34) {
    {
#line 1550
    wlen = get_string___0((bool )0);
    }
  } else {
#line 1561
    if ((int )delim == 10) {
#line 1563
      if ((int )*pc != 10) {
#line 1563
        pc ++;
      }
    } else {
#line 1565
      if ((int )*pc == 10) {
#line 1565
        lineno ++;
      }
#line 1566
      pc ++;
#line 1567
      multiline_start = lineno;
#line 1568
      check_multiline = (bool )-1;
    }
    {
#line 1570
    wlen = get_until(delim);
    }
  }
#line 1573
  if (print_it) {
    {
#line 1575
    tmp_lineno = lineno;
#line 1576
    lineno = start_lineno;
#line 1581
    tokenization_error(2048, (char *)statbuf);
#line 1582
    lineno = tmp_lineno;
    }
  }
#line 1585
  if (got_until_eof) {
    {
#line 1587
    warn_unterm(2097152, (char *)ug_msg, start_lineno);
    }
  } else
#line 1589
  if (check_multiline) {
    {
#line 1591
    warn_if_multiline((char *)ug_msg, multiline_start);
    }
  }
#line 1594
  return;
}
}
#line 1626 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void user_message(tic_param_t pfield ) 
{ 
  char delim ;

  {
  {
#line 1628
  delim = (char )pfield.deflt_elem;
#line 1629
  handle_user_message(delim, (bool )-1);
  }
#line 1630
  return;
}
}
#line 1657 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void skip_user_message(tic_param_t pfield ) 
{ 
  char delim ;

  {
  {
#line 1659
  delim = (char )pfield.deflt_elem;
#line 1660
  handle_user_message(delim, (bool )0);
  }
#line 1661
  return;
}
}
#line 1692 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool get_number(long *result ) 
{ 
  u8 *until ;
  long val ;
  bool retval ;
  size_t tmp ;

  {
  {
#line 1696
  retval = (bool )0;
#line 1698
  val = parse_number(statbuf, & until, (int )base);
#line 1709
  tmp = strlen((char const   *)((char *)statbuf));
  }
#line 1709
  if ((unsigned long )until == (unsigned long )(statbuf + tmp)) {
#line 1711
    *result = val;
#line 1712
    retval = (bool )-1;
  }
#line 1715
  return (retval);
}
}
#line 1744 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void deliver_number(long numval ) 
{ 


  {
#line 1746
  if (in_tokz_esc) {
    {
#line 1748
    dpush(numval);
    }
  } else {
    {
#line 1750
    emit_literal((u32 )numval);
    }
  }
#line 1752
  return;
}
}
#line 1773 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool handle_number(void) 
{ 
  bool retval ;
  long numval ;

  {
  {
#line 1778
  retval = get_number(& numval);
  }
#line 1779
  if (retval) {
    {
#line 1781
    deliver_number(numval);
    }
  }
#line 1784
  return (retval);
}
}
#line 1814 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void ascii_right_number(char *in_str ) 
{ 
  u8 nxt_ch ;
  char *str_ptr ;
  long numval ;

  {
#line 1817
  str_ptr = in_str;
#line 1818
  numval = 0L;
#line 1820
  nxt_ch = (u8 )*str_ptr;
  {
#line 1820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1820
    nxt_ch = (u8 )*str_ptr;
#line 1820
    if (! ((int )nxt_ch != 0)) {
#line 1820
      goto while_break;
    }
#line 1824
    numval = (numval << 8) + (long )nxt_ch;
#line 1820
    str_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1826
  deliver_number(numval);
  }
#line 1827
  return;
}
}
#line 1853 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void ascii_left_number(char *in_str ) 
{ 
  u8 nxt_ch ;
  char *str_ptr ;
  long numval ;
  int shift_amt ;
  bool shift_over ;

  {
#line 1856
  str_ptr = in_str;
#line 1857
  numval = 0L;
#line 1858
  shift_amt = 24;
#line 1859
  shift_over = (bool )0;
#line 1861
  nxt_ch = (u8 )*str_ptr;
  {
#line 1861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1861
    nxt_ch = (u8 )*str_ptr;
#line 1861
    if (! ((int )nxt_ch != 0)) {
#line 1861
      goto while_break;
    }
#line 1865
    if (shift_over) {
#line 1865
      numval <<= 8;
    }
#line 1866
    if (shift_amt == 0) {
#line 1866
      shift_over = (bool )-1;
    }
#line 1867
    numval += (long )((int )nxt_ch << shift_amt);
#line 1868
    if (shift_amt > 0) {
#line 1868
      shift_amt -= 8;
    }
#line 1861
    str_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1870
  deliver_number(numval);
  }
#line 1872
  return;
}
}
#line 1882 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void init_scanner(void) 
{ 
  void *tmp ;

  {
  {
#line 1884
  tmp = safe_malloc((size_t )1024, (char *)"initting scanner");
#line 1884
  statbuf = (u8 *)tmp;
  }
#line 1885
  return;
}
}
#line 1894 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void exit_scanner(void) 
{ 


  {
  {
#line 1896
  free((void *)statbuf);
  }
#line 1897
  return;
}
}
#line 1928 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void set_hdr_flag(headeredness new_flag ) 
{ 
  headeredness new_state ;

  {
#line 1930
  new_state = new_flag;
  {
#line 1933
  if ((unsigned int )new_flag == 0U) {
#line 1933
    goto case_0;
  }
#line 1940
  if ((unsigned int )new_flag == 2U) {
#line 1940
    goto case_2;
  }
#line 1947
  if ((unsigned int )new_flag == 1U) {
#line 1947
    goto case_1;
  }
#line 1931
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1935
  if (always_headers) {
#line 1936
    new_state = (headeredness )2;
  }
  case_2: /* CIL Label */ 
#line 1942
  if (always_external) {
#line 1943
    new_state = (headeredness )1;
  }
  case_1: /* CIL Label */ 
#line 1948
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1952
  hdr_flag = new_state;
#line 1954
  return;
}
}
#line 1989 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void init_scan_state(void) 
{ 


  {
  {
#line 1991
  base = (u8 )10;
#line 1992
  pci_is_last_image = (bool )-1;
#line 1993
  incolon = (bool )0;
#line 1994
  is_instance = (bool )0;
#line 1995
  set_hdr_flag((headeredness )0);
#line 1996
  reset_fcode_ranges();
#line 1997
  first_fc_starter = (bool )-1;
  }
#line 1998
  if ((unsigned long )last_colon_filename != (unsigned long )((void *)0)) {
    {
#line 1998
    free((void *)last_colon_filename);
    }
  }
#line 1999
  if ((unsigned long )instance_filename != (unsigned long )((void *)0)) {
    {
#line 1999
    free((void *)instance_filename);
    }
  }
#line 2000
  last_colon_filename = (char *)((void *)0);
#line 2001
  instance_filename = (char *)((void *)0);
#line 2002
  dev_change_instance_warning = (bool )-1;
#line 2003
  instance_definer_gap = (bool )0;
#line 2004
  need_to_pop_source = (bool )0;
#line 2005
  ret_stk_depth = 0;
#line 2006
  return;
}
}
#line 2041 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void collect_input_filename(char **saved_nam ) 
{ 
  bool update_lcfn ;
  int tmp ;

  {
#line 2043
  update_lcfn = (bool )-1;
#line 2044
  if ((unsigned long )*saved_nam != (unsigned long )((void *)0)) {
    {
#line 2046
    tmp = strcmp((char const   *)*saved_nam, (char const   *)iname);
    }
#line 2046
    if (tmp == 0) {
#line 2049
      update_lcfn = (bool )0;
    } else {
      {
#line 2051
      free((void *)*saved_nam);
      }
    }
  }
#line 2054
  if (update_lcfn) {
    {
#line 2056
    *saved_nam = strdup((char const   *)iname);
    }
  }
#line 2058
  return;
}
}
#line 2095 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool test_in_colon(char *wname , bool sb_in_colon , int severity , char *use_instead ) 
{ 
  bool is_wrong ;
  bool retval ;
  char *ui_pt1 ;
  char *ui_pt2 ;
  char *ui_pt3 ;
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 2101
  retval = (bool )-1;
#line 2103
  if (((int )sb_in_colon != 0) != ((int )incolon != 0)) {
#line 2103
    is_wrong = (bool )-1;
  } else {
#line 2103
    is_wrong = (bool )0;
  }
#line 2104
  if (is_wrong) {
#line 2106
    ui_pt1 = (char *)"";
#line 2107
    ui_pt2 = (char *)"";
#line 2108
    ui_pt3 = (char *)"";
#line 2109
    retval = (bool )0;
#line 2110
    if ((unsigned long )use_instead != (unsigned long )((void *)0)) {
#line 2112
      ui_pt1 = (char *)"  Use  ";
#line 2113
      ui_pt2 = use_instead;
#line 2114
      ui_pt3 = (char *)"  instead.";
    }
#line 2116
    if (sb_in_colon) {
#line 2116
      tmp = "out";
    } else {
#line 2116
      tmp = "in";
    }
    {
#line 2116
    tmp___0 = strupper(wname);
#line 2116
    tokenization_error(severity, (char *)"The word  %s  should not be used %sside of a colon definition.%s%s%s\n",
                       tmp___0, tmp, ui_pt1, ui_pt2, ui_pt3);
    }
  }
#line 2120
  return (retval);
}
}
#line 2134 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void must_be_deep_in_do(int how_deep ) 
{ 
  int functional_depth ;
  char deep_do[64] ;
  unsigned int tmp ;
  int indx ;
  bool prefix ;
  char *tmp___0 ;

  {
#line 2136
  functional_depth = do_loop_depth;
#line 2137
  if (incolon) {
#line 2139
    functional_depth = (int )((unsigned int )functional_depth - last_colon_do_depth);
  }
#line 2141
  if (functional_depth < how_deep) {
#line 2143
    deep_do[0] = (char )'\000';
#line 2143
    tmp = 1U;
    {
#line 2143
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2143
      if (tmp >= 64U) {
#line 2143
        goto while_break;
      }
#line 2143
      deep_do[tmp] = (char)0;
#line 2143
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2145
    prefix = (bool )0;
#line 2147
    indx = 0;
    {
#line 2147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2147
      if (! (indx < how_deep)) {
#line 2147
        goto while_break___0;
      }
      {
#line 2149
      strcat((char */* __restrict  */)(deep_do), (char const   */* __restrict  */)"DO ... ");
#line 2147
      indx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2151
    indx = 0;
    {
#line 2151
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2151
      if (! (indx < how_deep)) {
#line 2151
        goto while_break___1;
      }
#line 2153
      if (prefix) {
        {
#line 2155
        strcat((char */* __restrict  */)(deep_do), (char const   */* __restrict  */)" ... ");
        }
      }
      {
#line 2157
      strcat((char */* __restrict  */)(deep_do), (char const   */* __restrict  */)"LOOP");
#line 2158
      prefix = (bool )-1;
#line 2151
      indx ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2161
    tmp___0 = strupper((char *)statbuf);
#line 2161
    tokenization_error(67108864, (char *)"%s outside of  %s  structure", tmp___0,
                       deep_do);
#line 2163
    in_last_colon((bool )-1);
    }
  }
#line 2166
  return;
}
}
#line 2222 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void bump_ret_stk_depth(int bump ) 
{ 


  {
#line 2224
  ret_stk_depth += bump;
#line 2225
  return;
}
}
#line 2281 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void ret_stk_balance_rpt(char *before_what , bool clear_it ) 
{ 
  char *what_flow ;
  char const   *tmp ;
  char *what_phr ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 2283
  if (ret_stk_depth != 0) {
#line 2285
    if (ret_stk_depth < 0) {
#line 2285
      tmp = "deficit";
    } else {
#line 2285
      tmp = "excess";
    }
#line 2285
    what_flow = (char *)tmp;
#line 2286
    if ((unsigned long )before_what != (unsigned long )((void *)0)) {
#line 2286
      tmp___1 = before_what;
    } else {
      {
#line 2286
      tmp___0 = strupper((char *)statbuf);
#line 2286
      tmp___1 = tmp___0;
      }
    }
    {
#line 2286
    what_phr = tmp___1;
#line 2288
    tokenization_error(2097152, (char *)"Possible Return-Stack %s before %s", what_flow,
                       what_phr);
#line 2290
    in_last_colon((bool )-1);
    }
#line 2292
    if (clear_it) {
#line 2294
      ret_stk_depth = 0;
    }
  }
#line 2297
  return;
}
}
#line 2329 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void ret_stk_access_rpt(void) 
{ 
  char *tmp ;

  {
#line 2331
  if (ret_stk_depth <= 0) {
    {
#line 2333
    tmp = strupper((char *)statbuf);
#line 2333
    tokenization_error(2097152, (char *)"Possible Return-Stack access attempt by %s without value having been placed there",
                       tmp);
#line 2337
    in_last_colon((bool )-1);
    }
  }
#line 2339
  return;
}
}
#line 2357 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void encode_file(char const   *filename ) 
{ 
  FILE *f ;
  size_t s ;
  int num_encoded ;

  {
  {
#line 2361
  num_encoded = 0;
#line 2363
  tokenization_error(65536, (char *)"ENCODing File %s\n", filename);
#line 2365
  f = open_expanded_file(filename, (char *)"rb", (char *)"encoding");
  }
#line 2366
  if ((unsigned long )f != (unsigned long )((void *)0)) {
    {
#line 2368
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2368
      s = fread((void */* __restrict  */)statbuf, (size_t )1, (size_t )255, (FILE */* __restrict  */)f);
      }
#line 2368
      if (! s) {
#line 2368
        goto while_break;
      }
      {
#line 2370
      emit_token("b(\")");
#line 2371
      emit_string(statbuf, (int )s);
#line 2372
      emit_token("encode-bytes");
      }
#line 2373
      if (num_encoded) {
        {
#line 2374
        emit_token("encode+");
        }
      }
#line 2375
      num_encoded = (int )((size_t )num_encoded + s);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2377
    fclose(f);
#line 2378
    tokenization_error(65536, (char *)"ENCODed %d bytes.\n", num_encoded);
    }
  }
#line 2380
  return;
}
}
#line 2422 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void check_name_length(long wlen ) 
{ 
  int severity ;

  {
#line 2424
  if (wlen > 31L) {
#line 2426
    severity = 67108864;
#line 2427
    if (in_tokz_esc) {
#line 2428
      severity = 65536;
    } else
#line 2430
    if ((unsigned int )hdr_flag == 0U) {
#line 2431
      severity = 2097152;
    }
    {
#line 2434
    tokenization_error(severity, (char *)"ANSI Forth does not permit definition of names longer than 31 characters.\n");
    }
  }
#line 2439
  return;
}
}
#line 2464 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool definer_name(fwtoken definer , char **reslt_ptr ) 
{ 
  bool retval ;

  {
#line 2466
  retval = (bool )-1;
  {
#line 2469
  if ((unsigned int )definer == 47U) {
#line 2469
    goto case_47;
  }
#line 2472
  if ((unsigned int )definer == 16U) {
#line 2472
    goto case_16;
  }
#line 2475
  if ((unsigned int )definer == 46U) {
#line 2475
    goto case_46;
  }
#line 2478
  if ((unsigned int )definer == 10U) {
#line 2478
    goto case_10;
  }
#line 2481
  if ((unsigned int )definer == 12U) {
#line 2481
    goto case_12;
  }
#line 2484
  if ((unsigned int )definer == 1U) {
#line 2484
    goto case_1;
  }
#line 2487
  if ((unsigned int )definer == 14U) {
#line 2487
    goto case_14;
  }
#line 2490
  if ((unsigned int )definer == 25U) {
#line 2490
    goto case_25;
  }
#line 2493
  if ((unsigned int )definer == 84U) {
#line 2493
    goto case_84;
  }
#line 2496
  if ((unsigned int )definer == 5U) {
#line 2496
    goto case_5;
  }
#line 2499
  if ((unsigned int )definer == 75U) {
#line 2499
    goto case_75;
  }
#line 2502
  goto switch_default;
  case_47: /* CIL Label */ 
#line 2470
  *reslt_ptr = (char *)"VARIABLE";
#line 2471
  goto switch_break;
  case_16: /* CIL Label */ 
#line 2473
  *reslt_ptr = (char *)"DEFER";
#line 2474
  goto switch_break;
  case_46: /* CIL Label */ 
#line 2476
  *reslt_ptr = (char *)"VALUE";
#line 2477
  goto switch_break;
  case_10: /* CIL Label */ 
#line 2479
  *reslt_ptr = (char *)"BUFFER";
#line 2480
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2482
  *reslt_ptr = (char *)"CONSTANT";
#line 2483
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2485
  *reslt_ptr = (char *)"COLON";
#line 2486
  goto switch_break;
  case_14: /* CIL Label */ 
#line 2488
  *reslt_ptr = (char *)"CREATE";
#line 2489
  goto switch_break;
  case_25: /* CIL Label */ 
#line 2491
  *reslt_ptr = (char *)"FIELD";
#line 2492
  goto switch_break;
  case_84: /* CIL Label */ 
#line 2494
  *reslt_ptr = (char *)"MACRO";
#line 2495
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2497
  *reslt_ptr = (char *)"ALIAS";
#line 2498
  goto switch_break;
  case_75: /* CIL Label */ 
#line 2500
  *reslt_ptr = (char *)"Local Value name";
#line 2501
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2503
  retval = (bool )0;
  switch_break: /* CIL Label */ ;
  }
#line 2506
  return (retval);
}
}
#line 2542 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool as_a_what(fwtoken definer , char *as_what ) 
{ 
  char *defn_type_name ;
  bool retval ;
  bool tmp ;

  {
  {
#line 2545
  tmp = definer_name(definer, & defn_type_name);
#line 2545
  retval = tmp;
  }
#line 2546
  if (retval) {
    {
#line 2548
    strcat((char */* __restrict  */)as_what, (char const   */* __restrict  */)"as a");
    }
#line 2558
    if ((unsigned int )definer == 5U) {
      {
#line 2558
      strcat((char */* __restrict  */)as_what, (char const   */* __restrict  */)"n");
      }
    }
    {
#line 2560
    strcat((char */* __restrict  */)as_what, (char const   */* __restrict  */)" ");
#line 2561
    strcat((char */* __restrict  */)as_what, (char const   */* __restrict  */)defn_type_name);
    }
  }
#line 2563
  return (retval);
}
}
#line 2646 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static char lookup_where_pt1_buf[32]  ;
#line 2648 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
tic_hdr_t *lookup_word(char *stat_name , char **where_pt1 , char **where_pt2 ) 
{ 
  tic_hdr_t *found ;
  bool trail_space ;
  bool doing_lookup ;
  int tmp ;
  char *temp_where_pt2 ;
  bool tmp___0 ;

  {
#line 2650
  found = (tic_hdr_t *)((void *)0);
#line 2651
  trail_space = (bool )-1;
#line 2652
  if ((unsigned long )where_pt1 != (unsigned long )((void *)0)) {
#line 2652
    if ((unsigned long )where_pt2 != (unsigned long )((void *)0)) {
#line 2652
      tmp = -1;
    } else {
#line 2652
      tmp = 0;
    }
  } else {
#line 2652
    tmp = 0;
  }
#line 2652
  doing_lookup = (bool )tmp;
#line 2654
  temp_where_pt2 = (char *)"in the core vocabulary.\n";
#line 2656
  lookup_where_pt1_buf[0] = (char)0;
#line 2661
  if (in_tokz_esc) {
    {
#line 2663
    found = lookup_tokz_esc(stat_name);
    }
#line 2664
    if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 2666
      temp_where_pt2 = in_tkz_esc_mode;
    } else {
      {
#line 2669
      found = lookup_shared_word(stat_name);
      }
    }
  } else {
#line 2673
    if (ibm_locals) {
      {
#line 2675
      found = lookup_local(stat_name);
      }
#line 2676
      if (doing_lookup) {
#line 2676
        if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 2678
          trail_space = (bool )0;
#line 2679
          temp_where_pt2 = (char *)".\n";
        }
      }
    }
#line 2683
    if ((unsigned long )found == (unsigned long )((void *)0)) {
      {
#line 2685
      found = lookup_in_dev_node(stat_name);
      }
#line 2686
      if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 2688
        if (doing_lookup) {
          {
#line 2690
          temp_where_pt2 = in_what_node(current_device_node);
          }
        }
      } else {
        {
#line 2694
        found = lookup_core_word(stat_name);
        }
      }
    }
  }
#line 2699
  if (doing_lookup) {
#line 2699
    if ((unsigned long )found != (unsigned long )((void *)0)) {
      {
#line 2701
      tmp___0 = as_a_what(found->fword_defr, lookup_where_pt1_buf);
      }
#line 2701
      if (tmp___0) {
#line 2703
        if (trail_space) {
          {
#line 2705
          strcat((char */* __restrict  */)(lookup_where_pt1_buf), (char const   */* __restrict  */)" ");
          }
        }
      }
#line 2708
      *where_pt1 = lookup_where_pt1_buf;
#line 2709
      *where_pt2 = temp_where_pt2;
    }
  }
#line 2711
  return (found);
}
}
#line 2746 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool word_exists(char *stat_name , char **where_pt1 , char **where_pt2 ) 
{ 
  bool retval ;
  tic_hdr_t *found ;
  tic_hdr_t *tmp ;

  {
  {
#line 2748
  retval = (bool )0;
#line 2749
  tmp = lookup_word(stat_name, where_pt1, where_pt2);
#line 2749
  found = tmp;
  }
#line 2751
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 2753
    retval = (bool )-1;
  }
#line 2756
  return (retval);
}
}
#line 2804 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void warn_if_duplicate(char *stat_name ) 
{ 
  char *where_pt1 ;
  char *where_pt2 ;
  bool tmp ;

  {
#line 2806
  if (verbose_dup_warning) {
#line 2806
    if (do_not_overload) {
      {
#line 2810
      tmp = word_exists(stat_name, & where_pt1, & where_pt2);
      }
#line 2810
      if (tmp) {
        {
#line 2812
        tokenization_error(2097152, (char *)"Duplicate definition:   %s  already exists %s%s",
                           stat_name, where_pt1, where_pt2);
#line 2815
        show_node_start();
        }
      }
    }
  }
#line 2818
  do_not_overload = (bool )-1;
#line 2819
  return;
}
}
#line 2843 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void glob_not_allowed(int severity , bool not_ignoring ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 2845
  if (not_ignoring) {
#line 2845
    tmp = "Attempting to compensate..";
  } else {
#line 2845
    tmp = "Ignoring";
  }
  {
#line 2845
  tmp___0 = strupper((char *)statbuf);
#line 2845
  tokenization_error(severity, (char *)"Global Scope is in effect; %s not allowed.  %s.\n",
                     tmp___0, tmp);
  }
#line 2851
  return;
}
}
#line 2870 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void not_in_dict(char *stat_name ) 
{ 


  {
  {
#line 2872
  tokenization_error(67108864, (char *)"Word  %s  is not in dictionary.\n", stat_name);
  }
#line 2874
  return;
}
}
#line 2912 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void tokenized_word_error(char *stat_name ) 
{ 
  char *where_pt1 ;
  char *where_pt2 ;
  bool found_somewhere ;
  bool sav_in_tokz_esc ;
  char const   *tmp ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 2918
  sav_in_tokz_esc = in_tokz_esc;
#line 2919
  if (sav_in_tokz_esc) {
#line 2919
    in_tokz_esc = (bool )0;
  } else {
#line 2919
    in_tokz_esc = (bool )-1;
  }
  {
#line 2921
  traced_name_error(stat_name);
#line 2923
  found_somewhere = word_exists(stat_name, & where_pt1, & where_pt2);
  }
#line 2924
  if (found_somewhere) {
#line 2926
    if (sav_in_tokz_esc) {
#line 2926
      tmp = "not";
    } else {
#line 2926
      tmp = "only";
    }
    {
#line 2926
    tokenization_error(67108864, (char *)"The word %s is %s recognized in tokenizer-escape mode.\n",
                       stat_name, tmp);
    }
  } else {
    {
#line 2930
    not_in_dict(stat_name);
    }
  }
  {
#line 2933
  tmp___2 = exists_in_ancestor(stat_name);
  }
#line 2933
  if (tmp___2) {
#line 2933
    tmp___1 = 0;
  } else {
#line 2933
    tmp___1 = -1;
  }
#line 2933
  if (tmp___1) {
#line 2935
    if (found_somewhere) {
#line 2935
      if (sav_in_tokz_esc) {
        {
#line 2937
        tokenization_error(65536, (char *)"%s is defined %s%s", stat_name, where_pt1,
                           where_pt2);
#line 2939
        show_node_start();
        }
      }
    }
  }
#line 2943
  in_tokz_esc = sav_in_tokz_esc;
#line 2944
  return;
}
}
#line 2968 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void unresolved_instance(int severity ) 
{ 


  {
  {
#line 2970
  tokenization_error(severity, (char *)"Unresolved \"INSTANCE\"");
#line 2971
  just_where_started(instance_filename, instance_lineno);
  }
#line 2972
  return;
}
}
#line 2997 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void modified_by_instance(fwtoken definer , bool was_modded ) 
{ 
  char *was_not ;
  char const   *tmp ;
  char *defn_type_name ;

  {
#line 2999
  if (was_modded) {
#line 2999
    tmp = "was";
  } else {
#line 2999
    tmp = "not";
  }
  {
#line 2999
  was_not = (char *)tmp;
#line 3003
  definer_name(definer, & defn_type_name);
#line 3005
  tokenization_error(2097152, (char *)"%s definition %s modified by \"INSTANCE\"",
                     defn_type_name, was_not);
#line 3008
  just_where_started(instance_filename, instance_lineno);
  }
#line 3009
  return;
}
}
#line 3048 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void validate_instance(fwtoken definer ) 
{ 
  bool is_error ;

  {
#line 3050
  if (is_instance) {
#line 3052
    is_error = (bool )-1;
    {
#line 3059
    if ((unsigned int )definer == 10U) {
#line 3059
      goto case_10;
    }
#line 3059
    if ((unsigned int )definer == 16U) {
#line 3059
      goto case_10;
    }
#line 3059
    if ((unsigned int )definer == 47U) {
#line 3059
      goto case_10;
    }
#line 3059
    if ((unsigned int )definer == 46U) {
#line 3059
      goto case_10;
    }
#line 3063
    goto switch_default;
    case_10: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 3060
    is_error = (bool )0;
    switch_default: /* CIL Label */ 
#line 3064
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3067
    if (is_error) {
      {
#line 3069
      modified_by_instance(definer, (bool )0);
#line 3070
      instance_definer_gap = (bool )-1;
      }
    } else {
#line 3072
      if (instance_definer_gap) {
        {
#line 3074
        modified_by_instance(definer, (bool )-1);
        }
      }
#line 3076
      is_instance = (bool )0;
#line 3077
      instance_definer_gap = (bool )0;
    }
  }
#line 3080
  return;
}
}
#line 3176 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool create_word(fwtoken definer ) 
{ 
  long wlen ;
  bool retval ;
  char *defn_type_name ;
  char defn_type_buffr[32] ;
  unsigned int tmp ;
  unsigned int old_lineno ;
  bool emit_token_name ;
  bool tmp___0 ;

  {
  {
#line 3179
  retval = (bool )0;
#line 3184
  tmp___0 = test_in_colon((char *)statbuf, (bool )0, 67108864, (char *)((void *)0));
  }
#line 3184
  if (tmp___0) {
#line 3186
    defn_type_buffr[0] = (char )'\000';
#line 3186
    tmp = 1U;
    {
#line 3186
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3186
      if (tmp >= 32U) {
#line 3186
        goto while_break;
      }
#line 3186
      defn_type_buffr[tmp] = (char)0;
#line 3186
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3187
    old_lineno = lineno;
#line 3189
    define_token = (bool )-1;
#line 3194
    definer_name(definer, & defn_type_name);
#line 3196
    strcat((char */* __restrict  */)(defn_type_buffr), (char const   */* __restrict  */)defn_type_name);
#line 3197
    strcat((char */* __restrict  */)(defn_type_buffr), (char const   */* __restrict  */)" definition");
    }
#line 3200
    if (control_stack_depth != 0) {
      {
#line 3202
      announce_control_structs(67108864, defn_type_buffr, 0U);
#line 3204
      define_token = (bool )0;
      }
    }
    {
#line 3208
    wlen = get_word();
    }
#line 3214
    if (wlen <= 0L) {
      {
#line 3216
      warn_unterm(67108864, defn_type_buffr, old_lineno);
      }
    } else {
      {
#line 3218
      emit_token_name = (bool )-1;
#line 3221
      validate_instance(definer);
#line 3224
      assigning_fcode();
#line 3227
      add_to_current((char *)statbuf, (long )nextfcode, definer);
#line 3229
      check_name_length(wlen);
      }
      {
#line 3234
      if ((unsigned int )hdr_flag == 2U) {
#line 3234
        goto case_2;
      }
#line 3238
      if ((unsigned int )hdr_flag == 1U) {
#line 3238
        goto case_1;
      }
#line 3242
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 3235
      emit_token("named-token");
      }
#line 3236
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3239
      emit_token("external-token");
      }
#line 3240
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3243
      emit_token("new-token");
#line 3244
      emit_token_name = (bool )0;
      }
      switch_break: /* CIL Label */ ;
      }
#line 3248
      if (emit_token_name) {
#line 3250
        if (force_tokens_case) {
#line 3252
          if (force_lower_case_tokens) {
            {
#line 3254
            strlower((char *)statbuf);
            }
          } else {
            {
#line 3256
            strupper((char *)statbuf);
            }
          }
        }
        {
#line 3259
        emit_string(statbuf, (int )wlen);
        }
      }
      {
#line 3263
      emit_fcode(nextfcode);
#line 3266
      bump_fcode();
#line 3269
      retval = (bool )-1;
      }
    }
  }
#line 3272
  return (retval);
}
}
#line 3309 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void cannot_apply(char *func_nam , char *targ_nam , fwtoken defr ) 
{ 
  char *defr_name ;
  char *defr_phrase ;
  bool tmp ;

  {
  {
#line 3311
  defr_name = (char *)"";
#line 3312
  defr_phrase = wh_defined;
#line 3314
  tmp = definer_name(defr, & defr_name);
  }
#line 3314
  if (! tmp) {
#line 3316
    defr_phrase = (char *)"";
  }
  {
#line 3319
  tokenization_error(67108864, (char *)"Cannot apply  %s  to  %s %s%s.\n", func_nam,
                     targ_nam, defr_phrase, defr_name);
  }
#line 3323
  return;
}
}
#line 3358 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static tic_hdr_t *lookup_with_definer(char *stat_name , fwtoken *definr ) 
{ 
  tic_hdr_t *retval ;
  tic_hdr_t *tmp ;
  bool tmp___0 ;

  {
  {
#line 3360
  tmp = lookup_current(stat_name);
#line 3360
  retval = tmp;
  }
#line 3361
  if ((unsigned long )retval != (unsigned long )((void *)0)) {
#line 3363
    *definr = retval->fword_defr;
  } else {
    {
#line 3365
    tmp___0 = exists_as_local(stat_name);
    }
#line 3365
    if (tmp___0) {
#line 3365
      *definr = (fwtoken )75;
    }
  }
#line 3367
  return (retval);
}
}
#line 3414 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool validate_to_target(void) 
{ 
  long wlen ;
  tic_hdr_t *test_entry ;
  u8 *saved_pc ;
  char *cmd_cpy ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int saved_lineno ;
  unsigned int saved_abs_token_no ;
  fwtoken defr ;
  bool targ_err ;
  bool retval ;
  char *tmp___1 ;

  {
  {
#line 3418
  saved_pc = pc;
#line 3419
  tmp = strdup((char const   *)statbuf);
#line 3419
  tmp___0 = strupper(tmp);
#line 3419
  cmd_cpy = tmp___0;
#line 3420
  saved_lineno = lineno;
#line 3421
  saved_abs_token_no = abs_token_no;
#line 3422
  defr = (fwtoken )3131953165U;
#line 3423
  targ_err = (bool )-1;
#line 3424
  retval = (bool )0;
#line 3426
  wlen = get_word();
  }
#line 3427
  if (wlen <= 0L) {
    {
#line 3429
    warn_unterm(67108864, cmd_cpy, saved_lineno);
    }
  } else {
    {
#line 3432
    test_entry = lookup_with_definer((char *)statbuf, & defr);
    }
#line 3433
    if ((unsigned long )test_entry != (unsigned long )((void *)0)) {
      {
#line 3437
      if ((unsigned int )defr == 47U) {
#line 3437
        goto case_47;
      }
#line 3443
      if ((unsigned int )defr == 46U) {
#line 3443
        goto case_46;
      }
#line 3443
      if ((unsigned int )defr == 16U) {
#line 3443
        goto case_46;
      }
#line 3445
      if ((unsigned int )defr == 12U) {
#line 3445
        goto case_12;
      }
#line 3449
      goto switch_default;
      case_47: /* CIL Label */ 
      {
#line 3438
      tokenization_error(2097152, (char *)"Applying %s to a VARIABLE (%s) is not recommended; use  !  instead.\n",
                         cmd_cpy, statbuf);
      }
      case_46: /* CIL Label */ 
      case_16: /* CIL Label */ 
#line 3444
      targ_err = (bool )0;
      case_12: /* CIL Label */ 
#line 3446
      retval = (bool )-1;
      switch_default: /* CIL Label */ 
#line 3450
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3454
    if (targ_err) {
      {
#line 3456
      tmp___1 = strupper((char *)statbuf);
#line 3456
      cannot_apply(cmd_cpy, tmp___1, defr);
      }
    }
#line 3459
    pc = saved_pc;
#line 3460
    lineno = saved_lineno;
#line 3461
    abs_token_no = saved_abs_token_no;
  }
  {
#line 3463
  free((void *)cmd_cpy);
  }
#line 3464
  return (retval);
}
}
#line 3486 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void you_are_here(void) 
{ 
  char *tmp ;

  {
  {
#line 3488
  tmp = strupper((char *)statbuf);
#line 3488
  tokenization_error(65536, (char *)"%s encountered; processing...\n", tmp);
  }
#line 3491
  return;
}
}
#line 3553 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void fcode_starter(char const   *token_name , int spread , bool is_offs16 ) 
{ 


  {
  {
#line 3555
  you_are_here();
  }
#line 3556
  if (spread != 1) {
    {
#line 3558
    tokenization_error(2097152, (char *)"spread of %d not supported.\n", spread);
    }
  }
#line 3560
  if (fcode_started) {
    {
#line 3562
    tokenization_error(2097152, (char *)"Only one \"FCode Starter\" permitted per tokenization.  Ignoring...\n");
    }
  } else {
    {
#line 3567
    emit_fcodehdr(token_name);
#line 3568
    offs16 = is_offs16;
#line 3569
    fcode_started = (bool )-1;
#line 3571
    current_device_node->ifile_name = strdup((char const   *)iname);
#line 3572
    current_device_node->line_no = lineno;
    }
#line 3574
    if (first_fc_starter) {
      {
#line 3576
      reset_fcode_ranges();
#line 3577
      first_fc_starter = (bool )0;
      }
    } else {
      {
#line 3579
      set_next_fcode(nextfcode);
      }
    }
  }
#line 3582
  return;
}
}
#line 3608 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void fcode_end_err_check(void) 
{ 
  bool stack_imbal ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 3610
  tmp___1 = stackdepth();
  }
#line 3610
  if (tmp___1 != 0L) {
#line 3610
    tmp___0 = -1;
  } else {
#line 3610
    tmp___0 = 0;
  }
#line 3610
  stack_imbal = (bool )tmp___0;
#line 3612
  if (stack_imbal) {
    {
#line 3614
    tokenization_error(2097152, (char *)"Stack imbalance before end of tokenization.\n");
    }
  }
  {
#line 3617
  clear_stack();
#line 3618
  clear_control_structs((char *)"End of tokenization");
  }
#line 3619
  return;
}
}
#line 3675 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void fcode_ender(void) 
{ 
  char *tmp_iname ;

  {
#line 3677
  if (incolon) {
    {
#line 3679
    tmp_iname = iname;
#line 3680
    iname = last_colon_filename;
#line 3681
    unterm_is_colon = (bool )-1;
#line 3682
    warn_unterm(67108864, (char *)"Colon Definition", last_colon_lineno);
#line 3683
    iname = tmp_iname;
    }
  }
#line 3686
  haveend = (bool )-1;
#line 3688
  if (is_instance) {
    {
#line 3690
    unresolved_instance(67108864);
    }
  }
#line 3693
  if (scope_is_global) {
    {
#line 3695
    tokenization_error(2097152, (char *)"No DEVICE-DEFINITIONS directive encountered before end.  Compensating...\n");
#line 3698
    resume_device_scope();
    }
  }
  {
#line 3700
  fcode_end_err_check();
#line 3701
  reset_normal_vocabs();
#line 3702
  finish_fcodehdr();
#line 3703
  fcode_started = (bool )0;
  }
#line 3705
  if ((unsigned long )current_device_node->ifile_name != (unsigned long )(default_top_dev_ifile_name)) {
    {
#line 3707
    free((void *)current_device_node->ifile_name);
#line 3708
    current_device_node->ifile_name = default_top_dev_ifile_name;
#line 3709
    current_device_node->line_no = 0U;
    }
  }
#line 3711
  return;
}
}
#line 3753 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool get_token(tic_hdr_t **tok_entry ) 
{ 
  bool retval ;
  tic_hdr_t *found ;
  u8 *save_pc ;
  char cmnd_cpy[41] ;
  fwtoken defr ;
  char *tmp ;
  bool tmp___0 ;

  {
  {
#line 3755
  retval = (bool )0;
#line 3761
  strncpy((char */* __restrict  */)(cmnd_cpy), (char const   */* __restrict  */)statbuf,
          (size_t )40);
#line 3762
  cmnd_cpy[40] = (char)0;
#line 3764
  save_pc = pc;
#line 3766
  tmp___0 = get_word_in_line((char *)statbuf);
  }
#line 3766
  if (tmp___0) {
    {
#line 3768
    defr = (fwtoken )3131953165U;
#line 3779
    found = lookup_with_definer((char *)statbuf, & defr);
    }
#line 3780
    if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 3788
      if ((unsigned int )defr == 2985574557U) {
        {
#line 3790
        found = lookup_token((char *)statbuf);
        }
#line 3791
        if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 3791
          retval = (bool )-1;
        } else {
#line 3791
          retval = (bool )0;
        }
      } else {
        {
#line 3793
        retval = entry_is_token(found);
        }
      }
    }
    {
#line 3797
    handle_invocation(found);
    }
#line 3799
    if (retval) {
#line 3801
      *tok_entry = found;
    } else {
      {
#line 3803
      tmp = strupper((char *)statbuf);
#line 3803
      cannot_apply(cmnd_cpy, tmp, defr);
#line 3804
      pc = save_pc;
      }
    }
  }
#line 3808
  return (retval);
}
}
#line 3812 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void base_change(int new_base ) 
{ 
  int tmp ;

  {
#line 3814
  if (incolon) {
#line 3814
    if (in_tokz_esc) {
#line 3814
      tmp = 0;
    } else {
#line 3814
      tmp = -1;
    }
#line 3814
    if (tmp) {
      {
#line 3816
      emit_literal((u32 )new_base);
#line 3817
      emit_token("base");
#line 3818
      emit_token("!");
      }
    } else {
#line 3820
      base = (u8 )new_base;
    }
  } else {
#line 3820
    base = (u8 )new_base;
  }
#line 3822
  return;
}
}
#line 3824 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void base_val(int new_base ) 
{ 
  u8 *old_pc ;
  char base_cmnd[41] ;
  u8 basecpy ;
  char *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 3829
  strncpy((char */* __restrict  */)(base_cmnd), (char const   */* __restrict  */)statbuf,
          (size_t )40);
#line 3830
  base_cmnd[40] = (char)0;
#line 3832
  old_pc = pc;
#line 3833
  tmp___1 = get_word_in_line((char *)statbuf);
  }
#line 3833
  if (tmp___1) {
    {
#line 3835
    basecpy = base;
#line 3837
    base = (u8 )new_base;
#line 3838
    tmp___0 = handle_number();
    }
#line 3838
    if (! tmp___0) {
      {
#line 3841
      tmp = strupper(base_cmnd);
#line 3841
      tokenization_error(2097152, (char *)"Applying %s to non-numeric value.  Ignoring.\n",
                         tmp);
#line 3844
      pc = old_pc;
      }
    }
#line 3846
    base = basecpy;
  }
#line 3848
  return;
}
}
#line 3886 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void eval_string(char *inp_bufr ) 
{ 
  size_t tmp ;

  {
  {
#line 3888
  push_source((void (*)())((void *)0), (void *)0, (bool )0);
#line 3889
  tmp = strlen((char const   *)inp_bufr);
#line 3889
  init_inbuf(inp_bufr, (unsigned int )tmp);
  }
#line 3890
  return;
}
}
#line 3948 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void finish_or_new_device(bool finishing_device ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3950
  if (incolon) {
#line 3950
    tmp___0 = 0;
  } else {
#line 3950
    tmp___0 = -1;
  }
#line 3950
  if (tmp___0) {
#line 3952
    if (is_instance) {
#line 3952
      tmp = 0;
    } else {
#line 3952
      tmp = -1;
    }
#line 3952
    if (tmp) {
#line 3955
      dev_change_instance_warning = (bool )-1;
    } else {
#line 3958
      instance_definer_gap = (bool )-1;
#line 3960
      if (dev_change_instance_warning) {
        {
#line 3962
        unresolved_instance(2097152);
#line 3963
        dev_change_instance_warning = (bool )0;
        }
      }
    }
#line 3968
    if (scope_is_global) {
      {
#line 3970
      glob_not_allowed(67108864, noerrors);
      }
#line 3971
      if (noerrors) {
        {
#line 3973
        resume_device_scope();
        }
      } else {
#line 3975
        return;
      }
    }
#line 3979
    if (finishing_device) {
      {
#line 3981
      finish_device_vocab();
      }
    } else {
      {
#line 3983
      new_device_vocab();
      }
    }
  }
#line 3986
  if (finishing_device) {
#line 3986
    tmp___1 = "finish-device";
  } else {
#line 3986
    tmp___1 = "new-device";
  }
  {
#line 3986
  emit_token(tmp___1);
  }
#line 3987
  return;
}
}
#line 4054 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool abort_quote(fwtoken tok ) 
{ 
  bool retval ;
  char *save_statbuf ;
  long wlen ;
  char *abort_string ;
  long wlen___0 ;

  {
#line 4056
  retval = (bool )0;
#line 4057
  if ((unsigned int )tok == 219U) {
#line 4059
    if (! enable_abort_quote) {
      {
#line 4064
      save_statbuf = strdup((char const   *)((char *)statbuf));
#line 4065
      wlen = get_string___0((bool )0);
#line 4066
      strcpy((char */* __restrict  */)statbuf, (char const   */* __restrict  */)save_statbuf);
#line 4067
      free((void *)save_statbuf);
      }
    } else {
      {
#line 4080
      retval = (bool )-1;
#line 4081
      tokenization_error(65536, (char *)"ABORT\" in fcode not defined by IEEE 1275-1994\n");
#line 4083
      test_in_colon((char *)"ABORT\"", (bool )-1, 67108864, (char *)((void *)0));
#line 4084
      wlen___0 = get_string___0((bool )-1);
      }
#line 4086
      if (sun_style_abort_quote) {
        {
#line 4086
        emit_if();
        }
      }
      {
#line 4088
      emit_token("b(\")");
#line 4089
      emit_string(statbuf, (int )wlen___0);
      }
#line 4091
      if (sun_style_abort_quote) {
        {
#line 4091
        emit_token("type");
        }
      }
#line 4093
      if (abort_quote_throw) {
        {
#line 4095
        emit_literal((u32 )-2);
#line 4096
        emit_token("throw");
        }
      } else {
        {
#line 4098
        emit_token("abort");
        }
      }
#line 4101
      if (sun_style_abort_quote) {
        {
#line 4101
        emit_then();
        }
      }
#line 4103
      abort_string = (char *)" type -2 THROW THEN:";
    }
  }
#line 4106
  return (retval);
}
}
#line 4185 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static void create_alias(void) 
{ 
  char *new_alias ;
  char *old_name ;
  char *tmp ;
  bool tmp___0 ;
  tic_hdr_t *found ;
  tic_hdr_t *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;

  {
  {
#line 4189
  validate_instance((fwtoken )5);
  }
#line 4190
  if (incolon) {
    {
#line 4192
    tokenization_error(2097152, (char *)"ALIAS during colon-definition is not supported by IEEE 1275-1994\n");
    }
  }
  {
#line 4196
  tmp___6 = get_word_in_line((char *)"ALIAS");
  }
#line 4196
  if (tmp___6) {
    {
#line 4199
    new_alias = strdup((char const   *)((char *)statbuf));
#line 4201
    tmp___5 = get_word_in_line((char *)"ALIAS");
    }
#line 4201
    if (tmp___5) {
      {
#line 4203
      tmp = strdup((char const   *)((char *)statbuf));
#line 4203
      old_name = tmp;
      }
#line 4214
      if (in_tokz_esc) {
        {
#line 4216
        tmp___0 = create_tokz_esc_alias(new_alias, old_name);
        }
#line 4216
        if (tmp___0) {
#line 4217
          return;
        }
        {
#line 4226
        tmp___1 = lookup_shared_word(old_name);
#line 4226
        found = tmp___1;
        }
#line 4227
        if ((unsigned long )found != (unsigned long )((void *)0)) {
          {
#line 4229
          tmp___2 = create_core_alias(new_alias, old_name);
          }
#line 4229
          if (tmp___2) {
#line 4230
            return;
          }
        }
      } else {
        {
#line 4237
        tmp___3 = create_local_alias(new_alias, old_name);
        }
#line 4237
        if (tmp___3) {
#line 4238
          return;
        }
        {
#line 4248
        tmp___4 = create_current_alias(new_alias, old_name);
        }
#line 4248
        if (tmp___4) {
#line 4249
          return;
        }
      }
      {
#line 4256
      trace_create_failure(new_alias, old_name, (u16 )0);
#line 4257
      tokenized_word_error(old_name);
#line 4258
      free((void *)old_name);
      }
    }
    {
#line 4260
    free((void *)new_alias);
    }
  }
#line 4262
  return;
}
}
#line 4291 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
static bool string_err_check(bool is_paren , unsigned int sav_lineno , unsigned int strt_lineno ) 
{ 
  bool retval ;
  char *item_typ ;
  char const   *tmp ;

  {
#line 4295
  retval = noerrors;
#line 4296
  if (is_paren) {
#line 4296
    tmp = "Dot-Paren";
  } else {
#line 4296
    tmp = "Ess-Quote";
  }
#line 4296
  item_typ = (char *)tmp;
#line 4298
  if (got_until_eof) {
    {
#line 4300
    warn_unterm(67108864, item_typ, sav_lineno);
    }
  } else {
    {
#line 4302
    retval = (bool )-1;
#line 4303
    warn_if_multiline(item_typ, strt_lineno);
    }
  }
#line 4305
  return (retval);
}
}
#line 4358
void handle_internal(tic_param_t pfield ) ;
#line 4359 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void handle_internal(tic_param_t pfield ) 
{ 
  fwtoken tok ;
  long wlen ;
  unsigned int sav_lineno ;
  bool handy_toggle ;
  bool handy_toggle_too ;
  char *handy_string ;
  int handy_int ;
  bool tmp ;
  bool tmp___0 ;
  u16 maybe_last_colon_fcode ;
  unsigned int maybe_last_colon_lineno ;
  unsigned int maybe_last_colon_abs_token_no ;
  unsigned int maybe_last_colon_do_depth ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  u32 val ;
  long tmp___12 ;
  bool set_instance_state ;
  bool emit_instance ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  tic_hdr_t *token_entry ;
  bool tmp___17 ;
  tic_hdr_t *token_entry___0 ;
  bool tmp___18 ;
  char const   *tmp___19 ;
  bool tmp___20 ;
  bool tmp___21 ;
  bool stream_ok ;
  int tmp___22 ;
  bool tmp___23 ;
  u8 *tmp___24 ;
  unsigned int strt_lineno ;
  int tmp___25 ;
  bool tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  bool tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  bool tmp___32 ;
  char const   *tmp___33 ;
  bool tmp___34 ;
  bool tmp___35 ;
  long tmp___36 ;
  char const   *tmp___37 ;
  u32 val___0 ;
  long tmp___38 ;
  bool new_pili ;
  int tmp___39 ;
  char const   *tmp___40 ;
  bool tmp___41 ;
  char const   *tmp___42 ;
  time_t tt ;
  char temp_buffr[32] ;
  struct tm *tmp___43 ;
  struct tm *tmp___44 ;
  size_t tmp___45 ;
  bool tmp___46 ;
  bool found_it ;
  bool fake_out_lineno ;
  unsigned int save_lineno ;
  unsigned int true_lineno ;
  bool tmp___47 ;
  char *tmp___48 ;

  {
#line 4361
  tok = pfield.fw_token;
#line 4364
  sav_lineno = lineno;
#line 4366
  handy_toggle = (bool )-1;
#line 4367
  handy_toggle_too = (bool )-1;
#line 4368
  handy_string = (char *)"";
#line 4369
  handy_int = 0;
  {
#line 4376
  if ((unsigned int )tok == 9U) {
#line 4376
    goto case_9;
  }
#line 4380
  if ((unsigned int )tok == 10U) {
#line 4380
    goto case_10;
  }
#line 4387
  if ((unsigned int )tok == 12U) {
#line 4387
    goto case_12;
  }
#line 4394
  if ((unsigned int )tok == 1U) {
#line 4394
    goto case_1;
  }
#line 4430
  if ((unsigned int )tok == 2U) {
#line 4430
    goto case_2;
  }
#line 4452
  if ((unsigned int )tok == 14U) {
#line 4452
    goto case_14;
  }
#line 4459
  if ((unsigned int )tok == 16U) {
#line 4459
    goto case_16;
  }
#line 4466
  if ((unsigned int )tok == 83U) {
#line 4466
    goto case_83;
  }
#line 4470
  if ((unsigned int )tok == 82U) {
#line 4470
    goto case_82;
  }
#line 4477
  if ((unsigned int )tok == 17U) {
#line 4477
    goto case_17;
  }
#line 4484
  if ((unsigned int )tok == 80U) {
#line 4484
    goto case_80;
  }
#line 4491
  if ((unsigned int )tok == 81U) {
#line 4491
    goto case_81;
  }
#line 4495
  if ((unsigned int )tok == 25U) {
#line 4495
    goto case_25;
  }
#line 4502
  if ((unsigned int )tok == 46U) {
#line 4502
    goto case_46;
  }
#line 4509
  if ((unsigned int )tok == 47U) {
#line 4509
    goto case_47;
  }
#line 4516
  if ((unsigned int )tok == 4U) {
#line 4516
    goto case_4;
  }
#line 4520
  if ((unsigned int )tok == 5U) {
#line 4520
    goto case_5;
  }
#line 4524
  if ((unsigned int )tok == 13U) {
#line 4524
    goto case_13;
  }
#line 4531
  if ((unsigned int )tok == 19U) {
#line 4531
    goto case_19;
  }
#line 4536
  if ((unsigned int )tok == 18U) {
#line 4536
    goto case_18;
  }
#line 4541
  if ((unsigned int )tok == 20U) {
#line 4541
    goto case_20;
  }
#line 4545
  if ((unsigned int )tok == 11U) {
#line 4545
    goto case_11;
  }
#line 4549
  if ((unsigned int )tok == 21U) {
#line 4549
    goto case_21;
  }
#line 4553
  if ((unsigned int )tok == 26U) {
#line 4553
    goto case_26;
  }
#line 4555
  if ((unsigned int )tok == 27U) {
#line 4555
    goto case_27;
  }
#line 4559
  if ((unsigned int )tok == 28U) {
#line 4559
    goto case_28;
  }
#line 4567
  if ((unsigned int )tok == 40U) {
#line 4567
    goto case_40;
  }
#line 4571
  if ((unsigned int )tok == 22U) {
#line 4571
    goto case_22;
  }
#line 4575
  if ((unsigned int )tok == 23U) {
#line 4575
    goto case_23;
  }
#line 4579
  if ((unsigned int )tok == 29U) {
#line 4579
    goto case_29;
  }
#line 4583
  if ((unsigned int )tok == 30U) {
#line 4583
    goto case_30;
  }
#line 4587
  if ((unsigned int )tok == 15U) {
#line 4587
    goto case_15;
  }
#line 4592
  if ((unsigned int )tok == 31U) {
#line 4592
    goto case_31;
  }
#line 4596
  if ((unsigned int )tok == 39U) {
#line 4596
    goto case_39;
  }
#line 4600
  if ((unsigned int )tok == 49U) {
#line 4600
    goto case_49;
  }
#line 4612
  if ((unsigned int )tok == 32U) {
#line 4612
    goto case_32;
  }
#line 4623
  if ((unsigned int )tok == 33U) {
#line 4623
    goto case_33;
  }
#line 4628
  if ((unsigned int )tok == 34U) {
#line 4628
    goto case_34;
  }
#line 4633
  if ((unsigned int )tok == 35U) {
#line 4633
    goto case_35;
  }
#line 4638
  if ((unsigned int )tok == 36U) {
#line 4638
    goto case_36;
  }
#line 4643
  if ((unsigned int )tok == 37U) {
#line 4643
    goto case_37;
  }
#line 4648
  if ((unsigned int )tok == 38U) {
#line 4648
    goto case_38;
  }
#line 4654
  if ((unsigned int )tok == 24U) {
#line 4654
    goto case_24;
  }
#line 4693
  if ((unsigned int )tok == 85U) {
#line 4693
    goto case_85;
  }
#line 4709
  if ((unsigned int )tok == 86U) {
#line 4709
    goto case_86;
  }
#line 4716
  if ((unsigned int )tok == 3U) {
#line 4716
    goto case_3;
  }
#line 4718
  if ((unsigned int )tok == 6U) {
#line 4718
    goto case_6;
  }
#line 4730
  if ((unsigned int )tok == 7U) {
#line 4730
    goto case_7;
  }
#line 4752
  if ((unsigned int )tok == 217U) {
#line 4752
    goto case_217;
  }
#line 4754
  if ((unsigned int )tok == 218U) {
#line 4754
    goto case_218;
  }
#line 4757
  if ((unsigned int )tok == 8U) {
#line 4757
    goto case_8;
  }
#line 4764
  if ((unsigned int )tok == 45U) {
#line 4764
    goto case_45;
  }
#line 4768
  if ((unsigned int )tok == 48U) {
#line 4768
    goto case_48;
  }
#line 4772
  if ((unsigned int )tok == 41U) {
#line 4772
    goto case_41;
  }
#line 4776
  if ((unsigned int )tok == 42U) {
#line 4776
    goto case_42;
  }
#line 4780
  if ((unsigned int )tok == 44U) {
#line 4780
    goto case_44;
  }
#line 4783
  if ((unsigned int )tok == 43U) {
#line 4783
    goto case_43;
  }
#line 4790
  if ((unsigned int )tok == 52U) {
#line 4790
    goto case_52;
  }
#line 4807
  if ((unsigned int )tok == 53U) {
#line 4807
    goto case_53;
  }
#line 4809
  if ((unsigned int )tok == 54U) {
#line 4809
    goto case_54;
  }
#line 4819
  if ((unsigned int )tok == 56U) {
#line 4819
    goto case_56;
  }
#line 4821
  if ((unsigned int )tok == 55U) {
#line 4821
    goto case_55;
  }
#line 4839
  if ((unsigned int )tok == 77U) {
#line 4839
    goto case_77;
  }
#line 4857
  if ((unsigned int )tok == 78U) {
#line 4857
    goto case_78;
  }
#line 4862
  if ((unsigned int )tok == 79U) {
#line 4862
    goto case_79;
  }
#line 4866
  if ((unsigned int )tok == 62U) {
#line 4866
    goto case_62;
  }
#line 4870
  if ((unsigned int )tok == 63U) {
#line 4870
    goto case_63;
  }
#line 4874
  if ((unsigned int )tok == 64U) {
#line 4874
    goto case_64;
  }
#line 4878
  if ((unsigned int )tok == 67U) {
#line 4878
    goto case_67;
  }
#line 4880
  if ((unsigned int )tok == 66U) {
#line 4880
    goto case_66;
  }
#line 4893
  if ((unsigned int )tok == 69U) {
#line 4893
    goto case_69;
  }
#line 4893
  if ((unsigned int )tok == 68U) {
#line 4893
    goto case_69;
  }
#line 4899
  if ((unsigned int )tok == 70U) {
#line 4899
    goto case_70;
  }
#line 4906
  if ((unsigned int )tok == 71U) {
#line 4906
    goto case_71;
  }
#line 4910
  if ((unsigned int )tok == 72U) {
#line 4910
    goto case_72;
  }
#line 4918
  if ((unsigned int )tok == 76U) {
#line 4918
    goto case_76;
  }
#line 4931
  if ((unsigned int )tok == 50U) {
#line 4931
    goto case_50;
  }
#line 4936
  if ((unsigned int )tok == 222U) {
#line 4936
    goto case_222;
  }
#line 4936
  if ((unsigned int )tok == 236U) {
#line 4936
    goto case_222;
  }
#line 4944
  if ((unsigned int )tok == 223U) {
#line 4944
    goto case_223;
  }
#line 4944
  if ((unsigned int )tok == 239U) {
#line 4944
    goto case_223;
  }
#line 4944
  if ((unsigned int )tok == 233U) {
#line 4944
    goto case_223;
  }
#line 4948
  if ((unsigned int )tok == 232U) {
#line 4948
    goto case_232;
  }
#line 4952
  if ((unsigned int )tok == 234U) {
#line 4952
    goto case_234;
  }
#line 4956
  if ((unsigned int )tok == 235U) {
#line 4956
    goto case_235;
  }
#line 4960
  if ((unsigned int )tok == 216U) {
#line 4960
    goto case_216;
  }
#line 4966
  if ((unsigned int )tok == 255U) {
#line 4966
    goto case_255;
  }
#line 4966
  if ((unsigned int )tok == 215U) {
#line 4966
    goto case_255;
  }
#line 4976
  if ((unsigned int )tok == 58U) {
#line 4976
    goto case_58;
  }
#line 4984
  if ((unsigned int )tok == 57U) {
#line 4984
    goto case_57;
  }
#line 4991
  if ((unsigned int )tok == 59U) {
#line 4991
    goto case_59;
  }
#line 5003
  if ((unsigned int )tok == 60U) {
#line 5003
    goto case_60;
  }
#line 5013
  if ((unsigned int )tok == 61U) {
#line 5013
    goto case_61;
  }
#line 5044
  if ((unsigned int )tok == 228U) {
#line 5044
    goto case_228;
  }
#line 5048
  if ((unsigned int )tok == 229U) {
#line 5048
    goto case_229;
  }
#line 5054
  if ((unsigned int )tok == 227U) {
#line 5054
    goto case_227;
  }
#line 5063
  if ((unsigned int )tok == 224U) {
#line 5063
    goto case_224;
  }
#line 5065
  if ((unsigned int )tok == 225U) {
#line 5065
    goto case_225;
  }
#line 5067
  if ((unsigned int )tok == 226U) {
#line 5067
    goto case_226;
  }
#line 5082
  if ((unsigned int )tok == 231U) {
#line 5082
    goto case_231;
  }
#line 5092
  if ((unsigned int )tok == 230U) {
#line 5092
    goto case_230;
  }
#line 5104
  if ((unsigned int )tok == 238U) {
#line 5104
    goto case_238;
  }
#line 5106
  if ((unsigned int )tok == 237U) {
#line 5106
    goto case_237;
  }
#line 5128
  if ((unsigned int )tok == 221U) {
#line 5128
    goto case_221;
  }
#line 5135
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 4377
  emit_begin();
  }
#line 4378
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 4381
  tmp = create_word(tok);
  }
#line 4381
  if (tmp) {
    {
#line 4383
    emit_token("b(buffer:)");
    }
  }
#line 4385
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 4388
  tmp___0 = create_word(tok);
  }
#line 4388
  if (tmp___0) {
    {
#line 4390
    emit_token("b(constant)");
    }
  }
#line 4392
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 4400
  maybe_last_colon_fcode = nextfcode;
#line 4401
  maybe_last_colon_lineno = lineno;
#line 4402
  maybe_last_colon_abs_token_no = abs_token_no;
#line 4403
  maybe_last_colon_do_depth = (unsigned int )do_loop_depth;
#line 4408
  tmp___1 = create_word(tok);
  }
#line 4408
  if (tmp___1) {
    {
#line 4410
    last_colon_fcode = maybe_last_colon_fcode;
#line 4411
    last_colon_lineno = maybe_last_colon_lineno;
#line 4412
    last_colon_abs_token_no = maybe_last_colon_abs_token_no;
#line 4413
    last_colon_do_depth = maybe_last_colon_do_depth;
#line 4414
    collect_input_filename(& last_colon_filename);
    }
#line 4416
    if ((unsigned long )last_colon_defname != (unsigned long )((void *)0)) {
      {
#line 4418
      free((void *)last_colon_defname);
      }
    }
    {
#line 4420
    last_colon_defname = strdup((char const   *)statbuf);
#line 4422
    emit_token("b(:)");
#line 4423
    incolon = (bool )-1;
#line 4424
    hide_last_colon();
#line 4425
    lastcolon = (int )opc;
    }
  }
#line 4428
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 4431
  tmp___2 = test_in_colon((char *)"SEMICOLON", (bool )-1, 67108864, (char *)((void *)0));
  }
#line 4431
  if (tmp___2) {
    {
#line 4433
    ret_stk_balance_rpt((char *)"termination,", (bool )-1);
#line 4437
    clear_control_structs_to_limit((char *)"End of colon-definition", last_colon_abs_token_no);
    }
#line 4440
    if (ibm_locals) {
      {
#line 4442
      finish_locals();
#line 4443
      forget_locals();
      }
    }
    {
#line 4446
    emit_token("b(;)");
#line 4447
    incolon = (bool )0;
#line 4448
    reveal_last_colon();
    }
  }
#line 4450
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 4453
  tmp___3 = create_word(tok);
  }
#line 4453
  if (tmp___3) {
    {
#line 4455
    emit_token("b(create)");
    }
  }
#line 4457
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 4460
  tmp___4 = create_word(tok);
  }
#line 4460
  if (tmp___4) {
    {
#line 4462
    emit_token("b(defer)");
    }
  }
#line 4464
  goto switch_break;
  case_83: /* CIL Label */ 
#line 4467
  report_multiline = (bool )0;
#line 4468
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 4471
  tmp___5 = test_in_colon((char *)statbuf, (bool )0, 2097152, (char *)((void *)0));
  }
#line 4471
  if (tmp___5) {
#line 4473
    do_not_overload = (bool )0;
  }
#line 4475
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 4478
  tmp___6 = get_word_in_line((char *)statbuf);
  }
#line 4478
  if (tmp___6) {
    {
#line 4480
    eval_user_symbol((char *)statbuf);
    }
  }
#line 4482
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 4485
  tmp___7 = get_word_in_line((char *)statbuf);
  }
#line 4485
  if (tmp___7) {
    {
#line 4487
    set_cl_flag((char *)statbuf, (bool )-1);
    }
  }
#line 4489
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 4492
  show_all_cl_flag_settings((bool )-1);
  }
#line 4493
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 4496
  tmp___8 = create_word(tok);
  }
#line 4496
  if (tmp___8) {
    {
#line 4498
    emit_token("b(field)");
    }
  }
#line 4500
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 4503
  tmp___9 = create_word(tok);
  }
#line 4503
  if (tmp___9) {
    {
#line 4505
    emit_token("b(value)");
    }
  }
#line 4507
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 4510
  tmp___10 = create_word(tok);
  }
#line 4510
  if (tmp___10) {
    {
#line 4512
    emit_token("b(variable)");
    }
  }
#line 4514
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 4517
  emit_again();
  }
#line 4518
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 4521
  create_alias();
  }
#line 4522
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 4525
  tmp___11 = get_word_in_line((char *)statbuf);
  }
#line 4525
  if (tmp___11) {
    {
#line 4527
    emit_literal((u32 )((int )*(statbuf + 0) & 31));
    }
  }
#line 4529
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 4532
  emit_token("b(do)");
#line 4533
  mark_do();
  }
#line 4534
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 4537
  emit_token("b(?do)");
#line 4538
  mark_do();
  }
#line 4539
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 4542
  emit_else();
  }
#line 4543
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 4546
  emit_case();
  }
#line 4547
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 4550
  emit_endcase();
  }
#line 4551
  goto switch_break;
  case_26: /* CIL Label */ 
#line 4554
  handy_toggle = (bool )0;
  case_27: /* CIL Label */ 
  {
#line 4556
  finish_or_new_device(handy_toggle);
  }
#line 4557
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 4562
  tmp___12 = dpop();
#line 4562
  val = (u32 )tmp___12;
#line 4563
  emit_literal(val);
  }
#line 4565
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 4568
  emit_of();
  }
#line 4569
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 4572
  emit_endof();
  }
#line 4573
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 4576
  set_hdr_flag((headeredness )1);
  }
#line 4577
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 4580
  set_hdr_flag((headeredness )0);
  }
#line 4581
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 4584
  set_hdr_flag((headeredness )2);
  }
#line 4585
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 4589
  base_change(10);
  }
#line 4590
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 4593
  base_change(16);
  }
#line 4594
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 4597
  base_change(8);
  }
#line 4598
  goto switch_break;
  case_49: /* CIL Label */ 
#line 4601
  if (! offs16) {
    {
#line 4603
    tokenization_error(65536, (char *)"Switching to 16-bit offsets.\n");
    }
  } else {
    {
#line 4605
    tokenization_error(2097152, (char *)"Call of OFFSET16 is redundant.\n");
    }
  }
  {
#line 4608
  emit_token("offset16");
#line 4609
  offs16 = (bool )-1;
  }
#line 4610
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 4613
  emit_if();
  }
#line 4614
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 4624
  emit_token("unloop");
#line 4625
  must_be_deep_in_do(1);
  }
#line 4626
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 4629
  emit_token("b(leave)");
#line 4630
  must_be_deep_in_do(1);
  }
#line 4631
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 4634
  emit_token("i");
#line 4635
  must_be_deep_in_do(1);
  }
#line 4636
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 4639
  emit_token("j");
#line 4640
  must_be_deep_in_do(2);
  }
#line 4641
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 4644
  emit_token("b(loop)");
#line 4645
  resolve_loop();
  }
#line 4646
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 4649
  emit_token("b(+loop)");
#line 4650
  resolve_loop();
  }
#line 4651
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 4656
  set_instance_state = (bool )0;
#line 4657
  emit_instance = (bool )-1;
#line 4663
  tmp___13 = test_in_colon((char *)statbuf, (bool )0, 67108864, (char *)((void *)0));
  }
#line 4663
  if (tmp___13) {
#line 4666
    if (scope_is_global) {
      {
#line 4668
      glob_not_allowed(2097152, (bool )0);
#line 4669
      emit_instance = (bool )0;
      }
    } else {
#line 4671
      set_instance_state = (bool )-1;
    }
  }
#line 4674
  if (emit_instance) {
#line 4676
    if (set_instance_state) {
#line 4679
      if (is_instance) {
        {
#line 4681
        unresolved_instance(2097152);
        }
      }
      {
#line 4683
      collect_input_filename(& instance_filename);
#line 4684
      instance_lineno = lineno;
#line 4685
      is_instance = (bool )-1;
#line 4686
      dev_change_instance_warning = (bool )-1;
      }
    }
    {
#line 4688
    emit_token("instance");
    }
  }
#line 4691
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 4694
  tmp___15 = test_in_colon((char *)statbuf, (bool )0, 67108864, (char *)((void *)0));
  }
#line 4694
  if (tmp___15) {
#line 4696
    if (is_instance) {
#line 4696
      tmp___14 = 0;
    } else {
#line 4696
      tmp___14 = -1;
    }
#line 4696
    if (tmp___14) {
      {
#line 4698
      enter_global_scope();
      }
    } else {
      {
#line 4700
      tokenization_error(67108864, (char *)"Global Scope not allowed.  \"Instance\" is in effect; issued");
#line 4703
      just_where_started(instance_filename, instance_lineno);
      }
    }
  }
#line 4707
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 4710
  tmp___16 = test_in_colon((char *)statbuf, (bool )0, 67108864, (char *)((void *)0));
  }
#line 4710
  if (tmp___16) {
    {
#line 4712
    resume_device_scope();
    }
  }
#line 4714
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 4717
  test_in_colon((char *)statbuf, (bool )0, 2097152, (char *)"[\']");
  }
  case_6: /* CIL Label */ 
  {
#line 4721
  tmp___17 = get_token(& token_entry);
  }
#line 4721
  if (tmp___17) {
    {
#line 4723
    emit_token("b(\')");
#line 4725
    (*(token_entry->funct))(token_entry->pfield);
    }
  }
#line 4728
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 4737
  tmp___18 = get_token(& token_entry___0);
  }
#line 4737
  if (tmp___18) {
    {
#line 4740
    token_entry_warning(token_entry___0);
    }
#line 4742
    if (in_tokz_esc) {
      {
#line 4744
      dpush(token_entry___0->pfield.deflt_elem);
      }
    } else {
      {
#line 4746
      emit_literal((u32 )token_entry___0->pfield.deflt_elem);
      }
    }
  }
#line 4750
  goto switch_break;
  case_217: /* CIL Label */ 
#line 4753
  handy_toggle = (bool )0;
  case_218: /* CIL Label */ 
#line 4755
  if (handy_toggle) {
#line 4755
    tmp___19 = "CHAR";
  } else {
#line 4755
    tmp___19 = "[CHAR]";
  }
  {
#line 4755
  test_in_colon((char *)statbuf, handy_toggle, 2097152, (char *)tmp___19);
  }
  case_8: /* CIL Label */ 
  {
#line 4758
  tmp___20 = get_word_in_line((char *)statbuf);
  }
#line 4758
  if (tmp___20) {
    {
#line 4760
    emit_literal((u32 )*(statbuf + 0));
    }
  }
#line 4762
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 4765
  emit_until();
  }
#line 4766
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 4769
  emit_while();
  }
#line 4770
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 4773
  emit_repeat();
  }
#line 4774
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 4777
  emit_then();
  }
#line 4778
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 4781
  tokenization_error(65536, (char *)"Substituting  TO  for deprecated  IS\n");
  }
  case_43: /* CIL Label */ 
  {
#line 4784
  tmp___21 = validate_to_target();
  }
#line 4784
  if (tmp___21) {
    {
#line 4786
    emit_token("b(to)");
    }
  }
#line 4788
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 4791
  tmp___23 = get_word_in_line((char *)statbuf);
  }
#line 4791
  if (tmp___23) {
    {
#line 4795
    push_source((void (*)())(& close_stream), (void *)0, (bool )-1);
#line 4797
    tokenization_error(65536, (char *)"FLOADing %s\n", statbuf);
#line 4799
    stream_ok = init_stream((char const   *)statbuf);
    }
#line 4800
    if (stream_ok) {
#line 4800
      tmp___22 = 0;
    } else {
#line 4800
      tmp___22 = -1;
    }
#line 4800
    if (tmp___22) {
      {
#line 4802
      drop_source();
      }
    }
  }
#line 4805
  goto switch_break;
  case_53: /* CIL Label */ 
#line 4808
  handy_toggle = (bool )0;
  case_54: /* CIL Label */ 
  {
#line 4810
  wlen = get_string___0((bool )-1);
#line 4811
  emit_token("b(\")");
#line 4812
  emit_string(statbuf, (int )wlen);
  }
#line 4813
  if (handy_toggle) {
    {
#line 4815
    emit_token("type");
    }
  }
#line 4817
  goto switch_break;
  case_56: /* CIL Label */ 
#line 4820
  handy_toggle = (bool )0;
  case_55: /* CIL Label */ 
#line 4822
  tmp___24 = pc;
#line 4822
  pc ++;
#line 4822
  if ((int )*tmp___24 == 10) {
#line 4822
    lineno ++;
  }
#line 4824
  strt_lineno = lineno;
#line 4825
  if (handy_toggle) {
#line 4825
    tmp___25 = ')';
  } else {
#line 4825
    tmp___25 = '\"';
  }
  {
#line 4825
  wlen = get_until((char )tmp___25);
#line 4826
  tmp___26 = string_err_check(handy_toggle, sav_lineno, strt_lineno);
  }
#line 4826
  if (tmp___26) {
    {
#line 4829
    emit_token("b(\")");
#line 4830
    emit_string(statbuf, (int )wlen);
    }
#line 4831
    if (handy_toggle) {
      {
#line 4833
      emit_token("type");
      }
    }
  }
#line 4837
  goto switch_break;
  case_77: /* CIL Label */ 
#line 4840
  if (in_tokz_esc) {
#line 4842
    if (incolon) {
      {
#line 4844
      tokenization_error(64, (char *)"Currently");
      }
    } else {
      {
#line 4846
      tokenization_error(64, (char *)"After");
      }
    }
    {
#line 4848
    in_last_colon(incolon);
    }
  } else {
    {
#line 4850
    emit_token("b(\")");
#line 4851
    tmp___27 = strlen((char const   *)last_colon_defname);
#line 4851
    emit_string((u8 *)last_colon_defname, (int )tmp___27);
    }
  }
#line 4855
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 4858
  emit_token("b(\")");
#line 4859
  tmp___28 = strlen((char const   *)iname);
#line 4859
  emit_string((u8 *)iname, (int )tmp___28);
  }
#line 4860
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 4863
  emit_literal(lineno);
  }
#line 4864
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 4867
  base_val(16);
  }
#line 4868
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 4871
  base_val(10);
  }
#line 4872
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 4875
  base_val(8);
  }
#line 4876
  goto switch_break;
  case_67: /* CIL Label */ 
#line 4879
  handy_toggle = (bool )0;
  case_66: /* CIL Label */ 
  {
#line 4881
  tmp___29 = get_word_in_line((char *)statbuf);
  }
#line 4881
  if (tmp___29) {
#line 4883
    if (handy_toggle) {
      {
#line 4885
      ascii_right_number((char *)statbuf);
      }
    } else {
      {
#line 4887
      ascii_left_number((char *)statbuf);
      }
    }
  }
#line 4890
  goto switch_break;
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  {
#line 4894
  tmp___30 = strupper((char *)statbuf);
#line 4894
  tokenization_error(67108864, (char *)"No conditional preceding %s directive\n",
                     tmp___30);
  }
#line 4897
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 4900
  tokenization_error(65536, (char *)"FCode-token Assignment Counter of 0x%x has been saved on stack.\n",
                     (int )nextfcode);
#line 4903
  dpush((long )nextfcode);
  }
#line 4904
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 4907
  pop_next_fcode();
  }
#line 4908
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 4911
  tmp___31 = strupper((char *)statbuf);
#line 4911
  tokenization_error(65536, (char *)"Encountered %s.  Resetting FCode-token Assignment Counter.  ",
                     tmp___31);
#line 4914
  list_fcode_ranges((bool )0);
#line 4915
  reset_fcode_ranges();
  }
#line 4916
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 4919
  tmp___32 = test_in_colon((char *)statbuf, (bool )-1, 67108864, (char *)((void *)0));
  }
#line 4919
  if (tmp___32) {
#line 4919
    goto _L;
  } else
#line 4919
  if (noerrors) {
    _L: /* CIL Label */ 
    {
#line 4922
    ret_stk_balance_rpt((char *)((void *)0), (bool )0);
    }
#line 4923
    if (ibm_locals) {
      {
#line 4925
      finish_locals();
      }
    }
    {
#line 4927
    emit_token("exit");
    }
  }
#line 4929
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 4932
  enter_tokz_esc();
  }
#line 4933
  goto switch_break;
  case_222: /* CIL Label */ 
  case_236: /* CIL Label */ 
  {
#line 4937
  fcode_starter("version1", 1, (bool )0);
#line 4938
  tokenization_error(65536, (char *)"Using version1 header (8-bit offsets).\n");
  }
#line 4940
  goto switch_break;
  case_223: /* CIL Label */ 
  case_239: /* CIL Label */ 
  case_233: /* CIL Label */ 
  {
#line 4945
  fcode_starter("start1", 1, (bool )-1);
  }
#line 4946
  goto switch_break;
  case_232: /* CIL Label */ 
  {
#line 4949
  fcode_starter("start0", 0, (bool )-1);
  }
#line 4950
  goto switch_break;
  case_234: /* CIL Label */ 
  {
#line 4953
  fcode_starter("start2", 2, (bool )-1);
  }
#line 4954
  goto switch_break;
  case_235: /* CIL Label */ 
  {
#line 4957
  fcode_starter("start4", 4, (bool )-1);
  }
#line 4958
  goto switch_break;
  case_216: /* CIL Label */ 
  {
#line 4961
  tokenization_error(2097152, (char *)"Appearance of END1 in FCode source code is not intended by IEEE 1275-1994\n");
#line 4964
  handy_toggle = (bool )0;
  }
  case_255: /* CIL Label */ 
  case_215: /* CIL Label */ 
#line 4967
  if (handy_toggle) {
    {
#line 4969
    you_are_here();
    }
  }
#line 4971
  if (handy_toggle) {
#line 4971
    tmp___33 = "end0";
  } else {
#line 4971
    tmp___33 = "end1";
  }
  {
#line 4971
  emit_token(tmp___33);
#line 4972
  fcode_ender();
#line 4973
  fflush(stdout);
  }
#line 4974
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 4977
  tmp___34 = test_in_colon((char *)statbuf, (bool )-1, 67108864, (char *)((void *)0));
  }
#line 4977
  if (tmp___34) {
    {
#line 4979
    emit_fcode(last_colon_fcode);
    }
  }
#line 4981
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 4985
  tmp___35 = test_in_colon((char *)statbuf, (bool )-1, 67108864, (char *)((void *)0));
  }
#line 4985
  if (tmp___35) {
    {
#line 4987
    reveal_last_colon();
    }
  }
#line 4989
  goto switch_break;
  case_59: /* CIL Label */ 
#line 4997
  handy_string = (char *)"r@";
#line 5002
  handy_toggle = (bool )0;
  case_60: /* CIL Label */ 
#line 5004
  if (handy_toggle) {
#line 5006
    handy_string = (char *)"r>";
#line 5010
    handy_int = -1;
#line 5011
    handy_toggle = (bool )0;
  }
  case_61: /* CIL Label */ 
#line 5014
  if (handy_toggle) {
#line 5016
    handy_string = (char *)">r";
#line 5018
    handy_toggle_too = (bool )0;
#line 5020
    handy_int = 1;
  }
#line 5025
  handy_toggle = allow_ret_stk_interp;
#line 5026
  if (! handy_toggle) {
    {
#line 5028
    handy_toggle = test_in_colon((char *)statbuf, (bool )-1, 67108864, (char *)((void *)0));
    }
  }
#line 5030
  if (handy_toggle) {
#line 5030
    goto _L___0;
  } else
#line 5030
  if (noerrors) {
    _L___0: /* CIL Label */ 
#line 5032
    if (handy_toggle_too) {
      {
#line 5034
      ret_stk_access_rpt();
      }
    }
#line 5036
    if (handy_int != 0) {
      {
#line 5038
      bump_ret_stk_depth(handy_int);
      }
    }
    {
#line 5040
    emit_token((char const   *)handy_string);
    }
  }
#line 5042
  goto switch_break;
  case_228: /* CIL Label */ 
  {
#line 5045
  emit_pcihdr();
  }
#line 5046
  goto switch_break;
  case_229: /* CIL Label */ 
  {
#line 5049
  finish_pcihdr();
#line 5050
  reset_fcode_ranges();
#line 5051
  fflush(stdout);
  }
#line 5052
  goto switch_break;
  case_227: /* CIL Label */ 
  {
#line 5055
  tmp___36 = dpop();
#line 5055
  pci_image_rev = (u16 )tmp___36;
  }
#line 5056
  if (big_end_pci_image_rev) {
#line 5056
    tmp___37 = ".  Will be saved in Big-Endian format.";
  } else {
#line 5056
    tmp___37 = "";
  }
  {
#line 5056
  tokenization_error(65536, (char *)"PCI header revision=0x%04x%s\n", (int )pci_image_rev,
                     tmp___37);
  }
#line 5061
  goto switch_break;
  case_224: /* CIL Label */ 
#line 5064
  handy_toggle = (bool )0;
  case_225: /* CIL Label */ 
  {
#line 5066
  dpush((long )handy_toggle);
  }
  case_226: /* CIL Label */ 
  {
#line 5069
  tmp___38 = dpop();
#line 5069
  val___0 = (u32 )tmp___38;
  }
#line 5070
  if (val___0 != 0U) {
#line 5070
    tmp___39 = -1;
  } else {
#line 5070
    tmp___39 = 0;
  }
#line 5070
  new_pili = (bool )tmp___39;
#line 5071
  if ((int )pci_is_last_image != (int )new_pili) {
#line 5073
    if (new_pili) {
#line 5073
      tmp___40 = "Last image for PCI header.\n";
    } else {
#line 5073
      tmp___40 = "PCI header not last image.\n";
    }
    {
#line 5073
    tokenization_error(65536, (char *)tmp___40);
#line 5077
    pci_is_last_image = new_pili;
    }
  }
#line 5080
  goto switch_break;
  case_231: /* CIL Label */ 
  {
#line 5083
  tmp___41 = get_word_in_line((char *)statbuf);
  }
#line 5083
  if (tmp___41) {
    {
#line 5085
    free((void *)oname);
#line 5086
    oname = strdup((char const   *)statbuf);
#line 5087
    tokenization_error(65536, (char *)"Output is redirected to file:  %s\n", oname);
    }
  }
#line 5090
  goto switch_break;
  case_230: /* CIL Label */ 
#line 5093
  if (in_tokz_esc) {
#line 5093
    tmp___42 = "tokenizer-escape";
  } else {
#line 5093
    tmp___42 = "\"normal\"";
  }
  {
#line 5093
  tokenization_error(65536, (char *)"Resetting symbols defined in %s mode.\n", tmp___42);
  }
#line 5096
  if (in_tokz_esc) {
    {
#line 5098
    reset_tokz_esc();
    }
  } else {
    {
#line 5100
    reset_normal_vocabs();
    }
  }
#line 5102
  goto switch_break;
  case_238: /* CIL Label */ 
#line 5105
  handy_toggle = (bool )0;
  case_237: /* CIL Label */ 
  {
#line 5111
  tt = time((time_t *)((void *)0));
  }
#line 5112
  if (handy_toggle) {
    {
#line 5114
    tmp___43 = localtime((time_t const   *)(& tt));
#line 5114
    strftime((char */* __restrict  */)(temp_buffr), (size_t )32, (char const   */* __restrict  */)"%T %Z",
             (struct tm  const  */* __restrict  */)tmp___43);
    }
  } else {
    {
#line 5116
    tmp___44 = localtime((time_t const   *)(& tt));
#line 5116
    strftime((char */* __restrict  */)(temp_buffr), (size_t )32, (char const   */* __restrict  */)"%m/%d/%Y",
             (struct tm  const  */* __restrict  */)tmp___44);
    }
  }
#line 5118
  if (in_tokz_esc) {
    {
#line 5120
    tokenization_error(2048, temp_buffr);
    }
  } else {
    {
#line 5122
    emit_token("b(\")");
#line 5123
    tmp___45 = strlen((char const   *)(temp_buffr));
#line 5123
    emit_string((u8 *)(temp_buffr), (int )tmp___45);
    }
  }
#line 5126
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 5129
  tmp___46 = get_word_in_line((char *)statbuf);
  }
#line 5129
  if (tmp___46) {
    {
#line 5131
    encode_file((char const   *)((char *)statbuf));
    }
  }
#line 5133
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5137
  if (ibm_locals) {
#line 5139
    found_it = (bool )-1;
    {
#line 5141
    if ((unsigned int )tok == 73U) {
#line 5141
      goto case_73;
    }
#line 5144
    if ((unsigned int )tok == 74U) {
#line 5144
      goto case_74;
    }
#line 5147
    goto switch_default___0;
    case_73: /* CIL Label */ 
    {
#line 5142
    declare_locals((bool )0);
    }
#line 5143
    goto switch_break___0;
    case_74: /* CIL Label */ 
    {
#line 5145
    assign_local();
    }
#line 5146
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 5148
    found_it = (bool )0;
    switch_break___0: /* CIL Label */ ;
    }
#line 5150
    if (found_it) {
#line 5150
      goto switch_break;
    }
  }
  {
#line 5163
  fake_out_lineno = (bool )0;
#line 5164
  save_lineno = lineno;
#line 5166
  tmp___47 = abort_quote(tok);
  }
#line 5166
  if (tmp___47) {
#line 5167
    goto switch_break;
  } else
#line 5169
  if ((unsigned int )tok == 219U) {
#line 5169
    fake_out_lineno = (bool )-1;
  }
#line 5171
  true_lineno = lineno;
#line 5173
  if (fake_out_lineno) {
#line 5173
    lineno = save_lineno;
  }
  {
#line 5174
  tmp___48 = strupper((char *)statbuf);
#line 5174
  tokenization_error(67108864, (char *)"Unimplemented control word \'%s\'\n", tmp___48);
  }
#line 5176
  if (fake_out_lineno) {
#line 5176
    lineno = true_lineno;
  }
  switch_break: /* CIL Label */ ;
  }
#line 5179
  return;
}
}
#line 5220
void skip_string(tic_param_t pfield ) ;
#line 5221 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void skip_string(tic_param_t pfield ) 
{ 
  fwtoken tok ;
  unsigned int sav_lineno ;
  bool handy_toggle ;
  u8 *tmp ;
  unsigned int strt_lineno ;
  int tmp___0 ;
  bool found_it ;
  char *tmp___1 ;

  {
#line 5223
  tok = pfield.fw_token;
#line 5224
  sav_lineno = lineno;
#line 5225
  handy_toggle = (bool )-1;
  {
#line 5230
  if ((unsigned int )tok == 219U) {
#line 5230
    goto case_219;
  }
#line 5230
  if ((unsigned int )tok == 54U) {
#line 5230
    goto case_219;
  }
#line 5230
  if ((unsigned int )tok == 53U) {
#line 5230
    goto case_219;
  }
#line 5235
  if ((unsigned int )tok == 56U) {
#line 5235
    goto case_56;
  }
#line 5237
  if ((unsigned int )tok == 55U) {
#line 5237
    goto case_55;
  }
#line 5246
  goto switch_default;
  case_219: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  {
#line 5231
  get_string___0((bool )0);
  }
#line 5233
  goto switch_break;
  case_56: /* CIL Label */ 
#line 5236
  handy_toggle = (bool )0;
  case_55: /* CIL Label */ 
#line 5238
  tmp = pc;
#line 5238
  pc ++;
#line 5238
  if ((int )*tmp == 10) {
#line 5238
    lineno ++;
  }
#line 5240
  strt_lineno = lineno;
#line 5241
  if (handy_toggle) {
#line 5241
    tmp___0 = ')';
  } else {
#line 5241
    tmp___0 = '\"';
  }
  {
#line 5241
  get_until((char )tmp___0);
#line 5242
  string_err_check(handy_toggle, sav_lineno, strt_lineno);
  }
#line 5244
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5248
  if (ibm_locals) {
#line 5250
    found_it = (bool )-1;
    {
#line 5252
    if ((unsigned int )tok == 73U) {
#line 5252
      goto case_73;
    }
#line 5255
    if ((unsigned int )tok == 74U) {
#line 5255
      goto case_74;
    }
#line 5258
    goto switch_default___0;
    case_73: /* CIL Label */ 
    {
#line 5253
    declare_locals((bool )-1);
    }
#line 5254
    goto switch_break___0;
    case_74: /* CIL Label */ 
    {
#line 5256
    get_word();
    }
#line 5257
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 5259
    found_it = (bool )0;
    switch_break___0: /* CIL Label */ ;
    }
#line 5261
    if (found_it) {
#line 5261
      goto switch_break;
    }
  }
  {
#line 5264
  tmp___1 = strupper((char *)statbuf);
#line 5264
  tokenization_error((-0x7FFFFFFF-1), (char *)"Program Error.  Unimplemented skip-string word \'%s\'\n",
                     tmp___1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 5267
  return;
}
}
#line 5296 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void process_remark(tic_param_t pfield ) 
{ 
  char until_char ;
  unsigned int start_lineno ;
  bool tmp ;

  {
  {
#line 5298
  until_char = (char )pfield.deflt_elem;
#line 5299
  start_lineno = lineno;
#line 5308
  tmp = skip_until(until_char);
  }
#line 5308
  if (tmp) {
#line 5310
    if ((int )until_char == 10) {
      {
#line 5313
      tokenization_error(2097152, (char *)"Unterminated remark.\n");
      }
    } else {
      {
#line 5316
      warn_unterm(2097152, (char *)"comment", start_lineno);
      }
    }
  } else
#line 5319
  if ((int )until_char != 10) {
    {
#line 5321
    pc ++;
#line 5322
    warn_if_multiline((char *)"comment", start_lineno);
    }
  }
#line 5326
  return;
}
}
#line 5357 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
bool filter_comments(u8 *inword ) 
{ 
  bool retval ;
  tic_hdr_t *found ;
  tic_hdr_t *tmp ;

  {
  {
#line 5359
  retval = (bool )0;
#line 5360
  tmp = lookup_word((char *)inword, (char **)((void *)0), (char **)((void *)0));
#line 5360
  found = tmp;
  }
#line 5362
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 5364
    if ((unsigned long )found->funct == (unsigned long )(& process_remark)) {
      {
#line 5366
      (*(found->funct))(found->pfield);
#line 5367
      retval = (bool )-1;
      }
    } else
#line 5370
    if ((unsigned long )found->funct == (unsigned long )(& handle_internal)) {
#line 5372
      if ((unsigned int )found->pfield.fw_token == 83U) {
        {
#line 5375
        (*(found->funct))(found->pfield);
#line 5376
        retval = (bool )-1;
        }
      }
    }
  }
#line 5381
  return (retval);
}
}
#line 5444 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void tokenize_one_word(long wlen ) 
{ 
  tic_hdr_t *found ;
  tic_hdr_t *tmp ;
  bool tmp___0 ;

  {
  {
#line 5448
  tmp = lookup_word((char *)statbuf, (char **)((void *)0), (char **)((void *)0));
#line 5448
  found = tmp;
  }
#line 5450
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 5452
    tic_found = found;
#line 5453
    if (found->tracing) {
      {
#line 5455
      invoking_traced_name(found);
      }
    }
    {
#line 5457
    (*(found->funct))(found->pfield);
    }
#line 5458
    return;
  }
  {
#line 5464
  tmp___0 = handle_number();
  }
#line 5464
  if (tmp___0) {
#line 5466
    return;
  }
  {
#line 5470
  tokenized_word_error((char *)statbuf);
  }
#line 5471
  return;
}
}
#line 5487 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/scanner.c"
void tokenize(void) 
{ 
  long wlen ;

  {
#line 5489
  wlen = 0L;
  {
#line 5491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5491
    if (! (wlen >= 0L)) {
#line 5491
      goto while_break;
    }
    {
#line 5493
    wlen = get_word();
    }
#line 5494
    if (wlen > 0L) {
      {
#line 5496
      tokenize_one_word(wlen);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5499
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.h"
unsigned int pci_hdr_end_ob_off ;
#line 113
void user_emit_byte(u8 data ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
unsigned int opc  =    0U;
#line 84 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
unsigned int pci_hdr_end_ob_off  =    0U;
#line 109 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static int fcode_start_ob_off  =    -1;
#line 110 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static int fcode_hdr_ob_off  =    -1;
#line 111 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static int fcode_body_ob_off  =    -1;
#line 112 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static int pci_hdr_ob_off  =    -1;
#line 113 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static int pci_data_blk_ob_off  =    -1;
#line 123 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static bool fcode_written  =    (bool )0;
#line 149 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void init_emit(void) 
{ 


  {
#line 151
  fcode_start_ob_off = -1;
#line 152
  fcode_hdr_ob_off = -1;
#line 153
  fcode_body_ob_off = -1;
#line 154
  pci_hdr_ob_off = -1;
#line 155
  pci_data_blk_ob_off = -1;
#line 156
  opc = 0U;
#line 157
  pci_hdr_end_ob_off = 0U;
#line 158
  fcode_written = (bool )0;
#line 159
  haveend = (bool )0;
#line 160
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static void emit_byte(u8 data ) 
{ 


  {
#line 175
  if (opc == olen) {
    {
#line 177
    increase_output_buffer();
    }
  }
#line 181
  *(ostart + opc) = data;
#line 182
  opc ++;
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void emit_fcode(u16 tok ) 
{ 


  {
#line 187
  if ((int )tok >> 8) {
    {
#line 188
    emit_byte((u8 )((int )tok >> 8));
    }
  }
  {
#line 190
  emit_byte((u8 )((int )tok & 255));
#line 191
  fcode_written = (bool )-1;
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static void emit_num32(u32 num ) 
{ 


  {
  {
#line 196
  emit_byte((u8 )(num >> 24));
#line 197
  emit_byte((u8 )((num >> 16) & 255U));
#line 198
  emit_byte((u8 )((num >> 8) & 255U));
#line 199
  emit_byte((u8 )(num & 255U));
  }
#line 201
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void user_emit_byte(u8 data ) 
{ 


  {
  {
#line 214
  emit_byte(data);
#line 215
  fcode_written = (bool )-1;
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void emit_offset(s16 offs ) 
{ 


  {
#line 221
  if (offs16) {
    {
#line 222
    emit_byte((u8 )((int )offs >> 8));
    }
  }
  {
#line 223
  emit_byte((u8 )((int )offs & 255));
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void emit_literal(u32 num ) 
{ 


  {
  {
#line 228
  emit_token("b(lit)");
#line 229
  emit_num32(num);
  }
#line 230
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void emit_string(u8 *string , int cnt ) 
{ 
  int i ;
  int cnt_cpy ;

  {
#line 234
  i = 0;
#line 235
  cnt_cpy = cnt;
#line 237
  if (cnt_cpy > 255) {
    {
#line 239
    tokenization_error(67108864, (char *)"String too long:  %d characters.  Truncating.\n",
                       cnt);
#line 241
    cnt_cpy = 255;
    }
  }
  {
#line 243
  emit_byte((u8 )cnt_cpy);
#line 244
  i = 0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < cnt_cpy)) {
#line 244
      goto while_break;
    }
    {
#line 245
    emit_byte(*(string + i));
#line 244
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void emit_fcodehdr(char const   *starter_name ) 
{ 
  fcode_header_t *fcode_hdr ;
  int j ;

  {
#line 252
  if (fcode_written) {
    {
#line 254
    tokenization_error(67108864, (char *)"Cannot create FCode header after FCode output has begun.\n");
    }
#line 256
    if (! noerrors) {
#line 256
      return;
    }
  }
  {
#line 261
  fcode_start_ob_off = (int )opc;
#line 262
  emit_token(starter_name);
#line 264
  fcode_hdr_ob_off = (int )opc;
#line 265
  fcode_hdr = (fcode_header_t *)(ostart + fcode_hdr_ob_off);
#line 267
  j = 0;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((unsigned long )j < sizeof(fcode_header_t ))) {
#line 267
      goto while_break;
    }
    {
#line 267
    emit_byte((u8 )0);
#line 267
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  fcode_body_ob_off = (int )opc;
#line 272
  fcode_hdr->format = (u8 )8;
#line 274
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void finish_fcodehdr(void) 
{ 
  u16 checksum ;
  int length ;
  u8 *fcode_body ;
  u8 *ob_end ;
  fcode_header_t *fcode_hdr ;
  u8 *tmp ;

  {
#line 300
  if (fcode_hdr_ob_off == -1) {
    {
#line 302
    tokenization_error(67108864, (char *)"Missing FCode header.\n");
    }
#line 304
    return;
  }
#line 308
  if (! haveend) {
    {
#line 310
    tokenization_error(2097152, (char *)"End-of-file encountered without END0 or FCODE-END.  Supplying END0\n");
#line 313
    emit_token("end0");
#line 314
    fcode_ender();
    }
  }
#line 318
  if (fcode_start_ob_off != -1) {
#line 323
    fcode_body = ostart + fcode_body_ob_off;
#line 324
    ob_end = ostart + opc;
#line 325
    fcode_hdr = (fcode_header_t *)(ostart + fcode_hdr_ob_off);
#line 328
    length = (int )(opc - (unsigned int )fcode_start_ob_off);
#line 330
    checksum = (u16 )0;
    {
#line 330
    while (1) {
      while_continue: /* CIL Label */ ;
#line 330
      if (! ((unsigned long )fcode_body < (unsigned long )ob_end)) {
#line 330
        goto while_break;
      }
#line 330
      tmp = fcode_body;
#line 330
      fcode_body ++;
#line 330
      checksum = (u16 )((int )checksum + (int )*tmp);
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    fcode_hdr->checksum[0] = (u8 )((int )checksum >> 8);
#line 334
    fcode_hdr->checksum[1] = (u8 )checksum;
#line 335
    fcode_hdr->length[0] = (u8 )(length >> 24);
#line 335
    fcode_hdr->length[1] = (u8 )(length >> 16);
#line 335
    fcode_hdr->length[2] = (u8 )(length >> 8);
#line 335
    fcode_hdr->length[3] = (u8 )length;
#line 337
    if (verbose) {
      {
#line 339
      printf((char const   */* __restrict  */)"toke: checksum is 0x%04x (%d bytes).  ",
             (int )checksum, length);
#line 341
      list_fcode_ranges((bool )-1);
      }
    }
  }
#line 346
  fcode_start_ob_off = -1;
#line 347
  fcode_hdr_ob_off = -1;
#line 348
  fcode_body_ob_off = -1;
#line 349
  fcode_written = (bool )0;
#line 350
  haveend = (bool )0;
#line 351
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static void emit_pci_rom_hdr(void) 
{ 
  rom_header_t *pci_hdr ;
  int j ;

  {
#line 384
  pci_hdr_ob_off = (int )opc;
#line 385
  pci_hdr = (rom_header_t *)(ostart + pci_hdr_ob_off);
#line 387
  j = 0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! ((unsigned long )j < sizeof(rom_header_t ))) {
#line 387
      goto while_break;
    }
    {
#line 387
    emit_byte((u8 )0);
#line 387
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  pci_hdr->signature[1] = (u8 )(43605 >> 8);
#line 390
  pci_hdr->signature[0] = (u8 )43605;
#line 407
  pci_hdr->reserved[1] = (u8 )((sizeof(rom_header_t ) + sizeof(pci_data_t )) >> 8);
#line 407
  pci_hdr->reserved[0] = (u8 )(sizeof(rom_header_t ) + sizeof(pci_data_t ));
#line 413
  pci_hdr->data_ptr[1] = (u8 )(sizeof(rom_header_t ) >> 8);
#line 413
  pci_hdr->data_ptr[0] = (u8 )sizeof(rom_header_t );
#line 415
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
static void emit_pci_data_block(void) 
{ 
  pci_data_t *pci_data_blk ;
  u32 class_id ;
  long tmp ;
  u16 dev_id ;
  long tmp___0 ;
  u16 vend_id ;
  long tmp___1 ;
  int j ;

  {
  {
#line 452
  tmp = dpop();
#line 452
  class_id = (u32 )tmp;
#line 453
  tmp___0 = dpop();
#line 453
  dev_id = (u16 )tmp___0;
#line 454
  tmp___1 = dpop();
#line 454
  vend_id = (u16 )tmp___1;
#line 456
  pci_data_blk_ob_off = (int )opc;
#line 457
  pci_data_blk = (pci_data_t *)(ostart + pci_data_blk_ob_off);
#line 459
  j = 0;
  }
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! ((unsigned long )j < sizeof(pci_data_t ))) {
#line 459
      goto while_break;
    }
    {
#line 459
    emit_byte((u8 )0);
#line 459
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  pci_data_blk->signature[0] = (u8 )((u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82) >> 24);
#line 461
  pci_data_blk->signature[1] = (u8 )((u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82) >> 16);
#line 461
  pci_data_blk->signature[2] = (u8 )((u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82) >> 8);
#line 461
  pci_data_blk->signature[3] = (u8 )((u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82));
#line 463
  pci_data_blk->vendor[1] = (u8 )((int )vend_id >> 8);
#line 463
  pci_data_blk->vendor[0] = (u8 )vend_id;
#line 464
  pci_data_blk->device[1] = (u8 )((int )dev_id >> 8);
#line 464
  pci_data_blk->device[0] = (u8 )dev_id;
#line 465
  pci_data_blk->class_code[2] = (u8 )(class_id >> 16);
#line 465
  pci_data_blk->class_code[1] = (u8 )(class_id >> 8);
#line 465
  pci_data_blk->class_code[0] = (u8 )class_id;
#line 467
  pci_data_blk->dlen[1] = (u8 )(sizeof(pci_data_t ) >> 8);
#line 467
  pci_data_blk->dlen[0] = (u8 )sizeof(pci_data_t );
#line 469
  pci_data_blk->drevision = (u8 )0;
#line 472
  pci_data_blk->code_type = (u8 )1;
#line 475
  if (pci_is_last_image) {
#line 475
    pci_data_blk->last_image_flag = (u8 )128;
  } else {
#line 475
    pci_data_blk->last_image_flag = (u8 )0;
  }
  {
#line 477
  tokenization_error(65536, (char *)"PCI header vendor id=0x%04x, device id=0x%04x, class=%06x\n",
                     (int )vend_id, (int )dev_id, class_id);
  }
#line 482
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void emit_pcihdr(void) 
{ 


  {
#line 519
  if (fcode_start_ob_off != -1) {
#line 519
    goto _L;
  } else
#line 519
  if (fcode_written) {
    _L: /* CIL Label */ 
    {
#line 526
    tokenization_error(67108864, (char *)"Cannot create PCI header after FCode output has begun.\n");
    }
#line 528
    if (! noerrors) {
#line 528
      return;
    }
  }
  {
#line 531
  emit_pci_rom_hdr();
#line 533
  emit_pci_data_block();
#line 535
  pci_hdr_end_ob_off = opc;
  }
#line 536
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void finish_pcihdr(void) 
{ 
  u32 imagesize ;
  u32 imageblocks ;
  int padding ;
  rom_header_t *pci_hdr ;
  pci_data_t *pci_data_blk ;
  char *tmp ;
  int tmp___0 ;

  {
#line 556
  if (pci_data_blk_ob_off == -1) {
    {
#line 558
    tmp = strupper((char *)statbuf);
#line 558
    tokenization_error(67108864, (char *)"%s without PCI-HEADER\n", tmp);
    }
#line 560
    return;
  }
#line 563
  pci_hdr = (rom_header_t *)(ostart + pci_hdr_ob_off);
#line 564
  pci_data_blk = (pci_data_t *)(ostart + pci_data_blk_ob_off);
#line 567
  pci_data_blk->vpd[1] = (u8 )((int )pci_vpd >> 8);
#line 567
  pci_data_blk->vpd[0] = (u8 )pci_vpd;
#line 570
  imagesize = opc - (unsigned int )pci_hdr_ob_off;
#line 571
  imageblocks = (imagesize + 511U) >> 9;
#line 572
  padding = (int )((imageblocks << 9) - imagesize);
#line 575
  pci_data_blk->ilen[1] = (u8 )(imageblocks >> 8);
#line 575
  pci_data_blk->ilen[0] = (u8 )imageblocks;
#line 578
  if (big_end_pci_image_rev) {
#line 580
    pci_data_blk->irevision[0] = (u8 )((int )pci_image_rev >> 8);
#line 580
    pci_data_blk->irevision[1] = (u8 )pci_image_rev;
  } else {
#line 582
    pci_data_blk->irevision[1] = (u8 )((int )pci_image_rev >> 8);
#line 582
    pci_data_blk->irevision[0] = (u8 )pci_image_rev;
  }
#line 586
  if (pci_is_last_image) {
#line 586
    pci_data_blk->last_image_flag = (u8 )128;
  } else {
#line 586
    pci_data_blk->last_image_flag = (u8 )0;
  }
  {
#line 590
  printf((char const   */* __restrict  */)"Adding %d bytes of zero padding to PCI image.\n",
         padding);
  }
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    tmp___0 = padding;
#line 591
    padding --;
#line 591
    if (! tmp___0) {
#line 591
      goto while_break;
    }
    {
#line 592
    emit_byte((u8 )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 593
  if (! pci_is_last_image) {
    {
#line 595
    printf((char const   */* __restrict  */)"Note:  PCI header is not last image.\n");
    }
  }
  {
#line 597
  printf((char const   */* __restrict  */)"\n");
#line 599
  pci_hdr_ob_off = -1;
#line 600
  pci_data_blk_ob_off = -1;
#line 601
  pci_hdr_end_ob_off = 0U;
  }
#line 602
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/emit.c"
void finish_headers(void) 
{ 


  {
#line 615
  if (fcode_hdr_ob_off != -1) {
    {
#line 615
    finish_fcodehdr();
    }
  }
#line 616
  if (pci_hdr_ob_off != -1) {
    {
#line 616
    finish_pcihdr();
    }
  }
#line 617
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 166 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static bool print_msg  ;
#line 167 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int errs_to_print  =    -2078242751;
#line 169 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int err_types_found  =    0;
#line 170 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int err_count  =    0;
#line 171 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int warn_count  =    0;
#line 172 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int info_count  =    0;
#line 173 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int user_msg_count  =    0;
#line 174 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int trace_msg_count  =    0;
#line 175 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int fatal_err_exit  =    -1;
#line 176 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static FILE *message_dest  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static err_category const   error_categories[7]  = {      {(-0x7FFFFFFF-1), (char *)"Fatal Error", (char *)"", (char *)"", & err_count,
      (bool )-1}, 
        {67108864, (char *)"Error", (char *)"", (char *)"s", & err_count, (bool )0}, 
        {2097152, (char *)"Warning", (char *)"", (char *)"s", & warn_count, (bool )0}, 
        {65536,
      (char *)"Advisor", (char *)"y", (char *)"ies", & info_count, (bool )0}, 
        {2048, (char *)"Message", (char *)"", (char *)"s", & user_msg_count, (bool )-1}, 
        {64,
      (char *)"Message", (char *)"", (char *)"s", & user_msg_count, (bool )0}, 
        {32768, (char *)"Trace-Note", (char *)"", (char *)"s", & trace_msg_count, (bool )0}};
#line 212 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int const   num_categories  =    (int const   )(sizeof(error_categories) / sizeof(err_category ));
#line 238 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static void toup(char *chr_ptr ) 
{ 
  unsigned char upcas_diff ;

  {
#line 240
  upcas_diff = (unsigned char)32;
#line 241
  if ((int )*chr_ptr >= 97) {
#line 241
    if ((int )*chr_ptr <= 122) {
#line 243
      *chr_ptr = (char )((int )*chr_ptr - (int )upcas_diff);
    }
  }
#line 245
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
char *strupper(char *strung ) 
{ 
  char *strindx ;

  {
#line 272
  strindx = strung;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! ((int )*strindx != 0)) {
#line 272
      goto while_break;
    }
    {
#line 274
    toup(strindx);
#line 272
    strindx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return (strung);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static void tolow(char *chr_ptr ) 
{ 
  unsigned char lowcas_diff ;

  {
#line 309
  lowcas_diff = (unsigned char)224;
#line 310
  if ((int )*chr_ptr >= 65) {
#line 310
    if ((int )*chr_ptr <= 90) {
#line 312
      *chr_ptr = (char )((int )*chr_ptr - (int )lowcas_diff);
    }
  }
#line 314
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
char *strlower(char *strung ) 
{ 
  char *strindx ;

  {
#line 341
  strindx = strung;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((int )*strindx != 0)) {
#line 341
      goto while_break;
    }
    {
#line 343
    tolow(strindx);
#line 341
    strindx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return (strung);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void init_error_handler(void) 
{ 
  int indx ;

  {
#line 393
  message_dest = stderr;
#line 394
  if (verbose) {
#line 394
    errs_to_print |= 65536;
  }
#line 395
  err_types_found = 0;
#line 398
  indx = 1;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (indx < (int )num_categories)) {
#line 398
      goto while_break;
    }
#line 400
    *(error_categories[indx].counter) = 0;
#line 398
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 403
  fflush(stdout);
  }
#line 404
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void tokenization_error(int err_type , char *msg  , ...) 
{ 
  int indx ;
  char *catgy_name ;
  char *catgy_suffx ;
  int *catgy_counter ;
  bool print_new_line ;
  va_list argp ;

  {
#line 487
  catgy_name = (char *)"Error";
#line 488
  catgy_suffx = (char *)"";
#line 489
  catgy_counter = & err_count;
#line 490
  print_new_line = (bool )0;
#line 493
  err_types_found |= err_type;
#line 496
  indx = 0;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! (indx < (int )num_categories)) {
#line 496
      goto while_break;
    }
#line 498
    if ((error_categories[indx].type_bit & (int const   )err_type) != 0) {
#line 500
      catgy_name = (char *)error_categories[indx].category_name;
#line 501
      catgy_suffx = (char *)error_categories[indx].single;
#line 502
      catgy_counter = (int *)error_categories[indx].counter;
#line 503
      print_new_line = (bool )error_categories[indx].new_line;
#line 504
      goto while_break;
    }
#line 496
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  if ((unsigned long )catgy_name == (unsigned long )((void *)0)) {
    {
#line 511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Program error: Unknown Error-Type, 0x%08x.    Will treat as Error.\n",
            err_type);
#line 514
    err_types_found |= 67108864;
#line 515
    print_msg = (bool )-1;
    }
  } else
#line 518
  if ((errs_to_print & err_type) != 0) {
#line 518
    print_msg = (bool )-1;
  } else {
#line 518
    print_msg = (bool )0;
  }
#line 521
  if (print_msg) {
    {
#line 525
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s:  ",
            catgy_name, catgy_suffx);
    }
#line 527
    if ((unsigned long )iname != (unsigned long )((void *)0)) {
      {
#line 530
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File %s, Line %d.  ",
              iname, lineno);
      }
    }
#line 533
    if (opc > 0U) {
      {
#line 536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(Output Position = %d).  ",
              opc);
      }
    }
#line 538
    if (pci_hdr_end_ob_off > 0U) {
      {
#line 541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(PCI-Block Position = %d).  ",
              opc - pci_hdr_end_ob_off);
      }
    }
    {
#line 545
    __builtin_va_start(argp, msg);
#line 546
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             argp);
#line 547
    __builtin_va_end(argp);
    }
#line 548
    if (print_new_line) {
      {
#line 548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 551
    (*catgy_counter) ++;
  }
#line 553
  if ((unsigned int )err_type == 2147483648U) {
    {
#line 555
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Tokenization terminating.\n");
#line 556
    error_summary();
#line 557
    exit(fatal_err_exit);
    }
  }
#line 559
  return;
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static void print_where_started(bool show_started , bool show_that_st , char *saved_ifile ,
                                unsigned int saved_lineno , bool may_show_incolon ) 
{ 
  bool fil_is_diff ;
  bool lin_is_diff ;
  int tmp___0 ;

  {
#line 634
  if (print_msg) {
    {
#line 640
    tmp___0 = strcmp((char const   *)saved_ifile, (char const   *)iname);
    }
#line 640
    if (tmp___0 != 0) {
#line 640
      fil_is_diff = (bool )-1;
    } else {
#line 640
      fil_is_diff = (bool )0;
    }
#line 641
    if (saved_lineno != lineno) {
#line 641
      lin_is_diff = (bool )-1;
    } else {
#line 641
      lin_is_diff = (bool )0;
    }
#line 642
    if (fil_is_diff) {
#line 642
      goto _L;
    } else
#line 642
    if (lin_is_diff) {
      _L: /* CIL Label */ 
#line 644
      if (show_started) {
#line 646
        if (show_that_st) {
          {
#line 648
          fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)" that");
          }
        } else {
          {
#line 650
          fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)" , which");
          }
        }
        {
#line 652
        fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)" started");
        }
      }
      {
#line 654
      fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)" on line %d",
              saved_lineno);
      }
#line 655
      if (fil_is_diff) {
        {
#line 657
        fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)" of file %s",
                saved_ifile);
        }
      }
    }
#line 661
    if (may_show_incolon) {
      {
#line 663
      in_last_colon((bool )-1);
      }
    } else {
      {
#line 665
      fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 668
  return;
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void started_at(char *saved_ifile , unsigned int saved_lineno ) 
{ 


  {
  {
#line 696
  print_where_started((bool )-1, (bool )-1, saved_ifile, saved_lineno, (bool )-1);
  }
#line 697
  return;
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void print_started_at(char *saved_ifile , unsigned int saved_lineno ) 
{ 


  {
  {
#line 713
  message_dest = stdout;
#line 714
  started_at(saved_ifile, saved_lineno);
#line 715
  message_dest = stderr;
  }
#line 716
  return;
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void just_started_at(char *saved_ifile , unsigned int saved_lineno ) 
{ 


  {
  {
#line 744
  print_where_started((bool )-1, (bool )-1, saved_ifile, saved_lineno, (bool )0);
  }
#line 745
  return;
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void where_started(char *saved_ifile , unsigned int saved_lineno ) 
{ 


  {
  {
#line 772
  print_where_started((bool )0, (bool )0, saved_ifile, saved_lineno, (bool )-1);
  }
#line 773
  return;
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void just_where_started(char *saved_ifile , unsigned int saved_lineno ) 
{ 


  {
  {
#line 799
  print_where_started((bool )0, (bool )0, saved_ifile, saved_lineno, (bool )0);
  }
#line 800
  return;
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void in_last_colon(bool say_in ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 841
  if (print_msg) {
#line 843
    if (incolon) {
#line 843
      goto _L;
    } else
#line 843
    if (! say_in) {
      _L: /* CIL Label */ 
      {
#line 845
      tmp = strupper(last_colon_defname);
      }
#line 845
      if (say_in) {
#line 845
        tmp___0 = " in";
      } else {
#line 845
        tmp___0 = "";
      }
      {
#line 845
      fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)"%s definition of  %s ",
              tmp___0, tmp);
#line 847
      print_where_started((bool )-1, (bool )0, last_colon_filename, last_colon_lineno,
                          (bool )0);
      }
    } else {
      {
#line 850
      fprintf((FILE */* __restrict  */)message_dest, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 853
  return;
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
void *safe_malloc(size_t size , char *phrase ) 
{ 
  void *retval ;

  {
  {
#line 888
  retval = malloc(size);
  }
#line 889
  if (! retval) {
    {
#line 891
    fatal_err_exit = -12;
#line 892
    tokenization_error((-0x7FFFFFFF-1), (char *)"Out of memory while %s.", phrase);
    }
  }
#line 894
  return (retval);
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
static int const   suppress_mask  =    (int const   )2214592512U;
#line 926 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/errhandler.c"
bool error_summary(void) 
{ 
  bool retval ;
  bool suppressing ;
  int indx ;
  bool tally_started ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 930
  retval = (bool )-1;
#line 931
  suppressing = (bool )0;
#line 934
  if (((unsigned int )err_types_found & 2147483648U) != 0U) {
#line 937
    suppressing = (bool )-1;
  } else {
#line 940
    if (opc == 0U) {
      {
#line 942
      printf((char const   */* __restrict  */)"Nothing Tokenized");
      }
    } else {
      {
#line 944
      printf((char const   */* __restrict  */)"Tokenization Completed");
      }
    }
#line 947
    if (err_types_found != 0) {
      {
#line 950
      tally_started = (bool )0;
#line 951
      printf((char const   */* __restrict  */)". ");
#line 957
      indx = 1;
      }
      {
#line 957
      while (1) {
        while_continue: /* CIL Label */ ;
#line 957
        if (! (indx < (int )num_categories)) {
#line 957
          goto while_break;
        }
#line 959
        if (*(error_categories[indx].counter) > 0) {
#line 961
          if (*(error_categories[indx].counter) > 1) {
#line 961
            tmp = error_categories[indx].plural;
          } else {
#line 961
            tmp = error_categories[indx].single;
          }
#line 961
          if (tally_started) {
#line 961
            tmp___0 = ",";
          } else {
#line 961
            tmp___0 = "";
          }
          {
#line 961
          printf((char const   */* __restrict  */)"%s %d %s%s", tmp___0, *(error_categories[indx].counter),
                 error_categories[indx].category_name, tmp);
#line 972
          *(error_categories[indx].counter) = 0;
#line 973
          tally_started = (bool )-1;
          }
        }
#line 957
        indx ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 977
    printf((char const   */* __restrict  */)".\n");
    }
#line 979
    if ((err_types_found & (int )suppress_mask) != 0) {
#line 982
      if (noerrors) {
#line 982
        tmp___1 = 0;
      } else {
#line 982
        tmp___1 = -1;
      }
#line 982
      if (tmp___1) {
#line 984
        suppressing = (bool )-1;
      } else
#line 986
      if (opc > 0U) {
        {
#line 988
        printf((char const   */* __restrict  */)"Error-detection over-ridden; producing binary output.\n");
        }
      }
    }
  }
#line 994
  if (suppressing) {
    {
#line 996
    retval = (bool )0;
#line 997
    printf((char const   */* __restrict  */)"Suppressing binary output.\n");
    }
  }
#line 999
  return (retval);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static char const   *push_locals  =    "{push-locals}";
#line 58 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static char const   *pop_locals  =    "{pop-locals}";
#line 59 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static char const   *local_addr  =    "_{local}";
#line 62 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static char const   *local_op  =    "@";
#line 119 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static tic_hdr_t *local_names  =    (tic_hdr_t *)((void *)0);
#line 120 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static int num_ilocals  =    0;
#line 121 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static int num_ulocals  =    0;
#line 122 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static int localno  =    0;
#line 123 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static char eval_buf[64]  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static unsigned int l_d_lineno  ;
#line 172 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static char *int_to_str(int num , char *bufr ) 
{ 
  char *prefix ;

  {
#line 174
  prefix = (char *)"d# ";
#line 175
  if (num < 8) {
#line 175
    prefix = (char *)"";
  }
  {
#line 176
  sprintf((char */* __restrict  */)bufr, (char const   */* __restrict  */)"%s%d",
          prefix, num);
  }
#line 177
  return (bufr);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static void invoke_local(tic_param_t pfield ) 
{ 
  char local_num_buf[10] ;
  int loc_num ;

  {
  {
#line 232
  loc_num = (int )pfield.deflt_elem;
#line 234
  int_to_str(loc_num, local_num_buf);
#line 235
  sprintf((char */* __restrict  */)(eval_buf), (char const   */* __restrict  */)"%s %s %s",
          local_num_buf, local_addr, local_op);
#line 236
  eval_string(eval_buf);
  }
#line 238
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static bool locals_separator(char subj ) 
{ 
  bool retval ;

  {
#line 282
  retval = (bool )0;
#line 284
  if ((int )subj == 124) {
#line 286
    retval = (bool )-1;
#line 287
    return (retval);
  }
#line 290
  if (ibm_locals_legacy_separator) {
#line 292
    if ((int )subj == 59) {
#line 294
      retval = (bool )-1;
#line 295
      if (ibm_legacy_separator_message) {
        {
#line 297
        tokenization_error(2097152, (char *)"Semicolon as separator in Locals declaration is deprecated in favor of \'|\'\n");
        }
      }
    }
  }
#line 302
  return (retval);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static void add_local(long lnum , char *lname ) 
{ 
  char *lnamecopy ;

  {
  {
#line 339
  lnamecopy = strdup((char const   *)lname);
#line 340
  add_tic_entry(lnamecopy, (void (*)())(& invoke_local), lnum, (fwtoken )75, 0, (bool )0,
                (void (*)())((void *)0), & local_names);
  }
#line 343
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static bool gather_locals(bool initted , int *counter ) 
{ 
  long wlen ;
  bool retval ;
  bool tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  char *where_pt1 ;
  char *where_pt2 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 396
  retval = (bool )0;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 400
    wlen = get_word();
    }
#line 402
    if (wlen <= 0L) {
      {
#line 404
      warn_unterm(67108864, (char *)"Local-Values Declaration", l_d_lineno);
      }
#line 405
      goto while_break;
    }
    {
#line 409
    tmp = filter_comments(statbuf);
    }
#line 409
    if (tmp) {
#line 412
      goto while_continue;
    }
#line 415
    if (wlen == 1L) {
      {
#line 418
      tmp___0 = locals_separator((char )*(statbuf + 0));
      }
#line 418
      if (tmp___0) {
#line 421
        if (initted) {
#line 423
          retval = (bool )-1;
#line 424
          goto while_break;
        } else {
          {
#line 426
          tokenization_error(67108864, (char *)"Excess separator -- %s -- found in Local-Values declaration",
                             statbuf);
#line 429
          in_last_colon((bool )-1);
          }
#line 430
          goto while_continue;
        }
      }
#line 434
      if ((int )*(statbuf + 0) == 125) {
#line 436
        goto while_break;
      }
    }
    {
#line 444
    tmp___2 = word_exists((char *)statbuf, & where_pt1, & where_pt2);
    }
#line 444
    if (tmp___2) {
      {
#line 446
      tokenization_error(67108864, (char *)"Cannot declare %s as a Local-Name; it\'s already defined %s%s",
                         statbuf, where_pt1, where_pt2);
#line 449
      show_node_start();
      }
#line 450
      goto while_continue;
    }
    {
#line 453
    tmp___3 = get_number(& tmp___1);
    }
#line 453
    if (tmp___3) {
      {
#line 455
      tokenization_error(67108864, (char *)"Cannot declare %s as a Local-Name; it\'s a number.\n",
                         statbuf);
      }
#line 457
      goto while_continue;
    }
    {
#line 464
    (*counter) ++;
#line 467
    add_local((long )localno, (char *)statbuf);
#line 470
    localno ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return (retval);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static void activate_locals(void) 
{ 
  char ilocals_buf[10] ;
  char ulocals_buf[10] ;

  {
  {
#line 521
  int_to_str(num_ilocals, ilocals_buf);
#line 522
  int_to_str(num_ulocals, ulocals_buf);
#line 523
  sprintf((char */* __restrict  */)(eval_buf), (char const   */* __restrict  */)"%s %s %s",
          ilocals_buf, ulocals_buf, push_locals);
#line 524
  eval_string(eval_buf);
  }
#line 525
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static int last_local_colon  =    0;
#line 563 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static bool error_check_locals(void) 
{ 
  bool retval ;

  {
#line 565
  retval = (bool )0;
#line 567
  if (! incolon) {
    {
#line 569
    tokenization_error(67108864, (char *)"Can only declare Locals inside of a Colon-definition.\n");
#line 571
    retval = (bool )-1;
    }
  } else
#line 573
  if (last_local_colon == lastcolon) {
    {
#line 575
    tokenization_error(67108864, (char *)"Excess Locals Declaration");
#line 576
    in_last_colon((bool )-1);
#line 577
    retval = (bool )-1;
    }
  } else {
#line 579
    last_local_colon = lastcolon;
#line 580
    if (opc > (unsigned int )lastcolon) {
      {
#line 582
      tokenization_error(2097152, (char *)"Declaring Locals after the body of a Colon-definition has begun is not recommended.\n");
      }
    }
    {
#line 586
    announce_control_structs(67108864, (char *)"Local-Values Declaration encountered",
                             last_colon_abs_token_no);
    }
  }
#line 591
  return (retval);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
void declare_locals(bool ignoring ) 
{ 
  bool sav_rep_mul_lin ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 634
  num_ilocals = 0;
#line 635
  num_ulocals = 0;
#line 636
  localno = 0;
#line 638
  l_d_lineno = lineno;
#line 639
  sav_rep_mul_lin = report_multiline;
#line 640
  report_multiline = (bool )-1;
#line 642
  if (ignoring) {
#line 642
    goto _L;
  } else {
    {
#line 642
    tmp___1 = error_check_locals();
    }
#line 642
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 644
      tmp = skip_until((char )'}');
      }
#line 644
      if (tmp) {
        {
#line 646
        warn_unterm(67108864, (char *)"misplaced Local-Values Declaration", l_d_lineno);
        }
      } else {
#line 649
        pc ++;
      }
    } else {
      {
#line 652
      tmp___0 = gather_locals((bool )-1, & num_ilocals);
      }
#line 652
      if (tmp___0) {
        {
#line 654
        gather_locals((bool )0, & num_ulocals);
        }
      }
    }
  }
#line 664
  if ((unsigned long )pc < (unsigned long )end) {
    {
#line 666
    report_multiline = sav_rep_mul_lin;
#line 667
    warn_if_multiline((char *)"Local-Values declaration", l_d_lineno);
    }
  }
#line 672
  if (localno != 0) {
    {
#line 674
    activate_locals();
    }
  }
#line 676
  return;
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
static bool handle_local(char *lname ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 697
  tmp = handle_tic_vocab(lname, local_names);
#line 697
  retval = tmp;
  }
#line 698
  return (retval);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
tic_hdr_t *lookup_local(char *lname ) 
{ 
  tic_hdr_t *retval ;
  tic_hdr_t *tmp ;

  {
  {
#line 721
  tmp = lookup_tic_entry(lname, local_names);
#line 721
  retval = tmp;
  }
#line 722
  return (retval);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
bool create_local_alias(char *new_name , char *old_name ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 752
  tmp = create_tic_alias(new_name, old_name, & local_names);
#line 752
  retval = tmp;
  }
#line 753
  return (retval);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
bool exists_as_local(char *stat_name ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 773
  tmp = exists_in_tic_vocab(stat_name, local_names);
#line 773
  retval = tmp;
  }
#line 774
  return (retval);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
void assign_local(void) 
{ 
  long wlen ;
  bool is_okay ;
  u8 *savd_pc ;
  unsigned int savd_lineno ;
  int tmp ;

  {
  {
#line 823
  savd_pc = pc;
#line 824
  savd_lineno = lineno;
#line 826
  wlen = get_word();
  }
#line 828
  if (wlen <= 0L) {
    {
#line 830
    warn_unterm(67108864, (char *)"Locals Assignment", lineno);
    }
#line 831
    return;
  }
  {
#line 834
  local_op = "!";
#line 836
  is_okay = handle_local((char *)statbuf);
  }
#line 837
  if (is_okay) {
#line 837
    tmp = 0;
  } else {
#line 837
    tmp = -1;
  }
#line 837
  if (tmp) {
    {
#line 839
    tokenization_error(67108864, (char *)"Cannot apply -> to %s, only to a declared Local.\n",
                       statbuf);
#line 841
    pc = savd_pc;
#line 842
    lineno = savd_lineno;
    }
  }
#line 844
  local_op = "@";
#line 845
  return;
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
void finish_locals(void) 
{ 
  char nlocals_buf[10] ;
  long tmp ;
  long tmp___0 ;

  {
#line 897
  if (localno > 0) {
    {
#line 901
    int_to_str(localno, nlocals_buf);
#line 902
    sprintf((char */* __restrict  */)(eval_buf), (char const   */* __restrict  */)"%s %s",
            nlocals_buf, pop_locals);
#line 903
    eval_string(eval_buf);
#line 904
    tmp = get_word();
#line 904
    tokenize_one_word(tmp);
#line 905
    tmp___0 = get_word();
#line 905
    tokenize_one_word(tmp___0);
    }
  }
#line 907
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/parselocals.c"
void forget_locals(void) 
{ 


  {
#line 939
  if (localno != 0) {
    {
#line 941
    reset_tic_vocab(& local_names, (tic_hdr_t *)((void *)0));
#line 943
    num_ilocals = 0;
#line 944
    num_ulocals = 0;
#line 945
    localno = 0;
    }
  }
#line 947
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
char const   *pci_device_class_name(u32 code ) ;
#line 50
char const   *pci_code_type_name(u8 code ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static char const   *convert_num_to_name(u32 num , num_to_name_table *table , int max___0 ,
                                         char const   *not_found ) 
{ 
  int indx ;
  char const   *retval ;

  {
#line 98
  retval = not_found;
#line 100
  indx = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (indx < max___0)) {
#line 100
      goto while_break;
    }
#line 102
    if (num == (u32 )(table + indx)->classcode) {
#line 104
      retval = (table + indx)->classname;
#line 105
      goto while_break;
    }
#line 100
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (retval);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static num_to_name_table const   pci_code_type_name_table[4]  = {      {(u32 const   )0, "Intel x86"}, 
        {(u32 const   )1, "Open Firmware"}, 
        {(u32 const   )2, "HP PA Risc"}, 
        {(u32 const   )3, "Intel EFI (unofficial)"}};
#line 136 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static num_to_name_table const   pci_dev_class_name_table[134]  = 
#line 136
  {      {(u32 const   )0, "Legacy Device"}, 
        {(u32 const   )256, "VGA-Compatible Device"}, 
        {(u32 const   )65536, "SCSI bus controller"}, 
        {(u32 const   )66048, "Floppy disk controller"}, 
        {(u32 const   )66304, "IPI bus controller"}, 
        {(u32 const   )66560, "RAID controller"}, 
        {(u32 const   )66848, "ATA controller, single stepping"}, 
        {(u32 const   )66864, "ATA controller, continuous"}, 
        {(u32 const   )67072, "Serial ATA controller - vendor specific interface"}, 
        {(u32 const   )67073, "Serial ATA controller - AHCI 1.0 interface"}, 
        {(u32 const   )67328, "Serial Attached SCSI controller"}, 
        {(u32 const   )98304, "Mass Storage controller"}, 
        {(u32 const   )131072, "Ethernet controller"}, 
        {(u32 const   )131328, "Token Ring controller"}, 
        {(u32 const   )131584, "FDDI controller"}, 
        {(u32 const   )131840, "ATM controller"}, 
        {(u32 const   )132096, "ISDN controller"}, 
        {(u32 const   )132352, "WorldFip controller"}, 
        {(u32 const   )163840, "Network controller"}, 
        {(u32 const   )196608, "VGA Display controller"}, 
        {(u32 const   )196609, "8514-compatible Display controller"}, 
        {(u32 const   )196864, "XGA Display controller"}, 
        {(u32 const   )197120, "3D Display controller"}, 
        {(u32 const   )229376, "Display controller"}, 
        {(u32 const   )262144, "Video device"}, 
        {(u32 const   )262400, "Audio device"}, 
        {(u32 const   )262656, "Computer Telephony device"}, 
        {(u32 const   )294912, "Multimedia device"}, 
        {(u32 const   )327680, "RAM memory controller"}, 
        {(u32 const   )327936, "Flash memory controller"}, 
        {(u32 const   )360448, "Memory controller"}, 
        {(u32 const   )393216, "Host bridge"}, 
        {(u32 const   )393472, "ISA bridge"}, 
        {(u32 const   )393728, "EISA bridge"}, 
        {(u32 const   )393984, "MCA bridge"}, 
        {(u32 const   )394240, "PCI-to-PCI bridge"}, 
        {(u32 const   )394241, "PCI-to-PCI bridge (subtractive decoding)"}, 
        {(u32 const   )394496, "PCMCIA bridge"}, 
        {(u32 const   )394752, "NuBus bridge"}, 
        {(u32 const   )395008, "CardBus bridge"}, 
        {(u32 const   )395584, "PCI-to-PCI bridge, Semi-transparent, primary facing Host"}, 
        {(u32 const   )395648,
      "PCI-to-PCI bridge, Semi-transparent, secondary facing Host"}, 
        {(u32 const   )395776, "InfiniBand-to-PCI host bridge"}, 
        {(u32 const   )425984, "Bridge device"}, 
        {(u32 const   )458752, "Generic XT-compatible serial controller"}, 
        {(u32 const   )458753, "16450-compatible serial controller"}, 
        {(u32 const   )458754, "16550-compatible serial controller"}, 
        {(u32 const   )458755, "16650-compatible serial controller"}, 
        {(u32 const   )458756, "16750-compatible serial controller"}, 
        {(u32 const   )458757, "16850-compatible serial controller"}, 
        {(u32 const   )458758, "16950-compatible serial controller"}, 
        {(u32 const   )459008, "Parallel port"}, 
        {(u32 const   )459009, "Bi-directional parallel port"}, 
        {(u32 const   )459010, "ECP 1.X compliant parallel port"}, 
        {(u32 const   )459011, "IEEE1284 controller"}, 
        {(u32 const   )459262, "IEEE1284 target device"}, 
        {(u32 const   )459264, "Multiport serial controller"}, 
        {(u32 const   )459520, "Generic modem"}, 
        {(u32 const   )459521, "Hayes 16450-compatible modem"}, 
        {(u32 const   )459522, "Hayes 16550-compatible modem"}, 
        {(u32 const   )459523, "Hayes 16650-compatible modem"}, 
        {(u32 const   )459524, "Hayes 16750-compatible modem"}, 
        {(u32 const   )459776, "GPIB (IEEE 488.1/2) controller"}, 
        {(u32 const   )460032, "Smart Card"}, 
        {(u32 const   )491520, "Communications device"}, 
        {(u32 const   )524288, "Generic 8259 PIC"}, 
        {(u32 const   )524289, "ISA PIC"}, 
        {(u32 const   )524290, "EISA PIC"}, 
        {(u32 const   )524304, "I/O APIC interrupt controller"}, 
        {(u32 const   )524320, "I/O(x) APIC interrupt controller"}, 
        {(u32 const   )524544, "Generic 8237 DMA controller"}, 
        {(u32 const   )524545, "ISA DMA controller"}, 
        {(u32 const   )524546, "EISA DMA controller"}, 
        {(u32 const   )524800, "Generic 8254 system timer"}, 
        {(u32 const   )524801, "ISA system timer"}, 
        {(u32 const   )524802, "EISA system timer-pair"}, 
        {(u32 const   )525056, "Generic RTC controller"}, 
        {(u32 const   )525057, "ISA RTC controller"}, 
        {(u32 const   )525312, "Generic PCI Hot-Plug controller"}, 
        {(u32 const   )525568, "SD Host controller"}, 
        {(u32 const   )557056, "System peripheral"}, 
        {(u32 const   )589824, "Keyboard controller"}, 
        {(u32 const   )590080, "Digitizer (pen)"}, 
        {(u32 const   )590336, "Mouse controller"}, 
        {(u32 const   )590592, "Scanner controller"}, 
        {(u32 const   )590848, "Generic Gameport controller"}, 
        {(u32 const   )590864, "Legacy Gameport controller"}, 
        {(u32 const   )622592, "Input controller"}, 
        {(u32 const   )655360, "Generic docking station"}, 
        {(u32 const   )688128, "Docking station"}, 
        {(u32 const   )720896, "386 Processor"}, 
        {(u32 const   )721152, "486 Processor"}, 
        {(u32 const   )721408, "Pentium Processor"}, 
        {(u32 const   )724992, "Alpha Processor"}, 
        {(u32 const   )729088, "PowerPC Processor"}, 
        {(u32 const   )733184, "MIPS Processor"}, 
        {(u32 const   )737280, "Co-processor"}, 
        {(u32 const   )786432, "IEEE 1394 (FireWire)"}, 
        {(u32 const   )786448, "IEEE 1394 -- OpenHCI spec"}, 
        {(u32 const   )786688, "ACCESS.bus"}, 
        {(u32 const   )786944, "SSA"}, 
        {(u32 const   )787200, "Universal Serial Bus (UHC spec)"}, 
        {(u32 const   )787216, "Universal Serial Bus (Open Host spec)"}, 
        {(u32 const   )787232, "USB2 Host controller (Intel Enhanced HCI spec)"}, 
        {(u32 const   )787328, "Universal Serial Bus (no PI spec)"}, 
        {(u32 const   )787454, "USB Target Device"}, 
        {(u32 const   )787456, "Fibre Channel"}, 
        {(u32 const   )787712, "System Management Bus"}, 
        {(u32 const   )787968, "InfiniBand"}, 
        {(u32 const   )788224, "IPMI SMIC Interface"}, 
        {(u32 const   )788225, "IPMI Kybd Controller Style Interface"}, 
        {(u32 const   )788226, "IPMI Block Transfer Interface"}, 
        {(u32 const   )788736, "CANbus"}, 
        {(u32 const   )53504, "iRDA compatible controller"}, 
        {(u32 const   )53504, "Consumer IR controller"}, 
        {(u32 const   )53504, "RF controller"}, 
        {(u32 const   )53504, "Bluetooth controller"}, 
        {(u32 const   )53504, "Broadband controller"}, 
        {(u32 const   )53504, "Ethernet (802.11a 5 GHz) controller"}, 
        {(u32 const   )53504, "Ethernet (802.11b 2.4 GHz) controller"}, 
        {(u32 const   )53504, "Wireless controller"}, 
        {(u32 const   )917504, "Message FIFO at offset 040h"}, 
        {(u32 const   )983296, "TV satellite comm. controller"}, 
        {(u32 const   )983552, "Audio satellite comm. controller"}, 
        {(u32 const   )983808, "Voice satellite comm. controller"}, 
        {(u32 const   )984064, "Data satellite comm. controller"}, 
        {(u32 const   )1048576, "Network and computing en/decryption"}, 
        {(u32 const   )1052672, "Entertainment en/decryption"}, 
        {(u32 const   )1081344, "En/Decryption"}, 
        {(u32 const   )1114112, "DPIO modules"}, 
        {(u32 const   )1114368, "Perf. counters"}, 
        {(u32 const   )1118208, "Comm. synch., time and freq. test"}, 
        {(u32 const   )1122304, "Management card"}, 
        {(u32 const   )1146880, "Data acq./Signal proc."}};
#line 319 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static num_to_name_table const   pci_all_prg_intfcs_table[5]  = {      {(u32 const   )257, "IDE controller"}, 
        {(u32 const   )518, "PICMG 2.14 Multi Computing"}, 
        {(u32 const   )1544, "RACEway bridge"}, 
        {(u32 const   )3080, "SERCOS Interface"}, 
        {(u32 const   )3584, "I2O Intelligent I/O, spec 1.0"}};
#line 353 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
char const   *pci_device_class_name(u32 code ) 
{ 
  int pdc_max_indx ;
  char const   *result ;
  int pallpi_max_indx ;

  {
  {
#line 355
  pdc_max_indx = (int )(sizeof(pci_dev_class_name_table) / sizeof(num_to_name_table ));
#line 359
  result = convert_num_to_name(code, (num_to_name_table *)(pci_dev_class_name_table),
                               pdc_max_indx, (char const   *)((void *)0));
  }
#line 365
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 367
    pallpi_max_indx = (int )(sizeof(pci_all_prg_intfcs_table) / sizeof(num_to_name_table ));
#line 370
    result = convert_num_to_name(code >> 8, (num_to_name_table *)(pci_all_prg_intfcs_table),
                                 pallpi_max_indx, "unknown");
    }
  }
#line 376
  return (result);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
char const   *pci_code_type_name(u8 code ) 
{ 
  int pct_max_indx ;
  char const   *result ;

  {
  {
#line 404
  pct_max_indx = (int )(sizeof(pci_code_type_name_table) / sizeof(num_to_name_table ));
#line 408
  result = convert_num_to_name((u32 )code, (num_to_name_table *)(pci_code_type_name_table),
                               pct_max_indx, "unknown as of PCI specs 2.2");
  }
#line 413
  return (result);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.h"
void init_macros(tic_hdr_t **tic_vocab_ptr ) ;
#line 49
void add_user_macro(void) ;
#line 50
void skip_user_macro(tic_bool_param_t pfield ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.h"
void init_tokz_esc_vocab(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.h"
int split_alias_message ;
#line 120 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
bool scope_is_global  =    (bool )0;
#line 121 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
bool define_token  =    (bool )-1;
#line 221 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t *global_voc_dict_ptr  =    (tic_hdr_t *)((void *)0);
#line 222 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t *fc_tokens_list_ender  =    (tic_hdr_t *)((void *)0);
#line 223 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t *fc_tokens_list_start  =    (tic_hdr_t *)((void *)0);
#line 224 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t *shared_fwords_ender  =    (tic_hdr_t *)((void *)0);
#line 225 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t *global_voc_reset_ptr  =    (tic_hdr_t *)((void *)0);
#line 246 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
tic_hdr_t *lookup_core_word(char *tname ) 
{ 
  tic_hdr_t *found ;

  {
  {
#line 250
  found = lookup_tic_entry(tname, global_voc_dict_ptr);
  }
#line 251
  return (found);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
bool create_core_alias(char *new_name , char *old_name ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 285
  tmp = create_tic_alias(new_name, old_name, & global_voc_dict_ptr);
#line 285
  retval = tmp;
  }
#line 286
  return (retval);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static void emit_fc_token(tic_param_t pfield ) 
{ 
  u16 fc_tok ;

  {
  {
#line 315
  fc_tok = (u16 )pfield.deflt_elem;
#line 316
  emit_fcode(fc_tok);
  }
#line 317
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static void obsolete_warning(void) 
{ 
  char *tmp ;

  {
#line 350
  if (obso_fcode_warning) {
    {
#line 352
    tmp = strupper((char *)statbuf);
#line 352
    tokenization_error(2097152, (char *)"%s is an Obsolete FCode.\n", tmp);
    }
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static void obsolete_fc_token(tic_param_t pfield ) 
{ 


  {
  {
#line 359
  obsolete_warning();
#line 360
  emit_fc_token(pfield);
  }
#line 361
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t **save_device_definitions  ;
#line 502 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void enter_global_scope(void) 
{ 
  char *tmp ;

  {
#line 504
  if (scope_is_global) {
    {
#line 506
    tmp = strupper((char *)statbuf);
#line 506
    tokenization_error(2097152, (char *)"%s -- Global Scope already in effect; ignoring.\n",
                       tmp);
    }
  } else {
    {
#line 510
    tokenization_error(65536, (char *)"Initiating Global Scope definitions.\n");
#line 512
    scope_is_global = (bool )-1;
#line 513
    save_device_definitions = current_definitions;
#line 514
    current_definitions = & global_voc_dict_ptr;
    }
  }
#line 516
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void resume_device_scope(void) 
{ 
  char *tmp ;

  {
#line 520
  if (scope_is_global) {
    {
#line 522
    tokenization_error(65536, (char *)"Terminating Global Scope definitions; resuming Device-node definitions.\n");
#line 525
    current_definitions = save_device_definitions;
#line 526
    scope_is_global = (bool )0;
    }
  } else {
    {
#line 528
    tmp = strupper((char *)statbuf);
#line 528
    tokenization_error(2097152, (char *)"%s -- Device-node Scope already in effect; ignoring.\n",
                       tmp);
    }
  }
#line 533
  return;
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
tic_hdr_t *lookup_current(char *tname ) 
{ 
  tic_hdr_t *retval ;
  int tmp ;

  {
  {
#line 572
  retval = lookup_tic_entry(tname, *current_definitions);
  }
#line 573
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
#line 573
    if (scope_is_global) {
#line 573
      tmp = 0;
    } else {
#line 573
      tmp = -1;
    }
#line 573
    if (tmp) {
      {
#line 575
      retval = lookup_core_word(tname);
      }
    }
  }
#line 577
  return (retval);
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
bool exists_in_current(char *tname ) 
{ 
  tic_hdr_t *found ;
  tic_hdr_t *tmp ;
  bool retval ;
  int tmp___0 ;

  {
  {
#line 599
  tmp = lookup_word(tname, (char **)((void *)0), (char **)((void *)0));
#line 599
  found = tmp;
  }
#line 600
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 600
    tmp___0 = -1;
  } else {
#line 600
    tmp___0 = 0;
  }
#line 600
  retval = (bool )tmp___0;
#line 601
  return (retval);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
tic_hdr_t *lookup_in_dev_node(char *tname ) 
{ 
  tic_hdr_t *retval ;
  int tmp ;

  {
#line 627
  retval = (tic_hdr_t *)((void *)0);
#line 629
  if (scope_is_global) {
#line 629
    tmp = 0;
  } else {
#line 629
    tmp = -1;
  }
#line 629
  if (tmp) {
    {
#line 631
    retval = lookup_tic_entry(tname, *current_definitions);
    }
  }
#line 633
  return (retval);
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t *save_current  =    (tic_hdr_t *)((void *)0);
#line 708 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void add_to_current(char *name , long fc_token , fwtoken definer ) 
{ 
  char *nu_name ;
  char *tmp ;

  {
#line 712
  if (define_token) {
    {
#line 714
    tmp = strdup((char const   *)name);
#line 714
    nu_name = tmp;
#line 716
    save_current = *current_definitions;
#line 717
    add_tic_entry(nu_name, (void (*)())(& emit_fc_token), fc_token, definer, 0, (bool )-1,
                  (void (*)())((void *)0), current_definitions);
    }
  } else {
    {
#line 720
    trace_create_failure(name, (char *)((void *)0), (u16 )fc_token);
#line 721
    warn_if_duplicate(name);
    }
  }
#line 723
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void hide_last_colon(void) 
{ 
  tic_hdr_t *temp_vocab ;

  {
#line 728
  if (define_token) {
#line 738
    temp_vocab = save_current;
#line 739
    save_current = *current_definitions;
#line 740
    *current_definitions = temp_vocab;
  }
#line 743
  return;
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void reveal_last_colon(void) 
{ 


  {
#line 747
  if (define_token) {
#line 752
    *current_definitions = save_current;
  }
#line 754
  return;
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
bool create_current_alias(char *new_name , char *old_name ) 
{ 
  bool retval ;
  bool split_alias ;
  int tmp ;
  bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 838
  retval = (bool )0;
#line 839
  split_alias = (bool )0;
#line 842
  tmp___0 = create_tic_alias(new_name, old_name, current_definitions);
  }
#line 842
  if (tmp___0) {
#line 844
    retval = (bool )-1;
  } else {
#line 846
    if (scope_is_global) {
#line 846
      tmp = 0;
    } else {
#line 846
      tmp = -1;
    }
#line 846
    if (tmp) {
      {
#line 860
      split_alias = (bool )-1;
#line 861
      split_alias_message = 65536;
#line 862
      retval = create_split_alias(new_name, old_name, & global_voc_dict_ptr, current_definitions);
      }
    }
  }
#line 869
  if (retval) {
#line 871
    if (split_alias) {
      {
#line 873
      tmp___1 = in_what_node(current_device_node);
#line 873
      tmp___2 = strupper(old_name);
#line 873
      tokenization_error(split_alias_message, (char *)"%s is a Global definition, but its alias, %s, will only be defined %s",
                         tmp___2, new_name, tmp___1);
#line 878
      show_node_start();
      }
    }
  }
#line 882
  return (retval);
}
}
#line 902 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_hdr_t tokens_table[416]  = 
#line 902
  {      {(char *)"end0", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {0L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(lit)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {16L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(\')", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {17L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(\")", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {18L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bbranch", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {19L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b?branch",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {20L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(loop)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {21L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(+loop)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {22L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(do)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {23L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(?do)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {24L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"i", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {25L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"j", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {26L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(leave)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {27L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(of)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {28L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"execute", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {29L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"+",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {30L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"-", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {31L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {32L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {33L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"mod", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {34L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"and", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {35L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"or", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {36L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xor", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {37L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"invert", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {38L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"not", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {38L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lshift", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {39L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<<", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {39L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rshift", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {40L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {40L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">>a", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {41L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/mod", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {42L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u/mod", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {43L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"negate", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {44L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"abs", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {45L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"min", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {46L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"max", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {47L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">r", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {48L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"r>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {49L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"r@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {50L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"exit", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {51L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {52L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0<>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {53L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0<", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {54L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0<=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {55L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {56L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0>=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {57L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {58L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {59L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {60L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {61L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {62L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u<=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {63L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u<", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {64L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u>=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {65L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {66L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<=", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {67L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"between", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {68L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"within",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {69L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"drop", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {70L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"dup", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {71L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"over", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {72L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"swap", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {73L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rot", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {74L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"-rot", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {75L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"tuck", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {76L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"nip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {77L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"pick", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {78L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"roll", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {79L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"?dup", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {80L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"depth", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {81L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2drop", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {82L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2dup", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {83L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2over", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {84L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2swap", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {85L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2rot", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {86L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2/", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {87L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u2/", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {88L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {89L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/c", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {90L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/w", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {91L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/l", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {92L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/n", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {93L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"ca+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {94L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wa+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {95L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"la+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {96L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"na+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {97L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"char+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {98L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"ca1+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {98L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wa1+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {99L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"la1+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {100L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"cell+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {101L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"na1+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {101L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"chars", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {102L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/c*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {102L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/w*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {103L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/l*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {104L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"cells", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {105L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/n*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {105L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"on", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {106L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"off", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {107L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"+!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {108L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {109L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"l@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {110L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"w@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {111L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<w@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {112L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"c@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {113L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {114L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"l!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {115L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"w!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {116L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"c!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {117L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {118L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {119L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"move", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {120L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fill", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {121L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"comp", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {122L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"noop", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {123L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lwsplit", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {124L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wljoin",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {125L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lbsplit", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {126L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bljoin",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {127L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wbflip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {128L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"flip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {128L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"upc", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {129L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lcc", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {130L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"pack", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {131L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"count", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {132L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"body>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {133L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">body", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {134L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fcode-revision", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {135L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"version",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {135L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"span", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {136L},
      (fwtoken )47, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"unloop", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {137L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"expect", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {138L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"alloc-mem", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {139L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"free-mem",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {140L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"key?", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {141L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"key", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {142L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"emit", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {143L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"type", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {144L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"(cr", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {145L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"cr", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {146L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#out", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {147L},
      (fwtoken )47, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#line", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {148L},
      (fwtoken )47, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"hold", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {149L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<#", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {150L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u#>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {151L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"sign", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {152L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u#", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {153L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u#s", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {154L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u.", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {155L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u.r", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {156L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)".", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {157L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)".r", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {158L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)".s", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {159L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"base", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {160L},
      (fwtoken )47, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"convert", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {161L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"$number",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {162L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"digit", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {163L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"-1", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {164L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"true", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {164L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {165L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"false", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {165L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"struct", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {165L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"1", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {166L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {167L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"3", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {168L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bl", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {169L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bs", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {170L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bell", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {171L},
      (fwtoken )12, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bounds", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {172L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"here", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {173L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"aligned", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {174L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wbsplit",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {175L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bwjoin", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {176L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(<mark)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {177L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(>resolve)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {178L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"set-token-table", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {179L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"set-table",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {180L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"new-token", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {181L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"named-token",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {182L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(:)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {183L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(value)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {184L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(variable)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {185L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(constant)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {186L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(create)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {187L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(defer)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {188L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(buffer:)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {189L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(field)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {190L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(code)",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {191L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"instance", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {192L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(;)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {194L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(to)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {195L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(case)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {196L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(endcase)",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {197L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"b(endof)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {198L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {199L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#s", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {200L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#>", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {201L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"external-token", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {202L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"$find",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {203L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"offset16", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {204L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"evaluate",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {205L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"eval", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {205L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"c,", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {208L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"w,", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {209L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"l,", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {210L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)",", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {211L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"um*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {212L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"u*x", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {212L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"um/mod", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {213L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xu/mod", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {213L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"d+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {216L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"x+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {216L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"d-", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {217L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"x-", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {217L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-token", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {218L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"set-token",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {219L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"state", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {220L},
      (fwtoken )47, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"compile", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {221L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"behavior",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {222L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"start0", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {240L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"start1", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {241L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"start2", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {242L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"start4", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {243L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"ferror", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {252L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"version1", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {253L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"4-byte-id",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {254L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"end1", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {255L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"dma-alloc", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {257L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-address",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {258L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-space", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {259L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"memmap",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {260L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"free-virtual", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {261L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">physical",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {262L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-params", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {271L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"property",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {272L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"attribute", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {272L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"encode-int",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {273L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdrint", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {273L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"encode+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {274L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdr+",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {274L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"encode-phys", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {275L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdrphys",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {275L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"encode-string", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {276L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdrstring",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {276L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"encode-bytes", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {277L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdrbytes",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {277L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"reg", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {278L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"intr", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {279L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"driver",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {280L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"model", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {281L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"device-type", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {282L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"parse-2int",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {283L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"decode-2int", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {283L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"is-install",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {284L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"is-remove", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {285L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"is-selftest",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {286L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"new-device", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {287L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"diagnostic-mode?",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {288L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"display-status", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {289L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"memory-test-issue",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {290L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"group-code", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {291L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"mask",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {292L}, (fwtoken )47,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-msecs", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {293L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"ms",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {294L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"finish-device", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {295L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"decode-phys",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {296L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"interpose", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {299L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"map-low",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {304L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"map-sbus", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {304L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"sbus-intr>cpu",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {305L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#lines", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {336L},
      (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"#columns", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {337L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"line#", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {338L},
      (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"column#", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {339L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"inverse?", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {340L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"inverse-screen?", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {341L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"frame-buffer-busy?", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {342L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"draw-character", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {343L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"reset-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {344L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"toggle-cursor", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {345L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"erase-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {346L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"blink-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {347L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"invert-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {348L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"insert-characters", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {349L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"delete-characters", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {350L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"insert-lines", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {351L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"delete-lines", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {352L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"draw-logo", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {353L}, (fwtoken )16, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"frame-buffer-adr", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {354L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"screen-height", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {355L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"screen-width", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {356L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"window-top", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {357L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"window-left", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {358L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"default-font", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {362L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"set-font",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {363L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"char-height", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {364L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"char-width", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {365L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)">font", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {366L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fontbytes", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {367L}, (fwtoken )46, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-draw-character", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {368L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-reset-screen",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {369L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-toggle-cursor", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {370L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-erase-screen",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {371L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-blink-screen", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {372L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-invert-screen",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {373L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-insert-characters", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {374L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-delete-characters",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {375L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-insert-lines", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {376L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-delete-lines",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {377L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-draw-logo", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {378L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-install",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {379L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb1-slide-up", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {380L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-draw-character",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {384L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-reset-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {385L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-toggle-cursor",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {386L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-erase-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {387L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-blink-screen",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {388L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-invert-screen", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {389L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-insert-characters",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {390L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-delete-characters", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {391L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-insert-lines",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {392L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-delete-lines", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {393L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-draw-logo",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {394L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fb8-install", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {395L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"return-buffer",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {416L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xmit-packet", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {417L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"poll-packet",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {418L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"mac-address", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {420L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"device-name",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {513L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"name", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {513L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-args", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {514L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-self",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {515L}, (fwtoken )46,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"find-package", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {516L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"open-package",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {517L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"close-package", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {518L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"find-method",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {519L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"call-package", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {520L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"$call-parent",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {521L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-parent", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {522L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"ihandle>phandle",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {523L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"my-unit", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {525L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"$call-method",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {526L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"$open-package", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {527L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"processor-type",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {528L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"firmware-version", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {529L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"fcode-version",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {530L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"alarm", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {531L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"(is-user-word)", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {532L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"suspend-fcode",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {533L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"abort", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {534L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"catch", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {535L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"throw", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {536L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"user-abort", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {537L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-my-property",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {538L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-my-attribute", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {538L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"decode-int",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {539L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdrtoint", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {539L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"decode-string",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {540L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xdrtostring", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {540L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-inherited-property",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {541L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-inherited-attribute", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {541L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"delete-property",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {542L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"delete-attribute", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {542L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-package-property",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {543L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"get-package-attribute", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {543L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"cpeek",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {544L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wpeek", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {545L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lpeek", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {546L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"cpoke", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {547L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wpoke", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {548L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lpoke", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {549L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lwflip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {550L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lbflip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {551L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lbflips", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {552L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"adr-mask",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {553L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rb@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {560L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rb!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {561L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rw@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {562L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rw!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {563L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rl@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {564L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rl!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {565L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wbflips", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {566L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wflips",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {566L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lwflips", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {567L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lflips",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {567L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"probe", (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token),
      {568L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"probe-virtual",
      (tic_hdr_t *)((void *)0), (void (*)())(& obsolete_fc_token), {569L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"child", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {571L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"peer", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {572L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"next-property", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {573L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"byte-load",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {574L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"set-args", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {575L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"left-parse-string",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {576L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rx@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {558L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"rx!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {559L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"bxjoin", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {577L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"<l@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {578L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"lxjoin", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {579L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"wxjoin", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {580L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"x,", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {581L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"x@", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {582L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"x!", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {583L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/x", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {584L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"/x*", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {585L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xa+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {586L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xa1+", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {587L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xbflip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {588L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xbflips", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {589L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xbsplit",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {590L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xlflip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {591L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xlflips", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {592L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xlsplit",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {593L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xwflip", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {594L},
      (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xwflips", (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token),
      {595L}, (fwtoken )3131953165U, (bool )-1, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"xwsplit",
      (tic_hdr_t *)((void *)0), (void (*)())(& emit_fc_token), {596L}, (fwtoken )3131953165U,
      (bool )-1, (void (*)())((void *)0), 0, (bool )0}};
#line 1324 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static int const   number_of_builtin_tokens  =    (int const   )(sizeof(tokens_table) / sizeof(tic_hdr_t ));
#line 1365 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void emit_token(char const   *fc_name ) 
{ 
  bool tmp ;

  {
  {
#line 1368
  tmp = handle_tic_vocab((char *)fc_name, fc_tokens_list_start);
  }
#line 1368
  if (tmp) {
#line 1370
    return;
  }
  {
#line 1373
  tokenization_error((-0x7FFFFFFF-1), (char *)"Did not recognize FCode name %s", fc_name);
  }
#line 1374
  return;
}
}
#line 1395 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
tic_hdr_t *lookup_token(char *tname ) 
{ 
  tic_hdr_t *found ;

  {
  {
#line 1399
  found = lookup_tic_entry(tname, fc_tokens_list_start);
  }
#line 1400
  return (found);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
bool entry_is_token(tic_hdr_t *test_entry ) 
{ 
  bool retval ;

  {
#line 1453
  retval = (bool )0;
#line 1454
  if ((unsigned long )test_entry != (unsigned long )((void *)0)) {
#line 1456
    retval = test_entry->is_token;
  }
#line 1458
  return (retval);
}
}
#line 1485 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void token_entry_warning(tic_hdr_t *t_entry ) 
{ 


  {
#line 1487
  if ((unsigned long )t_entry->funct == (unsigned long )(& obsolete_fc_token)) {
    {
#line 1489
    obsolete_warning();
    }
  }
#line 1491
  return;
}
}
#line 1500 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_fwt_hdr_t fwords_list[74]  = 
#line 1500
  {      {(char *)":", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )1}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)";", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )2}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"\'", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )3}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"again", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )4}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[\']", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )6}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"ascii", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )8}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"begin", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )9}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"buffer:", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )10}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"case", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )11}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"constant", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )12}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"control", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )13}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"create", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )14}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"defer", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )16}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"?do", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )18}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"do", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )19}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"else", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )20}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"endcase", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )21}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"endof", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )22}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"external", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )23}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"field", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )25}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"finish-device", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )27}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"headerless", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )29}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"headers", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )30}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"instance", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )24}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"if", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )32}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"unloop", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )33}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"leave", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )34}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"+loop", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )38}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"loop", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )37}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"of", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )40}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"repeat", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )41}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"then", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )42}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"to", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )43}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"is", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )44}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"until", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )45}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"value", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )46}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"variable", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )47}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"while", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )48}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"offset16", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )49}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"\"", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )53}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)".\"", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )54}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)".(", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )55}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)"s\"", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )56}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)"[input-file-name]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )78}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[line-number]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )79}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"recurse", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )58}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"recursive", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )57}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"r@", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )59}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"r>", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )60}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)">r", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )61}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"endif", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )42}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"new-device", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )26}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"i", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )35}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"j", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )36}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"version1", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )236}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"start0", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )232}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"start1", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )233}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"start2", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )234}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"start4", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )235}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"end0", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )215}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"end1", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )216}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"fcode-version1", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )222}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"fcode-version2", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )239}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"fcode-version3", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )223}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"fcode-end", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )255}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"{", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )73}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)"->", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )74}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)"exit", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )76}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"char", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )217}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[char]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )218}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"abort\"", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )219}, (fwtoken )2985574557U, (bool )0, (void (*)())(& skip_string),
      0, (bool )0}, 
        {(char *)"encode-file", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )221}, (fwtoken )2985574557U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"tokenizer[", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )50}, (fwtoken )2985574557U, (bool )0, (void (*)())(& handle_internal),
      0, (bool )0}, 
        {(char *)"f[", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )50}, (fwtoken )2985574557U, (bool )0, (void (*)())(& handle_internal),
      0, (bool )0}};
#line 1591 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static int const   number_of_builtin_fwords  =    (int const   )(sizeof(fwords_list) / sizeof(tic_hdr_t ));
#line 1602 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static tic_fwt_hdr_t shared_words_list[63]  = 
#line 1602
  {      {(char *)"fload", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )52}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"multi-line", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )83}, (fwtoken )3236806878U, (bool )0, (void (*)())(& handle_internal),
      0, (bool )0}, 
        {(char *)"f[\']", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )7}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word),
      0, (bool )0}, 
        {(char *)"alias", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )5}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_two_words_in_line),
      0, (bool )0}, 
        {(char *)"decimal", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )15}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"hex", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )31}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"octal", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )39}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"h#", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )62}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"d#", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )63}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"o#", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )64}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"a#", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )66}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"al#", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )67}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"fliteral", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )28}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[defined]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )17}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"#defined", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )17}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"[#defined]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )17}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"[fcode-date]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )238}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[fcode-time]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )237}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[function-name]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )77}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"#else", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )69}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[else]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )69}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[#else]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )69}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"#then", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )68}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[then]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )68}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[#then]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )68}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"#endif", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )68}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[endif]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )68}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[#endif]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )68}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"overload", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )82}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"global-definitions", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )85}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"device-definitions", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )86}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[FLAG]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )80}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"#FLAG", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )80}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"[#FLAG]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )80}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"[FLAGS]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )81}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"#FLAGS", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )81}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[#FLAGS]", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )81}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"SHOW-FLAGS", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )81}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"FCODE-PUSH", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )70}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"FCODE-POP", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )71}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"FCODE-RESET", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )72}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"pci-header", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )228}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"pci-end", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )229}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"pci-header-end", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )229}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"pci-revision", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )227}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"pci-code-revision", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )227}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"set-rev-level", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )227}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"not-last-image", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )224}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"not-last-img", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )224}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"last-image", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )225}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"last-img", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )225}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"set-last-image", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )226}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"set-last-img", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )226}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"save-image", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )231}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"save-img", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )231}, (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_a_word_in_line),
      0, (bool )0}, 
        {(char *)"reset-symbols", (tic_fwt_hdr_t *)((void *)0), (void (*)())(& handle_internal),
      {(fwtoken )230}, (fwtoken )3236806878U, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"[MACRO]", (tic_fwt_hdr_t *)((void *)0), & add_user_macro, {(fwtoken )0},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_user_macro), 0, (bool )0}, 
        {(char *)"\\",
      (tic_fwt_hdr_t *)((void *)0), (void (*)())(& process_remark), {(fwtoken )'\n'},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& process_remark), 0, (bool )0}, 
        {(char *)"(",
      (tic_fwt_hdr_t *)((void *)0), (void (*)())(& process_remark), {(fwtoken )')'},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& process_remark), 0, (bool )0}, 
        {(char *)"[MESSAGE]",
      (tic_fwt_hdr_t *)((void *)0), (void (*)())(& user_message), {(fwtoken )'\n'},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_user_message), 0, (bool )0}, 
        {(char *)"#MESSAGE",
      (tic_fwt_hdr_t *)((void *)0), (void (*)())(& user_message), {(fwtoken )'\n'},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_user_message), 0, (bool )0}, 
        {(char *)"[#MESSAGE]",
      (tic_fwt_hdr_t *)((void *)0), (void (*)())(& user_message), {(fwtoken )'\n'},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_user_message), 0, (bool )0}, 
        {(char *)"#MESSAGE\"",
      (tic_fwt_hdr_t *)((void *)0), (void (*)())(& user_message), {(fwtoken )'\"'},
      (fwtoken )3236806878U, (bool )0, (void (*)())(& skip_user_message), 0, (bool )0}};
#line 1718 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
static int const   number_of_shared_words  =    (int const   )(sizeof(shared_words_list) / sizeof(tic_hdr_t ));
#line 1753 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
tic_hdr_t *lookup_shared_word(char *tname ) 
{ 
  tic_hdr_t *found ;
  tic_hdr_t *retval ;

  {
  {
#line 1756
  retval = (tic_hdr_t *)((void *)0);
#line 1758
  found = lookup_current(tname);
  }
#line 1759
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 1761
    if ((unsigned int )found->fword_defr == 3236806878U) {
#line 1763
      retval = found;
    }
  }
#line 1767
  return (retval);
}
}
#line 1803 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
tic_hdr_t *lookup_shared_f_exec_word(char *tname ) 
{ 
  tic_hdr_t *found ;
  tic_hdr_t *retval ;

  {
  {
#line 1806
  retval = (tic_hdr_t *)((void *)0);
#line 1808
  found = lookup_shared_word(tname);
  }
#line 1809
  if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 1811
    if ((unsigned long )found->funct == (unsigned long )(& handle_internal)) {
#line 1813
      retval = found;
    }
  }
#line 1817
  return (retval);
}
}
#line 1868 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void init_dictionary(void) 
{ 


  {
  {
#line 1871
  global_voc_dict_ptr = (tic_hdr_t *)((void *)0);
#line 1874
  fc_tokens_list_ender = global_voc_dict_ptr;
#line 1875
  init_tic_vocab(tokens_table, (int )number_of_builtin_tokens, & global_voc_dict_ptr);
#line 1878
  fc_tokens_list_start = global_voc_dict_ptr;
#line 1881
  init_tic_vocab((tic_hdr_t *)(fwords_list), (int )number_of_builtin_fwords, & global_voc_dict_ptr);
#line 1886
  shared_fwords_ender = global_voc_dict_ptr;
#line 1887
  init_tic_vocab((tic_hdr_t *)(shared_words_list), (int )number_of_shared_words, & global_voc_dict_ptr);
#line 1892
  init_conditionals_vocab(& global_voc_dict_ptr);
#line 1895
  init_macros(& global_voc_dict_ptr);
#line 1898
  global_voc_reset_ptr = global_voc_dict_ptr;
#line 1901
  init_tokz_esc_vocab();
  }
#line 1905
  return;
}
}
#line 1952 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void reset_normal_vocabs(void) 
{ 


  {
  {
#line 1954
  reset_tic_vocab(& global_voc_dict_ptr, global_voc_reset_ptr);
  }
  {
#line 1960
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1962
    if ((unsigned long )current_device_node->parent_node != (unsigned long )((void *)0)) {
      {
#line 1964
      tokenization_error(67108864, (char *)"Missing FINISH-DEVICE for new device");
#line 1966
      started_at(current_device_node->ifile_name, current_device_node->line_no);
      }
    }
    {
#line 1969
    delete_device_vocab();
    }
#line 1960
    if (! ((unsigned long )current_device_node->parent_node != (unsigned long )((void *)0))) {
#line 1960
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1972
  return;
}
}
#line 1999 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/dictionary.c"
void reset_vocabs(void) 
{ 


  {
  {
#line 2001
  reset_normal_vocabs();
#line 2002
  reset_tokz_esc();
  }
#line 2003
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static void macro_recursion_error(tic_param_t pfield ) 
{ 


  {
  {
#line 125
  tokenization_error(67108864, (char *)"Recursive invocation of macro named %s\n",
                     statbuf);
  }
#line 127
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static void (*sav_mac_funct)()  ;
#line 225 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static void mac_string_recovery(tic_hdr_t *macro_entry ) 
{ 


  {
#line 227
  macro_entry->funct = sav_mac_funct;
#line 228
  macro_entry->ign_func = sav_mac_funct;
#line 229
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static void eval_mac_string(tic_param_t pfield ) 
{ 
  int mac_str_len ;
  size_t tmp ;

  {
  {
#line 238
  tmp = strlen((char const   *)pfield.chr_ptr);
#line 238
  mac_str_len = (int )tmp;
#line 248
  sav_mac_funct = tic_found->funct;
#line 249
  tic_found->funct = (void (*)())(& macro_recursion_error);
#line 250
  tic_found->ign_func = (void (*)())(& macro_recursion_error);
#line 251
  push_source((void (*)())(& mac_string_recovery), (void *)tic_found, (bool )0);
#line 252
  report_multiline = (bool )0;
#line 256
  init_inbuf(pfield.chr_ptr, (unsigned int )mac_str_len);
  }
#line 257
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static void eval_builtin_mac(tic_param_t pfield ) 
{ 


  {
  {
#line 267
  eval_string(pfield.chr_ptr);
  }
#line 268
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static tic_mac_hdr_t macros_tbl[22]  = 
#line 285
  {      {(char *)"(.)", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"dup abs <# u#s swap sign u#>"}, (fwtoken )84, (bool )0, (void (*)())((void *)0),
      0, (bool )0}, 
        {(char *)"?", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"@ ."}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"1+",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"1 +"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"1-", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"1 -"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2+",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"2 +"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2-", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"2 -"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"accept",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"span @ -rot expect span @ swap span !"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"allot", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"0 max 0 ?do 0 c, loop"}, (fwtoken )84, (bool )0, (void (*)())((void *)0),
      0, (bool )0}, 
        {(char *)"blank", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"bl fill"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"carret",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"h# d"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)".d", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"base @ swap h# a base ! . base !"}, (fwtoken )84, (bool )0, (void (*)())((void *)0),
      0, (bool )0}, 
        {(char *)"decode-bytes", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"tuck - -rot 2dup + swap 2swap rot"}, (fwtoken )84, (bool )0, (void (*)())((void *)0),
      0, (bool )0}, 
        {(char *)"3drop", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"drop 2drop"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"3dup", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"2 pick 2 pick 2 pick"}, (fwtoken )84, (bool )0, (void (*)())((void *)0),
      0, (bool )0}, 
        {(char *)"erase", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"0 fill"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)".h",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"base @ swap h# 10 base ! . base !"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"linefeed", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"h# a"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"s.",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"(.) type space"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"space", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"bl emit"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"spaces",
      (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac), {(char *)"0 max 0 ?do space loop"},
      (fwtoken )84, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"(u.)", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"<# u#s u#>"}, (fwtoken )84, (bool )0, (void (*)())((void *)0), 0,
      (bool )0}, 
        {(char *)"?leave", (tic_mac_hdr_t *)((void *)0), (void (*)())(& eval_builtin_mac),
      {(char *)"if leave then"}, (fwtoken )84, (bool )0, (void (*)())((void *)0),
      0, (bool )0}};
#line 322 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static int const   number_of_builtin_macros  =    (int const   )(sizeof(macros_tbl) / sizeof(tic_mac_hdr_t ));
#line 348 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
void init_macros(tic_hdr_t **tic_vocab_ptr ) 
{ 


  {
  {
#line 350
  init_tic_vocab((tic_hdr_t *)(macros_tbl), (int )number_of_builtin_macros, tic_vocab_ptr);
  }
#line 353
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
static void print_if_mac_err(bool failure , char *func_cpy ) 
{ 
  char *tmp ;

  {
#line 376
  if (failure) {
    {
#line 378
    tmp = strupper(func_cpy);
#line 378
    tokenization_error(67108864, (char *)"%s directive expects name and definition on the same line\n",
                       tmp);
    }
  }
  {
#line 382
  free((void *)func_cpy);
  }
#line 383
  return;
}
}
#line 456
tic_hdr_t *tokz_esc_vocab ;
#line 458 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
void add_user_macro(void) 
{ 
  char *macroname ;
  char *macrobody ;
  bool failure ;
  char *func_cpy ;
  char *tmp ;
  int mac_body_len ;
  tic_hdr_t **target_vocab ;
  size_t tmp___0 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 462
  failure = (bool )-1;
#line 465
  tmp = strdup((char const   *)statbuf);
#line 465
  func_cpy = tmp;
#line 467
  tmp___4 = get_word_in_line((char *)((void *)0));
  }
#line 467
  if (tmp___4) {
    {
#line 470
    macroname = strdup((char const   *)statbuf);
#line 472
    tmp___3 = get_rest_of_line();
    }
#line 472
    if (tmp___3) {
#line 472
      tmp___2 = 0;
    } else {
#line 472
      tmp___2 = -1;
    }
#line 472
    if (tmp___2) {
      {
#line 475
      free((void *)macroname);
      }
    } else {
#line 479
      mac_body_len = 0;
#line 481
      target_vocab = current_definitions;
#line 482
      if (in_tokz_esc) {
#line 482
        target_vocab = & tokz_esc_vocab;
      }
      {
#line 491
      strcat((char */* __restrict  */)statbuf, (char const   */* __restrict  */)"\n");
#line 492
      macrobody = strdup((char const   *)statbuf);
#line 493
      tmp___0 = strlen((char const   *)macrobody);
#line 493
      mac_body_len = (int )tmp___0;
#line 495
      add_tic_entry(macroname, (void (*)())(& eval_mac_string), (long )macrobody,
                    (fwtoken )84, mac_body_len, (bool )0, (void (*)())(& eval_mac_string),
                    target_vocab);
#line 499
      failure = (bool )0;
      }
    }
  }
  {
#line 503
  print_if_mac_err(failure, func_cpy);
  }
#line 504
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/macros.c"
void skip_user_macro(tic_bool_param_t pfield ) 
{ 
  bool failure ;
  char *func_cpy ;
  char *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 538
  failure = (bool )-1;
#line 539
  tmp = strdup((char const   *)statbuf);
#line 539
  func_cpy = tmp;
#line 540
  tmp___1 = get_word_in_line((char *)((void *)0));
  }
#line 540
  if (tmp___1) {
    {
#line 542
    tmp___0 = get_rest_of_line();
    }
#line 542
    if (tmp___0) {
#line 544
      failure = (bool )0;
    }
  }
  {
#line 548
  print_if_mac_err(failure, func_cpy);
  }
#line 550
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
tic_hdr_t *tokz_esc_vocab  =    (tic_hdr_t *)((void *)0);
#line 156 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static int saved_base  ;
#line 158 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
void enter_tokz_esc(void) 
{ 


  {
#line 160
  saved_base = (int )base;
#line 161
  base = (u8 )16;
#line 162
  in_tokz_esc = (bool )-1;
#line 163
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void end_tokz_esc(tic_param_t pfield ) 
{ 


  {
#line 181
  in_tokz_esc = (bool )0;
#line 182
  base = (u8 )saved_base;
#line 183
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void tokz_esc_emit_byte(tic_param_t pfield ) 
{ 
  long num_on_stk ;
  long tmp ;
  u8 byt_to_emit ;
  char *tmp___0 ;

  {
  {
#line 199
  tmp = dpop();
#line 199
  num_on_stk = tmp;
#line 200
  byt_to_emit = (u8 )num_on_stk;
  }
#line 201
  if ((long )byt_to_emit != num_on_stk) {
    {
#line 203
    tmp___0 = strupper((char *)statbuf);
#line 203
    tokenization_error(2097152, (char *)"Value on stack for %s command is 0x%0x.  Truncating to 0x%02x.\n",
                       tmp___0, num_on_stk, (int )byt_to_emit);
    }
  }
  {
#line 208
  user_emit_byte(byt_to_emit);
  }
#line 209
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static bool get_fcode_from_stack(u16 *the_num , bool setting_fc ) 
{ 
  bool retval ;
  char *the_action ;
  u16 legal_minimum ;
  long num_on_stk ;
  long tmp ;
  u16 test_fcode ;
  char *tmp___0 ;

  {
  {
#line 257
  retval = (bool )0;
#line 258
  the_action = (char *)"emit FCode value of";
#line 259
  legal_minimum = (u16 )16;
#line 260
  tmp = dpop();
#line 260
  num_on_stk = tmp;
#line 261
  test_fcode = (u16 )num_on_stk;
  }
#line 263
  if (setting_fc) {
#line 265
    the_action = (char *)"set next fcode to";
#line 266
    legal_minimum = (u16 )2048;
  }
#line 268
  if ((long )test_fcode != num_on_stk) {
    {
#line 270
    tmp___0 = strupper((char *)statbuf);
#line 270
    tokenization_error(2097152, (char *)"Value on stack for %s command is 0x%0x.  Truncating to 0x%03x.\n",
                       tmp___0, num_on_stk, (int )test_fcode);
    }
  }
#line 275
  if ((int )test_fcode >= (int )legal_minimum) {
#line 275
    if ((int )test_fcode <= 4095) {
#line 277
      retval = (bool )-1;
#line 278
      *the_num = test_fcode;
    } else {
      {
#line 279
      tokenization_error(67108864, (char *)"Attempt to %s 0x%x, which violates limit specified by IEEE-1275.  Disallowing.\n",
                         the_action, (int )test_fcode);
      }
    }
  } else {
    {
#line 279
    tokenization_error(67108864, (char *)"Attempt to %s 0x%x, which violates limit specified by IEEE-1275.  Disallowing.\n",
                       the_action, (int )test_fcode);
    }
  }
#line 283
  return (retval);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void tokz_esc_next_fcode(tic_param_t pfield ) 
{ 
  u16 test_fcode ;
  char const   *tmp ;
  bool tmp___0 ;

  {
  {
#line 308
  tmp___0 = get_fcode_from_stack(& test_fcode, (bool )-1);
  }
#line 308
  if (tmp___0) {
#line 310
    if ((int )test_fcode == (int )nextfcode) {
      {
#line 312
      tokenization_error(65536, (char *)"FCode-token Assignment Counter is unchanged from 0x%x.\n",
                         (int )nextfcode);
      }
    } else {
#line 316
      if ((int )test_fcode > (int )nextfcode) {
#line 316
        tmp = "advanced";
      } else {
#line 316
        tmp = "reset";
      }
      {
#line 316
      tokenization_error(65536, (char *)"FCode-token Assignment Counter was 0x%x; has been %s to 0x%x.\n",
                         (int )nextfcode, tmp, (int )test_fcode);
#line 321
      set_next_fcode(test_fcode);
      }
    }
  }
#line 324
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void tokz_emit_fcode(tic_param_t pfield ) 
{ 
  u16 test_fcode ;
  bool tmp ;

  {
  {
#line 347
  tmp = get_fcode_from_stack(& test_fcode, (bool )0);
  }
#line 347
  if (tmp) {
    {
#line 349
    tokenization_error(65536, (char *)"Emitting FCode value of 0x%x\n", (int )test_fcode);
#line 351
    emit_fcode(test_fcode);
    }
  }
#line 353
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void zero_equals(tic_param_t pfield ) 
{ 


  {
#line 368
  if (*dstack == 0L) {
#line 368
    *dstack = -1L;
  } else {
#line 368
    *dstack = 0L;
  }
#line 369
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void tokz_esc_swap(tic_param_t pfield ) 
{ 


  {
  {
#line 382
  swap();
  }
#line 383
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void tokz_esc_two_swap(tic_param_t pfield ) 
{ 


  {
  {
#line 396
  two_swap();
  }
#line 397
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void tokz_esc_noop(tic_param_t pfield ) 
{ 


  {
#line 410
  return;
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void do_constant(tic_param_t pfield ) 
{ 


  {
  {
#line 454
  dpush(pfield.long_val);
  }
#line 455
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static void create_constant(tic_param_t pfield ) 
{ 
  char *c_name_space ;
  long valu ;
  long wlen ;

  {
  {
#line 508
  wlen = get_word();
  }
#line 509
  if (wlen <= 0L) {
    {
#line 511
    warn_unterm(67108864, (char *)"Constant definition", lineno);
    }
#line 512
    return;
  }
  {
#line 515
  valu = dpop();
#line 522
  c_name_space = strdup((char const   *)statbuf);
#line 524
  add_tic_entry(c_name_space, (void (*)())(& do_constant), valu, (fwtoken )12, 0,
                (bool )0, (void (*)())((void *)0), & tokz_esc_vocab);
#line 532
  check_name_length(wlen);
  }
#line 534
  return;
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static tic_hdr_t tokz_esc_vocab_tbl[15]  = 
#line 568
  {      {(char *)"]tokenizer", (tic_hdr_t *)((void *)0), (void (*)())(& end_tokz_esc),
      {0L}, (fwtoken )3131953165U, (bool )0, (void (*)())(& end_tokz_esc), 0, (bool )0}, 
        {(char *)"f]",
      (tic_hdr_t *)((void *)0), (void (*)())(& end_tokz_esc), {0L}, (fwtoken )3131953165U,
      (bool )0, (void (*)())(& end_tokz_esc), 0, (bool )0}, 
        {(char *)"]f", (tic_hdr_t *)((void *)0), (void (*)())(& end_tokz_esc), {0L},
      (fwtoken )3131953165U, (bool )0, (void (*)())(& end_tokz_esc), 0, (bool )0}, 
        {(char *)"emit-byte",
      (tic_hdr_t *)((void *)0), (void (*)())(& tokz_esc_emit_byte), {0L}, (fwtoken )3131953165U,
      (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"next-fcode", (tic_hdr_t *)((void *)0), (void (*)())(& tokz_esc_next_fcode),
      {0L}, (fwtoken )3131953165U, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"emit-fcode",
      (tic_hdr_t *)((void *)0), (void (*)())(& tokz_emit_fcode), {0L}, (fwtoken )3131953165U,
      (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"constant", (tic_hdr_t *)((void *)0), (void (*)())(& create_constant),
      {0L}, (fwtoken )3131953165U, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"0=",
      (tic_hdr_t *)((void *)0), (void (*)())(& zero_equals), {0L}, (fwtoken )3131953165U,
      (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"swap", (tic_hdr_t *)((void *)0), (void (*)())(& tokz_esc_swap), {0L},
      (fwtoken )3131953165U, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"2swap", (tic_hdr_t *)((void *)0), (void (*)())(& tokz_esc_two_swap),
      {0L}, (fwtoken )3131953165U, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"noop",
      (tic_hdr_t *)((void *)0), (void (*)())(& tokz_esc_noop), {0L}, (fwtoken )3131953165U,
      (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"false", (tic_hdr_t *)((void *)0), (void (*)())(& do_constant), {0L},
      (fwtoken )12, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)"true", (tic_hdr_t *)((void *)0), (void (*)())(& do_constant), {-1L},
      (fwtoken )12, (bool )0, (void (*)())((void *)0), 0, (bool )0}, 
        {(char *)".(", (tic_hdr_t *)((void *)0), (void (*)())(& user_message), {(long )')'},
      (fwtoken )3131953165U, (bool )0, (void (*)())(& skip_user_message), 0, (bool )0}, 
        {(char *)".\"",
      (tic_hdr_t *)((void *)0), (void (*)())(& user_message), {(long )'\"'}, (fwtoken )3131953165U,
      (bool )0, (void (*)())(& skip_user_message), 0, (bool )0}};
#line 603 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static tic_hdr_t const   *built_in_tokz_esc  =    (tic_hdr_t const   *)(& tokz_esc_vocab_tbl[sizeof(tokz_esc_vocab_tbl) / sizeof(tic_hdr_t ) - 1UL]);
#line 621 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
static int const   tokz_esc_vocab_max_indx  =    (int const   )(sizeof(tokz_esc_vocab_tbl) / sizeof(tic_hdr_t ));
#line 619 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
void init_tokz_esc_vocab(void) 
{ 


  {
  {
#line 624
  in_tokz_esc = (bool )-1;
#line 625
  tokz_esc_vocab = (tic_hdr_t *)((void *)0);
#line 626
  init_tic_vocab(tokz_esc_vocab_tbl, (int )tokz_esc_vocab_max_indx, & tokz_esc_vocab);
#line 629
  in_tokz_esc = (bool )0;
  }
#line 630
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
tic_hdr_t *lookup_tokz_esc(char *name ) 
{ 
  tic_hdr_t *retval ;
  tic_hdr_t *tmp ;

  {
  {
#line 651
  tmp = lookup_tic_entry(name, tokz_esc_vocab);
#line 651
  retval = tmp;
  }
#line 652
  return (retval);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
bool create_tokz_esc_alias(char *new_name , char *old_name ) 
{ 
  bool retval ;
  bool tmp ;

  {
  {
#line 683
  tmp = create_tic_alias(new_name, old_name, & tokz_esc_vocab);
#line 683
  retval = tmp;
  }
#line 684
  return (retval);
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
void reset_tokz_esc(void) 
{ 


  {
  {
#line 714
  reset_tic_vocab(& tokz_esc_vocab, (tic_hdr_t *)built_in_tokz_esc);
  }
#line 715
  return;
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tokzesc.c"
void pop_next_fcode(void) 
{ 
  tic_param_t dummy_param ;

  {
  {
#line 741
  tokz_esc_next_fcode(dummy_param);
  }
#line 742
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.h"
void tracing_fcode(char *fc_phrase_buff , u16 fc_token_num ) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
int split_alias_message  =    65536;
#line 142 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
static trace_entry_t *trace_list  =    (trace_entry_t *)((void *)0);
#line 143 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
static trace_entry_t *trace_list_last  =    (trace_entry_t *)((void *)0);
#line 145 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
static bool tracing_symbols  =    (bool )0;
#line 183 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void add_to_trace_list(char *trace_symb ) 
{ 
  trace_entry_t *new_t_l_entry ;
  void *tmp ;

  {
  {
#line 185
  tmp = safe_malloc(sizeof(trace_entry_t ), (char *)"adding to trace-list");
#line 185
  new_t_l_entry = (trace_entry_t *)tmp;
#line 187
  new_t_l_entry->tracee = strdup((char const   *)trace_symb);
#line 188
  new_t_l_entry->next = (struct trace_entry *)((void *)0);
  }
#line 190
  if ((unsigned long )trace_list != (unsigned long )((void *)0)) {
#line 192
    trace_list_last->next = new_t_l_entry;
  } else {
#line 194
    trace_list = new_t_l_entry;
#line 195
    tracing_symbols = (bool )-1;
  }
#line 197
  trace_list_last = new_t_l_entry;
#line 198
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
bool is_on_trace_list(char *symb_name ) 
{ 
  bool retval ;
  trace_entry_t *test_entry ;
  int tmp ;

  {
#line 220
  retval = (bool )0;
#line 221
  if (tracing_symbols) {
#line 223
    test_entry = trace_list;
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
#line 224
      if (! ((unsigned long )test_entry != (unsigned long )((void *)0))) {
#line 224
        goto while_break;
      }
      {
#line 226
      tmp = strcasecmp((char const   *)symb_name, (char const   *)test_entry->tracee);
      }
#line 226
      if (tmp == 0) {
#line 228
        retval = (bool )-1;
#line 229
        goto while_break;
      }
#line 231
      test_entry = test_entry->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 234
  return (retval);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void tracing_fcode(char *fc_phrase_buff , u16 fc_token_num ) 
{ 


  {
#line 272
  if ((int )fc_token_num > 0) {
    {
#line 274
    sprintf((char */* __restrict  */)fc_phrase_buff, (char const   */* __restrict  */)" (FCode token = 0x%03x)",
            (int )fc_token_num);
    }
  }
#line 277
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void trace_creation(tic_hdr_t *trace_entry , char *nu_name , bool is_global ) 
{ 
  char fc_token_display[32] ;
  unsigned int tmp ;
  char *head_ness ;
  char *defr_name ;
  char *defr_phrase ;
  char *with_scope ;
  bool def_is_local ;
  int tmp___0 ;
  bool creating_alias ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 340
  fc_token_display[0] = (char )'\000';
#line 340
  tmp = 1U;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (tmp >= 32U) {
#line 340
      goto while_break;
    }
#line 340
    fc_token_display[tmp] = (char)0;
#line 340
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  head_ness = (char *)"";
#line 342
  defr_name = (char *)"";
#line 343
  defr_phrase = (char *)"";
#line 344
  with_scope = (char *)"";
#line 345
  if ((unsigned int )trace_entry->fword_defr == 75U) {
#line 345
    tmp___0 = -1;
  } else {
#line 345
    tmp___0 = 0;
  }
#line 345
  def_is_local = (bool )tmp___0;
#line 346
  if ((unsigned long )nu_name != (unsigned long )((void *)0)) {
#line 346
    tmp___1 = -1;
  } else {
#line 346
    tmp___1 = 0;
  }
#line 346
  creating_alias = (bool )tmp___1;
#line 348
  if (creating_alias) {
#line 350
    head_ness = (char *)"n";
#line 351
    split_alias_message = 32768;
  }
#line 354
  if (in_tokz_esc) {
#line 356
    with_scope = in_tkz_esc_mode;
  } else {
#line 358
    if (! def_is_local) {
#line 360
      if (is_global) {
#line 362
        with_scope = (char *)"with Global scope.\n";
      } else {
        {
#line 364
        with_scope = in_what_node(current_device_node);
        }
      }
    }
#line 368
    if (trace_entry->is_token) {
      {
#line 370
      tracing_fcode(fc_token_display, (u16 )trace_entry->pfield.deflt_elem);
      }
#line 374
      if (! creating_alias) {
        {
#line 378
        if ((unsigned int )hdr_flag == 2U) {
#line 378
          goto case_2;
        }
#line 382
        if ((unsigned int )hdr_flag == 1U) {
#line 382
          goto case_1;
        }
#line 386
        goto switch_default;
        case_2: /* CIL Label */ 
#line 379
        head_ness = (char *)" Headered";
#line 380
        goto switch_break;
        case_1: /* CIL Label */ 
#line 383
        head_ness = (char *)"n External";
#line 384
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 387
        head_ness = (char *)" Headerless";
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 395
  tmp___2 = definer_name(trace_entry->fword_defr, & defr_name);
  }
#line 395
  if (tmp___2) {
#line 397
    defr_phrase = wh_defined;
  } else
#line 404
  if (creating_alias) {
#line 406
    defr_phrase = (char *)", which is defined";
  }
#line 410
  if (creating_alias) {
    {
#line 417
    tokenization_error(32768, (char *)"Creating %s as a%s ALIAS to %s%s%s%s %s", nu_name,
                       head_ness, trace_entry->name, fc_token_display, defr_phrase,
                       defr_name, with_scope);
    }
  } else {
    {
#line 431
    tokenization_error(32768, (char *)"Creating %s%s as a%s %s %s", trace_entry->name,
                       fc_token_display, head_ness, defr_name, with_scope);
    }
  }
#line 450
  if (! in_tokz_esc) {
#line 452
    if (def_is_local) {
      {
#line 454
      in_last_colon((bool )-1);
      }
    } else {
      {
#line 456
      show_node_start();
      }
    }
  }
#line 460
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void trace_create_failure(char *new_name , char *old_name , u16 fc_tokn ) 
{ 
  bool not_alias ;
  int tmp ;
  bool do_it ;
  bool tmp___0 ;
  char fc_token_display[32] ;
  unsigned int tmp___1 ;
  char *as_alias ;
  char const   *tmp___2 ;
  char *alias_name ;
  char const   *tmp___3 ;

  {
#line 487
  if ((unsigned long )old_name == (unsigned long )((void *)0)) {
#line 487
    tmp = -1;
  } else {
#line 487
    tmp = 0;
  }
  {
#line 487
  not_alias = (bool )tmp;
#line 488
  tmp___0 = is_on_trace_list(new_name);
#line 488
  do_it = tmp___0;
  }
#line 490
  if (! do_it) {
#line 490
    if (! not_alias) {
      {
#line 492
      do_it = is_on_trace_list(old_name);
      }
    }
  }
#line 495
  if (do_it) {
#line 497
    fc_token_display[0] = (char )'\000';
#line 497
    tmp___1 = 1U;
    {
#line 497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 497
      if (tmp___1 >= 32U) {
#line 497
        goto while_break;
      }
#line 497
      fc_token_display[tmp___1] = (char)0;
#line 497
      tmp___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 498
    if (not_alias) {
#line 498
      tmp___2 = "";
    } else {
#line 498
      tmp___2 = " as an ALIAS to ";
    }
#line 498
    as_alias = (char *)tmp___2;
#line 499
    if (not_alias) {
#line 499
      tmp___3 = "";
    } else {
#line 499
      tmp___3 = (char const   *)old_name;
    }
#line 499
    alias_name = (char *)tmp___3;
#line 501
    if ((int )fc_tokn > 0) {
      {
#line 503
      tracing_fcode(fc_token_display, fc_tokn);
      }
    }
    {
#line 505
    tokenization_error(32768, (char *)"Failed to create %s%s%s%s\n", new_name, fc_token_display,
                       as_alias, alias_name);
    }
  }
#line 513
  return;
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void traced_name_error(char *trace_name ) 
{ 
  bool tmp ;

  {
  {
#line 542
  tmp = is_on_trace_list(trace_name);
  }
#line 542
  if (tmp) {
    {
#line 544
    tokenization_error(32768, (char *)"Attempt to invoke (undefined) %s.\n", trace_name);
    }
  }
#line 547
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void invoking_traced_name(tic_hdr_t *trace_entry ) 
{ 
  char fc_token_display[32] ;
  unsigned int tmp ;
  char *defr_name ;
  char *defr_phrase ;
  char *defr_space ;
  bool tmp___0 ;

  {
#line 582
  fc_token_display[0] = (char )'\000';
#line 582
  tmp = 1U;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (tmp >= 32U) {
#line 582
      goto while_break;
    }
#line 582
    fc_token_display[tmp] = (char)0;
#line 582
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  defr_name = (char *)"";
#line 584
  defr_phrase = (char *)"";
#line 585
  defr_space = (char *)"";
#line 587
  if (trace_entry->is_token) {
    {
#line 589
    tracing_fcode(fc_token_display, (u16 )trace_entry->pfield.deflt_elem);
    }
  }
  {
#line 593
  tmp___0 = definer_name(trace_entry->fword_defr, & defr_name);
  }
#line 593
  if (tmp___0) {
#line 595
    defr_phrase = (char *)" defined as a";
#line 596
    defr_space = (char *)" ";
  }
  {
#line 600
  tokenization_error(32768, (char *)"Invoking %s%s%s%s%s.\n", trace_entry->name, fc_token_display,
                     defr_phrase, defr_space, defr_name);
  }
#line 610
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void handle_invocation(tic_hdr_t *trace_entry ) 
{ 


  {
#line 638
  if ((unsigned long )trace_entry != (unsigned long )((void *)0)) {
#line 640
    if (trace_entry->tracing) {
      {
#line 642
      invoking_traced_name(trace_entry);
      }
    }
  }
#line 645
  return;
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void show_trace_list(void) 
{ 
  trace_entry_t *test_entry ;

  {
#line 671
  if (tracing_symbols) {
    {
#line 674
    printf((char const   */* __restrict  */)"\nTracing these symbols:");
#line 675
    test_entry = trace_list;
    }
    {
#line 675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 675
      if (! ((unsigned long )test_entry != (unsigned long )((void *)0))) {
#line 675
        goto while_break;
      }
      {
#line 679
      printf((char const   */* __restrict  */)"   %s", test_entry->tracee);
#line 675
      test_entry = test_entry->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 682
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 685
  return;
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/tracesyms.c"
void trace_builtin(tic_hdr_t *trace_entry ) 
{ 
  char fc_token_display[32] ;
  unsigned int tmp ;
  char *defr_name ;
  char *ws_space ;
  char const   *tmp___0 ;
  char *with_scope ;
  char const   *tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 718
  tmp___2 = is_on_trace_list(trace_entry->name);
  }
#line 718
  if (tmp___2) {
#line 720
    fc_token_display[0] = (char )'\000';
#line 720
    tmp = 1U;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (tmp >= 32U) {
#line 720
        goto while_break;
      }
#line 720
      fc_token_display[tmp] = (char)0;
#line 720
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 721
    defr_name = (char *)"word";
#line 722
    if (in_tokz_esc) {
#line 722
      tmp___0 = " ";
    } else {
#line 722
      tmp___0 = "";
    }
#line 722
    ws_space = (char *)tmp___0;
#line 723
    if (in_tokz_esc) {
#line 723
      tmp___1 = (char const   *)in_tkz_esc_mode;
    } else {
#line 723
      tmp___1 = ".\n";
    }
#line 723
    with_scope = (char *)tmp___1;
#line 724
    if (trace_entry->is_token) {
      {
#line 726
      tracing_fcode(fc_token_display, (u16 )trace_entry->pfield.deflt_elem);
      }
    }
    {
#line 729
    definer_name(trace_entry->fword_defr, & defr_name);
#line 730
    trace_entry->tracing = (bool )-1;
#line 731
    tokenization_error(32768, (char *)"%s%s is a built-in %s%s%s", trace_entry->name,
                       fc_token_display, defr_name, ws_space, with_scope);
    }
  }
#line 739
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/../shared/classcodes.c"
static char const   *convert_num_to_name___0(u32 num , num_to_name_table *table ,
                                             int max___0 , char const   *not_found ) 
{ 
  int indx ;
  char const   *retval ;

  {
#line 98
  retval = not_found;
#line 100
  indx = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (indx < max___0)) {
#line 100
      goto while_break;
    }
#line 102
    if (num == (u32 )(table + indx)->classcode) {
#line 104
      retval = (table + indx)->classname;
#line 105
      goto while_break;
    }
#line 100
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (retval);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/../shared/classcodes.c"
static num_to_name_table const   pci_code_type_name_table___0[4]  = {      {(u32 const   )0, "Intel x86"}, 
        {(u32 const   )1, "Open Firmware"}, 
        {(u32 const   )2, "HP PA Risc"}, 
        {(u32 const   )3, "Intel EFI (unofficial)"}};
#line 136 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/../shared/classcodes.c"
static num_to_name_table const   pci_dev_class_name_table___0[134]  = 
#line 136
  {      {(u32 const   )0, "Legacy Device"}, 
        {(u32 const   )256, "VGA-Compatible Device"}, 
        {(u32 const   )65536, "SCSI bus controller"}, 
        {(u32 const   )66048, "Floppy disk controller"}, 
        {(u32 const   )66304, "IPI bus controller"}, 
        {(u32 const   )66560, "RAID controller"}, 
        {(u32 const   )66848, "ATA controller, single stepping"}, 
        {(u32 const   )66864, "ATA controller, continuous"}, 
        {(u32 const   )67072, "Serial ATA controller - vendor specific interface"}, 
        {(u32 const   )67073, "Serial ATA controller - AHCI 1.0 interface"}, 
        {(u32 const   )67328, "Serial Attached SCSI controller"}, 
        {(u32 const   )98304, "Mass Storage controller"}, 
        {(u32 const   )131072, "Ethernet controller"}, 
        {(u32 const   )131328, "Token Ring controller"}, 
        {(u32 const   )131584, "FDDI controller"}, 
        {(u32 const   )131840, "ATM controller"}, 
        {(u32 const   )132096, "ISDN controller"}, 
        {(u32 const   )132352, "WorldFip controller"}, 
        {(u32 const   )163840, "Network controller"}, 
        {(u32 const   )196608, "VGA Display controller"}, 
        {(u32 const   )196609, "8514-compatible Display controller"}, 
        {(u32 const   )196864, "XGA Display controller"}, 
        {(u32 const   )197120, "3D Display controller"}, 
        {(u32 const   )229376, "Display controller"}, 
        {(u32 const   )262144, "Video device"}, 
        {(u32 const   )262400, "Audio device"}, 
        {(u32 const   )262656, "Computer Telephony device"}, 
        {(u32 const   )294912, "Multimedia device"}, 
        {(u32 const   )327680, "RAM memory controller"}, 
        {(u32 const   )327936, "Flash memory controller"}, 
        {(u32 const   )360448, "Memory controller"}, 
        {(u32 const   )393216, "Host bridge"}, 
        {(u32 const   )393472, "ISA bridge"}, 
        {(u32 const   )393728, "EISA bridge"}, 
        {(u32 const   )393984, "MCA bridge"}, 
        {(u32 const   )394240, "PCI-to-PCI bridge"}, 
        {(u32 const   )394241, "PCI-to-PCI bridge (subtractive decoding)"}, 
        {(u32 const   )394496, "PCMCIA bridge"}, 
        {(u32 const   )394752, "NuBus bridge"}, 
        {(u32 const   )395008, "CardBus bridge"}, 
        {(u32 const   )395584, "PCI-to-PCI bridge, Semi-transparent, primary facing Host"}, 
        {(u32 const   )395648,
      "PCI-to-PCI bridge, Semi-transparent, secondary facing Host"}, 
        {(u32 const   )395776, "InfiniBand-to-PCI host bridge"}, 
        {(u32 const   )425984, "Bridge device"}, 
        {(u32 const   )458752, "Generic XT-compatible serial controller"}, 
        {(u32 const   )458753, "16450-compatible serial controller"}, 
        {(u32 const   )458754, "16550-compatible serial controller"}, 
        {(u32 const   )458755, "16650-compatible serial controller"}, 
        {(u32 const   )458756, "16750-compatible serial controller"}, 
        {(u32 const   )458757, "16850-compatible serial controller"}, 
        {(u32 const   )458758, "16950-compatible serial controller"}, 
        {(u32 const   )459008, "Parallel port"}, 
        {(u32 const   )459009, "Bi-directional parallel port"}, 
        {(u32 const   )459010, "ECP 1.X compliant parallel port"}, 
        {(u32 const   )459011, "IEEE1284 controller"}, 
        {(u32 const   )459262, "IEEE1284 target device"}, 
        {(u32 const   )459264, "Multiport serial controller"}, 
        {(u32 const   )459520, "Generic modem"}, 
        {(u32 const   )459521, "Hayes 16450-compatible modem"}, 
        {(u32 const   )459522, "Hayes 16550-compatible modem"}, 
        {(u32 const   )459523, "Hayes 16650-compatible modem"}, 
        {(u32 const   )459524, "Hayes 16750-compatible modem"}, 
        {(u32 const   )459776, "GPIB (IEEE 488.1/2) controller"}, 
        {(u32 const   )460032, "Smart Card"}, 
        {(u32 const   )491520, "Communications device"}, 
        {(u32 const   )524288, "Generic 8259 PIC"}, 
        {(u32 const   )524289, "ISA PIC"}, 
        {(u32 const   )524290, "EISA PIC"}, 
        {(u32 const   )524304, "I/O APIC interrupt controller"}, 
        {(u32 const   )524320, "I/O(x) APIC interrupt controller"}, 
        {(u32 const   )524544, "Generic 8237 DMA controller"}, 
        {(u32 const   )524545, "ISA DMA controller"}, 
        {(u32 const   )524546, "EISA DMA controller"}, 
        {(u32 const   )524800, "Generic 8254 system timer"}, 
        {(u32 const   )524801, "ISA system timer"}, 
        {(u32 const   )524802, "EISA system timer-pair"}, 
        {(u32 const   )525056, "Generic RTC controller"}, 
        {(u32 const   )525057, "ISA RTC controller"}, 
        {(u32 const   )525312, "Generic PCI Hot-Plug controller"}, 
        {(u32 const   )525568, "SD Host controller"}, 
        {(u32 const   )557056, "System peripheral"}, 
        {(u32 const   )589824, "Keyboard controller"}, 
        {(u32 const   )590080, "Digitizer (pen)"}, 
        {(u32 const   )590336, "Mouse controller"}, 
        {(u32 const   )590592, "Scanner controller"}, 
        {(u32 const   )590848, "Generic Gameport controller"}, 
        {(u32 const   )590864, "Legacy Gameport controller"}, 
        {(u32 const   )622592, "Input controller"}, 
        {(u32 const   )655360, "Generic docking station"}, 
        {(u32 const   )688128, "Docking station"}, 
        {(u32 const   )720896, "386 Processor"}, 
        {(u32 const   )721152, "486 Processor"}, 
        {(u32 const   )721408, "Pentium Processor"}, 
        {(u32 const   )724992, "Alpha Processor"}, 
        {(u32 const   )729088, "PowerPC Processor"}, 
        {(u32 const   )733184, "MIPS Processor"}, 
        {(u32 const   )737280, "Co-processor"}, 
        {(u32 const   )786432, "IEEE 1394 (FireWire)"}, 
        {(u32 const   )786448, "IEEE 1394 -- OpenHCI spec"}, 
        {(u32 const   )786688, "ACCESS.bus"}, 
        {(u32 const   )786944, "SSA"}, 
        {(u32 const   )787200, "Universal Serial Bus (UHC spec)"}, 
        {(u32 const   )787216, "Universal Serial Bus (Open Host spec)"}, 
        {(u32 const   )787232, "USB2 Host controller (Intel Enhanced HCI spec)"}, 
        {(u32 const   )787328, "Universal Serial Bus (no PI spec)"}, 
        {(u32 const   )787454, "USB Target Device"}, 
        {(u32 const   )787456, "Fibre Channel"}, 
        {(u32 const   )787712, "System Management Bus"}, 
        {(u32 const   )787968, "InfiniBand"}, 
        {(u32 const   )788224, "IPMI SMIC Interface"}, 
        {(u32 const   )788225, "IPMI Kybd Controller Style Interface"}, 
        {(u32 const   )788226, "IPMI Block Transfer Interface"}, 
        {(u32 const   )788736, "CANbus"}, 
        {(u32 const   )53504, "iRDA compatible controller"}, 
        {(u32 const   )53504, "Consumer IR controller"}, 
        {(u32 const   )53504, "RF controller"}, 
        {(u32 const   )53504, "Bluetooth controller"}, 
        {(u32 const   )53504, "Broadband controller"}, 
        {(u32 const   )53504, "Ethernet (802.11a 5 GHz) controller"}, 
        {(u32 const   )53504, "Ethernet (802.11b 2.4 GHz) controller"}, 
        {(u32 const   )53504, "Wireless controller"}, 
        {(u32 const   )917504, "Message FIFO at offset 040h"}, 
        {(u32 const   )983296, "TV satellite comm. controller"}, 
        {(u32 const   )983552, "Audio satellite comm. controller"}, 
        {(u32 const   )983808, "Voice satellite comm. controller"}, 
        {(u32 const   )984064, "Data satellite comm. controller"}, 
        {(u32 const   )1048576, "Network and computing en/decryption"}, 
        {(u32 const   )1052672, "Entertainment en/decryption"}, 
        {(u32 const   )1081344, "En/Decryption"}, 
        {(u32 const   )1114112, "DPIO modules"}, 
        {(u32 const   )1114368, "Perf. counters"}, 
        {(u32 const   )1118208, "Comm. synch., time and freq. test"}, 
        {(u32 const   )1122304, "Management card"}, 
        {(u32 const   )1146880, "Data acq./Signal proc."}};
#line 319 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/../shared/classcodes.c"
static num_to_name_table const   pci_all_prg_intfcs_table___0[5]  = {      {(u32 const   )257, "IDE controller"}, 
        {(u32 const   )518, "PICMG 2.14 Multi Computing"}, 
        {(u32 const   )1544, "RACEway bridge"}, 
        {(u32 const   )3080, "SERCOS Interface"}, 
        {(u32 const   )3584, "I2O Intelligent I/O, spec 1.0"}};
#line 46 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/romheaders.c"
char *rom  =    (char *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/romheaders.c"
size_t romlen  =    (size_t )0;
#line 61 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/romheaders.c"
static bool dump_rom_header(rom_header_t *data ) 
{ 
  u16 pci_header_signature ;
  u16 sig ;
  int i ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 63
  pci_header_signature = (u16 )21930;
#line 64
  sig = (u16 )(((int )data->signature[0] << 8) | (int )data->signature[1]);
#line 67
  printf((char const   */* __restrict  */)"PCI Expansion ROM Header:\n");
  }
#line 69
  if ((int )sig == (int )pci_header_signature) {
#line 69
    tmp = "Ok";
  } else {
#line 69
    tmp = "Not Ok";
  }
  {
#line 69
  printf((char const   */* __restrict  */)"  Signature: 0x%04x (%s)\n", (int )sig,
         tmp);
#line 72
  printf((char const   */* __restrict  */)"  CPU unique data:");
#line 73
  i = 0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 16)) {
#line 73
      goto while_break;
    }
    {
#line 74
    printf((char const   */* __restrict  */)" 0x%02x", (int )data->reserved[i]);
    }
#line 75
    if (i == 7) {
      {
#line 75
      printf((char const   */* __restrict  */)"\n                  ");
      }
    }
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  printf((char const   */* __restrict  */)"\n  Pointer to PCI Data Structure: 0x%04x\n\n",
         (int )((u16 )(((int )data->data_ptr[1] << 8) | (int )data->data_ptr[0])));
  }
#line 81
  if ((int )sig == (int )pci_header_signature) {
#line 81
    tmp___0 = -1;
  } else {
#line 81
    tmp___0 = 0;
  }
#line 81
  return ((bool )tmp___0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/romheaders.c"
static bool dump_pci_data(pci_data_t *data ) 
{ 
  u32 pci_data_hdr ;
  u32 sig ;
  u32 classcode ;
  u32 dlen ;
  u32 ilen___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 86
  pci_data_hdr = (u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82);
#line 88
  sig = (u32 )(((((int )data->signature[0] << 24) | ((int )data->signature[1] << 16)) | ((int )data->signature[2] << 8)) | (int )data->signature[3]);
#line 89
  classcode = (u32 )((((int )data->class_code[2] << 16) | ((int )data->class_code[1] << 8)) | (int )data->class_code[0]);
#line 90
  dlen = (u32 )((u16 )(((int )data->dlen[1] << 8) | (int )data->dlen[0]));
#line 91
  ilen___0 = (u32 )((u16 )(((int )data->ilen[1] << 8) | (int )data->ilen[0]));
#line 93
  printf((char const   */* __restrict  */)"PCI Data Structure:\n");
#line 94
  printf((char const   */* __restrict  */)"  Signature: 0x%04x \'%c%c%c%c\' ", sig,
         sig >> 24, (sig >> 16) & 255U, (sig >> 8) & 255U, sig & 255U);
  }
#line 96
  if (sig == pci_data_hdr) {
#line 96
    tmp = "Ok";
  } else {
#line 96
    tmp = "Not Ok";
  }
  {
#line 96
  printf((char const   */* __restrict  */)"(%s)\n", tmp);
#line 98
  printf((char const   */* __restrict  */)"  Vendor ID: 0x%04x\n", (int )((u16 )(((int )data->vendor[1] << 8) | (int )data->vendor[0])));
#line 99
  printf((char const   */* __restrict  */)"  Device ID: 0x%04x\n", (int )((u16 )(((int )data->device[1] << 8) | (int )data->device[0])));
#line 100
  printf((char const   */* __restrict  */)"  Vital Product Data:  0x%04x\n", (int )((u16 )(((int )data->vpd[1] << 8) | (int )data->vpd[0])));
#line 102
  printf((char const   */* __restrict  */)"  PCI Data Structure Length: 0x%04x (%d bytes)\n",
         dlen, dlen);
#line 103
  printf((char const   */* __restrict  */)"  PCI Data Structure Revision: 0x%02x\n",
         (int )data->drevision);
#line 104
  tmp___0 = (char *)pci_device_class_name(classcode);
#line 104
  printf((char const   */* __restrict  */)"  Class Code: 0x%06x (%s)\n", classcode,
         tmp___0);
#line 106
  printf((char const   */* __restrict  */)"  Image Length: 0x%04x blocks (%d bytes)\n",
         ilen___0, ilen___0 * 512U);
#line 107
  printf((char const   */* __restrict  */)"  Revision Level of Code/Data: 0x%04x\n",
         (u32 )((u16 )(((int )data->irevision[1] << 8) | (int )data->irevision[0])));
#line 109
  tmp___1 = (char *)pci_code_type_name(data->code_type);
#line 109
  printf((char const   */* __restrict  */)"  Code Type: 0x%02x (%s)\n", (int )data->code_type,
         tmp___1);
  }
#line 111
  if ((int )data->last_image_flag & 128) {
#line 111
    tmp___2 = "";
  } else {
#line 111
    tmp___2 = "not ";
  }
  {
#line 111
  printf((char const   */* __restrict  */)"  Last-Image Flag: 0x%02x (%slast image in rom)\n",
         (int )data->last_image_flag, tmp___2);
#line 114
  printf((char const   */* __restrict  */)"  Reserved: 0x%04x\n\n", (((int )data->reserved_2 >> 8) & 255) | (((int )data->reserved_2 & 255) << 8));
  }
#line 116
  if (sig == (u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82)) {
#line 116
    tmp___3 = -1;
  } else {
#line 116
    tmp___3 = 0;
  }
#line 116
  return ((bool )tmp___3);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/romheaders/romheaders.c"
static void dump_platform_extensions(u8 type , rom_header_t *data ) 
{ 
  u32 entry ;

  {
  {
#line 124
  if ((int )type == 0) {
#line 124
    goto case_0;
  }
#line 160
  if ((int )type == 1) {
#line 160
    goto case_1;
  }
#line 165
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 125
  printf((char const   */* __restrict  */)"Platform specific data for x86 compliant option rom:\n");
#line 126
  printf((char const   */* __restrict  */)"  Initialization Size: 0x%02x (%d bytes)\n",
         (int )data->reserved[0], (int )data->reserved[0] * 512);
  }
  {
#line 135
  if ((int )data->reserved[1] == 235) {
#line 135
    goto case_235;
  }
#line 141
  if ((int )data->reserved[1] == 233) {
#line 141
    goto case_233;
  }
#line 145
  goto switch_default;
  case_235: /* CIL Label */ 
#line 136
  entry = (u32 )((int )data->reserved[2] + 2);
#line 140
  goto switch_break___0;
  case_233: /* CIL Label */ 
#line 142
  entry = (u32 )((((int )data->reserved[3] << 8) | (int )data->reserved[2]) + 3);
#line 144
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 146
  entry = (u32 )0;
#line 147
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 150
  if (entry) {
    {
#line 152
    entry += 3U;
#line 153
    printf((char const   */* __restrict  */)"  Entry point for INIT function: 0x%x\n\n",
           entry);
    }
  } else {
    {
#line 156
    printf((char const   */* __restrict  */)"  Unable to determine entry point for INIT function. Please report.\n\n");
    }
  }
#line 159
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 161
  printf((char const   */* __restrict  */)"Platform specific data for Open Firmware compliant rom:\n");
#line 162
  printf((char const   */* __restrict  */)"  Pointer to FCode program: 0x%04x\n\n",
         ((int )data->reserved[1] << 8) | (int )data->reserved[0]);
  }
#line 164
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"Parsing of platform specific data not available for this image\n\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static char const   *convert_num_to_name___1(u32 num , num_to_name_table *table ,
                                             int max___0 , char const   *not_found ) 
{ 
  int indx ;
  char const   *retval ;

  {
#line 98
  retval = not_found;
#line 100
  indx = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (indx < max___0)) {
#line 100
      goto while_break;
    }
#line 102
    if (num == (u32 )(table + indx)->classcode) {
#line 104
      retval = (table + indx)->classname;
#line 105
      goto while_break;
    }
#line 100
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (retval);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static num_to_name_table const   pci_code_type_name_table___1[4]  = {      {(u32 const   )0, "Intel x86"}, 
        {(u32 const   )1, "Open Firmware"}, 
        {(u32 const   )2, "HP PA Risc"}, 
        {(u32 const   )3, "Intel EFI (unofficial)"}};
#line 136 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static num_to_name_table const   pci_dev_class_name_table___1[134]  = 
#line 136
  {      {(u32 const   )0, "Legacy Device"}, 
        {(u32 const   )256, "VGA-Compatible Device"}, 
        {(u32 const   )65536, "SCSI bus controller"}, 
        {(u32 const   )66048, "Floppy disk controller"}, 
        {(u32 const   )66304, "IPI bus controller"}, 
        {(u32 const   )66560, "RAID controller"}, 
        {(u32 const   )66848, "ATA controller, single stepping"}, 
        {(u32 const   )66864, "ATA controller, continuous"}, 
        {(u32 const   )67072, "Serial ATA controller - vendor specific interface"}, 
        {(u32 const   )67073, "Serial ATA controller - AHCI 1.0 interface"}, 
        {(u32 const   )67328, "Serial Attached SCSI controller"}, 
        {(u32 const   )98304, "Mass Storage controller"}, 
        {(u32 const   )131072, "Ethernet controller"}, 
        {(u32 const   )131328, "Token Ring controller"}, 
        {(u32 const   )131584, "FDDI controller"}, 
        {(u32 const   )131840, "ATM controller"}, 
        {(u32 const   )132096, "ISDN controller"}, 
        {(u32 const   )132352, "WorldFip controller"}, 
        {(u32 const   )163840, "Network controller"}, 
        {(u32 const   )196608, "VGA Display controller"}, 
        {(u32 const   )196609, "8514-compatible Display controller"}, 
        {(u32 const   )196864, "XGA Display controller"}, 
        {(u32 const   )197120, "3D Display controller"}, 
        {(u32 const   )229376, "Display controller"}, 
        {(u32 const   )262144, "Video device"}, 
        {(u32 const   )262400, "Audio device"}, 
        {(u32 const   )262656, "Computer Telephony device"}, 
        {(u32 const   )294912, "Multimedia device"}, 
        {(u32 const   )327680, "RAM memory controller"}, 
        {(u32 const   )327936, "Flash memory controller"}, 
        {(u32 const   )360448, "Memory controller"}, 
        {(u32 const   )393216, "Host bridge"}, 
        {(u32 const   )393472, "ISA bridge"}, 
        {(u32 const   )393728, "EISA bridge"}, 
        {(u32 const   )393984, "MCA bridge"}, 
        {(u32 const   )394240, "PCI-to-PCI bridge"}, 
        {(u32 const   )394241, "PCI-to-PCI bridge (subtractive decoding)"}, 
        {(u32 const   )394496, "PCMCIA bridge"}, 
        {(u32 const   )394752, "NuBus bridge"}, 
        {(u32 const   )395008, "CardBus bridge"}, 
        {(u32 const   )395584, "PCI-to-PCI bridge, Semi-transparent, primary facing Host"}, 
        {(u32 const   )395648,
      "PCI-to-PCI bridge, Semi-transparent, secondary facing Host"}, 
        {(u32 const   )395776, "InfiniBand-to-PCI host bridge"}, 
        {(u32 const   )425984, "Bridge device"}, 
        {(u32 const   )458752, "Generic XT-compatible serial controller"}, 
        {(u32 const   )458753, "16450-compatible serial controller"}, 
        {(u32 const   )458754, "16550-compatible serial controller"}, 
        {(u32 const   )458755, "16650-compatible serial controller"}, 
        {(u32 const   )458756, "16750-compatible serial controller"}, 
        {(u32 const   )458757, "16850-compatible serial controller"}, 
        {(u32 const   )458758, "16950-compatible serial controller"}, 
        {(u32 const   )459008, "Parallel port"}, 
        {(u32 const   )459009, "Bi-directional parallel port"}, 
        {(u32 const   )459010, "ECP 1.X compliant parallel port"}, 
        {(u32 const   )459011, "IEEE1284 controller"}, 
        {(u32 const   )459262, "IEEE1284 target device"}, 
        {(u32 const   )459264, "Multiport serial controller"}, 
        {(u32 const   )459520, "Generic modem"}, 
        {(u32 const   )459521, "Hayes 16450-compatible modem"}, 
        {(u32 const   )459522, "Hayes 16550-compatible modem"}, 
        {(u32 const   )459523, "Hayes 16650-compatible modem"}, 
        {(u32 const   )459524, "Hayes 16750-compatible modem"}, 
        {(u32 const   )459776, "GPIB (IEEE 488.1/2) controller"}, 
        {(u32 const   )460032, "Smart Card"}, 
        {(u32 const   )491520, "Communications device"}, 
        {(u32 const   )524288, "Generic 8259 PIC"}, 
        {(u32 const   )524289, "ISA PIC"}, 
        {(u32 const   )524290, "EISA PIC"}, 
        {(u32 const   )524304, "I/O APIC interrupt controller"}, 
        {(u32 const   )524320, "I/O(x) APIC interrupt controller"}, 
        {(u32 const   )524544, "Generic 8237 DMA controller"}, 
        {(u32 const   )524545, "ISA DMA controller"}, 
        {(u32 const   )524546, "EISA DMA controller"}, 
        {(u32 const   )524800, "Generic 8254 system timer"}, 
        {(u32 const   )524801, "ISA system timer"}, 
        {(u32 const   )524802, "EISA system timer-pair"}, 
        {(u32 const   )525056, "Generic RTC controller"}, 
        {(u32 const   )525057, "ISA RTC controller"}, 
        {(u32 const   )525312, "Generic PCI Hot-Plug controller"}, 
        {(u32 const   )525568, "SD Host controller"}, 
        {(u32 const   )557056, "System peripheral"}, 
        {(u32 const   )589824, "Keyboard controller"}, 
        {(u32 const   )590080, "Digitizer (pen)"}, 
        {(u32 const   )590336, "Mouse controller"}, 
        {(u32 const   )590592, "Scanner controller"}, 
        {(u32 const   )590848, "Generic Gameport controller"}, 
        {(u32 const   )590864, "Legacy Gameport controller"}, 
        {(u32 const   )622592, "Input controller"}, 
        {(u32 const   )655360, "Generic docking station"}, 
        {(u32 const   )688128, "Docking station"}, 
        {(u32 const   )720896, "386 Processor"}, 
        {(u32 const   )721152, "486 Processor"}, 
        {(u32 const   )721408, "Pentium Processor"}, 
        {(u32 const   )724992, "Alpha Processor"}, 
        {(u32 const   )729088, "PowerPC Processor"}, 
        {(u32 const   )733184, "MIPS Processor"}, 
        {(u32 const   )737280, "Co-processor"}, 
        {(u32 const   )786432, "IEEE 1394 (FireWire)"}, 
        {(u32 const   )786448, "IEEE 1394 -- OpenHCI spec"}, 
        {(u32 const   )786688, "ACCESS.bus"}, 
        {(u32 const   )786944, "SSA"}, 
        {(u32 const   )787200, "Universal Serial Bus (UHC spec)"}, 
        {(u32 const   )787216, "Universal Serial Bus (Open Host spec)"}, 
        {(u32 const   )787232, "USB2 Host controller (Intel Enhanced HCI spec)"}, 
        {(u32 const   )787328, "Universal Serial Bus (no PI spec)"}, 
        {(u32 const   )787454, "USB Target Device"}, 
        {(u32 const   )787456, "Fibre Channel"}, 
        {(u32 const   )787712, "System Management Bus"}, 
        {(u32 const   )787968, "InfiniBand"}, 
        {(u32 const   )788224, "IPMI SMIC Interface"}, 
        {(u32 const   )788225, "IPMI Kybd Controller Style Interface"}, 
        {(u32 const   )788226, "IPMI Block Transfer Interface"}, 
        {(u32 const   )788736, "CANbus"}, 
        {(u32 const   )53504, "iRDA compatible controller"}, 
        {(u32 const   )53504, "Consumer IR controller"}, 
        {(u32 const   )53504, "RF controller"}, 
        {(u32 const   )53504, "Bluetooth controller"}, 
        {(u32 const   )53504, "Broadband controller"}, 
        {(u32 const   )53504, "Ethernet (802.11a 5 GHz) controller"}, 
        {(u32 const   )53504, "Ethernet (802.11b 2.4 GHz) controller"}, 
        {(u32 const   )53504, "Wireless controller"}, 
        {(u32 const   )917504, "Message FIFO at offset 040h"}, 
        {(u32 const   )983296, "TV satellite comm. controller"}, 
        {(u32 const   )983552, "Audio satellite comm. controller"}, 
        {(u32 const   )983808, "Voice satellite comm. controller"}, 
        {(u32 const   )984064, "Data satellite comm. controller"}, 
        {(u32 const   )1048576, "Network and computing en/decryption"}, 
        {(u32 const   )1052672, "Entertainment en/decryption"}, 
        {(u32 const   )1081344, "En/Decryption"}, 
        {(u32 const   )1114112, "DPIO modules"}, 
        {(u32 const   )1114368, "Perf. counters"}, 
        {(u32 const   )1118208, "Comm. synch., time and freq. test"}, 
        {(u32 const   )1122304, "Management card"}, 
        {(u32 const   )1146880, "Data acq./Signal proc."}};
#line 319 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/toke/../shared/classcodes.c"
static num_to_name_table const   pci_all_prg_intfcs_table___1[5]  = {      {(u32 const   )257, "IDE controller"}, 
        {(u32 const   )518, "PICMG 2.14 Multi Computing"}, 
        {(u32 const   )1544, "RACEway bridge"}, 
        {(u32 const   )3080, "SERCOS Interface"}, 
        {(u32 const   )3584, "I2O Intelligent I/O, spec 1.0"}};
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
void link_token(token_t *curr_token ) ;
#line 60
void add_token(u16 number , char *name ) ;
#line 68
void printremark(char *str ) ;
#line 82
bool check_tok_seq ;
#line 63 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.h"
unsigned int stream_max ;
#line 64
u8 *indata ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.h"
u16 *double_lit_code ;
#line 56
bool add_fcodes_from_list(char *vf_file_name ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static char *current_vfc_line  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static char *vfc_remainder  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static int vfc_line_no  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static char *vfc_buf_end  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
token_t spcl_func_list[1]  = {      {(char *)"double(lit)", (u16 )-1, (token_t *)((void *)0)}};
#line 111 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static int const   spcl_func_count  =    (int const   )(sizeof(spcl_func_list) / sizeof(token_t ));
#line 118 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
u16 *double_lit_code  =    & spcl_func_list[0].fcode;
#line 137 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static void skip_whitespace(char **string_line_ptr ) 
{ 
  char *cur_char_ptr ;

  {
#line 139
  cur_char_ptr = *string_line_ptr;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((int )*cur_char_ptr != 0)) {
#line 140
      goto while_break;
    }
#line 141
    if ((int )*cur_char_ptr != 9) {
#line 141
      if ((int )*cur_char_ptr != 32) {
#line 142
        *string_line_ptr = cur_char_ptr;
#line 143
        goto while_break;
      }
    }
#line 140
    cur_char_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static bool get_next_vfc_line(void) 
{ 
  bool retval ;

  {
#line 174
  retval = (bool )0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! ((unsigned long )vfc_remainder < (unsigned long )vfc_buf_end)) {
#line 175
      goto while_break;
    }
    {
#line 176
    current_vfc_line = vfc_remainder;
#line 177
    vfc_remainder = strchr((char const   *)current_vfc_line, '\n');
#line 178
    *vfc_remainder = (char)0;
#line 179
    vfc_remainder ++;
#line 180
    vfc_line_no ++;
#line 181
    skip_whitespace(& current_vfc_line);
    }
#line 182
    if ((int )*current_vfc_line == 0) {
#line 183
      goto while_continue;
    }
#line 184
    if ((int )*current_vfc_line == 35) {
#line 185
      goto while_continue;
    }
#line 186
    if ((int )*current_vfc_line == 92) {
#line 187
      goto while_continue;
    }
#line 188
    retval = (bool )-1;
#line 189
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (retval);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static bool did_not_splash  =    (bool )-1;
#line 216 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
static void vfc_splash(char *vf_file_name ) 
{ 
  char *strbfr ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 218
  if (did_not_splash) {
    {
#line 221
    tmp = strlen((char const   *)vf_file_name);
#line 221
    tmp___0 = malloc(tmp + 65UL);
#line 221
    strbfr = (char *)tmp___0;
#line 222
    sprintf((char */* __restrict  */)strbfr, (char const   */* __restrict  */)"Reading additional FCodes from file:  %s\n",
            vf_file_name);
#line 225
    printremark(strbfr);
#line 226
    free((void *)strbfr);
#line 227
    did_not_splash = (bool )0;
    }
  }
#line 229
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/addfcodes.c"
bool add_fcodes_from_list(char *vf_file_name ) 
{ 
  bool retval ;
  int added_fc_count ;
  char *strbfr ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char vs_fc_name[36] ;
  int vs_fc_number ;
  int scan_result ;
  char *lookup_result ;
  char *fc_name_cpy ;
  char *strbfr___0 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *strbfr___1 ;
  void *tmp___4 ;
  char *strbfr___2 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  bool found_spf ;
  int indx ;
  char strbuf[64] ;
  int tmp___8 ;
  bool tmp___9 ;
  char strbfr___3[32] ;

  {
#line 289
  retval = (bool )0;
#line 290
  added_fc_count = 0;
#line 291
  check_tok_seq = (bool )0;
#line 293
  if (verbose) {
    {
#line 294
    vfc_splash(vf_file_name);
    }
  }
  {
#line 296
  tmp___1 = (int )init_stream(vf_file_name);
  }
#line 296
  if (tmp___1 != 0) {
    {
#line 297
    tmp = strlen((char const   *)vf_file_name);
#line 297
    tmp___0 = malloc(tmp + 65UL);
#line 297
    strbfr = (char *)tmp___0;
#line 298
    sprintf((char */* __restrict  */)strbfr, (char const   */* __restrict  */)"Could not open Additional FCodes file:  %s\n",
            vf_file_name);
#line 301
    printremark(strbfr);
#line 302
    free((void *)strbfr);
#line 303
    exit(1);
    }
  }
#line 305
  vfc_remainder = (char *)indata;
#line 306
  vfc_buf_end = (char *)((indata + stream_max) - 1);
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 308
    tmp___9 = get_next_vfc_line();
    }
#line 308
    if (! tmp___9) {
#line 308
      goto while_break;
    }
    {
#line 322
    scan_result = sscanf((char const   */* __restrict  */)current_vfc_line, (char const   */* __restrict  */)"0x%x %32s",
                         & vs_fc_number, vs_fc_name);
    }
#line 325
    if (scan_result != 2) {
      {
#line 326
      scan_result = sscanf((char const   */* __restrict  */)current_vfc_line, (char const   */* __restrict  */)"0X%x %32s",
                           & vs_fc_number, vs_fc_name);
      }
    }
#line 329
    if (scan_result != 2) {
      {
#line 330
      scan_result = sscanf((char const   */* __restrict  */)current_vfc_line, (char const   */* __restrict  */)"%x %32s",
                           & vs_fc_number, vs_fc_name);
      }
    }
#line 334
    if (scan_result != 2) {
      {
#line 335
      tmp___2 = strlen((char const   *)current_vfc_line);
#line 335
      tmp___3 = malloc(tmp___2 + 65UL);
#line 335
      strbfr___0 = (char *)tmp___3;
#line 337
      vfc_splash(vf_file_name);
#line 338
      sprintf((char */* __restrict  */)strbfr___0, (char const   */* __restrict  */)"Line #%d, invalid format.  Ignoring:  %s\n",
              vfc_line_no, current_vfc_line);
#line 341
      printremark(strbfr___0);
#line 342
      free((void *)strbfr___0);
      }
#line 343
      goto while_continue;
    }
#line 346
    if (vs_fc_number < 16) {
#line 346
      goto _L;
    } else
#line 346
    if (vs_fc_number > 2047) {
      _L: /* CIL Label */ 
      {
#line 347
      tmp___4 = malloc((size_t )85);
#line 347
      strbfr___1 = (char *)tmp___4;
#line 348
      vfc_splash(vf_file_name);
#line 349
      sprintf((char */* __restrict  */)strbfr___1, (char const   */* __restrict  */)"Line #%d, FCode number out of range:  0x%x  Ignoring.\n",
              vfc_line_no, vs_fc_number);
#line 352
      printremark(strbfr___1);
#line 353
      free((void *)strbfr___1);
      }
#line 354
      goto while_continue;
    }
    {
#line 357
    lookup_result = lookup_token((u16 )vs_fc_number);
#line 358
    tmp___7 = strcmp((char const   *)lookup_result, "ferror");
    }
#line 358
    if (tmp___7 != 0) {
      {
#line 359
      tmp___5 = strlen((char const   *)lookup_result);
#line 359
      tmp___6 = malloc(tmp___5 + 85UL);
#line 359
      strbfr___2 = (char *)tmp___6;
#line 360
      vfc_splash(vf_file_name);
#line 361
      sprintf((char */* __restrict  */)strbfr___2, (char const   */* __restrict  */)"Line #%d.  FCode number 0x%x is already defined as %s  Ignoring.\n",
              vfc_line_no, vs_fc_number, lookup_result);
#line 365
      printremark(strbfr___2);
#line 366
      free((void *)strbfr___2);
      }
#line 367
      goto while_continue;
    }
#line 372
    found_spf = (bool )0;
#line 374
    indx = 0;
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 374
      if (! (indx < (int )spcl_func_count)) {
#line 374
        goto while_break___0;
      }
      {
#line 375
      tmp___8 = strcmp((char const   *)(vs_fc_name), (char const   *)spcl_func_list[indx].name);
      }
#line 375
      if (tmp___8 == 0) {
        {
#line 377
        found_spf = (bool )-1;
#line 378
        spcl_func_list[indx].fcode = (u16 )vs_fc_number;
#line 379
        link_token(& spcl_func_list[indx]);
#line 380
        added_fc_count ++;
#line 381
        sprintf((char */* __restrict  */)(strbuf), (char const   */* __restrict  */)"Added Special Function FCode number 0x%03x, name %s\n",
                vs_fc_number, vs_fc_name);
#line 383
        printremark(strbuf);
        }
#line 384
        goto while_break___0;
      }
#line 374
      indx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 388
    if (found_spf) {
#line 389
      goto while_continue;
    }
    {
#line 393
    fc_name_cpy = strdup((char const   *)(vs_fc_name));
#line 394
    add_token((u16 )vs_fc_number, fc_name_cpy);
#line 395
    added_fc_count ++;
#line 396
    retval = (bool )-1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if (verbose) {
    {
#line 401
    sprintf((char */* __restrict  */)(strbfr___3), (char const   */* __restrict  */)"Added %d FCode numbers\n",
            added_fc_count);
#line 403
    printremark(strbfr___3);
    }
  }
  {
#line 406
  close_stream();
#line 407
  check_tok_seq = (bool )-1;
  }
#line 408
  return (retval);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
void reset_dictionary(void) ;
#line 63
void freeze_dictionary(void) ;
#line 91
u16 last_defined_token ;
#line 39 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
bool check_tok_seq  =    (bool )-1;
#line 40 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
static token_t *dictionary  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
static char *fcerror  =    (char *)"ferror";
#line 78 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
void link_token(token_t *curr_token ) 
{ 


  {
#line 80
  curr_token->prev = dictionary;
#line 82
  dictionary = curr_token;
#line 83
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
void add_token(u16 number , char *name ) 
{ 
  token_t *curr ;
  void *tmp ;

  {
  {
#line 130
  tmp = malloc(sizeof(token_t ));
#line 130
  curr = (token_t *)tmp;
  }
#line 131
  if (! curr) {
    {
#line 132
    printf((char const   */* __restrict  */)"Out of memory while adding token.\n");
#line 133
    exit(-12);
    }
  }
  {
#line 136
  curr->name = name;
#line 137
  curr->fcode = number;
#line 139
  link_token(curr);
  }
#line 141
  if (check_tok_seq) {
#line 143
    if ((int )number == (int )last_defined_token + 1) {
#line 145
      last_defined_token = number;
    } else
#line 143
    if ((int )last_defined_token == 0) {
#line 145
      last_defined_token = number;
    } else
#line 147
    if ((int )number <= (int )last_defined_token) {
      {
#line 148
      printremark((char *)"Warning:  New token # might overlap previously assigned token #(s).");
      }
    } else {
      {
#line 151
      printremark((char *)"Warning:  New token # out of sequence with previously assigned token #(s).");
#line 154
      last_defined_token = number;
      }
    }
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
token_t detok_table[382]  = 
#line 161
  {      {(char *)"end0", (u16 )0, (token_t *)((void *)0)}, 
        {(char *)"b(lit)", (u16 )16, (token_t *)((void *)0)}, 
        {(char *)"b(\')", (u16 )17, (token_t *)((void *)0)}, 
        {(char *)"b(\")", (u16 )18, (token_t *)((void *)0)}, 
        {(char *)"bbranch", (u16 )19, (token_t *)((void *)0)}, 
        {(char *)"b?branch", (u16 )20, (token_t *)((void *)0)}, 
        {(char *)"b(loop)", (u16 )21, (token_t *)((void *)0)}, 
        {(char *)"b(+loop)", (u16 )22, (token_t *)((void *)0)}, 
        {(char *)"b(do)", (u16 )23, (token_t *)((void *)0)}, 
        {(char *)"b(?do)", (u16 )24, (token_t *)((void *)0)}, 
        {(char *)"i", (u16 )25, (token_t *)((void *)0)}, 
        {(char *)"j", (u16 )26, (token_t *)((void *)0)}, 
        {(char *)"b(leave)", (u16 )27, (token_t *)((void *)0)}, 
        {(char *)"b(of)", (u16 )28, (token_t *)((void *)0)}, 
        {(char *)"execute", (u16 )29, (token_t *)((void *)0)}, 
        {(char *)"+", (u16 )30, (token_t *)((void *)0)}, 
        {(char *)"-", (u16 )31, (token_t *)((void *)0)}, 
        {(char *)"*", (u16 )32, (token_t *)((void *)0)}, 
        {(char *)"/", (u16 )33, (token_t *)((void *)0)}, 
        {(char *)"mod", (u16 )34, (token_t *)((void *)0)}, 
        {(char *)"and", (u16 )35, (token_t *)((void *)0)}, 
        {(char *)"or", (u16 )36, (token_t *)((void *)0)}, 
        {(char *)"xor", (u16 )37, (token_t *)((void *)0)}, 
        {(char *)"invert", (u16 )38, (token_t *)((void *)0)}, 
        {(char *)"lshift", (u16 )39, (token_t *)((void *)0)}, 
        {(char *)"rshift", (u16 )40, (token_t *)((void *)0)}, 
        {(char *)">>a", (u16 )41, (token_t *)((void *)0)}, 
        {(char *)"/mod", (u16 )42, (token_t *)((void *)0)}, 
        {(char *)"u/mod", (u16 )43, (token_t *)((void *)0)}, 
        {(char *)"negate", (u16 )44, (token_t *)((void *)0)}, 
        {(char *)"abs", (u16 )45, (token_t *)((void *)0)}, 
        {(char *)"min", (u16 )46, (token_t *)((void *)0)}, 
        {(char *)"max", (u16 )47, (token_t *)((void *)0)}, 
        {(char *)">r", (u16 )48, (token_t *)((void *)0)}, 
        {(char *)"r>", (u16 )49, (token_t *)((void *)0)}, 
        {(char *)"r@", (u16 )50, (token_t *)((void *)0)}, 
        {(char *)"exit", (u16 )51, (token_t *)((void *)0)}, 
        {(char *)"0=", (u16 )52, (token_t *)((void *)0)}, 
        {(char *)"0<>", (u16 )53, (token_t *)((void *)0)}, 
        {(char *)"0<", (u16 )54, (token_t *)((void *)0)}, 
        {(char *)"0<=", (u16 )55, (token_t *)((void *)0)}, 
        {(char *)"0>", (u16 )56, (token_t *)((void *)0)}, 
        {(char *)"0>=", (u16 )57, (token_t *)((void *)0)}, 
        {(char *)"<", (u16 )58, (token_t *)((void *)0)}, 
        {(char *)">", (u16 )59, (token_t *)((void *)0)}, 
        {(char *)"=", (u16 )60, (token_t *)((void *)0)}, 
        {(char *)"<>", (u16 )61, (token_t *)((void *)0)}, 
        {(char *)"u>", (u16 )62, (token_t *)((void *)0)}, 
        {(char *)"u<=", (u16 )63, (token_t *)((void *)0)}, 
        {(char *)"u<", (u16 )64, (token_t *)((void *)0)}, 
        {(char *)"u>=", (u16 )65, (token_t *)((void *)0)}, 
        {(char *)">=", (u16 )66, (token_t *)((void *)0)}, 
        {(char *)"<=", (u16 )67, (token_t *)((void *)0)}, 
        {(char *)"between", (u16 )68, (token_t *)((void *)0)}, 
        {(char *)"within", (u16 )69, (token_t *)((void *)0)}, 
        {(char *)"drop", (u16 )70, (token_t *)((void *)0)}, 
        {(char *)"dup", (u16 )71, (token_t *)((void *)0)}, 
        {(char *)"over", (u16 )72, (token_t *)((void *)0)}, 
        {(char *)"swap", (u16 )73, (token_t *)((void *)0)}, 
        {(char *)"rot", (u16 )74, (token_t *)((void *)0)}, 
        {(char *)"-rot", (u16 )75, (token_t *)((void *)0)}, 
        {(char *)"tuck", (u16 )76, (token_t *)((void *)0)}, 
        {(char *)"nip", (u16 )77, (token_t *)((void *)0)}, 
        {(char *)"pick", (u16 )78, (token_t *)((void *)0)}, 
        {(char *)"roll", (u16 )79, (token_t *)((void *)0)}, 
        {(char *)"?dup", (u16 )80, (token_t *)((void *)0)}, 
        {(char *)"depth", (u16 )81, (token_t *)((void *)0)}, 
        {(char *)"2drop", (u16 )82, (token_t *)((void *)0)}, 
        {(char *)"2dup", (u16 )83, (token_t *)((void *)0)}, 
        {(char *)"2over", (u16 )84, (token_t *)((void *)0)}, 
        {(char *)"2swap", (u16 )85, (token_t *)((void *)0)}, 
        {(char *)"2rot", (u16 )86, (token_t *)((void *)0)}, 
        {(char *)"2/", (u16 )87, (token_t *)((void *)0)}, 
        {(char *)"u2/", (u16 )88, (token_t *)((void *)0)}, 
        {(char *)"2*", (u16 )89, (token_t *)((void *)0)}, 
        {(char *)"/c", (u16 )90, (token_t *)((void *)0)}, 
        {(char *)"/w", (u16 )91, (token_t *)((void *)0)}, 
        {(char *)"/l", (u16 )92, (token_t *)((void *)0)}, 
        {(char *)"/n", (u16 )93, (token_t *)((void *)0)}, 
        {(char *)"ca+", (u16 )94, (token_t *)((void *)0)}, 
        {(char *)"wa+", (u16 )95, (token_t *)((void *)0)}, 
        {(char *)"la+", (u16 )96, (token_t *)((void *)0)}, 
        {(char *)"na+", (u16 )97, (token_t *)((void *)0)}, 
        {(char *)"char+", (u16 )98, (token_t *)((void *)0)}, 
        {(char *)"wa1+", (u16 )99, (token_t *)((void *)0)}, 
        {(char *)"la1+", (u16 )100, (token_t *)((void *)0)}, 
        {(char *)"cell+", (u16 )101, (token_t *)((void *)0)}, 
        {(char *)"chars", (u16 )102, (token_t *)((void *)0)}, 
        {(char *)"/w*", (u16 )103, (token_t *)((void *)0)}, 
        {(char *)"/l*", (u16 )104, (token_t *)((void *)0)}, 
        {(char *)"cells", (u16 )105, (token_t *)((void *)0)}, 
        {(char *)"on", (u16 )106, (token_t *)((void *)0)}, 
        {(char *)"off", (u16 )107, (token_t *)((void *)0)}, 
        {(char *)"+!", (u16 )108, (token_t *)((void *)0)}, 
        {(char *)"@", (u16 )109, (token_t *)((void *)0)}, 
        {(char *)"l@", (u16 )110, (token_t *)((void *)0)}, 
        {(char *)"w@", (u16 )111, (token_t *)((void *)0)}, 
        {(char *)"<w@", (u16 )112, (token_t *)((void *)0)}, 
        {(char *)"c@", (u16 )113, (token_t *)((void *)0)}, 
        {(char *)"!", (u16 )114, (token_t *)((void *)0)}, 
        {(char *)"l!", (u16 )115, (token_t *)((void *)0)}, 
        {(char *)"w!", (u16 )116, (token_t *)((void *)0)}, 
        {(char *)"c!", (u16 )117, (token_t *)((void *)0)}, 
        {(char *)"2@", (u16 )118, (token_t *)((void *)0)}, 
        {(char *)"2!", (u16 )119, (token_t *)((void *)0)}, 
        {(char *)"move", (u16 )120, (token_t *)((void *)0)}, 
        {(char *)"fill", (u16 )121, (token_t *)((void *)0)}, 
        {(char *)"comp", (u16 )122, (token_t *)((void *)0)}, 
        {(char *)"noop", (u16 )123, (token_t *)((void *)0)}, 
        {(char *)"lwsplit", (u16 )124, (token_t *)((void *)0)}, 
        {(char *)"wljoin", (u16 )125, (token_t *)((void *)0)}, 
        {(char *)"lbsplit", (u16 )126, (token_t *)((void *)0)}, 
        {(char *)"bljoin", (u16 )127, (token_t *)((void *)0)}, 
        {(char *)"wbflip", (u16 )128, (token_t *)((void *)0)}, 
        {(char *)"upc", (u16 )129, (token_t *)((void *)0)}, 
        {(char *)"lcc", (u16 )130, (token_t *)((void *)0)}, 
        {(char *)"pack", (u16 )131, (token_t *)((void *)0)}, 
        {(char *)"count", (u16 )132, (token_t *)((void *)0)}, 
        {(char *)"body>", (u16 )133, (token_t *)((void *)0)}, 
        {(char *)">body", (u16 )134, (token_t *)((void *)0)}, 
        {(char *)"fcode-revision", (u16 )135, (token_t *)((void *)0)}, 
        {(char *)"span", (u16 )136, (token_t *)((void *)0)}, 
        {(char *)"unloop", (u16 )137, (token_t *)((void *)0)}, 
        {(char *)"expect", (u16 )138, (token_t *)((void *)0)}, 
        {(char *)"alloc-mem", (u16 )139, (token_t *)((void *)0)}, 
        {(char *)"free-mem", (u16 )140, (token_t *)((void *)0)}, 
        {(char *)"key?", (u16 )141, (token_t *)((void *)0)}, 
        {(char *)"key", (u16 )142, (token_t *)((void *)0)}, 
        {(char *)"emit", (u16 )143, (token_t *)((void *)0)}, 
        {(char *)"type", (u16 )144, (token_t *)((void *)0)}, 
        {(char *)"(cr", (u16 )145, (token_t *)((void *)0)}, 
        {(char *)"cr", (u16 )146, (token_t *)((void *)0)}, 
        {(char *)"#out", (u16 )147, (token_t *)((void *)0)}, 
        {(char *)"#line", (u16 )148, (token_t *)((void *)0)}, 
        {(char *)"hold", (u16 )149, (token_t *)((void *)0)}, 
        {(char *)"<#", (u16 )150, (token_t *)((void *)0)}, 
        {(char *)"u#>", (u16 )151, (token_t *)((void *)0)}, 
        {(char *)"sign", (u16 )152, (token_t *)((void *)0)}, 
        {(char *)"u#", (u16 )153, (token_t *)((void *)0)}, 
        {(char *)"u#s", (u16 )154, (token_t *)((void *)0)}, 
        {(char *)"u.", (u16 )155, (token_t *)((void *)0)}, 
        {(char *)"u.r", (u16 )156, (token_t *)((void *)0)}, 
        {(char *)".", (u16 )157, (token_t *)((void *)0)}, 
        {(char *)".r", (u16 )158, (token_t *)((void *)0)}, 
        {(char *)".s", (u16 )159, (token_t *)((void *)0)}, 
        {(char *)"base", (u16 )160, (token_t *)((void *)0)}, 
        {(char *)"convert", (u16 )161, (token_t *)((void *)0)}, 
        {(char *)"$number", (u16 )162, (token_t *)((void *)0)}, 
        {(char *)"digit", (u16 )163, (token_t *)((void *)0)}, 
        {(char *)"-1", (u16 )164, (token_t *)((void *)0)}, 
        {(char *)"0", (u16 )165, (token_t *)((void *)0)}, 
        {(char *)"1", (u16 )166, (token_t *)((void *)0)}, 
        {(char *)"2", (u16 )167, (token_t *)((void *)0)}, 
        {(char *)"3", (u16 )168, (token_t *)((void *)0)}, 
        {(char *)"bl", (u16 )169, (token_t *)((void *)0)}, 
        {(char *)"bs", (u16 )170, (token_t *)((void *)0)}, 
        {(char *)"bell", (u16 )171, (token_t *)((void *)0)}, 
        {(char *)"bounds", (u16 )172, (token_t *)((void *)0)}, 
        {(char *)"here", (u16 )173, (token_t *)((void *)0)}, 
        {(char *)"aligned", (u16 )174, (token_t *)((void *)0)}, 
        {(char *)"wbsplit", (u16 )175, (token_t *)((void *)0)}, 
        {(char *)"bwjoin", (u16 )176, (token_t *)((void *)0)}, 
        {(char *)"b(<mark)", (u16 )177, (token_t *)((void *)0)}, 
        {(char *)"b(>resolve)", (u16 )178, (token_t *)((void *)0)}, 
        {(char *)"set-token-table", (u16 )179, (token_t *)((void *)0)}, 
        {(char *)"set-table", (u16 )180, (token_t *)((void *)0)}, 
        {(char *)"new-token", (u16 )181, (token_t *)((void *)0)}, 
        {(char *)"named-token", (u16 )182, (token_t *)((void *)0)}, 
        {(char *)"b(:)", (u16 )183, (token_t *)((void *)0)}, 
        {(char *)"b(value)", (u16 )184, (token_t *)((void *)0)}, 
        {(char *)"b(variable)", (u16 )185, (token_t *)((void *)0)}, 
        {(char *)"b(constant)", (u16 )186, (token_t *)((void *)0)}, 
        {(char *)"b(create)", (u16 )187, (token_t *)((void *)0)}, 
        {(char *)"b(defer)", (u16 )188, (token_t *)((void *)0)}, 
        {(char *)"b(buffer:)", (u16 )189, (token_t *)((void *)0)}, 
        {(char *)"b(field)", (u16 )190, (token_t *)((void *)0)}, 
        {(char *)"b(code)", (u16 )191, (token_t *)((void *)0)}, 
        {(char *)"instance", (u16 )192, (token_t *)((void *)0)}, 
        {(char *)"b(;)", (u16 )194, (token_t *)((void *)0)}, 
        {(char *)"b(to)", (u16 )195, (token_t *)((void *)0)}, 
        {(char *)"b(case)", (u16 )196, (token_t *)((void *)0)}, 
        {(char *)"b(endcase)", (u16 )197, (token_t *)((void *)0)}, 
        {(char *)"b(endof)", (u16 )198, (token_t *)((void *)0)}, 
        {(char *)"#", (u16 )199, (token_t *)((void *)0)}, 
        {(char *)"#s", (u16 )200, (token_t *)((void *)0)}, 
        {(char *)"#>", (u16 )201, (token_t *)((void *)0)}, 
        {(char *)"external-token", (u16 )202, (token_t *)((void *)0)}, 
        {(char *)"$find", (u16 )203, (token_t *)((void *)0)}, 
        {(char *)"offset16", (u16 )204, (token_t *)((void *)0)}, 
        {(char *)"evaluate", (u16 )205, (token_t *)((void *)0)}, 
        {(char *)"c,", (u16 )208, (token_t *)((void *)0)}, 
        {(char *)"w,", (u16 )209, (token_t *)((void *)0)}, 
        {(char *)"l,", (u16 )210, (token_t *)((void *)0)}, 
        {(char *)",", (u16 )211, (token_t *)((void *)0)}, 
        {(char *)"um*", (u16 )212, (token_t *)((void *)0)}, 
        {(char *)"um/mod", (u16 )213, (token_t *)((void *)0)}, 
        {(char *)"d+", (u16 )216, (token_t *)((void *)0)}, 
        {(char *)"d-", (u16 )217, (token_t *)((void *)0)}, 
        {(char *)"get-token", (u16 )218, (token_t *)((void *)0)}, 
        {(char *)"set-token", (u16 )219, (token_t *)((void *)0)}, 
        {(char *)"state", (u16 )220, (token_t *)((void *)0)}, 
        {(char *)"compile", (u16 )221, (token_t *)((void *)0)}, 
        {(char *)"behavior", (u16 )222, (token_t *)((void *)0)}, 
        {(char *)"start0", (u16 )240, (token_t *)((void *)0)}, 
        {(char *)"start1", (u16 )241, (token_t *)((void *)0)}, 
        {(char *)"start2", (u16 )242, (token_t *)((void *)0)}, 
        {(char *)"start4", (u16 )243, (token_t *)((void *)0)}, 
        {(char *)"ferror", (u16 )252, (token_t *)((void *)0)}, 
        {(char *)"version1", (u16 )253, (token_t *)((void *)0)}, 
        {(char *)"4-byte-id", (u16 )254, (token_t *)((void *)0)}, 
        {(char *)"end1", (u16 )255, (token_t *)((void *)0)}, 
        {(char *)"dma-alloc", (u16 )257, (token_t *)((void *)0)}, 
        {(char *)"my-address", (u16 )258, (token_t *)((void *)0)}, 
        {(char *)"my-space", (u16 )259, (token_t *)((void *)0)}, 
        {(char *)"memmap", (u16 )260, (token_t *)((void *)0)}, 
        {(char *)"free-virtual", (u16 )261, (token_t *)((void *)0)}, 
        {(char *)">physical", (u16 )262, (token_t *)((void *)0)}, 
        {(char *)"my-params", (u16 )271, (token_t *)((void *)0)}, 
        {(char *)"property", (u16 )272, (token_t *)((void *)0)}, 
        {(char *)"encode-int", (u16 )273, (token_t *)((void *)0)}, 
        {(char *)"encode+", (u16 )274, (token_t *)((void *)0)}, 
        {(char *)"encode-phys", (u16 )275, (token_t *)((void *)0)}, 
        {(char *)"encode-string", (u16 )276, (token_t *)((void *)0)}, 
        {(char *)"encode-bytes", (u16 )277, (token_t *)((void *)0)}, 
        {(char *)"reg", (u16 )278, (token_t *)((void *)0)}, 
        {(char *)"intr", (u16 )279, (token_t *)((void *)0)}, 
        {(char *)"driver", (u16 )280, (token_t *)((void *)0)}, 
        {(char *)"model", (u16 )281, (token_t *)((void *)0)}, 
        {(char *)"device-type", (u16 )282, (token_t *)((void *)0)}, 
        {(char *)"parse-2int", (u16 )283, (token_t *)((void *)0)}, 
        {(char *)"is-install", (u16 )284, (token_t *)((void *)0)}, 
        {(char *)"is-remove", (u16 )285, (token_t *)((void *)0)}, 
        {(char *)"is-selftest", (u16 )286, (token_t *)((void *)0)}, 
        {(char *)"new-device", (u16 )287, (token_t *)((void *)0)}, 
        {(char *)"diagnostic-mode?", (u16 )288, (token_t *)((void *)0)}, 
        {(char *)"display-status", (u16 )289, (token_t *)((void *)0)}, 
        {(char *)"memory-test-issue", (u16 )290, (token_t *)((void *)0)}, 
        {(char *)"group-code", (u16 )291, (token_t *)((void *)0)}, 
        {(char *)"mask", (u16 )292, (token_t *)((void *)0)}, 
        {(char *)"get-msecs", (u16 )293, (token_t *)((void *)0)}, 
        {(char *)"ms", (u16 )294, (token_t *)((void *)0)}, 
        {(char *)"finish-device", (u16 )295, (token_t *)((void *)0)}, 
        {(char *)"decode-phys", (u16 )296, (token_t *)((void *)0)}, 
        {(char *)"interpose", (u16 )299, (token_t *)((void *)0)}, 
        {(char *)"map-low", (u16 )304, (token_t *)((void *)0)}, 
        {(char *)"sbus-intr>cpu", (u16 )305, (token_t *)((void *)0)}, 
        {(char *)"#lines", (u16 )336, (token_t *)((void *)0)}, 
        {(char *)"#columns", (u16 )337, (token_t *)((void *)0)}, 
        {(char *)"line#", (u16 )338, (token_t *)((void *)0)}, 
        {(char *)"column#", (u16 )339, (token_t *)((void *)0)}, 
        {(char *)"inverse?", (u16 )340, (token_t *)((void *)0)}, 
        {(char *)"inverse-screen?", (u16 )341, (token_t *)((void *)0)}, 
        {(char *)"frame-buffer-busy?", (u16 )342, (token_t *)((void *)0)}, 
        {(char *)"draw-character", (u16 )343, (token_t *)((void *)0)}, 
        {(char *)"reset-screen", (u16 )344, (token_t *)((void *)0)}, 
        {(char *)"toggle-cursor", (u16 )345, (token_t *)((void *)0)}, 
        {(char *)"erase-screen", (u16 )346, (token_t *)((void *)0)}, 
        {(char *)"blink-screen", (u16 )347, (token_t *)((void *)0)}, 
        {(char *)"invert-screen", (u16 )348, (token_t *)((void *)0)}, 
        {(char *)"insert-characters", (u16 )349, (token_t *)((void *)0)}, 
        {(char *)"delete-characters", (u16 )350, (token_t *)((void *)0)}, 
        {(char *)"insert-lines", (u16 )351, (token_t *)((void *)0)}, 
        {(char *)"delete-lines", (u16 )352, (token_t *)((void *)0)}, 
        {(char *)"draw-logo", (u16 )353, (token_t *)((void *)0)}, 
        {(char *)"frame-buffer-adr", (u16 )354, (token_t *)((void *)0)}, 
        {(char *)"screen-height", (u16 )355, (token_t *)((void *)0)}, 
        {(char *)"screen-width", (u16 )356, (token_t *)((void *)0)}, 
        {(char *)"window-top", (u16 )357, (token_t *)((void *)0)}, 
        {(char *)"window-left", (u16 )358, (token_t *)((void *)0)}, 
        {(char *)"default-font", (u16 )362, (token_t *)((void *)0)}, 
        {(char *)"set-font", (u16 )363, (token_t *)((void *)0)}, 
        {(char *)"char-height", (u16 )364, (token_t *)((void *)0)}, 
        {(char *)"char-width", (u16 )365, (token_t *)((void *)0)}, 
        {(char *)">font", (u16 )366, (token_t *)((void *)0)}, 
        {(char *)"fontbytes", (u16 )367, (token_t *)((void *)0)}, 
        {(char *)"fb1-draw-character", (u16 )368, (token_t *)((void *)0)}, 
        {(char *)"fb1-reset-screen", (u16 )369, (token_t *)((void *)0)}, 
        {(char *)"fb1-toggle-cursor", (u16 )370, (token_t *)((void *)0)}, 
        {(char *)"fb1-erase-screen", (u16 )371, (token_t *)((void *)0)}, 
        {(char *)"fb1-blink-screen", (u16 )372, (token_t *)((void *)0)}, 
        {(char *)"fb1-invert-screen", (u16 )373, (token_t *)((void *)0)}, 
        {(char *)"fb1-insert-characters", (u16 )374, (token_t *)((void *)0)}, 
        {(char *)"fb1-delete-characters", (u16 )375, (token_t *)((void *)0)}, 
        {(char *)"fb1-insert-lines", (u16 )376, (token_t *)((void *)0)}, 
        {(char *)"fb1-delete-lines", (u16 )377, (token_t *)((void *)0)}, 
        {(char *)"fb1-draw-logo", (u16 )378, (token_t *)((void *)0)}, 
        {(char *)"fb1-install", (u16 )379, (token_t *)((void *)0)}, 
        {(char *)"fb1-slide-up", (u16 )380, (token_t *)((void *)0)}, 
        {(char *)"fb8-draw-character", (u16 )384, (token_t *)((void *)0)}, 
        {(char *)"fb8-reset-screen", (u16 )385, (token_t *)((void *)0)}, 
        {(char *)"fb8-toggle-cursor", (u16 )386, (token_t *)((void *)0)}, 
        {(char *)"fb8-erase-screen", (u16 )387, (token_t *)((void *)0)}, 
        {(char *)"fb8-blink-screen", (u16 )388, (token_t *)((void *)0)}, 
        {(char *)"fb8-invert-screen", (u16 )389, (token_t *)((void *)0)}, 
        {(char *)"fb8-insert-characters", (u16 )390, (token_t *)((void *)0)}, 
        {(char *)"fb8-delete-characters", (u16 )391, (token_t *)((void *)0)}, 
        {(char *)"fb8-insert-lines", (u16 )392, (token_t *)((void *)0)}, 
        {(char *)"fb8-delete-lines", (u16 )393, (token_t *)((void *)0)}, 
        {(char *)"fb8-draw-logo", (u16 )394, (token_t *)((void *)0)}, 
        {(char *)"fb8-install", (u16 )395, (token_t *)((void *)0)}, 
        {(char *)"return-buffer", (u16 )416, (token_t *)((void *)0)}, 
        {(char *)"xmit-packet", (u16 )417, (token_t *)((void *)0)}, 
        {(char *)"poll-packet", (u16 )418, (token_t *)((void *)0)}, 
        {(char *)"mac-address", (u16 )420, (token_t *)((void *)0)}, 
        {(char *)"device-name", (u16 )513, (token_t *)((void *)0)}, 
        {(char *)"my-args", (u16 )514, (token_t *)((void *)0)}, 
        {(char *)"my-self", (u16 )515, (token_t *)((void *)0)}, 
        {(char *)"find-package", (u16 )516, (token_t *)((void *)0)}, 
        {(char *)"open-package", (u16 )517, (token_t *)((void *)0)}, 
        {(char *)"close-package", (u16 )518, (token_t *)((void *)0)}, 
        {(char *)"find-method", (u16 )519, (token_t *)((void *)0)}, 
        {(char *)"call-package", (u16 )520, (token_t *)((void *)0)}, 
        {(char *)"$call-parent", (u16 )521, (token_t *)((void *)0)}, 
        {(char *)"my-parent", (u16 )522, (token_t *)((void *)0)}, 
        {(char *)"ihandle>phandle", (u16 )523, (token_t *)((void *)0)}, 
        {(char *)"my-unit", (u16 )525, (token_t *)((void *)0)}, 
        {(char *)"$call-method", (u16 )526, (token_t *)((void *)0)}, 
        {(char *)"$open-package", (u16 )527, (token_t *)((void *)0)}, 
        {(char *)"processor-type", (u16 )528, (token_t *)((void *)0)}, 
        {(char *)"firmware-version", (u16 )529, (token_t *)((void *)0)}, 
        {(char *)"fcode-version", (u16 )530, (token_t *)((void *)0)}, 
        {(char *)"alarm", (u16 )531, (token_t *)((void *)0)}, 
        {(char *)"(is-user-word)", (u16 )532, (token_t *)((void *)0)}, 
        {(char *)"suspend-fcode", (u16 )533, (token_t *)((void *)0)}, 
        {(char *)"abort", (u16 )534, (token_t *)((void *)0)}, 
        {(char *)"catch", (u16 )535, (token_t *)((void *)0)}, 
        {(char *)"throw", (u16 )536, (token_t *)((void *)0)}, 
        {(char *)"user-abort", (u16 )537, (token_t *)((void *)0)}, 
        {(char *)"get-my-property", (u16 )538, (token_t *)((void *)0)}, 
        {(char *)"decode-int", (u16 )539, (token_t *)((void *)0)}, 
        {(char *)"decode-string", (u16 )540, (token_t *)((void *)0)}, 
        {(char *)"get-inherited-property", (u16 )541, (token_t *)((void *)0)}, 
        {(char *)"delete-property", (u16 )542, (token_t *)((void *)0)}, 
        {(char *)"get-package-property", (u16 )543, (token_t *)((void *)0)}, 
        {(char *)"cpeek", (u16 )544, (token_t *)((void *)0)}, 
        {(char *)"wpeek", (u16 )545, (token_t *)((void *)0)}, 
        {(char *)"lpeek", (u16 )546, (token_t *)((void *)0)}, 
        {(char *)"cpoke", (u16 )547, (token_t *)((void *)0)}, 
        {(char *)"wpoke", (u16 )548, (token_t *)((void *)0)}, 
        {(char *)"lpoke", (u16 )549, (token_t *)((void *)0)}, 
        {(char *)"lwflip", (u16 )550, (token_t *)((void *)0)}, 
        {(char *)"lbflip", (u16 )551, (token_t *)((void *)0)}, 
        {(char *)"lbflips", (u16 )552, (token_t *)((void *)0)}, 
        {(char *)"adr-mask", (u16 )553, (token_t *)((void *)0)}, 
        {(char *)"rb@", (u16 )560, (token_t *)((void *)0)}, 
        {(char *)"rb!", (u16 )561, (token_t *)((void *)0)}, 
        {(char *)"rw@", (u16 )562, (token_t *)((void *)0)}, 
        {(char *)"rw!", (u16 )563, (token_t *)((void *)0)}, 
        {(char *)"rl@", (u16 )564, (token_t *)((void *)0)}, 
        {(char *)"rl!", (u16 )565, (token_t *)((void *)0)}, 
        {(char *)"wbflips", (u16 )566, (token_t *)((void *)0)}, 
        {(char *)"lwflips", (u16 )567, (token_t *)((void *)0)}, 
        {(char *)"probe", (u16 )568, (token_t *)((void *)0)}, 
        {(char *)"probe-virtual", (u16 )569, (token_t *)((void *)0)}, 
        {(char *)"child", (u16 )571, (token_t *)((void *)0)}, 
        {(char *)"peer", (u16 )572, (token_t *)((void *)0)}, 
        {(char *)"next-property", (u16 )573, (token_t *)((void *)0)}, 
        {(char *)"byte-load", (u16 )574, (token_t *)((void *)0)}, 
        {(char *)"set-args", (u16 )575, (token_t *)((void *)0)}, 
        {(char *)"left-parse-string", (u16 )576, (token_t *)((void *)0)}, 
        {(char *)"rx@", (u16 )558, (token_t *)((void *)0)}, 
        {(char *)"rx!", (u16 )559, (token_t *)((void *)0)}, 
        {(char *)"bxjoin", (u16 )577, (token_t *)((void *)0)}, 
        {(char *)"<l@", (u16 )578, (token_t *)((void *)0)}, 
        {(char *)"lxjoin", (u16 )579, (token_t *)((void *)0)}, 
        {(char *)"wxjoin", (u16 )580, (token_t *)((void *)0)}, 
        {(char *)"x,", (u16 )581, (token_t *)((void *)0)}, 
        {(char *)"x@", (u16 )582, (token_t *)((void *)0)}, 
        {(char *)"x!", (u16 )583, (token_t *)((void *)0)}, 
        {(char *)"/x", (u16 )584, (token_t *)((void *)0)}, 
        {(char *)"/x*", (u16 )585, (token_t *)((void *)0)}, 
        {(char *)"xa+", (u16 )586, (token_t *)((void *)0)}, 
        {(char *)"xa1+", (u16 )587, (token_t *)((void *)0)}, 
        {(char *)"xbflip", (u16 )588, (token_t *)((void *)0)}, 
        {(char *)"xbflips", (u16 )589, (token_t *)((void *)0)}, 
        {(char *)"xbsplit", (u16 )590, (token_t *)((void *)0)}, 
        {(char *)"xlflip", (u16 )591, (token_t *)((void *)0)}, 
        {(char *)"xlflips", (u16 )592, (token_t *)((void *)0)}, 
        {(char *)"xlsplit", (u16 )593, (token_t *)((void *)0)}, 
        {(char *)"xwflip", (u16 )594, (token_t *)((void *)0)}, 
        {(char *)"xwflips", (u16 )595, (token_t *)((void *)0)}, 
        {(char *)"xwsplit", (u16 )596, (token_t *)((void *)0)}};
#line 549 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
static int const   dictionary_indx_max  =    (int const   )(sizeof(detok_table) / sizeof(token_t ));
#line 552 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
static token_t *dictionary_reset_position  ;
#line 566 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
void reset_dictionary(void) 
{ 
  token_t *next_t ;

  {
#line 570
  next_t = dictionary;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! ((unsigned long )next_t != (unsigned long )dictionary_reset_position)) {
#line 571
      goto while_break;
    }
    {
#line 572
    next_t = dictionary->prev;
#line 573
    free((void *)dictionary->name);
#line 574
    free((void *)dictionary);
#line 575
    dictionary = next_t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/dictionary.c"
void freeze_dictionary(void) 
{ 


  {
#line 582
  dictionary_reset_position = dictionary;
#line 583
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
void detokenize(void) ;
#line 78
bool decode_all ;
#line 79
bool show_linenumbers ;
#line 80
bool show_offsets ;
#line 55 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.c"
bool decode_all  =    (bool )0;
#line 56 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.c"
bool show_linenumbers  =    (bool )0;
#line 57 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.c"
bool show_offsets  =    (bool )0;
#line 61 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.c"
static void print_copyright___0(bool is_error ) 
{ 
  void (*pfunct)() ;
  char buffr[512] ;

  {
  {
#line 67
  sprintf((char */* __restrict  */)(buffr), (char const   */* __restrict  */)"Welcome to detok - OpenBIOS detokenizer v1.0.2\n(C) Copyright 2001-2006 Stefan Reinauer.\n(C) Copyright 2006 coresystems GmbH <info@coresystems.de>\n(C) Copyright 2005 IBM Corporation.  All Rights Reserved.\nWritten by Stefan Reinauer, <stepan@openbios.org>\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License v2. This program has absolutely no warranty.\n\n");
  }
#line 75
  if (is_error) {
#line 75
    pfunct = (void (*)())(& printf);
  } else {
#line 75
    pfunct = (void (*)())(& printremark);
  }
  {
#line 77
  (*pfunct)(buffr);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.c"
static void usage___0(char *name ) 
{ 


  {
  {
#line 82
  printf((char const   */* __restrict  */)"usage: %s [OPTION]... [FCODE-FILE]...\n\n         -v, --verbose     print fcode numbers\n         -a, --all         don\'t stop at end0\n         -n, --linenumbers print line numbers\n         -o, --offsets     print byte offsets\n         -f, --fcodes      add FCodes from list-file\n         -h, --help        print this help text\n\n",
         name);
  }
#line 89
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.c"
static struct option long_options___0[7]  = {      {"verbose", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"all", 0, (int *)0, 'a'}, 
        {"linenumbers", 0, (int *)0, 'n'}, 
        {"offsets", 0, (int *)0, 'o'}, 
        {"fcodes", 1, (int *)0, 'f'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 74 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.h"
bool more_to_go(void) ;
#line 45
void adjust_for_pci_header(void) ;
#line 46
void adjust_for_pci_filler(void) ;
#line 47
void init_fcode_block(void) ;
#line 49
int get_streampos(void) ;
#line 50
void set_streampos(int pos ) ;
#line 52
u16 next_token(void) ;
#line 53
u8 get_num8(void) ;
#line 54
u16 get_num16(void) ;
#line 55
u32 get_num32(void) ;
#line 56
s16 get_offset(void) ;
#line 57
u8 *get_string(u8 *len ) ;
#line 58
char *get_name(u8 *len ) ;
#line 59
u16 calc_checksum(void) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.h"
unsigned int stream_max  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.h"
u8 *indata  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.h"
u8 *max  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
int handle_pci_header(u8 *data_ptr ) ;
#line 71
void handle_pci_filler(u8 *filler_ptr ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
u16 fcode  ;
#line 86
bool end_found ;
#line 87
unsigned int linenum ;
#line 89
u8 *pci_image_end ;
#line 90
unsigned int token_streampos ;
#line 43 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
jmp_buf eof_exception ;
#line 77 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
static u8 *fc_start  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
static bool pci_image_found  =    (bool )0;
#line 121 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
void init_fcode_block(void) 
{ 


  {
#line 123
  fc_start = pc;
#line 124
  linenum = 1U;
#line 125
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
int get_streampos(void) 
{ 


  {
#line 136
  return ((int )(pc - fc_start));
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
void set_streampos(int pos ) 
{ 


  {
#line 141
  pc = fc_start + pos;
#line 142
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
static void throw_eof(bool premature ) 
{ 
  char yoo ;
  char eee ;

  {
#line 173
  yoo = (char )'U';
#line 174
  eee = (char )'E';
#line 175
  if (premature) {
    {
#line 176
    printf((char const   */* __restrict  */)"Premature ");
#line 177
    yoo = (char )'u';
#line 178
    eee = (char )'e';
    }
  }
#line 180
  if (! end_found) {
    {
#line 181
    printf((char const   */* __restrict  */)"%cnexpected ", (int )yoo);
#line 182
    eee = (char )'e';
    }
  }
  {
#line 184
  printf((char const   */* __restrict  */)"%cnd of file.\n", (int )eee);
#line 185
  longjmp((struct __jmp_buf_tag *)(eof_exception), -1);
  }
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
static u8 *get_bytes(int nbytes ) 
{ 
  u8 *retval ;

  {
#line 231
  retval = pc;
#line 232
  if ((unsigned long )pc == (unsigned long )max) {
    {
#line 233
    throw_eof((bool )0);
    }
  }
#line 235
  if ((unsigned long )(pc + nbytes) > (unsigned long )max) {
    {
#line 236
    throw_eof((bool )-1);
    }
  }
#line 238
  pc += nbytes;
#line 239
  return (retval);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
bool more_to_go(void) 
{ 
  bool retval ;

  {
#line 254
  if ((unsigned long )pc == (unsigned long )max) {
#line 254
    retval = (bool )0;
  } else {
#line 254
    retval = (bool )-1;
  }
#line 255
  return (retval);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
u16 next_token(void) 
{ 
  u16 tok ;
  int tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;

  {
  {
#line 278
  tmp = get_streampos();
#line 278
  token_streampos = (unsigned int )tmp;
#line 279
  tmp___0 = get_bytes(1);
#line 279
  tok = (u16 )*tmp___0;
  }
#line 280
  if ((int )tok != 0) {
#line 280
    if ((int )tok < 16) {
      {
#line 281
      tok = (u16 )((int )tok << 8);
#line 282
      tmp___1 = get_bytes(1);
#line 282
      tok = (u16 )((int )tok | (int )*tmp___1);
      }
    }
  }
#line 284
  fcode = tok;
#line 285
  return (tok);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
u32 get_num32(void) 
{ 
  u32 retval ;
  u8 *num_str ;

  {
  {
#line 293
  num_str = get_bytes(4);
#line 294
  retval = (u32 )(((((int )*(num_str + 0) << 24) | ((int )*(num_str + 1) << 16)) | ((int )*(num_str + 2) << 8)) | (int )*(num_str + 3));
  }
#line 296
  return (retval);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
u16 get_num16(void) 
{ 
  u16 retval ;
  u8 *num_str ;

  {
  {
#line 304
  num_str = get_bytes(2);
#line 305
  retval = (u16 )(((int )*(num_str + 0) << 8) | (int )*(num_str + 1));
  }
#line 307
  return (retval);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
u8 get_num8(void) 
{ 
  u8 inbyte ;
  u8 *tmp ;

  {
  {
#line 314
  tmp = get_bytes(1);
#line 314
  inbyte = *tmp;
  }
#line 315
  return (inbyte);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
s16 get_offset(void) 
{ 
  s16 retval ;
  u16 tmp ;
  u8 tmp___0 ;
  int tmp___1 ;

  {
#line 321
  if (offs16) {
    {
#line 322
    tmp = get_num16();
#line 322
    retval = (s16 )tmp;
    }
  } else {
    {
#line 324
    tmp___0 = get_num8();
#line 324
    retval = (s16 )tmp___0;
    }
#line 326
    if ((int )retval & 128) {
#line 326
      tmp___1 = 65280;
    } else {
#line 326
      tmp___1 = 0;
    }
#line 326
    retval = (s16 )((int )retval | tmp___1);
  }
#line 329
  return (retval);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
u8 *get_string(u8 *len ) 
{ 
  char *retval ;
  u8 *tmp ;

  {
  {
#line 361
  *len = get_num8();
#line 362
  tmp = get_bytes((int )*len);
#line 362
  retval = (char *)tmp;
  }
#line 364
  return ((u8 *)retval);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
char *get_name(u8 *len ) 
{ 
  char *str_start ;
  char *retval ;
  u8 sav_byt ;
  u8 *tmp ;

  {
  {
#line 408
  tmp = get_string(len);
#line 408
  str_start = (char *)tmp;
#line 410
  sav_byt = *pc;
#line 411
  *pc = (u8 )0;
#line 413
  retval = strdup((char const   *)str_start);
#line 414
  *pc = sav_byt;
  }
#line 416
  return (retval);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
u16 calc_checksum(void) 
{ 
  u16 retval ;
  u8 *cksmptr ;
  u8 *save_pc ;
  u32 fc_blk_len ;
  int indx ;
  u8 *tmp ;

  {
  {
#line 449
  retval = (u16 )0;
#line 455
  save_pc = pc;
#line 457
  fc_blk_len = get_num32();
#line 458
  cksmptr = get_bytes((int )(fc_blk_len - 8U));
#line 460
  indx = 8;
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! ((u32 )indx < fc_blk_len)) {
#line 460
      goto while_break;
    }
#line 461
    tmp = cksmptr;
#line 461
    cksmptr ++;
#line 461
    retval = (u16 )((int )retval + (int )*tmp);
#line 460
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  pc = save_pc;
#line 465
  return (retval);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
void adjust_for_pci_header(void) 
{ 
  int pci_header_size ;

  {
  {
#line 507
  pci_header_size = handle_pci_header(pc);
  }
#line 508
  if (pci_header_size > 0) {
#line 508
    pci_image_found = (bool )-1;
  } else {
#line 508
    pci_image_found = (bool )0;
  }
#line 509
  pc += pci_header_size;
#line 510
  fc_start += pci_header_size;
#line 511
  last_defined_token = (u16 )0;
#line 512
  return;
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/stream.c"
void adjust_for_pci_filler(void) 
{ 
  int pci_filler_len ;
  u8 *pci_filler_ptr ;

  {
#line 539
  if (pci_image_found) {
    {
#line 543
    pci_filler_len = (int )(pci_image_end - pc);
#line 544
    pci_filler_ptr = get_bytes(pci_filler_len);
#line 545
    handle_pci_filler(pci_filler_ptr);
#line 546
    pci_image_found = (bool )0;
    }
  }
#line 548
  return;
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
unsigned int linenum  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/detok.h"
unsigned int token_streampos  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static int indent  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static bool ended_okay  =    (bool )-1;
#line 61 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
bool end_found  =    (bool )0;
#line 63 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
u16 last_defined_token  =    (u16 )0;
#line 65 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
jmp_buf eof_exception  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static int fclen  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static char const   *unnamed  =    "(unnamed-fcode)";
#line 70 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_indent(void) 
{ 
  int i ;

  {
#line 73
  if (indent < 0) {
#line 77
    indent = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < indent)) {
#line 79
      goto while_break;
    }
    {
#line 80
    printf((char const   */* __restrict  */)"    ");
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void pretty_print_string(void) 
{ 
  u8 len ;
  u8 *strptr ;
  int indx ;
  bool in_parens ;
  char const   *tmp ;
  u8 c ;
  u8 *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 89
  in_parens = (bool )0;
#line 91
  strptr = get_string(& len);
  }
#line 93
  if ((int )len >= 10) {
#line 93
    tmp = "0x";
  } else {
#line 93
    tmp = "";
  }
  {
#line 93
  printf((char const   */* __restrict  */)"( len=%s%x", tmp, (int )len);
  }
#line 94
  if ((int )len >= 10) {
    {
#line 95
    printf((char const   */* __restrict  */)" [%d bytes]", (int )len);
    }
  }
  {
#line 96
  printf((char const   */* __restrict  */)" )\n");
  }
#line 97
  if (show_linenumbers) {
    {
#line 98
    printf((char const   */* __restrict  */)"        ");
    }
  }
  {
#line 99
  decode_indent();
#line 100
  printf((char const   */* __restrict  */)"\" ");
#line 102
  indx = 0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (indx < (int )len)) {
#line 102
      goto while_break;
    }
    {
#line 103
    tmp___0 = strptr;
#line 103
    strptr ++;
#line 103
    c = *tmp___0;
#line 104
    tmp___1 = __ctype_b_loc();
    }
#line 104
    if ((int const   )*(*tmp___1 + (int )c) & 16384) {
#line 105
      if (in_parens) {
        {
#line 106
        printf((char const   */* __restrict  */)" )");
#line 107
        in_parens = (bool )0;
        }
      }
      {
#line 109
      printf((char const   */* __restrict  */)"%c", (int )c);
      }
#line 111
      if ((int )c == 34) {
        {
#line 112
        printf((char const   */* __restrict  */)"%c", (int )c);
        }
      }
    } else {
#line 114
      if (! in_parens) {
        {
#line 115
        printf((char const   */* __restrict  */)"\"(");
#line 116
        in_parens = (bool )-1;
        }
      }
      {
#line 118
      printf((char const   */* __restrict  */)" %02x", (int )c);
      }
    }
#line 102
    indx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (in_parens) {
    {
#line 122
    printf((char const   */* __restrict  */)" )");
    }
  }
  {
#line 123
  printf((char const   */* __restrict  */)"\"");
  }
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_lines(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 128
  if (show_linenumbers) {
#line 129
    if (show_offsets) {
#line 129
      tmp___0 = token_streampos;
    } else {
#line 129
      tmp = linenum;
#line 129
      linenum ++;
#line 129
      tmp___0 = tmp;
    }
    {
#line 129
    printf((char const   */* __restrict  */)"%6d: ", tmp___0);
    }
  }
#line 131
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void output_token_name(void) 
{ 
  char *tname ;
  char temp_buf[80] ;
  int buf_pos ;
  u8 top_byte ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 180
  if ((int )fcode > (int )last_defined_token) {
#line 180
    if ((int )last_defined_token > 0) {
      {
#line 183
      top_byte = (u8 )((int )fcode >> 8);
#line 184
      printf((char const   */* __restrict  */)"Invalid token:  [0x%03x]\n", (int )fcode);
#line 185
      sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"Backing up over first byte, which is ");
#line 186
      tmp = strlen((char const   *)(temp_buf));
#line 186
      buf_pos = (int )tmp;
      }
#line 187
      if ((int )top_byte < 10) {
        {
#line 188
        sprintf((char */* __restrict  */)(& temp_buf[buf_pos]), (char const   */* __restrict  */)" %02x",
                (int )top_byte);
        }
      } else {
        {
#line 190
        sprintf((char */* __restrict  */)(& temp_buf[buf_pos]), (char const   */* __restrict  */)"0x%02x ( =dec %d)",
                (int )top_byte, (int )top_byte);
        }
      }
      {
#line 193
      printremark(temp_buf);
#line 194
      set_streampos((int )(token_streampos + 1U));
      }
#line 195
      return;
    }
  }
  {
#line 199
  tname = lookup_token(fcode);
#line 200
  printf((char const   */* __restrict  */)"%s ", tname);
#line 208
  tmp___0 = strcmp((char const   *)tname, unnamed);
  }
#line 208
  if (tmp___0 == 0) {
    {
#line 209
    printf((char const   */* __restrict  */)"[0x%03x] ", (int )fcode);
    }
  } else
#line 211
  if (verbose) {
    {
#line 216
    printf((char const   */* __restrict  */)"( 0x%03x ) ", (int )fcode);
    }
  }
#line 219
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void output_token(void) 
{ 


  {
  {
#line 237
  decode_lines();
#line 238
  decode_indent();
#line 239
  output_token_name();
  }
#line 240
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static s16 decode_offset(void) 
{ 
  s16 offs ;
  int dest ;
  bool invalid_dest ;
  int streampos ;
  int tmp ;

  {
  {
#line 293
  tmp = get_streampos();
#line 293
  streampos = tmp;
#line 295
  output_token();
#line 296
  offs = get_offset();
#line 302
  dest = streampos + (int )offs;
  }
#line 311
  if (dest <= 0) {
#line 311
    invalid_dest = (bool )-1;
  } else
#line 311
  if ((unsigned int )dest > stream_max) {
#line 311
    invalid_dest = (bool )-1;
  } else
#line 311
  if ((int )offs == 0) {
#line 311
    invalid_dest = (bool )-1;
  } else {
#line 311
    invalid_dest = (bool )0;
  }
#line 316
  if (offs16) {
    {
#line 317
    printf((char const   */* __restrict  */)"0x%04x (", (int )((u16 )((int )offs & 65535)));
    }
  } else {
    {
#line 319
    printf((char const   */* __restrict  */)"0x%02x (", (int )((u8 )((int )offs & 255)));
    }
  }
#line 321
  if ((int )offs < 0) {
    {
#line 322
    printf((char const   */* __restrict  */)" =dec %d", (int )offs);
    }
  } else
#line 321
  if ((int )offs > 9) {
    {
#line 322
    printf((char const   */* __restrict  */)" =dec %d", (int )offs);
    }
  }
#line 324
  if (show_offsets) {
    {
#line 325
    printf((char const   */* __restrict  */)"  dest = %d ", dest);
    }
  } else
#line 324
  if (invalid_dest) {
    {
#line 325
    printf((char const   */* __restrict  */)"  dest = %d ", dest);
    }
  }
  {
#line 327
  printf((char const   */* __restrict  */)")\n");
  }
#line 329
  if (invalid_dest) {
#line 330
    if ((int )offs == 0) {
      {
#line 331
      printremark((char *)"Error:  Unresolved offset.");
      }
    } else {
      {
#line 333
      printremark((char *)"Error:  Invalid offset.  Ignoring...");
#line 335
      set_streampos(streampos);
      }
    }
  }
#line 338
  return (offs);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_default(void) 
{ 


  {
  {
#line 343
  output_token();
#line 344
  printf((char const   */* __restrict  */)"\n");
  }
#line 345
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void new_token(void) 
{ 
  u16 token ;
  char *tmp ;

  {
  {
#line 350
  output_token();
#line 351
  token = next_token();
#line 352
  printf((char const   */* __restrict  */)"0x%03x\n", (int )token);
#line 353
  tmp = strdup(unnamed);
#line 353
  add_token(token, tmp);
  }
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void named_token(void) 
{ 
  u16 token ;
  u8 len ;
  u8 *string ;
  char *tmp ;

  {
  {
#line 362
  output_token();
#line 364
  tmp = get_name(& len);
#line 364
  string = (u8 *)tmp;
#line 365
  token = next_token();
#line 366
  printf((char const   */* __restrict  */)"%s 0x%03x\n", string, (int )token);
#line 367
  add_token(token, (char *)string);
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void bquote(void) 
{ 


  {
  {
#line 372
  output_token();
#line 374
  pretty_print_string();
#line 375
  printf((char const   */* __restrict  */)"\n");
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void blit(void) 
{ 
  u32 lit ;

  {
  {
#line 382
  output_token();
#line 383
  lit = get_num32();
#line 384
  printf((char const   */* __restrict  */)"0x%x\n", lit);
  }
#line 385
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void double_length_literal(void) 
{ 
  u16 quadhh ;
  u16 quadhl ;
  u16 quadlh ;
  u16 quadll ;

  {
  {
#line 391
  output_token();
#line 392
  quadhh = get_num16();
#line 393
  quadhl = get_num16();
#line 394
  quadlh = get_num16();
#line 395
  quadll = get_num16();
#line 396
  printf((char const   */* __restrict  */)"0x%04x.%04x.%04x.%04x\n", (int )quadhh,
         (int )quadhl, (int )quadlh, (int )quadll);
  }
#line 397
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void offset16(void) 
{ 


  {
  {
#line 401
  decode_default();
#line 402
  offs16 = (bool )-1;
  }
#line 403
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_branch(void) 
{ 
  s16 offs ;

  {
  {
#line 408
  offs = decode_offset();
  }
#line 409
  if ((int )offs >= 0) {
#line 410
    indent ++;
  } else {
#line 412
    indent --;
  }
#line 413
  return;
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_two(void) 
{ 
  u16 token ;

  {
  {
#line 419
  output_token();
#line 420
  token = next_token();
#line 421
  output_token_name();
#line 422
  printf((char const   */* __restrict  */)"\n");
  }
#line 423
  return;
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_start(void) 
{ 
  u8 fcformat ;
  u16 fcchecksum ;
  u16 checksum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u32 tmp___3 ;

  {
  {
#line 439
  checksum = (u16 )0;
#line 441
  output_token();
  }
#line 442
  if (offs16) {
#line 442
    tmp = 16;
  } else {
#line 442
    tmp = 8;
  }
  {
#line 442
  printf((char const   */* __restrict  */)"  ( %d-bit offsets)\n", tmp);
#line 444
  tmp___0 = get_streampos();
#line 444
  token_streampos = (unsigned int )tmp___0;
#line 445
  decode_lines();
#line 446
  fcformat = get_num8();
#line 447
  printf((char const   */* __restrict  */)"  format:    0x%02x\n", (int )fcformat);
#line 452
  tmp___1 = get_streampos();
#line 452
  token_streampos = (unsigned int )tmp___1;
#line 453
  decode_lines();
#line 454
  fcchecksum = get_num16();
#line 455
  checksum = calc_checksum();
  }
#line 457
  if ((int )fcchecksum == (int )checksum) {
    {
#line 458
    printf((char const   */* __restrict  */)"  checksum:  0x%04x (Ok)\n", (int )fcchecksum);
    }
  } else {
    {
#line 460
    printf((char const   */* __restrict  */)"  checksum should be:  0x%04x, but is 0x%04x\n",
           (int )checksum, (int )fcchecksum);
    }
  }
  {
#line 464
  tmp___2 = get_streampos();
#line 464
  token_streampos = (unsigned int )tmp___2;
#line 465
  decode_lines();
#line 466
  tmp___3 = get_num32();
#line 466
  fclen = (int )tmp___3;
#line 467
  printf((char const   */* __restrict  */)"  len:       0x%04x ( %d bytes)\n", fclen,
         fclen);
  }
#line 468
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_token(u16 token ) 
{ 
  bool handy_flag ;

  {
#line 485
  handy_flag = (bool )-1;
  {
#line 487
  if ((int )token == 181) {
#line 487
    goto case_181;
  }
#line 491
  if ((int )token == 202) {
#line 491
    goto case_202;
  }
#line 491
  if ((int )token == 182) {
#line 491
    goto case_202;
  }
#line 494
  if ((int )token == 18) {
#line 494
    goto case_18;
  }
#line 497
  if ((int )token == 16) {
#line 497
    goto case_16;
  }
#line 500
  if ((int )token == 204) {
#line 500
    goto case_204;
  }
#line 504
  if ((int )token == 20) {
#line 504
    goto case_20;
  }
#line 504
  if ((int )token == 19) {
#line 504
    goto case_20;
  }
#line 509
  if ((int )token == 196) {
#line 509
    goto case_196;
  }
#line 509
  if ((int )token == 177) {
#line 509
    goto case_196;
  }
#line 509
  if ((int )token == 183) {
#line 509
    goto case_196;
  }
#line 515
  if ((int )token == 197) {
#line 515
    goto case_197;
  }
#line 515
  if ((int )token == 178) {
#line 515
    goto case_197;
  }
#line 515
  if ((int )token == 194) {
#line 515
    goto case_197;
  }
#line 521
  if ((int )token == 198) {
#line 521
    goto case_198;
  }
#line 521
  if ((int )token == 22) {
#line 521
    goto case_198;
  }
#line 521
  if ((int )token == 21) {
#line 521
    goto case_198;
  }
#line 527
  if ((int )token == 28) {
#line 527
    goto case_28;
  }
#line 527
  if ((int )token == 24) {
#line 527
    goto case_28;
  }
#line 527
  if ((int )token == 23) {
#line 527
    goto case_28;
  }
#line 532
  if ((int )token == 195) {
#line 532
    goto case_195;
  }
#line 532
  if ((int )token == 17) {
#line 532
    goto case_195;
  }
#line 535
  if ((int )token == 253) {
#line 535
    goto case_253;
  }
#line 540
  if ((int )token == 243) {
#line 540
    goto case_243;
  }
#line 540
  if ((int )token == 242) {
#line 540
    goto case_243;
  }
#line 540
  if ((int )token == 241) {
#line 540
    goto case_243;
  }
#line 540
  if ((int )token == 240) {
#line 540
    goto case_243;
  }
#line 547
  if ((int )token == 255) {
#line 547
    goto case_255;
  }
#line 547
  if ((int )token == 0) {
#line 547
    goto case_255;
  }
#line 560
  goto switch_default;
  case_181: /* CIL Label */ 
  {
#line 488
  new_token();
  }
#line 489
  goto switch_break;
  case_202: /* CIL Label */ 
  case_182: /* CIL Label */ 
  {
#line 492
  named_token();
  }
#line 493
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 495
  bquote();
  }
#line 496
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 498
  blit();
  }
#line 499
  goto switch_break;
  case_204: /* CIL Label */ 
  {
#line 501
  offset16();
  }
#line 502
  goto switch_break;
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  {
#line 505
  decode_branch();
  }
#line 506
  goto switch_break;
  case_196: /* CIL Label */ 
  case_177: /* CIL Label */ 
  case_183: /* CIL Label */ 
  {
#line 510
  decode_default();
#line 511
  indent ++;
  }
#line 512
  goto switch_break;
  case_197: /* CIL Label */ 
  case_178: /* CIL Label */ 
  case_194: /* CIL Label */ 
  {
#line 516
  indent --;
#line 517
  decode_default();
  }
#line 518
  goto switch_break;
  case_198: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 522
  indent --;
#line 523
  decode_offset();
  }
#line 524
  goto switch_break;
  case_28: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  {
#line 528
  decode_offset();
#line 529
  indent ++;
  }
#line 530
  goto switch_break;
  case_195: /* CIL Label */ 
  case_17: /* CIL Label */ 
  {
#line 533
  decode_two();
  }
#line 534
  goto switch_break;
  case_253: /* CIL Label */ 
#line 536
  handy_flag = (bool )0;
  case_243: /* CIL Label */ 
  case_242: /* CIL Label */ 
  case_241: /* CIL Label */ 
  case_240: /* CIL Label */ 
  {
#line 541
  offs16 = handy_flag;
#line 542
  printremark((char *)"Unexpected FCode-Block Starter.");
#line 543
  decode_start();
#line 544
  printremark((char *)"  Ignoring length field.");
  }
#line 545
  goto switch_break;
  case_255: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 548
  end_found = (bool )-1;
#line 549
  decode_default();
  }
#line 550
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 563
  if ((int )token == (int )*double_lit_code) {
    {
#line 565
    double_length_literal();
    }
#line 566
    goto switch_break;
  }
  {
#line 569
  decode_default();
  }
  switch_break: /* CIL Label */ ;
  }
#line 572
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_fcode_header(void) 
{ 
  long err_pos ;
  u16 token ;
  bool new_offs16 ;
  int tmp ;
  char temp_bufr[128] ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 614
  new_offs16 = (bool )-1;
#line 616
  tmp = get_streampos();
#line 616
  err_pos = (long )tmp;
#line 617
  indent = 0;
#line 618
  token = next_token();
  }
  {
#line 621
  if ((int )token == 253) {
#line 621
    goto case_253;
  }
#line 626
  if ((int )token == 243) {
#line 626
    goto case_243;
  }
#line 626
  if ((int )token == 242) {
#line 626
    goto case_243;
  }
#line 626
  if ((int )token == 241) {
#line 626
    goto case_243;
  }
#line 626
  if ((int )token == 240) {
#line 626
    goto case_243;
  }
#line 630
  goto switch_default;
  case_253: /* CIL Label */ 
#line 622
  new_offs16 = (bool )0;
  case_243: /* CIL Label */ 
  case_242: /* CIL Label */ 
  case_241: /* CIL Label */ 
  case_240: /* CIL Label */ 
  {
#line 627
  offs16 = new_offs16;
#line 628
  decode_start();
  }
#line 629
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 632
  temp_bufr[0] = (char )'I';
#line 632
  temp_bufr[1] = (char )'n';
#line 632
  temp_bufr[2] = (char )'v';
#line 632
  temp_bufr[3] = (char )'a';
#line 632
  temp_bufr[4] = (char )'l';
#line 632
  temp_bufr[5] = (char )'i';
#line 632
  temp_bufr[6] = (char )'d';
#line 632
  temp_bufr[7] = (char )' ';
#line 632
  temp_bufr[8] = (char )'F';
#line 632
  temp_bufr[9] = (char )'C';
#line 632
  temp_bufr[10] = (char )'o';
#line 632
  temp_bufr[11] = (char )'d';
#line 632
  temp_bufr[12] = (char )'e';
#line 632
  temp_bufr[13] = (char )' ';
#line 632
  temp_bufr[14] = (char )'S';
#line 632
  temp_bufr[15] = (char )'t';
#line 632
  temp_bufr[16] = (char )'a';
#line 632
  temp_bufr[17] = (char )'r';
#line 632
  temp_bufr[18] = (char )'t';
#line 632
  temp_bufr[19] = (char )' ';
#line 632
  temp_bufr[20] = (char )'B';
#line 632
  temp_bufr[21] = (char )'y';
#line 632
  temp_bufr[22] = (char )'t';
#line 632
  temp_bufr[23] = (char )'e';
#line 632
  temp_bufr[24] = (char )'.';
#line 632
  temp_bufr[25] = (char )' ';
#line 632
  temp_bufr[26] = (char )' ';
#line 632
  temp_bufr[27] = (char )'I';
#line 632
  temp_bufr[28] = (char )'g';
#line 632
  temp_bufr[29] = (char )'n';
#line 632
  temp_bufr[30] = (char )'o';
#line 632
  temp_bufr[31] = (char )'r';
#line 632
  temp_bufr[32] = (char )'i';
#line 632
  temp_bufr[33] = (char )'n';
#line 632
  temp_bufr[34] = (char )'g';
#line 632
  temp_bufr[35] = (char )' ';
#line 632
  temp_bufr[36] = (char )'F';
#line 632
  temp_bufr[37] = (char )'C';
#line 632
  temp_bufr[38] = (char )'o';
#line 632
  temp_bufr[39] = (char )'d';
#line 632
  temp_bufr[40] = (char )'e';
#line 632
  temp_bufr[41] = (char )' ';
#line 632
  temp_bufr[42] = (char )'h';
#line 632
  temp_bufr[43] = (char )'e';
#line 632
  temp_bufr[44] = (char )'a';
#line 632
  temp_bufr[45] = (char )'d';
#line 632
  temp_bufr[46] = (char )'e';
#line 632
  temp_bufr[47] = (char )'r';
#line 632
  temp_bufr[48] = (char )'.';
#line 632
  temp_bufr[49] = (char )'\000';
#line 632
  tmp___0 = 50U;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (tmp___0 >= 128U) {
#line 632
      goto while_break;
    }
#line 632
    temp_bufr[tmp___0] = (char)0;
#line 632
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  set_streampos((int )err_pos);
#line 635
  fclen = (int )(max - pc);
#line 636
  printf((char const   */* __restrict  */)"\n");
  }
#line 637
  if (show_linenumbers) {
    {
#line 638
    tmp___1 = strlen((char const   *)(temp_bufr));
#line 638
    sprintf((char */* __restrict  */)(& temp_bufr[tmp___1]), (char const   */* __restrict  */)"  Remaining len = 0x%04x ( %d bytes)",
            fclen, fclen);
    }
  }
  {
#line 642
  printremark(temp_bufr);
  }
  switch_break: /* CIL Label */ ;
  }
#line 645
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static void decode_fcode_block(void) 
{ 
  u16 token ;
  unsigned int fc_block_start ;
  unsigned int fc_block_end ;
  int tmp ;
  int tmp___0 ;
  char temp_bufr[80] ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 688
  end_found = (bool )0;
#line 689
  tmp = get_streampos();
#line 689
  fc_block_start = (unsigned int )tmp;
#line 691
  decode_fcode_header();
#line 693
  fc_block_end = fc_block_start + (unsigned int )fclen;
  }
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! end_found) {
#line 695
      goto _L;
    } else
#line 695
    if (decode_all) {
      _L: /* CIL Label */ 
      {
#line 695
      tmp___0 = get_streampos();
      }
#line 695
      if (! ((unsigned int )tmp___0 < fc_block_end)) {
#line 695
        goto while_break;
      }
    } else {
#line 695
      goto while_break;
    }
    {
#line 697
    token = next_token();
#line 698
    decode_token(token);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  if (! end_found) {
    {
#line 701
    printremark((char *)"FCode-ender not found");
    }
  }
  {
#line 708
  tmp___2 = get_streampos();
  }
#line 708
  if ((unsigned int )tmp___2 == fc_block_end) {
    {
#line 709
    sprintf((char */* __restrict  */)(temp_bufr), (char const   */* __restrict  */)"Detokenization finished normally after %d bytes.",
            fc_block_end - fc_block_start);
    }
  } else {
    {
#line 713
    tmp___1 = get_streampos();
#line 713
    sprintf((char */* __restrict  */)(temp_bufr), (char const   */* __restrict  */)"Detokenization finished prematurely after %d of %d bytes.",
            (unsigned int )tmp___1 - fc_block_start, fc_block_end - fc_block_start);
#line 717
    ended_okay = (bool )0;
    }
  }
  {
#line 719
  printremark(temp_bufr);
  }
#line 721
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
static bool another_fcode_block(void) 
{ 
  bool retval ;
  u16 token ;
  char temp_bufr[80] ;

  {
  {
#line 753
  retval = (bool )0;
#line 756
  token = next_token();
#line 757
  set_streampos((int )token_streampos);
  }
  {
#line 764
  if ((int )token == 243) {
#line 764
    goto case_243;
  }
#line 764
  if ((int )token == 242) {
#line 764
    goto case_243;
  }
#line 764
  if ((int )token == 241) {
#line 764
    goto case_243;
  }
#line 764
  if ((int )token == 240) {
#line 764
    goto case_243;
  }
#line 764
  if ((int )token == 253) {
#line 764
    goto case_243;
  }
#line 769
  if ((int )token == 0) {
#line 769
    goto case_0;
  }
#line 772
  goto switch_default;
  case_243: /* CIL Label */ 
  case_242: /* CIL Label */ 
  case_241: /* CIL Label */ 
  case_240: /* CIL Label */ 
  case_253: /* CIL Label */ 
  {
#line 765
  retval = (bool )-1;
#line 766
  printremark((char *)"Subsequent FCode Block detected.  Detokenizing.");
  }
#line 768
  goto switch_break;
  case_0: /* CIL Label */ 
#line 771
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 775
  sprintf((char */* __restrict  */)(temp_bufr), (char const   */* __restrict  */)"Unexpected token, 0x%02x, after end of FCode block.",
          (int )token);
#line 778
  printremark(temp_bufr);
  }
  switch_break: /* CIL Label */ ;
  }
#line 781
  return (retval);
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/decode.c"
void detokenize(void) 
{ 
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 795
  fclen = (int )stream_max;
#line 797
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(eof_exception));
  }
#line 797
  if (tmp___1 == 0) {
    {
#line 798
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 798
      tmp___0 = more_to_go();
      }
#line 798
      if (! tmp___0) {
#line 798
        goto while_break;
      }
#line 799
      if (ended_okay) {
        {
#line 800
        init_fcode_block();
        }
      }
      {
#line 802
      ended_okay = (bool )-1;
#line 804
      adjust_for_pci_header();
      }
      {
#line 810
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 811
        decode_fcode_block();
#line 810
        tmp = another_fcode_block();
        }
#line 810
        if (! tmp) {
#line 810
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 814
      adjust_for_pci_filler();
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 820
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
u8 *pci_image_end  =    (u8 *)((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
static int pci_image_len  =    0;
#line 139 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
static int is_pci_header(rom_header_t *pci_rom_hdr ) 
{ 
  u16 pci_header_signature ;
  int retval ;

  {
#line 141
  pci_header_signature = (u16 )21930;
#line 144
  retval = 0;
#line 146
  if ((int )((u16 )(((int )pci_rom_hdr->signature[0] << 8) | (int )pci_rom_hdr->signature[1])) == (int )pci_header_signature) {
#line 147
    retval = (int )((u16 )(((int )pci_rom_hdr->data_ptr[1] << 8) | (int )pci_rom_hdr->data_ptr[0]));
  }
#line 149
  return (retval);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
static int is_pci_data_struct(pci_data_t *pci_data_ptr ) 
{ 
  int retval ;

  {
#line 202
  retval = 0;
#line 204
  if ((u32 )(((((int )pci_data_ptr->signature[0] << 24) | ((int )pci_data_ptr->signature[1] << 16)) | ((int )pci_data_ptr->signature[2] << 8)) | (int )pci_data_ptr->signature[3]) == (u32 )((((80 << 24) | (67 << 16)) | (73 << 8)) | 82)) {
#line 205
    retval = (int )((u16 )(((int )pci_data_ptr->dlen[1] << 8) | (int )pci_data_ptr->dlen[0]));
  }
#line 207
  return (retval);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
static void announce_pci_hdr(rom_header_t *pci_rom_hdr ) 
{ 
  char temp_buf[80] ;
  u32 temp ;

  {
  {
#line 232
  printremark((char *)"PCI Header identified");
#line 233
  temp = (u32 )((u16 )(((int )pci_rom_hdr->data_ptr[1] << 8) | (int )pci_rom_hdr->data_ptr[0]));
#line 234
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Offset to Data Structure = 0x%04x (%d)\n",
          temp, temp);
#line 236
  printremark(temp_buf);
  }
#line 237
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
static void announce_pci_data_struct(pci_data_t *pci_data_ptr ) 
{ 
  char temp_buf[80] ;
  u32 temp ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 272
  printremark((char *)"PCI Data Structure identified");
#line 274
  temp = (u32 )((u16 )(((int )pci_data_ptr->dlen[1] << 8) | (int )pci_data_ptr->dlen[0]));
#line 275
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Data Structure Length = 0x%04x (%d)\n",
          temp, temp);
#line 276
  printremark(temp_buf);
#line 278
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Vendor ID: 0x%04x\n",
          (int )((u16 )(((int )pci_data_ptr->vendor[1] << 8) | (int )pci_data_ptr->vendor[0])));
#line 280
  printremark(temp_buf);
#line 282
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Device ID: 0x%04x\n",
          (int )((u16 )(((int )pci_data_ptr->device[1] << 8) | (int )pci_data_ptr->device[0])));
#line 284
  printremark(temp_buf);
#line 286
  temp = (u32 )((((int )pci_data_ptr->class_code[2] << 16) | ((int )pci_data_ptr->class_code[1] << 8)) | (int )pci_data_ptr->class_code[0]);
#line 287
  tmp = (char *)pci_device_class_name(temp);
#line 287
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Class Code: 0x%06x  (%s)",
          temp, tmp);
#line 289
  printremark(temp_buf);
#line 291
  temp = (u32 )((u16 )(((int )pci_data_ptr->vpd[1] << 8) | (int )pci_data_ptr->vpd[0]));
  }
#line 292
  if (temp != 0U) {
    {
#line 293
    sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Vital Prod Data: 0x%02x\n",
            temp);
#line 294
    printremark(temp_buf);
    }
  }
#line 297
  temp = (u32 )((u16 )(((int )pci_data_ptr->irevision[1] << 8) | (int )pci_data_ptr->irevision[0]));
#line 298
  if (temp != 0U) {
    {
#line 299
    sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Image Revision: 0x%02x\n",
            temp);
#line 300
    printremark(temp_buf);
    }
  }
  {
#line 303
  tmp___0 = (char *)pci_code_type_name(pci_data_ptr->code_type);
#line 303
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Code Type: 0x%02x (%s)\n",
          (int )pci_data_ptr->code_type, tmp___0);
#line 306
  printremark(temp_buf);
#line 308
  temp = (u32 )((u16 )(((int )pci_data_ptr->ilen[1] << 8) | (int )pci_data_ptr->ilen[0]));
#line 309
  pci_image_len = (int )(temp * 512U);
#line 310
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  Image Length: 0x%04x blocks (%d bytes)\n",
          temp, pci_image_len);
#line 312
  printremark(temp_buf);
  }
#line 314
  if (pci_data_ptr->last_image_flag) {
#line 314
    tmp___1 = "L";
  } else {
#line 314
    tmp___1 = "Not l";
  }
  {
#line 314
  sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"  %sast PCI Image.\n",
          tmp___1);
#line 316
  printremark(temp_buf);
  }
#line 318
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
int handle_pci_header(u8 *data_ptr ) 
{ 
  int hdrlen ;
  int data_struc_len ;

  {
  {
#line 375
  data_struc_len = 0;
#line 377
  hdrlen = is_pci_header((rom_header_t *)data_ptr);
  }
#line 379
  if (! (hdrlen < 0)) {
#line 385
    if (hdrlen > 0) {
      {
#line 386
      announce_pci_hdr((rom_header_t *)data_ptr);
#line 387
      data_struc_len = is_pci_data_struct((pci_data_t *)(data_ptr + hdrlen));
      }
#line 392
      if (! (data_struc_len <= 0)) {
        {
#line 398
        announce_pci_data_struct((pci_data_t *)(data_ptr + hdrlen));
#line 399
        pci_image_end = data_ptr + pci_image_len;
        }
      }
    }
  }
#line 404
  return (hdrlen + data_struc_len);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/pcihdr.c"
void handle_pci_filler(u8 *filler_ptr ) 
{ 
  u8 *scan_ptr ;
  int filler_len ;
  char temp_buf[80] ;
  bool all_zero ;
  u8 filler_byte ;

  {
#line 446
  all_zero = (bool )-1;
#line 447
  filler_byte = *filler_ptr;
#line 449
  filler_len = (int )(pci_image_end - filler_ptr);
#line 451
  scan_ptr = filler_ptr;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! ((unsigned long )scan_ptr < (unsigned long )pci_image_end)) {
#line 451
      goto while_break;
    }
#line 453
    if ((int )filler_byte != 0) {
#line 454
      all_zero = (bool )0;
#line 455
      goto while_break;
    }
#line 451
    scan_ptr ++;
#line 451
    filler_byte = *scan_ptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  if (all_zero) {
    {
#line 460
    sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"PCI Image padded with %d bytes of zero",
            filler_len);
    }
  } else {
    {
#line 462
    sprintf((char */* __restrict  */)(temp_buf), (char const   */* __restrict  */)"PCI Image padding-field of %d bytes had first non-zero byte at offset %ld",
            filler_len, scan_ptr - filler_ptr);
    }
  }
  {
#line 466
  printremark(temp_buf);
  }
#line 467
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/fcode-utils-1.0.2/detok/printformats.c"
void printremark(char *str ) 
{ 
  char *strtmp ;
  int substrlen ;
  char *substrend ;
  char *strend ;
  char *strbfr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 97
  tmp = strlen((char const   *)str);
#line 97
  tmp___0 = malloc(tmp + 1UL);
#line 97
  strbfr = (char *)tmp___0;
  }
#line 98
  if (! strbfr) {
    {
#line 99
    printf((char const   */* __restrict  */)"No memory.\n");
#line 100
    exit(-1);
    }
  }
  {
#line 104
  strtmp = str;
#line 105
  tmp___1 = strlen((char const   *)str);
#line 105
  strend = str + tmp___1;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )strtmp < (unsigned long )strend)) {
#line 117
      goto while_break;
    }
    {
#line 118
    substrend = strchr((char const   *)strtmp, '\n');
    }
#line 119
    if (substrend) {
#line 119
      substrlen = (int )(substrend - strtmp);
    } else {
      {
#line 119
      tmp___2 = strlen((char const   *)strtmp);
#line 119
      substrlen = (int )tmp___2;
      }
    }
    {
#line 121
    strncpy((char */* __restrict  */)strbfr, (char const   */* __restrict  */)strtmp,
            (size_t )substrlen);
#line 128
    *(strbfr + substrlen) = (char)0;
#line 130
    printf((char const   */* __restrict  */)"\\  %s\n", strbfr);
    }
#line 132
    if (substrend) {
#line 132
      tmp___3 = 1;
    } else {
#line 132
      tmp___3 = 0;
    }
#line 132
    strtmp += substrlen + tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  free((void *)strbfr);
  }
#line 137
  return;
}
}
