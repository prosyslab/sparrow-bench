/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 49 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
struct archived_file_header_tag {
   unsigned char method ;
   char name[13] ;
   unsigned long compressed_size ;
   unsigned int date ;
   unsigned int time ;
   unsigned int crc ;
   unsigned long orig_size ;
   int has_crc ;
};
#line 20 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
struct huff_node_tag {
   int kids[2] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 7 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.h"
void outputrle(int chr , void (*outputfunc)(int  ) ) ;
#line 8
unsigned char *convert_rle(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) ;
#line 18 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static unsigned char *data_in_point  ;
#line 18 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static unsigned char *data_in_max  ;
#line 19 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static unsigned char *data_out_point  ;
#line 19 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static unsigned char *data_out_max  ;
#line 22 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static void rawoutput(int byte ) 
{ 
  unsigned char *tmp ;

  {
#line 24
  if ((unsigned long )data_out_point < (unsigned long )data_out_max) {
#line 25
    tmp = data_out_point;
#line 25
    data_out_point ++;
#line 25
    *tmp = (unsigned char )byte;
  }
#line 26
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static int lastchr  =    0;
#line 32 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
static int repeating  =    0;
#line 30 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
void outputrle(int chr , void (*outputfunc)(int  ) ) 
{ 
  int f ;

  {
#line 35
  if (chr == -1) {
#line 37
    repeating = 0;
#line 37
    lastchr = repeating;
#line 38
    return;
  }
#line 41
  if (repeating) {
#line 43
    if (chr == 0) {
      {
#line 44
      (*outputfunc)(144);
      }
    } else {
#line 46
      f = 1;
      {
#line 46
      while (1) {
        while_continue: /* CIL Label */ ;
#line 46
        if (! (f < chr)) {
#line 46
          goto while_break;
        }
        {
#line 47
        (*outputfunc)(lastchr);
#line 46
        f ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 48
    repeating = 0;
  } else
#line 52
  if (chr == 144) {
#line 53
    repeating = 1;
  } else {
    {
#line 56
    (*outputfunc)(chr);
#line 57
    lastchr = chr;
    }
  }
#line 60
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/nomarch-1.4/readrle.c"
unsigned char *convert_rle(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) 
{ 
  unsigned char *data_out ;
  void *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 69
  tmp = malloc(orig_len);
#line 69
  data_out = (unsigned char *)tmp;
  }
#line 69
  if ((unsigned long )data_out == (unsigned long )((void *)0)) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 70
    exit(1);
    }
  }
  {
#line 72
  data_in_point = data_in;
#line 72
  data_in_max = data_in + in_len;
#line 73
  data_out_point = data_out;
#line 73
  data_out_max = data_out + orig_len;
#line 74
  outputrle(-1, (void (*)(int  ))((void *)0));
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )data_in_point < (unsigned long )data_in_max)) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = data_in_point;
#line 77
    data_in_point ++;
#line 77
    outputrle((int )*tmp___0, & rawoutput);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (data_out);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 7 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.h"
unsigned char *convert_huff(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) ;
#line 7 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.h"
unsigned char *convert_lzw_dynamic(unsigned char *data_in , int max_bits , int use_rle ,
                                   unsigned long in_len , unsigned long orig_len ) ;
#line 39 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
char *archive_filename  =    (char *)((void *)0);
#line 40 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
char **archive_matchstrs  =    (char **)((void *)0);
#line 41 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int num_matchstrs  =    0;
#line 43 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int opt_list  =    0;
#line 43 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int opt_print  =    0;
#line 43 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int opt_test  =    0;
#line 43 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int opt_verbose  =    0;
#line 44 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int opt_preservecase  =    0;
#line 46 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int quiet  =    0;
#line 61 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int maybe_downcase(int c ) 
{ 
  int tmp ;

  {
#line 63
  if (opt_preservecase) {
#line 64
    return (c);
  }
  {
#line 66
  tmp = tolower(c);
  }
#line 66
  return (tmp);
}
}
#line 75 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int read_file_header(FILE *in , struct archived_file_header_tag *hdrp ) 
{ 
  unsigned char buf___1[14] ;
  int bufsiz ;
  int method_high ;
  int c ;
  int f ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 78
  bufsiz = (int )sizeof(buf___1);
#line 82
  hdrp->method = (unsigned char)255;
#line 83
  tmp = fgetc(in);
  }
#line 83
  if (tmp != 26) {
#line 84
    return (0);
  }
  {
#line 86
  c = fgetc(in);
  }
#line 86
  if (c == -1) {
#line 87
    return (0);
  }
#line 90
  method_high = c >> 7;
#line 91
  hdrp->method = (unsigned char )(c & 127);
#line 94
  if ((int )hdrp->method == 0) {
#line 95
    return (1);
  }
#line 98
  if ((int )hdrp->method == 1) {
#line 99
    bufsiz -= 4;
  }
  {
#line 101
  tmp___0 = fread((void */* __restrict  */)(hdrp->name), (size_t )1, sizeof(hdrp->name),
                  (FILE */* __restrict  */)in);
  }
#line 101
  if (tmp___0 != sizeof(hdrp->name)) {
#line 103
    return (0);
  } else {
    {
#line 101
    tmp___1 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )bufsiz,
                    (FILE */* __restrict  */)in);
    }
#line 101
    if (tmp___1 != (size_t )bufsiz) {
#line 103
      return (0);
    }
  }
#line 106
  hdrp->compressed_size = (unsigned long )((((int )buf___1[0] | ((int )buf___1[1] << 8)) | ((int )buf___1[2] << 16)) | ((int )buf___1[3] << 24));
#line 107
  hdrp->date = (unsigned int )((int )buf___1[4] | ((int )buf___1[5] << 8));
#line 108
  hdrp->time = (unsigned int )((int )buf___1[6] | ((int )buf___1[7] << 8));
#line 109
  hdrp->crc = (unsigned int )((int )buf___1[8] | ((int )buf___1[9] << 8));
#line 110
  hdrp->has_crc = 1;
#line 111
  if ((int )hdrp->method == 1) {
#line 112
    hdrp->orig_size = hdrp->compressed_size;
  } else {
#line 114
    hdrp->orig_size = (unsigned long )((((int )buf___1[10] | ((int )buf___1[11] << 8)) | ((int )buf___1[12] << 16)) | ((int )buf___1[13] << 24));
  }
#line 117
  hdrp->name[12] = (char)0;
#line 120
  f = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    tmp___3 = strlen((char const   *)(hdrp->name));
    }
#line 120
    if (! ((size_t )f < tmp___3)) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp___2 = maybe_downcase((int )hdrp->name[f] & 127);
#line 121
    hdrp->name[f] = (char )tmp___2;
#line 120
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  if (method_high) {
    {
#line 126
    tmp___4 = fread((void */* __restrict  */)(buf___1), (size_t )1, (size_t )12, (FILE */* __restrict  */)in);
    }
#line 126
    if (tmp___4 != 12UL) {
#line 127
      return (0);
    }
#line 134
    if ((int )hdrp->method == 2) {
#line 134
      if ((int )buf___1[3] == 255) {
#line 134
        if ((int )buf___1[2] == 253) {
#line 134
          if ((int )buf___1[1] == 220) {
#line 135
            hdrp->has_crc = 0;
          }
        }
      }
    }
  }
#line 138
  return (1);
}
}
#line 158 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int skip_sfx_header(FILE *in ) 
{ 
  int c ;
  int f ;
  int got ;

  {
#line 160
  got = 0;
#line 162
  f = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (f < 4)) {
#line 162
      goto while_break;
    }
    {
#line 164
    c = fgetc(in);
    }
#line 164
    if (c == -1) {
#line 165
      return (0);
    }
#line 166
    if (c == 26) {
      {
#line 168
      got = 1;
#line 169
      ungetc(c, in);
      }
#line 170
      goto while_break;
    }
#line 162
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (got);
}
}
#line 183 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
unsigned char *read_file_data(FILE *in , struct archived_file_header_tag *hdrp ) 
{ 
  unsigned char *data ;
  int siz ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 186
  siz = (int )hdrp->compressed_size;
#line 188
  tmp = malloc((size_t )siz);
#line 188
  data = (unsigned char *)tmp;
  }
#line 188
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 189
    exit(1);
    }
  }
  {
#line 191
  tmp___0 = fread((void */* __restrict  */)data, (size_t )1, (size_t )siz, (FILE */* __restrict  */)in);
  }
#line 191
  if (tmp___0 != (size_t )siz) {
    {
#line 193
    free((void *)data);
#line 194
    data = (unsigned char *)((void *)0);
    }
  }
#line 197
  return (data);
}
}
#line 202 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int skip_file_data(FILE *in , struct archived_file_header_tag *hdrp ) 
{ 
  int siz ;
  int f ;
  int tmp ;

  {
#line 204
  siz = (int )hdrp->compressed_size;
#line 207
  f = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (f < siz)) {
#line 207
      goto while_break;
    }
    {
#line 208
    tmp = fgetc(in);
    }
#line 208
    if (tmp == -1) {
#line 208
      return (0);
    }
#line 207
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (1);
}
}
#line 217 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
unsigned int calc_crc(unsigned char *data , unsigned long len ) 
{ 
  unsigned long f ;
  unsigned char *ptr ;
  unsigned long crc ;
  int i ;
  unsigned char *tmp ;

  {
#line 220
  ptr = data;
#line 221
  crc = 0UL;
#line 224
  f = 0UL;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (f < len)) {
#line 224
      goto while_break;
    }
#line 226
    tmp = ptr;
#line 226
    ptr ++;
#line 226
    crc ^= (unsigned long )*tmp;
#line 227
    i = 0;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (i < 8)) {
#line 227
        goto while_break___0;
      }
#line 229
      if (crc & 1UL) {
#line 230
        crc = (crc >> 1) ^ 40961UL;
      } else {
#line 232
        crc >>= 1;
      }
#line 227
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  crc &= 65535UL;
#line 238
  return ((unsigned int )crc);
}
}
#line 245 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
static char buf[128]  ;
#line 243 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
char *mkdatetimestr(unsigned int hdate , unsigned int htime ) 
{ 
  int day ;
  int month ;
  int year ;
  int hour ;
  int min ;

  {
  {
#line 248
  year = (int )(1980U + (hdate >> 9));
#line 249
  month = (int )((hdate >> 5) & 15U);
#line 250
  day = (int )(hdate & 31U);
#line 251
  hour = (int )(htime >> 11);
#line 252
  min = (int )((htime >> 5) & 63U);
#line 255
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%4d-%02d-%02d %02d:%02d",
          year, month, day, hour, min);
  }
#line 256
  return (buf);
}
}
#line 261 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
time_t mkdatetimet(unsigned int hdate , unsigned int htime ) 
{ 
  struct tm tms ;
  time_t tmp ;

  {
  {
#line 265
  tms.tm_year = (int )(80U + (hdate >> 9));
#line 266
  tms.tm_mon = (int )(((hdate >> 5) & 15U) - 1U);
#line 267
  tms.tm_mday = (int )(hdate & 31U);
#line 268
  tms.tm_hour = (int )(htime >> 11);
#line 269
  tms.tm_min = (int )((htime >> 5) & 63U);
#line 270
  tms.tm_sec = (int )((htime & 31U) * 2U);
#line 271
  tms.tm_isdst = -1;
#line 273
  tmp = mktime(& tms);
  }
#line 273
  return (tmp);
}
}
#line 281 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int is_match(char *filename , char *wildcard ) 
{ 
  char *ptr ;
  char *match ;
  char *tmp ;
  char *tmp2 ;
  int old ;
  int ok ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 283
  ptr = filename;
#line 283
  match = wildcard;
#line 286
  ok = 1;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (*ptr) {
#line 288
      if (*match) {
#line 288
        if (! ok) {
#line 288
          goto while_break;
        }
      } else {
#line 288
        goto while_break;
      }
    } else {
#line 288
      goto while_break;
    }
    {
#line 292
    if ((int )*match == 42) {
#line 292
      goto case_42;
    }
#line 331
    if ((int )*match == 63) {
#line 331
      goto case_63;
    }
#line 335
    goto switch_default;
    case_42: /* CIL Label */ 
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      if (! ((int )*match == 42)) {
#line 297
        if (! ((int )*match == 63)) {
#line 297
          goto while_break___0;
        }
      }
#line 298
      match ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 301
    tmp = strchr((char const   *)match, '*');
    }
#line 302
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 302
      tmp = strchr((char const   *)match, '?');
      }
    }
#line 303
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 303
      tmp___0 = strlen((char const   *)match);
#line 303
      tmp = match + tmp___0;
      }
    }
#line 304
    tmp --;
#line 309
    if ((int )*match == 0) {
      {
#line 310
      tmp___1 = strlen((char const   *)ptr);
#line 310
      ptr += tmp___1;
      }
    } else {
      {
#line 313
      tmp___2 = strlen((char const   *)ptr);
      }
#line 313
      if ((size_t )((tmp + 1) - match) > tmp___2) {
#line 314
        ok = 0;
      } else {
        {
#line 320
        old = (int )*(tmp + 1);
#line 320
        *(tmp + 1) = (char)0;
#line 321
        tmp2 = strstr((char const   *)ptr, (char const   *)match);
        }
#line 321
        if ((unsigned long )tmp2 == (unsigned long )((void *)0)) {
#line 322
          ok = 0;
        } else {
#line 324
          ptr = tmp2;
        }
#line 326
        *(tmp + 1) = (char )old;
      }
    }
#line 329
    goto switch_break;
    case_63: /* CIL Label */ 
#line 332
    match ++;
#line 332
    ptr ++;
#line 333
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 336
    if ((int )*match != (int )*ptr) {
#line 337
      ok = 0;
    } else {
#line 340
      match ++;
#line 341
      ptr ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  if (*ptr) {
#line 346
    ok = 0;
  } else
#line 346
  if (*match) {
#line 346
    ok = 0;
  }
#line 348
  return (ok);
}
}
#line 355 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int file_matches(char *filename ) 
{ 
  int f ;
  int tmp ;

  {
#line 359
  if (! num_matchstrs) {
#line 359
    return (1);
  }
#line 361
  f = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (f < num_matchstrs)) {
#line 361
      goto while_break;
    }
    {
#line 362
    tmp = is_match(filename, *(archive_matchstrs + f));
    }
#line 362
    if (tmp) {
#line 363
      return (1);
    }
#line 361
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (0);
}
}
#line 370 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int arc_list(int verbose ) 
{ 
  char *methodstr[10] ;
  FILE *in ;
  struct archived_file_header_tag hdr ;
  int done ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 373
  methodstr[0] = (char *)"EOF";
#line 373
  methodstr[1] = (char *)"Stored";
#line 373
  methodstr[2] = (char *)"Stored";
#line 373
  methodstr[3] = (char *)"Packed";
#line 373
  methodstr[4] = (char *)"Squeezed";
#line 373
  methodstr[5] = (char *)"crunched";
#line 373
  methodstr[6] = (char *)"crunched";
#line 373
  methodstr[7] = (char *)"crunched";
#line 373
  methodstr[8] = (char *)"Crunched";
#line 373
  methodstr[9] = (char *)"Squashed";
#line 388
  done = 0;
#line 390
  in = fopen((char const   */* __restrict  */)archive_filename, (char const   */* __restrict  */)"rb");
  }
#line 390
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 391
    tmp = __errno_location();
#line 391
    tmp___0 = strerror(*tmp);
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: %s\n",
            tmp___0);
#line 391
    exit(1);
    }
  }
  {
#line 393
  tmp___1 = skip_sfx_header(in);
  }
#line 393
  if (tmp___1) {
    {
#line 393
    tmp___2 = read_file_header(in, & hdr);
    }
#line 393
    if (! tmp___2) {
      {
#line 394
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: bad first header - not a .arc file?\n");
#line 394
      exit(1);
      }
    }
  } else {
    {
#line 394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: bad first header - not a .arc file?\n");
#line 394
    exit(1);
    }
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if ((int )hdr.method == 0) {
#line 400
      done = 1;
#line 401
      goto __Cont;
    }
    {
#line 404
    tmp___3 = skip_file_data(in, & hdr);
    }
#line 404
    if (! tmp___3) {
      {
#line 405
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading data (hit EOF)\n");
#line 405
      exit(1);
      }
    }
    {
#line 407
    tmp___8 = file_matches(hdr.name);
    }
#line 407
    if (tmp___8) {
#line 409
      if (verbose) {
        {
#line 411
        tmp___4 = mkdatetimestr(hdr.date, hdr.time);
        }
#line 411
        if ((int )hdr.method < 10) {
#line 411
          tmp___6 = (char const   *)methodstr[hdr.method];
        } else {
#line 411
          if ((int )hdr.method == 127) {
#line 411
            tmp___5 = "Compress";
          } else {
#line 411
            tmp___5 = "unknown";
          }
#line 411
          tmp___6 = tmp___5;
        }
        {
#line 411
        printf((char const   */* __restrict  */)"%-13s\t%d (%s)\t%9ld %9ld  %s  ",
               hdr.name, (int )hdr.method, tmp___6, hdr.compressed_size, hdr.orig_size,
               tmp___4);
        }
#line 418
        if (hdr.has_crc) {
          {
#line 419
          printf((char const   */* __restrict  */)"%04X", hdr.crc);
          }
        }
        {
#line 420
        putchar('\n');
        }
      } else {
        {
#line 423
        tmp___7 = mkdatetimestr(hdr.date, hdr.time);
#line 423
        printf((char const   */* __restrict  */)"%-13s\t%9ld   %s\n", hdr.name, hdr.orig_size,
               tmp___7);
        }
      }
    }
    {
#line 428
    tmp___9 = read_file_header(in, & hdr);
    }
#line 428
    if (! tmp___9) {
      {
#line 429
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading record header\n");
#line 429
      exit(1);
      }
    }
    __Cont: /* CIL Label */ 
#line 396
    if (! (! done)) {
#line 396
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  fclose(in);
  }
#line 435
  return (0);
}
}
#line 439 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int arc_extract_or_test(int test_only ) 
{ 
  FILE *in ;
  struct archived_file_header_tag hdr ;
  int done ;
  unsigned char *data ;
  unsigned char *orig_data ;
  int supported ;
  int exitval ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  struct _IO_FILE *tmp___5 ;
  struct _IO_FILE *tmp___6 ;
  FILE *out ;
  char *ptr ;
  int *tmp___7 ;
  char *tmp___8 ;
  struct _IO_FILE *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  struct _IO_FILE *tmp___12 ;
  char const   *tmp___13 ;
  struct _IO_FILE *tmp___14 ;
  unsigned int tmp___15 ;
  size_t tmp___16 ;
  struct utimbuf ubuf ;
  time_t t ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 443
  done = 0;
#line 446
  exitval = 0;
#line 448
  in = fopen((char const   */* __restrict  */)archive_filename, (char const   */* __restrict  */)"rb");
  }
#line 448
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 449
    tmp = __errno_location();
#line 449
    tmp___0 = strerror(*tmp);
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: %s\n",
            tmp___0);
#line 449
    exit(1);
    }
  }
  {
#line 451
  tmp___1 = skip_sfx_header(in);
  }
#line 451
  if (tmp___1) {
    {
#line 451
    tmp___2 = read_file_header(in, & hdr);
    }
#line 451
    if (! tmp___2) {
      {
#line 452
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: bad first header - not a .arc file?\n");
#line 452
      exit(1);
      }
    }
  } else {
    {
#line 452
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: bad first header - not a .arc file?\n");
#line 452
    exit(1);
    }
  }
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if ((int )hdr.method == 0) {
#line 458
      done = 1;
#line 459
      goto __Cont;
    }
    {
#line 462
    tmp___17 = file_matches(hdr.name);
    }
#line 462
    if (tmp___17) {
      {
#line 469
      data = read_file_data(in, & hdr);
      }
#line 469
      if ((unsigned long )data == (unsigned long )((void *)0)) {
        {
#line 470
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading data (hit EOF)\n");
#line 470
        exit(1);
        }
      }
#line 473
      if (! quiet) {
        {
#line 475
        printf((char const   */* __restrict  */)"%-12s\t", hdr.name);
#line 476
        fflush(stdout);
        }
      }
#line 479
      orig_data = (unsigned char *)((void *)0);
#line 480
      supported = 0;
      {
#line 489
      if ((int )hdr.method == 2) {
#line 489
        goto case_2;
      }
#line 489
      if ((int )hdr.method == 1) {
#line 489
        goto case_2;
      }
#line 494
      if ((int )hdr.method == 3) {
#line 494
        goto case_3;
      }
#line 499
      if ((int )hdr.method == 4) {
#line 499
        goto case_4;
      }
#line 504
      if ((int )hdr.method == 5) {
#line 504
        goto case_5;
      }
#line 510
      if ((int )hdr.method == 6) {
#line 510
        goto case_6;
      }
#line 516
      if ((int )hdr.method == 7) {
#line 516
        goto case_7;
      }
#line 524
      if ((int )hdr.method == 8) {
#line 524
        goto case_8;
      }
#line 531
      if ((int )hdr.method == 9) {
#line 531
        goto case_9;
      }
#line 537
      if ((int )hdr.method == 127) {
#line 537
        goto case_127;
      }
#line 487
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 490
      supported = 1;
#line 491
      orig_data = data;
#line 492
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 495
      supported = 1;
#line 496
      orig_data = convert_rle(data, hdr.compressed_size, hdr.orig_size);
      }
#line 497
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 500
      supported = 1;
#line 501
      orig_data = convert_huff(data, hdr.compressed_size, hdr.orig_size);
      }
#line 502
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 505
      supported = 1;
#line 506
      orig_data = convert_lzw_dynamic(data, 0, 0, hdr.compressed_size, hdr.orig_size);
      }
#line 508
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 511
      supported = 1;
#line 512
      orig_data = convert_lzw_dynamic(data, 0, 1, hdr.compressed_size, hdr.orig_size);
      }
#line 514
      goto switch_break;
      case_7: /* CIL Label */ 
#line 522
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 526
      supported = 1;
#line 527
      orig_data = convert_lzw_dynamic(data, 12, 1, hdr.compressed_size, hdr.orig_size);
      }
#line 529
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 532
      supported = 1;
#line 533
      orig_data = convert_lzw_dynamic(data, 13, 0, hdr.compressed_size, hdr.orig_size);
      }
#line 535
      goto switch_break;
      case_127: /* CIL Label */ 
      {
#line 538
      supported = 1;
#line 539
      orig_data = convert_lzw_dynamic(data, 16, 0, hdr.compressed_size, hdr.orig_size);
      }
#line 541
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 548
      if ((unsigned long )orig_data == (unsigned long )((void *)0)) {
#line 550
        if (supported) {
#line 551
          if (test_only) {
#line 551
            tmp___4 = "";
          } else {
#line 551
            tmp___4 = " extracting file";
          }
#line 551
          if (quiet) {
#line 551
            tmp___5 = stderr;
          } else {
#line 551
            tmp___5 = stdout;
          }
          {
#line 551
          fprintf((FILE */* __restrict  */)tmp___5, (char const   */* __restrict  */)"error%s\n",
                  tmp___4);
          }
        } else {
#line 554
          if (quiet) {
#line 554
            tmp___6 = stderr;
          } else {
#line 554
            tmp___6 = stdout;
          }
          {
#line 554
          fprintf((FILE */* __restrict  */)tmp___6, (char const   */* __restrict  */)"unsupported compression method %d\n",
                  (int )hdr.method);
          }
        }
#line 556
        exitval = 1;
      } else {
#line 560
        out = (FILE *)((void *)0);
        {
#line 564
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 564
          ptr = strchr((char const   *)(hdr.name), '/');
          }
#line 564
          if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 564
            goto while_break___0;
          }
#line 565
          *ptr = (char )'_';
        }
        while_break___0: /* CIL Label */ ;
        }
#line 567
        if (opt_print) {
#line 568
          out = stdout;
        }
#line 571
        if (! opt_print) {
#line 571
          if (! test_only) {
            {
#line 571
            out = fopen((char const   */* __restrict  */)(hdr.name), (char const   */* __restrict  */)"wb");
            }
#line 571
            if ((unsigned long )out == (unsigned long )((void *)0)) {
              {
#line 573
              tmp___7 = __errno_location();
#line 573
              tmp___8 = strerror(*tmp___7);
              }
#line 573
              if (quiet) {
#line 573
                tmp___9 = stderr;
              } else {
#line 573
                tmp___9 = stdout;
              }
              {
#line 573
              fprintf((FILE */* __restrict  */)tmp___9, (char const   */* __restrict  */)"error, %s\n",
                      tmp___8);
#line 574
              exitval = 1;
              }
            } else {
#line 571
              goto _L___2;
            }
          } else {
#line 571
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 578
          if (! test_only) {
            {
#line 578
            tmp___16 = fwrite((void const   */* __restrict  */)orig_data, (size_t )1,
                              hdr.orig_size, (FILE */* __restrict  */)out);
            }
#line 578
            if (tmp___16 != hdr.orig_size) {
              {
#line 580
              tmp___10 = __errno_location();
#line 580
              tmp___11 = strerror(*tmp___10);
              }
#line 580
              if (quiet) {
#line 580
                tmp___12 = stderr;
              } else {
#line 580
                tmp___12 = stdout;
              }
              {
#line 580
              fprintf((FILE */* __restrict  */)tmp___12, (char const   */* __restrict  */)"error, %s\n",
                      tmp___11);
#line 581
              exitval = 1;
              }
            } else {
#line 578
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 585
          if (hdr.has_crc) {
            {
#line 585
            tmp___15 = calc_crc(orig_data, hdr.orig_size);
            }
#line 585
            if (tmp___15 != hdr.crc) {
#line 587
              if (test_only) {
#line 587
                tmp___13 = "test failed";
              } else {
#line 587
                tmp___13 = "warning";
              }
#line 587
              if (quiet) {
#line 587
                tmp___14 = stderr;
              } else {
#line 587
                tmp___14 = stdout;
              }
              {
#line 587
              fprintf((FILE */* __restrict  */)tmp___14, (char const   */* __restrict  */)"%s, bad CRC\n",
                      tmp___13);
#line 589
              exitval = 1;
              }
            } else {
#line 585
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 593
          if (! quiet) {
            {
#line 594
            printf((char const   */* __restrict  */)"ok\n");
            }
          }
#line 598
          if (! test_only) {
#line 598
            if ((unsigned long )out != (unsigned long )stdout) {
              {
#line 603
              fclose(out);
#line 606
              t = mkdatetimet(hdr.date, hdr.time);
#line 607
              ubuf.modtime = t;
#line 607
              ubuf.actime = ubuf.modtime;
#line 608
              utime((char const   *)(hdr.name), (struct utimbuf  const  *)(& ubuf));
              }
            }
          }
        }
#line 612
        if ((unsigned long )orig_data != (unsigned long )data) {
          {
#line 613
          free((void *)orig_data);
          }
        }
      }
      {
#line 616
      free((void *)data);
      }
    } else {
      {
#line 464
      tmp___3 = skip_file_data(in, & hdr);
      }
#line 464
      if (! tmp___3) {
        {
#line 465
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading data (hit EOF)\n");
#line 465
        exit(1);
        }
      }
    }
    {
#line 620
    tmp___18 = read_file_header(in, & hdr);
    }
#line 620
    if (! tmp___18) {
      {
#line 621
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: error reading record header\n");
#line 621
      exit(1);
      }
    }
    __Cont: /* CIL Label */ 
#line 454
    if (! (! done)) {
#line 454
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 625
  fclose(in);
  }
#line 627
  return (exitval);
}
}
#line 631 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
void usage_help(void) 
{ 


  {
  {
#line 633
  printf((char const   */* __restrict  */)"nomarch %s - copyright (c) 2001-2006 Russell Marks.\n",
         "1.4");
#line 634
  printf((char const   */* __restrict  */)"\nusage: nomarch [-hlptUv] [archive.arc] [match1 [match2 ...]]\n\n\t-h\tthis usage help.\n\t-l\tlist contents of archive.\n\t-p\textract to standard output, rather than to separate files.\n\t-t\ttest archive (i.e. check file CRCs).\n\t-U\tuse uppercase filenames (preserve case).\n\t-v\tgive verbose listing (when used with `-l\').\n\n  archive.arc\tthe .arc or .ark file to list/extract/test.\n\t\t(The default action is to extract the files.)\n\n  match1 etc.\tzero or more wildcards, for files to list/extract/test;\n\t\tthe file is processed if it matches any one of these.\n\t\t(If *no* wildcards are specified, all files match.)\n\t\tWildcard operators supported are shell-like `*\' and `?\'.\n");
  }
#line 651
  return;
}
}
#line 654 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
void parse_options(int argc , char **argv ) 
{ 
  int done ;
  int tmp ;

  {
#line 656
  done = 0;
#line 658
  archive_filename = (char *)((void *)0);
#line 660
  opterr = 0;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 663
    tmp = getopt(argc, (char * const  *)argv, "hlptUv");
    }
    {
#line 665
    if (tmp == 108) {
#line 665
      goto case_108;
    }
#line 668
    if (tmp == 104) {
#line 668
      goto case_104;
    }
#line 671
    if (tmp == 112) {
#line 671
      goto case_112;
    }
#line 674
    if (tmp == 116) {
#line 674
      goto case_116;
    }
#line 677
    if (tmp == 85) {
#line 677
      goto case_85;
    }
#line 680
    if (tmp == 118) {
#line 680
      goto case_118;
    }
#line 683
    if (tmp == 63) {
#line 683
      goto case_63;
    }
#line 686
    if (tmp == -1) {
#line 686
      goto case_neg_1;
    }
#line 663
    goto switch_break;
    case_108: /* CIL Label */ 
#line 666
    opt_list = 1;
#line 667
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 669
    usage_help();
#line 670
    exit(0);
    }
    case_112: /* CIL Label */ 
#line 672
    opt_print = 1;
#line 673
    goto switch_break;
    case_116: /* CIL Label */ 
#line 675
    opt_test = 1;
#line 676
    goto switch_break;
    case_85: /* CIL Label */ 
#line 678
    opt_preservecase = 1;
#line 679
    goto switch_break;
    case_118: /* CIL Label */ 
#line 681
    opt_verbose = 1;
#line 682
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 684
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: option `%c\' not recognised.\n",
            optopt);
#line 685
    exit(1);
    }
    case_neg_1: /* CIL Label */ 
#line 687
    done = 1;
    switch_break: /* CIL Label */ ;
    }
#line 662
    if (! (! done)) {
#line 662
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  if (argc - optind > 1) {
#line 694
    archive_matchstrs = (argv + optind) + 1;
#line 695
    num_matchstrs = (argc - optind) - 1;
  }
#line 698
  if (argc == optind) {
    {
#line 699
    usage_help();
#line 699
    exit(1);
    }
  }
#line 701
  archive_filename = *(argv + optind);
#line 703
  if (opt_print) {
#line 704
    quiet = 1;
  }
#line 705
  return;
}
}
#line 708 "/home/wheatley/newnew/temp/nomarch-1.4/main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 710
  parse_options(argc, argv);
  }
#line 712
  if (opt_list) {
#line 712
    if (opt_test) {
#line 713
      opt_list = 0;
    }
  }
#line 715
  if (opt_list) {
    {
#line 716
    tmp = arc_list(opt_verbose);
#line 716
    exit(tmp);
    }
  }
  {
#line 718
  tmp___0 = arc_extract_or_test(opt_test);
#line 718
  exit(tmp___0);
  }
}
}
#line 32 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static int bitbox  ;
#line 32 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static int bitsleft  ;
#line 34 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static unsigned char *data_in_point___0  ;
#line 34 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static unsigned char *data_in_max___0  ;
#line 35 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static unsigned char *data_out_point___0  ;
#line 35 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static unsigned char *data_out_max___0  ;
#line 38 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static int rawinput(void) 
{ 
  unsigned char *tmp ;

  {
#line 40
  if ((unsigned long )data_in_point___0 < (unsigned long )data_in_max___0) {
#line 41
    tmp = data_in_point___0;
#line 41
    data_in_point___0 ++;
#line 41
    return ((int )*tmp);
  }
#line 42
  return (-1);
}
}
#line 45 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static void rawoutput___0(int byte ) 
{ 
  unsigned char *tmp ;

  {
#line 47
  if ((unsigned long )data_out_point___0 < (unsigned long )data_out_max___0) {
#line 48
    tmp = data_out_point___0;
#line 48
    data_out_point___0 ++;
#line 48
    *tmp = (unsigned char )byte;
  }
#line 49
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static void bit_init(void) 
{ 


  {
#line 54
  bitbox = 0;
#line 54
  bitsleft = 0;
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
static int bit_input(void) 
{ 
  int tmp ;

  {
#line 59
  if (bitsleft == 0) {
    {
#line 61
    bitbox = rawinput();
    }
#line 62
    if (bitbox == -1) {
#line 62
      return (-1);
    }
#line 63
    bitsleft = 8;
  }
#line 66
  bitsleft --;
#line 67
  if (bitbox & (1 << (7 - bitsleft))) {
#line 67
    tmp = 1;
  } else {
#line 67
    tmp = 0;
  }
#line 67
  return (tmp);
}
}
#line 71 "/home/wheatley/newnew/temp/nomarch-1.4/readhuff.c"
unsigned char *convert_huff(unsigned char *data_in , unsigned long in_len , unsigned long orig_len ) 
{ 
  unsigned char *data_out ;
  struct huff_node_tag *nodearr ;
  int nodes ;
  int f ;
  int b ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 79
  tmp = malloc(orig_len);
#line 79
  data_out = (unsigned char *)tmp;
  }
#line 79
  if ((unsigned long )data_out == (unsigned long )((void *)0)) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 80
    exit(1);
    }
  }
  {
#line 82
  data_in_point___0 = data_in;
#line 82
  data_in_max___0 = data_in + in_len;
#line 83
  data_out_point___0 = data_out;
#line 83
  data_out_max___0 = data_out + orig_len;
#line 85
  nodes = rawinput();
#line 85
  tmp___0 = rawinput();
#line 85
  nodes |= tmp___0 << 8;
  }
#line 87
  if (! nodes) {
    {
#line 89
    free((void *)data_out);
    }
#line 90
    return ((unsigned char *)((void *)0));
  }
  {
#line 93
  tmp___1 = malloc(sizeof(struct huff_node_tag ) * (unsigned long )nodes);
#line 93
  nodearr = (struct huff_node_tag *)tmp___1;
  }
#line 93
  if ((unsigned long )nodearr == (unsigned long )((void *)0)) {
    {
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 94
    exit(1);
    }
  }
#line 101
  tmp___2 = 65279;
#line 101
  (nodearr + 0)->kids[1] = tmp___2;
#line 101
  (nodearr + 0)->kids[0] = tmp___2;
#line 103
  f = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (f < nodes)) {
#line 103
      goto while_break;
    }
    {
#line 105
    (nodearr + f)->kids[0] = rawinput();
#line 105
    tmp___3 = rawinput();
#line 105
    (nodearr + f)->kids[0] |= tmp___3 << 8;
#line 106
    (nodearr + f)->kids[1] = rawinput();
#line 106
    tmp___4 = rawinput();
#line 106
    (nodearr + f)->kids[1] |= tmp___4 << 8;
#line 103
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  bit_init();
#line 113
  outputrle(-1, (void (*)(int  ))((void *)0));
  }
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    f = 0;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! ((f & 32768) == 0)) {
#line 118
        goto while_break___1;
      }
#line 120
      if (f >= nodes) {
        {
#line 123
        free((void *)nodearr);
#line 124
        free((void *)data_out);
        }
#line 125
        return ((unsigned char *)((void *)0));
      }
      {
#line 132
      b = bit_input();
      }
#line 132
      if (b == -1) {
#line 134
        f = 65279;
#line 135
        goto while_break___1;
      }
#line 138
      f = (nodearr + f)->kids[b];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    f ^= 65535;
#line 142
    if (f != 256) {
      {
#line 143
      outputrle(f, & rawoutput___0);
      }
    }
#line 115
    if (! (f != 256)) {
#line 115
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 147
  free((void *)nodearr);
  }
#line 149
  return (data_out);
}
}
#line 30 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int st_ptr[65536]  ;
#line 30 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int st_chr[65536]  ;
#line 30 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int st_last  ;
#line 31 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int st_ptr1st[65536]  ;
#line 36 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int dc_bitbox  ;
#line 36 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int dc_bitsleft  ;
#line 38 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static unsigned char *data_in_point___1  ;
#line 38 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static unsigned char *data_in_max___1  ;
#line 39 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static unsigned char *data_out_point___1  ;
#line 39 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static unsigned char *data_out_max___1  ;
#line 41 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int codeofs  ;
#line 42 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int global_use_rle  ;
#line 42 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int oldver  ;
#line 44 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int maxstr  ;
#line 46 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int st_oldverhashlinks[4096]  ;
#line 50
void code_resync(int old ) ;
#line 51
void inittable(int orgcsize ) ;
#line 52
int addstring(int oldcode , int chr ) ;
#line 53
int readcode(int *newcode , int numbits ) ;
#line 54
void outputstring(int code ) ;
#line 55
void outputchr(int chr ) ;
#line 56
int findfirstchr(int code ) ;
#line 59 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
unsigned char *convert_lzw_dynamic(unsigned char *data_in , int max_bits , int use_rle ,
                                   unsigned long in_len , unsigned long orig_len ) 
{ 
  unsigned char *data_out ;
  int csize ;
  int orgcsize ;
  int newcode ;
  int oldcode ;
  int k ;
  int first ;
  int noadd ;
  void *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 66
  k = 0;
#line 67
  first = 1;
#line 69
  global_use_rle = use_rle;
#line 70
  maxstr = 1 << max_bits;
#line 72
  tmp = malloc(orig_len);
#line 72
  data_out = (unsigned char *)tmp;
  }
#line 72
  if ((unsigned long )data_out == (unsigned long )((void *)0)) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nomarch: out of memory!\n");
#line 73
    exit(1);
    }
  }
  {
#line 75
  data_in_point___1 = data_in;
#line 75
  data_in_max___1 = data_in + in_len;
#line 76
  data_out_point___1 = data_out;
#line 76
  data_out_max___1 = data_out + orig_len;
#line 77
  dc_bitsleft = 0;
#line 77
  dc_bitbox = dc_bitsleft;
#line 78
  codeofs = 0;
#line 79
  outputrle(-1, (void (*)(int  ))((void *)0));
#line 81
  oldver = 0;
#line 82
  csize = 9;
  }
#line 83
  if (max_bits == 0) {
#line 84
    oldver = 1;
#line 84
    csize = 12;
#line 84
    maxstr = 4096;
  }
  {
#line 85
  orgcsize = csize;
#line 86
  inittable(orgcsize);
#line 88
  newcode = 0;
#line 88
  oldcode = newcode;
  }
#line 89
  if (max_bits == 12) {
#line 90
    data_in_point___1 ++;
  }
#line 92
  if (max_bits == 16) {
#line 93
    tmp___0 = data_in_point___1;
#line 93
    data_in_point___1 ++;
#line 93
    maxstr = 1 << (int )*tmp___0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp___1 = readcode(& newcode, csize);
    }
#line 97
    if (! tmp___1) {
#line 98
      goto while_break;
    }
#line 100
    noadd = 0;
#line 101
    if (first) {
#line 103
      k = newcode;
#line 103
      first = 0;
#line 104
      if (oldver) {
#line 104
        noadd = 1;
      }
    }
#line 107
    if (newcode == 256) {
#line 107
      if (! oldver) {
        {
#line 113
        st_last = 255;
#line 118
        code_resync(csize);
#line 119
        csize = orgcsize;
#line 120
        tmp___2 = readcode(& newcode, csize);
        }
#line 120
        if (! tmp___2) {
#line 121
          goto while_break;
        }
      }
    }
#line 124
    if (! oldver) {
#line 124
      if (newcode <= st_last) {
        {
#line 127
        outputstring(newcode);
#line 128
        k = findfirstchr(newcode);
        }
      } else {
#line 124
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 124
    if (oldver) {
#line 124
      if (st_chr[newcode] != -1) {
        {
#line 127
        outputstring(newcode);
#line 128
        k = findfirstchr(newcode);
        }
      } else {
        {
#line 141
        outputstring(oldcode);
#line 142
        outputchr(k);
        }
      }
    } else {
      {
#line 141
      outputstring(oldcode);
#line 142
      outputchr(k);
      }
    }
#line 145
    if (st_last != maxstr - 1) {
#line 147
      if (! noadd) {
        {
#line 149
        tmp___3 = addstring(oldcode, k);
        }
#line 149
        if (tmp___3) {
#line 149
          tmp___4 = 0;
        } else {
#line 149
          tmp___4 = 1;
        }
#line 155
        if (st_last != maxstr - 1) {
#line 155
          if (st_last == (1 << csize) - 1) {
            {
#line 157
            csize ++;
#line 158
            code_resync(csize - 1);
            }
          }
        }
      }
    }
#line 163
    oldcode = newcode;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if ((unsigned long )data_in_point___1 != (unsigned long )data_in_max___1) {
    {
#line 169
    free((void *)data_out);
    }
#line 170
    return ((unsigned char *)((void *)0));
  }
#line 173
  return (data_out);
}
}
#line 183 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
void code_resync(int old ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! codeofs) {
#line 187
      goto while_break;
    }
    {
#line 188
    tmp___0 = readcode(& tmp, old);
    }
#line 188
    if (! tmp___0) {
#line 189
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 193 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
void inittable(int orgcsize ) 
{ 
  int f ;
  int numcols ;

  {
#line 196
  numcols = 1 << (orgcsize - 1);
#line 198
  f = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (f < 65536)) {
#line 198
      goto while_break;
    }
#line 200
    st_chr[f] = -1;
#line 201
    st_ptr[f] = -1;
#line 202
    st_ptr1st[f] = -1;
#line 198
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  f = 0;
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 205
    if (! (f < 4096)) {
#line 205
      goto while_break___0;
    }
#line 206
    st_oldverhashlinks[f] = -1;
#line 205
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  if (oldver) {
#line 211
    st_last = -1;
#line 212
    f = 0;
    {
#line 212
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 212
      if (! (f < 256)) {
#line 212
        goto while_break___1;
      }
      {
#line 213
      addstring(65535, f);
#line 212
      f ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 217
    f = 0;
    {
#line 217
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 217
      if (! (f < numcols)) {
#line 217
        goto while_break___2;
      }
#line 218
      st_chr[f] = f;
#line 217
      f ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 219
    st_last = numcols - 1;
  }
#line 221
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
int oldver_getidx(int oldcode , int chr ) 
{ 
  int lasthash ;
  int hashval ;
  int a ;
  int f ;

  {
#line 238
  a = ((oldcode + chr) | 2048) & 65535;
#line 239
  hashval = (a * a >> 6) & 4095;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (st_chr[hashval] != -1) {
#line 242
      if (! (st_oldverhashlinks[hashval] != -1)) {
#line 242
        goto while_break;
      }
    } else {
#line 242
      goto while_break;
    }
#line 243
    hashval = st_oldverhashlinks[hashval];
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  if (st_chr[hashval] == -1) {
#line 247
    return (hashval);
  }
#line 249
  lasthash = hashval;
#line 256
  hashval += 101;
#line 257
  hashval &= 4095;
#line 259
  if (st_chr[hashval] != -1) {
#line 261
    f = 0;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if (! (f < maxstr)) {
#line 261
        goto while_break___0;
      }
#line 262
      if (st_chr[hashval] == -1) {
#line 263
        goto while_break___0;
      }
#line 261
      f ++;
#line 261
      hashval ++;
#line 261
      hashval &= 4095;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    if (hashval == maxstr) {
#line 265
      return (-1);
    }
  }
#line 269
  st_oldverhashlinks[lasthash] = hashval;
#line 271
  return (hashval);
}
}
#line 276 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
int addstring(int oldcode , int chr ) 
{ 
  int idx ;

  {
#line 280
  st_last ++;
#line 281
  if (st_last & maxstr) {
#line 283
    st_last = maxstr - 1;
#line 284
    return (1);
  }
#line 287
  idx = st_last;
#line 289
  if (oldver) {
    {
#line 292
    idx = oldver_getidx(oldcode, chr);
    }
#line 292
    if (idx == -1) {
#line 293
      return (0);
    }
  }
#line 296
  st_chr[idx] = chr;
#line 303
  if (oldcode >= maxstr) {
#line 303
    return (1);
  }
#line 304
  st_ptr[idx] = oldcode;
#line 306
  if (st_ptr[oldcode] == -1) {
#line 307
    st_ptr1st[idx] = oldcode;
  } else {
#line 309
    st_ptr1st[idx] = st_ptr1st[oldcode];
  }
#line 311
  return (1);
}
}
#line 316 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
int readcode(int *newcode , int numbits ) 
{ 
  int bitsfilled ;
  int got ;
  unsigned char *tmp ;

  {
#line 320
  got = 0;
#line 320
  bitsfilled = got;
#line 321
  *newcode = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (bitsfilled < numbits)) {
#line 323
      goto while_break;
    }
#line 325
    if (dc_bitsleft == 0) {
#line 327
      if ((unsigned long )data_in_point___1 >= (unsigned long )data_in_max___1) {
#line 328
        return (0);
      }
#line 329
      tmp = data_in_point___1;
#line 329
      data_in_point___1 ++;
#line 329
      dc_bitbox = (int )*tmp;
#line 330
      dc_bitsleft = 8;
    }
#line 332
    if (dc_bitsleft < numbits - bitsfilled) {
#line 333
      got = dc_bitsleft;
    } else {
#line 335
      got = numbits - bitsfilled;
    }
#line 337
    if (oldver) {
#line 339
      dc_bitbox &= 255;
#line 340
      dc_bitbox <<= got;
#line 341
      bitsfilled += got;
#line 342
      *newcode |= (dc_bitbox >> 8) << (numbits - bitsfilled);
#line 343
      dc_bitsleft -= got;
    } else {
#line 347
      *newcode |= (dc_bitbox & ((1 << got) - 1)) << bitsfilled;
#line 348
      dc_bitbox >>= got;
#line 349
      dc_bitsleft -= got;
#line 350
      bitsfilled += got;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  if (*newcode < 0) {
#line 354
    return (0);
  } else
#line 354
  if (*newcode > maxstr - 1) {
#line 354
    return (0);
  }
#line 357
  codeofs ++;
#line 358
  codeofs &= 7;
#line 360
  return (1);
}
}
#line 366 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static int buf___0[65536]  ;
#line 364 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
void outputstring(int code ) 
{ 
  int *ptr ;
  int *tmp ;

  {
#line 367
  ptr = buf___0;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (st_ptr[code] != -1) {
#line 369
      if (! ((unsigned long )ptr < (unsigned long )(buf___0 + maxstr))) {
#line 369
        goto while_break;
      }
    } else {
#line 369
      goto while_break;
    }
#line 371
    tmp = ptr;
#line 371
    ptr ++;
#line 371
    *tmp = st_chr[code];
#line 372
    code = st_ptr[code];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  outputchr(st_chr[code]);
  }
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! ((unsigned long )ptr > (unsigned long )(buf___0))) {
#line 376
      goto while_break___0;
    }
    {
#line 377
    ptr --;
#line 377
    outputchr(*ptr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 381 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
static void rawoutput___1(int byte ) 
{ 
  unsigned char *tmp ;

  {
#line 383
  if ((unsigned long )data_out_point___1 < (unsigned long )data_out_max___1) {
#line 384
    tmp = data_out_point___1;
#line 384
    data_out_point___1 ++;
#line 384
    *tmp = (unsigned char )byte;
  }
#line 385
  return;
}
}
#line 388 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
void outputchr(int chr ) 
{ 


  {
#line 390
  if (global_use_rle) {
    {
#line 391
    outputrle(chr, & rawoutput___1);
    }
  } else {
    {
#line 393
    rawoutput___1(chr);
    }
  }
#line 394
  return;
}
}
#line 397 "/home/wheatley/newnew/temp/nomarch-1.4/readlzw.c"
int findfirstchr(int code ) 
{ 


  {
#line 399
  if (st_ptr[code] != -1) {
#line 400
    code = st_ptr1st[code];
  }
#line 401
  return (st_chr[code]);
}
}
