/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/port_before.h"
struct timeval;
#line 31
struct timezone;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_51 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_51 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 104 "../include/arpa/nameser.h"
enum __ns_sect {
    ns_s_qd = 0,
    ns_s_zn = 0,
    ns_s_an = 1,
    ns_s_pr = 1,
    ns_s_ns = 2,
    ns_s_ud = 2,
    ns_s_ar = 3,
    ns_s_max = 4
} ;
#line 104 "../include/arpa/nameser.h"
typedef enum __ns_sect ns_sect;
#line 132 "../include/arpa/nameser.h"
struct __ns_msg {
   u_char const   *_msg ;
   u_char const   *_eom ;
   u_int16_t _id ;
   u_int16_t _flags ;
   u_int16_t _counts[4] ;
   u_char const   *_sections[4] ;
   ns_sect _sect ;
   int _rrnum ;
   u_char const   *_msg_ptr ;
};
#line 132 "../include/arpa/nameser.h"
typedef struct __ns_msg ns_msg;
#line 167 "../include/arpa/nameser.h"
struct __ns_rr {
   char name[1025] ;
   u_int16_t type ;
   u_int16_t rr_class ;
   u_int32_t ttl ;
   u_int16_t rdlength ;
   u_char const   *rdata ;
};
#line 167 "../include/arpa/nameser.h"
typedef struct __ns_rr ns_rr;
#line 266 "../include/arpa/nameser.h"
struct ns_tsig_key {
   char name[1025] ;
   char alg[1025] ;
   unsigned char *data ;
   int len ;
};
#line 271 "../include/arpa/nameser.h"
typedef struct ns_tsig_key ns_tsig_key;
#line 276
struct dst_key;
#line 276 "../include/arpa/nameser.h"
struct ns_tcp_tsig_state {
   int counter ;
   struct dst_key *key ;
   void *ctx ;
   unsigned char sig[512] ;
   int siglen ;
};
#line 283 "../include/arpa/nameser.h"
typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;
#line 296
enum __ns_type {
    ns_t_invalid = 0,
    ns_t_a = 1,
    ns_t_ns = 2,
    ns_t_md = 3,
    ns_t_mf = 4,
    ns_t_cname = 5,
    ns_t_soa = 6,
    ns_t_mb = 7,
    ns_t_mg = 8,
    ns_t_mr = 9,
    ns_t_null = 10,
    ns_t_wks = 11,
    ns_t_ptr = 12,
    ns_t_hinfo = 13,
    ns_t_minfo = 14,
    ns_t_mx = 15,
    ns_t_txt = 16,
    ns_t_rp = 17,
    ns_t_afsdb = 18,
    ns_t_x25 = 19,
    ns_t_isdn = 20,
    ns_t_rt = 21,
    ns_t_nsap = 22,
    ns_t_nsap_ptr = 23,
    ns_t_sig = 24,
    ns_t_key = 25,
    ns_t_px = 26,
    ns_t_gpos = 27,
    ns_t_aaaa = 28,
    ns_t_loc = 29,
    ns_t_nxt = 30,
    ns_t_eid = 31,
    ns_t_nimloc = 32,
    ns_t_srv = 33,
    ns_t_atma = 34,
    ns_t_naptr = 35,
    ns_t_kx = 36,
    ns_t_cert = 37,
    ns_t_a6 = 38,
    ns_t_dname = 39,
    ns_t_sink = 40,
    ns_t_opt = 41,
    ns_t_apl = 42,
    ns_t_ds = 43,
    ns_t_sshfp = 44,
    ns_t_ipseckey = 45,
    ns_t_rrsig = 46,
    ns_t_nsec = 47,
    ns_t_dnskey = 48,
    ns_t_dhcid = 49,
    ns_t_nsec3 = 50,
    ns_t_nsec3param = 51,
    ns_t_hip = 55,
    ns_t_spf = 99,
    ns_t_tkey = 249,
    ns_t_tsig = 250,
    ns_t_ixfr = 251,
    ns_t_axfr = 252,
    ns_t_mailb = 253,
    ns_t_maila = 254,
    ns_t_any = 255,
    ns_t_zxfr = 256,
    ns_t_dlv = 32769,
    ns_t_max = 65536
} ;
#line 296 "../include/arpa/nameser.h"
typedef enum __ns_type ns_type;
#line 94 "../include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_52 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 94 "../include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_52 HEADER;
#line 5 "../include/isc/dst.h"
struct dst_key {
   char *dk_key_name ;
   int dk_key_size ;
   int dk_proto ;
   int dk_alg ;
   u_int32_t dk_flags ;
   u_int16_t dk_id ;
};
#line 5 "../include/isc/dst.h"
typedef struct dst_key DST_KEY;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 172 "../include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   size_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 100 "../include/resolv.h"
struct __res_state;
#line 115
enum __anonenum_res_sendhookact_66 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 115 "../include/resolv.h"
typedef enum __anonenum_res_sendhookact_66 res_sendhookact;
#line 154
struct __res_state_ext;
#line 156 "../include/resolv.h"
struct __anonstruct_sort_list_67 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 156 "../include/resolv.h"
struct __anonstruct__ext_69 {
   u_int16_t nscount ;
   u_int16_t nstimes[3] ;
   int nssocks[3] ;
   struct __res_state_ext *ext ;
};
#line 156 "../include/resolv.h"
union __anonunion__u_68 {
   char pad[(56UL - 4UL * sizeof(int )) - 2UL * sizeof(void *)] ;
   struct __anonstruct__ext_69 _ext ;
};
#line 156 "../include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   char unused[3] ;
   struct __anonstruct_sort_list_67 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr * const  * , u_char const   ** , int * ,
                            u_char * , int  , int * ) ;
   res_sendhookact (*rhook)(struct sockaddr  const  * , u_char const   * , int  ,
                            u_char * , int  , int * ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   u_char _rnd[16] ;
   u_int _pad ;
   union __anonunion__u_68 _u ;
};
#line 202 "../include/resolv.h"
typedef struct __res_state *res_state;
#line 204 "../include/resolv.h"
union res_sockaddr_union {
   struct sockaddr_in sin ;
   struct sockaddr_in6 sin6 ;
   int32_t __align32 ;
   char __space[128] ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
struct __anonstruct_AddrInfo_70 {
   int addrType ;
   int addrLen ;
   char *addr ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
typedef struct __anonstruct_AddrInfo_70 AddrInfo;
#line 101 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
struct __anonstruct_ServerInfo_71 {
   char *name ;
   char **domains ;
   AddrInfo **addrList ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
typedef struct __anonstruct_ServerInfo_71 ServerInfo;
#line 107 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
struct __anonstruct_HostInfo_72 {
   char *name ;
   char **aliases ;
   AddrInfo **addrList ;
   ServerInfo **servers ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
typedef struct __anonstruct_HostInfo_72 HostInfo;
#line 283 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_packet__73 {
   HEADER header_ ;
   u_char packet_[512] ;
};
#line 289 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_answer_74 {
   HEADER u ;
   u_char b[65535] ;
};
#line 1274 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_querybuf_75 {
   HEADER qb1 ;
   u_char qb2[512] ;
};
#line 1274 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
typedef union __anonunion_querybuf_75 querybuf;
#line 1292
enum __anonenum_error_76 {
    NO_ERRORS = 0,
    ERR_READING_LEN = 1,
    ERR_READING_MSG = 2,
    ERR_PRINTING = 3
} ;
#line 1663 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 1663 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 1663 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 1663 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 1663 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 1663 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 134 "../include/resolv.h"
struct res_sym {
   int number ;
   char const   *name ;
   char const   *humanname ;
};
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 93 "../include/arpa/inet.h"
extern int __inet_aton(char const   * , struct in_addr * ) ;
#line 103
extern char *__inet_ntoa(struct in_addr  ) ;
#line 104
extern int __inet_pton(int  , char const   * , void * ) ;
#line 105
extern char const   *__inet_ntop(int  , void const   * , char * , size_t  ) ;
#line 585 "../include/arpa/nameser.h"
extern int __ns_msg_getflag(ns_msg  , int  ) ;
#line 586
extern u_int __ns_get16(u_char const   * ) ;
#line 588
extern void __ns_put16(u_int  , u_char * ) ;
#line 590
extern int __ns_initparse(u_char const   * , int  , ns_msg * ) ;
#line 592
extern int __ns_parserr(ns_msg * , ns_sect  , int  , ns_rr * ) ;
#line 594
extern int __ns_sprintrr(ns_msg const   * , ns_rr const   * , char const   * , char const   * ,
                         char * , size_t  ) ;
#line 626
extern int __ns_sign(u_char * , int * , int  , int  , void * , u_char const   * ,
                     int  , u_char * , int * , time_t  ) ;
#line 638
extern u_char *__ns_find_tsig(u_char * , u_char * ) ;
#line 642
extern int __ns_verify_tcp(u_char * , int * , ns_tcp_tsig_state * , int  ) ;
#line 643
extern int __ns_verify_tcp_init(void * , u_char const   * , int  , ns_tcp_tsig_state * ) ;
#line 648
extern int __ns_samename(char const   * , char const   * ) ;
#line 58 "../include/isc/dst.h"
extern void __dst_init(void) ;
#line 76
extern DST_KEY *__dst_read_key(char const   * , u_int16_t const    , int const    ,
                               int const    ) ;
#line 88
extern DST_KEY *__dst_buffer_to_key(char const   * , int const    , int const    ,
                                    int const    , u_char const   * , int const    ) ;
#line 94
extern int __dst_key_to_buffer(DST_KEY * , u_char * , int  ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 407 "../include/netdb.h"
extern int getaddrinfo(char const   * , char const   * , struct addrinfo  const  * ,
                       struct addrinfo ** ) ;
#line 411
extern void freeaddrinfo(struct addrinfo * ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 717
extern int system(char const   *__command ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 764
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 417 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/port_after.h"
extern int isc__gettimeofday(struct timeval *tp , struct timezone *tzp ) ;
#line 433 "../include/resolv.h"
extern int __dn_skipname(u_char const   * , u_char const   * ) ;
#line 442
extern char const   *__p_type(int  ) ;
#line 444
extern char const   *__p_sockun(union res_sockaddr_union  , char * , size_t  ) ;
#line 453
extern int __dn_comp(char const   * , u_char * , int  , u_char ** , u_char ** ) ;
#line 455
extern int __dn_expand(u_char const   * , u_char const   * , u_char const   * , char * ,
                       int  ) ;
#line 466
extern int __res_ninit(res_state  ) ;
#line 469
extern void __fp_resstat(res_state const    , FILE * ) ;
#line 479
extern int __res_nmkquery(res_state  , int  , char const   * , int  , int  , u_char const   * ,
                          int  , u_char const   * , u_char * , int  ) ;
#line 482
extern int __res_nsend(res_state  , u_char const   * , int  , u_char * , int  ) ;
#line 483
extern int __res_nsendsigned(res_state  , u_char const   * , int  , ns_tsig_key * ,
                             u_char * , int  ) ;
#line 491
extern int __res_nopt(res_state  , int  , u_char * , int  , int  ) ;
#line 507
extern void __res_setservers(res_state  , union res_sockaddr_union  const  * , int  ) ;
#line 509
extern int __res_getservers(res_state  , union res_sockaddr_union * , int  ) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
int pickString(char const   *src , char *dest , size_t dest_size ) ;
#line 120
int StringToType(char *type , int dflt , FILE *errorfile ) ;
#line 121
int StringToClass(char *class , int dflt , FILE *errorfile ) ;
#line 236 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static int eecode  =    0;
#line 237 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static FILE *qfp  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static char myhostname[64]  ;
#line 239 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static struct sockaddr_in myaddress  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static struct sockaddr_in6 myaddress6  ;
#line 241 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static u_int32_t ixfr_serial  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static char ubuf[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:123.123.123.123")]  ;
#line 245 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
struct __res_state res  ;
#line 246 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
FILE *filePtr  ;
#line 247 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
jmp_buf env  ;
#line 248 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
HostInfo *defaultPtr  =    (HostInfo *)((void *)0);
#line 249 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
HostInfo curHostInfo  ;
#line 249 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
HostInfo defaultRec  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
int curHostValid  =    0;
#line 251 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
int queryType  ;
#line 251 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
int queryClass  ;
#line 258 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
char *pager  =    (char *)((void *)0);
#line 263
static void Usage(void) ;
#line 264
static int setopt(char const   *string ) ;
#line 265
static void res_re_init(void) ;
#line 266
static int xstrtonum(char *p ) ;
#line 267
static int printZone(ns_type xfr , char const   *zone , struct sockaddr_in  const  *sin ,
                     ns_tsig_key *key ) ;
#line 269
static int print_axfr(FILE *file , u_char const   *msg , size_t msglen ) ;
#line 271
static struct timeval difftv(struct timeval a , struct timeval b ) ;
#line 272
static void prnttime(struct timeval t ) ;
#line 273
static void stackarg(char *l , char **y ) ;
#line 274
static void reverse6(char *domain , struct in6_addr *in6 ) ;
#line 278 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
int main(int argc , char **argv ) 
{ 
  short port ;
  uint16_t tmp ;
  short lport ;
  union __anonunion_packet__73 packet_ ;
  union __anonunion_answer_74 answer___0 ;
  int n ;
  char doping[90] ;
  char pingstr[50] ;
  char *afile ;
  char *addrc ;
  char *addrend ;
  char *addrbegin ;
  time_t exectime ;
  struct timeval tv1 ;
  struct timeval tv2 ;
  struct timeval start_time ;
  struct timeval end_time ;
  struct timeval query_time ;
  char *srv ;
  int anyflag ;
  int sticky ;
  int tmp___0 ;
  int qtypeSet ;
  ns_type xfr ;
  int bytes_out ;
  int bytes_in ;
  char cmd[512] ;
  char domain[1025] ;
  char msg[120] ;
  char **vtmp ;
  char *args[30] ;
  char **ax ;
  int once ;
  int dofile ;
  char fileq[384] ;
  int fp ;
  int wait___0 ;
  int delay ;
  int envset ;
  int envsave ;
  struct __res_state res_x ;
  struct __res_state res_t ;
  int r ;
  struct in6_addr in6 ;
  ns_tsig_key key ;
  char *keyfile ;
  char *keyname ;
  char const   *pingfmt ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  unsigned long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  int tmp___18 ;
  uint16_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *a ;
  char *p ;
  char *tmp___22 ;
  int tmp___23 ;
  uint16_t tmp___24 ;
  uint16_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  DST_KEY *dst_key ;
  char cwd[4097] ;
  char *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  int nscount ;
  union res_sockaddr_union u[3] ;
  struct addrinfo *answer___1 ;
  struct addrinfo *cur ;
  struct addrinfo hint ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int i ;
  int nscount___0 ;
  union res_sockaddr_union u___0[3] ;
  int x ;
  char const   *tmp___43 ;
  char *tmp___44 ;
  HEADER *hp ;
  u_char *cpp ;
  uint16_t tmp___45 ;
  uint16_t tmp___46 ;
  register u_int16_t t_s ;
  register u_char *t_cp ;
  u_char *tmp___47 ;
  register u_int16_t t_s___0 ;
  register u_char *t_cp___0 ;
  u_char *tmp___48 ;
  register u_int32_t t_l ;
  register u_char *t_cp___1 ;
  u_char *tmp___49 ;
  u_char *tmp___50 ;
  u_char *tmp___51 ;
  register u_int16_t t_s___1 ;
  register u_char *t_cp___2 ;
  u_char *tmp___52 ;
  u_char *tmp___53 ;
  u_char *tmp___54 ;
  register u_int32_t t_l___0 ;
  register u_char *t_cp___3 ;
  u_char *tmp___55 ;
  u_char *tmp___56 ;
  u_char *tmp___57 ;
  register u_int32_t t_l___1 ;
  register u_char *t_cp___4 ;
  u_char *tmp___58 ;
  u_char *tmp___59 ;
  u_char *tmp___60 ;
  register u_int32_t t_l___2 ;
  register u_char *t_cp___5 ;
  u_char *tmp___61 ;
  u_char *tmp___62 ;
  u_char *tmp___63 ;
  register u_int32_t t_l___3 ;
  register u_char *t_cp___6 ;
  u_char *tmp___64 ;
  u_char *tmp___65 ;
  u_char *tmp___66 ;
  register u_int32_t t_l___4 ;
  register u_char *t_cp___7 ;
  u_char *tmp___67 ;
  u_char *tmp___68 ;
  u_char *tmp___69 ;
  union res_sockaddr_union u___1[3] ;
  char const   *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  int tmp___73 ;

  {
  {
#line 280
  tmp = htons((uint16_t )53);
#line 280
  port = (short )tmp;
#line 303
  anyflag = 0;
#line 304
  sticky = 0;
#line 307
  xfr = (ns_type )0;
#line 315
  once = 1;
#line 315
  dofile = 0;
#line 318
  wait___0 = 0;
#line 319
  envset = 0;
#line 319
  envsave = 0;
#line 325
  keyfile = (char *)((void *)0);
#line 325
  keyname = (char *)((void *)0);
#line 326
  pingfmt = (char const   *)((void *)0);
#line 328
  argc = argc;
#line 330
  __res_ninit(& res);
#line 331
  res.pfcode = (u_long )45049;
#line 332
  qtypeSet = 0;
#line 333
  memset((void *)(domain), 0, sizeof(domain));
#line 334
  gethostname(myhostname, sizeof(myhostname));
#line 338
  myaddress.sin_family = (sa_family_t )2;
#line 339
  myaddress.sin_addr.s_addr = (in_addr_t )0;
#line 340
  myaddress.sin_port = (in_port_t )0;
#line 345
  myaddress6.sin6_family = (sa_family_t )10;
#line 346
  myaddress6.sin6_addr = (struct in6_addr )in6addr_any;
#line 347
  myaddress6.sin6_port = (in_port_t )0;
#line 349
  res_x = res;
#line 357
  tmp___1 = getenv("LOCALDEF");
#line 357
  afile = tmp___1;
  }
#line 357
  if ((unsigned long )afile != (unsigned long )((char *)((void *)0))) {
    {
#line 357
    fp = open((char const   *)afile, 0);
    }
#line 357
    if (fp > 0) {
      {
#line 360
      read(fp, (void *)((char *)(& res_x)), sizeof(res_x));
#line 361
      close(fp);
#line 362
      res = res_x;
      }
    } else {
#line 357
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 357
    fp = open("DiG.env", 0);
    }
#line 357
    if (fp > 0) {
      {
#line 360
      read(fp, (void *)((char *)(& res_x)), sizeof(res_x));
#line 361
      close(fp);
#line 362
      res = res_x;
      }
    }
  }
#line 367
  vtmp = argv;
#line 368
  ax = args;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((unsigned long )*vtmp != (unsigned long )((void *)0))) {
#line 369
      goto while_break;
    }
    {
#line 370
    tmp___2 = strcmp((char const   *)*vtmp, "-h");
    }
#line 370
    if (tmp___2 == 0) {
      {
#line 374
      Usage();
#line 375
      exit(0);
      }
    } else {
      {
#line 370
      tmp___3 = strcmp((char const   *)*vtmp, "-help");
      }
#line 370
      if (tmp___3 == 0) {
        {
#line 374
        Usage();
#line 375
        exit(0);
        }
      } else {
        {
#line 370
        tmp___4 = strcmp((char const   *)*vtmp, "-usage");
        }
#line 370
        if (tmp___4 == 0) {
          {
#line 374
          Usage();
#line 375
          exit(0);
          }
        } else {
          {
#line 370
          tmp___5 = strcmp((char const   *)*vtmp, "help");
          }
#line 370
          if (tmp___5 == 0) {
            {
#line 374
            Usage();
#line 375
            exit(0);
            }
          }
        }
      }
    }
    {
#line 378
    tmp___7 = strcmp((char const   *)*vtmp, "-f");
    }
#line 378
    if (tmp___7 == 0) {
      {
#line 379
      dofile ++;
#line 379
      once = 0;
#line 380
      vtmp ++;
#line 380
      qfp = fopen((char const   */* __restrict  */)*vtmp, (char const   */* __restrict  */)"r");
      }
#line 380
      if ((unsigned long )qfp == (unsigned long )((void *)0)) {
        {
#line 381
        fflush(stdout);
#line 382
        perror("file open");
#line 383
        fflush(stderr);
#line 384
        exit(10);
        }
      }
    } else {
#line 387
      if (ax - args == 30L) {
        {
#line 388
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dig: too many arguments\n");
#line 389
        exit(10);
        }
      }
#line 391
      tmp___6 = ax;
#line 391
      ax ++;
#line 391
      *tmp___6 = *vtmp;
    }
#line 393
    vtmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 396
  isc__gettimeofday(& tv1, (struct timezone *)((void *)0));
#line 402
  fileq[0] = (char )'\000';
  }
  {
#line 403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 403
    if (dofile) {
      {
#line 403
      tmp___72 = fgets((char */* __restrict  */)(fileq), (int )sizeof(fileq), (FILE */* __restrict  */)qfp);
      }
#line 403
      if (! ((unsigned long )tmp___72 != (unsigned long )((void *)0))) {
#line 403
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 403
    if (! dofile) {
#line 403
      tmp___73 = once;
#line 403
      once --;
#line 403
      if (! tmp___73) {
#line 403
        goto while_break___0;
      }
    } else {
#line 403
      goto while_break___0;
    }
#line 406
    if ((int )fileq[0] == 10) {
      {
#line 407
      printf((char const   */* __restrict  */)"%s", fileq);
      }
#line 408
      goto while_continue___0;
    } else
#line 406
    if ((int )fileq[0] == 35) {
      {
#line 407
      printf((char const   */* __restrict  */)"%s", fileq);
      }
#line 408
      goto while_continue___0;
    } else
#line 406
    if ((int )fileq[0] == 59) {
      {
#line 407
      printf((char const   */* __restrict  */)"%s", fileq);
      }
#line 408
      goto while_continue___0;
    }
#line 415
    if (sticky) {
      {
#line 416
      printf((char const   */* __restrict  */)";; (using sticky settings)\n");
#line 417
      res = res_x;
      }
    }
    {
#line 423
    stackarg(fileq, ax);
#line 426
    queryType = 2;
#line 427
    queryClass = 1;
#line 428
    xfr = (ns_type )0;
#line 429
    pingstr[0] = (char)0;
#line 430
    srv = (char *)((void *)0);
#line 432
    sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"\n; <<>> DiG %s (libbind %d) <<>> ",
            "8.4", 20090302);
#line 434
    argv = args;
    }
    {
#line 440
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 440
      argv ++;
#line 440
      if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 440
        if (! ((int )*(*argv) != 0)) {
#line 440
          goto while_break___1;
        }
      } else {
#line 440
        goto while_break___1;
      }
      {
#line 441
      tmp___8 = strlen((char const   *)(cmd));
#line 441
      tmp___9 = strlen((char const   *)*argv);
      }
#line 441
      if ((tmp___8 + tmp___9) + 2UL > sizeof(cmd)) {
        {
#line 442
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Argument too large for input buffer\n");
#line 444
        exit(1);
        }
      }
      {
#line 446
      strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)*argv);
#line 447
      strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)" ");
      }
#line 448
      if ((int )*(*argv) == 64) {
#line 449
        srv = *argv + 1;
#line 450
        goto while_continue___1;
      }
#line 452
      if ((int )*(*argv) == 37) {
#line 453
        goto while_continue___1;
      }
#line 454
      if ((int )*(*argv) == 43) {
        {
#line 455
        setopt((char const   *)(*argv + 1));
        }
#line 456
        goto while_continue___1;
      }
#line 458
      if ((int )*(*argv) == 61) {
        {
#line 459
        tmp___10 = strtoul((char const   */* __restrict  */)(*argv + 1), (char **/* __restrict  */)((void *)0),
                           0);
#line 459
        ixfr_serial = (u_int32_t )tmp___10;
        }
#line 460
        goto while_continue___1;
      }
      {
#line 462
      tmp___14 = strncmp((char const   *)*argv, "-nost", (size_t )5);
      }
#line 462
      if (tmp___14 == 0) {
#line 463
        sticky = 0;
#line 464
        goto while_continue___1;
      } else {
        {
#line 465
        tmp___13 = strncmp((char const   *)*argv, "-st", (size_t )3);
        }
#line 465
        if (tmp___13 == 0) {
#line 466
          sticky ++;
#line 467
          goto while_continue___1;
        } else {
          {
#line 468
          tmp___12 = strncmp((char const   *)*argv, "-envsa", (size_t )6);
          }
#line 468
          if (tmp___12 == 0) {
#line 469
            envsave ++;
#line 470
            goto while_continue___1;
          } else {
            {
#line 471
            tmp___11 = strncmp((char const   *)*argv, "-envse", (size_t )6);
            }
#line 471
            if (tmp___11 == 0) {
#line 472
              envset ++;
#line 473
              goto while_continue___1;
            }
          }
        }
      }
#line 476
      if ((int )*(*argv) == 45) {
        {
#line 478
        if ((int )*(*(argv + 0) + 1) == 84) {
#line 478
          goto case_84;
        }
#line 484
        if ((int )*(*(argv + 0) + 1) == 99) {
#line 484
          goto case_99;
        }
#line 500
        if ((int )*(*(argv + 0) + 1) == 116) {
#line 500
          goto case_116;
        }
#line 526
        if ((int )*(*(argv + 0) + 1) == 120) {
#line 526
          goto case_120;
        }
#line 552
        if ((int )*(*(argv + 0) + 1) == 112) {
#line 552
          goto case_112;
        }
#line 560
        if ((int )*(*(argv + 0) + 1) == 80) {
#line 560
          goto case_80;
        }
#line 570
        if ((int )*(*(argv + 0) + 1) == 110) {
#line 570
          goto case_110;
        }
#line 578
        if ((int )*(*(argv + 0) + 1) == 98) {
#line 578
          goto case_98;
        }
#line 605
        if ((int )*(*(argv + 0) + 1) == 107) {
#line 605
          goto case_107;
        }
#line 477
        goto switch_break;
        case_84: /* CIL Label */ 
#line 479
        argv ++;
#line 479
        if ((unsigned long )*argv == (unsigned long )((void *)0)) {
          {
#line 480
          printf((char const   */* __restrict  */)"; no arg for -T?\n");
          }
        } else {
          {
#line 482
          wait___0 = atoi((char const   *)*argv);
          }
        }
#line 483
        goto switch_break;
        case_99: /* CIL Label */ 
#line 485
        argv ++;
#line 485
        if ((unsigned long )*argv == (unsigned long )((void *)0)) {
          {
#line 486
          printf((char const   */* __restrict  */)"; no arg for -c?\n");
          }
        } else {
          {
#line 487
          tmp___0 = atoi((char const   *)*argv);
          }
#line 487
          if (tmp___0) {
#line 489
            queryClass = tmp___0;
          } else
#line 487
          if ((int )*(*(argv + 0)) == 48) {
#line 489
            queryClass = tmp___0;
          } else {
            {
#line 490
            tmp___0 = StringToClass(*argv, 0, (FILE *)((void *)0));
            }
#line 490
            if (tmp___0 != 0) {
#line 493
              queryClass = tmp___0;
            } else {
              {
#line 495
              printf((char const   */* __restrict  */)"; invalid class specified\n");
              }
            }
          }
        }
#line 499
        goto switch_break;
        case_116: /* CIL Label */ 
#line 501
        argv ++;
#line 501
        if ((unsigned long )*argv == (unsigned long )((void *)0)) {
          {
#line 502
          printf((char const   */* __restrict  */)"; no arg for -t?\n");
          }
        } else {
          {
#line 503
          tmp___0 = atoi((char const   *)*argv);
          }
#line 503
          if (tmp___0) {
#line 503
            goto _L___0;
          } else
#line 503
          if ((int )*(*(argv + 0)) == 48) {
            _L___0: /* CIL Label */ 
#line 505
            if (tmp___0 == 252) {
#line 506
              xfr = (ns_type )tmp___0;
            } else
#line 505
            if (tmp___0 == 251) {
#line 506
              xfr = (ns_type )tmp___0;
            } else
#line 505
            if (tmp___0 == 256) {
#line 506
              xfr = (ns_type )tmp___0;
            } else {
#line 508
              queryType = tmp___0;
#line 509
              qtypeSet ++;
            }
          } else {
            {
#line 511
            tmp___0 = StringToType(*argv, 0, (FILE *)((void *)0));
            }
#line 511
            if (tmp___0 != 0) {
#line 514
              if (tmp___0 == 252) {
#line 515
                xfr = (ns_type )tmp___0;
              } else
#line 514
              if (tmp___0 == 251) {
#line 515
                xfr = (ns_type )tmp___0;
              } else
#line 514
              if (tmp___0 == 256) {
#line 515
                xfr = (ns_type )tmp___0;
              } else {
#line 517
                queryType = tmp___0;
#line 518
                qtypeSet ++;
              }
            } else {
              {
#line 521
              printf((char const   */* __restrict  */)"; invalid type specified\n");
              }
            }
          }
        }
#line 525
        goto switch_break;
        case_120: /* CIL Label */ 
#line 527
        if (! qtypeSet) {
#line 528
          queryType = 255;
#line 529
          qtypeSet ++;
        }
#line 531
        argv ++;
#line 531
        addrc = *argv;
#line 531
        if ((unsigned long )addrc == (unsigned long )((void *)0)) {
          {
#line 532
          printf((char const   */* __restrict  */)"; no arg for -x?\n");
          }
#line 533
          goto switch_break;
        }
        {
#line 535
        r = __inet_pton(10, (char const   *)addrc, (void *)(& in6));
        }
#line 536
        if (r > 0) {
          {
#line 537
          reverse6(domain, & in6);
          }
#line 538
          goto switch_break;
        }
        {
#line 540
        tmp___15 = strlen((char const   *)addrc);
#line 540
        addrend = addrc + tmp___15;
        }
#line 541
        if ((int )*addrend == 46) {
#line 542
          *addrend = (char )'\000';
        }
#line 543
        domain[0] = (char )'\000';
        {
#line 544
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 544
          addrbegin = strrchr((char const   *)addrc, '.');
          }
#line 544
          if (! addrbegin) {
#line 544
            goto while_break___2;
          }
          {
#line 545
          strcat((char */* __restrict  */)(domain), (char const   */* __restrict  */)(addrbegin + 1));
#line 546
          strcat((char */* __restrict  */)(domain), (char const   */* __restrict  */)".");
#line 547
          *addrbegin = (char )'\000';
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 549
        strcat((char */* __restrict  */)(domain), (char const   */* __restrict  */)addrc);
#line 550
        strcat((char */* __restrict  */)(domain), (char const   */* __restrict  */)".in-addr.arpa.");
        }
#line 551
        goto switch_break;
        case_112: /* CIL Label */ 
#line 553
        if ((int )*(*(argv + 0) + 2) != 0) {
          {
#line 554
          tmp___16 = atoi((char const   *)(*(argv + 0) + 2));
#line 554
          tmp___17 = htons((uint16_t )tmp___16);
#line 554
          port = (short )tmp___17;
          }
        } else {
#line 555
          argv ++;
#line 555
          if ((unsigned long )*argv == (unsigned long )((void *)0)) {
            {
#line 556
            printf((char const   */* __restrict  */)"; no arg for -p?\n");
            }
          } else {
            {
#line 558
            tmp___18 = atoi((char const   *)*argv);
#line 558
            tmp___19 = htons((uint16_t )tmp___18);
#line 558
            port = (short )tmp___19;
            }
          }
        }
#line 559
        goto switch_break;
        case_80: /* CIL Label */ 
#line 561
        if ((int )*(*(argv + 0) + 2) != 0) {
          {
#line 562
          strcpy((char */* __restrict  */)(pingstr), (char const   */* __restrict  */)(*(argv + 0) + 2));
#line 563
          pingfmt = "%s %s 56 3 | %s -3";
          }
        } else {
          {
#line 566
          strcpy((char */* __restrict  */)(pingstr), (char const   */* __restrict  */)"ping");
#line 567
          pingfmt = "%s -s %s 56 3 | %s -3";
          }
        }
#line 569
        goto switch_break;
        case_110: /* CIL Label */ 
#line 571
        if ((int )*(*(argv + 0) + 2) != 0) {
          {
#line 572
          tmp___20 = atoi((char const   *)(*(argv + 0) + 2));
#line 572
          res.ndots = (unsigned int )tmp___20;
          }
        } else {
#line 573
          argv ++;
#line 573
          if ((unsigned long )*argv == (unsigned long )((void *)0)) {
            {
#line 574
            printf((char const   */* __restrict  */)"; no arg for -n?\n");
            }
          } else {
            {
#line 576
            tmp___21 = atoi((char const   *)*argv);
#line 576
            res.ndots = (unsigned int )tmp___21;
            }
          }
        }
#line 577
        goto switch_break;
        case_98: /* CIL Label */ 
#line 581
        if ((int )*(*(argv + 0) + 2) != 0) {
#line 582
          a = *(argv + 0) + 2;
        } else {
#line 583
          argv ++;
#line 583
          if ((unsigned long )*argv == (unsigned long )((void *)0)) {
            {
#line 584
            printf((char const   */* __restrict  */)"; no arg for -b?\n");
            }
#line 585
            goto switch_break;
          } else {
#line 587
            a = *argv;
          }
        }
        {
#line 588
        p = strchr((char const   *)a, ':');
        }
#line 588
        if ((unsigned long )p != (unsigned long )((void *)0)) {
          {
#line 589
          tmp___22 = p;
#line 589
          p ++;
#line 589
          *tmp___22 = (char )'\000';
#line 590
          tmp___23 = atoi((char const   *)p);
#line 590
          tmp___24 = htons((uint16_t )tmp___23);
#line 590
          lport = (short )tmp___24;
          }
        } else {
          {
#line 592
          tmp___25 = htons((uint16_t )0);
#line 592
          lport = (short )tmp___25;
          }
        }
        {
#line 593
        tmp___27 = __inet_pton(10, (char const   *)a, (void *)(& myaddress6.sin6_addr));
        }
#line 593
        if (tmp___27 == 1) {
#line 595
          myaddress6.sin6_port = (in_port_t )lport;
        } else {
          {
#line 596
          tmp___26 = __inet_aton((char const   *)a, & myaddress.sin_addr);
          }
#line 596
          if (tmp___26) {
#line 602
            myaddress.sin_port = (in_port_t )lport;
          } else {
            {
#line 598
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";; bad -b addr\n");
#line 600
            exit(1);
            }
          }
        }
#line 604
        goto switch_break;
        case_107: /* CIL Label */ 
#line 608
        if ((int )*(*(argv + 0) + 2) != 0) {
#line 609
          keyfile = *(argv + 0) + 2;
        } else {
#line 610
          argv ++;
#line 610
          if ((unsigned long )*argv == (unsigned long )((void *)0)) {
            {
#line 611
            printf((char const   */* __restrict  */)"; no arg for -k?\n");
            }
#line 612
            goto switch_break;
          } else {
#line 614
            keyfile = *argv;
          }
        }
        {
#line 616
        keyname = strchr((char const   *)keyfile, ':');
        }
#line 617
        if ((unsigned long )keyname == (unsigned long )((void *)0)) {
          {
#line 618
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"key option argument should be keydir:keyname\n");
#line 620
          exit(1);
          }
        }
#line 622
        tmp___28 = keyname;
#line 622
        keyname ++;
#line 622
        *tmp___28 = (char )'\000';
#line 623
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 625
        goto while_continue___1;
      }
      {
#line 628
      tmp___0 = StringToType(*argv, -1, (FILE *)((void *)0));
      }
#line 628
      if (tmp___0 != -1) {
#line 629
        if (255 == tmp___0) {
#line 629
          tmp___29 = anyflag;
#line 629
          anyflag ++;
#line 629
          if (tmp___29) {
#line 630
            queryClass = 255;
#line 631
            goto while_continue___1;
          }
        }
#line 633
        if (tmp___0 == 252) {
#line 633
          goto _L___1;
        } else
#line 633
        if (tmp___0 == 251) {
#line 633
          goto _L___1;
        } else
#line 633
        if (tmp___0 == 256) {
          _L___1: /* CIL Label */ 
#line 633
          if (tmp___0 == 252) {
#line 637
            res.pfcode = (u_long )42233;
#line 638
            xfr = (ns_type )tmp___0;
          } else
#line 633
          if ((res.options & 8UL) != 0UL) {
#line 637
            res.pfcode = (u_long )42233;
#line 638
            xfr = (ns_type )tmp___0;
          } else {
#line 640
            queryType = tmp___0;
#line 641
            qtypeSet ++;
          }
        } else {
#line 640
          queryType = tmp___0;
#line 641
          qtypeSet ++;
        }
      } else {
        {
#line 643
        tmp___0 = StringToClass(*argv, -1, (FILE *)((void *)0));
        }
#line 643
        if (tmp___0 != -1) {
#line 645
          queryClass = tmp___0;
        } else {
          {
#line 647
          memset((void *)(domain), 0, sizeof(domain));
#line 648
          sprintf((char */* __restrict  */)(domain), (char const   */* __restrict  */)"%s",
                  *argv);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 653
    if (keyfile) {
      {
#line 728
      tmp___30 = getcwd(cwd, (size_t )4096);
      }
#line 728
      if ((unsigned long )tmp___30 == (unsigned long )((void *)0)) {
        {
#line 729
        perror("unable to get current directory");
#line 730
        exit(1);
        }
      }
      {
#line 732
      tmp___33 = chdir((char const   *)keyfile);
      }
#line 732
      if (tmp___33 < 0) {
        {
#line 733
        tmp___31 = __errno_location();
#line 733
        tmp___32 = strerror(*tmp___31);
#line 733
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to chdir to %s: %s\n",
                keyfile, tmp___32);
#line 736
        exit(1);
        }
      }
      {
#line 739
      __dst_init();
#line 740
      dst_key = __dst_read_key((char const   *)keyname, (u_int16_t const   )0, (int const   )157,
                               (int const   )33554432);
      }
#line 743
      if (! dst_key) {
        {
#line 744
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dst_read_key: error reading key\n");
#line 746
        exit(1);
        }
      }
      {
#line 748
      tmp___34 = malloc(1024UL * sizeof(char ));
#line 748
      key.data = (unsigned char *)tmp___34;
#line 749
      __dst_key_to_buffer(dst_key, key.data, 1024);
#line 750
      key.len = dst_key->dk_key_size;
#line 752
      strcpy((char */* __restrict  */)(key.name), (char const   */* __restrict  */)keyname);
#line 753
      strcpy((char */* __restrict  */)(key.alg), (char const   */* __restrict  */)"HMAC-MD5.SIG-ALG.REG.INT");
#line 755
      tmp___37 = chdir((char const   *)(cwd));
      }
#line 755
      if (tmp___37 < 0) {
        {
#line 756
        tmp___35 = __errno_location();
#line 756
        tmp___36 = strerror(*tmp___35);
#line 756
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to chdir to %s: %s\n",
                cwd, tmp___36);
#line 758
        exit(1);
        }
      }
    }
#line 763
    if (res.pfcode & 524288UL) {
      {
#line 764
      printf((char const   */* __restrict  */)"; pfcode: %08lx, options: %08lx\n",
             res.pfcode, res.options);
      }
    }
#line 772
    if (envset) {
#line 773
      res_x = res;
#line 774
      envset = 0;
    }
#line 782
    if (envsave) {
      {
#line 783
      tmp___38 = getenv("LOCALDEF");
#line 783
      afile = tmp___38;
      }
#line 784
      if (afile) {
        {
#line 784
        fp = open((char const   *)afile, 577, 384);
        }
#line 784
        if (fp > 0) {
          {
#line 792
          write(fp, (void const   *)((char *)(& res)), sizeof(res));
#line 793
          close(fp);
          }
        } else {
#line 784
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 784
        fp = open("DiG.env", 577, 384);
        }
#line 784
        if (fp > 0) {
          {
#line 792
          write(fp, (void const   *)((char *)(& res)), sizeof(res));
#line 793
          close(fp);
          }
        }
      }
#line 795
      envsave = 0;
    }
#line 798
    if (res.pfcode & 8UL) {
      {
#line 799
      printf((char const   */* __restrict  */)"%s\n", cmd);
      }
    }
#line 801
    anyflag = 0;
#line 812
    if ((unsigned long )srv != (unsigned long )((void *)0)) {
      {
#line 813
      nscount = 0;
#line 815
      answer___1 = (struct addrinfo *)((void *)0);
#line 816
      cur = (struct addrinfo *)((void *)0);
#line 819
      memset((void *)(u), 0, sizeof(u));
#line 820
      res_t = res;
#line 821
      __res_ninit(& res);
#line 822
      res.pfcode = (u_long )0;
#line 823
      res.options = (u_long )2147484352U;
#line 824
      memset((void *)(& hint), 0, sizeof(hint));
#line 825
      hint.ai_socktype = 2;
#line 826
      tmp___41 = getaddrinfo((char const   *)srv, (char const   *)((void *)0), (struct addrinfo  const  *)(& hint),
                             & answer___1);
      }
#line 826
      if (tmp___41) {
        {
#line 853
        res = res_t;
#line 854
        fflush(stdout);
#line 855
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"; Bad server: %s -- using default server and timer opts\n",
                srv);
#line 858
        fflush(stderr);
#line 859
        srv = (char *)((void *)0);
        }
      } else {
#line 827
        res = res_t;
#line 828
        cur = answer___1;
#line 829
        cur = answer___1;
        {
#line 829
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 829
          if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 829
            goto while_break___3;
          }
#line 832
          if (nscount == 3) {
#line 833
            goto while_break___3;
          }
          {
#line 835
          if ((int )(cur->ai_addr)->sa_family == 10) {
#line 835
            goto case_10;
          }
#line 841
          if ((int )(cur->ai_addr)->sa_family == 2) {
#line 841
            goto case_2;
          }
#line 834
          goto switch_break___0;
          case_10: /* CIL Label */ 
#line 836
          u[nscount].sin6 = *((struct sockaddr_in6 *)cur->ai_addr);
#line 838
          tmp___39 = nscount;
#line 838
          nscount ++;
#line 838
          u[tmp___39].sin6.sin6_port = (in_port_t )port;
#line 840
          goto switch_break___0;
          case_2: /* CIL Label */ 
#line 842
          u[nscount].sin = *((struct sockaddr_in *)cur->ai_addr);
#line 844
          tmp___40 = nscount;
#line 844
          nscount ++;
#line 844
          u[tmp___40].sin.sin_port = (in_port_t )port;
#line 846
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 829
          cur = cur->ai_next;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 849
        if (nscount != 0) {
          {
#line 850
          __res_setservers(& res, (union res_sockaddr_union  const  *)(u), nscount);
          }
        }
        {
#line 851
        freeaddrinfo(answer___1);
        }
      }
#line 861
      if (res.nscount == 1) {
#line 861
        tmp___42 = "";
      } else {
#line 861
        tmp___42 = "s";
      }
      {
#line 861
      printf((char const   */* __restrict  */)"; (%d server%s found)\n", res.nscount,
             tmp___42);
#line 863
      res.id = (u_short )((int )res.id + res.retry);
      }
    }
#line 866
    if ((unsigned int )xfr == 252U) {
#line 866
      goto _L___3;
    } else
#line 866
    if ((unsigned int )xfr == 251U) {
#line 866
      goto _L___3;
    } else
#line 866
    if ((unsigned int )xfr == 256U) {
      _L___3: /* CIL Label */ 
      {
#line 870
      nscount___0 = __res_getservers(& res, u___0, 3);
#line 871
      i = 0;
      }
      {
#line 871
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 871
        if (! (i < nscount___0)) {
#line 871
          goto while_break___4;
        }
#line 874
        if (keyfile) {
          {
#line 875
          x = printZone(xfr, (char const   *)(domain), (struct sockaddr_in  const  *)(& u___0[i].sin),
                        & key);
          }
        } else {
          {
#line 879
          x = printZone(xfr, (char const   *)(domain), (struct sockaddr_in  const  *)(& u___0[i].sin),
                        (ns_tsig_key *)((void *)0));
          }
        }
#line 882
        if (res.pfcode & 1UL) {
          {
#line 883
          exectime = time((time_t *)((void *)0));
#line 884
          tmp___43 = __p_sockun(u___0[i], ubuf, sizeof(ubuf));
#line 884
          printf((char const   */* __restrict  */)";; FROM: %s to SERVER: %s\n", myhostname,
                 tmp___43);
#line 888
          tmp___44 = ctime((time_t const   *)(& exectime));
#line 888
          printf((char const   */* __restrict  */)";; WHEN: %s", tmp___44);
          }
        }
#line 890
        if (! x) {
#line 891
          goto while_break___4;
        }
#line 871
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 893
      fflush(stdout);
      }
#line 894
      goto while_continue___0;
    }
#line 897
    if (domain[0]) {
#line 897
      if (! qtypeSet) {
#line 898
        queryType = 1;
#line 899
        qtypeSet ++;
      }
    }
    {
#line 902
    n = __res_nmkquery(& res, 0, (char const   *)(domain), queryClass, queryType,
                       (u_char const   *)((void *)0), 0, (u_char const   *)((void *)0),
                       packet_.packet_, (int )sizeof(packet_.packet_));
#line 902
    bytes_out = n;
    }
#line 906
    if (n < 0) {
      {
#line 907
      fflush(stderr);
#line 908
      printf((char const   */* __restrict  */)";; res_nmkquery: buffer too small\n\n");
#line 909
      fflush(stdout);
      }
#line 910
      goto while_continue___0;
    }
#line 912
    if (queryType == 251) {
      {
#line 913
      hp = (HEADER *)(packet_.packet_);
#line 914
      cpp = packet_.packet_ + bytes_out;
#line 916
      tmp___45 = ntohs((uint16_t )hp->nscount);
#line 916
      tmp___46 = htons((uint16_t )(1 + (int )tmp___45));
#line 916
      hp->nscount = (unsigned int )tmp___46;
#line 917
      n = __dn_comp((char const   *)(domain), cpp, (int )(sizeof(packet_.packet_) - (unsigned long )(cpp - packet_.packet_)),
                    (u_char **)((void *)0), (u_char **)((void *)0));
#line 920
      cpp += n;
      }
      {
#line 921
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 921
        t_s = (u_int16_t )6;
#line 921
        t_cp = cpp;
#line 921
        tmp___47 = t_cp;
#line 921
        t_cp ++;
#line 921
        *tmp___47 = (u_char )((int )t_s >> 8);
#line 921
        *t_cp = (u_char )t_s;
#line 921
        cpp += 2;
#line 921
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 922
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 922
        t_s___0 = (u_int16_t )1;
#line 922
        t_cp___0 = cpp;
#line 922
        tmp___48 = t_cp___0;
#line 922
        t_cp___0 ++;
#line 922
        *tmp___48 = (u_char )((int )t_s___0 >> 8);
#line 922
        *t_cp___0 = (u_char )t_s___0;
#line 922
        cpp += 2;
#line 922
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 923
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 923
        t_l = (u_int32_t )0;
#line 923
        t_cp___1 = cpp;
#line 923
        tmp___49 = t_cp___1;
#line 923
        t_cp___1 ++;
#line 923
        *tmp___49 = (u_char )(t_l >> 24);
#line 923
        tmp___50 = t_cp___1;
#line 923
        t_cp___1 ++;
#line 923
        *tmp___50 = (u_char )(t_l >> 16);
#line 923
        tmp___51 = t_cp___1;
#line 923
        t_cp___1 ++;
#line 923
        *tmp___51 = (u_char )(t_l >> 8);
#line 923
        *t_cp___1 = (u_char )t_l;
#line 923
        cpp += 4;
#line 923
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 924
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 924
        t_s___1 = (u_int16_t )22;
#line 924
        t_cp___2 = cpp;
#line 924
        tmp___52 = t_cp___2;
#line 924
        t_cp___2 ++;
#line 924
        *tmp___52 = (u_char )((int )t_s___1 >> 8);
#line 924
        *t_cp___2 = (u_char )t_s___1;
#line 924
        cpp += 2;
#line 924
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 925
      tmp___53 = cpp;
#line 925
      cpp ++;
#line 925
      *tmp___53 = (u_char )0;
#line 926
      tmp___54 = cpp;
#line 926
      cpp ++;
#line 926
      *tmp___54 = (u_char )0;
      {
#line 927
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 927
        t_l___0 = ixfr_serial;
#line 927
        t_cp___3 = cpp;
#line 927
        tmp___55 = t_cp___3;
#line 927
        t_cp___3 ++;
#line 927
        *tmp___55 = (u_char )(t_l___0 >> 24);
#line 927
        tmp___56 = t_cp___3;
#line 927
        t_cp___3 ++;
#line 927
        *tmp___56 = (u_char )(t_l___0 >> 16);
#line 927
        tmp___57 = t_cp___3;
#line 927
        t_cp___3 ++;
#line 927
        *tmp___57 = (u_char )(t_l___0 >> 8);
#line 927
        *t_cp___3 = (u_char )t_l___0;
#line 927
        cpp += 4;
#line 927
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 928
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 928
        t_l___1 = (u_int32_t )57005;
#line 928
        t_cp___4 = cpp;
#line 928
        tmp___58 = t_cp___4;
#line 928
        t_cp___4 ++;
#line 928
        *tmp___58 = (u_char )(t_l___1 >> 24);
#line 928
        tmp___59 = t_cp___4;
#line 928
        t_cp___4 ++;
#line 928
        *tmp___59 = (u_char )(t_l___1 >> 16);
#line 928
        tmp___60 = t_cp___4;
#line 928
        t_cp___4 ++;
#line 928
        *tmp___60 = (u_char )(t_l___1 >> 8);
#line 928
        *t_cp___4 = (u_char )t_l___1;
#line 928
        cpp += 4;
#line 928
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 929
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 929
        t_l___2 = (u_int32_t )48879;
#line 929
        t_cp___5 = cpp;
#line 929
        tmp___61 = t_cp___5;
#line 929
        t_cp___5 ++;
#line 929
        *tmp___61 = (u_char )(t_l___2 >> 24);
#line 929
        tmp___62 = t_cp___5;
#line 929
        t_cp___5 ++;
#line 929
        *tmp___62 = (u_char )(t_l___2 >> 16);
#line 929
        tmp___63 = t_cp___5;
#line 929
        t_cp___5 ++;
#line 929
        *tmp___63 = (u_char )(t_l___2 >> 8);
#line 929
        *t_cp___5 = (u_char )t_l___2;
#line 929
        cpp += 4;
#line 929
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 930
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 930
        t_l___3 = (u_int32_t )43981;
#line 930
        t_cp___6 = cpp;
#line 930
        tmp___64 = t_cp___6;
#line 930
        t_cp___6 ++;
#line 930
        *tmp___64 = (u_char )(t_l___3 >> 24);
#line 930
        tmp___65 = t_cp___6;
#line 930
        t_cp___6 ++;
#line 930
        *tmp___65 = (u_char )(t_l___3 >> 16);
#line 930
        tmp___66 = t_cp___6;
#line 930
        t_cp___6 ++;
#line 930
        *tmp___66 = (u_char )(t_l___3 >> 8);
#line 930
        *t_cp___6 = (u_char )t_l___3;
#line 930
        cpp += 4;
#line 930
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 931
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 931
        t_l___4 = (u_int32_t )6006;
#line 931
        t_cp___7 = cpp;
#line 931
        tmp___67 = t_cp___7;
#line 931
        t_cp___7 ++;
#line 931
        *tmp___67 = (u_char )(t_l___4 >> 24);
#line 931
        tmp___68 = t_cp___7;
#line 931
        t_cp___7 ++;
#line 931
        *tmp___68 = (u_char )(t_l___4 >> 16);
#line 931
        tmp___69 = t_cp___7;
#line 931
        t_cp___7 ++;
#line 931
        *tmp___69 = (u_char )(t_l___4 >> 8);
#line 931
        *t_cp___7 = (u_char )t_l___4;
#line 931
        cpp += 4;
#line 931
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 932
      n = (int )(cpp - packet_.packet_);
#line 932
      bytes_out = n;
    }
#line 936
    if (n > 0) {
#line 936
      if ((res.options & 1075838976UL) != 0UL) {
        {
#line 938
        n = __res_nopt(& res, n, packet_.packet_, (int )sizeof(packet_.packet_), 4096);
#line 938
        bytes_out = n;
        }
      }
    }
#line 942
    eecode = 0;
#line 943
    if (res.pfcode & 256UL) {
      {
#line 944
      __fp_resstat((res_state const   )(& res), stdout);
      }
    }
    {
#line 945
    isc__gettimeofday(& start_time, (struct timezone *)((void *)0));
    }
#line 946
    if (keyfile) {
      {
#line 947
      n = __res_nsendsigned(& res, (u_char const   *)(packet_.packet_), n, & key,
                            answer___0.b, (int )sizeof(answer___0.b));
      }
    } else {
      {
#line 950
      n = __res_nsend(& res, (u_char const   *)(packet_.packet_), n, answer___0.b,
                      (int )sizeof(answer___0.b));
      }
    }
#line 952
    bytes_in = n;
#line 952
    if (bytes_in < 0) {
      {
#line 953
      fflush(stdout);
#line 954
      n = 0 - n;
      }
#line 955
      if (keyfile) {
        {
#line 956
        strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)";; res_nsendsigned");
        }
      } else {
        {
#line 958
        strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)";; res_nsend");
        }
      }
      {
#line 959
      perror((char const   *)(msg));
#line 960
      fflush(stderr);
      }
#line 962
      if (! dofile) {
#line 963
        if (eecode) {
          {
#line 964
          exit(eecode);
          }
        } else {
          {
#line 966
          exit(9);
          }
        }
      }
    }
    {
#line 969
    isc__gettimeofday(& end_time, (struct timezone *)((void *)0));
    }
#line 971
    if (res.pfcode & 1UL) {
      {
#line 974
      __res_getservers(& res, u___1, 3);
#line 975
      query_time = difftv(start_time, end_time);
#line 976
      printf((char const   */* __restrict  */)";; Total query time: ");
#line 977
      prnttime(query_time);
#line 978
      putchar('\n');
#line 979
      exectime = time((time_t *)((void *)0));
#line 980
      tmp___70 = __p_sockun(u___1[(res._flags & 240U) >> 4], ubuf, sizeof(ubuf));
#line 980
      printf((char const   */* __restrict  */)";; FROM: %s to SERVER: %s\n", myhostname,
             tmp___70);
#line 983
      tmp___71 = ctime((time_t const   *)(& exectime));
#line 983
      printf((char const   */* __restrict  */)";; WHEN: %s", tmp___71);
#line 984
      printf((char const   */* __restrict  */)";; MSG SIZE  sent: %d  rcvd: %d\n",
             bytes_out, bytes_in);
      }
    }
    {
#line 988
    fflush(stdout);
    }
#line 993
    if (pingstr[0]) {
#line 993
      if ((unsigned long )srv != (unsigned long )((void *)0)) {
        {
#line 994
        sprintf((char */* __restrict  */)(doping), (char const   */* __restrict  */)pingfmt,
                pingstr, srv, "tail");
#line 995
        system((char const   *)(doping));
        }
      }
    }
    {
#line 997
    putchar('\n');
#line 1003
    isc__gettimeofday(& tv2, (struct timezone *)((void *)0));
#line 1004
    delay = (int )(tv2.tv_sec - tv1.tv_sec);
    }
#line 1005
    if (delay < wait___0) {
      {
#line 1006
      sleep((unsigned int )(wait___0 - delay));
      }
    }
#line 1008
    tv1 = tv2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1010
  return (eecode);
}
}
#line 1015 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static void Usage(void) 
{ 


  {
  {
#line 1017
  fputs((char const   */* __restrict  */)"usage:  dig [@server] [domain] [q-type] [q-class] {q-opt} {d-opt} [%comment]\nwhere:\tserver,\n\tdomain\tare names in the Domain Name System\n\tq-class\tis one of (in,any,...) [default: in]\n\tq-type\tis one of (a,any,mx,ns,soa,hinfo,axfr,txt,...) [default: a]\n",
        (FILE */* __restrict  */)stderr);
#line 1024
  fputs((char const   */* __restrict  */)"\tq-opt\tis one of:\n\t\t-x dot-notation-address\t(shortcut to in-addr.arpa lookups)\n\t\t-f file\t\t\t(batch mode input file name)\n\t\t-T time\t\t\t(batch mode time delay, per query)\n\t\t-p port\t\t\t(nameserver is on this port) [53]\n\t\t-b addr[:port]\t\t(bind AXFR to this tcp address) [*]\n\t\t-P[ping-string]\t\t(see man page)\n\t\t-t query-type\t\t(synonym for q-type)\n\t\t-c query-class\t\t(synonym for q-class)\n\t\t-k keydir:keyname\t(sign the query with this TSIG key)\n\t\t-envsav,-envset\t\t(see man page)\n\t\t-[no]stick\t\t(see man page)\n",
        (FILE */* __restrict  */)stderr);
#line 1038
  fputs((char const   */* __restrict  */)"\td-opt\tis of the form ``+keyword=value\'\' where keyword is one of:\n\t\t[no]debug [no]d2 [no]recurse retry=# time=# [no]ko [no]vc\n\t\t[no]defname [no]search domain=NAME [no]ignore [no]primary\n\t\t[no]aaonly [no]cmd [no]stats [no]Header [no]header [no]trunc\n\t\t[no]ttlid [no]cl [no]qr [no]reply [no]ques [no]answer\n\t\t[no]author [no]addit [no]dnssec pfdef pfmin\n\t\tpfset=# pfand=# pfor=#\n",
        (FILE */* __restrict  */)stderr);
#line 1047
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"notes:\tdefname and search don\'t work; use fully-qualified names.\n\tthis is DiG version %s (libbind %d)\n\t$Id: dig8.c,v 1.4 2009/03/03 23:49:07 tbox Exp $\n",
          "8.4", 20090302);
  }
#line 1051
  return;
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static int setopt(char const   *string ) 
{ 
  char option[256] ;
  char *ptr ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;

  {
  {
#line 1058
  i = pickString(string, option, sizeof(option));
  }
#line 1059
  if (i == 0) {
    {
#line 1060
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";*** Invalid option: %s\n",
            string);
#line 1065
    exit(9);
    }
  }
  {
#line 1068
  tmp___57 = strncmp((char const   *)(option), "aa", (size_t )2);
  }
#line 1068
  if (tmp___57 == 0) {
#line 1069
    res.options |= 4UL;
  } else {
    {
#line 1070
    tmp___56 = strncmp((char const   *)(option), "noaa", (size_t )4);
    }
#line 1070
    if (tmp___56 == 0) {
#line 1071
      res.options &= 0xfffffffffffffffbUL;
    } else {
      {
#line 1072
      tmp___55 = strncmp((char const   *)(option), "deb", (size_t )3);
      }
#line 1072
      if (tmp___55 == 0) {
#line 1073
        res.options |= 2UL;
      } else {
        {
#line 1074
        tmp___54 = strncmp((char const   *)(option), "nodeb", (size_t )5);
        }
#line 1074
        if (tmp___54 == 0) {
#line 1075
          res.options &= 0xffffffffffbffffdUL;
        } else {
          {
#line 1076
          tmp___53 = strncmp((char const   *)(option), "ko", (size_t )2);
          }
#line 1076
          if (tmp___53 == 0) {
#line 1077
            res.options |= 264UL;
          } else {
            {
#line 1078
            tmp___52 = strncmp((char const   *)(option), "noko", (size_t )4);
            }
#line 1078
            if (tmp___52 == 0) {
#line 1079
              res.options &= 0xfffffffffffffeffUL;
            } else {
              {
#line 1080
              tmp___51 = strncmp((char const   *)(option), "d2", (size_t )2);
              }
#line 1080
              if (tmp___51 == 0) {
#line 1081
                res.options |= 4194306UL;
              } else {
                {
#line 1082
                tmp___50 = strncmp((char const   *)(option), "nod2", (size_t )4);
                }
#line 1082
                if (tmp___50 == 0) {
#line 1083
                  res.options &= 0xffffffffffbfffffUL;
                } else {
                  {
#line 1084
                  tmp___49 = strncmp((char const   *)(option), "def", (size_t )3);
                  }
#line 1084
                  if (tmp___49 == 0) {
#line 1085
                    res.options |= 128UL;
                  } else {
                    {
#line 1086
                    tmp___48 = strncmp((char const   *)(option), "nodef", (size_t )5);
                    }
#line 1086
                    if (tmp___48 == 0) {
#line 1087
                      res.options &= 0xffffffffffffff7fUL;
                    } else {
                      {
#line 1088
                      tmp___47 = strncmp((char const   *)(option), "dn", (size_t )2);
                      }
#line 1088
                      if (tmp___47 == 0) {
#line 1089
                        res.options |= 2097152UL;
                      } else {
                        {
#line 1090
                        tmp___46 = strncmp((char const   *)(option), "nodn", (size_t )4);
                        }
#line 1090
                        if (tmp___46 == 0) {
#line 1091
                          res.options &= 0xffffffffffdfffffUL;
                        } else {
                          {
#line 1092
                          tmp___45 = strncmp((char const   *)(option), "sea", (size_t )3);
                          }
#line 1092
                          if (tmp___45 == 0) {
#line 1093
                            res.options |= 512UL;
                          } else {
                            {
#line 1094
                            tmp___44 = strncmp((char const   *)(option), "nosea",
                                               (size_t )5);
                            }
#line 1094
                            if (tmp___44 == 0) {
#line 1095
                              res.options &= 0xfffffffffffffdffUL;
                            } else {
                              {
#line 1096
                              tmp___43 = strncmp((char const   *)(option), "do", (size_t )2);
                              }
#line 1096
                              if (tmp___43 == 0) {
                                {
#line 1097
                                ptr = strchr((char const   *)(option), '=');
                                }
#line 1098
                                if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                  {
#line 1099
                                  ptr ++;
#line 1099
                                  i = pickString((char const   *)ptr, res.defdname,
                                                 sizeof(res.defdname));
                                  }
#line 1100
                                  if (i == 0) {
                                    {
#line 1103
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Invalid domain: %s\n",
                                            ptr);
#line 1104
                                    exit(9);
                                    }
                                  }
                                }
                              } else {
                                {
#line 1107
                                tmp___42 = strncmp((char const   *)(option), "ti",
                                                   (size_t )2);
                                }
#line 1107
                                if (tmp___42 == 0) {
                                  {
#line 1108
                                  ptr = strchr((char const   *)(option), '=');
                                  }
#line 1109
                                  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                    {
#line 1110
                                    ptr ++;
#line 1110
                                    sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"%d",
                                           & res.retrans);
                                    }
                                  }
                                } else {
                                  {
#line 1111
                                  tmp___41 = strncmp((char const   *)(option), "ret",
                                                     (size_t )3);
                                  }
#line 1111
                                  if (tmp___41 == 0) {
                                    {
#line 1112
                                    ptr = strchr((char const   *)(option), '=');
                                    }
#line 1113
                                    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                      {
#line 1114
                                      ptr ++;
#line 1114
                                      sscanf((char const   */* __restrict  */)ptr,
                                             (char const   */* __restrict  */)"%d",
                                             & res.retry);
                                      }
                                    }
                                  } else {
                                    {
#line 1115
                                    tmp___40 = strncmp((char const   *)(option), "i",
                                                       (size_t )1);
                                    }
#line 1115
                                    if (tmp___40 == 0) {
#line 1116
                                      res.options |= 32UL;
                                    } else {
                                      {
#line 1117
                                      tmp___39 = strncmp((char const   *)(option),
                                                         "noi", (size_t )3);
                                      }
#line 1117
                                      if (tmp___39 == 0) {
#line 1118
                                        res.options &= 0xffffffffffffffdfUL;
                                      } else {
                                        {
#line 1119
                                        tmp___38 = strncmp((char const   *)(option),
                                                           "pr", (size_t )2);
                                        }
#line 1119
                                        if (tmp___38 == 0) {
#line 1120
                                          res.options |= 16UL;
                                        } else {
                                          {
#line 1121
                                          tmp___37 = strncmp((char const   *)(option),
                                                             "nop", (size_t )3);
                                          }
#line 1121
                                          if (tmp___37 == 0) {
#line 1122
                                            res.options &= 0xffffffffffffffefUL;
                                          } else {
                                            {
#line 1123
                                            tmp___36 = strncmp((char const   *)(option),
                                                               "rec", (size_t )3);
                                            }
#line 1123
                                            if (tmp___36 == 0) {
#line 1124
                                              res.options |= 64UL;
                                            } else {
                                              {
#line 1125
                                              tmp___35 = strncmp((char const   *)(option),
                                                                 "norec", (size_t )5);
                                              }
#line 1125
                                              if (tmp___35 == 0) {
#line 1126
                                                res.options &= 0xffffffffffffffbfUL;
                                              } else {
                                                {
#line 1127
                                                tmp___34 = strncmp((char const   *)(option),
                                                                   "v", (size_t )1);
                                                }
#line 1127
                                                if (tmp___34 == 0) {
#line 1128
                                                  res.options |= 8UL;
                                                } else {
                                                  {
#line 1129
                                                  tmp___33 = strncmp((char const   *)(option),
                                                                     "nov", (size_t )3);
                                                  }
#line 1129
                                                  if (tmp___33 == 0) {
#line 1130
                                                    res.options &= 0xfffffffffffffff7UL;
                                                  } else {
                                                    {
#line 1131
                                                    tmp___32 = strncmp((char const   *)(option),
                                                                       "pfset", (size_t )5);
                                                    }
#line 1131
                                                    if (tmp___32 == 0) {
                                                      {
#line 1132
                                                      ptr = strchr((char const   *)(option),
                                                                   '=');
                                                      }
#line 1133
                                                      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                                        {
#line 1134
                                                        ptr ++;
#line 1134
                                                        tmp = xstrtonum(ptr);
#line 1134
                                                        res.pfcode = (u_long )tmp;
                                                        }
                                                      }
                                                    } else {
                                                      {
#line 1135
                                                      tmp___31 = strncmp((char const   *)(option),
                                                                         "pfand",
                                                                         (size_t )5);
                                                      }
#line 1135
                                                      if (tmp___31 == 0) {
                                                        {
#line 1136
                                                        ptr = strchr((char const   *)(option),
                                                                     '=');
                                                        }
#line 1137
                                                        if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                                          {
#line 1138
                                                          ptr ++;
#line 1138
                                                          tmp___0 = xstrtonum(ptr);
#line 1138
                                                          res.pfcode &= (unsigned long )tmp___0;
                                                          }
                                                        }
                                                      } else {
                                                        {
#line 1139
                                                        tmp___30 = strncmp((char const   *)(option),
                                                                           "pfor",
                                                                           (size_t )4);
                                                        }
#line 1139
                                                        if (tmp___30 == 0) {
                                                          {
#line 1140
                                                          ptr = strchr((char const   *)(option),
                                                                       '=');
                                                          }
#line 1141
                                                          if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                                            {
#line 1142
                                                            ptr ++;
#line 1142
                                                            tmp___1 = xstrtonum(ptr);
#line 1142
                                                            res.pfcode |= (unsigned long )tmp___1;
                                                            }
                                                          }
                                                        } else {
                                                          {
#line 1143
                                                          tmp___29 = strncmp((char const   *)(option),
                                                                             "pfmin",
                                                                             (size_t )5);
                                                          }
#line 1143
                                                          if (tmp___29 == 0) {
#line 1144
                                                            res.pfcode = (u_long )43312;
                                                          } else {
                                                            {
#line 1145
                                                            tmp___28 = strncmp((char const   *)(option),
                                                                               "pfdef",
                                                                               (size_t )5);
                                                            }
#line 1145
                                                            if (tmp___28 == 0) {
#line 1146
                                                              res.pfcode = (u_long )45049;
                                                            } else {
                                                              {
#line 1147
                                                              tmp___27 = strncmp((char const   *)(option),
                                                                                 "an",
                                                                                 (size_t )2);
                                                              }
#line 1147
                                                              if (tmp___27 == 0) {
#line 1148
                                                                res.pfcode |= 32UL;
                                                              } else {
                                                                {
#line 1149
                                                                tmp___26 = strncmp((char const   *)(option),
                                                                                   "noan",
                                                                                   (size_t )4);
                                                                }
#line 1149
                                                                if (tmp___26 == 0) {
#line 1150
                                                                  res.pfcode &= 0xffffffffffffffdfUL;
                                                                } else {
                                                                  {
#line 1151
                                                                  tmp___25 = strncmp((char const   *)(option),
                                                                                     "qu",
                                                                                     (size_t )2);
                                                                  }
#line 1151
                                                                  if (tmp___25 == 0) {
#line 1152
                                                                    res.pfcode |= 16UL;
                                                                  } else {
                                                                    {
#line 1153
                                                                    tmp___24 = strncmp((char const   *)(option),
                                                                                       "noqu",
                                                                                       (size_t )4);
                                                                    }
#line 1153
                                                                    if (tmp___24 == 0) {
#line 1154
                                                                      res.pfcode &= 0xffffffffffffffefUL;
                                                                    } else {
                                                                      {
#line 1155
                                                                      tmp___23 = strncmp((char const   *)(option),
                                                                                         "au",
                                                                                         (size_t )2);
                                                                      }
#line 1155
                                                                      if (tmp___23 == 0) {
#line 1156
                                                                        res.pfcode |= 64UL;
                                                                      } else {
                                                                        {
#line 1157
                                                                        tmp___22 = strncmp((char const   *)(option),
                                                                                           "noau",
                                                                                           (size_t )4);
                                                                        }
#line 1157
                                                                        if (tmp___22 == 0) {
#line 1158
                                                                          res.pfcode &= 0xffffffffffffffbfUL;
                                                                        } else {
                                                                          {
#line 1159
                                                                          tmp___21 = strncmp((char const   *)(option),
                                                                                             "ad",
                                                                                             (size_t )2);
                                                                          }
#line 1159
                                                                          if (tmp___21 == 0) {
#line 1160
                                                                            res.pfcode |= 128UL;
                                                                          } else {
                                                                            {
#line 1161
                                                                            tmp___20 = strncmp((char const   *)(option),
                                                                                               "noad",
                                                                                               (size_t )4);
                                                                            }
#line 1161
                                                                            if (tmp___20 == 0) {
#line 1162
                                                                              res.pfcode &= 0xffffffffffffff7fUL;
                                                                            } else {
                                                                              {
#line 1163
                                                                              tmp___19 = strncmp((char const   *)(option),
                                                                                                 "tt",
                                                                                                 (size_t )2);
                                                                              }
#line 1163
                                                                              if (tmp___19 == 0) {
#line 1164
                                                                                res.pfcode |= 1024UL;
                                                                              } else {
                                                                                {
#line 1165
                                                                                tmp___18 = strncmp((char const   *)(option),
                                                                                                   "nott",
                                                                                                   (size_t )4);
                                                                                }
#line 1165
                                                                                if (tmp___18 == 0) {
#line 1166
                                                                                  res.pfcode &= 0xfffffffffffffbffUL;
                                                                                } else {
                                                                                  {
#line 1167
                                                                                  tmp___17 = strncmp((char const   *)(option),
                                                                                                     "tr",
                                                                                                     (size_t )2);
                                                                                  }
#line 1167
                                                                                  if (tmp___17 == 0) {
#line 1168
                                                                                    res.pfcode |= 32768UL;
                                                                                  } else {
                                                                                    {
#line 1169
                                                                                    tmp___16 = strncmp((char const   *)(option),
                                                                                                       "notr",
                                                                                                       (size_t )4);
                                                                                    }
#line 1169
                                                                                    if (tmp___16 == 0) {
#line 1170
                                                                                      res.pfcode &= 0xffffffffffff7fffUL;
                                                                                    } else {
                                                                                      {
#line 1171
                                                                                      tmp___15 = strncmp((char const   *)(option),
                                                                                                         "he",
                                                                                                         (size_t )2);
                                                                                      }
#line 1171
                                                                                      if (tmp___15 == 0) {
#line 1172
                                                                                        res.pfcode |= 512UL;
                                                                                      } else {
                                                                                        {
#line 1173
                                                                                        tmp___14 = strncmp((char const   *)(option),
                                                                                                           "nohe",
                                                                                                           (size_t )4);
                                                                                        }
#line 1173
                                                                                        if (tmp___14 == 0) {
#line 1174
                                                                                          res.pfcode &= 0xfffffffffffffdffUL;
                                                                                        } else {
                                                                                          {
#line 1175
                                                                                          tmp___13 = strncmp((char const   *)(option),
                                                                                                             "H",
                                                                                                             (size_t )1);
                                                                                          }
#line 1175
                                                                                          if (tmp___13 == 0) {
#line 1176
                                                                                            res.pfcode |= 2048UL;
                                                                                          } else {
                                                                                            {
#line 1177
                                                                                            tmp___12 = strncmp((char const   *)(option),
                                                                                                               "noH",
                                                                                                               (size_t )3);
                                                                                            }
#line 1177
                                                                                            if (tmp___12 == 0) {
#line 1178
                                                                                              res.pfcode &= 0xfffffffffffff7ffUL;
                                                                                            } else {
                                                                                              {
#line 1179
                                                                                              tmp___11 = strncmp((char const   *)(option),
                                                                                                                 "qr",
                                                                                                                 (size_t )2);
                                                                                              }
#line 1179
                                                                                              if (tmp___11 == 0) {
#line 1180
                                                                                                res.pfcode |= 4096UL;
                                                                                              } else {
                                                                                                {
#line 1181
                                                                                                tmp___10 = strncmp((char const   *)(option),
                                                                                                                   "noqr",
                                                                                                                   (size_t )4);
                                                                                                }
#line 1181
                                                                                                if (tmp___10 == 0) {
#line 1182
                                                                                                  res.pfcode &= 0xffffffffffffefffUL;
                                                                                                } else {
                                                                                                  {
#line 1183
                                                                                                  tmp___9 = strncmp((char const   *)(option),
                                                                                                                    "rep",
                                                                                                                    (size_t )3);
                                                                                                  }
#line 1183
                                                                                                  if (tmp___9 == 0) {
#line 1184
                                                                                                    res.pfcode |= 8192UL;
                                                                                                  } else {
                                                                                                    {
#line 1185
                                                                                                    tmp___8 = strncmp((char const   *)(option),
                                                                                                                      "norep",
                                                                                                                      (size_t )5);
                                                                                                    }
#line 1185
                                                                                                    if (tmp___8 == 0) {
#line 1186
                                                                                                      res.pfcode &= 0xffffffffffffdfffUL;
                                                                                                    } else {
                                                                                                      {
#line 1187
                                                                                                      tmp___7 = strncmp((char const   *)(option),
                                                                                                                        "cm",
                                                                                                                        (size_t )2);
                                                                                                      }
#line 1187
                                                                                                      if (tmp___7 == 0) {
#line 1188
                                                                                                        res.pfcode |= 8UL;
                                                                                                      } else {
                                                                                                        {
#line 1189
                                                                                                        tmp___6 = strncmp((char const   *)(option),
                                                                                                                          "nocm",
                                                                                                                          (size_t )4);
                                                                                                        }
#line 1189
                                                                                                        if (tmp___6 == 0) {
#line 1190
                                                                                                          res.pfcode &= 0xfffffffffffffff7UL;
                                                                                                        } else {
                                                                                                          {
#line 1191
                                                                                                          tmp___5 = strncmp((char const   *)(option),
                                                                                                                            "cl",
                                                                                                                            (size_t )2);
                                                                                                          }
#line 1191
                                                                                                          if (tmp___5 == 0) {
#line 1192
                                                                                                            res.pfcode |= 4UL;
                                                                                                          } else {
                                                                                                            {
#line 1193
                                                                                                            tmp___4 = strncmp((char const   *)(option),
                                                                                                                              "nocl",
                                                                                                                              (size_t )4);
                                                                                                            }
#line 1193
                                                                                                            if (tmp___4 == 0) {
#line 1194
                                                                                                              res.pfcode &= 0xfffffffffffffffbUL;
                                                                                                            } else {
                                                                                                              {
#line 1195
                                                                                                              tmp___3 = strncmp((char const   *)(option),
                                                                                                                                "st",
                                                                                                                                (size_t )2);
                                                                                                              }
#line 1195
                                                                                                              if (tmp___3 == 0) {
#line 1196
                                                                                                                res.pfcode |= 1UL;
                                                                                                              } else {
                                                                                                                {
#line 1197
                                                                                                                tmp___2 = strncmp((char const   *)(option),
                                                                                                                                  "nost",
                                                                                                                                  (size_t )4);
                                                                                                                }
#line 1197
                                                                                                                if (tmp___2 == 0) {
#line 1198
                                                                                                                  res.pfcode &= 0xfffffffffffffffeUL;
                                                                                                                } else {
                                                                                                                  {
#line 1200
                                                                                                                  fprintf((FILE */* __restrict  */)stderr,
                                                                                                                          (char const   */* __restrict  */)"; *** Invalid option: %s\n",
                                                                                                                          option);
                                                                                                                  }
#line 1201
                                                                                                                  return (-3);
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1203
  res_re_init();
  }
#line 1204
  return (0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static char localdomain[12]  = 
#line 1212
  {      (char )'L',      (char )'O',      (char )'C',      (char )'A', 
        (char )'L',      (char )'D',      (char )'O',      (char )'M', 
        (char )'A',      (char )'I',      (char )'N',      (char )'\000'};
#line 1210 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static void res_re_init(void) 
{ 
  u_long pfcode ;
  u_long options ;
  unsigned int ndots ;
  int retrans ;
  int retry ;
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1213
  pfcode = res.pfcode;
#line 1213
  options = res.options;
#line 1214
  ndots = res.ndots;
#line 1215
  retrans = res.retrans;
#line 1215
  retry = res.retry;
#line 1221
  tmp = strlen((char const   *)(res.defdname));
#line 1221
  tmp___0 = malloc((sizeof(localdomain) + tmp) + 10UL);
#line 1221
  buf = (char *)tmp___0;
#line 1222
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s=%s",
          localdomain, res.defdname);
#line 1223
  putenv(buf);
#line 1224
  __res_ninit(& res);
#line 1225
  res.pfcode = pfcode;
#line 1226
  res.options = options;
#line 1227
  res.ndots = ndots;
#line 1228
  res.retrans = retrans;
#line 1229
  res.retry = retry;
  }
#line 1230
  return;
}
}
#line 1235 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static int xstrtonum(char *p ) 
{ 
  int v ;
  int i ;
  int b ;
  int flag ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1237
  v = 0;
#line 1239
  b = 10;
#line 1240
  flag = 0;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! ((int )*p != 0)) {
#line 1241
      goto while_break;
    }
#line 1242
    tmp = flag;
#line 1242
    flag ++;
#line 1242
    if (! tmp) {
#line 1243
      if ((int )*p == 48) {
#line 1244
        b = 8;
#line 1244
        p ++;
#line 1245
        goto while_continue;
      }
    }
    {
#line 1247
    tmp___1 = __ctype_b_loc();
    }
#line 1247
    if ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 256) {
      {
#line 1248
      tmp___0 = tolower((int )*p);
#line 1248
      *p = (char )tmp___0;
      }
    }
#line 1249
    if ((int )*p == 120) {
#line 1250
      b = 16;
#line 1250
      p ++;
#line 1251
      goto while_continue;
    }
    {
#line 1253
    tmp___3 = __ctype_b_loc();
    }
#line 1253
    if ((int const   )*(*tmp___3 + (int )((unsigned char )*p)) & 2048) {
#line 1254
      i = (int )*p - 48;
    } else {
      {
#line 1255
      tmp___2 = __ctype_b_loc();
      }
#line 1255
      if ((int const   )*(*tmp___2 + (int )((unsigned char )*p)) & 4096) {
#line 1256
        i = ((int )*p - 97) + 10;
      } else {
        {
#line 1258
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"; *** Bad char in numeric string..ignored\n");
#line 1260
        i = -1;
        }
      }
    }
#line 1262
    if (i >= b) {
      {
#line 1263
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"; *** Bad char in numeric string..ignored\n");
#line 1265
      i = -1;
      }
    }
#line 1267
    if (i >= 0) {
#line 1268
      v = v * b + i;
    }
#line 1269
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  return (v);
}
}
#line 1283 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static u_char *answer  =    (u_char *)((void *)0);
#line 1284 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static int answerLen  =    0;
#line 1279 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static int printZone(ns_type xfr , char const   *zone , struct sockaddr_in  const  *sin ,
                     ns_tsig_key *key ) 
{ 
  querybuf buf ;
  int msglen ;
  int amtToRead ;
  int numRead ;
  int result ;
  int sockFD ;
  int len ;
  int count ;
  int type ;
  int rlen ;
  int done ;
  int n ;
  int numAnswers ;
  int numRecords ;
  int soacnt ;
  u_char *cp ;
  u_char tmp[2] ;
  char dname[2][1025] ;
  enum __anonenum_error_76 error ;
  pid_t zpid ;
  u_char *newmsg ;
  int newmsglen ;
  ns_tcp_tsig_state tsig_state ;
  int tsig_ret ;
  int tsig_required ;
  int tsig_present ;
  char const   *tmp___0 ;
  DST_KEY *dstkey ;
  int bufsize ;
  int siglen ;
  u_char sig[64] ;
  int ret ;
  void *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int e ;
  int *tmp___7 ;
  int e___0 ;
  int *tmp___8 ;
  char *tmp___9 ;
  uint16_t tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int e___1 ;
  int *tmp___13 ;
  int tmp___14 ;
  int e___2 ;
  int *tmp___15 ;
  char buf___0[80] ;
  char *tmp___16 ;
  uint16_t tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int e___3 ;
  int *tmp___20 ;
  int tmp___21 ;
  int e___4 ;
  int *tmp___22 ;
  ssize_t tmp___23 ;
  ssize_t tmp___24 ;
  int z[2] ;
  int e___5 ;
  int *tmp___25 ;
  int tmp___26 ;
  int e___6 ;
  int *tmp___27 ;
  ssize_t tmp___28 ;
  u_int tmp___29 ;
  void *tmp___30 ;
  ssize_t tmp___31 ;
  uint16_t tmp___32 ;
  uint16_t tmp___33 ;
  uint16_t tmp___34 ;
  register u_char const   *t_cp ;
  register u_char const   *t_cp___0 ;
  int tmp___35 ;
  int tmp___36 ;
  u_char *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  pid_t pid ;
  int status ;
  int e___7 ;
  int *tmp___40 ;
  int tmp___41 ;
  union __anonunion_79 __constr_expr_1 ;
  union __anonunion_81 __constr_expr_3 ;
  int tmp___42 ;
  union __anonunion_82 __constr_expr_4 ;
  union __anonunion_83 __constr_expr_5 ;

  {
#line 1294
  zpid = -1;
  {
#line 1302
  if ((unsigned int )xfr == 256U) {
#line 1302
    goto case_256;
  }
#line 1302
  if ((unsigned int )xfr == 252U) {
#line 1302
    goto case_256;
  }
#line 1304
  goto switch_default;
  case_256: /* CIL Label */ 
  case_252: /* CIL Label */ 
#line 1303
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1305
  tmp___0 = __p_type((int )xfr);
#line 1305
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";; %s - transfer type not supported\n",
          tmp___0);
  }
#line 1307
  return (-3);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1313
  msglen = __res_nmkquery(& res, 0, zone, queryClass, 252, (u_char const   *)((void *)0),
                          0, (u_char const   *)0, buf.qb2, (int )sizeof(buf));
  }
#line 1316
  if (msglen < 0) {
#line 1317
    if (res.options & 2UL) {
      {
#line 1318
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";; res_nmkquery failed\n");
      }
    }
#line 1319
    return (-3);
  }
#line 1325
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 1326
    newmsg = (u_char *)(& buf);
#line 1327
    newmsglen = msglen;
  } else {
    {
#line 1337
    __dst_init();
#line 1339
    bufsize = msglen + 1024;
#line 1340
    tmp___1 = malloc((size_t )bufsize);
#line 1340
    newmsg = (u_char *)tmp___1;
    }
#line 1341
    if ((unsigned long )newmsg == (unsigned long )((void *)0)) {
      {
#line 1342
      tmp___2 = __errno_location();
#line 1342
      *tmp___2 = 12;
      }
#line 1343
      return (-1);
    }
    {
#line 1345
    memcpy((void */* __restrict  */)newmsg, (void const   */* __restrict  */)((u_char *)(& buf)),
           (size_t )msglen);
#line 1346
    newmsglen = msglen;
#line 1348
    tmp___3 = strcmp((char const   *)(key->alg), "HMAC-MD5.SIG-ALG.REG.INT");
    }
#line 1348
    if (tmp___3 != 0) {
#line 1349
      dstkey = (DST_KEY *)((void *)0);
    } else {
      {
#line 1351
      dstkey = __dst_buffer_to_key((char const   *)(key->name), (int const   )157,
                                   (int const   )16384, (int const   )255, (u_char const   *)key->data,
                                   (int const   )key->len);
      }
    }
#line 1355
    if ((unsigned long )dstkey == (unsigned long )((void *)0)) {
      {
#line 1356
      tmp___4 = __errno_location();
#line 1356
      *tmp___4 = 22;
      }
#line 1357
      if (key) {
        {
#line 1358
        free((void *)newmsg);
        }
      }
#line 1359
      return (-1);
    }
    {
#line 1362
    siglen = (int )sizeof(sig);
#line 1364
    ret = __ns_sign(newmsg, & newmsglen, bufsize, 0, (void *)dstkey, (u_char const   *)((void *)0),
                    0, sig, & siglen, (time_t )0);
    }
#line 1366
    if (ret < 0) {
#line 1367
      if (key) {
        {
#line 1368
        free((void *)newmsg);
        }
      }
#line 1369
      if (ret == -11) {
        {
#line 1370
        tmp___5 = __errno_location();
#line 1370
        *tmp___5 = 90;
        }
      } else
#line 1371
      if (ret == -1) {
        {
#line 1372
        tmp___6 = __errno_location();
#line 1372
        *tmp___6 = 22;
        }
      }
#line 1373
      return (ret);
    }
    {
#line 1375
    __ns_verify_tcp_init((void *)dstkey, (u_char const   *)(sig), siglen, & tsig_state);
    }
  }
  {
#line 1381
  sockFD = socket((int )sin->sin_family, 1, 0);
  }
#line 1381
  if (sockFD < 0) {
    {
#line 1382
    tmp___7 = __errno_location();
#line 1382
    e = *tmp___7;
#line 1384
    perror(";; socket");
    }
#line 1385
    return (e);
  }
  {
#line 1389
  if ((int const   )sin->sin_family == 2) {
#line 1389
    goto case_2;
  }
#line 1412
  if ((int const   )sin->sin_family == 10) {
#line 1412
    goto case_10;
  }
#line 1388
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1390
  tmp___12 = bind(sockFD, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& myaddress)),
                  (socklen_t )sizeof(myaddress));
  }
#line 1390
  if (tmp___12 < 0) {
    {
#line 1392
    tmp___8 = __errno_location();
#line 1392
    e___0 = *tmp___8;
#line 1394
    tmp___9 = strerror(e___0);
#line 1394
    tmp___10 = ntohs(myaddress.sin_port);
#line 1394
    tmp___11 = __inet_ntoa(myaddress.sin_addr);
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";; bind(%s port %u): %s\n",
            tmp___11, (int )tmp___10, tmp___9);
#line 1398
    close(sockFD);
#line 1399
    sockFD = -1;
    }
#line 1400
    return (e___0);
  }
  {
#line 1402
  tmp___14 = connect(sockFD, (struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)sin),
                     (socklen_t )sizeof(*sin));
  }
#line 1402
  if (tmp___14 < 0) {
    {
#line 1404
    tmp___13 = __errno_location();
#line 1404
    e___1 = *tmp___13;
#line 1406
    perror(";; connect");
#line 1407
    close(sockFD);
#line 1408
    sockFD = -1;
    }
#line 1409
    return (e___1);
  }
#line 1411
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 1413
  tmp___19 = bind(sockFD, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& myaddress6)),
                  (socklen_t )sizeof(myaddress6));
  }
#line 1413
  if (tmp___19 < 0) {
    {
#line 1415
    tmp___15 = __errno_location();
#line 1415
    e___2 = *tmp___15;
#line 1418
    tmp___16 = strerror(e___2);
#line 1418
    tmp___17 = ntohs(myaddress6.sin6_port);
#line 1418
    tmp___18 = __inet_ntop(10, (void const   *)(& myaddress6.sin6_addr), buf___0,
                           sizeof(buf___0));
#line 1418
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";; bind(%s port %u): %s\n",
            tmp___18, (int )tmp___17, tmp___16);
#line 1423
    close(sockFD);
#line 1424
    sockFD = -1;
    }
#line 1425
    return (e___2);
  }
  {
#line 1427
  tmp___21 = connect(sockFD, (struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)sin),
                     (socklen_t )sizeof(struct sockaddr_in6 ));
  }
#line 1427
  if (tmp___21 < 0) {
    {
#line 1429
    tmp___20 = __errno_location();
#line 1429
    e___3 = *tmp___20;
#line 1431
    perror(";; connect");
#line 1432
    close(sockFD);
#line 1433
    sockFD = -1;
    }
#line 1434
    return (e___3);
  }
#line 1436
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1443
  __ns_put16((u_int )newmsglen, tmp);
#line 1444
  tmp___23 = write(sockFD, (void const   *)((char *)(tmp)), (size_t )2);
  }
#line 1444
  if (tmp___23 != 2L) {
#line 1444
    goto _L;
  } else {
    {
#line 1444
    tmp___24 = write(sockFD, (void const   *)((char *)newmsg), (size_t )newmsglen);
    }
#line 1444
    if (tmp___24 != (ssize_t )newmsglen) {
      _L: /* CIL Label */ 
      {
#line 1446
      tmp___22 = __errno_location();
#line 1446
      e___4 = *tmp___22;
      }
#line 1447
      if (key) {
        {
#line 1448
        free((void *)newmsg);
        }
      }
      {
#line 1449
      perror(";; write");
#line 1450
      close(sockFD);
#line 1451
      sockFD = -1;
      }
#line 1452
      return (e___4);
    } else
#line 1453
    if (key) {
      {
#line 1454
      free((void *)newmsg);
      }
    }
  }
#line 1459
  if ((unsigned int )xfr == 256U) {
    {
#line 1463
    tmp___26 = pipe((int *)(z));
    }
#line 1463
    if (tmp___26 < 0) {
      {
#line 1464
      tmp___25 = __errno_location();
#line 1464
      e___5 = *tmp___25;
#line 1466
      perror(";; pipe");
#line 1467
      close(sockFD);
#line 1468
      sockFD = -1;
      }
#line 1469
      return (e___5);
    }
    {
#line 1471
    zpid = vfork();
    }
#line 1472
    if (zpid < 0) {
      {
#line 1473
      tmp___27 = __errno_location();
#line 1473
      e___6 = *tmp___27;
#line 1475
      perror(";; fork");
#line 1476
      close(sockFD);
#line 1477
      sockFD = -1;
      }
#line 1478
      return (e___6);
    } else
#line 1479
    if (zpid == 0) {
      {
#line 1481
      close(z[0]);
#line 1482
      dup2(sockFD, 0);
#line 1483
      close(sockFD);
#line 1484
      dup2(z[1], 1);
#line 1485
      close(z[1]);
#line 1486
      execlp("gzip", "gzip", "-d", "-v", (void *)0);
#line 1487
      perror(";; child: execlp(gunzip)");
#line 1488
      _exit(1);
      }
    }
    {
#line 1491
    close(z[1]);
#line 1492
    dup2(z[0], sockFD);
#line 1493
    close(z[0]);
    }
  }
#line 1495
  result = 0;
#line 1496
  numAnswers = 0;
#line 1497
  numRecords = 0;
#line 1498
  soacnt = 0;
#line 1499
  error = (enum __anonenum_error_76 )0;
#line 1500
  numRead = 0;
#line 1502
  dname[0][0] = (char )'\000';
#line 1503
  done = 0;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! (! done)) {
#line 1503
      goto while_break;
    }
#line 1508
    cp = tmp;
#line 1509
    amtToRead = 2;
    {
#line 1510
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1510
      if (amtToRead > 0) {
        {
#line 1510
        tmp___28 = read(sockFD, (void *)cp, (size_t )amtToRead);
#line 1510
        numRead = (int )tmp___28;
        }
#line 1510
        if (! (numRead > 0)) {
#line 1510
          goto while_break___0;
        }
      } else {
#line 1510
        goto while_break___0;
      }
#line 1512
      cp += numRead;
#line 1513
      amtToRead -= numRead;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1515
    if (numRead <= 0) {
#line 1516
      error = (enum __anonenum_error_76 )1;
#line 1517
      goto while_break;
    }
    {
#line 1520
    tmp___29 = __ns_get16((u_char const   *)(tmp));
#line 1520
    len = (int )tmp___29;
    }
#line 1521
    if (len == 0) {
#line 1522
      goto while_break;
    }
#line 1528
    if (len > answerLen) {
#line 1529
      if (answerLen != 0) {
        {
#line 1530
        free((void *)answer);
        }
      }
      {
#line 1531
      answerLen = len;
#line 1532
      tmp___30 = malloc((size_t )answerLen);
#line 1532
      answer = (u_char *)tmp___30;
      }
    }
#line 1539
    amtToRead = len;
#line 1540
    cp = answer;
    {
#line 1541
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1541
      if (amtToRead > 0) {
        {
#line 1541
        tmp___31 = read(sockFD, (void *)cp, (size_t )amtToRead);
#line 1541
        numRead = (int )tmp___31;
        }
#line 1541
        if (! (numRead > 0)) {
#line 1541
          goto while_break___1;
        }
      } else {
#line 1541
        goto while_break___1;
      }
#line 1543
      cp += numRead;
#line 1544
      amtToRead -= numRead;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1546
    if (numRead <= 0) {
#line 1547
      error = (enum __anonenum_error_76 )2;
#line 1548
      goto while_break;
    }
    {
#line 1551
    result = print_axfr(stdout, (u_char const   *)answer, (size_t )len);
    }
#line 1552
    if (result != 0) {
#line 1553
      error = (enum __anonenum_error_76 )3;
#line 1554
      goto while_break;
    }
    {
#line 1556
    tmp___32 = htons((uint16_t )((HEADER *)answer)->ancount);
#line 1556
    numRecords += (int )tmp___32;
#line 1557
    numAnswers ++;
#line 1560
    cp = answer + 12;
#line 1562
    tmp___33 = ntohs((uint16_t )((HEADER *)answer)->qdcount);
#line 1562
    count = (int )tmp___33;
    }
    {
#line 1562
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1562
      if (! (count > 0)) {
#line 1562
        goto while_break___2;
      }
      {
#line 1565
      n = __dn_skipname((u_char const   *)cp, (u_char const   *)(answer + len));
      }
#line 1566
      if (n < 0) {
#line 1567
        error = (enum __anonenum_error_76 )3;
#line 1568
        done ++;
#line 1569
        goto while_break___2;
      }
#line 1571
      cp += n + 4;
#line 1572
      if ((unsigned long )cp > (unsigned long )(answer + len)) {
#line 1573
        error = (enum __anonenum_error_76 )3;
#line 1574
        done ++;
#line 1575
        goto while_break___2;
      }
#line 1562
      count --;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1579
    tmp___34 = ntohs((uint16_t )((HEADER *)answer)->ancount);
#line 1579
    count = (int )tmp___34;
    }
    {
#line 1579
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1579
      if (count > 0) {
#line 1579
        if (! (! done)) {
#line 1579
          goto while_break___3;
        }
      } else {
#line 1579
        goto while_break___3;
      }
      {
#line 1582
      n = __dn_expand((u_char const   *)answer, (u_char const   *)(answer + len),
                      (u_char const   *)cp, dname[soacnt], (int )sizeof(dname[0]));
      }
#line 1584
      if (n < 0) {
#line 1585
        error = (enum __anonenum_error_76 )3;
#line 1586
        done ++;
#line 1587
        goto while_break___3;
      }
#line 1589
      cp += n;
#line 1590
      if ((unsigned long )((cp + 6) + 4) > (unsigned long )(answer + len)) {
#line 1591
        error = (enum __anonenum_error_76 )3;
#line 1592
        done ++;
#line 1593
        goto while_break___3;
      }
      {
#line 1595
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1595
        t_cp = (u_char const   *)cp;
#line 1595
        type = ((int )((u_int16_t )*(t_cp + 0)) << 8) | (int )((u_int16_t )*(t_cp + 1));
#line 1595
        cp += 2;
#line 1595
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1596
      cp += 2;
#line 1597
      cp += 4;
      {
#line 1598
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1598
        t_cp___0 = (u_char const   *)cp;
#line 1598
        rlen = ((int )((u_int16_t )*(t_cp___0 + 0)) << 8) | (int )((u_int16_t )*(t_cp___0 + 1));
#line 1598
        cp += 2;
#line 1598
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1599
      cp += rlen;
#line 1600
      if ((unsigned long )cp > (unsigned long )(answer + len)) {
#line 1601
        error = (enum __anonenum_error_76 )3;
#line 1602
        done ++;
#line 1603
        goto while_break___3;
      }
#line 1605
      if (type == 6) {
#line 1605
        tmp___35 = soacnt;
#line 1605
        soacnt ++;
#line 1605
        if (tmp___35) {
          {
#line 1605
          tmp___36 = __ns_samename((char const   *)(dname[0]), (char const   *)(dname[1]));
          }
#line 1605
          if (tmp___36 == 1) {
#line 1607
            done ++;
#line 1608
            goto while_break___3;
          }
        }
      }
#line 1579
      count --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1616
    if (key) {
      {
#line 1617
      tmp___37 = __ns_find_tsig(answer, answer + len);
      }
#line 1617
      if ((unsigned long )tmp___37 != (unsigned long )((void *)0)) {
#line 1618
        tsig_present = 1;
      } else {
#line 1620
        tsig_present = 0;
      }
#line 1621
      if (numAnswers == 1) {
#line 1622
        tsig_required = 1;
      } else
#line 1621
      if (soacnt > 1) {
#line 1622
        tsig_required = 1;
      } else {
#line 1624
        tsig_required = 0;
      }
      {
#line 1625
      tsig_ret = __ns_verify_tcp(answer, & len, & tsig_state, tsig_required);
      }
#line 1627
      if (tsig_ret == 0) {
#line 1628
        if (tsig_present) {
          {
#line 1629
          printf((char const   */* __restrict  */)"; TSIG ok\n");
          }
        }
      } else {
        {
#line 1632
        printf((char const   */* __restrict  */)"; TSIG invalid\n");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1637
  if (numRecords != 1) {
#line 1637
    tmp___38 = "s";
  } else {
#line 1637
    tmp___38 = "";
  }
#line 1637
  if (numAnswers != 1) {
#line 1637
    tmp___39 = "s";
  } else {
#line 1637
    tmp___39 = "";
  }
  {
#line 1637
  printf((char const   */* __restrict  */)";; Received %d answer%s (%d record%s).\n",
         numAnswers, tmp___39, numRecords, tmp___38);
#line 1641
  close(sockFD);
#line 1642
  sockFD = -1;
  }
#line 1647
  if ((unsigned int )xfr == 256U) {
    {
#line 1649
    status = 0;
#line 1651
    pid = wait((union wait *)(& status));
    }
#line 1652
    if (pid < 0) {
      {
#line 1653
      tmp___40 = __errno_location();
#line 1653
      e___7 = *tmp___40;
#line 1655
      perror(";; wait");
      }
#line 1656
      return (e___7);
    }
#line 1658
    if (pid != zpid) {
      {
#line 1659
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)";; wrong pid (%lu != %lu)\n",
              (u_long )pid, (u_long )zpid);
      }
#line 1661
      return (-3);
    }
#line 1663
    __constr_expr_1.__in = status;
#line 1663
    if (__constr_expr_1.__i & 128) {
#line 1663
      tmp___41 = 't';
    } else {
#line 1663
      tmp___41 = 'f';
    }
#line 1663
    __constr_expr_4.__in = status;
#line 1663
    if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 1663
      __constr_expr_3.__in = status;
#line 1663
      tmp___42 = __constr_expr_3.__i & 127;
    } else {
#line 1663
      tmp___42 = 0;
    }
    {
#line 1663
    __constr_expr_5.__in = status;
#line 1663
    printf((char const   */* __restrict  */)";; pid %lu: exit %d, signal %d, core %c\n",
           (u_long )pid, (__constr_expr_5.__i & 65280) >> 8, tmp___42, tmp___41);
    }
  }
  {
#line 1670
  if ((unsigned int )error == 0U) {
#line 1670
    goto case_0;
  }
#line 1673
  if ((unsigned int )error == 1U) {
#line 1673
    goto case_1;
  }
#line 1676
  if ((unsigned int )error == 3U) {
#line 1676
    goto case_3;
  }
#line 1679
  if ((unsigned int )error == 2U) {
#line 1679
    goto case_2___0;
  }
#line 1682
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 1671
  return (0);
  case_1: /* CIL Label */ 
#line 1674
  return (90);
  case_3: /* CIL Label */ 
#line 1677
  return (result);
  case_2___0: /* CIL Label */ 
#line 1680
  return (90);
  switch_default___0: /* CIL Label */ 
#line 1683
  return (14);
  switch_break___1: /* CIL Label */ ;
  }
}
}
#line 1711 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static char origin[1025]  ;
#line 1711 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static char name_ctx[1025]  ;
#line 1687 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static int print_axfr(FILE *file , u_char const   *msg , size_t msglen ) 
{ 
  ns_msg handle ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *name ;
  char buf[2048] ;
  ns_rr rr ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 1691
  tmp___1 = __ns_initparse(msg, (int )msglen, & handle);
  }
#line 1691
  if (tmp___1 < 0) {
    {
#line 1692
    tmp = __errno_location();
#line 1692
    tmp___0 = strerror(*tmp);
#line 1692
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)";; ns_initparse: %s\n",
            tmp___0);
    }
#line 1693
    return (1);
  }
  {
#line 1695
  tmp___3 = __ns_msg_getflag(handle, 9);
  }
#line 1695
  if (tmp___3 != 0) {
    {
#line 1696
    tmp___2 = __ns_msg_getflag(handle, 9);
    }
#line 1696
    return (tmp___2);
  }
#line 1703
  if ((int )handle._counts[1] == 0) {
#line 1704
    return (-2);
  }
  {
#line 1710
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1716
    tmp___7 = __ns_parserr(& handle, (ns_sect )1, -1, & rr);
    }
#line 1716
    if (tmp___7) {
      {
#line 1717
      tmp___6 = __errno_location();
      }
#line 1717
      if (*tmp___6 != 19) {
        {
#line 1718
        tmp___4 = __errno_location();
#line 1718
        tmp___5 = strerror(*tmp___4);
#line 1718
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)";; ns_parserr: %s\n",
                tmp___5);
        }
#line 1720
        return (1);
      }
#line 1722
      goto while_break;
    }
#line 1724
    if ((int )rr.name[0] != 0) {
#line 1724
      name = (char const   *)(rr.name);
    } else {
#line 1724
      name = ".";
    }
#line 1725
    if ((int )origin[0] == 0) {
#line 1725
      if ((int const   )*(name + 0) != 0) {
        {
#line 1726
        tmp___8 = strcmp(name, ".");
        }
#line 1726
        if (tmp___8 != 0) {
          {
#line 1727
          strcpy((char */* __restrict  */)(origin), (char const   */* __restrict  */)name);
          }
        }
        {
#line 1728
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"$ORIGIN %s.\n",
                origin);
#line 1729
        tmp___9 = strcmp(name, ".");
        }
#line 1729
        if (tmp___9 == 0) {
          {
#line 1730
          strcpy((char */* __restrict  */)(origin), (char const   */* __restrict  */)name);
          }
        }
#line 1731
        if (res.pfcode & 32768UL) {
          {
#line 1732
          strcpy((char */* __restrict  */)(name_ctx), (char const   */* __restrict  */)"@");
          }
        }
      }
    }
#line 1734
    if (res.pfcode & 32768UL) {
#line 1734
      tmp___12 = origin;
    } else {
#line 1734
      tmp___12 = (char *)((void *)0);
    }
#line 1734
    if (res.pfcode & 32768UL) {
#line 1734
      tmp___13 = name_ctx;
    } else {
#line 1734
      tmp___13 = (char *)((void *)0);
    }
    {
#line 1734
    tmp___14 = __ns_sprintrr((ns_msg const   *)(& handle), (ns_rr const   *)(& rr),
                             (char const   *)tmp___13, (char const   *)tmp___12, buf,
                             sizeof(buf));
    }
#line 1734
    if (tmp___14 < 0) {
      {
#line 1738
      tmp___10 = __errno_location();
#line 1738
      tmp___11 = strerror(*tmp___10);
#line 1738
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)";; ns_sprintrr: %s\n",
              tmp___11);
      }
#line 1739
      return (1);
    }
    {
#line 1741
    strcpy((char */* __restrict  */)(name_ctx), (char const   */* __restrict  */)name);
#line 1742
    fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)file);
#line 1743
    fputc('\n', file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1745
  return (0);
}
}
#line 1750 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static struct timeval diff  ;
#line 1748 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static struct timeval difftv(struct timeval a , struct timeval b ) 
{ 


  {
#line 1752
  diff.tv_sec = b.tv_sec - a.tv_sec;
#line 1753
  diff.tv_usec = b.tv_usec - a.tv_usec;
#line 1753
  if (diff.tv_usec < 0L) {
#line 1754
    (diff.tv_sec) --;
#line 1755
    diff.tv_usec += 1000000L;
  }
#line 1757
  return (diff);
}
}
#line 1760 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static void prnttime(struct timeval t ) 
{ 


  {
  {
#line 1762
  printf((char const   */* __restrict  */)"%lu msec", (u_long )(t.tv_sec * 1000L + t.tv_usec / 1000L));
  }
#line 1763
  return;
}
}
#line 1769 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static void stackarg(char *l , char **y ) 
{ 
  int done ;
  char **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
#line 1771
  done = 0;
  {
#line 1773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1773
    if (! (! done)) {
#line 1773
      goto while_break;
    }
    {
#line 1776
    if ((int )*l == 32) {
#line 1776
      goto case_32;
    }
#line 1776
    if ((int )*l == 9) {
#line 1776
      goto case_32;
    }
#line 1780
    if ((int )*l == 10) {
#line 1780
      goto case_10;
    }
#line 1780
    if ((int )*l == 0) {
#line 1780
      goto case_10;
    }
#line 1784
    goto switch_default;
    case_32: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1777
    l ++;
#line 1778
    goto switch_break;
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1781
    done ++;
#line 1782
    *y = (char *)((void *)0);
#line 1783
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1785
    tmp = y;
#line 1785
    y ++;
#line 1785
    *tmp = l;
    {
#line 1786
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1786
      tmp___0 = __ctype_b_loc();
      }
#line 1786
      if ((int const   )*(*tmp___0 + (int )((unsigned char )*l)) & 8192) {
#line 1786
        goto while_break___0;
      }
#line 1787
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1788
    if ((int )*l == 10) {
#line 1789
      done ++;
    }
#line 1790
    tmp___1 = l;
#line 1790
    l ++;
#line 1790
    *tmp___1 = (char )'\000';
#line 1791
    *y = (char *)((void *)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1794
  return;
}
}
#line 1796 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/dig8.c"
static void reverse6(char *domain , struct in6_addr *in6 ) 
{ 


  {
  {
#line 1798
  sprintf((char */* __restrict  */)domain, (char const   */* __restrict  */)"%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa",
          (int )in6->__in6_u.__u6_addr8[15] & 15, ((int )in6->__in6_u.__u6_addr8[15] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[14] & 15, ((int )in6->__in6_u.__u6_addr8[14] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[13] & 15, ((int )in6->__in6_u.__u6_addr8[13] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[12] & 15, ((int )in6->__in6_u.__u6_addr8[12] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[11] & 15, ((int )in6->__in6_u.__u6_addr8[11] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[10] & 15, ((int )in6->__in6_u.__u6_addr8[10] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[9] & 15, ((int )in6->__in6_u.__u6_addr8[9] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[8] & 15, ((int )in6->__in6_u.__u6_addr8[8] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[7] & 15, ((int )in6->__in6_u.__u6_addr8[7] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[6] & 15, ((int )in6->__in6_u.__u6_addr8[6] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[5] & 15, ((int )in6->__in6_u.__u6_addr8[5] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[4] & 15, ((int )in6->__in6_u.__u6_addr8[4] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[3] & 15, ((int )in6->__in6_u.__u6_addr8[3] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[2] & 15, ((int )in6->__in6_u.__u6_addr8[2] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[1] & 15, ((int )in6->__in6_u.__u6_addr8[1] >> 4) & 15,
          (int )in6->__in6_u.__u6_addr8[0] & 15, ((int )in6->__in6_u.__u6_addr8[0] >> 4) & 15);
  }
#line 1815
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 349 "../include/resolv.h"
extern struct res_sym  const  __p_class_syms[] ;
#line 350
extern struct res_sym  const  __p_type_syms[] ;
#line 426
extern int __sym_ston(struct res_sym  const  * , char const   * , int * ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/res.h"
int matchString(char const   *format , char const   *src ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/subr.c"
int StringToClass(char *class , int dflt , FILE *errorfile ) 
{ 
  int result ;
  int success ;

  {
  {
#line 100
  result = __sym_ston(__p_class_syms, (char const   *)class, & success);
  }
#line 101
  if (success) {
#line 102
    return (result);
  }
#line 104
  if (errorfile) {
    {
#line 105
    fprintf((FILE */* __restrict  */)errorfile, (char const   */* __restrict  */)"unknown query class: %s\n",
            class);
    }
  }
#line 106
  return (dflt);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/subr.c"
int StringToType(char *type , int dflt , FILE *errorfile ) 
{ 
  int result ;
  int success ;

  {
  {
#line 129
  result = __sym_ston(__p_type_syms, (char const   *)type, & success);
  }
#line 130
  if (success) {
#line 131
    return (result);
  }
#line 133
  if (errorfile) {
    {
#line 134
    fprintf((FILE */* __restrict  */)errorfile, (char const   */* __restrict  */)"unknown query type: %s\n",
            type);
    }
  }
#line 135
  return (dflt);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/subr.c"
int pickString(char const   *src , char *dest , size_t dest_size ) 
{ 
  char const   *start ;
  char const   *end ;
  size_t sublen ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 161
  if (dest_size == 0UL) {
#line 162
    return (0);
  } else
#line 161
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 162
    return (0);
  } else
#line 161
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 162
    return (0);
  }
#line 164
  start = src;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    tmp = __ctype_b_loc();
    }
#line 164
    if (! ((int const   )*(*tmp + (int )((unsigned char )*start)) & 8192)) {
#line 164
      goto while_break;
    }
#line 164
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  end = start;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if ((int const   )*end != 0) {
      {
#line 167
      tmp___0 = __ctype_b_loc();
      }
#line 167
      if ((int const   )*(*tmp___0 + (int )((unsigned char )*end)) & 8192) {
#line 167
        goto while_break___0;
      }
    } else {
#line 167
      goto while_break___0;
    }
#line 167
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 170
  sublen = (size_t )(end - start);
#line 172
  if (sublen == 0UL) {
#line 173
    return (0);
  } else
#line 172
  if (sublen > dest_size - 1UL) {
#line 173
    return (0);
  }
  {
#line 175
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)start, sublen);
#line 177
  *(dest + sublen) = (char )'\000';
  }
#line 179
  return ((int )(end - src));
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/libbind-6.0/tests/subr.c"
int matchString(char const   *format , char const   *src ) 
{ 
  char const   *f ;
  char const   *s ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 205
  f = format;
#line 206
  s = src;
#line 208
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 209
    goto notfound;
  } else
#line 208
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 209
    goto notfound;
  }
  {
#line 211
  tmp___1 = __ctype_b_loc();
  }
#line 211
  if ((int const   )*(*tmp___1 + (int )((unsigned char )*f)) & 8192) {
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 212
      tmp = __ctype_b_loc();
      }
#line 212
      if (! ((int const   )*(*tmp + (int )((unsigned char )*f)) & 8192)) {
#line 212
        goto while_break;
      }
#line 213
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 214
      tmp___0 = __ctype_b_loc();
      }
#line 214
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 214
        goto while_break___0;
      }
#line 215
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 218
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 219
    tmp___5 = __ctype_b_loc();
    }
#line 219
    if ((int const   )*(*tmp___5 + (int )((unsigned char )*f)) & 8192) {
      {
#line 220
      tmp___2 = __ctype_b_loc();
      }
#line 220
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192)) {
#line 221
        goto notfound;
      }
      {
#line 222
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 222
        tmp___3 = __ctype_b_loc();
        }
#line 222
        if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 8192)) {
#line 222
          goto while_break___2;
        }
#line 223
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 227
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 227
        tmp___4 = __ctype_b_loc();
        }
#line 227
        if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*f)) & 8192)) {
#line 227
          goto while_break___3;
        }
#line 228
        f ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 229
    if ((int const   )*f == 0) {
#line 230
      return ((int )(s - src));
    } else
#line 231
    if ((int const   )*f != (int const   )*s) {
#line 232
      goto notfound;
    } else {
#line 234
      s ++;
#line 235
      f ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  notfound: 
#line 239
  return (0);
}
}
