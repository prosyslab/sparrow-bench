/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 18 "/usr/include/linux/serial.h"
struct serial_struct {
   int type ;
   int line ;
   unsigned int port ;
   int irq ;
   int flags ;
   int xmit_fifo_size ;
   int custom_divisor ;
   int baud_base ;
   unsigned short close_delay ;
   char io_type ;
   char reserved_char[1] ;
   int hub6 ;
   unsigned short closing_wait ;
   unsigned short closing_wait2 ;
   unsigned char *iomem_base ;
   unsigned short iomem_reg_shift ;
   unsigned int port_high ;
   unsigned long iomap_base ;
};
#line 68 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
struct _OFF_TIMER {
   int day ;
   long time ;
   void *pointer ;
};
#line 68 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
typedef struct _OFF_TIMER TIMER;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 31 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 78 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static char avr_device[11]  = 
#line 78 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
  {      (char )'/',      (char )'d',      (char )'e',      (char )'v', 
        (char )'/',      (char )'t',      (char )'t',      (char )'y', 
        (char )'S',      (char )'1',      (char )'\000'};
#line 81 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char config_file_location[22]  = 
#line 81
  {      (char )'/',      (char )'e',      (char )'t',      (char )'c', 
        (char )'/',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )'/',      (char )'a',      (char )'v',      (char )'r', 
        (char )'-',      (char )'e',      (char )'v',      (char )'t', 
        (char )'d',      (char )'\000'};
#line 83 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
TIMER *offTimer  =    (TIMER *)((void *)0);
#line 84 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
TIMER *onTimer  =    (TIMER *)((void *)0);
#line 85 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int FileDescriptor  =    0;
#line 86 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
time_t LastMelcoAccess  =    (time_t )0;
#line 87 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int TimerFlag  =    0;
#line 88 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
long ShutdownTimer  =    9999L;
#line 89 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char FirstTimeFlag  =    (char)1;
#line 90 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char FirstWarning  =    (char)1;
#line 91 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
long OffTime  =    -1L;
#line 92 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
long OnTime  =    -1L;
#line 95 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char CommandLineUpdate  =    (char)0;
#line 100 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int checkPercentage  =    90;
#line 101 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int last_day  ;
#line 102 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int refreshRate  =    40;
#line 103 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int holdCycle  =    3;
#line 104 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char debug  =    (char)0;
#line 105 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char pesterMessage  =    (char)0;
#line 106 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int fanFaultSeize  =    30;
#line 107 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int checkState  =    1;
#line 110 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char em_mode  =    (char)0;
#line 111 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char const   version[41]  = 
#line 111
  {      (char const   )'L',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'/', 
        (char const   )'K',      (char const   )'u',      (char const   )'r',      (char const   )'o', 
        (char const   )' ',      (char const   )'A',      (char const   )'V',      (char const   )'R', 
        (char const   )' ',      (char const   )'d',      (char const   )'a',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'$',      (char const   )'R',      (char const   )'e',      (char const   )'v', 
        (char const   )':',      (char const   )' ',      (char const   )'1',      (char const   )'4', 
        (char const   )'7',      (char const   )' ',      (char const   )'$',      (char const   )'\n', 
        (char const   )'\000'};
#line 112 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char rootPartition[10]  = {      (char )'\000'};
#line 114 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char workingPartition[10]  = {      (char )'\000'};
#line 115 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int diskCheckNumber  =    0;
#line 116 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char keepAlive  =    (char)91;
#line 117 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
char resetPresses  =    (char)0;
#line 118 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int diskUsed  =    0;
#line 121
static void usage(void) ;
#line 122
static int check_timer(char type ) ;
#line 123
static void termination_handler(int signum ) ;
#line 124
static int ( __attribute__((__always_inline__)) open_serial)(char *device ) ;
#line 132
static void parse_timer(char *buff ) ;
#line 136
static int close_serial(void) ;
#line 137
static void avr_evtd_main(void) ;
#line 138
static char ( __attribute__((__always_inline__)) check_disk)(void) ;
#line 139
static void set_avr_timer(char type ) ;
#line 140
static void parse_avr(char *buff ) ;
#line 141
static void GetTime(long timeNow , TIMER *pTimerLocate , long *time___0 , long defaultTime ) ;
#line 142
static int FindNextToday(long timeNow , TIMER *pTimer , long *time___0 ) ;
#line 143
static int FindNextDay(long timeNow , TIMER *pTimer , long *time___0 , long *offset ) ;
#line 144
static void destroyObject(TIMER *pTimer ) ;
#line 145
static void writeUART(char output_ ) ;
#line 146
static void errorReport(int errorNumber ) ;
#line 147
static void execute_command1(char cmd ) ;
#line 148
static void execute_command(char cmd , int cmd2 ) ;
#line 150 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void usage(void) 
{ 


  {
  {
#line 152
  printf((char const   */* __restrict  */)"Usage: avr-evtd [OPTION...]\n  -d DEVICE     listen for events on DEVICE\n  -i            display memory location for device used with -d\n  -c            run in the foreground, not as a daemon\n  -v            display program version\n  -h            display this usage notice\n");
#line 160
  exit(0);
  }
}
}
#line 164 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void writeUART(char output_ ) 
{ 
  char output[4] ;

  {
  {
#line 167
  output[3] = output_;
#line 167
  output[2] = output[3];
#line 167
  output[1] = output[2];
#line 167
  output[0] = output[1];
#line 168
  write(FileDescriptor, (void const   *)(output), (size_t )4);
  }
#line 169
  return;
}
}
#line 172 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static int ( __attribute__((__always_inline__)) open_serial)(char *device ) 
{ 
  struct termios newtio ;
  struct serial_struct serinfo ;

  {
  {
#line 181
  FileDescriptor = open((char const   *)device, 258);
  }
#line 183
  if (FileDescriptor < 0) {
    {
#line 184
    perror((char const   *)device);
    }
#line 185
    return (-1);
  }
#line 190
  if (2 == (int )debug) {
    {
#line 191
    ioctl(FileDescriptor, 21534UL, & serinfo);
    }
#line 192
    if (serinfo.iomem_base) {
      {
#line 193
      printf((char const   */* __restrict  */)"%p\n", serinfo.iomem_base);
      }
    } else {
      {
#line 195
      printf((char const   */* __restrict  */)"%X\n", serinfo.port);
      }
    }
#line 196
    return (0);
  }
  {
#line 200
  ioctl(FileDescriptor, 21515UL, 2);
#line 202
  memset((void *)(& newtio), 0, sizeof(newtio));
#line 203
  newtio.c_iflag = (tcflag_t )8;
#line 204
  newtio.c_oflag = (tcflag_t )1;
#line 209
  newtio.c_cflag = (tcflag_t )2557;
#line 213
  ioctl(FileDescriptor, 21506UL, & newtio);
#line 215
  ioctl(FileDescriptor, 21515UL, 2);
#line 219
  writeUART((char)65);
#line 220
  writeUART((char)70);
#line 221
  writeUART((char)74);
#line 222
  writeUART((char)62);
#line 225
  writeUART((char)88);
  }
#line 227
  return (0);
}
}
#line 230 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static int close_serial(void) 
{ 


  {
#line 232
  if (FileDescriptor != 0) {
    {
#line 237
    writeUART((char)75);
#line 240
    close(FileDescriptor);
#line 241
    FileDescriptor = 0;
    }
  }
  {
#line 245
  destroyObject(offTimer);
#line 246
  destroyObject(onTimer);
#line 249
  closelog();
  }
#line 250
  return (0);
}
}
#line 253 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void termination_handler(int signum ) 
{ 


  {
  {
#line 256
  if (signum == 15) {
#line 256
    goto case_15;
  }
#line 260
  if (signum == 18) {
#line 260
    goto case_18;
  }
#line 262
  goto switch_default;
  case_15: /* CIL Label */ 
  {
#line 257
  close_serial();
#line 258
  exit(0);
  }
#line 259
  goto switch_break;
  case_18: /* CIL Label */ 
#line 261
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 263
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 269 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void execute_command(char cmd , int cmd2 ) 
{ 
  char strEventScript[45] ;

  {
  {
#line 273
  sprintf((char */* __restrict  */)(strEventScript), (char const   */* __restrict  */)"/etc/avr-evtd/EventScript %c %s %d &",
          (int )cmd, avr_device, cmd2);
#line 275
  system((char const   *)(strEventScript));
  }
#line 276
  return;
}
}
#line 279 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void execute_command1(char cmd ) 
{ 


  {
  {
#line 281
  execute_command(cmd, 0);
  }
#line 282
  return;
}
}
#line 286 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void avr_evtd_main(void) 
{ 
  char buf[17] ;
  char cmd ;
  char PushedPowerFlag ;
  char PushedResetFlag ;
  char PressedPowerFlag ;
  char PressedResetFlag ;
  char currentStatus ;
  time_t tt_TimeIdle ;
  time_t tmp ;
  time_t tt_Power_Press ;
  time_t tt_fault_time ;
  time_t tt_LastShutdownPing ;
  time_t tt_TimeNow ;
  fd_set fReadFS ;
  struct timeval tt_TimeoutPoll ;
  int iResult ;
  int fan_fault ;
  long lTimerDiff ;
  char extraTime ;
  char diskFull ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 290
  PushedPowerFlag = (char)0;
#line 291
  PushedResetFlag = (char)0;
#line 292
  PressedPowerFlag = (char)0;
#line 293
  PressedResetFlag = (char)0;
#line 294
  currentStatus = (char)0;
#line 295
  tmp = time((time_t *)((void *)0));
#line 295
  tt_TimeIdle = tmp;
#line 296
  tt_Power_Press = tt_TimeIdle;
#line 303
  fan_fault = 0;
#line 305
  extraTime = (char)0;
#line 306
  diskFull = (char)0;
#line 309
  tt_fault_time = (time_t )0;
#line 310
  tt_LastShutdownPing = time((time_t *)((void *)0));
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! FileDescriptor) {
#line 313
      goto while_break;
    }
#line 314
    tt_TimeoutPoll.tv_usec = (__suseconds_t )0;
#line 315
    iResult = refreshRate;
#line 319
    if (checkState > 0) {
#line 320
      iResult = 2;
    } else
#line 325
    if (PushedPowerFlag) {
#line 327
      tt_TimeoutPoll.tv_usec = (__suseconds_t )250;
#line 328
      iResult = 0;
#line 329
      checkState = -2;
    } else
#line 325
    if (PushedResetFlag) {
#line 327
      tt_TimeoutPoll.tv_usec = (__suseconds_t )250;
#line 328
      iResult = 0;
#line 329
      checkState = -2;
    } else
#line 325
    if ((int )FirstTimeFlag > 1) {
#line 327
      tt_TimeoutPoll.tv_usec = (__suseconds_t )250;
#line 328
      iResult = 0;
#line 329
      checkState = -2;
    }
#line 334
    if (checkState != -2) {
#line 338
      if (1 == TimerFlag) {
#line 339
        if (ShutdownTimer < (long )iResult) {
#line 340
          iResult = (int )ShutdownTimer;
        }
      }
#line 345
      if (fan_fault > 0) {
#line 346
        if (fan_fault == 6) {
#line 346
          iResult = fanFaultSeize;
        } else {
#line 346
          iResult = 2;
        }
      }
    }
#line 350
    tt_TimeoutPoll.tv_sec = (__time_t )iResult;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fReadFS.__fds_bits[0]): "memory");
#line 352
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 353
    fReadFS.__fds_bits[FileDescriptor / (8 * (int )sizeof(__fd_mask ))] |= 1L << FileDescriptor % (8 * (int )sizeof(__fd_mask ));
#line 356
    iResult = select(FileDescriptor + 1, (fd_set */* __restrict  */)(& fReadFS), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tt_TimeoutPoll));
#line 360
    tt_TimeNow = time((time_t *)((void *)0));
    }
#line 363
    if (iResult > 0) {
      {
#line 365
      tmp___0 = read(FileDescriptor, (void *)(buf), (size_t )16);
#line 365
      iResult = (int )tmp___0;
#line 367
      checkState = -2;
      }
      {
#line 371
      if ((int )buf[0] == 32) {
#line 371
        goto case_32;
      }
#line 400
      if ((int )buf[0] == 33) {
#line 400
        goto case_33;
      }
#line 408
      if ((int )buf[0] == 34) {
#line 408
        goto case_34;
      }
#line 431
      if ((int )buf[0] == 35) {
#line 431
        goto case_35;
      }
#line 439
      if ((int )buf[0] == 36) {
#line 439
        goto case_36;
      }
#line 445
      if ((int )buf[0] == 37) {
#line 445
        goto case_37;
      }
#line 458
      if ((int )buf[0] == 48) {
#line 458
        goto case_48;
      }
#line 462
      if ((int )buf[0] == 49) {
#line 462
        goto case_49;
      }
#line 468
      if ((int )buf[0] == 51) {
#line 468
        goto case_51;
      }
#line 369
      goto switch_break;
      case_32: /* CIL Label */ 
#line 372
      if (0 == (int )PressedPowerFlag) {
#line 373
        cmd = (char )'3';
#line 375
        if (tt_TimeNow - tt_Power_Press <= 1L) {
#line 375
          if ((int )FirstTimeFlag < 2) {
#line 378
            cmd = (char )'8';
          } else {
#line 375
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 379
        if (ShutdownTimer < 300L) {
#line 379
          goto _L;
        } else
#line 379
        if ((int )FirstTimeFlag > 1) {
          _L: /* CIL Label */ 
#line 382
          if (0 == (int )FirstTimeFlag) {
#line 383
            FirstTimeFlag = (char)10;
          }
#line 385
          ShutdownTimer += 300L;
#line 387
          FirstTimeFlag = (char )((int )FirstTimeFlag - 1);
#line 388
          extraTime = (char)1;
        }
        {
#line 391
        execute_command1(cmd);
#line 393
        tt_Power_Press = tt_TimeNow;
        }
      }
#line 396
      PressedPowerFlag = (char)0;
#line 396
      PushedPowerFlag = PressedPowerFlag;
#line 397
      goto switch_break;
      case_33: /* CIL Label */ 
      {
#line 401
      execute_command1((char )'4');
#line 403
      PressedPowerFlag = (char)0;
#line 404
      PushedPowerFlag = (char)1;
      }
#line 405
      goto switch_break;
      case_34: /* CIL Label */ 
#line 409
      if (0 == (int )PressedResetFlag) {
#line 410
        cmd = (char )'5';
#line 411
        iResult = 0;
#line 414
        if (tt_TimeNow - tt_Power_Press <= 1L) {
#line 417
          cmd = (char )'0';
#line 418
          iResult = (int )resetPresses;
#line 419
          resetPresses = (char )((int )resetPresses + 1);
        }
        {
#line 422
        execute_command(cmd, iResult);
#line 424
        tt_Power_Press = tt_TimeNow;
        }
      }
#line 427
      PressedResetFlag = (char)0;
#line 427
      PushedResetFlag = PressedResetFlag;
#line 428
      goto switch_break;
      case_35: /* CIL Label */ 
      {
#line 432
      execute_command1((char )'6');
#line 434
      PressedResetFlag = (char)0;
#line 435
      PushedResetFlag = (char)1;
      }
#line 436
      goto switch_break;
      case_36: /* CIL Label */ 
#line 440
      fan_fault = 6;
#line 441
      tt_fault_time = tt_TimeNow;
#line 442
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 447
      execute_command((char )'F', fan_fault);
      }
#line 449
      if (fanFaultSeize > 0) {
#line 450
        fan_fault = 2;
#line 451
        tt_fault_time = tt_TimeNow;
      } else {
#line 453
        fan_fault = -1;
      }
#line 455
      goto switch_break;
      case_48: /* CIL Label */ 
#line 459
      goto switch_break;
      case_49: /* CIL Label */ 
      {
#line 463
      close_serial();
#line 464
      execute_command1((char )'1');
      }
#line 465
      goto switch_break;
      case_51: /* CIL Label */ 
#line 469
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 480
      time(& tt_TimeIdle);
      }
    } else {
#line 484
      if (tt_TimeIdle + (time_t )holdCycle < tt_TimeNow) {
#line 486
        if (1 == (int )PushedPowerFlag) {
#line 490
          if (! extraTime) {
            {
#line 491
            set_avr_timer((char)1);
            }
          }
          {
#line 493
          execute_command1((char )'7');
#line 495
          PushedPowerFlag = (char)0;
#line 496
          PressedPowerFlag = (char)1;
          }
        }
      }
#line 522
      if (! PushedResetFlag) {
#line 522
        if (! PushedPowerFlag) {
#line 522
          if ((int )FirstTimeFlag < 2) {
#line 524
            if (1 == TimerFlag) {
#line 526
              if (ShutdownTimer > 0L) {
                {
#line 527
                lTimerDiff = tt_TimeNow - tt_LastShutdownPing;
#line 531
                tmp___1 = abs((int )lTimerDiff);
                }
#line 531
                if (refreshRate + 60 > tmp___1) {
#line 532
                  ShutdownTimer -= lTimerDiff;
#line 537
                  if (ShutdownTimer < 300L) {
#line 538
                    if (FirstTimeFlag) {
                      {
#line 539
                      FirstTimeFlag = (char)0;
#line 542
                      execute_command((char )'S', (int )ShutdownTimer);
                      }
#line 548
                      if (! extraTime) {
                        {
#line 549
                        set_avr_timer((char)1);
                        }
                      }
                    }
                  }
                } else {
                  {
#line 559
                  check_timer((char)2);
                  }
                }
              } else {
                {
#line 564
                PressedResetFlag = (char)2;
#line 564
                PushedPowerFlag = PressedResetFlag;
#line 565
                execute_command1((char )'2');
                }
              }
            }
            {
#line 570
            tt_LastShutdownPing = time((time_t *)((void *)0));
            }
            {
#line 576
            if (checkState == 0) {
#line 576
              goto case_0;
            }
#line 582
            if (checkState == 1) {
#line 582
              goto case_1;
            }
#line 593
            if (checkState == 2) {
#line 593
              goto case_2;
            }
#line 593
            if (checkState == -2) {
#line 593
              goto case_2;
            }
#line 628
            if (checkState == 3) {
#line 628
              goto case_3;
            }
#line 574
            goto switch_break___0;
            case_0: /* CIL Label */ 
#line 577
            checkState = 1;
#line 578
            goto switch_break___0;
            case_1: /* CIL Label */ 
            {
#line 583
            check_timer((char)0);
#line 584
            checkState = 2;
            }
#line 585
            goto switch_break___0;
            case_2: /* CIL Label */ 
            case_neg_2: /* CIL Label */ 
            {
#line 594
            cmd = keepAlive;
#line 596
            currentStatus = check_disk();
            }
#line 596
            if (currentStatus) {
#line 598
              if (FirstWarning) {
                {
#line 599
                FirstWarning = pesterMessage;
#line 600
                execute_command((char )'9', diskUsed);
                }
              }
            }
#line 607
            if ((int )diskFull != (int )currentStatus) {
#line 609
              cmd = (char)86;
#line 610
              if (currentStatus) {
#line 611
                cmd = (char )((int )cmd + 1);
              } else {
                {
#line 613
                FirstWarning = (char)0;
#line 614
                execute_command((char )'9', 0);
                }
              }
#line 618
              diskFull = currentStatus;
            }
            {
#line 622
            writeUART(cmd);
#line 624
            checkState = 3;
            }
#line 625
            goto switch_break___0;
            case_3: /* CIL Label */ 
#line 629
            checkState = 0;
#line 630
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 636
      if (fan_fault == -1) {
#line 636
        goto case_neg_1;
      }
#line 638
      if (fan_fault == 1) {
#line 638
        goto case_1___0;
      }
#line 644
      if (fan_fault == 4) {
#line 644
        goto case_4;
      }
#line 644
      if (fan_fault == 3) {
#line 644
        goto case_4;
      }
#line 644
      if (fan_fault == 2) {
#line 644
        goto case_4;
      }
#line 655
      if (fan_fault == 6) {
#line 655
        goto case_6;
      }
#line 635
      goto switch_break___1;
      case_neg_1: /* CIL Label */ 
#line 637
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
#line 639
      fan_fault = 0;
#line 640
      goto switch_break___1;
      case_4: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      case_2___0: /* CIL Label */ 
#line 645
      if (tt_fault_time + (time_t )fanFaultSeize < tt_TimeNow) {
        {
#line 649
        execute_command((char )'F', 4);
#line 650
        fan_fault = 5;
        }
      }
#line 653
      goto switch_break___1;
      case_6: /* CIL Label */ 
#line 657
      if (tt_fault_time + 300L < tt_TimeNow) {
        {
#line 658
        writeUART((char)92);
#line 659
        fan_fault = 1;
        }
      }
#line 662
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 668
      if (tt_Power_Press + 10L < tt_TimeNow) {
#line 668
        if ((int )FirstTimeFlag > 1) {
          {
#line 671
          execute_command((char )'S', (int )((float )ShutdownTimer / 60.0f));
#line 675
          FirstTimeFlag = (char)1;
#line 676
          tt_Power_Press = (time_t )0;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  return;
}
}
#line 683 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
int main(int argc , char **argv ) 
{ 
  char *thisarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 687
  argc --;
#line 688
  argv ++;
  {
#line 691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 691
    if (argc >= 1) {
#line 691
      if (! (45 == (int )*(*argv))) {
#line 691
        goto while_break;
      }
    } else {
#line 691
      goto while_break;
    }
#line 692
    thisarg = *argv;
#line 693
    thisarg ++;
    {
#line 696
    if ((int )*thisarg == 100) {
#line 696
      goto case_100;
    }
#line 701
    if ((int )*thisarg == 105) {
#line 701
      goto case_105;
    }
#line 706
    if ((int )*thisarg == 99) {
#line 706
      goto case_99;
    }
#line 710
    if ((int )*thisarg == 118) {
#line 710
      goto case_118;
    }
#line 714
    if ((int )*thisarg == 101) {
#line 714
      goto case_101;
    }
#line 718
    if ((int )*thisarg == 104) {
#line 718
      goto case_104;
    }
#line 721
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 697
    argc --;
#line 698
    argv ++;
#line 699
    sprintf((char */* __restrict  */)(avr_device), (char const   */* __restrict  */)"%s",
            *argv);
    }
#line 700
    goto switch_break;
    case_105: /* CIL Label */ 
#line 702
    argc --;
#line 703
    debug = (char)2;
#line 704
    goto switch_break;
    case_99: /* CIL Label */ 
#line 707
    argc --;
#line 708
    debug = (char)1;
#line 709
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 711
    argc --;
#line 712
    printf((char const   */* __restrict  */)"%s", version);
#line 713
    exit(0);
    }
    case_101: /* CIL Label */ 
#line 715
    argc --;
#line 716
    em_mode = (char)1;
#line 717
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 719
    usage();
#line 720
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 722
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
#line 724
    argc --;
#line 725
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  if (! debug) {
    {
#line 730
    tmp = daemon(0, 0);
    }
#line 730
    if (tmp != 0) {
      {
#line 731
      exit(-1);
      }
    }
  } else
#line 733
  if (1 == (int )debug) {
    {
#line 734
    check_timer((char)0);
    }
  }
  {
#line 737
  signal(20, (void (*)(int  ))1);
#line 738
  signal(1, (void (*)(int  ))1);
#line 739
  signal(17, (void (*)(int  ))1);
#line 740
  signal(15, & termination_handler);
#line 741
  signal(18, & termination_handler);
#line 742
  signal(2, & termination_handler);
#line 745
  tmp___0 = open_serial(avr_device);
  }
#line 745
  if (tmp___0) {
    {
#line 746
    exit(-3);
    }
  }
#line 749
  if ((int )debug > 1) {
    {
#line 750
    close(FileDescriptor);
#line 751
    exit(0);
    }
  }
  {
#line 756
  setsid();
#line 759
  umask((__mode_t )0);
#line 762
  openlog("avr-daemon", 19, 4);
#line 765
  syslog(6, "%s", version);
#line 768
  avr_evtd_main();
  }
#line 770
  return (0);
}
}
#line 774 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void errorReport(int errorNumber ) 
{ 


  {
  {
#line 776
  execute_command((char )'D', errorNumber);
  }
#line 777
  return;
}
}
#line 787
static char ( __attribute__((__always_inline__)) check_disk)(void) ;
#line 787 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static char FirstTime  =    (char)0;
#line 788 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static char strRoot[16]  ;
#line 789 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static char strWorking[16]  ;
#line 780 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static char ( __attribute__((__always_inline__)) check_disk)(void) 
{ 
  struct statfs mountfs ;
  char bFull ;
  int errno ;
  int total ;
  int total2 ;
  char cmd ;
  char *pos ;
  int file ;
  int iRead ;
  int i ;
  char buff[4096] ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 791
  bFull = (char)0;
#line 793
  total = 0;
#line 794
  total2 = 0;
#line 803
  if ((int )FirstTime < diskCheckNumber) {
    {
#line 804
    FirstTime = (char)0;
#line 806
    file = open("/etc/mtab", 0);
    }
#line 809
    if (file) {
      {
#line 810
      tmp = read(file, (void *)(buff), (size_t )4095);
#line 810
      iRead = (int )tmp;
#line 812
      pos = strtok((char */* __restrict  */)(buff), (char const   */* __restrict  */)" \n");
      }
#line 813
      if (iRead > 0) {
#line 814
        i = 0;
        {
#line 814
        while (1) {
          while_continue: /* CIL Label */ ;
#line 814
          if (! (i < 60)) {
#line 814
            goto while_break;
          }
          {
#line 815
          cmd = (char)-1;
#line 817
          tmp___1 = strcasecmp((char const   *)pos, (char const   *)(rootPartition));
          }
#line 817
          if (tmp___1 == 0) {
#line 819
            cmd = (char)0;
          } else {
            {
#line 820
            tmp___0 = strcasecmp((char const   *)pos, (char const   *)(workingPartition));
            }
#line 820
            if (tmp___0 == 0) {
#line 823
              cmd = (char)1;
            }
          }
          {
#line 825
          pos = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \n");
          }
#line 826
          if (! pos) {
#line 827
            goto while_break;
          }
          {
#line 834
          if ((int )cmd == 0) {
#line 834
            goto case_0;
          }
#line 839
          if ((int )cmd == 1) {
#line 839
            goto case_1;
          }
#line 833
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 835
          sprintf((char */* __restrict  */)(strRoot), (char const   */* __restrict  */)"%s",
                  pos);
#line 837
          FirstTime = (char )((int )FirstTime + 1);
          }
#line 838
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 840
          sprintf((char */* __restrict  */)(strWorking), (char const   */* __restrict  */)"%s",
                  pos);
#line 842
          FirstTime = (char )((int )FirstTime + 1);
          }
#line 843
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 814
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 848
    close(file);
    }
  }
#line 853
  if (checkPercentage > 0) {
#line 853
    if (diskCheckNumber > 0) {
#line 854
      errno = -1;
#line 856
      if (diskCheckNumber == (int )FirstTime) {
        {
#line 858
        tmp___2 = strlen((char const   *)(strRoot));
        }
#line 858
        if (tmp___2 > 0UL) {
          {
#line 859
          errno = statfs((char const   *)(strRoot), & mountfs);
          }
#line 862
          if (0 == errno) {
#line 863
            total = 100 - (int )(((double )mountfs.f_bavail / (double )mountfs.f_blocks) * (double )100.0f + 0.99);
#line 871
            if (total >= checkPercentage) {
#line 872
              bFull = (char)1;
            }
          }
        }
        {
#line 876
        tmp___3 = strlen((char const   *)(strWorking));
        }
#line 876
        if (tmp___3 > 0UL) {
          {
#line 878
          errno = statfs((char const   *)(strWorking), & mountfs);
          }
#line 879
          if (0 == errno) {
#line 880
            total2 = 100 - (int )(((double )mountfs.f_bavail / (double )mountfs.f_blocks) * (double )100.0f + 0.99);
#line 887
            if (total2 >= checkPercentage) {
#line 888
              bFull = (char)1;
            }
          }
        }
      }
#line 894
      if (0 != errno) {
        {
#line 896
        writeUART((char)89);
        }
      }
    }
  }
#line 900
  diskUsed = total2;
#line 901
  if (total > total2) {
#line 902
    diskUsed = total;
  }
#line 904
  return (bFull);
}
}
#line 910 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void parse_timer(char *buff ) 
{ 
  int offHour ;
  int offMinutes ;
  int onHour ;
  int onMinutes ;
  long offTime ;
  long onTime ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 914
  offTime = -1L;
#line 914
  onTime = -1L;
#line 917
  tmp___0 = sscanf((char const   */* __restrict  */)buff, (char const   */* __restrict  */)"on<>%02d:%02d<>%02d:%02d",
                   & offHour, & offMinutes, & onHour, & onMinutes);
  }
#line 917
  if (tmp___0) {
#line 920
    TimerFlag = 1;
#line 921
    offTime = (long )(offHour * 60 + offMinutes);
#line 922
    onTime = (long )(onHour * 60 + onMinutes);
  } else {
    {
#line 924
    tmp = sscanf((char const   */* __restrict  */)buff, (char const   */* __restrict  */)"off<>%02d:%02d<>%02d:%02d",
                 & offHour, & offMinutes, & onHour, & onMinutes);
    }
#line 924
    if (tmp) {
#line 927
      TimerFlag = 0;
    } else {
#line 929
      TimerFlag = 0;
    }
  }
#line 932
  if (1 == TimerFlag) {
#line 933
    OffTime = offTime;
#line 934
    OnTime = onTime;
  }
#line 936
  return;
}
}
#line 943 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void parse_avr(char *buff ) 
{ 
  char const   *command[19] ;
  char *pos ;
  char *last ;
  int i ;
  int j ;
  int cmd ;
  int iHour ;
  int iMinutes ;
  int iGroup ;
  int ilastGroup ;
  int iFirstDay ;
  int iProcessDay ;
  TIMER *pTimer ;
  TIMER *pOff ;
  TIMER *pOn ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 945
  command[0] = "TIMER";
#line 945
  command[1] = "SHUTDOWN";
#line 945
  command[2] = "OFF";
#line 945
  command[3] = "POWERON";
#line 945
  command[4] = "ON";
#line 945
  command[5] = "DISKCHECK";
#line 945
  command[6] = "REFRESH";
#line 945
  command[7] = "HOLD";
#line 945
  command[8] = "SUN";
#line 945
  command[9] = "MON";
#line 945
  command[10] = "TUE";
#line 945
  command[11] = "WED";
#line 945
  command[12] = "THR";
#line 945
  command[13] = "FRI";
#line 945
  command[14] = "SAT";
#line 945
  command[15] = "DISKNAG";
#line 945
  command[16] = "FANSTOP";
#line 945
  command[17] = "ROOT";
#line 945
  command[18] = "WORK";
#line 967
  iGroup = 0;
#line 968
  ilastGroup = 0;
#line 969
  iFirstDay = -1;
#line 970
  iProcessDay = -1;
#line 976
  pos = strtok_r((char */* __restrict  */)buff, (char const   */* __restrict  */)",=\n",
                 (char **/* __restrict  */)(& last));
#line 979
  destroyObject(offTimer);
#line 980
  destroyObject(onTimer);
#line 983
  tmp = calloc(sizeof(TIMER ), sizeof(char ));
#line 983
  onTimer = (TIMER *)tmp;
#line 983
  pOn = onTimer;
#line 984
  tmp___0 = calloc(sizeof(TIMER ), sizeof(char ));
#line 984
  offTimer = (TIMER *)tmp___0;
#line 984
  pOff = offTimer;
#line 987
  pesterMessage = (char)0;
#line 988
  TimerFlag = 0;
#line 989
  refreshRate = 40;
#line 990
  holdCycle = 3;
#line 991
  diskCheckNumber = 0;
#line 994
  i = 0;
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! (i < 200)) {
#line 994
      goto while_break;
    }
#line 995
    cmd = -1;
#line 998
    if (35 != (int )*(pos + 0)) {
#line 1001
      if (45 == (int )*(pos + 3)) {
        {
#line 1002
        *(last - 1) = (char )'=';
#line 1003
        iGroup = 1;
#line 1004
        last -= 8;
#line 1005
        pos = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-",
                       (char **/* __restrict  */)(& last));
        }
      }
#line 1009
      cmd = 0;
      {
#line 1009
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1009
        if (! (cmd < 19)) {
#line 1009
          goto while_break___0;
        }
        {
#line 1010
        tmp___1 = strcasecmp((char const   *)pos, command[cmd]);
        }
#line 1010
        if (tmp___1 == 0) {
#line 1011
          goto while_break___0;
        }
#line 1009
        cmd ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1013
      pos = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",=\n",
                     (char **/* __restrict  */)(& last));
      }
    } else {
      {
#line 1015
      pos = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                     (char **/* __restrict  */)(& last));
      }
#line 1020
      if (35 != (int )*(pos + 0)) {
        {
#line 1021
        tmp___2 = strlen((char const   *)pos);
#line 1021
        j = (int )tmp___2;
#line 1022
        *(last - 1) = (char )',';
#line 1023
        last -= j + 1;
#line 1026
        pos = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",=\n",
                       (char **/* __restrict  */)(& last));
        }
      }
    }
#line 1030
    if (! pos) {
#line 1031
      goto while_break;
    }
#line 1033
    if (35 == (int )*(pos + 0)) {
#line 1034
      cmd = -1;
    }
    {
#line 1040
    if (cmd == 0) {
#line 1040
      goto case_0;
    }
#line 1046
    if (cmd == 1) {
#line 1046
      goto case_1;
    }
#line 1052
    if (cmd == 2) {
#line 1052
      goto case_2;
    }
#line 1059
    if (cmd == 3) {
#line 1059
      goto case_3;
    }
#line 1065
    if (cmd == 4) {
#line 1065
      goto case_4;
    }
#line 1136
    if (cmd == 5) {
#line 1136
      goto case_5;
    }
#line 1147
    if (cmd == 6) {
#line 1147
      goto case_6;
    }
#line 1158
    if (cmd == 7) {
#line 1158
      goto case_7;
    }
#line 1175
    if (cmd == 14) {
#line 1175
      goto case_14;
    }
#line 1175
    if (cmd == 13) {
#line 1175
      goto case_14;
    }
#line 1175
    if (cmd == 12) {
#line 1175
      goto case_14;
    }
#line 1175
    if (cmd == 11) {
#line 1175
      goto case_14;
    }
#line 1175
    if (cmd == 10) {
#line 1175
      goto case_14;
    }
#line 1175
    if (cmd == 9) {
#line 1175
      goto case_14;
    }
#line 1175
    if (cmd == 8) {
#line 1175
      goto case_14;
    }
#line 1190
    if (cmd == 15) {
#line 1190
      goto case_15;
    }
#line 1195
    if (cmd == 16) {
#line 1195
      goto case_16;
    }
#line 1213
    if (cmd == 18) {
#line 1213
      goto case_18;
    }
#line 1213
    if (cmd == 17) {
#line 1213
      goto case_18;
    }
#line 1038
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1041
    tmp___3 = strcasecmp((char const   *)pos, "ON");
    }
#line 1041
    if (tmp___3 == 0) {
#line 1042
      TimerFlag = 1;
    }
#line 1043
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1047
    pTimer = pOff;
#line 1048
    iMinutes = -1;
#line 1048
    iHour = iMinutes;
#line 1049
    goto process;
    case_2: /* CIL Label */ 
#line 1053
    pTimer = pOff;
#line 1054
    iHour = 24;
#line 1055
    iMinutes = 0;
#line 1056
    goto process;
    case_3: /* CIL Label */ 
#line 1060
    pTimer = pOn;
#line 1061
    iMinutes = -1;
#line 1061
    iHour = iMinutes;
#line 1062
    goto process;
    case_4: /* CIL Label */ 
#line 1066
    pTimer = pOn;
#line 1067
    iMinutes = 0;
#line 1067
    iHour = iMinutes;
    process: 
    {
#line 1069
    tmp___6 = sscanf((char const   */* __restrict  */)pos, (char const   */* __restrict  */)"%02d:%02d",
                     & iHour, & iMinutes);
    }
#line 1069
    if (tmp___6) {
#line 1073
      if (iHour >= 0) {
#line 1073
        if (iHour <= 24) {
#line 1073
          if (iMinutes >= 0) {
#line 1073
            if (iMinutes <= 59) {
#line 1076
              if (2 == cmd) {
#line 1076
                goto _L;
              } else
#line 1076
              if (4 == cmd) {
                _L: /* CIL Label */ 
#line 1078
                if (iGroup != 0) {
#line 1079
                  j = iFirstDay - 1;
                  {
#line 1083
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 1083
                    if (! (j != iProcessDay)) {
#line 1083
                      goto while_break___1;
                    }
#line 1084
                    j ++;
#line 1085
                    if (j > 7) {
#line 1086
                      j = 0;
                    }
                    {
#line 1087
                    pTimer->day = j;
#line 1088
                    pTimer->time = (long )(iHour * 60 + iMinutes);
#line 1095
                    tmp___4 = calloc(sizeof(TIMER ), sizeof(char ));
#line 1095
                    pTimer->pointer = tmp___4;
#line 1101
                    pTimer = (TIMER *)pTimer->pointer;
                    }
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                } else {
                  {
#line 1106
                  pTimer->day = iProcessDay;
#line 1107
                  pTimer->time = (long )(iHour * 60 + iMinutes);
#line 1111
                  tmp___5 = calloc(sizeof(TIMER ), sizeof(char ));
#line 1111
                  pTimer->pointer = tmp___5;
#line 1114
                  pTimer = (TIMER *)pTimer->pointer;
                  }
                }
              } else
#line 1120
              if (1 == cmd) {
#line 1121
                OffTime = (long )(iHour * 60 + iMinutes);
              } else
#line 1122
              if (3 == cmd) {
#line 1123
                OnTime = (long )(iHour * 60 + iMinutes);
              }
            } else {
#line 1125
              TimerFlag = -1;
            }
          } else {
#line 1125
            TimerFlag = -1;
          }
        } else {
#line 1125
          TimerFlag = -1;
        }
      } else {
#line 1125
        TimerFlag = -1;
      }
    } else {
#line 1070
      TimerFlag = -1;
    }
#line 1128
    if (cmd < 3) {
#line 1129
      pOff = pTimer;
    } else {
#line 1131
      pOn = pTimer;
    }
#line 1133
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1137
    tmp___7 = sscanf((char const   */* __restrict  */)pos, (char const   */* __restrict  */)"%d",
                     & checkPercentage);
    }
#line 1137
    if (tmp___7) {
#line 1140
      if (checkPercentage > 100) {
#line 1141
        checkPercentage = 100;
      } else
#line 1142
      if (checkPercentage < 0) {
#line 1143
        checkPercentage = -1;
      }
    } else {
#line 1138
      checkPercentage = -1;
    }
#line 1144
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1148
    tmp___8 = sscanf((char const   */* __restrict  */)pos, (char const   */* __restrict  */)"%03d",
                     & refreshRate);
    }
#line 1148
    if (tmp___8) {
#line 1149
      refreshRate = 40;
    } else
#line 1151
    if (refreshRate > 300) {
#line 1152
      refreshRate = 300;
    } else
#line 1153
    if (refreshRate < 10) {
#line 1154
      refreshRate = 1;
    }
#line 1155
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1159
    tmp___9 = sscanf((char const   */* __restrict  */)pos, (char const   */* __restrict  */)"%02d",
                     & holdCycle);
    }
#line 1159
    if (tmp___9) {
#line 1160
      holdCycle = 3;
    } else
#line 1162
    if (holdCycle > 10) {
#line 1163
      holdCycle = 10;
    } else
#line 1164
    if (holdCycle < 2) {
#line 1165
      holdCycle = 2;
    }
#line 1166
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 1177
    iProcessDay = cmd - 8;
#line 1179
    ilastGroup += iGroup;
#line 1180
    if (ilastGroup > 2) {
#line 1181
      iGroup = 0;
#line 1182
      ilastGroup = 0;
    }
#line 1185
    if (1 == ilastGroup) {
#line 1186
      iFirstDay = iProcessDay;
    }
#line 1188
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1191
    tmp___10 = strcasecmp((char const   *)pos, "ON");
    }
#line 1191
    if (tmp___10 == 0) {
#line 1192
      pesterMessage = (char)1;
    }
    case_16: /* CIL Label */ 
    {
#line 1196
    tmp___12 = strcasecmp((char const   *)pos, "OFF");
    }
#line 1196
    if (tmp___12 == 0) {
#line 1197
      fanFaultSeize = 0;
    } else {
      {
#line 1199
      tmp___11 = sscanf((char const   */* __restrict  */)pos, (char const   */* __restrict  */)"%02d",
                        & fanFaultSeize);
      }
#line 1199
      if (tmp___11) {
#line 1200
        fanFaultSeize = 30;
      } else
#line 1202
      if (fanFaultSeize > 60) {
#line 1203
        fanFaultSeize = 60;
      } else
#line 1204
      if (fanFaultSeize < 1) {
#line 1205
        fanFaultSeize = 1;
      }
    }
#line 1207
    goto switch_break;
#line 1209
    goto switch_break;
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    {
#line 1214
    tmp___13 = strlen((char const   *)pos);
    }
#line 1214
    if (tmp___13 <= 5UL) {
#line 1215
      diskCheckNumber ++;
#line 1218
      if (17 == cmd) {
        {
#line 1219
        sprintf((char */* __restrict  */)(rootPartition), (char const   */* __restrict  */)"/dev/%s",
                pos);
        }
      } else {
        {
#line 1223
        sprintf((char */* __restrict  */)(workingPartition), (char const   */* __restrict  */)"/dev/%s",
                pos);
        }
      }
    }
#line 1226
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1230
  if (TimerFlag < 0) {
    {
#line 1231
    TimerFlag = 0;
#line 1232
    errorReport(3);
    }
  }
#line 1234
  return;
}
}
#line 1237 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void destroyObject(TIMER *pTimer ) 
{ 
  TIMER *pObj ;

  {
#line 1244
  if (pTimer) {
    {
#line 1247
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1248
      pObj = (TIMER *)pTimer->pointer;
#line 1249
      if ((unsigned long )((void *)0) == (unsigned long )pObj) {
#line 1250
        goto while_break;
      }
      {
#line 1251
      free((void *)pTimer);
#line 1252
      pTimer = (TIMER *)((void *)0);
#line 1253
      pTimer = pObj;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1256
    pTimer = (TIMER *)((void *)0);
  }
#line 1258
  return;
}
}
#line 1261 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static int FindNextToday(long timeNow , TIMER *pTimer , long *time___0 ) 
{ 
  int iLocated ;

  {
#line 1264
  iLocated = 0;
  {
#line 1266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1266
    if ((unsigned long )pTimer != (unsigned long )((void *)0)) {
#line 1266
      if (! ((unsigned long )pTimer->pointer != (unsigned long )((void *)0))) {
#line 1266
        goto while_break;
      }
    } else {
#line 1266
      goto while_break;
    }
#line 1268
    if (pTimer->day == last_day) {
#line 1268
      if (pTimer->time > timeNow) {
#line 1269
        iLocated = 1;
#line 1270
        *time___0 = pTimer->time;
#line 1271
        pTimer = (TIMER *)((void *)0);
      } else {
#line 1273
        pTimer = (TIMER *)pTimer->pointer;
      }
    } else {
#line 1273
      pTimer = (TIMER *)pTimer->pointer;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  return (iLocated);
}
}
#line 1281 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static int FindNextDay(long timeNow , TIMER *pTimer , long *time___0 , long *offset ) 
{ 
  int iLocated ;

  {
#line 1284
  iLocated = 0;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if ((unsigned long )pTimer != (unsigned long )((void *)0)) {
#line 1286
      if (! ((unsigned long )pTimer->pointer != (unsigned long )((void *)0))) {
#line 1286
        goto while_break;
      }
    } else {
#line 1286
      goto while_break;
    }
#line 1288
    if (pTimer->day > last_day) {
#line 1290
      if (pTimer->day > last_day) {
#line 1291
        *offset = (long )((((pTimer->day - last_day) * 12) * 60) * 2);
      }
#line 1295
      iLocated = 1;
#line 1296
      *time___0 = pTimer->time;
#line 1297
      pTimer = (TIMER *)((void *)0);
    } else {
#line 1299
      pTimer = (TIMER *)pTimer->pointer;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (iLocated);
}
}
#line 1307 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void GetTime(long timeNow , TIMER *pTimerLocate , long *time___0 , long defaultTime ) 
{ 
  long lOffset ;
  char onLocated ;
  TIMER *pTimer ;
  int tmp ;
  int tmp___0 ;

  {
#line 1310
  lOffset = 0L;
#line 1311
  onLocated = (char)0;
#line 1315
  if (pTimerLocate) {
#line 1315
    if ((unsigned long )pTimerLocate->pointer != (unsigned long )((void *)0)) {
      {
#line 1316
      lOffset = 0L;
#line 1317
      pTimer = pTimerLocate;
#line 1319
      tmp = FindNextToday(timeNow, pTimer, time___0);
#line 1319
      onLocated = (char )tmp;
      }
#line 1323
      if (0 == (int )onLocated) {
        {
#line 1324
        pTimer = pTimerLocate;
#line 1325
        tmp___0 = FindNextDay(timeNow, pTimer, time___0, & lOffset);
#line 1325
        onLocated = (char )tmp___0;
        }
      }
#line 1330
      if (0 == (int )onLocated) {
#line 1331
        *time___0 = pTimerLocate->time;
#line 1332
        lOffset = (long )(((((6 - last_day) + pTimerLocate->day) * 12) * 60) * 2);
      }
#line 1337
      *time___0 += lOffset;
#line 1339
      if (lOffset > 1440L) {
#line 1339
        if (defaultTime > 0L) {
#line 1340
          *time___0 = defaultTime;
        }
      }
    } else {
#line 1342
      *time___0 = defaultTime;
    }
  } else {
#line 1342
    *time___0 = defaultTime;
  }
#line 1343
  return;
}
}
#line 1431 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static void set_avr_timer(char type ) 
{ 
  char const   *strMessage[3] ;
  long current_time ;
  long wait_time ;
  time_t ltime ;
  time_t ttime ;
  struct tm *decode_time ;
  char message[80] ;
  char strAVR ;
  char twelve ;
  int i ;
  long mask ;
  long offTime ;
  long onTime ;
  int tmp ;

  {
#line 1435
  strMessage[0] = "file update";
#line 1435
  strMessage[1] = "re-validation";
#line 1435
  strMessage[2] = "clock skew";
#line 1444
  mask = 2048L;
#line 1448
  if (TimerFlag) {
    {
#line 1450
    time(& ltime);
#line 1452
    decode_time = localtime((time_t const   *)(& ltime));
#line 1453
    current_time = (long )(decode_time->tm_hour * 60 + decode_time->tm_min);
#line 1455
    last_day = decode_time->tm_wday;
#line 1457
    GetTime(current_time, offTimer, & offTime, OffTime);
    }
#line 1459
    if (offTime > 1440L) {
      {
#line 1460
      GetTime(current_time, onTimer, & onTime, OnTime);
      }
    } else {
      {
#line 1462
      GetTime(offTime, onTimer, & onTime, OnTime);
      }
    }
#line 1465
    twelve = (char)0;
#line 1466
    if (offTime < current_time) {
#line 1467
      twelve = (char)1;
#line 1468
      ShutdownTimer = (720L + (offTime - (current_time - 720L))) * 60L;
    } else {
#line 1472
      ShutdownTimer = (offTime - current_time) * 60L;
    }
    {
#line 1476
    ShutdownTimer -= (long )decode_time->tm_sec;
#line 1478
    ttime = ltime + ShutdownTimer;
#line 1479
    decode_time = localtime((time_t const   *)(& ttime));
#line 1481
    sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)"Timer is set with %02d/%02d %02d:%02d",
            decode_time->tm_mon + 1, decode_time->tm_mday, decode_time->tm_hour, decode_time->tm_min);
    }
#line 1488
    if (onTime < current_time) {
#line 1489
      wait_time = (720L + (onTime - (current_time - 720L))) * 60L;
#line 1492
      onTime = ((720L + (onTime - (current_time - 720L))) * 100L) / 112L;
    } else {
#line 1497
      if (onTime < offTime - 1440L) {
#line 1498
        onTime += 1440L;
      } else
#line 1499
      if (onTime < offTime) {
#line 1500
        onTime += 1440L;
      }
#line 1502
      wait_time = (onTime - current_time) * 60L;
#line 1503
      onTime = ((onTime - current_time) * 100L) / 112L;
    }
#line 1507
    if (onTime > 4095L) {
#line 1507
      if (onTime - ShutdownTimer / 60L > 4095L) {
        {
#line 1510
        wait_time -= ((onTime - 4095L) * 672L) / 10L;
#line 1512
        errorReport(2);
#line 1514
        onTime = 4095L;
        }
      }
    }
    {
#line 1517
    ttime = ltime + wait_time;
#line 1518
    decode_time = localtime((time_t const   *)(& ttime));
#line 1520
    sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)"%s-%02d/%02d %02d:%02d (Following timer %s)",
            message, decode_time->tm_mon + 1, decode_time->tm_mday, decode_time->tm_hour,
            decode_time->tm_min, strMessage[(int )type]);
#line 1526
    syslog(6, (char const   *)(message));
#line 1529
    writeUART((char)62);
#line 1530
    writeUART((char)60);
#line 1531
    writeUART((char)58);
#line 1532
    writeUART((char)56);
#line 1535
    i = 0;
    }
    {
#line 1535
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1535
      if (! (i < 12)) {
#line 1535
        goto while_break;
      }
#line 1536
      if (onTime & mask) {
#line 1536
        tmp = 33;
      } else {
#line 1536
        tmp = 32;
      }
      {
#line 1536
      strAVR = (char )(tmp + (11 - i) * 2);
#line 1538
      mask >>= 1;
#line 1541
      writeUART(strAVR);
#line 1535
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1545
    writeUART((char)63);
#line 1546
    keepAlive = (char)91;
    }
  } else {
    {
#line 1550
    writeUART((char)62);
#line 1551
    keepAlive = (char)90;
    }
  }
  {
#line 1554
  writeUART(keepAlive);
  }
#line 1555
  return;
}
}
#line 1558 "/home/june/collector/temp/avr-evtd-1.7.7/avr-evtd.c"
static int check_timer(char type ) 
{ 
  int iReturn ;
  int iRead ;
  int errno ;
  char buff[4096] ;
  int file ;
  struct stat filestatus ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 1563
  iReturn = 1;
#line 1574
  if (0 == (int )CommandLineUpdate) {
    {
#line 1575
    CommandLineUpdate = (char)1;
#line 1581
    errno = stat((char const   */* __restrict  */)"/etc/melco/timer_sleep", (struct stat */* __restrict  */)(& filestatus));
    }
#line 1585
    if (0 == errno) {
#line 1587
      if (filestatus.st_mtim.tv_sec != LastMelcoAccess) {
        {
#line 1588
        iRead = -1;
#line 1606
        file = open("/etc/melco/timer_sleep", 0);
        }
#line 1610
        if (file) {
          {
#line 1611
          tmp = read(file, (void *)(buff), (size_t )31);
#line 1611
          iRead = (int )tmp;
#line 1614
          close(file);
          }
#line 1616
          if (iRead > 0) {
            {
#line 1617
            parse_timer(buff);
            }
          }
        }
#line 1620
        if (iRead > 0) {
          {
#line 1622
          CommandLineUpdate = (char)0;
#line 1622
          iReturn = (int )CommandLineUpdate;
#line 1623
          set_avr_timer(type);
          }
        }
      } else {
#line 1626
        CommandLineUpdate = (char)0;
      }
#line 1629
      LastMelcoAccess = filestatus.st_mtim.tv_sec;
    } else {
#line 1632
      LastMelcoAccess = (time_t )0;
#line 1633
      CommandLineUpdate = (char)1;
    }
  }
#line 1639
  if (1 == (int )CommandLineUpdate) {
    {
#line 1642
    CommandLineUpdate = (char)2;
#line 1644
    errno = stat((char const   */* __restrict  */)(config_file_location), (struct stat */* __restrict  */)(& filestatus));
    }
#line 1647
    if (0 == errno) {
#line 1649
      if (filestatus.st_mtim.tv_sec != LastMelcoAccess) {
        {
#line 1650
        file = open((char const   *)(config_file_location), 0);
        }
#line 1654
        if (file) {
          {
#line 1655
          tmp___0 = read(file, (void *)(buff), (size_t )4095);
#line 1655
          iRead = (int )tmp___0;
#line 1658
          close(file);
          }
#line 1660
          if (iRead > 0) {
            {
#line 1662
            iReturn = 0;
#line 1663
            CommandLineUpdate = (char)1;
#line 1664
            parse_avr(buff);
#line 1665
            set_avr_timer(type);
            }
          }
        }
      } else {
#line 1669
        CommandLineUpdate = (char)1;
      }
#line 1672
      LastMelcoAccess = filestatus.st_mtim.tv_sec;
    }
  }
#line 1678
  if (2 == (int )CommandLineUpdate) {
    {
#line 1679
    CommandLineUpdate = (char)3;
#line 1680
    set_avr_timer(type);
#line 1681
    errorReport(1);
    }
  }
#line 1684
  return (iReturn);
}
}
