/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
struct HttpResponse;
#line 4 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
typedef struct HttpResponse HttpResponse;
#line 5
struct HttpRequest;
#line 5 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
typedef struct HttpRequest HttpRequest;
#line 4 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.h"
struct WikiPageList;
#line 4 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.h"
typedef struct WikiPageList WikiPageList;
#line 6 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.h"
struct WikiPageList {
   char *name ;
   time_t mtime ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
struct __anonstruct_listtypes_65 {
   char ident ;
   int depth ;
   char *tag ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_18 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_18 fd_set;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 6 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
struct HttpRequestParam;
#line 6 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
typedef struct HttpRequestParam HttpRequestParam;
#line 20 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
struct HttpRequestParam {
   char *key ;
   char *val ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
struct HttpRequest {
   HttpRequestParam *params ;
   int n_params ;
   int n_params_alloc ;
   char *uri ;
   char *path_info ;
   char *query_string ;
   char *ip_src ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
struct HttpResponse {
   char *content_type ;
   char *status_str ;
   int status ;
   char *extra_headers ;
   char *data ;
   int data_len ;
   int data_len_alloced ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 373
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.h"
void util_dehttpize(char *z ) ;
#line 16
char *util_htmlize(char const   *in , int n ) ;
#line 19
char *util_httpize(char const   *url ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
char *http_request_param_get(HttpRequest *req , char *key ) ;
#line 20
char *http_request_get_path_info(HttpRequest *req ) ;
#line 23
char *http_request_get_query_string(HttpRequest *req ) ;
#line 26
char *http_request_get_ip_src(HttpRequest *req ) ;
#line 29
HttpResponse *http_response_new(HttpRequest *req ) ;
#line 32
void http_response_printf(HttpResponse *res , char const   *format  , ...) ;
#line 35
void http_response_printf_alloc_buffer(HttpResponse *res , int bytes ) ;
#line 38
void http_response_set_content_type(HttpResponse *res , char *type ) ;
#line 41
void http_response_set_status(HttpResponse *res , int status_code , char *status_desc ) ;
#line 46
void http_response_set_data(HttpResponse *res , void *data , int data_len ) ;
#line 49
void http_response_append_header(HttpResponse *res , char *header ) ;
#line 55
void http_response_send(HttpResponse *res ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.h"
void wiki_handle_http_request(HttpRequest *req ) ;
#line 15
void wiki_show_header(HttpResponse *res , char *page_title , int want_edit ) ;
#line 18
void wiki_show_footer(HttpResponse *res ) ;
#line 21
void wiki_print_data_as_html(HttpResponse *res , char *raw_page_data ) ;
#line 24
int wiki_init(char *didiwiki_home ) ;
#line 268 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wikitext.h"
unsigned char FaviconData[198]  = 
#line 268 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wikitext.h"
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)2,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)176,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)22,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)40,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)16,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)32,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)64,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)238,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)186,      (unsigned char)171, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)146,      (unsigned char)171, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)170,      (unsigned char)155, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)187,      (unsigned char)175, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)186,      (unsigned char)171, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)141,      (unsigned char)27, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)181,      (unsigned char)107, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)181,      (unsigned char)107, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)183,      (unsigned char)111, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)141,      (unsigned char)27, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 288 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wikitext.h"
unsigned int FaviconDataLen  =    198U;
#line 20 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static char *CssData  =    (char *)"body {\n  font-family: Verdana, Arial, Helvetica, sans-serif;\n  font-size: 90%;  \n  color: #333333;\n  margin: 2px;\n  padding: 2px;\n}\n\n#header {\n    font-size: 90%;\n    background-color: #eef;\n    border: 1px solid #aaa;\n    font-family: Verdana, Arial, Helvetica, sans-serif;\n    padding: 5px;\n    margin-bottom:20px;\n}\n#header input {\n    margin:0px;\n    padding: 0;\n    background-color: White;\n    border: 1px solid #aaaaaa;\n    font-size: 90%;\n}\n\n#footer {\n    font-size: 10px;\n    color: #ddd;\n    margin-top:40px;\n    width: 100%;\n    text-align: center;\n}\ntable.wikitable { background-color: #fff; border: 1px solid #aaa; }\ntable.wikitable td { background-color: #fff; border: 1px solid #aaa; }\n\npre {\n    font-family: monospace;\n    background-color: #eee;\n    padding: 2px;\n    padding-left: 10px;\n    margin-left: 20px;\n    margin-right: 20px;\n}\n\nhr {\n height: 1px;\n color: #aaaaaa;\n background-color: #aaaaaa;\n border: 0;\n margin: 0.2em 5px 0.2em 5px;\n}\n\nform {\n    border: none;\n    margin: 0;\n}\n\ntextarea {\n    border: 1px solid #aaaaaa;\n    color: Black;\n    background-color: white;\n    width: 100%;\n    padding: 0.1em;\n    overflow: auto;\n}\n\ninput {\n    margin-top:1px;\n    padding: 0 0.4em !important;\n    background-color: White;\n    border: 1px solid #aaaaaa;\n}\n\na, ulink{\n   color: #333;\n   text-decoration:none;\n   border-bottom: 1px #333 dotted;\n   display: inline;\n }\n\na:hover {\n   color: #333;\n   text-decoration: None;\n   border-bottom: 1px #000 solid;\n   }\n\na:visited {\n   color: #333;\n}\n\n";
#line 22 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static char *get_line_from_string(char **lines , int *line_len ) 
{ 
  int i ;
  char *z ;

  {
#line 26
  z = *lines;
#line 28
  if ((int )*(z + 0) == 0) {
#line 28
    return ((char *)((void *)0));
  }
#line 30
  i = 0;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! *(z + i)) {
#line 30
      goto while_break;
    }
#line 32
    if ((int )*(z + i) == 10) {
#line 34
      if (i > 0) {
#line 34
        if ((int )*(z + (i - 1)) == 13) {
#line 35
          *(z + (i - 1)) = (char )'\000';
        } else {
#line 37
          *(z + i) = (char )'\000';
        }
      } else {
#line 37
        *(z + i) = (char )'\000';
      }
#line 38
      i ++;
#line 39
      goto while_break;
    }
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  *lines = z + i;
#line 45
  *line_len -= i;
#line 47
  return (z);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static char *check_for_link(char *line , int *skip_chars ) 
{ 
  char *start ;
  char *p ;
  char *url ;
  char *title ;
  char *result ;
  int found ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int num_upper_char ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int len ;
  size_t tmp___9 ;
  char *extra_attr ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 53
  start = line;
#line 54
  p = line;
#line 55
  url = (char *)((void *)0);
#line 56
  title = (char *)((void *)0);
#line 57
  result = (char *)((void *)0);
#line 58
  found = 0;
#line 60
  if ((int )*p == 91) {
#line 69
    url = start + 1;
#line 69
    *p = (char )'\000';
#line 69
    p ++;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if ((int )*p != 93) {
#line 70
        if ((int )*p != 0) {
          {
#line 70
          tmp = __ctype_b_loc();
          }
#line 70
          if ((int const   )*(*tmp + (int )*p) & 8192) {
#line 70
            goto while_break;
          }
        } else {
#line 70
          goto while_break;
        }
      } else {
#line 70
        goto while_break;
      }
#line 70
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 72
    tmp___0 = __ctype_b_loc();
    }
#line 72
    if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 74
      *p = (char )'\000';
#line 75
      p ++;
#line 75
      title = p;
      {
#line 76
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 76
        if ((int )*p != 93) {
#line 76
          if (! ((int )*p != 0)) {
#line 76
            goto while_break___0;
          }
        } else {
#line 76
          goto while_break___0;
        }
#line 77
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 80
    *p = (char )'\000';
#line 81
    p ++;
  } else {
    {
#line 83
    tmp___5 = strncasecmp((char const   *)p, "http://", (size_t )7);
    }
#line 83
    if (tmp___5) {
      {
#line 83
      tmp___6 = strncasecmp((char const   *)p, "mailto://", (size_t )9);
      }
#line 83
      if (tmp___6) {
        {
#line 83
        tmp___7 = strncasecmp((char const   *)p, "file://", (size_t )7);
        }
#line 83
        if (tmp___7) {
          {
#line 92
          tmp___4 = __ctype_b_loc();
          }
#line 92
          if ((int const   )*(*tmp___4 + (int )*p) & 256) {
#line 94
            num_upper_char = 1;
#line 95
            p ++;
            {
#line 96
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 96
              if ((int )*p != 0) {
                {
#line 96
                tmp___3 = __ctype_b_loc();
                }
#line 96
                if (! ((int const   )*(*tmp___3 + (int )*p) & 8)) {
#line 96
                  goto while_break___1;
                }
              } else {
#line 96
                goto while_break___1;
              }
              {
#line 98
              tmp___2 = __ctype_b_loc();
              }
#line 98
              if ((int const   )*(*tmp___2 + (int )*p) & 256) {
#line 99
                found = 1;
#line 99
                num_upper_char ++;
              }
#line 100
              p ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 103
            if ((long )num_upper_char == p - start) {
#line 104
              return ((char *)((void *)0));
            }
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 87
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 87
            if ((int )*p != 0) {
              {
#line 87
              tmp___1 = __ctype_b_loc();
              }
#line 87
              if ((int const   )*(*tmp___1 + (int )*p) & 8192) {
#line 87
                goto while_break___2;
              }
            } else {
#line 87
              goto while_break___2;
            }
#line 87
            p ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 90
          found = 1;
        }
      } else {
#line 83
        goto _L;
      }
    } else {
#line 83
      goto _L;
    }
  }
#line 107
  if (found) {
    {
#line 109
    tmp___8 = malloc(sizeof(char ) * (unsigned long )((p - start) + 2L));
#line 109
    url = (char *)tmp___8;
#line 110
    memset((void *)url, 0, sizeof(char ) * (unsigned long )((p - start) + 2L));
#line 111
    strncpy((char */* __restrict  */)url, (char const   */* __restrict  */)start,
            (size_t )(p - start));
#line 112
    *start = (char )'\000';
    }
  }
#line 115
  if ((unsigned long )url != (unsigned long )((void *)0)) {
    {
#line 117
    tmp___9 = strlen((char const   *)url);
#line 117
    len = (int )tmp___9;
#line 119
    *skip_chars = (int )(p - start);
#line 122
    tmp___11 = strncmp((char const   *)((url + len) - 4), ".gif", (size_t )4);
    }
#line 122
    if (tmp___11) {
      {
#line 122
      tmp___12 = strncmp((char const   *)((url + len) - 4), ".png", (size_t )4);
      }
#line 122
      if (tmp___12) {
        {
#line 122
        tmp___13 = strncmp((char const   *)((url + len) - 4), ".jpg", (size_t )4);
        }
#line 122
        if (tmp___13) {
          {
#line 122
          tmp___14 = strncmp((char const   *)((url + len) - 5), ".jpeg", (size_t )5);
          }
#line 122
          if (tmp___14) {
            {
#line 133
            extra_attr = (char *)"";
#line 135
            tmp___10 = strncasecmp((char const   *)url, "http://", (size_t )7);
            }
#line 135
            if (! tmp___10) {
#line 136
              extra_attr = (char *)" title=\'WWW link\' ";
            }
#line 138
            if (title) {
              {
#line 139
              asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"<a %s href=\'%s\'>%s</a>",
                       extra_attr, url, title);
              }
            } else {
              {
#line 141
              asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"<a %s href=\'%s\'>%s</a>",
                       extra_attr, url, url);
              }
            }
          } else
          _L___0: /* CIL Label */ 
#line 125
          if (title) {
            {
#line 126
            asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"<a href=\'%s\'><img src=\'%s\' border=\'0\'></a>",
                     title, url);
            }
          } else {
            {
#line 129
            asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"<img src=\'%s\' border=\'0\'>",
                     url);
            }
          }
        } else {
#line 122
          goto _L___0;
        }
      } else {
#line 122
        goto _L___0;
      }
    } else {
#line 122
      goto _L___0;
    }
#line 146
    return (result);
  }
#line 149
  return ((char *)((void *)0));
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static char *file_read(char *filename ) 
{ 
  struct stat st ;
  FILE *fp ;
  char *str ;
  int len ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 162
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 162
  if (tmp) {
#line 163
    return ((char *)((void *)0));
  }
  {
#line 165
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 165
  if (! fp) {
#line 166
    return ((char *)((void *)0));
  }
  {
#line 168
  tmp___0 = malloc(sizeof(char ) * (unsigned long )(st.st_size + 1L));
#line 168
  str = (char *)tmp___0;
#line 169
  tmp___1 = fread((void */* __restrict  */)str, (size_t )1, (size_t )st.st_size, (FILE */* __restrict  */)fp);
#line 169
  len = (int )tmp___1;
  }
#line 170
  if (len >= 0) {
#line 170
    *(str + len) = (char )'\000';
  }
  {
#line 172
  fclose(fp);
  }
#line 174
  return (str);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static int file_write(char *filename , char *data ) 
{ 
  FILE *fp ;
  int bytes_written ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 182
  bytes_written = 0;
#line 183
  tmp = strlen((char const   *)data);
#line 183
  len = (int )(tmp + 1UL);
#line 185
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
  }
#line 185
  if (! fp) {
#line 186
    return (-1);
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (len > 0)) {
#line 188
      goto while_break;
    }
    {
#line 190
    tmp___0 = fwrite((void const   */* __restrict  */)data, sizeof(char ), (size_t )len,
                     (FILE */* __restrict  */)fp);
#line 190
    bytes_written = (int )tmp___0;
#line 191
    len -= bytes_written;
#line 192
    data += bytes_written;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  fclose(fp);
  }
#line 197
  return (1);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static int is_wiki_format_char_or_space(char c ) 
{ 
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 203
  tmp = __ctype_b_loc();
  }
#line 203
  if ((int const   )*(*tmp + (int )c) & 8192) {
#line 203
    return (1);
  }
  {
#line 204
  tmp___0 = strchr("/*_-", (int )c);
  }
#line 204
  if (tmp___0) {
#line 204
    return (1);
  }
#line 205
  return (0);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_print_data_as_html(HttpResponse *res , char *raw_page_data ) 
{ 
  char *p ;
  char *q ;
  char *link___0 ;
  char *line ;
  int line_len ;
  int i ;
  int j ;
  int skip_chars ;
  int bold_on ;
  int italic_on ;
  int underline_on ;
  int strikethrough_on ;
  int open_para ;
  int pre_on ;
  int table_on ;
  struct __anonstruct_listtypes_65 listtypes[2] ;
  int header_level ;
  char *line_start ;
  int skip_to_content ;
  unsigned short const   **tmp ;
  int item_depth ;
  unsigned short const   **tmp___0 ;
  int n_spaces ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *tmp___15 ;
  int slashes ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  char const   *tmp___18 ;
  unsigned short const   **tmp___19 ;

  {
#line 211
  p = raw_page_data;
#line 212
  q = (char *)((void *)0);
#line 212
  link___0 = (char *)((void *)0);
#line 213
  line = (char *)((void *)0);
#line 218
  bold_on = 0;
#line 219
  italic_on = 0;
#line 220
  underline_on = 0;
#line 221
  strikethrough_on = 0;
#line 222
  open_para = 0;
#line 223
  pre_on = 0;
#line 224
  table_on = 0;
#line 230
  listtypes[0].ident = (char )'*';
#line 230
  listtypes[0].depth = 0;
#line 230
  listtypes[0].tag = (char *)"ul";
#line 230
  listtypes[1].ident = (char )'#';
#line 230
  listtypes[1].depth = 0;
#line 230
  listtypes[1].tag = (char *)"ol";
#line 236
  q = p;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 240
    line = get_line_from_string(& q, & line_len);
    }
#line 240
    if (! line) {
#line 240
      goto while_break;
    }
#line 242
    header_level = 0;
#line 243
    line_start = line;
#line 244
    skip_to_content = 0;
#line 249
    if (pre_on) {
      {
#line 249
      tmp = __ctype_b_loc();
      }
#line 249
      if (! ((int const   )*(*tmp + (int )*line) & 8192)) {
#line 249
        if ((int )*line != 0) {
          {
#line 252
          http_response_printf(res, "</pre>\n");
#line 253
          pre_on = 0;
          }
        }
      }
    }
#line 257
    i = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (i < 2)) {
#line 257
        goto while_break___0;
      }
#line 261
      if ((int )*line == (int )listtypes[i].ident) {
#line 261
        if ((int )*(line + 1) == (int )listtypes[i].ident) {
#line 261
          goto _L___0;
        } else {
          {
#line 261
          tmp___0 = __ctype_b_loc();
          }
#line 261
          if ((int const   )*(*tmp___0 + (int )*(line + 1)) & 8192) {
            _L___0: /* CIL Label */ 
#line 264
            item_depth = 0;
#line 266
            if (listtypes[! i].depth) {
#line 268
              j = 0;
              {
#line 268
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 268
                if (! (j < listtypes[! i].depth)) {
#line 268
                  goto while_break___1;
                }
                {
#line 269
                http_response_printf(res, "</%s>\n", listtypes[! i].tag);
#line 268
                j ++;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 270
              listtypes[! i].depth = 0;
            }
            {
#line 273
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 273
              if (! ((int )*line == (int )listtypes[i].ident)) {
#line 273
                goto while_break___2;
              }
#line 273
              line ++;
#line 273
              item_depth ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 275
            if (item_depth < listtypes[i].depth) {
#line 277
              j = 0;
              {
#line 277
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 277
                if (! (j < listtypes[i].depth - item_depth)) {
#line 277
                  goto while_break___3;
                }
                {
#line 278
                http_response_printf(res, "</%s>\n", listtypes[i].tag);
#line 277
                j ++;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
            } else {
#line 282
              j = 0;
              {
#line 282
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 282
                if (! (j < item_depth - listtypes[i].depth)) {
#line 282
                  goto while_break___4;
                }
                {
#line 283
                http_response_printf(res, "<%s>\n", listtypes[i].tag);
#line 282
                j ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            }
            {
#line 286
            http_response_printf(res, "<li>");
#line 288
            listtypes[i].depth = item_depth;
#line 290
            skip_to_content = 1;
            }
          } else {
#line 261
            goto _L;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 292
      if (listtypes[i].depth) {
#line 292
        if (! listtypes[! i].depth) {
#line 296
          j = 0;
          {
#line 296
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 296
            if (! (j < listtypes[i].depth)) {
#line 296
              goto while_break___5;
            }
            {
#line 297
            http_response_printf(res, "</%s>\n", listtypes[i].tag);
#line 296
            j ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 298
          listtypes[i].depth = 0;
        }
      }
#line 257
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 302
    if (skip_to_content) {
#line 303
      goto line_content;
    }
#line 307
    if ((int )*line == 124) {
#line 309
      if (table_on == 0) {
        {
#line 310
        http_response_printf(res, "<table class=\'wikitable\' cellspacing=\'0\' cellpadding=\'4\'>\n");
        }
      }
      {
#line 311
      line ++;
#line 313
      http_response_printf(res, "<tr><td>");
#line 315
      table_on = 1;
      }
#line 316
      goto line_content;
    } else
#line 320
    if (table_on) {
      {
#line 322
      http_response_printf(res, "</table>\n");
#line 323
      table_on = 0;
      }
    }
    {
#line 329
    tmp___2 = __ctype_b_loc();
    }
#line 329
    if ((int const   )*(*tmp___2 + (int )*line) & 8192) {
#line 329
      goto _L___1;
    } else
#line 329
    if ((int )*line == 0) {
      _L___1: /* CIL Label */ 
#line 331
      n_spaces = 0;
      {
#line 333
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 333
        tmp___1 = __ctype_b_loc();
        }
#line 333
        if (! ((int const   )*(*tmp___1 + (int )*line) & 8192)) {
#line 333
          goto while_break___6;
        }
#line 333
        line ++;
#line 333
        n_spaces ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 335
      if ((int )*line == 0) {
#line 337
        if (pre_on) {
          {
#line 339
          http_response_printf(res, "\n");
          }
#line 340
          goto while_continue;
        } else
#line 342
        if (open_para) {
          {
#line 344
          http_response_printf(res, "\n</p><p>\n");
          }
        } else {
          {
#line 348
          http_response_printf(res, "\n<p>\n");
#line 349
          open_para = 1;
          }
        }
      } else {
#line 354
        if (! pre_on) {
          {
#line 355
          http_response_printf(res, "<pre>\n");
          }
        }
        {
#line 356
        pre_on = 1;
#line 357
        line -= n_spaces - 1;
#line 359
        http_response_printf(res, "%s\n", line);
        }
#line 360
        goto while_continue;
      }
    } else
#line 363
    if ((int )*line == 61) {
      {
#line 365
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 365
        if (! ((int )*line == 61)) {
#line 365
          goto while_break___7;
        }
#line 366
        header_level ++;
#line 366
        line ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 368
      http_response_printf(res, "<h%d>", header_level);
#line 369
      p = line;
      }
    } else
#line 371
    if ((int )*line == 45) {
#line 371
      if ((int )*(line + 1) == 45) {
        {
#line 374
        http_response_printf(res, "<hr/>\n");
        }
        {
#line 375
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 375
          if (! ((int )*line == 45)) {
#line 375
            goto while_break___8;
          }
#line 375
          line ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
    line_content: 
#line 384
    p = line;
    {
#line 386
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 386
      if (! ((int )*line != 0)) {
#line 386
        goto while_break___9;
      }
#line 388
      if ((int )*line == 33) {
        {
#line 388
        tmp___19 = __ctype_b_loc();
        }
#line 388
        if ((int const   )*(*tmp___19 + (int )*(line + 1)) & 8192) {
#line 388
          goto _L___2;
        } else {
          {
#line 390
          *line = (char )'\000';
#line 391
          http_response_printf(res, "%s", p);
#line 392
          line ++;
#line 392
          p = line;
          }
          {
#line 394
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 394
            if ((int )*line != 0) {
              {
#line 394
              tmp___3 = __ctype_b_loc();
              }
#line 394
              if ((int const   )*(*tmp___3 + (int )*line) & 8192) {
#line 394
                goto while_break___10;
              }
            } else {
#line 394
              goto while_break___10;
            }
#line 394
            line ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 395
          if ((int )*line == 0) {
#line 396
            goto while_continue___9;
          }
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 398
        link___0 = check_for_link(line, & skip_chars);
        }
#line 398
        if ((unsigned long )link___0 != (unsigned long )((void *)0)) {
          {
#line 400
          http_response_printf(res, "%s", p);
#line 401
          http_response_printf(res, "%s", link___0);
#line 403
          line += skip_chars;
#line 404
          p = line;
          }
#line 406
          goto while_continue___9;
        } else
#line 412
        if ((int )*line == 42) {
#line 415
          if ((unsigned long )line_start != (unsigned long )line) {
            {
#line 415
            tmp___4 = is_wiki_format_char_or_space(*(line - 1));
            }
#line 415
            if (! tmp___4) {
#line 415
              if (! bold_on) {
#line 418
                line ++;
#line 418
                goto while_continue___9;
              }
            }
          }
          {
#line 420
          tmp___5 = __ctype_b_loc();
          }
#line 420
          if ((int const   )*(*tmp___5 + (int )*(line + 1)) & 8192) {
#line 420
            if (! bold_on) {
#line 421
              line ++;
#line 421
              goto while_continue___9;
            }
          }
#line 424
          *line = (char )'\000';
#line 425
          if (bold_on) {
#line 425
            tmp___6 = "</b>";
          } else {
#line 425
            tmp___6 = "<b>";
          }
          {
#line 425
          http_response_printf(res, "%s%s\n", p, tmp___6);
#line 426
          bold_on ^= 1;
#line 427
          p = line + 1;
          }
        } else
#line 430
        if ((int )*line == 95) {
#line 432
          if ((unsigned long )line_start != (unsigned long )line) {
            {
#line 432
            tmp___7 = is_wiki_format_char_or_space(*(line - 1));
            }
#line 432
            if (! tmp___7) {
#line 432
              if (! underline_on) {
#line 435
                line ++;
#line 435
                goto while_continue___9;
              }
            }
          }
          {
#line 437
          tmp___8 = __ctype_b_loc();
          }
#line 437
          if ((int const   )*(*tmp___8 + (int )*(line + 1)) & 8192) {
#line 437
            if (! underline_on) {
#line 438
              line ++;
#line 438
              goto while_continue___9;
            }
          }
#line 440
          *line = (char )'\000';
#line 441
          if (underline_on) {
#line 441
            tmp___9 = "</u>";
          } else {
#line 441
            tmp___9 = "<u>";
          }
          {
#line 441
          http_response_printf(res, "%s%s\n", p, tmp___9);
#line 442
          underline_on ^= 1;
#line 443
          p = line + 1;
          }
        } else
#line 445
        if ((int )*line == 45) {
#line 447
          if ((unsigned long )line_start != (unsigned long )line) {
            {
#line 447
            tmp___10 = is_wiki_format_char_or_space(*(line - 1));
            }
#line 447
            if (! tmp___10) {
#line 447
              if (! strikethrough_on) {
#line 450
                line ++;
#line 450
                goto while_continue___9;
              }
            }
          }
          {
#line 452
          tmp___11 = __ctype_b_loc();
          }
#line 452
          if ((int const   )*(*tmp___11 + (int )*(line + 1)) & 8192) {
#line 452
            if (! strikethrough_on) {
#line 453
              line ++;
#line 453
              goto while_continue___9;
            }
          }
#line 456
          *line = (char )'\000';
#line 457
          if (strikethrough_on) {
#line 457
            tmp___12 = "</del>";
          } else {
#line 457
            tmp___12 = "<del>";
          }
          {
#line 457
          http_response_printf(res, "%s%s\n", p, tmp___12);
#line 458
          strikethrough_on ^= 1;
#line 459
          p = line + 1;
          }
        } else
#line 463
        if ((int )*line == 47) {
#line 465
          if ((unsigned long )line_start != (unsigned long )line) {
            {
#line 465
            tmp___13 = is_wiki_format_char_or_space(*(line - 1));
            }
#line 465
            if (! tmp___13) {
#line 465
              if (! italic_on) {
#line 468
                line ++;
#line 468
                goto while_continue___9;
              }
            }
          }
          {
#line 470
          tmp___14 = __ctype_b_loc();
          }
#line 470
          if ((int const   )*(*tmp___14 + (int )*(line + 1)) & 8192) {
#line 470
            if (! italic_on) {
#line 471
              line ++;
#line 471
              goto while_continue___9;
            }
          }
#line 474
          if ((unsigned long )line_start != (unsigned long )line) {
            {
#line 474
            tmp___17 = __ctype_b_loc();
            }
#line 474
            if ((int const   )*(*tmp___17 + (int )*(line - 1)) & 8192) {
#line 474
              if (! italic_on) {
#line 476
                tmp___15 = line + 1;
#line 477
                slashes = 0;
                {
#line 480
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 480
                  if ((int )*tmp___15 != 0) {
                    {
#line 480
                    tmp___16 = __ctype_b_loc();
                    }
#line 480
                    if ((int const   )*(*tmp___16 + (int )*tmp___15) & 8192) {
#line 480
                      goto while_break___11;
                    }
                  } else {
#line 480
                    goto while_break___11;
                  }
#line 482
                  if ((int )*tmp___15 == 47) {
#line 482
                    slashes ++;
                  }
#line 483
                  tmp___15 ++;
                }
                while_break___11: /* CIL Label */ ;
                }
#line 486
                if (slashes > 1) {
#line 487
                  line = tmp___15;
#line 487
                  goto while_continue___9;
                } else
#line 486
                if (slashes == 1) {
#line 486
                  if ((int )*(tmp___15 - 1) != 47) {
#line 487
                    line = tmp___15;
#line 487
                    goto while_continue___9;
                  }
                }
              }
            }
          }
#line 490
          if ((int )*(line + 1) == 47) {
#line 491
            line ++;
          } else {
#line 495
            *line = (char )'\000';
#line 496
            if (italic_on) {
#line 496
              tmp___18 = "</i>";
            } else {
#line 496
              tmp___18 = "<i>";
            }
            {
#line 496
            http_response_printf(res, "%s%s\n", p, tmp___18);
#line 497
            italic_on ^= 1;
#line 498
            p = line + 1;
            }
          }
        } else
#line 501
        if ((int )*line == 124) {
#line 501
          if (table_on) {
            {
#line 503
            *line = (char )'\000';
#line 504
            http_response_printf(res, "%s", p);
#line 505
            http_response_printf(res, "</td><td>\n");
#line 506
            p = line + 1;
            }
          }
        }
      }
#line 509
      line ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 513
    if ((int )*p != 0) {
      {
#line 514
      http_response_printf(res, "%s", p);
      }
    }
#line 519
    if (listtypes[0].depth) {
      {
#line 520
      http_response_printf(res, "</li>");
      }
    }
#line 522
    if (listtypes[1].depth) {
      {
#line 523
      http_response_printf(res, "</li>");
      }
    }
#line 525
    if (table_on) {
      {
#line 526
      http_response_printf(res, "</td></tr>\n");
      }
    }
#line 528
    if (header_level) {
      {
#line 529
      http_response_printf(res, "</h%d>\n", header_level);
      }
    } else {
      {
#line 531
      http_response_printf(res, "\n");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  if (pre_on) {
    {
#line 539
    http_response_printf(res, "</pre>\n");
    }
  }
#line 542
  i = 0;
  {
#line 542
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 542
    if (! (i < listtypes[0].depth)) {
#line 542
      goto while_break___12;
    }
    {
#line 543
    http_response_printf(res, "</ul>\n");
#line 542
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 545
  i = 0;
  {
#line 545
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 545
    if (! (i < listtypes[1].depth)) {
#line 545
      goto while_break___13;
    }
    {
#line 546
    http_response_printf(res, "</ol>\n");
#line 545
    i ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 549
  if (open_para) {
    {
#line 550
    http_response_printf(res, "</p>\n");
    }
  }
#line 553
  if (table_on) {
    {
#line 554
    http_response_printf(res, "</table>\n");
    }
  }
#line 556
  return;
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
int wiki_redirect(HttpResponse *res , char *location ) 
{ 
  char *location_enc ;
  char *tmp ;
  int header_len ;
  size_t tmp___0 ;
  char *header ;
  void *tmp___1 ;

  {
  {
#line 561
  tmp = util_httpize((char const   *)location);
#line 561
  location_enc = tmp;
#line 563
  tmp___0 = strlen((char const   *)location_enc);
#line 563
  header_len = (int )(tmp___0 + 14UL);
#line 564
  tmp___1 = __builtin_alloca(sizeof(char ) * (unsigned long )header_len);
#line 564
  header = (char *)tmp___1;
#line 566
  snprintf((char */* __restrict  */)header, (size_t )header_len, (char const   */* __restrict  */)"Location: %s\r\n",
           location_enc);
#line 567
  free((void *)location_enc);
#line 569
  http_response_append_header(res, header);
#line 570
  http_response_printf(res, "<html>\n<p>Redirect to %s</p>\n</html>\n", location);
#line 572
  http_response_set_status(res, 302, (char *)"Moved Temporarily");
#line 573
  http_response_send(res);
#line 575
  exit(0);
  }
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_page(HttpResponse *res , char *wikitext , char *page ) 
{ 
  char *html_clean_wikitext ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 583
  html_clean_wikitext = (char *)((void *)0);
#line 585
  tmp = strlen((char const   *)wikitext);
#line 585
  http_response_printf_alloc_buffer(res, (int )(tmp * 2UL));
#line 587
  wiki_show_header(res, page, 1);
#line 589
  tmp___0 = strlen((char const   *)wikitext);
#line 589
  html_clean_wikitext = util_htmlize((char const   *)wikitext, (int )tmp___0);
#line 591
  wiki_print_data_as_html(res, html_clean_wikitext);
#line 593
  wiki_show_footer(res);
#line 595
  http_response_send(res);
#line 597
  exit(0);
  }
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_edit_page(HttpResponse *res , char *wikitext , char *page ) 
{ 


  {
  {
#line 604
  wiki_show_header(res, page, 0);
  }
#line 606
  if ((unsigned long )wikitext == (unsigned long )((void *)0)) {
#line 606
    wikitext = (char *)"";
  }
  {
#line 607
  http_response_printf(res, "<form method=POST action=\'%s\' name=\'editform\'>\n<textarea name=\'wikitext\' rows=\'20\' cols=\'80\' wrap=\'virtual\'>%s</textarea>\n<p><input type=\'submit\' value=\'Save\' title=\'[alt-k]\' accesskey=\'k\'></p>\n</form>\n<script language=\'JavaScript\'>\n<!--\n/* Give the textarea focus ...less mouse usage but may annoy people ?*/ \ndocument.editform.wikitext.focus()\ndocument.editform.wikitext.scrollTop = document.editform.wikitext.scrollHeight;\n//-->\n</script>\n",
                       page, wikitext);
#line 609
  wiki_show_footer(res);
#line 611
  http_response_send(res);
#line 612
  exit(0);
  }
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_create_page(HttpResponse *res ) 
{ 


  {
  {
#line 618
  wiki_show_header(res, (char *)"Create New Page", 0);
#line 619
  http_response_printf(res, "%s", "<form method=POST action=\'/Create\'>\n<input type=\'text\' name=\'title\' />\n<p><input type=\'submit\' value=\'Create\' /></p>\n</form>\n");
#line 620
  wiki_show_footer(res);
#line 622
  http_response_send(res);
#line 623
  exit(0);
  }
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
static int changes_compar(struct dirent  const  **d1 , struct dirent  const  **d2 ) 
{ 
  struct stat st1 ;
  struct stat st2 ;

  {
  {
#line 631
  stat((char const   */* __restrict  */)((*d1)->d_name), (struct stat */* __restrict  */)(& st1));
#line 633
  stat((char const   */* __restrict  */)((*d2)->d_name), (struct stat */* __restrict  */)(& st2));
  }
#line 635
  if (st1.st_mtim.tv_sec > st2.st_mtim.tv_sec) {
#line 636
    return (1);
  } else {
#line 638
    return (-1);
  }
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
WikiPageList **wiki_get_pages(int *n_pages , char *expr ) 
{ 
  WikiPageList **pages ;
  struct dirent **namelist ;
  int n ;
  int i ;
  struct stat st ;
  void *tmp ;
  int tmp___0 ;
  char *data ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 648
  i = 0;
#line 651
  n = scandir((char const   */* __restrict  */)".", (struct dirent ***/* __restrict  */)(& namelist),
              (int (*)(struct dirent  const  * ))0, (int (*)(struct dirent  const  ** ,
                                                             struct dirent  const  ** ))((void *)(& changes_compar)));
#line 653
  tmp = malloc(sizeof(WikiPageList *) * (unsigned long )n);
#line 653
  pages = (WikiPageList **)tmp;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    tmp___5 = n;
#line 655
    n --;
#line 655
    if (! tmp___5) {
#line 655
      goto while_break;
    }
#line 657
    if ((int )(*(namelist + n))->d_name[0] == 46) {
#line 659
      goto cleanup;
    } else {
      {
#line 657
      tmp___0 = strcmp((char const   *)((*(namelist + n))->d_name), "styles.css");
      }
#line 657
      if (! tmp___0) {
#line 659
        goto cleanup;
      }
    }
#line 661
    if ((unsigned long )expr != (unsigned long )((void *)0)) {
      {
#line 663
      data = (char *)((void *)0);
#line 664
      data = file_read((*(namelist + n))->d_name);
      }
#line 664
      if ((unsigned long )data != (unsigned long )((void *)0)) {
        {
#line 665
        tmp___2 = strcasestr((char const   *)data, (char const   *)expr);
        }
#line 665
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
          {
#line 666
          tmp___1 = strcmp((char const   *)((*(namelist + n))->d_name), (char const   *)expr);
          }
#line 666
          if (tmp___1 != 0) {
#line 667
            goto cleanup;
          }
        }
      }
    }
    {
#line 671
    stat((char const   */* __restrict  */)((*(namelist + n))->d_name), (struct stat */* __restrict  */)(& st));
    }
#line 674
    if ((st.st_mode & 61440U) == 32768U) {
      {
#line 674
      tmp___4 = access((char const   *)((*(namelist + n))->d_name), 4);
      }
#line 674
      if (tmp___4 == 0) {
        {
#line 676
        tmp___3 = malloc(sizeof(WikiPageList ));
#line 676
        *(pages + i) = (WikiPageList *)tmp___3;
#line 677
        (*(pages + i))->name = strdup((char const   *)((*(namelist + n))->d_name));
#line 678
        (*(pages + i))->mtime = st.st_mtim.tv_sec;
#line 680
        i ++;
        }
      }
    }
    cleanup: 
    {
#line 684
    free((void *)*(namelist + n));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 687
  *n_pages = i;
#line 689
  free((void *)namelist);
  }
#line 691
  if (i == 0) {
#line 691
    return ((WikiPageList **)((void *)0));
  }
#line 693
  return (pages);
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_changes_page(HttpResponse *res ) 
{ 
  WikiPageList **pages ;
  int n_pages ;
  int i ;
  struct tm *pTm ;
  char datebuf[64] ;

  {
  {
#line 699
  pages = (WikiPageList **)((void *)0);
#line 702
  wiki_show_header(res, (char *)"Changes", 0);
#line 704
  pages = wiki_get_pages(& n_pages, (char *)((void *)0));
#line 706
  i = 0;
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (i < n_pages)) {
#line 706
      goto while_break;
    }
    {
#line 711
    pTm = localtime((time_t const   *)(& (*(pages + i))->mtime));
#line 712
    strftime((char */* __restrict  */)(datebuf), sizeof(datebuf), (char const   */* __restrict  */)"%Y-%m-%d %H:%M",
             (struct tm  const  */* __restrict  */)pTm);
#line 713
    http_response_printf(res, "<a href=\'%s\'>%s</a> %s<br />\n", (*(pages + i))->name,
                         (*(pages + i))->name, datebuf);
#line 706
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 719
  wiki_show_footer(res);
#line 720
  http_response_send(res);
#line 721
  exit(0);
  }
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_search_results_page(HttpResponse *res , char *expr ) 
{ 
  WikiPageList **pages ;
  int n_pages ;
  int i ;
  size_t tmp ;

  {
#line 727
  pages = (WikiPageList **)((void *)0);
#line 730
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 732
    wiki_show_header(res, (char *)"Search", 0);
#line 733
    http_response_printf(res, "No search terms supplied.");
#line 734
    wiki_show_footer(res);
#line 735
    http_response_send(res);
#line 736
    exit(0);
    }
  } else {
    {
#line 730
    tmp = strlen((char const   *)expr);
    }
#line 730
    if (tmp == 0UL) {
      {
#line 732
      wiki_show_header(res, (char *)"Search", 0);
#line 733
      http_response_printf(res, "No search terms supplied.");
#line 734
      wiki_show_footer(res);
#line 735
      http_response_send(res);
#line 736
      exit(0);
      }
    }
  }
  {
#line 739
  pages = wiki_get_pages(& n_pages, expr);
  }
#line 741
  if (pages) {
    {
#line 743
    wiki_show_header(res, (char *)"Search", 0);
    }
#line 746
    if (n_pages == 1) {
      {
#line 747
      wiki_redirect(res, (*(pages + 0))->name);
      }
    }
#line 749
    i = 0;
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! (i < n_pages)) {
#line 749
        goto while_break;
      }
      {
#line 751
      http_response_printf(res, "<a href=\'%s\'>%s</a><br />\n", (*(pages + i))->name,
                           (*(pages + i))->name);
#line 749
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 758
    wiki_show_header(res, (char *)"Search", 0);
#line 759
    http_response_printf(res, "No matches");
    }
  }
  {
#line 762
  wiki_show_footer(res);
#line 763
  http_response_send(res);
#line 765
  exit(0);
  }
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_template(HttpResponse *res , char *template_data ) 
{ 


  {
#line 782
  return;
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_header(HttpResponse *res , char *page_title , int want_edit ) 
{ 
  char const   *tmp ;

  {
  {
#line 787
  http_response_printf(res, "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\'http://www.w3.org/1999/xhtml\'>\n<head>\n<meta http-equiv=\'Content-Type\' content=\'text/html; charset=utf-8\' />\n<link rel=\'SHORTCUT ICON\' href=\'/favicon.ico\' />\n<link media=\'all\' href=\'/styles.css\' rel=\'stylesheet\' type=\'text/css\' />\n<title>%s</title>\n</head>\n<body>\n",
                       page_title);
  }
#line 800
  if (want_edit) {
#line 800
    tmp = " ( <a href=\'?edit\' title=\'Edit this wiki page contents. [alt-j]\' accesskey=\'j\'>Edit</a> ) ";
  } else {
#line 800
    tmp = "";
  }
  {
#line 800
  http_response_printf(res, "<div id=\'header\'>\n<form method=\'get\' action=\'/Search\'>\n<table border=\'0\' width=\'100%%\'>\n<tr>\n<td align=\'left\' ><strong>%s</strong> %s</td>\n<td align=\'right\' >\n<a href=\'/WikiHome\' title=\'Visit Wiki home page. [alt-z]\' accesskey=\'z\'>Home</a> |\n<a href=\'/Changes\' title=\'List recent changes in the wiki. [alt-r]\' accesskey=\'r\' >Changes</a> | \n<a href=\'/Create\' title=\'Create a new wiki page by title. [alt-c]\' accesskey=\'c\'>New</a> | \n<a href=\'/WikiHelp\' title=\'Get help on wiki usage and formatting.\'>Help</a> |\n<input type=\'text\' name=\'expr\' size=\'15\' title=\'Enter text to search for and press return.\' /> </td>\n</tr>\n</table>\n</form>\n</div>\n<div id=\'wikidata\'>\n",
                       page_title, tmp);
  }
#line 802
  return;
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_show_footer(HttpResponse *res ) 
{ 


  {
  {
#line 807
  http_response_printf(res, "%s", "</div><div id=\'footer\'>DidiWiki, Version: 0.5</div>\n");
#line 809
  http_response_printf(res, "</body>\n</html>\n");
  }
#line 813
  return;
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
int page_name_is_good(char *page_name ) 
{ 
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 822
  if (! page_name) {
#line 823
    return (0);
  }
  {
#line 825
  tmp = __ctype_b_loc();
  }
#line 825
  if (! ((int const   )*(*tmp + (int )*(page_name + 0)) & 8)) {
#line 826
    return (0);
  }
  {
#line 828
  tmp___0 = strstr((char const   *)page_name, "..");
  }
#line 828
  if (tmp___0) {
#line 829
    return (0);
  }
#line 831
  return (1);
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_handle_rest_call(HttpRequest *req , HttpResponse *res , char *func ) 
{ 
  char *page ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *wikitext ;
  char *page___0 ;
  int tmp___3 ;
  char *page___1 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *page___2 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  WikiPageList **pages ;
  int n_pages ;
  int i ;
  char *expr ;
  char *tmp___10 ;
  struct tm *pTm ;
  char datebuf[64] ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 840
  if ((unsigned long )func != (unsigned long )((void *)0)) {
#line 840
    if ((int )*func != 0) {
      {
#line 842
      tmp___16 = strcmp((char const   *)func, "page/get");
      }
#line 842
      if (tmp___16) {
        {
#line 856
        tmp___15 = strcmp((char const   *)func, "page/set");
        }
#line 856
        if (tmp___15) {
          {
#line 871
          tmp___14 = strcmp((char const   *)func, "page/delete");
          }
#line 871
          if (tmp___14) {
            {
#line 885
            tmp___13 = strcmp((char const   *)func, "page/exists");
            }
#line 885
            if (tmp___13) {
              {
#line 899
              tmp___11 = strcmp((char const   *)func, "pages");
              }
#line 899
              if (tmp___11) {
                {
#line 899
                tmp___12 = strcmp((char const   *)func, "search");
                }
#line 899
                if (! tmp___12) {
                  _L: /* CIL Label */ 
                  {
#line 901
                  pages = (WikiPageList **)((void *)0);
#line 903
                  tmp___10 = http_request_param_get(req, (char *)"expr");
#line 903
                  expr = tmp___10;
                  }
#line 905
                  if ((unsigned long )expr == (unsigned long )((void *)0)) {
                    {
#line 906
                    expr = http_request_get_query_string(req);
                    }
                  }
                  {
#line 908
                  pages = wiki_get_pages(& n_pages, expr);
                  }
#line 910
                  if (pages) {
#line 912
                    i = 0;
                    {
#line 912
                    while (1) {
                      while_continue: /* CIL Label */ ;
#line 912
                      if (! (i < n_pages)) {
#line 912
                        goto while_break;
                      }
                      {
#line 917
                      pTm = localtime((time_t const   *)(& (*(pages + i))->mtime));
#line 918
                      strftime((char */* __restrict  */)(datebuf), sizeof(datebuf),
                               (char const   */* __restrict  */)"%Y-%m-%d %H:%M",
                               (struct tm  const  */* __restrict  */)pTm);
#line 919
                      http_response_printf(res, "%s\t%s\n", (*(pages + i))->name,
                                           datebuf);
#line 912
                      i ++;
                      }
                    }
                    while_break: /* CIL Label */ ;
                    }
                    {
#line 922
                    http_response_send(res);
                    }
#line 923
                    return;
                  }
                }
              } else {
#line 899
                goto _L;
              }
            } else {
              {
#line 887
              tmp___7 = http_request_param_get(req, (char *)"page");
#line 887
              page___2 = tmp___7;
              }
#line 889
              if ((unsigned long )page___2 == (unsigned long )((void *)0)) {
                {
#line 890
                page___2 = http_request_get_query_string(req);
                }
              }
#line 892
              if (page___2) {
                {
#line 892
                tmp___8 = page_name_is_good(page___2);
                }
#line 892
                if (tmp___8) {
                  {
#line 892
                  tmp___9 = access((char const   *)page___2, 4);
                  }
#line 892
                  if (tmp___9 == 0) {
                    {
#line 894
                    http_response_printf(res, "success");
#line 895
                    http_response_send(res);
                    }
#line 896
                    return;
                  }
                }
              }
            }
          } else {
            {
#line 873
            tmp___4 = http_request_param_get(req, (char *)"page");
#line 873
            page___1 = tmp___4;
            }
#line 875
            if ((unsigned long )page___1 == (unsigned long )((void *)0)) {
              {
#line 876
              page___1 = http_request_get_query_string(req);
              }
            }
#line 878
            if (page___1) {
              {
#line 878
              tmp___5 = page_name_is_good(page___1);
              }
#line 878
              if (tmp___5) {
                {
#line 878
                tmp___6 = unlink((char const   *)page___1);
                }
#line 878
                if (tmp___6 > 0) {
                  {
#line 880
                  http_response_printf(res, "success");
#line 881
                  http_response_send(res);
                  }
#line 882
                  return;
                }
              }
            }
          }
        } else {
          {
#line 858
          wikitext = (char *)((void *)0);
#line 858
          page___0 = (char *)((void *)0);
#line 859
          wikitext = http_request_param_get(req, (char *)"text");
          }
#line 859
          if ((unsigned long )wikitext != (unsigned long )((void *)0)) {
            {
#line 859
            page___0 = http_request_param_get(req, (char *)"page");
            }
#line 859
            if ((unsigned long )page___0 != (unsigned long )((void *)0)) {
              {
#line 862
              tmp___3 = page_name_is_good(page___0);
              }
#line 862
              if (tmp___3) {
                {
#line 864
                file_write(page___0, wikitext);
#line 865
                http_response_printf(res, "success");
#line 866
                http_response_send(res);
                }
#line 867
                return;
              }
            }
          }
        }
      } else {
        {
#line 844
        tmp = http_request_param_get(req, (char *)"page");
#line 844
        page = tmp;
        }
#line 846
        if ((unsigned long )page == (unsigned long )((void *)0)) {
          {
#line 847
          page = http_request_get_query_string(req);
          }
        }
#line 849
        if (page) {
          {
#line 849
          tmp___1 = page_name_is_good(page);
          }
#line 849
          if (tmp___1) {
            {
#line 849
            tmp___2 = access((char const   *)page, 4);
            }
#line 849
            if (tmp___2 == 0) {
              {
#line 851
              tmp___0 = file_read(page);
#line 851
              http_response_printf(res, "%s", tmp___0);
#line 852
              http_response_send(res);
              }
#line 853
              return;
            }
          }
        }
      }
    }
  }
  {
#line 928
  http_response_set_status(res, 500, (char *)"Error");
#line 929
  http_response_printf(res, "<html><body>Failed</body></html>\n");
#line 930
  http_response_send(res);
  }
#line 932
  return;
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
void wiki_handle_http_request(HttpRequest *req ) 
{ 
  HttpResponse *res ;
  HttpResponse *tmp ;
  char *page ;
  char *tmp___0 ;
  char *command ;
  char *tmp___1 ;
  char *wikitext ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *p ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char buf[1024] ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 940
  tmp = http_response_new(req);
#line 940
  res = tmp;
#line 941
  tmp___0 = http_request_get_path_info(req);
#line 941
  page = tmp___0;
#line 942
  tmp___1 = http_request_get_query_string(req);
#line 942
  command = tmp___1;
#line 943
  wikitext = (char *)"";
#line 945
  util_dehttpize(page);
#line 948
  tmp___3 = strcmp((char const   *)page, "/");
  }
#line 948
  if (! tmp___3) {
    {
#line 950
    tmp___2 = access("WikiHome", 4);
    }
#line 950
    if (tmp___2 != 0) {
      {
#line 951
      wiki_redirect(res, (char *)"/WikiHome?create");
      }
    }
#line 952
    page = (char *)"/WikiHome";
  }
  {
#line 955
  tmp___4 = strcmp((char const   *)page, "/styles.css");
  }
#line 955
  if (! tmp___4) {
    {
#line 958
    http_response_set_content_type(res, (char *)"text/css");
#line 959
    http_response_printf(res, "%s", CssData);
#line 960
    http_response_send(res);
#line 961
    exit(0);
    }
  }
  {
#line 964
  tmp___5 = strcmp((char const   *)page, "/favicon.ico");
  }
#line 964
  if (! tmp___5) {
    {
#line 967
    http_response_set_content_type(res, (char *)"image/ico");
#line 968
    http_response_set_data(res, (void *)(FaviconData), (int )FaviconDataLen);
#line 969
    http_response_send(res);
#line 970
    exit(0);
    }
  }
  {
#line 974
  page ++;
#line 976
  tmp___6 = strncmp((char const   *)page, "api/", (size_t )4);
  }
#line 976
  if (! tmp___6) {
#line 980
    page += 4;
#line 981
    p = page;
    {
#line 981
    while (1) {
      while_continue: /* CIL Label */ ;
#line 981
      if (! ((int )*p != 0)) {
#line 981
        goto while_break;
      }
#line 982
      if ((int )*p == 63) {
#line 982
        *p = (char )'\000';
#line 982
        goto while_break;
      }
#line 981
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 984
    wiki_handle_rest_call(req, res, page);
#line 985
    exit(0);
    }
  }
  {
#line 991
  tmp___7 = page_name_is_good(page);
  }
#line 991
  if (! tmp___7) {
    {
#line 993
    http_response_set_status(res, 404, (char *)"Not Found");
#line 994
    http_response_printf(res, "<html><body>404 Not Found</body></html>\n");
#line 995
    http_response_send(res);
#line 996
    exit(0);
    }
  }
  {
#line 999
  tmp___17 = strcmp((char const   *)page, "Changes");
  }
#line 999
  if (tmp___17) {
    {
#line 1004
    tmp___16 = strcmp((char const   *)page, "Search");
    }
#line 1004
    if (tmp___16) {
      {
#line 1008
      tmp___15 = strcmp((char const   *)page, "Create");
      }
#line 1008
      if (tmp___15) {
        {
#line 1024
        wikitext = http_request_param_get(req, (char *)"wikitext");
        }
#line 1024
        if ((unsigned long )wikitext != (unsigned long )((void *)0)) {
          {
#line 1026
          file_write(page, wikitext);
#line 1029
          tmp___10 = http_request_get_ip_src(req);
#line 1029
          syslog((16 << 3) | 6, "page %s modified from %s", page, tmp___10);
          }
        }
        {
#line 1032
        tmp___14 = access((char const   *)page, 4);
        }
#line 1032
        if (tmp___14 == 0) {
          {
#line 1034
          wikitext = file_read(page);
#line 1037
          tmp___11 = http_request_get_ip_src(req);
#line 1037
          syslog((16 << 3) | 6, "page %s viewed from %s", page, tmp___11);
#line 1039
          tmp___12 = strcmp((char const   *)command, "edit");
          }
#line 1039
          if (tmp___12) {
            {
#line 1046
            wiki_show_page(res, wikitext, page);
            }
          } else {
            {
#line 1042
            wiki_show_edit_page(res, wikitext, page);
            }
          }
        } else {
          {
#line 1051
          tmp___13 = strcmp((char const   *)command, "create");
          }
#line 1051
          if (tmp___13) {
            {
#line 1058
            snprintf((char */* __restrict  */)(buf), (size_t )1024, (char const   */* __restrict  */)"%s?create",
                     page);
#line 1059
            wiki_redirect(res, buf);
            }
          } else {
            {
#line 1053
            wiki_show_edit_page(res, (char *)((void *)0), page);
            }
          }
        }
      } else {
        {
#line 1010
        wikitext = http_request_param_get(req, (char *)"title");
        }
#line 1010
        if ((unsigned long )wikitext != (unsigned long )((void *)0)) {
          {
#line 1013
          tmp___9 = http_request_param_get(req, (char *)"title");
#line 1013
          wiki_redirect(res, tmp___9);
          }
        } else {
          {
#line 1018
          wiki_show_create_page(res);
          }
        }
      }
    } else {
      {
#line 1006
      tmp___8 = http_request_param_get(req, (char *)"expr");
#line 1006
      wiki_show_search_results_page(res, tmp___8);
      }
    }
  } else {
    {
#line 1002
    wiki_show_changes_page(res);
    }
  }
#line 1064
  return;
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/wiki.c"
int wiki_init(char *didiwiki_home ) 
{ 
  char datadir[512] ;
  unsigned int tmp ;
  struct stat st ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1069
  datadir[0] = (char)0;
#line 1069
  tmp = 1U;
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (tmp >= 512U) {
#line 1069
      goto while_break;
    }
#line 1069
    datadir[tmp] = (char)0;
#line 1069
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1072
  if (didiwiki_home) {
    {
#line 1074
    snprintf((char */* __restrict  */)(datadir), (size_t )512, (char const   */* __restrict  */)"%s",
             didiwiki_home);
    }
  } else {
    {
#line 1078
    tmp___3 = getenv("DIDIWIKIHOME");
    }
#line 1078
    if (tmp___3) {
      {
#line 1080
      tmp___0 = getenv("DIDIWIKIHOME");
#line 1080
      snprintf((char */* __restrict  */)(datadir), (size_t )512, (char const   */* __restrict  */)"%s",
               tmp___0);
      }
    } else {
      {
#line 1084
      tmp___1 = getenv("HOME");
      }
#line 1084
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 1086
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to get home directory, is HOME set?\n");
#line 1087
        exit(1);
        }
      }
      {
#line 1090
      tmp___2 = getenv("HOME");
#line 1090
      snprintf((char */* __restrict  */)(datadir), (size_t )512, (char const   */* __restrict  */)"%s/.didiwiki",
               tmp___2);
      }
    }
  }
  {
#line 1095
  tmp___5 = stat((char const   */* __restrict  */)(datadir), (struct stat */* __restrict  */)(& st));
  }
#line 1095
  if (tmp___5 != 0) {
    {
#line 1097
    tmp___4 = mkdir((char const   *)(datadir), (__mode_t )493);
    }
#line 1097
    if (tmp___4 == -1) {
      {
#line 1099
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to create \'%s\', giving up.\n",
              datadir);
#line 1100
      exit(1);
      }
    }
  }
  {
#line 1104
  chdir((char const   *)(datadir));
#line 1108
  tmp___6 = access("WikiHelp", 4);
  }
#line 1108
  if (tmp___6 != 0) {
    {
#line 1109
    file_write((char *)"WikiHelp", (char *)"=Quick Guide \nTop toolbar usage\n* [?edit Edit] Allows you to edit pages ( see below for rules )\n* [/WikiHome Home] Takes you to the wiki front page\n* [/Changes Changes] Lists the pages changed by date\n* [/Create New] Creates a new wiki page by title\n* [/WikiHelp Help] Takes you to this help page\n\nUse the text entry box to perform a very simple keyword search on the\nWiki contents. Hit return to activate the search.\n\nUse the WikiSandbox to practice formatting.\n\n----\n=Formatting rules\n\n=Top Level Heading\n  =Top Level Heading (H1)\n==Second Level Heading\n  ==Second Level Heading (H2)\nMore levels \n  === (H3), ==== (H4) etc\n----\nThe horizontal lines in this page are made with 4 or more dashes:\n ---- Horizonal line\n----\n\nParagraphs are separated by an empty line\n\nLike this. Another paragraph.\n\n Paragraphs are separated by a blank line.\n\n Like this. Another paragraph.\n----\n*Bold text*, /italic text/, _underscore text_ and -strikethrough-.\n  *Bold text*, /italic text/, _underscore text_ and -strikethrough-.\n/*Combination of bold and italics*/\n  /*Combination of bold and italics*/\n----\n\nWikiLinks are formed by two or more words in /camelcase/.\n WikiLinks are formed by two or more words in /camelcase/.\nExternal links begin with http://, like http://www.freepan.org\n External links begin with http://, like http://www.freepan.org\nForced wiki [links] are a alphanumeric string surrounded by square brackets.\n Forced wiki [links] are a alphanumeric string surrounded by square brackets.\nNamed http links have text with an !http:// link inside, like [http://www.freepan.org FreePAN]\n Named http links have text with an !http:// link inside, like [http://www.freepan.org FreePAN]\nSometimes !WordsShouldNotMakeAWikiLink so put a \'! \' beforehand.\n Sometimes !WordsShouldNotMakeAWikiLink so put a \'! \' beforehand.\nSame thing with !http://foobar.com\n Same thing with !http://foobar.com\n----\n\nLinks to images display the image:\n\nhttp://www.google.com/images/logo.gif\n http://www.google.com/images/logo.gif\n----\nUnordered lists begin with a \'* \'. The number of asterisks determines the level:\n* foo\n* bar\n** boom\n** bam\n* baz\n\n  * foo\n  * bar\n  ** boom\n  ** bam\n  * baz\n\nOrdered lists work the same, but use a \'#\'\n----\nTables begin the line with a \'|\' and before every new column after.\n\n| row:1,col:1 | row:1,col:2\n| row:2,col:1 | row:2,col:2\n | row:1,col:1 | row:1,col:2\n | row:2,col:1 | row:2,col:2\n---\n<Inline> <html> <is> <escaped>.\n\n----\nLines prefixed with a space are unformatted ( Like examples on this page )\n\n----\n");
    }
  }
  {
#line 1111
  tmp___7 = access("WikiHome", 4);
  }
#line 1111
  if (tmp___7 != 0) {
    {
#line 1112
    file_write((char *)"WikiHome", (char *)"==Welcome to !DidiWiki\n/!DidiWiki / is a small and simple [http://en.wikipedia.org/wiki/Wiki WikiWikiWeb]\nimplementation. It\'s intended for personal note-taking, \"to do\" lists, and any other uses you can think of.\n\nTo learn more about what a [http://www.c2.com/cgi/wiki?WikiWikiWeb WikiWikiWeb] is, read about [http://www.c2.com/cgi/wiki?WhyWikiWorks WhyWikiWorks] and the [http://www.c2.com/cgi/wiki?WikiNature WikiNature]. Also, consult the [http://www.c2.com/cgi/wiki?WikiWikiWebFaq WikiWikiWebFaq].\n\nFor an example of how a !DidiWiki entry looks in text form you can [?edit edit] this page. Also see WikiHelp for infomation on usage and formatting rules. Use The WikiSandbox to experiment.\n\n/!DidiWiki / is written by [mailto://mallum@o-hand.com Matthew Allum] in C and is free software, released under the [http://www.gnu.org GNU] [http://www.gnu.org/copyleft/gpl.html GPL]. It uses a formatting style similar to that of [http://www.kwiki.org kwiki] and some webserver code from [http://www.cvstrac.org cvstrac].\n");
    }
  }
  {
#line 1116
  tmp___8 = access("styles.css", 4);
  }
#line 1116
  if (tmp___8 == 0) {
    {
#line 1117
    CssData = file_read((char *)"styles.css");
    }
  }
#line 1119
  return (1);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
HttpRequest *http_server(struct in_addr address , int iPort ) ;
#line 11
HttpRequest *http_request_new(void) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/didi.c"
static int debug  ;
#line 5 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/didi.c"
int usage(void) 
{ 


  {
  {
#line 8
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: didiwiki [options]\n");
#line 9
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -d, --debug           : debug mode, listens to requests from stdin\n");
#line 10
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -h, --home   <path>   : specify didiwiki\'s home directory\n");
#line 11
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -l, --listen <ipaddr> : specify IP address\n");
#line 12
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   -p, --port   <port>   : specify port number \n");
#line 13
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       --help            : display this help message\n");
#line 14
  exit(1);
  }
}
}
#line 34
int main(int argc , char **argv ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/didi.c"
static struct option long_options[6]  = {      {"debug", 0, (int *)0, 'd'}, 
        {"listen", 1, (int *)0, 'l'}, 
        {"port", 1, (int *)0, 'p'}, 
        {"home", 1, (int *)0, 'h'}, 
        {"help", 0, (int *)0, 10}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 17 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/didi.c"
int main(int argc , char **argv ) 
{ 
  HttpRequest *req ;
  int port ;
  int c ;
  char *didiwiki_home ;
  struct in_addr address ;
  int option_index ;
  int tmp ;

  {
  {
#line 20
  req = (HttpRequest *)((void *)0);
#line 21
  port = 8000;
#line 23
  didiwiki_home = (char *)((void *)0);
#line 27
  debug = 0;
#line 30
  address.s_addr = inet_addr("0.0.0.0");
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    option_index = 0;
#line 47
    c = getopt_long(argc, (char * const  *)argv, "dl:p:h:", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 50
    if (c == -1) {
#line 51
      goto while_break;
    }
    {
#line 55
    if (c == 0) {
#line 55
      goto case_0;
    }
#line 58
    if (c == 100) {
#line 58
      goto case_100;
    }
#line 62
    if (c == 112) {
#line 62
      goto case_112;
    }
#line 66
    if (c == 104) {
#line 66
      goto case_104;
    }
#line 70
    if (c == 108) {
#line 70
      goto case_108;
    }
#line 78
    if (c == 10) {
#line 78
      goto case_10;
    }
#line 82
    goto switch_default;
    case_0: /* CIL Label */ 
#line 56
    goto switch_break;
    case_100: /* CIL Label */ 
#line 59
    debug = 1;
#line 60
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 63
    port = atoi((char const   *)optarg);
    }
#line 64
    goto switch_break;
    case_104: /* CIL Label */ 
#line 67
    didiwiki_home = optarg;
#line 68
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 71
    tmp = inet_aton((char const   *)optarg, & address);
    }
#line 71
    if (tmp == 0) {
      {
#line 72
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"didiwiki: invalid ip address \"%s\"\n",
              optarg);
#line 73
      exit(1);
      }
    } else {
      {
#line 75
      address.s_addr = inet_addr((char const   *)optarg);
      }
    }
#line 76
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 79
    usage();
    }
#line 80
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 83
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  wiki_init(didiwiki_home);
  }
#line 89
  if (debug) {
    {
#line 91
    req = http_request_new();
    }
  } else {
    {
#line 94
    req = http_server(address, port);
    }
  }
  {
#line 97
  wiki_handle_http_request(req);
  }
#line 99
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 399 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.h"
char *util_mprintf(char const   *format  , ...) ;
#line 7
int util_ascii_to_hex(int c ) ;
#line 13
char *util_extract_token(char *input , char **leftOver ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
char *util_mprintf(char const   *format  , ...) 
{ 
  va_list ap ;
  char *buf ;

  {
  {
#line 24
  buf = (char *)((void *)0);
#line 26
  __builtin_va_start(ap, format);
#line 27
  vasprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)format,
            ap);
#line 28
  __builtin_va_end(ap);
  }
#line 30
  return (buf);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
int util_ascii_to_hex(int c ) 
{ 


  {
#line 40
  if (c >= 97) {
#line 40
    if (c <= 102) {
#line 41
      c += -87;
    } else {
#line 40
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 42
  if (c >= 65) {
#line 42
    if (c <= 70) {
#line 43
      c += -55;
    } else {
#line 42
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 44
  if (c >= 48) {
#line 44
    if (c <= 57) {
#line 45
      c -= 48;
    } else {
#line 47
      c = 0;
    }
  } else {
#line 47
    c = 0;
  }
#line 49
  return (c);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
void util_dehttpize(char *z ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 59
  i = 0;
#line 59
  j = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! *(z + i)) {
#line 61
      goto while_break;
    }
    {
#line 65
    if ((int )*(z + i) == 37) {
#line 65
      goto case_37;
    }
#line 72
    if ((int )*(z + i) == 43) {
#line 72
      goto case_43;
    }
#line 75
    goto switch_default;
    case_37: /* CIL Label */ 
#line 66
    if (*(z + (i + 1))) {
#line 66
      if (*(z + (i + 2))) {
        {
#line 67
        tmp = util_ascii_to_hex((int )*(z + (i + 1)));
#line 67
        *(z + j) = (char )(tmp << 4);
#line 68
        tmp___0 = util_ascii_to_hex((int )*(z + (i + 2)));
#line 68
        *(z + j) = (char )((int )*(z + j) | tmp___0);
#line 69
        i += 2;
        }
      }
    }
#line 71
    goto switch_break;
    case_43: /* CIL Label */ 
#line 73
    *(z + j) = (char )' ';
#line 74
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 76
    *(z + j) = *(z + i);
#line 77
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 79
    i ++;
#line 79
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  *(z + j) = (char)0;
#line 82
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
char *util_extract_token(char *input , char **leftOver ) 
{ 
  char *result ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 93
  result = (char *)0;
#line 95
  if ((unsigned long )input == (unsigned long )((char *)0)) {
#line 97
    if (leftOver) {
#line 97
      *leftOver = (char *)0;
    }
#line 98
    return ((char *)0);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = __ctype_b_loc();
    }
#line 101
    if (! ((int const   )*(*tmp + (int )*input) & 8192)) {
#line 101
      goto while_break;
    }
#line 102
    input ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  result = input;
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (*input) {
      {
#line 106
      tmp___0 = __ctype_b_loc();
      }
#line 106
      if ((int const   )*(*tmp___0 + (int )*input) & 8192) {
#line 106
        goto while_break___0;
      }
    } else {
#line 106
      goto while_break___0;
    }
#line 107
    input ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (*input) {
#line 111
    *input = (char)0;
#line 112
    input ++;
    {
#line 113
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 113
      tmp___1 = __ctype_b_loc();
      }
#line 113
      if (! ((int const   )*(*tmp___1 + (int )*input) & 8192)) {
#line 113
        goto while_break___1;
      }
#line 113
      input ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 116
  if (leftOver) {
#line 117
    *leftOver = input;
  }
#line 119
  return (result);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
char *util_htmlize(char const   *in , int n ) 
{ 
  int c ;
  int i ;
  int count ;
  char *out ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 136
  i = 0;
#line 137
  count = 0;
#line 140
  if (n < 0) {
    {
#line 140
    tmp = strlen(in);
#line 140
    n = (int )tmp;
    }
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (i < n) {
#line 141
      c = (int )*(in + i);
#line 141
      if (! (c != 0)) {
#line 141
        goto while_break;
      }
    } else {
#line 141
      goto while_break;
    }
    {
#line 143
    if (c == 60) {
#line 143
      goto case_60;
    }
#line 144
    if (c == 62) {
#line 144
      goto case_62;
    }
#line 145
    if (c == 38) {
#line 145
      goto case_38;
    }
#line 146
    if (c == 34) {
#line 146
      goto case_34;
    }
#line 147
    goto switch_default;
    case_60: /* CIL Label */ 
#line 143
    count += 4;
#line 143
    goto switch_break;
    case_62: /* CIL Label */ 
#line 144
    count += 4;
#line 144
    goto switch_break;
    case_38: /* CIL Label */ 
#line 145
    count += 5;
#line 145
    goto switch_break;
    case_34: /* CIL Label */ 
#line 146
    count += 6;
#line 146
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 147
    count ++;
#line 147
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  i = 0;
#line 152
  tmp___0 = malloc((size_t )(count + 1));
#line 152
  out = (char *)tmp___0;
  }
#line 153
  if ((unsigned long )out == (unsigned long )((char *)0)) {
#line 153
    return ((char *)0);
  }
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 154
    tmp___21 = n;
#line 154
    n --;
#line 154
    if (tmp___21 > 0) {
#line 154
      c = (int )*in;
#line 154
      if (! (c != 0)) {
#line 154
        goto while_break___0;
      }
    } else {
#line 154
      goto while_break___0;
    }
    {
#line 156
    if (c == 60) {
#line 156
      goto case_60___0;
    }
#line 162
    if (c == 62) {
#line 162
      goto case_62___0;
    }
#line 168
    if (c == 38) {
#line 168
      goto case_38___0;
    }
#line 175
    if (c == 34) {
#line 175
      goto case_34___0;
    }
#line 183
    goto switch_default___0;
    case_60___0: /* CIL Label */ 
#line 157
    tmp___1 = i;
#line 157
    i ++;
#line 157
    *(out + tmp___1) = (char )'&';
#line 158
    tmp___2 = i;
#line 158
    i ++;
#line 158
    *(out + tmp___2) = (char )'l';
#line 159
    tmp___3 = i;
#line 159
    i ++;
#line 159
    *(out + tmp___3) = (char )'t';
#line 160
    tmp___4 = i;
#line 160
    i ++;
#line 160
    *(out + tmp___4) = (char )';';
#line 161
    goto switch_break___0;
    case_62___0: /* CIL Label */ 
#line 163
    tmp___5 = i;
#line 163
    i ++;
#line 163
    *(out + tmp___5) = (char )'&';
#line 164
    tmp___6 = i;
#line 164
    i ++;
#line 164
    *(out + tmp___6) = (char )'g';
#line 165
    tmp___7 = i;
#line 165
    i ++;
#line 165
    *(out + tmp___7) = (char )'t';
#line 166
    tmp___8 = i;
#line 166
    i ++;
#line 166
    *(out + tmp___8) = (char )';';
#line 167
    goto switch_break___0;
    case_38___0: /* CIL Label */ 
#line 169
    tmp___9 = i;
#line 169
    i ++;
#line 169
    *(out + tmp___9) = (char )'&';
#line 170
    tmp___10 = i;
#line 170
    i ++;
#line 170
    *(out + tmp___10) = (char )'a';
#line 171
    tmp___11 = i;
#line 171
    i ++;
#line 171
    *(out + tmp___11) = (char )'m';
#line 172
    tmp___12 = i;
#line 172
    i ++;
#line 172
    *(out + tmp___12) = (char )'p';
#line 173
    tmp___13 = i;
#line 173
    i ++;
#line 173
    *(out + tmp___13) = (char )';';
#line 174
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
#line 176
    tmp___14 = i;
#line 176
    i ++;
#line 176
    *(out + tmp___14) = (char )'&';
#line 177
    tmp___15 = i;
#line 177
    i ++;
#line 177
    *(out + tmp___15) = (char )'q';
#line 178
    tmp___16 = i;
#line 178
    i ++;
#line 178
    *(out + tmp___16) = (char )'u';
#line 179
    tmp___17 = i;
#line 179
    i ++;
#line 179
    *(out + tmp___17) = (char )'o';
#line 180
    tmp___18 = i;
#line 180
    i ++;
#line 180
    *(out + tmp___18) = (char )'t';
#line 181
    tmp___19 = i;
#line 181
    i ++;
#line 181
    *(out + tmp___19) = (char )';';
#line 182
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 184
    tmp___20 = i;
#line 184
    i ++;
#line 184
    *(out + tmp___20) = (char )c;
#line 185
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 187
    in ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 189
  *(out + i) = (char)0;
#line 190
  return (out);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
int validURIchar(char c ) 
{ 
  int tmp ;

  {
#line 196
  if ((int )c >= 97) {
#line 196
    if ((int )c <= 122) {
#line 196
      tmp = 1;
    } else {
#line 196
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 196
  if ((int )c >= 65) {
#line 196
    if ((int )c <= 90) {
#line 196
      tmp = 1;
    } else {
#line 196
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 196
  if ((int )c == 46) {
#line 196
    tmp = 1;
  } else
#line 196
  if ((int )c == 45) {
#line 196
    tmp = 1;
  } else
#line 196
  if ((int )c == 95) {
#line 196
    tmp = 1;
  } else
#line 196
  if ((int )c == 126) {
#line 196
    tmp = 1;
  } else
#line 196
  if ((int )c == 63) {
#line 196
    tmp = 1;
  } else {
#line 196
    tmp = 0;
  }
#line 196
  return (tmp);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
char urienc[16]  = 
#line 207
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F'};
#line 208 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/util.c"
char *util_httpize(char const   *url ) 
{ 
  int i ;
  int len ;
  int tmp ;
  char *out ;
  void *tmp___0 ;
  int j ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 212
  len = 0;
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! *(url + i)) {
#line 213
      goto while_break;
    }
    {
#line 214
    tmp = validURIchar((char )*(url + i));
    }
#line 214
    if (tmp) {
#line 215
      len ++;
    } else {
#line 217
      len += 3;
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  tmp___0 = malloc(sizeof(char ) * (unsigned long )(len + 1));
#line 219
  out = (char *)tmp___0;
  }
#line 220
  if ((unsigned long )out == (unsigned long )((char *)0)) {
#line 220
    return ((char *)0);
  }
#line 222
  *(out + len) = (char)0;
#line 223
  j = 0;
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 224
    if (! *(url + i)) {
#line 224
      goto while_break___0;
    }
    {
#line 225
    tmp___5 = validURIchar((char )*(url + i));
    }
#line 225
    if (tmp___5) {
#line 226
      tmp___1 = j;
#line 226
      j ++;
#line 226
      *(out + tmp___1) = (char )*(url + i);
    } else {
#line 228
      tmp___2 = j;
#line 228
      j ++;
#line 228
      *(out + tmp___2) = (char )'%';
#line 229
      tmp___3 = j;
#line 229
      j ++;
#line 229
      *(out + tmp___3) = urienc[((int const   )*(url + i) & 240) >> 4];
#line 230
      tmp___4 = j;
#line 230
      j ++;
#line 230
      *(out + tmp___4) = urienc[(int const   )*(url + i) & 15];
    }
#line 224
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  return (out);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.h"
char *http_request_get_uri(HttpRequest *req ) ;
#line 52
void http_response_send_headers(HttpResponse *res ) ;
#line 58
void sigint(int sig ) ;
#line 61
void sigterm(int sig ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
static void malformed_request(void) 
{ 
  HttpResponse *res ;

  {
  {
#line 55
  res = (HttpResponse *)((void *)0);
#line 57
  res = http_response_new((HttpRequest *)((void *)0));
#line 59
  http_response_set_status(res, 501, (char *)"Not Implemented");
#line 60
  http_response_printf(res, "<html><body>Unrecognized HTTP Request</body></html>\n");
#line 61
  http_response_send(res);
#line 63
  exit(0);
  }
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
static void http_request_add_param(HttpRequest *req , char *key , char *value ) 
{ 
  void *tmp ;

  {
#line 72
  if (req->n_params_alloc <= req->n_params) {
    {
#line 74
    req->n_params_alloc = req->n_params_alloc * 2 + 10;
#line 75
    tmp = realloc((void *)req->params, (unsigned long )req->n_params_alloc * sizeof(HttpRequestParam ));
#line 75
    req->params = (HttpRequestParam *)tmp;
    }
#line 77
    if (! req->params) {
      {
#line 77
      exit(1);
      }
    }
  }
#line 80
  (req->params + req->n_params)->key = key;
#line 81
  (req->params + req->n_params)->val = value;
#line 83
  (req->n_params) ++;
#line 84
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
static void http_request_parse_params(HttpRequest *req , char *data , int terminator ) 
{ 
  char *key ;
  char *val ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! *data) {
#line 107
      goto while_break;
    }
#line 109
    key = (char *)((void *)0);
#line 109
    val = (char *)((void *)0);
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 111
      tmp = __ctype_b_loc();
      }
#line 111
      if (! ((int const   )*(*tmp + (int )*data) & 8192)) {
#line 111
        goto while_break___0;
      }
#line 111
      data ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 113
    key = data;
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 115
      if (*data) {
#line 115
        if ((int )*data != 61) {
#line 115
          if (! ((int )*data != terminator)) {
#line 115
            goto while_break___1;
          }
        } else {
#line 115
          goto while_break___1;
        }
      } else {
#line 115
        goto while_break___1;
      }
#line 116
      data ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    if ((int )*data == 61) {
#line 120
      *data = (char )'\000';
#line 121
      data ++;
#line 122
      val = data;
      {
#line 124
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 124
        if (*data) {
#line 124
          if (! ((int )*data != terminator)) {
#line 124
            goto while_break___2;
          }
        } else {
#line 124
          goto while_break___2;
        }
#line 125
        data ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 127
      if (*data) {
#line 127
        *data = (char )'\000';
#line 127
        data ++;
      }
      {
#line 129
      util_dehttpize(val);
#line 131
      http_request_add_param(req, key, val);
      }
    } else {
#line 136
      if (*data) {
#line 136
        tmp___0 = data;
#line 136
        data ++;
#line 136
        *tmp___0 = (char)0;
      }
      {
#line 138
      http_request_add_param(req, key, (char *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
char *http_request_param_get(HttpRequest *req , char *key ) 
{ 
  int i ;
  int tmp ;

  {
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < req->n_params)) {
#line 149
      goto while_break;
    }
    {
#line 150
    tmp = strcmp((char const   *)(req->params + i)->key, (char const   *)key);
    }
#line 150
    if (! tmp) {
#line 151
      return ((req->params + i)->val);
    }
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((char *)((void *)0));
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
char *http_request_get_uri(HttpRequest *req ) 
{ 


  {
#line 159
  return (req->uri);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
char *http_request_get_path_info(HttpRequest *req ) 
{ 


  {
#line 165
  return (req->path_info);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
char *http_request_get_query_string(HttpRequest *req ) 
{ 


  {
#line 171
  return (req->query_string);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
char *http_request_get_ip_src(HttpRequest *req ) 
{ 


  {
#line 177
  return (req->ip_src);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
HttpRequest *http_request_new(void) 
{ 
  char *token ;
  char *content_type ;
  char *post_data ;
  char *z ;
  int i ;
  int len ;
  struct sockaddr_in remoteName ;
  socklen_t size ;
  char request_line[2048] ;
  HttpRequest *req ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *key ;
  char *val ;
  unsigned short const   **tmp___13 ;
  size_t tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  size_t tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;

  {
  {
#line 191
  size = (socklen_t )sizeof(struct sockaddr_in );
#line 193
  req = (HttpRequest *)((void *)0);
#line 195
  tmp = malloc(sizeof(HttpRequest ));
#line 195
  req = (HttpRequest *)tmp;
#line 196
  memset((void *)req, 0, sizeof(HttpRequest ));
#line 198
  tmp___0 = fgets((char */* __restrict  */)(request_line), (int )sizeof(request_line),
                  (FILE */* __restrict  */)stdin);
  }
#line 198
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 199
    malformed_request();
    }
  }
  {
#line 201
  token = util_extract_token(request_line, & z);
  }
#line 201
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    {
#line 202
    malformed_request();
    }
  }
  {
#line 204
  tmp___1 = strcmp((char const   *)token, "GET");
  }
#line 204
  if (tmp___1) {
    {
#line 204
    tmp___2 = strcmp((char const   *)token, "POST");
    }
#line 204
    if (tmp___2) {
      {
#line 204
      tmp___3 = strcmp((char const   *)token, "HEAD");
      }
#line 204
      if (tmp___3) {
        {
#line 205
        malformed_request();
        }
      }
    }
  }
  {
#line 207
  putenv((char *)"GATEWAY_INTERFACE=CGI/1.0");
#line 208
  tmp___4 = util_mprintf("REQUEST_METHOD=%s", token);
#line 208
  putenv(tmp___4);
#line 210
  token = util_extract_token(z, & z);
  }
#line 210
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    {
#line 211
    malformed_request();
    }
  }
  {
#line 213
  tmp___5 = util_mprintf("REQUEST_URI=%s", token);
#line 213
  putenv(tmp___5);
  }
#line 215
  if (token) {
    {
#line 216
    req->uri = strdup((char const   *)token);
    }
  }
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (*(token + i)) {
#line 220
      if (! ((int )*(token + i) != 63)) {
#line 220
        goto while_break;
      }
    } else {
#line 220
      goto while_break;
    }
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (*(token + i)) {
#line 222
    tmp___6 = i;
#line 222
    i ++;
#line 222
    *(token + tmp___6) = (char)0;
  }
  {
#line 224
  tmp___7 = util_mprintf("PATH_INFO=%s", token);
#line 224
  putenv(tmp___7);
  }
#line 226
  if (token) {
    {
#line 227
    req->path_info = strdup((char const   *)token);
    }
  }
  {
#line 229
  tmp___8 = util_mprintf("QUERY_STRING=%s", token + i);
#line 229
  putenv(tmp___8);
  }
#line 231
  if (token + i) {
    {
#line 232
    req->query_string = strdup((char const   *)(token + i));
    }
  }
  {
#line 234
  tmp___11 = fileno(stdin);
#line 234
  tmp___12 = getpeername(tmp___11, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& remoteName)),
                         (socklen_t */* __restrict  */)(& size));
  }
#line 234
  if (tmp___12 >= 0) {
    {
#line 235
    tmp___9 = inet_ntoa(remoteName.sin_addr);
#line 235
    tmp___10 = util_mprintf("REMOTE_ADDR=%s", tmp___9);
#line 235
    putenv(tmp___10);
#line 236
    req->ip_src = inet_ntoa(remoteName.sin_addr);
    }
  }
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 241
    tmp___29 = fgets((char */* __restrict  */)(request_line), (int )sizeof(request_line),
                     (FILE */* __restrict  */)stdin);
    }
#line 241
    if (! tmp___29) {
#line 241
      goto while_break___0;
    }
    {
#line 243
    key = (char *)((void *)0);
#line 243
    val = (char *)((void *)0);
#line 245
    key = util_extract_token(request_line, & val);
    }
#line 247
    if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 248
      goto while_break___0;
    } else
#line 247
    if ((int )*key == 0) {
#line 248
      goto while_break___0;
    }
    {
#line 251
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 251
      tmp___13 = __ctype_b_loc();
      }
#line 251
      if (! ((int const   )*(*tmp___13 + (int )*val) & 8192)) {
#line 251
        goto while_break___1;
      }
#line 251
      val ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 252
    tmp___14 = strlen((char const   *)val);
#line 252
    i = (int )tmp___14;
    }
    {
#line 253
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 253
      if (i > 0) {
        {
#line 253
        tmp___15 = __ctype_b_loc();
        }
#line 253
        if (! ((int const   )*(*tmp___15 + (int )*(val + (i - 1))) & 8192)) {
#line 253
          goto while_break___2;
        }
      } else {
#line 253
        goto while_break___2;
      }
#line 253
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 253
    *(val + i) = (char )'\000';
#line 256
    i = 0;
    {
#line 256
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 256
      if (! *(key + i)) {
#line 256
        goto while_break___3;
      }
      {
#line 257
      tmp___16 = tolower((int )*(key + i));
#line 257
      *(key + i) = (char )tmp___16;
#line 256
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 259
    tmp___28 = strcmp((char const   *)key, "user-agent:");
    }
#line 259
    if (tmp___28) {
      {
#line 263
      tmp___27 = strcmp((char const   *)key, "content-length:");
      }
#line 263
      if (tmp___27) {
        {
#line 267
        tmp___26 = strcmp((char const   *)key, "referer:");
        }
#line 267
        if (tmp___26) {
          {
#line 271
          tmp___25 = strcmp((char const   *)key, "host:");
          }
#line 271
          if (tmp___25) {
            {
#line 275
            tmp___24 = strcmp((char const   *)key, "content-type:");
            }
#line 275
            if (tmp___24) {
              {
#line 279
              tmp___23 = strcmp((char const   *)key, "cookie:");
              }
#line 279
              if (! tmp___23) {
                {
#line 281
                tmp___22 = util_mprintf("HTTP_COOKIE=%s", val);
#line 281
                putenv(tmp___22);
                }
              }
            } else {
              {
#line 277
              tmp___21 = util_mprintf("CONTENT_TYPE=%s", val);
#line 277
              putenv(tmp___21);
              }
            }
          } else {
            {
#line 273
            tmp___20 = util_mprintf("HTTP_HOST=%s", val);
#line 273
            putenv(tmp___20);
            }
          }
        } else {
          {
#line 269
          tmp___19 = util_mprintf("HTTP_REFERER=%s", val);
#line 269
          putenv(tmp___19);
          }
        }
      } else {
        {
#line 265
        tmp___18 = util_mprintf("CONTENT_LENGTH=%s", val);
#line 265
        putenv(tmp___18);
        }
      }
    } else {
      {
#line 261
      tmp___17 = util_mprintf("HTTP_USER_AGENT=%s", val);
#line 261
      putenv(tmp___17);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 287
  tmp___32 = getenv("QUERY_STRING");
  }
#line 287
  if (tmp___32) {
    {
#line 288
    tmp___30 = getenv("QUERY_STRING");
#line 288
    tmp___31 = strdup((char const   *)tmp___30);
#line 288
    http_request_parse_params(req, tmp___31, '&');
    }
  }
  {
#line 292
  content_type = getenv("CONTENT_TYPE");
#line 293
  tmp___36 = getenv("CONTENT_LENGTH");
  }
#line 293
  if (tmp___36) {
    {
#line 293
    tmp___34 = getenv("CONTENT_LENGTH");
#line 293
    tmp___35 = atoi((char const   *)tmp___34);
#line 293
    len = tmp___35;
    }
  } else {
#line 293
    len = 0;
  }
#line 295
  if (len) {
#line 295
    if (content_type) {
      {
#line 299
      tmp___37 = strncmp((char const   *)content_type, "application/x-www-form-urlencoded",
                         (size_t )19);
      }
#line 299
      if (tmp___37 != 0) {
        {
#line 300
        malformed_request();
        }
      }
      {
#line 302
      tmp___38 = malloc((size_t )(len + 1));
#line 302
      post_data = (char *)tmp___38;
#line 303
      tmp___39 = fread((void */* __restrict  */)post_data, (size_t )1, (size_t )len,
                       (FILE */* __restrict  */)stdin);
#line 303
      len = (int )tmp___39;
#line 304
      *(post_data + len) = (char )'\000';
#line 305
      http_request_parse_params(req, post_data, '&');
      }
    }
  }
  {
#line 308
  tmp___42 = getenv("HTTP_COOKIE");
  }
#line 308
  if (tmp___42) {
    {
#line 309
    tmp___40 = getenv("HTTP_COOKIE");
#line 309
    tmp___41 = strdup((char const   *)tmp___40);
#line 309
    http_request_parse_params(req, tmp___41, '&');
    }
  }
#line 311
  return (req);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
HttpResponse *http_response_new(HttpRequest *req ) 
{ 
  HttpResponse *res ;
  void *tmp ;

  {
  {
#line 317
  res = (HttpResponse *)((void *)0);
#line 319
  tmp = malloc(sizeof(HttpResponse ));
#line 319
  res = (HttpResponse *)tmp;
#line 320
  memset((void *)res, 0, sizeof(HttpResponse ));
#line 322
  res->status = 200;
#line 323
  res->status_str = (char *)"OK";
#line 324
  res->content_type = (char *)((void *)0);
  }
#line 326
  return (res);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_set_content_type(HttpResponse *res , char *type ) 
{ 


  {
  {
#line 332
  res->content_type = strdup((char const   *)type);
  }
#line 333
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_append_header(HttpResponse *res , char *header ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 339
  if (res->extra_headers) {
    {
#line 341
    tmp = strlen((char const   *)res->extra_headers);
#line 341
    tmp___0 = strlen((char const   *)header);
#line 341
    tmp___1 = realloc((void *)res->extra_headers, (tmp + tmp___0) + 1UL);
#line 341
    res->extra_headers = (char *)tmp___1;
#line 344
    strcat((char */* __restrict  */)res->extra_headers, (char const   */* __restrict  */)header);
    }
  } else {
    {
#line 348
    res->extra_headers = strdup((char const   *)header);
    }
  }
#line 350
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_printf_alloc_buffer(HttpResponse *res , int bytes ) 
{ 
  void *tmp ;

  {
  {
#line 356
  res->data_len_alloced += bytes;
#line 357
  tmp = realloc((void *)res->data, (size_t )res->data_len_alloced);
#line 357
  res->data = (char *)tmp;
  }
#line 358
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_printf(HttpResponse *res , char const   *format  , ...) 
{ 
  va_list ap ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 365
  tmp = (char *)((void *)0);
#line 367
  __builtin_va_start(ap, format);
#line 368
  vasprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)format,
            ap);
#line 369
  __builtin_va_end(ap);
#line 371
  tmp___10 = strlen((char const   *)tmp);
  }
#line 371
  if (((size_t )res->data_len + tmp___10) + 1UL < (size_t )res->data_len_alloced) {
#line 373
    if (res->data_len) {
      {
#line 374
      tmp___0 = strlen((char const   *)tmp);
#line 374
      memcpy((void */* __restrict  */)((res->data + res->data_len) - 1), (void const   */* __restrict  */)tmp,
             tmp___0 + 1UL);
      }
    } else {
      {
#line 376
      tmp___1 = strlen((char const   *)tmp);
#line 376
      memcpy((void */* __restrict  */)res->data, (void const   */* __restrict  */)tmp,
             tmp___1 + 1UL);
      }
    }
  } else
#line 378
  if (! res->data_len) {
    {
#line 380
    tmp___2 = strlen((char const   *)tmp);
#line 380
    tmp___3 = malloc(tmp___2 + 1UL);
#line 380
    res->data = (char *)tmp___3;
#line 381
    tmp___4 = strlen((char const   *)tmp);
#line 381
    memcpy((void */* __restrict  */)res->data, (void const   */* __restrict  */)tmp,
           tmp___4 + 1UL);
#line 382
    tmp___5 = strlen((char const   *)tmp);
#line 382
    res->data_len_alloced = (int )(tmp___5 + 1UL);
    }
  } else {
    {
#line 386
    tmp___6 = strlen((char const   *)tmp);
#line 386
    tmp___7 = realloc((void *)res->data, (size_t )res->data_len + tmp___6);
#line 386
    res->data = (char *)tmp___7;
#line 387
    tmp___8 = strlen((char const   *)tmp);
#line 387
    memcpy((void */* __restrict  */)((res->data + res->data_len) - 1), (void const   */* __restrict  */)tmp,
           tmp___8 + 1UL);
#line 388
    tmp___9 = strlen((char const   *)tmp);
#line 388
    res->data_len_alloced = (int )((size_t )res->data_len + tmp___9);
    }
  }
  {
#line 391
  tmp___11 = strlen((char const   *)res->data);
#line 391
  res->data_len = (int )(tmp___11 + 1UL);
#line 392
  free((void *)tmp);
  }
#line 393
  return;
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_set_status(HttpResponse *res , int status_code , char *status_desc ) 
{ 


  {
  {
#line 401
  res->status = status_code;
#line 402
  res->status_str = strdup((char const   *)status_desc);
  }
#line 403
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_set_data(HttpResponse *res , void *data , int data_len ) 
{ 


  {
#line 409
  res->data = (char *)data;
#line 410
  res->data_len = data_len;
#line 411
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_send_headers(HttpResponse *res ) 
{ 
  char const   *tmp ;

  {
  {
#line 417
  printf((char const   */* __restrict  */)"HTTP/1.0 %d %s\r\n", res->status, res->status_str);
  }
#line 419
  if (res->extra_headers) {
    {
#line 419
    printf((char const   */* __restrict  */)"%s", res->extra_headers);
    }
  }
#line 423
  if ((unsigned long )res->content_type == (unsigned long )((void *)0)) {
#line 423
    tmp = "text/html";
  } else {
#line 423
    tmp = (char const   *)res->content_type;
  }
  {
#line 423
  printf((char const   */* __restrict  */)"Content-Type: %s; charset=UTF-8\r\n", tmp);
  }
#line 426
  if (res->data_len) {
    {
#line 428
    printf((char const   */* __restrict  */)"Content-Length: %d\r\n", res->data_len);
#line 429
    printf((char const   */* __restrict  */)"Connection: close\r\n");
    }
  }
  {
#line 432
  printf((char const   */* __restrict  */)"\r\n");
  }
#line 433
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void http_response_send(HttpResponse *res ) 
{ 


  {
  {
#line 438
  http_response_send_headers(res);
  }
#line 440
  if (res->data) {
    {
#line 441
    fwrite((void const   */* __restrict  */)res->data, (size_t )1, (size_t )res->data_len,
           (FILE */* __restrict  */)stdout);
    }
  }
#line 442
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void sigint(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
#line 451
  printf((char const   */* __restrict  */)"\nDidiwiki stopped.\n");
#line 452
  syslog((16 << 3) | 6, "Didiwiki stopped.\n");
#line 454
  signal(2, (void (*)(int  ))0);
#line 455
  tmp = getpid();
#line 455
  kill(tmp, 2);
#line 458
  exit(1);
  }
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
void sigterm(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
#line 467
  printf((char const   */* __restrict  */)"\nDidiwiki stopped.\n");
#line 468
  syslog((16 << 3) | 6, "Didiwiki stopped.\n");
#line 470
  signal(15, (void (*)(int  ))0);
#line 471
  tmp = getpid();
#line 471
  kill(tmp, 15);
#line 474
  exit(1);
  }
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/didiwiki-0.5/src/http.c"
HttpRequest *http_server(struct in_addr address , int iPort ) 
{ 
  int listener ;
  int connection ;
  fd_set readfds ;
  socklen_t lenaddr ;
  int child ;
  int nchildren ;
  struct timeval delay ;
  struct sockaddr_in inaddr ;
  int reuse ;
  char *tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int __d0 ;
  int __d1 ;
  HttpRequest *tmp___2 ;
  int tmp___3 ;
  __pid_t tmp___4 ;

  {
  {
#line 495
  nchildren = 0;
#line 498
  reuse = 1;
#line 501
  signal(2, & sigint);
#line 504
  signal(15, & sigterm);
#line 506
  memset((void *)(& inaddr), 0, sizeof(inaddr));
#line 507
  inaddr.sin_family = (sa_family_t )2;
#line 508
  inaddr.sin_addr.s_addr = address.s_addr;
#line 509
  inaddr.sin_port = htons((uint16_t )iPort);
#line 510
  listener = socket(2, 1, 0);
#line 512
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DidiWiki firing up ...\n");
  }
#line 514
  if (listener < 0) {
    {
#line 516
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t create a socket\n");
#line 517
    exit(1);
    }
  }
  {
#line 521
  setsockopt(listener, 1, 2, (void const   *)(& reuse), (socklen_t )sizeof(reuse));
#line 524
  tmp = inet_ntoa(address);
#line 524
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempting to bind to %s:%i .. ",
          tmp, iPort);
#line 526
  inaddr.sin_port = htons((uint16_t )iPort);
#line 528
  tmp___0 = bind(listener, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& inaddr)),
                 (socklen_t )sizeof(inaddr));
  }
#line 528
  if (tmp___0 < 0) {
    {
#line 530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed! \n");
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t bind to IP and/or port.\n");
#line 533
    exit(1);
    }
  }
  {
#line 536
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Success! \n");
#line 538
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DidiWiki Started.\n");
#line 541
  openlog("didiwiki", 0, 0);
#line 542
  tmp___1 = getpid();
#line 542
  syslog((16 << 3) | 6, "started with PID %d", tmp___1);
#line 544
  listen(listener, 10);
  }
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (nchildren > 5) {
      {
#line 551
      sleep((unsigned int )(nchildren - 5));
      }
    }
#line 554
    delay.tv_sec = (__time_t )60;
#line 555
    delay.tv_usec = (__suseconds_t )0;
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.fds_bits[0]): "memory");
#line 556
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 557
    readfds.fds_bits[listener / (8 * (int )sizeof(__fd_mask ))] |= 1L << listener % (8 * (int )sizeof(__fd_mask ));
#line 559
    tmp___3 = select(listener + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& delay));
    }
#line 559
    if (tmp___3) {
      {
#line 561
      lenaddr = (socklen_t )sizeof(inaddr);
#line 562
      connection = accept(listener, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& inaddr)),
                          (socklen_t */* __restrict  */)(& lenaddr));
      }
#line 563
      if (connection >= 0) {
        {
#line 565
        child = fork();
        }
#line 566
        if (child != 0) {
#line 568
          if (child > 0) {
#line 569
            nchildren ++;
          }
          {
#line 570
          close(connection);
          }
        } else {
          {
#line 576
          close(0);
#line 577
          dup(connection);
#line 578
          close(1);
#line 579
          dup(connection);
#line 580
          close(2);
#line 581
          dup(connection);
#line 582
          close(connection);
#line 583
          tmp___2 = http_request_new();
          }
#line 583
          return (tmp___2);
        }
      }
    }
    {
#line 589
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 589
      tmp___4 = waitpid(0, (int *)0, 1);
      }
#line 589
      if (! (tmp___4 > 0)) {
#line 589
        goto while_break___1;
      }
#line 589
      nchildren --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  exit(1);
  }
}
}
