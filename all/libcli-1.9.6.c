/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.h"
struct cli_command;
#line 36
struct unp;
#line 36
struct cli_filter;
#line 36 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.h"
struct cli_def {
   int completion_callback ;
   struct cli_command *commands ;
   int (*auth_callback)(char const   * , char const   * ) ;
   int (*regular_callback)(struct cli_def *cli ) ;
   int (*enable_callback)(char const   * ) ;
   char *banner ;
   struct unp *users ;
   char *enable_password ;
   char *history[256] ;
   char showprompt ;
   char *promptchar ;
   char *hostname ;
   char *modestring ;
   int privilege ;
   int mode ;
   int state ;
   struct cli_filter *filters ;
   void (*print_callback)(struct cli_def *cli , char const   *string ) ;
   FILE *client ;
   void *conn ;
   void *service ;
   char *commandname ;
   char *buffer ;
   unsigned int buf_size ;
   struct timeval timeout_tm ;
   time_t idle_timeout ;
   int (*idle_timeout_callback)(struct cli_def * ) ;
   time_t last_action ;
   int telnet_protocol ;
   void *user_context ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.h"
struct cli_filter {
   int (*filter)(struct cli_def *cli , char const   *string , void *data ) ;
   void *data ;
   struct cli_filter *next ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.h"
struct cli_command {
   char *command ;
   int (*callback)(struct cli_def * , char const   * , char ** , int  ) ;
   unsigned int unique_len ;
   char *help ;
   int privilege ;
   int mode ;
   struct cli_command *next ;
   struct cli_command *children ;
   struct cli_command *parent ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
struct my_context {
   int value ;
   char *message ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_31 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_31 regmatch_t;
#line 110 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
struct unp {
   char *username ;
   char *password ;
   struct unp *next ;
};
#line 116 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
struct cli_filter_cmds {
   char const   *cmd ;
   char const   *help ;
};
#line 2061 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
union __anonunion_match_32 {
   char *string ;
   regex_t re ;
};
#line 2061 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
struct cli_match_filter_state {
   int flags ;
   union __anonunion_match_32 match ;
};
#line 2195 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
struct cli_range_filter_state {
   int matched ;
   char *from ;
   char *to ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 107 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.h"
struct cli_def *cli_init(void) ;
#line 89
int cli_done(struct cli_def *cli ) ;
#line 90
struct cli_command *cli_register_command(struct cli_def *cli , struct cli_command *parent ,
                                         char const   *command , int (*callback)(struct cli_def *cli ,
                                                                                 char const   * ,
                                                                                 char ** ,
                                                                                 int  ) ,
                                         int privilege , int mode , char const   *help ) ;
#line 95
int cli_loop(struct cli_def *cli , int sockfd ) ;
#line 96
int cli_file(struct cli_def *cli , FILE *fh , int privilege , int mode ) ;
#line 97
void cli_set_auth_callback(struct cli_def *cli , int (*auth_callback)(char const   * ,
                                                                      char const   * ) ) ;
#line 98
void cli_set_enable_callback(struct cli_def *cli , int (*enable_callback)(char const   * ) ) ;
#line 102
void cli_set_banner(struct cli_def *cli , char const   *banner ) ;
#line 103
void cli_set_hostname(struct cli_def *cli , char const   *hostname ) ;
#line 107
int cli_set_configmode(struct cli_def *cli , int mode , char const   *config_desc ) ;
#line 108
void cli_reprompt(struct cli_def *cli ) ;
#line 109
void cli_regular(struct cli_def *cli , int (*callback)(struct cli_def *cli ) ) ;
#line 110
void cli_regular_interval(struct cli_def *cli , int seconds ) ;
#line 111
void ( /* format attribute */  cli_print)(struct cli_def *cli , char const   *format 
                                          , ...) ;
#line 115
void cli_print_callback(struct cli_def *cli , void (*callback)(struct cli_def * ,
                                                               char const   * ) ) ;
#line 118
void cli_set_idle_timeout_callback(struct cli_def *cli , unsigned int seconds , int (*callback)(struct cli_def * ) ) ;
#line 122
void cli_telnet_protocol(struct cli_def *cli , int telnet_protocol ) ;
#line 125
void cli_set_context(struct cli_def *cli , void *context ) ;
#line 126
void *cli_get_context(struct cli_def *cli ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
unsigned int regular_count  =    0U;
#line 30 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
unsigned int debug_regular  =    0U;
#line 72 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_test(struct cli_def *cli , char const   *command , char **argv , int argc ) 
{ 
  int i ;

  {
  {
#line 75
  cli_print(cli, "called %s with \"%s\"", "cmd_test", command);
#line 76
  cli_print(cli, "%d arguments:", argc);
#line 77
  i = 0;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < argc)) {
#line 77
      goto while_break;
    }
    {
#line 78
    cli_print(cli, "        %s", *(argv + i));
#line 77
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_set(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
            char **argv , int argc ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int sec ;
  int tmp___1 ;

  {
#line 86
  if (argc < 2) {
    {
#line 88
    cli_print(cli, "Specify a variable to set");
    }
#line 89
    return (0);
  } else {
    {
#line 86
    tmp = strcmp((char const   *)*(argv + 0), "?");
    }
#line 86
    if (tmp == 0) {
      {
#line 88
      cli_print(cli, "Specify a variable to set");
      }
#line 89
      return (0);
    }
  }
  {
#line 92
  tmp___0 = strcmp((char const   *)*(argv + 1), "?");
  }
#line 92
  if (tmp___0 == 0) {
    {
#line 94
    cli_print(cli, "Specify a value");
    }
#line 95
    return (0);
  }
  {
#line 98
  tmp___1 = strcmp((char const   *)*(argv + 0), "regular_interval");
  }
#line 98
  if (tmp___1 == 0) {
#line 100
    sec = 0U;
#line 101
    if (! *(argv + 1)) {
#line 101
      if (! (argv + 1)) {
        {
#line 103
        cli_print(cli, "Specify a regular callback interval in seconds");
        }
#line 104
        return (0);
      }
    }
    {
#line 106
    sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"%u",
           & sec);
    }
#line 107
    if (sec < 1U) {
      {
#line 109
      cli_print(cli, "Specify a regular callback interval in seconds");
      }
#line 110
      return (0);
    }
    {
#line 112
    cli->timeout_tm.tv_sec = (__time_t )sec;
#line 113
    cli->timeout_tm.tv_usec = (__suseconds_t )0;
#line 114
    cli_print(cli, "Regular callback interval is now %d seconds", sec);
    }
#line 115
    return (0);
  }
  {
#line 118
  cli_print(cli, "Setting \"%s\" to \"%s\"", *(argv + 0), *(argv + 1));
  }
#line 119
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_config_int(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                   char **argv , int argc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 124
  if (argc < 1) {
    {
#line 126
    cli_print(cli, "Specify an interface to configure");
    }
#line 127
    return (0);
  }
  {
#line 130
  tmp___0 = strcmp((char const   *)*(argv + 0), "?");
  }
#line 130
  if (tmp___0 == 0) {
    {
#line 131
    cli_print(cli, "  test0/0");
    }
  } else {
    {
#line 133
    tmp = strcasecmp((char const   *)*(argv + 0), "test0/0");
    }
#line 133
    if (tmp == 0) {
      {
#line 134
      cli_set_configmode(cli, 10, "test");
      }
    } else {
      {
#line 136
      cli_print(cli, "Unknown interface %s", *(argv + 0));
      }
    }
  }
#line 138
  return (0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_config_int_exit(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                        char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 143
  cli_set_configmode(cli, 1, (char const   *)((void *)0));
  }
#line 144
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_show_regular(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                     char **argv , int argc ) 
{ 


  {
  {
#line 149
  cli_print(cli, "cli_regular() has run %u times", regular_count);
  }
#line 150
  return (0);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_debug_regular(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                      char **argv , int argc ) 
{ 
  char const   *tmp ;

  {
#line 155
  debug_regular = (unsigned int )(! debug_regular);
#line 156
  if (debug_regular) {
#line 156
    tmp = "enabled";
  } else {
#line 156
    tmp = "disabled";
  }
  {
#line 156
  cli_print(cli, "cli_regular() debugging is %s", tmp);
  }
#line 157
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int cmd_context(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 
  struct my_context *myctx ;
  void *tmp ;

  {
  {
#line 162
  tmp = cli_get_context(cli);
#line 162
  myctx = (struct my_context *)tmp;
#line 163
  cli_print(cli, "User context has a value of %d and message saying %s", myctx->value,
            myctx->message);
  }
#line 164
  return (0);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int check_auth(char const   *username , char const   *password ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 169
  tmp = strcasecmp(username, "fred");
  }
#line 169
  if (tmp != 0) {
#line 170
    return (-1);
  }
  {
#line 171
  tmp___0 = strcasecmp(password, "nerk");
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 173
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int regular_callback(struct cli_def *cli ) 
{ 


  {
#line 178
  regular_count ++;
#line 179
  if (debug_regular) {
    {
#line 181
    cli_print(cli, "Regular callback - %u times so far", regular_count);
#line 182
    cli_reprompt(cli);
    }
  }
#line 184
  return (0);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int check_enable(char const   *password ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 189
  tmp = strcasecmp(password, "topsecret");
  }
#line 189
  if (tmp) {
#line 189
    tmp___0 = 0;
  } else {
#line 189
    tmp___0 = 1;
  }
#line 189
  return (tmp___0);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int idle_timeout(struct cli_def *cli ) 
{ 


  {
  {
#line 194
  cli_print(cli, "Custom idle timeout");
  }
#line 195
  return (-2);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
void pc(struct cli_def *cli  __attribute__((__unused__)) , char const   *string ) 
{ 


  {
  {
#line 200
  printf((char const   */* __restrict  */)"%s\n", string);
  }
#line 201
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/clitest.c"
int main(void) 
{ 
  struct cli_command *c ;
  struct cli_def *cli ;
  int s ;
  int x ;
  struct sockaddr_in addr ;
  int on ;
  char mymessage[21] ;
  struct my_context myctx ;
  FILE *fh ;
  int tmp ;
  int tmp___0 ;
  int pid ;
  __pid_t tmp___1 ;
  socklen_t len ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 209
  on = 1;
#line 212
  signal(17, (void (*)(int  ))1);
#line 222
  mymessage[0] = (char )'I';
#line 222
  mymessage[1] = (char )' ';
#line 222
  mymessage[2] = (char )'c';
#line 222
  mymessage[3] = (char )'o';
#line 222
  mymessage[4] = (char )'n';
#line 222
  mymessage[5] = (char )'t';
#line 222
  mymessage[6] = (char )'a';
#line 222
  mymessage[7] = (char )'i';
#line 222
  mymessage[8] = (char )'n';
#line 222
  mymessage[9] = (char )' ';
#line 222
  mymessage[10] = (char )'u';
#line 222
  mymessage[11] = (char )'s';
#line 222
  mymessage[12] = (char )'e';
#line 222
  mymessage[13] = (char )'r';
#line 222
  mymessage[14] = (char )' ';
#line 222
  mymessage[15] = (char )'d';
#line 222
  mymessage[16] = (char )'a';
#line 222
  mymessage[17] = (char )'t';
#line 222
  mymessage[18] = (char )'a';
#line 222
  mymessage[19] = (char )'!';
#line 222
  mymessage[20] = (char )'\000';
#line 224
  myctx.value = 5;
#line 225
  myctx.message = mymessage;
#line 227
  cli = cli_init();
#line 228
  cli_set_banner(cli, "libcli test environment");
#line 229
  cli_set_hostname(cli, "router");
#line 230
  cli_telnet_protocol(cli, 1);
#line 231
  cli_regular(cli, & regular_callback);
#line 232
  cli_regular_interval(cli, 5);
#line 233
  cli_set_idle_timeout_callback(cli, 60U, & idle_timeout);
#line 234
  cli_register_command(cli, (struct cli_command *)((void *)0), "test", & cmd_test,
                       0, 0, (char const   *)((void *)0));
#line 236
  cli_register_command(cli, (struct cli_command *)((void *)0), "simple", (int (*)(struct cli_def * ,
                                                                                  char const   * ,
                                                                                  char ** ,
                                                                                  int  ))((void *)0),
                       0, 0, (char const   *)((void *)0));
#line 238
  cli_register_command(cli, (struct cli_command *)((void *)0), "simon", (int (*)(struct cli_def * ,
                                                                                 char const   * ,
                                                                                 char ** ,
                                                                                 int  ))((void *)0),
                       0, 0, (char const   *)((void *)0));
#line 240
  cli_register_command(cli, (struct cli_command *)((void *)0), "set", & cmd_set, 15,
                       0, (char const   *)((void *)0));
#line 242
  c = cli_register_command(cli, (struct cli_command *)((void *)0), "show", (int (*)(struct cli_def * ,
                                                                                    char const   * ,
                                                                                    char ** ,
                                                                                    int  ))((void *)0),
                           0, 0, (char const   *)((void *)0));
#line 244
  cli_register_command(cli, c, "regular", & cmd_show_regular, 0, 0, "Show the how many times cli_regular has run");
#line 247
  cli_register_command(cli, c, "counters", & cmd_test, 0, 0, "Show the counters that the system uses");
#line 250
  cli_register_command(cli, c, "junk", & cmd_test, 0, 0, (char const   *)((void *)0));
#line 252
  cli_register_command(cli, (struct cli_command *)((void *)0), "interface", & cmd_config_int,
                       15, 1, "Configure an interface");
#line 255
  cli_register_command(cli, (struct cli_command *)((void *)0), "exit", & cmd_config_int_exit,
                       15, 10, "Exit from interface configuration");
#line 258
  cli_register_command(cli, (struct cli_command *)((void *)0), "address", & cmd_test,
                       15, 10, "Set IP address");
#line 260
  c = cli_register_command(cli, (struct cli_command *)((void *)0), "debug", (int (*)(struct cli_def * ,
                                                                                     char const   * ,
                                                                                     char ** ,
                                                                                     int  ))((void *)0),
                           0, 0, (char const   *)((void *)0));
#line 262
  cli_register_command(cli, c, "regular", & cmd_debug_regular, 0, 0, "Enable cli_regular() callback debugging");
#line 266
  cli_set_context(cli, (void *)(& myctx));
#line 267
  cli_register_command(cli, (struct cli_command *)((void *)0), "context", & cmd_context,
                       0, 0, "Test a user-specified context");
#line 270
  cli_set_auth_callback(cli, & check_auth);
#line 271
  cli_set_enable_callback(cli, & check_enable);
#line 276
  fh = fopen((char const   */* __restrict  */)"clitest.txt", (char const   */* __restrict  */)"r");
  }
#line 276
  if (fh) {
    {
#line 279
    cli_print_callback(cli, & pc);
#line 280
    cli_file(cli, fh, 0, 0);
#line 281
    cli_print_callback(cli, (void (*)(struct cli_def * , char const   * ))((void *)0));
#line 282
    fclose(fh);
    }
  }
  {
#line 286
  s = socket(2, 1, 0);
  }
#line 286
  if (s < 0) {
    {
#line 288
    perror("socket");
    }
#line 289
    return (1);
  }
  {
#line 291
  setsockopt(s, 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
#line 293
  memset((void *)(& addr), 0, sizeof(addr));
#line 294
  addr.sin_family = (sa_family_t )2;
#line 295
  addr.sin_addr.s_addr = htonl((in_addr_t )0);
#line 296
  addr.sin_port = htons((uint16_t )8000);
#line 297
  tmp = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 297
  if (tmp < 0) {
    {
#line 299
    perror("bind");
    }
#line 300
    return (1);
  }
  {
#line 303
  tmp___0 = listen(s, 50);
  }
#line 303
  if (tmp___0 < 0) {
    {
#line 305
    perror("listen");
    }
#line 306
    return (1);
  }
  {
#line 309
  printf((char const   */* __restrict  */)"Listening on port %d\n", 8000);
  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 310
    x = accept(s, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)0);
    }
#line 310
    if (! x) {
#line 310
      goto while_break;
    }
    {
#line 313
    tmp___1 = fork();
#line 313
    pid = tmp___1;
    }
#line 314
    if (pid < 0) {
      {
#line 316
      perror("fork");
      }
#line 317
      return (1);
    }
#line 321
    if (pid > 0) {
      {
#line 323
      len = (socklen_t )sizeof(addr);
#line 324
      tmp___3 = getpeername(x, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                            (socklen_t */* __restrict  */)(& len));
      }
#line 324
      if (tmp___3 >= 0) {
        {
#line 325
        tmp___2 = inet_ntoa(addr.sin_addr);
#line 325
        printf((char const   */* __restrict  */)" * accepted connection from %s\n",
               tmp___2);
        }
      }
      {
#line 327
      close(x);
      }
#line 328
      goto while_continue;
    }
    {
#line 332
    close(s);
#line 333
    cli_loop(cli, x);
#line 334
    exit(0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  cli_done(cli);
  }
#line 343
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 1120
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) crypt)(char const   *__key ,
                                                                                                char const   *__salt ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.h"
int cli_unregister_command(struct cli_def *cli , char const   *command ) ;
#line 94
int cli_run_command(struct cli_def *cli , char const   *command ) ;
#line 99
void cli_allow_user(struct cli_def *cli , char const   *username , char const   *password ) ;
#line 100
void cli_allow_enable(struct cli_def *cli , char const   *password ) ;
#line 101
void cli_deny_user(struct cli_def *cli , char const   *username ) ;
#line 104
void cli_set_promptchar(struct cli_def *cli , char const   *promptchar ) ;
#line 105
void cli_set_modestring(struct cli_def *cli , char const   *modestring ) ;
#line 106
int cli_set_privilege(struct cli_def *cli , int priv ) ;
#line 112
void ( /* format attribute */  cli_bufprint)(struct cli_def *cli , char const   *format 
                                             , ...) ;
#line 113
void cli_vabufprint(struct cli_def *cli , char const   *format , va_list ap ) ;
#line 114
void ( /* format attribute */  cli_error)(struct cli_def *cli , char const   *format 
                                          , ...) ;
#line 116
void cli_free_history(struct cli_def *cli ) ;
#line 117
void cli_set_idle_timeout(struct cli_def *cli , unsigned int seconds ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_match_filter_init(struct cli_def *cli , int argc , char **argv , struct cli_filter *filt ) ;
#line 126
int cli_range_filter_init(struct cli_def *cli , int argc , char **argv , struct cli_filter *filt ) ;
#line 127
int cli_count_filter_init(struct cli_def *cli , int argc , char **argv  __attribute__((__unused__)) ,
                          struct cli_filter *filt ) ;
#line 128
int cli_match_filter(struct cli_def *cli  __attribute__((__unused__)) , char const   *string ,
                     void *data ) ;
#line 129
int cli_range_filter(struct cli_def *cli  __attribute__((__unused__)) , char const   *string ,
                     void *data ) ;
#line 130
int cli_count_filter(struct cli_def *cli , char const   *string , void *data ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static struct cli_filter_cmds filter_cmds[8]  = 
#line 132
  {      {"begin", "Begin with lines that match"}, 
        {"between", "Between lines that match"}, 
        {"count", "Count of lines"}, 
        {"exclude", "Exclude lines that match"}, 
        {"include", "Include lines that match"}, 
        {"grep", "Include lines that match regex (options: -v, -i, -e)"}, 
        {"egrep", "Include lines that match extended regex"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 144 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static ssize_t _write(int fd , void const   *buf , size_t count ) 
{ 
  size_t written ;
  ssize_t thisTime ;
  int *tmp ;

  {
#line 146
  written = (size_t )0;
#line 147
  thisTime = (ssize_t )0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (count != written)) {
#line 148
      goto while_break;
    }
    {
#line 150
    thisTime = write(fd, (void const   *)((char *)buf + written), count - written);
    }
#line 151
    if (thisTime == -1L) {
      {
#line 153
      tmp = __errno_location();
      }
#line 153
      if (*tmp == 4) {
#line 154
        goto while_continue;
      } else {
#line 156
        return ((ssize_t )-1);
      }
    }
#line 158
    written += (size_t )thisTime;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return ((ssize_t )written);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
char *cli_command_name(struct cli_def *cli , struct cli_command *command ) 
{ 
  char *name ;
  char *o ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 164
  name = cli->commandname;
#line 167
  if (name) {
    {
#line 167
    free((void *)name);
    }
  }
  {
#line 168
  tmp = calloc((size_t )1, (size_t )1);
#line 168
  name = (char *)tmp;
  }
#line 168
  if (! name) {
#line 169
    return ((char *)((void *)0));
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! command) {
#line 171
      goto while_break;
    }
#line 173
    o = name;
#line 174
    if (*o) {
#line 174
      tmp___2 = " ";
    } else {
#line 174
      tmp___2 = "";
    }
    {
#line 174
    tmp___3 = asprintf((char **/* __restrict  */)(& name), (char const   */* __restrict  */)"%s%s%s",
                       command->command, tmp___2, o);
    }
#line 174
    if (tmp___3 == -1) {
      {
#line 176
      tmp___0 = __errno_location();
#line 176
      tmp___1 = strerror(*tmp___0);
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate memory for command_name: %s",
              tmp___1);
#line 177
      free((void *)o);
      }
#line 178
      return ((char *)((void *)0));
    }
    {
#line 180
    command = command->parent;
#line 181
    free((void *)o);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  cli->commandname = name;
#line 184
  return (name);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_auth_callback(struct cli_def *cli , int (*auth_callback)(char const   * ,
                                                                      char const   * ) ) 
{ 


  {
#line 189
  cli->auth_callback = auth_callback;
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_enable_callback(struct cli_def *cli , int (*enable_callback)(char const   * ) ) 
{ 


  {
#line 194
  cli->enable_callback = enable_callback;
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_allow_user(struct cli_def *cli , char const   *username , char const   *password ) 
{ 
  struct unp *u ;
  struct unp *n ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 200
  tmp___1 = malloc(sizeof(struct unp ));
#line 200
  n = (struct unp *)tmp___1;
  }
#line 200
  if (! n) {
    {
#line 202
    tmp = __errno_location();
#line 202
    tmp___0 = strerror(*tmp);
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate memory for user: %s",
            tmp___0);
    }
#line 203
    return;
  }
  {
#line 205
  tmp___4 = strdup(username);
#line 205
  n->username = tmp___4;
  }
#line 205
  if (! tmp___4) {
    {
#line 207
    tmp___2 = __errno_location();
#line 207
    tmp___3 = strerror(*tmp___2);
#line 207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate memory for username: %s",
            tmp___3);
#line 208
    free((void *)n);
    }
#line 209
    return;
  }
  {
#line 211
  tmp___7 = strdup(password);
#line 211
  n->password = tmp___7;
  }
#line 211
  if (! tmp___7) {
    {
#line 213
    tmp___5 = __errno_location();
#line 213
    tmp___6 = strerror(*tmp___5);
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate memory for password: %s",
            tmp___6);
#line 214
    free((void *)n->username);
#line 215
    free((void *)n);
    }
#line 216
    return;
  }
#line 218
  n->next = (struct unp *)((void *)0);
#line 220
  if (! cli->users) {
#line 222
    cli->users = n;
  } else {
#line 226
    u = cli->users;
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 226
      if (u) {
#line 226
        if (! u->next) {
#line 226
          goto while_break;
        }
      } else {
#line 226
        goto while_break;
      }
#line 226
      u = u->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 227
    if (u) {
#line 227
      u->next = n;
    }
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_allow_enable(struct cli_def *cli , char const   *password ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (cli->enable_password) {
      {
#line 233
      free((void *)cli->enable_password);
#line 233
      cli->enable_password = (char *)0;
      }
    }
#line 233
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp___1 = strdup(password);
#line 234
  cli->enable_password = tmp___1;
  }
#line 234
  if (! tmp___1) {
    {
#line 236
    tmp = __errno_location();
#line 236
    tmp___0 = strerror(*tmp);
#line 236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate memory for enable password: %s",
            tmp___0);
    }
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_deny_user(struct cli_def *cli , char const   *username ) 
{ 
  struct unp *u ;
  struct unp *p ;
  int tmp ;

  {
#line 242
  p = (struct unp *)((void *)0);
#line 243
  if (! cli->users) {
#line 243
    return;
  }
#line 244
  u = cli->users;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! u) {
#line 244
      goto while_break;
    }
    {
#line 246
    tmp = strcmp(username, (char const   *)u->username);
    }
#line 246
    if (tmp == 0) {
#line 248
      if (p) {
#line 249
        p->next = u->next;
      } else {
#line 251
        cli->users = u->next;
      }
      {
#line 252
      free((void *)u->username);
#line 253
      free((void *)u->password);
#line 254
      free((void *)u);
      }
#line 255
      goto while_break;
    }
#line 257
    p = u;
#line 244
    u = u->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_banner(struct cli_def *cli , char const   *banner ) 
{ 


  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (cli->banner) {
      {
#line 263
      free((void *)cli->banner);
#line 263
      cli->banner = (char *)0;
      }
    }
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if (banner) {
#line 264
    if (*banner) {
      {
#line 265
      cli->banner = strdup(banner);
      }
    }
  }
#line 266
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_hostname(struct cli_def *cli , char const   *hostname ) 
{ 


  {
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (cli->hostname) {
      {
#line 270
      free((void *)cli->hostname);
#line 270
      cli->hostname = (char *)0;
      }
    }
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  if (hostname) {
#line 271
    if (*hostname) {
      {
#line 272
      cli->hostname = strdup(hostname);
      }
    }
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_promptchar(struct cli_def *cli , char const   *promptchar ) 
{ 


  {
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (cli->promptchar) {
      {
#line 277
      free((void *)cli->promptchar);
#line 277
      cli->promptchar = (char *)0;
      }
    }
#line 277
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  cli->promptchar = strdup(promptchar);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_build_shortest(struct cli_def *cli , struct cli_command *commands ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;
  char *cp ;
  char *pp ;
  unsigned int len ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 287
  c = commands;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! c) {
#line 287
      goto while_break;
    }
    {
#line 289
    tmp = strlen((char const   *)c->command);
#line 289
    c->unique_len = (unsigned int )tmp;
    }
#line 290
    if (c->mode != -1) {
#line 290
      if (c->mode != cli->mode) {
#line 291
        goto __Cont;
      } else {
#line 290
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 290
    if (c->privilege > cli->privilege) {
#line 291
      goto __Cont;
    }
#line 293
    c->unique_len = 1U;
#line 294
    p = commands;
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      if (! p) {
#line 294
        goto while_break___0;
      }
#line 296
      if ((unsigned long )c == (unsigned long )p) {
#line 297
        goto __Cont___0;
      }
#line 299
      if (p->mode != -1) {
#line 299
        if (p->mode != cli->mode) {
#line 300
          goto __Cont___0;
        } else {
#line 299
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 299
      if (p->privilege > cli->privilege) {
#line 300
        goto __Cont___0;
      }
#line 302
      cp = c->command;
#line 303
      pp = p->command;
#line 304
      len = 1U;
      {
#line 306
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 306
        if (*cp) {
#line 306
          if (*pp) {
#line 306
            tmp___0 = cp;
#line 306
            cp ++;
#line 306
            tmp___1 = pp;
#line 306
            pp ++;
#line 306
            if (! ((int )*tmp___0 == (int )*tmp___1)) {
#line 306
              goto while_break___1;
            }
          } else {
#line 306
            goto while_break___1;
          }
        } else {
#line 306
          goto while_break___1;
        }
#line 307
        len ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 309
      if (len > c->unique_len) {
#line 310
        c->unique_len = len;
      }
      __Cont___0: /* CIL Label */ 
#line 294
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    if (c->children) {
      {
#line 314
      cli_build_shortest(cli, c->children);
      }
    }
    __Cont: /* CIL Label */ 
#line 287
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (0);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_set_privilege(struct cli_def *cli , int priv ) 
{ 
  int old ;
  char const   *tmp ;

  {
#line 322
  old = cli->privilege;
#line 323
  cli->privilege = priv;
#line 325
  if (priv != old) {
#line 327
    if (priv == 15) {
#line 327
      tmp = "# ";
    } else {
#line 327
      tmp = "> ";
    }
    {
#line 327
    cli_set_promptchar(cli, tmp);
#line 328
    cli_build_shortest(cli, cli->commands);
    }
  }
#line 331
  return (old);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_modestring(struct cli_def *cli , char const   *modestring ) 
{ 


  {
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (cli->modestring) {
      {
#line 336
      free((void *)cli->modestring);
#line 336
      cli->modestring = (char *)0;
      }
    }
#line 336
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (modestring) {
    {
#line 338
    cli->modestring = strdup(modestring);
    }
  }
#line 339
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_set_configmode(struct cli_def *cli , int mode , char const   *config_desc ) 
{ 
  int old ;
  char string[64] ;

  {
#line 343
  old = cli->mode;
#line 344
  cli->mode = mode;
#line 346
  if (mode != old) {
#line 348
    if (! cli->mode) {
      {
#line 351
      cli_set_modestring(cli, (char const   *)((void *)0));
      }
    } else
#line 353
    if (config_desc) {
#line 353
      if (*config_desc) {
        {
#line 356
        snprintf((char */* __restrict  */)(string), sizeof(string), (char const   */* __restrict  */)"(config-%s)",
                 config_desc);
#line 357
        cli_set_modestring(cli, (char const   *)(string));
        }
      } else {
        {
#line 361
        cli_set_modestring(cli, "(config)");
        }
      }
    } else {
      {
#line 361
      cli_set_modestring(cli, "(config)");
      }
    }
    {
#line 364
    cli_build_shortest(cli, cli->commands);
    }
  }
#line 367
  return (old);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
struct cli_command *cli_register_command(struct cli_def *cli , struct cli_command *parent ,
                                         char const   *command , int (*callback)(struct cli_def *cli ,
                                                                                 char const   * ,
                                                                                 char ** ,
                                                                                 int  ) ,
                                         int privilege , int mode , char const   *help ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 376
  if (! command) {
#line 376
    return ((struct cli_command *)((void *)0));
  }
  {
#line 377
  tmp = calloc(sizeof(struct cli_command ), (size_t )1);
#line 377
  c = (struct cli_command *)tmp;
  }
#line 377
  if (! c) {
#line 377
    return ((struct cli_command *)((void *)0));
  }
  {
#line 379
  c->callback = callback;
#line 380
  c->next = (struct cli_command *)((void *)0);
#line 381
  tmp___0 = strdup(command);
#line 381
  c->command = tmp___0;
  }
#line 381
  if (! tmp___0) {
#line 382
    return ((struct cli_command *)((void *)0));
  }
#line 383
  c->parent = parent;
#line 384
  c->privilege = privilege;
#line 385
  c->mode = mode;
#line 386
  if (help) {
    {
#line 386
    tmp___1 = strdup(help);
#line 386
    c->help = tmp___1;
    }
#line 386
    if (! tmp___1) {
#line 387
      return ((struct cli_command *)((void *)0));
    }
  }
#line 389
  if (parent) {
#line 391
    if (! parent->children) {
#line 393
      parent->children = c;
    } else {
#line 397
      p = parent->children;
      {
#line 397
      while (1) {
        while_continue: /* CIL Label */ ;
#line 397
        if (p) {
#line 397
          if (! p->next) {
#line 397
            goto while_break;
          }
        } else {
#line 397
          goto while_break;
        }
#line 397
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 398
      if (p) {
#line 398
        p->next = c;
      }
    }
  } else
#line 403
  if (! cli->commands) {
#line 405
    cli->commands = c;
  } else {
#line 409
    p = cli->commands;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (p) {
#line 409
        if (! p->next) {
#line 409
          goto while_break___0;
        }
      } else {
#line 409
        goto while_break___0;
      }
#line 409
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    if (p) {
#line 410
      p->next = c;
    }
  }
#line 413
  return (c);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static void cli_free_command(struct cli_command *cmd ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;

  {
#line 420
  c = cmd->children;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! c) {
#line 420
      goto while_break;
    }
    {
#line 422
    p = c->next;
#line 423
    cli_free_command(c);
#line 424
    c = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  free((void *)cmd->command);
  }
#line 428
  if (cmd->help) {
    {
#line 428
    free((void *)cmd->help);
    }
  }
  {
#line 429
  free((void *)cmd);
  }
#line 430
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_unregister_command(struct cli_def *cli , char const   *command ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;
  int tmp ;

  {
#line 434
  p = (struct cli_command *)((void *)0);
#line 436
  if (! command) {
#line 436
    return (-1);
  }
#line 437
  if (! cli->commands) {
#line 437
    return (0);
  }
#line 439
  c = cli->commands;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! c) {
#line 439
      goto while_break;
    }
    {
#line 441
    tmp = strcmp((char const   *)c->command, command);
    }
#line 441
    if (tmp == 0) {
#line 443
      if (p) {
#line 444
        p->next = c->next;
      } else {
#line 446
        cli->commands = c->next;
      }
      {
#line 448
      cli_free_command(c);
      }
#line 449
      return (0);
    }
#line 451
    p = c;
#line 439
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_show_help(struct cli_def *cli , struct cli_command *c ) 
{ 
  struct cli_command *p ;
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 461
  p = c;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! p) {
#line 461
      goto while_break;
    }
#line 463
    if (p->command) {
#line 463
      if (p->callback) {
#line 463
        if (cli->privilege >= p->privilege) {
#line 463
          if (p->mode == cli->mode) {
#line 463
            goto _L;
          } else
#line 463
          if (p->mode == -1) {
            _L: /* CIL Label */ 
#line 466
            if ((unsigned long )p->help != (unsigned long )((void *)0)) {
#line 466
              tmp = (char const   *)p->help;
            } else {
#line 466
              tmp = "";
            }
            {
#line 466
            tmp___0 = cli_command_name(cli, p);
#line 466
            cli_error(cli, "  %-20s %s", tmp___0, tmp);
            }
          }
        }
      }
    }
#line 469
    if (p->children) {
      {
#line 470
      cli_show_help(cli, p->children);
      }
    }
#line 461
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return (0);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_enable(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                   char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 


  {
#line 478
  if (cli->privilege == 15) {
#line 479
    return (0);
  }
#line 481
  if (! cli->enable_password) {
#line 481
    if (! cli->enable_callback) {
      {
#line 484
      cli_set_privilege(cli, 15);
#line 485
      cli_set_configmode(cli, 0, (char const   *)((void *)0));
      }
    } else {
#line 490
      cli->state = 3;
    }
  } else {
#line 490
    cli->state = 3;
  }
#line 493
  return (0);
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_disable(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                    char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 498
  cli_set_privilege(cli, 0);
#line 499
  cli_set_configmode(cli, 0, (char const   *)((void *)0));
  }
#line 500
  return (0);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_help(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                 char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 505
  cli_error(cli, "\nCommands available:");
#line 506
  cli_show_help(cli, cli->commands);
  }
#line 507
  return (0);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_history(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                    char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 
  int i ;

  {
  {
#line 514
  cli_error(cli, "\nCommand history:");
#line 515
  i = 0;
  }
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! (i < 256)) {
#line 515
      goto while_break;
    }
#line 517
    if (cli->history[i]) {
      {
#line 518
      cli_error(cli, "%3d. %s", i, cli->history[i]);
      }
    }
#line 515
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_quit(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                 char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 526
  cli_set_privilege(cli, 0);
#line 527
  cli_set_configmode(cli, 0, (char const   *)((void *)0));
  }
#line 528
  return (-2);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_exit(struct cli_def *cli , char const   *command , char **argv , int argc ) 
{ 
  int tmp ;

  {
#line 533
  if (cli->mode == 0) {
    {
#line 534
    tmp = cli_int_quit(cli, command, argv, argc);
    }
#line 534
    return (tmp);
  }
#line 536
  if (cli->mode > 1) {
    {
#line 537
    cli_set_configmode(cli, 1, (char const   *)((void *)0));
    }
  } else {
    {
#line 539
    cli_set_configmode(cli, 0, (char const   *)((void *)0));
    }
  }
#line 541
  cli->service = (void *)0;
#line 542
  return (0);
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_idle_timeout(struct cli_def *cli ) 
{ 


  {
  {
#line 547
  cli_print(cli, "Idle timeout");
  }
#line 548
  return (-2);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_int_configure_terminal(struct cli_def *cli , char const   *command  __attribute__((__unused__)) ,
                               char **argv  __attribute__((__unused__)) , int argc  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 553
  cli_set_configmode(cli, 1, (char const   *)((void *)0));
  }
#line 554
  return (0);
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
struct cli_def *cli_init(void) 
{ 
  struct cli_def *cli ;
  struct cli_command *c ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 562
  tmp = calloc(sizeof(struct cli_def ), (size_t )1);
#line 562
  cli = (struct cli_def *)tmp;
  }
#line 562
  if (! cli) {
#line 563
    return ((struct cli_def *)0);
  }
  {
#line 565
  cli->buf_size = 1024U;
#line 566
  tmp___1 = calloc((size_t )cli->buf_size, (size_t )1);
#line 566
  tmp___0 = (char *)tmp___1;
#line 566
  cli->buffer = tmp___0;
  }
#line 566
  if (! tmp___0) {
    {
#line 568
    while (1) {
      while_continue: /* CIL Label */ ;
#line 568
      if (cli) {
        {
#line 568
        free((void *)cli);
#line 568
        cli = (struct cli_def *)0;
        }
      }
#line 568
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 569
    return ((struct cli_def *)0);
  }
  {
#line 571
  cli->telnet_protocol = 1;
#line 573
  cli_register_command(cli, (struct cli_command *)0, "help", & cli_int_help, 0, -1,
                       "Show available commands");
#line 574
  cli_register_command(cli, (struct cli_command *)0, "quit", & cli_int_quit, 0, -1,
                       "Disconnect");
#line 575
  cli_register_command(cli, (struct cli_command *)0, "logout", & cli_int_quit, 0,
                       -1, "Disconnect");
#line 576
  cli_register_command(cli, (struct cli_command *)0, "exit", & cli_int_exit, 0, -1,
                       "Exit from current mode");
#line 577
  cli_register_command(cli, (struct cli_command *)0, "history", & cli_int_history,
                       0, -1, "Show a list of previously run commands");
#line 579
  cli_register_command(cli, (struct cli_command *)0, "enable", & cli_int_enable, 0,
                       0, "Turn on privileged commands");
#line 581
  cli_register_command(cli, (struct cli_command *)0, "disable", & cli_int_disable,
                       15, 0, "Turn off privileged commands");
#line 584
  c = cli_register_command(cli, (struct cli_command *)0, "configure", (int (*)(struct cli_def *cli ,
                                                                               char const   * ,
                                                                               char ** ,
                                                                               int  ))0,
                           15, 0, "Enter configuration mode");
#line 585
  cli_register_command(cli, c, "terminal", & cli_int_configure_terminal, 15, 0, "Configure from the terminal");
#line 588
  tmp___2 = -1;
#line 588
  cli->mode = tmp___2;
#line 588
  cli->privilege = tmp___2;
#line 589
  cli_set_privilege(cli, 0);
#line 590
  cli_set_configmode(cli, 0, (char const   *)0);
#line 593
  cli->timeout_tm.tv_sec = (__time_t )1;
#line 594
  cli->timeout_tm.tv_usec = (__suseconds_t )0;
#line 597
  cli_set_idle_timeout_callback(cli, 0U, & cli_int_idle_timeout);
  }
#line 598
  return (cli);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_unregister_all(struct cli_def *cli , struct cli_command *command ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;

  {
#line 603
  p = (struct cli_command *)((void *)0);
#line 605
  if (! command) {
#line 605
    command = cli->commands;
  }
#line 606
  if (! command) {
#line 606
    return;
  }
#line 608
  c = command;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! c) {
#line 608
      goto while_break;
    }
#line 610
    p = c->next;
#line 613
    if (c->children) {
      {
#line 614
      cli_unregister_all(cli, c->children);
      }
    }
#line 616
    if (c->command) {
      {
#line 616
      free((void *)c->command);
      }
    }
#line 617
    if (c->help) {
      {
#line 617
      free((void *)c->help);
      }
    }
    {
#line 618
    free((void *)c);
#line 620
    c = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return;
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_done(struct cli_def *cli ) 
{ 
  struct unp *u ;
  struct unp *n ;

  {
#line 626
  u = cli->users;
#line 628
  if (! cli) {
#line 628
    return (0);
  }
  {
#line 629
  cli_free_history(cli);
  }
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! u) {
#line 632
      goto while_break;
    }
#line 634
    if (u->username) {
      {
#line 634
      free((void *)u->username);
      }
    }
#line 635
    if (u->password) {
      {
#line 635
      free((void *)u->password);
      }
    }
    {
#line 636
    n = u->next;
#line 637
    free((void *)u);
#line 638
    u = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 642
  cli_unregister_all(cli, (struct cli_command *)0);
  }
  {
#line 644
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 644
    if (cli->commandname) {
      {
#line 644
      free((void *)cli->commandname);
#line 644
      cli->commandname = (char *)0;
      }
    }
#line 644
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 645
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 645
    if (cli->modestring) {
      {
#line 645
      free((void *)cli->modestring);
#line 645
      cli->modestring = (char *)0;
      }
    }
#line 645
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 646
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 646
    if (cli->banner) {
      {
#line 646
      free((void *)cli->banner);
#line 646
      cli->banner = (char *)0;
      }
    }
#line 646
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 647
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 647
    if (cli->promptchar) {
      {
#line 647
      free((void *)cli->promptchar);
#line 647
      cli->promptchar = (char *)0;
      }
    }
#line 647
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 648
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 648
    if (cli->hostname) {
      {
#line 648
      free((void *)cli->hostname);
#line 648
      cli->hostname = (char *)0;
      }
    }
#line 648
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 649
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 649
    if (cli->buffer) {
      {
#line 649
      free((void *)cli->buffer);
#line 649
      cli->buffer = (char *)0;
      }
    }
#line 649
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 650
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 650
    if (cli) {
      {
#line 650
      free((void *)cli);
#line 650
      cli = (struct cli_def *)0;
      }
    }
#line 650
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 652
  return (0);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_add_history(struct cli_def *cli , char const   *cmd ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 658
  i = 0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (i < 256)) {
#line 658
      goto while_break;
    }
#line 660
    if (! cli->history[i]) {
#line 662
      if (i == 0) {
#line 662
        goto _L;
      } else {
        {
#line 662
        tmp___0 = strcasecmp((char const   *)cli->history[i - 1], cmd);
        }
#line 662
        if (tmp___0) {
          _L: /* CIL Label */ 
          {
#line 663
          tmp = strdup(cmd);
#line 663
          cli->history[i] = tmp;
          }
#line 663
          if (! tmp) {
#line 664
            return (-1);
          }
        }
      }
#line 665
      return (0);
    }
#line 658
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  free((void *)cli->history[0]);
#line 670
  i = 0;
  }
  {
#line 670
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 670
    if (! (i < 255)) {
#line 670
      goto while_break___0;
    }
#line 671
    cli->history[i] = cli->history[i + 1];
#line 670
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 672
  tmp___1 = strdup(cmd);
#line 672
  cli->history[255] = tmp___1;
  }
#line 672
  if (! tmp___1) {
#line 673
    return (-1);
  }
#line 674
  return (0);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_free_history(struct cli_def *cli ) 
{ 
  int i ;

  {
#line 680
  i = 0;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! (i < 256)) {
#line 680
      goto while_break;
    }
#line 682
    if (cli->history[i]) {
      {
#line 683
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 683
        if (cli->history[i]) {
          {
#line 683
          free((void *)cli->history[i]);
#line 683
          cli->history[i] = (char *)0;
          }
        }
#line 683
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_parse_line(char const   *line , char **words , int max_words ) 
{ 
  int nwords ;
  char const   *p ;
  char const   *word_start ;
  int inquote ;
  unsigned short const   **tmp ;
  int len ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 689
  nwords = 0;
#line 690
  p = line;
#line 691
  word_start = (char const   *)0;
#line 692
  inquote = 0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! *p) {
#line 694
      goto while_break;
    }
    {
#line 696
    tmp = __ctype_b_loc();
    }
#line 696
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 698
      word_start = p;
#line 699
      goto while_break;
    }
#line 701
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 704
    if (! (nwords < max_words - 1)) {
#line 704
      goto while_break___0;
    }
#line 706
    if (! *p) {
#line 706
      goto _L___1;
    } else
#line 706
    if ((int const   )*p == (int const   )inquote) {
#line 706
      goto _L___1;
    } else
#line 706
    if (word_start) {
#line 706
      if (! inquote) {
        {
#line 706
        tmp___7 = __ctype_b_loc();
        }
#line 706
        if ((int const   )*(*tmp___7 + (int )*p) & 8192) {
#line 706
          goto _L___1;
        } else
#line 706
        if ((int const   )*p == 124) {
          _L___1: /* CIL Label */ 
#line 708
          if (word_start) {
            {
#line 710
            len = (int )(p - word_start);
#line 712
            tmp___1 = malloc((size_t )(len + 1));
#line 712
            tmp___0 = (char *)tmp___1;
#line 712
            *(words + nwords) = tmp___0;
#line 712
            memcpy((void */* __restrict  */)tmp___0, (void const   */* __restrict  */)word_start,
                   (size_t )len);
#line 713
            tmp___2 = nwords;
#line 713
            nwords ++;
#line 713
            *(*(words + tmp___2) + len) = (char)0;
            }
          }
#line 716
          if (! *p) {
#line 717
            goto while_break___0;
          }
#line 719
          if (inquote) {
#line 720
            p ++;
          }
#line 722
          inquote = 0;
#line 723
          word_start = (char const   *)0;
        } else {
#line 706
          goto _L___2;
        }
      } else {
#line 706
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 725
    if ((int const   )*p == 34) {
#line 727
      tmp___3 = p;
#line 727
      p ++;
#line 727
      inquote = (int )*tmp___3;
#line 728
      word_start = p;
    } else
#line 725
    if ((int const   )*p == 39) {
#line 727
      tmp___3 = p;
#line 727
      p ++;
#line 727
      inquote = (int )*tmp___3;
#line 728
      word_start = p;
    } else {
#line 732
      if (! word_start) {
#line 734
        if ((int const   )*p == 124) {
          {
#line 736
          tmp___4 = nwords;
#line 736
          nwords ++;
#line 736
          tmp___5 = strdup("|");
#line 736
          *(words + tmp___4) = tmp___5;
          }
#line 736
          if (! tmp___5) {
#line 737
            return (0);
          }
        } else {
          {
#line 739
          tmp___6 = __ctype_b_loc();
          }
#line 739
          if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 740
            word_start = p;
          }
        }
      }
#line 743
      p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 747
  return (nwords);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static char *join_words(int argc , char **argv ) 
{ 
  char *p ;
  int len ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 753
  len = 0;
#line 756
  i = 0;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    if (! (i < argc)) {
#line 756
      goto while_break;
    }
#line 758
    if (i) {
#line 759
      len ++;
    }
    {
#line 761
    tmp = strlen((char const   *)*(argv + i));
#line 761
    len = (int )((size_t )len + tmp);
#line 756
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 764
  tmp___0 = malloc((size_t )(len + 1));
#line 764
  p = (char *)tmp___0;
#line 765
  *(p + 0) = (char)0;
#line 767
  i = 0;
  }
  {
#line 767
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 767
    if (! (i < argc)) {
#line 767
      goto while_break___0;
    }
#line 769
    if (i) {
      {
#line 770
      strcat((char */* __restrict  */)p, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 772
    strcat((char */* __restrict  */)p, (char const   */* __restrict  */)*(argv + i));
#line 767
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 775
  return (p);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_find_command(struct cli_def *cli , struct cli_command *commands , int num_words ,
                            char **words , int start_word , int *filters ) 
{ 
  struct cli_command *c ;
  struct cli_command *again ;
  int c_words ;
  int l ;
  size_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int rc ;
  int f ;
  struct cli_filter **filt ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int n ;
  char **argv ;
  int argc ;
  int len ;
  size_t tmp___11 ;
  int i ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  struct cli_filter *filt___0 ;
  char const   *tmp___22 ;

  {
#line 781
  again = (struct cli_command *)((void *)0);
#line 782
  c_words = num_words;
#line 784
  if (*(filters + 0)) {
#line 785
    c_words = *(filters + 0);
  }
#line 788
  if (! *(words + start_word)) {
#line 789
    return (-1);
  }
  {
#line 791
  tmp___4 = strlen((char const   *)*(words + start_word));
  }
#line 791
  if ((int )*(*(words + start_word) + (tmp___4 - 1UL)) == 63) {
    {
#line 793
    tmp = strlen((char const   *)*(words + start_word));
#line 793
    l = (int )(tmp - 1UL);
    }
#line 795
    if (commands->parent) {
#line 795
      if ((commands->parent)->callback) {
#line 796
        if ((unsigned long )(commands->parent)->help != (unsigned long )((void *)0)) {
#line 796
          tmp___0 = (char const   *)(commands->parent)->help;
        } else {
#line 796
          tmp___0 = "";
        }
        {
#line 796
        tmp___1 = cli_command_name(cli, commands->parent);
#line 796
        cli_error(cli, "%-20s %s", tmp___1, tmp___0);
        }
      }
    }
#line 799
    c = commands;
    {
#line 799
    while (1) {
      while_continue: /* CIL Label */ ;
#line 799
      if (! c) {
#line 799
        goto while_break;
      }
      {
#line 801
      tmp___3 = strncasecmp((char const   *)c->command, (char const   *)*(words + start_word),
                            (size_t )l);
      }
#line 801
      if (tmp___3 == 0) {
#line 801
        if (c->callback) {
#line 801
          goto _L___0;
        } else
#line 801
        if (c->children) {
          _L___0: /* CIL Label */ 
#line 801
          if (cli->privilege >= c->privilege) {
#line 801
            if (c->mode == cli->mode) {
#line 801
              goto _L;
            } else
#line 801
            if (c->mode == -1) {
              _L: /* CIL Label */ 
#line 805
              if ((unsigned long )c->help != (unsigned long )((void *)0)) {
#line 805
                tmp___2 = (char const   *)c->help;
              } else {
#line 805
                tmp___2 = "";
              }
              {
#line 805
              cli_error(cli, "  %-20s %s", c->command, tmp___2);
              }
            }
          }
        }
      }
#line 799
      c = c->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 808
    return (0);
  }
#line 811
  c = commands;
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 811
    if (! c) {
#line 811
      goto while_break___0;
    }
#line 813
    if (cli->privilege < c->privilege) {
#line 814
      goto __Cont;
    }
    {
#line 816
    tmp___5 = strncasecmp((char const   *)c->command, (char const   *)*(words + start_word),
                          (size_t )c->unique_len);
    }
#line 816
    if (tmp___5) {
#line 817
      goto __Cont;
    }
    {
#line 819
    tmp___6 = strlen((char const   *)*(words + start_word));
#line 819
    tmp___7 = strncasecmp((char const   *)c->command, (char const   *)*(words + start_word),
                          tmp___6);
    }
#line 819
    if (tmp___7) {
#line 820
      goto __Cont;
    }
    AGAIN: 
#line 823
    if (c->mode == cli->mode) {
#line 823
      goto _L___1;
    } else
#line 823
    if (c->mode == -1) {
      _L___1: /* CIL Label */ 
#line 825
      rc = 0;
#line 827
      filt = & cli->filters;
#line 830
      if (! c->children) {
#line 833
        if (! c->callback) {
          {
#line 835
          tmp___8 = cli_command_name(cli, c);
#line 835
          cli_error(cli, "No callback for \"%s\"", tmp___8);
          }
#line 836
          return (-1);
        }
      } else {
#line 841
        if (start_word == c_words - 1) {
#line 843
          if (c->callback) {
#line 844
            goto CORRECT_CHECKS;
          }
          {
#line 846
          cli_error(cli, "Incomplete command");
          }
#line 847
          return (-1);
        }
        {
#line 849
        rc = cli_find_command(cli, c->children, num_words, words, start_word + 1,
                              filters);
        }
#line 850
        if (rc == -3) {
#line 852
          if (c->callback) {
#line 854
            rc = 0;
#line 855
            goto CORRECT_CHECKS;
          } else {
#line 859
            if (commands->parent) {
#line 859
              tmp___9 = "argument";
            } else {
#line 859
              tmp___9 = "command";
            }
            {
#line 859
            cli_error(cli, "Invalid %s \"%s\"", tmp___9, *(words + start_word));
            }
          }
        }
#line 863
        return (rc);
      }
#line 866
      if (! c->callback) {
        {
#line 868
        tmp___10 = cli_command_name(cli, c);
#line 868
        cli_error(cli, "Internal server error processing \"%s\"", tmp___10);
        }
#line 869
        return (-1);
      }
      CORRECT_CHECKS: 
#line 873
      f = 0;
      {
#line 873
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 873
        if (rc == 0) {
#line 873
          if (! *(filters + f)) {
#line 873
            goto while_break___1;
          }
        } else {
#line 873
          goto while_break___1;
        }
#line 875
        n = num_words;
#line 880
        if (*(filters + (f + 1))) {
#line 881
          n = *(filters + (f + 1));
        }
#line 883
        if (*(filters + f) == n - 1) {
          {
#line 885
          cli_error(cli, "Missing filter");
          }
#line 886
          return (-1);
        }
        {
#line 889
        argv = (words + *(filters + f)) + 1;
#line 890
        argc = n - (*(filters + f) + 1);
#line 891
        tmp___11 = strlen((char const   *)*(argv + 0));
#line 891
        len = (int )tmp___11;
#line 892
        tmp___12 = strlen((char const   *)*(argv + (argc - 1)));
        }
#line 892
        if ((int )*(*(argv + (argc - 1)) + (tmp___12 - 1UL)) == 63) {
#line 894
          if (argc == 1) {
#line 897
            i = 0;
            {
#line 897
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 897
              if (! filter_cmds[i].cmd) {
#line 897
                goto while_break___2;
              }
              {
#line 898
              cli_error(cli, "  %-20s %s", filter_cmds[i].cmd, filter_cmds[i].help);
#line 897
              i ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
#line 902
            if ((int )*(*(argv + 0) + 0) != 99) {
              {
#line 903
              cli_error(cli, "  WORD");
              }
            }
#line 905
            if (argc > 2) {
              {
#line 906
              cli_error(cli, "  <cr>");
              }
            } else
#line 905
            if ((int )*(*(argv + 0) + 0) == 99) {
              {
#line 906
              cli_error(cli, "  <cr>");
              }
            }
          }
#line 909
          return (0);
        }
#line 912
        if ((int )*(*(argv + 0) + 0) == 98) {
#line 912
          if (len < 3) {
            {
#line 914
            cli_error(cli, "Ambiguous filter \"%s\" (begin, between)", *(argv + 0));
            }
#line 915
            return (-1);
          }
        }
        {
#line 917
        tmp___13 = calloc(sizeof(struct cli_filter ), (size_t )1);
#line 917
        *filt = (struct cli_filter *)tmp___13;
#line 919
        tmp___17 = strncmp("include", (char const   *)*(argv + 0), (size_t )len);
        }
#line 919
        if (tmp___17) {
          {
#line 919
          tmp___18 = strncmp("exclude", (char const   *)*(argv + 0), (size_t )len);
          }
#line 919
          if (tmp___18) {
            {
#line 919
            tmp___19 = strncmp("grep", (char const   *)*(argv + 0), (size_t )len);
            }
#line 919
            if (tmp___19) {
              {
#line 919
              tmp___20 = strncmp("egrep", (char const   *)*(argv + 0), (size_t )len);
              }
#line 919
              if (tmp___20) {
                {
#line 922
                tmp___15 = strncmp("begin", (char const   *)*(argv + 0), (size_t )len);
                }
#line 922
                if (tmp___15) {
                  {
#line 922
                  tmp___16 = strncmp("between", (char const   *)*(argv + 0), (size_t )len);
                  }
#line 922
                  if (tmp___16) {
                    {
#line 924
                    tmp___14 = strncmp("count", (char const   *)*(argv + 0), (size_t )len);
                    }
#line 924
                    if (tmp___14) {
                      {
#line 928
                      cli_error(cli, "Invalid filter \"%s\"", *(argv + 0));
#line 929
                      rc = -1;
                      }
                    } else {
                      {
#line 925
                      rc = cli_count_filter_init(cli, argc, argv, *filt);
                      }
                    }
                  } else {
                    {
#line 923
                    rc = cli_range_filter_init(cli, argc, argv, *filt);
                    }
                  }
                } else {
                  {
#line 923
                  rc = cli_range_filter_init(cli, argc, argv, *filt);
                  }
                }
              } else {
                {
#line 921
                rc = cli_match_filter_init(cli, argc, argv, *filt);
                }
              }
            } else {
              {
#line 921
              rc = cli_match_filter_init(cli, argc, argv, *filt);
              }
            }
          } else {
            {
#line 921
            rc = cli_match_filter_init(cli, argc, argv, *filt);
            }
          }
        } else {
          {
#line 921
          rc = cli_match_filter_init(cli, argc, argv, *filt);
          }
        }
#line 932
        if (rc == 0) {
#line 934
          filt = & (*filt)->next;
        } else {
          {
#line 938
          free((void *)*filt);
#line 939
          *filt = (struct cli_filter *)0;
          }
        }
#line 873
        f ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 943
      if (rc == 0) {
        {
#line 944
        tmp___21 = cli_command_name(cli, c);
#line 944
        rc = (*(c->callback))(cli, (char const   *)tmp___21, (words + start_word) + 1,
                              (c_words - start_word) - 1);
        }
      }
      {
#line 946
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 946
        if (! cli->filters) {
#line 946
          goto while_break___3;
        }
        {
#line 948
        filt___0 = cli->filters;
#line 951
        (*(filt___0->filter))(cli, (char const   *)((void *)0), filt___0->data);
#line 952
        cli->filters = filt___0->next;
#line 953
        free((void *)filt___0);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 956
      return (rc);
    } else
#line 958
    if (cli->mode > 1) {
#line 958
      if (c->mode == 1) {
#line 962
        again = c;
      }
    }
    __Cont: /* CIL Label */ 
#line 811
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 967
  if (again) {
    {
#line 969
    c = again;
#line 970
    cli_set_configmode(cli, 1, (char const   *)((void *)0));
    }
#line 971
    goto AGAIN;
  }
#line 974
  if (start_word == 0) {
#line 975
    if (commands->parent) {
#line 975
      tmp___22 = "argument";
    } else {
#line 975
      tmp___22 = "command";
    }
    {
#line 975
    cli_error(cli, "Invalid %s \"%s\"", tmp___22, *(words + start_word));
    }
  }
#line 977
  return (-3);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_run_command(struct cli_def *cli , char const   *command ) 
{ 
  int r ;
  unsigned int num_words ;
  unsigned int i ;
  unsigned int f ;
  char *words[128] ;
  unsigned int tmp ;
  int filters[128] ;
  unsigned int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 984
  words[0] = (char *)0;
#line 984
  tmp = 1U;
  {
#line 984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 984
    if (tmp >= 128U) {
#line 984
      goto while_break;
    }
#line 984
    words[tmp] = (char *)0;
#line 984
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 985
  filters[0] = 0;
#line 985
  tmp___0 = 1U;
  {
#line 985
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 985
    if (tmp___0 >= 128U) {
#line 985
      goto while_break___0;
    }
#line 985
    filters[tmp___0] = 0;
#line 985
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 987
  if (! command) {
#line 987
    return (-1);
  }
  {
#line 988
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 988
    tmp___1 = __ctype_b_loc();
    }
#line 988
    if (! ((int const   )*(*tmp___1 + (int )*command) & 8192)) {
#line 988
      goto while_break___1;
    }
#line 989
    command ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 991
  if (! *command) {
#line 991
    return (0);
  }
  {
#line 993
  tmp___2 = cli_parse_line(command, words, 128);
#line 993
  num_words = (unsigned int )tmp___2;
#line 994
  f = 0U;
#line 994
  i = f;
  }
  {
#line 994
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 994
    if (i < num_words) {
#line 994
      if (! (f < 127U)) {
#line 994
        goto while_break___2;
      }
    } else {
#line 994
      goto while_break___2;
    }
#line 996
    if ((int )*(words[i] + 0) == 124) {
#line 997
      tmp___3 = f;
#line 997
      f ++;
#line 997
      filters[tmp___3] = (int )i;
    }
#line 994
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1000
  filters[f] = 0;
#line 1002
  if (num_words) {
    {
#line 1003
    r = cli_find_command(cli, cli->commands, (int )num_words, words, 0, filters);
    }
  } else {
#line 1005
    r = -1;
  }
#line 1007
  i = 0U;
  {
#line 1007
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1007
    if (! (i < num_words)) {
#line 1007
      goto while_break___3;
    }
    {
#line 1008
    free((void *)words[i]);
#line 1007
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1010
  if (r == -2) {
#line 1011
    return (r);
  }
#line 1013
  return (0);
}
}
#line 1016 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_get_completions(struct cli_def *cli , char const   *command , char **completions ,
                               int max_completions ) 
{ 
  struct cli_command *c ;
  struct cli_command *n ;
  int num_words ;
  int i ;
  int k ;
  char *words[128] ;
  unsigned int tmp ;
  int filter ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned int len ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 1020
  k = 0;
#line 1021
  words[0] = (char *)0;
#line 1021
  tmp = 1U;
  {
#line 1021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1021
    if (tmp >= 128U) {
#line 1021
      goto while_break;
    }
#line 1021
    words[tmp] = (char *)0;
#line 1021
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1022
  filter = 0;
#line 1024
  if (! command) {
#line 1024
    return (0);
  }
  {
#line 1025
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1025
    tmp___0 = __ctype_b_loc();
    }
#line 1025
    if (! ((int const   )*(*tmp___0 + (int )*command) & 8192)) {
#line 1025
      goto while_break___0;
    }
#line 1026
    command ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1028
  num_words = cli_parse_line(command, words, (int )(sizeof(words) / sizeof(words[0])));
  }
#line 1029
  if (! *(command + 0)) {
#line 1030
    num_words ++;
  } else {
    {
#line 1029
    tmp___1 = strlen(command);
    }
#line 1029
    if ((int const   )*(command + (tmp___1 - 1UL)) == 32) {
#line 1030
      num_words ++;
    }
  }
#line 1032
  if (! num_words) {
#line 1033
    return (0);
  }
#line 1035
  i = 0;
  {
#line 1035
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1035
    if (! (i < num_words)) {
#line 1035
      goto while_break___1;
    }
#line 1037
    if (words[i]) {
#line 1037
      if ((int )*(words[i] + 0) == 124) {
#line 1038
        filter = i;
      }
    }
#line 1035
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1041
  if (filter) {
#line 1043
    len = 0U;
#line 1045
    if (filter < num_words - 1) {
#line 1046
      return (0);
    }
#line 1048
    if (filter == num_words - 1) {
      {
#line 1049
      tmp___2 = strlen((char const   *)words[num_words - 1]);
#line 1049
      len = (unsigned int )tmp___2;
      }
    }
#line 1051
    i = 0;
    {
#line 1051
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1051
      if (filter_cmds[i].cmd) {
#line 1051
        if (! (k < max_completions)) {
#line 1051
          goto while_break___2;
        }
      } else {
#line 1051
        goto while_break___2;
      }
#line 1053
      if (! len) {
#line 1054
        tmp___3 = k;
#line 1054
        k ++;
#line 1054
        *(completions + tmp___3) = (char *)filter_cmds[i].cmd;
      } else {
        {
#line 1053
        tmp___4 = strlen(filter_cmds[i].cmd);
        }
#line 1053
        if ((size_t )len < tmp___4) {
          {
#line 1053
          tmp___5 = strncmp(filter_cmds[i].cmd, (char const   *)words[num_words - 1],
                            (size_t )len);
          }
#line 1053
          if (! tmp___5) {
#line 1054
            tmp___3 = k;
#line 1054
            k ++;
#line 1054
            *(completions + tmp___3) = (char *)filter_cmds[i].cmd;
          }
        }
      }
#line 1051
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1057
    *(completions + k) = (char *)((void *)0);
#line 1058
    return (k);
  }
#line 1061
  c = cli->commands;
#line 1061
  i = 0;
  {
#line 1061
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1061
    if (c) {
#line 1061
      if (i < num_words) {
#line 1061
        if (! (k < max_completions)) {
#line 1061
          goto while_break___3;
        }
      } else {
#line 1061
        goto while_break___3;
      }
    } else {
#line 1061
      goto while_break___3;
    }
#line 1063
    n = c->next;
#line 1065
    if (cli->privilege < c->privilege) {
#line 1066
      goto __Cont;
    }
#line 1068
    if (c->mode != cli->mode) {
#line 1068
      if (c->mode != -1) {
#line 1069
        goto __Cont;
      }
    }
#line 1071
    if (words[i]) {
      {
#line 1071
      tmp___6 = strlen((char const   *)words[i]);
#line 1071
      tmp___7 = strncasecmp((char const   *)c->command, (char const   *)words[i],
                            tmp___6);
      }
#line 1071
      if (tmp___7) {
#line 1072
        goto __Cont;
      }
    }
#line 1074
    if (i < num_words - 1) {
      {
#line 1076
      tmp___8 = strlen((char const   *)words[i]);
      }
#line 1076
      if (tmp___8 < (size_t )c->unique_len) {
#line 1077
        goto __Cont;
      }
#line 1079
      n = c->children;
#line 1080
      i ++;
#line 1081
      goto __Cont;
    }
#line 1084
    tmp___9 = k;
#line 1084
    k ++;
#line 1084
    *(completions + tmp___9) = c->command;
    __Cont: /* CIL Label */ 
#line 1061
    c = n;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1087
  return (k);
}
}
#line 1090 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static void cli_clear_line(int sockfd , char *cmd , int l , int cursor ) 
{ 
  int i ;

  {
#line 1093
  if (cursor < l) {
#line 1095
    i = 0;
    {
#line 1095
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1095
      if (! (i < l - cursor)) {
#line 1095
        goto while_break;
      }
      {
#line 1096
      _write(sockfd, (void const   *)" ", (size_t )1);
#line 1095
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1098
  i = 0;
  {
#line 1098
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1098
    if (! (i < l)) {
#line 1098
      goto while_break___0;
    }
#line 1099
    *(cmd + i) = (char )'\b';
#line 1098
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1100
    if (! (i < l * 2)) {
#line 1100
      goto while_break___1;
    }
#line 1101
    *(cmd + i) = (char )' ';
#line 1100
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1102
    if (! (i < l * 3)) {
#line 1102
      goto while_break___2;
    }
#line 1103
    *(cmd + i) = (char )'\b';
#line 1102
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1104
  _write(sockfd, (void const   *)cmd, (size_t )i);
#line 1105
  memset((void *)cmd, 0, (size_t )i);
#line 1106
  cursor = 0;
#line 1106
  l = cursor;
  }
#line 1107
  return;
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_reprompt(struct cli_def *cli ) 
{ 


  {
#line 1111
  if (! cli) {
#line 1111
    return;
  }
#line 1112
  cli->showprompt = (char)1;
#line 1113
  return;
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_regular(struct cli_def *cli , int (*callback)(struct cli_def *cli ) ) 
{ 


  {
#line 1117
  if (! cli) {
#line 1117
    return;
  }
#line 1118
  cli->regular_callback = callback;
#line 1119
  return;
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_regular_interval(struct cli_def *cli , int seconds ) 
{ 


  {
#line 1123
  if (seconds < 1) {
#line 1123
    seconds = 1;
  }
#line 1124
  cli->timeout_tm.tv_sec = (__time_t )seconds;
#line 1125
  cli->timeout_tm.tv_usec = (__suseconds_t )0;
#line 1126
  return;
}
}
#line 1131 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int pass_matches(char const   *pass , char const   *try ) 
{ 
  int des ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1134
  tmp = strncasecmp(pass, "{crypt}", sizeof("{crypt}") - 1UL);
  }
#line 1134
  if (tmp) {
#line 1134
    tmp___0 = 0;
  } else {
#line 1134
    tmp___0 = 1;
  }
#line 1134
  des = tmp___0;
#line 1134
  if (des) {
#line 1135
    pass += sizeof("{crypt}") - 1UL;
  }
#line 1141
  if (des) {
    {
#line 1142
    tmp___1 = crypt(try, pass);
#line 1142
    try = (char const   *)tmp___1;
    }
  } else {
    {
#line 1141
    tmp___2 = strncmp(pass, "$1$", sizeof("$1$") - 1UL);
    }
#line 1141
    if (! tmp___2) {
      {
#line 1142
      tmp___1 = crypt(try, pass);
#line 1142
      try = (char const   *)tmp___1;
      }
    }
  }
  {
#line 1145
  tmp___3 = strcmp(pass, try);
  }
#line 1145
  if (tmp___3) {
#line 1145
    tmp___4 = 0;
  } else {
#line 1145
    tmp___4 = 1;
  }
#line 1145
  return (tmp___4);
}
}
#line 1150 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int show_prompt(struct cli_def *cli , int sockfd ) 
{ 
  int len ;
  size_t tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 1152
  len = 0;
#line 1154
  if (cli->hostname) {
    {
#line 1155
    tmp = strlen((char const   *)cli->hostname);
#line 1155
    tmp___0 = write(sockfd, (void const   *)cli->hostname, tmp);
#line 1155
    len = (int )((ssize_t )len + tmp___0);
    }
  }
#line 1157
  if (cli->modestring) {
    {
#line 1158
    tmp___1 = strlen((char const   *)cli->modestring);
#line 1158
    tmp___2 = write(sockfd, (void const   *)cli->modestring, tmp___1);
#line 1158
    len = (int )((ssize_t )len + tmp___2);
    }
  }
  {
#line 1160
  tmp___3 = strlen((char const   *)cli->promptchar);
#line 1160
  tmp___4 = write(sockfd, (void const   *)cli->promptchar, tmp___3);
  }
#line 1160
  return ((int )((ssize_t )len + tmp___4));
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static char const   *negotiate  =    "\377\373\003\377\373\001\377\375\003\377\375\001";
#line 1163 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_loop(struct cli_def *cli , int sockfd ) 
{ 
  unsigned char c ;
  int n ;
  int l ;
  int oldl ;
  int is_telnet_option ;
  int skip ;
  int esc ;
  int cursor ;
  int insertmode ;
  char *cmd ;
  char *oldcmd ;
  char *username ;
  char *password ;
  size_t tmp ;
  void *tmp___0 ;
  FILE *tmp___1 ;
  int in_history ;
  int lastchar ;
  struct timeval tm ;
  int sr ;
  fd_set r ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int n___0 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int __d0 ;
  int __d1 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  time_t tmp___9 ;
  int *tmp___10 ;
  ssize_t tmp___11 ;
  int back ;
  int nc ;
  int i ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int i___0 ;
  int cursorback ;
  int c___0 ;
  char *completions[128] ;
  int num_completions ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int i___1 ;
  size_t tmp___18 ;
  int history_found ;
  int i___2 ;
  size_t tmp___19 ;
  int i___3 ;
  int allowed ;
  int tmp___20 ;
  struct unp *u ;
  int tmp___21 ;
  int tmp___22 ;
  int allowed___0 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 1166
  oldl = 0;
#line 1166
  is_telnet_option = 0;
#line 1166
  skip = 0;
#line 1166
  esc = 0;
#line 1167
  cursor = 0;
#line 1167
  insertmode = 1;
#line 1168
  cmd = (char *)((void *)0);
#line 1168
  oldcmd = (char *)0;
#line 1169
  username = (char *)((void *)0);
#line 1169
  password = (char *)((void *)0);
#line 1171
  cli_build_shortest(cli, cli->commands);
#line 1172
  cli->state = 0;
#line 1174
  cli_free_history(cli);
  }
#line 1175
  if (cli->telnet_protocol) {
    {
#line 1182
    tmp = strlen(negotiate);
#line 1182
    _write(sockfd, (void const   *)negotiate, tmp);
    }
  }
  {
#line 1185
  tmp___0 = malloc((size_t )4096);
#line 1185
  cmd = (char *)tmp___0;
  }
#line 1185
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 1186
    return (-1);
  }
  {
#line 1196
  tmp___1 = fdopen(sockfd, "w+");
#line 1196
  cli->client = tmp___1;
  }
#line 1196
  if (! tmp___1) {
#line 1197
    return (-1);
  }
  {
#line 1200
  setbuf((FILE */* __restrict  */)cli->client, (char */* __restrict  */)((void *)0));
  }
#line 1201
  if (cli->banner) {
    {
#line 1202
    cli_error(cli, "%s", cli->banner);
    }
  }
#line 1205
  if (cli->idle_timeout) {
    {
#line 1206
    time(& cli->last_action);
    }
  }
  {
#line 1209
  cli_set_privilege(cli, 0);
#line 1210
  cli_set_configmode(cli, 0, (char const   *)((void *)0));
  }
#line 1213
  if (! cli->users) {
#line 1213
    if (! cli->auth_callback) {
#line 1214
      cli->state = 2;
    }
  }
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1218
    in_history = 0;
#line 1219
    lastchar = 0;
#line 1222
    cli->showprompt = (char)1;
#line 1224
    if (oldcmd) {
#line 1226
      cursor = oldl;
#line 1226
      l = cursor;
#line 1227
      *(oldcmd + l) = (char)0;
#line 1228
      cli->showprompt = (char)1;
#line 1229
      oldcmd = (char *)((void *)0);
#line 1230
      oldl = 0;
    } else {
      {
#line 1234
      memset((void *)cmd, 0, (size_t )4096);
#line 1235
      l = 0;
#line 1236
      cursor = 0;
      }
    }
    {
#line 1239
    memcpy((void */* __restrict  */)(& tm), (void const   */* __restrict  */)(& cli->timeout_tm),
           sizeof(tm));
    }
    {
#line 1241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1245
      if (cli->showprompt) {
#line 1247
        if (cli->state != 1) {
#line 1247
          if (cli->state != 3) {
            {
#line 1248
            _write(sockfd, (void const   *)"\r\n", (size_t )2);
            }
          }
        }
        {
#line 1252
        if (cli->state == 0) {
#line 1252
          goto case_0;
        }
#line 1256
        if (cli->state == 1) {
#line 1256
          goto case_1;
        }
#line 1261
        if (cli->state == 4) {
#line 1261
          goto case_4;
        }
#line 1261
        if (cli->state == 2) {
#line 1261
          goto case_4;
        }
#line 1272
        if (cli->state == 3) {
#line 1272
          goto case_3;
        }
#line 1250
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 1253
        tmp___2 = strlen("Username: ");
#line 1253
        _write(sockfd, (void const   *)"Username: ", tmp___2);
        }
#line 1254
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 1257
        tmp___3 = strlen("Password: ");
#line 1257
        _write(sockfd, (void const   *)"Password: ", tmp___3);
        }
#line 1258
        goto switch_break;
        case_4: /* CIL Label */ 
        case_2: /* CIL Label */ 
        {
#line 1262
        show_prompt(cli, sockfd);
#line 1263
        _write(sockfd, (void const   *)cmd, (size_t )l);
        }
#line 1264
        if (cursor < l) {
#line 1266
          n___0 = l - cursor;
          {
#line 1267
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1267
            tmp___4 = n___0;
#line 1267
            n___0 --;
#line 1267
            if (! tmp___4) {
#line 1267
              goto while_break___1;
            }
            {
#line 1268
            _write(sockfd, (void const   *)"\b", (size_t )1);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1270
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 1273
        tmp___5 = strlen("Password: ");
#line 1273
        _write(sockfd, (void const   *)"Password: ", tmp___5);
        }
#line 1274
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1278
        cli->showprompt = (char)0;
      }
      {
#line 1281
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1281
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& r.fds_bits[0]): "memory");
#line 1281
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1282
      r.fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockfd % (8 * (int )sizeof(__fd_mask ));
#line 1284
      sr = select(sockfd + 1, (fd_set */* __restrict  */)(& r), (fd_set */* __restrict  */)((void *)0),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tm));
      }
#line 1284
      if (sr < 0) {
        {
#line 1287
        tmp___6 = __errno_location();
        }
#line 1287
        if (*tmp___6 == 4) {
#line 1288
          goto while_continue___0;
        }
        {
#line 1290
        perror("select");
#line 1291
        l = -1;
        }
#line 1292
        goto while_break___0;
      }
#line 1295
      if (sr == 0) {
#line 1298
        if (cli->regular_callback) {
          {
#line 1298
          tmp___7 = (*(cli->regular_callback))(cli);
          }
#line 1298
          if (tmp___7 != 0) {
#line 1300
            l = -1;
#line 1301
            goto while_break___0;
          }
        }
#line 1304
        if (cli->idle_timeout) {
          {
#line 1306
          tmp___9 = time((time_t *)((void *)0));
          }
#line 1306
          if (tmp___9 - cli->last_action >= cli->idle_timeout) {
#line 1308
            if (cli->idle_timeout_callback) {
              {
#line 1311
              tmp___8 = (*(cli->idle_timeout_callback))(cli);
              }
#line 1311
              if (tmp___8 == 0) {
                {
#line 1314
                time(& cli->last_action);
                }
#line 1315
                goto while_continue___0;
              }
            }
#line 1319
            l = -1;
#line 1320
            goto while_break___0;
          }
        }
        {
#line 1324
        memcpy((void */* __restrict  */)(& tm), (void const   */* __restrict  */)(& cli->timeout_tm),
               sizeof(tm));
        }
#line 1325
        goto while_continue___0;
      }
      {
#line 1328
      tmp___11 = read(sockfd, (void *)(& c), (size_t )1);
#line 1328
      n = (int )tmp___11;
      }
#line 1328
      if (n < 0) {
        {
#line 1330
        tmp___10 = __errno_location();
        }
#line 1330
        if (*tmp___10 == 4) {
#line 1331
          goto while_continue___0;
        }
        {
#line 1333
        perror("read");
#line 1334
        l = -1;
        }
#line 1335
        goto while_break___0;
      }
#line 1338
      if (cli->idle_timeout) {
        {
#line 1339
        time(& cli->last_action);
        }
      }
#line 1341
      if (n == 0) {
#line 1343
        l = -1;
#line 1344
        goto while_break___0;
      }
#line 1347
      if (skip) {
#line 1349
        skip --;
#line 1350
        goto while_continue___0;
      }
#line 1353
      if ((int )c == 255) {
#line 1353
        if (! is_telnet_option) {
#line 1355
          is_telnet_option ++;
#line 1356
          goto while_continue___0;
        }
      }
#line 1359
      if (is_telnet_option) {
#line 1361
        if ((int )c >= 251) {
#line 1361
          if ((int )c <= 254) {
#line 1363
            is_telnet_option = (int )c;
#line 1364
            goto while_continue___0;
          }
        }
#line 1367
        if ((int )c != 255) {
#line 1369
          is_telnet_option = 0;
#line 1370
          goto while_continue___0;
        }
#line 1373
        is_telnet_option = 0;
      }
#line 1377
      if (esc) {
#line 1379
        if (esc == 91) {
          {
#line 1384
          if ((int )c == 65) {
#line 1384
            goto case_65;
          }
#line 1388
          if ((int )c == 66) {
#line 1388
            goto case_66;
          }
#line 1392
          if ((int )c == 67) {
#line 1392
            goto case_67;
          }
#line 1396
          if ((int )c == 68) {
#line 1396
            goto case_68;
          }
#line 1400
          goto switch_default;
          case_65: /* CIL Label */ 
#line 1385
          c = (unsigned char)16;
#line 1386
          goto switch_break___0;
          case_66: /* CIL Label */ 
#line 1389
          c = (unsigned char)14;
#line 1390
          goto switch_break___0;
          case_67: /* CIL Label */ 
#line 1393
          c = (unsigned char)6;
#line 1394
          goto switch_break___0;
          case_68: /* CIL Label */ 
#line 1397
          c = (unsigned char)2;
#line 1398
          goto switch_break___0;
          switch_default: /* CIL Label */ 
#line 1401
          c = (unsigned char)0;
          switch_break___0: /* CIL Label */ ;
          }
#line 1404
          esc = 0;
        } else {
#line 1408
          if ((int )c == 91) {
#line 1408
            esc = (int )c;
          } else {
#line 1408
            esc = 0;
          }
#line 1409
          goto while_continue___0;
        }
      }
#line 1413
      if ((int )c == 0) {
#line 1413
        goto while_continue___0;
      }
#line 1414
      if ((int )c == 10) {
#line 1414
        goto while_continue___0;
      }
#line 1416
      if ((int )c == 13) {
#line 1418
        if (cli->state != 1) {
#line 1418
          if (cli->state != 3) {
            {
#line 1419
            _write(sockfd, (void const   *)"\r\n", (size_t )2);
            }
          }
        }
#line 1420
        goto while_break___0;
      }
#line 1423
      if ((int )c == 27) {
#line 1425
        esc = 1;
#line 1426
        goto while_continue___0;
      }
#line 1429
      if ((int )c == 3) {
        {
#line 1431
        _write(sockfd, (void const   *)"\a", (size_t )1);
        }
#line 1432
        goto while_continue___0;
      }
#line 1436
      if ((int )c == 23) {
#line 1436
        goto _L;
      } else
#line 1436
      if ((int )c == 8) {
#line 1436
        goto _L;
      } else
#line 1436
      if ((int )c == 127) {
        _L: /* CIL Label */ 
#line 1438
        back = 0;
#line 1440
        if ((int )c == 23) {
#line 1442
          nc = cursor;
#line 1444
          if (l == 0) {
#line 1445
            goto while_continue___0;
          } else
#line 1444
          if (cursor == 0) {
#line 1445
            goto while_continue___0;
          }
          {
#line 1447
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1447
            if (nc) {
#line 1447
              if (! ((int )*(cmd + (nc - 1)) == 32)) {
#line 1447
                goto while_break___3;
              }
            } else {
#line 1447
              goto while_break___3;
            }
#line 1449
            nc --;
#line 1450
            back ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 1453
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1453
            if (nc) {
#line 1453
              if (! ((int )*(cmd + (nc - 1)) != 32)) {
#line 1453
                goto while_break___4;
              }
            } else {
#line 1453
              goto while_break___4;
            }
#line 1455
            nc --;
#line 1456
            back ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
#line 1461
          if (l == 0) {
            {
#line 1463
            _write(sockfd, (void const   *)"\a", (size_t )1);
            }
#line 1464
            goto while_continue___0;
          } else
#line 1461
          if (cursor == 0) {
            {
#line 1463
            _write(sockfd, (void const   *)"\a", (size_t )1);
            }
#line 1464
            goto while_continue___0;
          }
#line 1467
          back = 1;
        }
#line 1470
        if (back) {
          {
#line 1472
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1472
            tmp___14 = back;
#line 1472
            back --;
#line 1472
            if (! tmp___14) {
#line 1472
              goto while_break___5;
            }
#line 1474
            if (l == cursor) {
#line 1476
              cursor --;
#line 1476
              *(cmd + cursor) = (char)0;
#line 1477
              if (cli->state != 1) {
#line 1477
                if (cli->state != 3) {
                  {
#line 1478
                  _write(sockfd, (void const   *)"\b \b", (size_t )3);
                  }
                }
              }
            } else {
#line 1483
              cursor --;
#line 1484
              if (cli->state != 1) {
#line 1484
                if (cli->state != 3) {
#line 1486
                  i = cursor;
                  {
#line 1486
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 1486
                    if (! (i <= l)) {
#line 1486
                      goto while_break___6;
                    }
#line 1486
                    *(cmd + i) = *(cmd + (i + 1));
#line 1486
                    i ++;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
                  {
#line 1487
                  _write(sockfd, (void const   *)"\b", (size_t )1);
#line 1488
                  tmp___12 = strlen((char const   *)(cmd + cursor));
#line 1488
                  _write(sockfd, (void const   *)(cmd + cursor), tmp___12);
#line 1489
                  _write(sockfd, (void const   *)" ", (size_t )1);
#line 1490
                  i = 0;
                  }
                  {
#line 1490
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
                    {
#line 1490
                    tmp___13 = strlen((char const   *)(cmd + cursor));
                    }
#line 1490
                    if (! (i <= (int )tmp___13)) {
#line 1490
                      goto while_break___7;
                    }
                    {
#line 1491
                    _write(sockfd, (void const   *)"\b", (size_t )1);
#line 1490
                    i ++;
                    }
                  }
                  while_break___7: /* CIL Label */ ;
                  }
                }
              }
            }
#line 1494
            l --;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1497
          goto while_continue___0;
        }
      }
#line 1502
      if ((int )c == 12) {
#line 1505
        cursorback = l - cursor;
#line 1507
        if (cli->state == 1) {
#line 1508
          goto while_continue___0;
        } else
#line 1507
        if (cli->state == 3) {
#line 1508
          goto while_continue___0;
        }
        {
#line 1510
        _write(sockfd, (void const   *)"\r\n", (size_t )2);
#line 1511
        show_prompt(cli, sockfd);
#line 1512
        _write(sockfd, (void const   *)cmd, (size_t )l);
#line 1514
        i___0 = 0;
        }
        {
#line 1514
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1514
          if (! (i___0 < cursorback)) {
#line 1514
            goto while_break___8;
          }
          {
#line 1515
          _write(sockfd, (void const   *)"\b", (size_t )1);
#line 1514
          i___0 ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1517
        goto while_continue___0;
      }
#line 1521
      if ((int )c == 21) {
#line 1523
        if (cli->state == 1) {
          {
#line 1524
          memset((void *)cmd, 0, (size_t )l);
          }
        } else
#line 1523
        if (cli->state == 3) {
          {
#line 1524
          memset((void *)cmd, 0, (size_t )l);
          }
        } else {
          {
#line 1526
          cli_clear_line(sockfd, cmd, l, cursor);
          }
        }
#line 1528
        cursor = 0;
#line 1528
        l = cursor;
#line 1529
        goto while_continue___0;
      }
#line 1533
      if ((int )c == 11) {
#line 1535
        if (cursor == l) {
#line 1536
          goto while_continue___0;
        }
#line 1538
        if (cli->state != 1) {
#line 1538
          if (cli->state != 3) {
#line 1541
            c___0 = cursor;
            {
#line 1541
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 1541
              if (! (c___0 < l)) {
#line 1541
                goto while_break___9;
              }
              {
#line 1542
              _write(sockfd, (void const   *)" ", (size_t )1);
#line 1541
              c___0 ++;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 1544
            c___0 = cursor;
            {
#line 1544
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 1544
              if (! (c___0 < l)) {
#line 1544
                goto while_break___10;
              }
              {
#line 1545
              _write(sockfd, (void const   *)"\b", (size_t )1);
#line 1544
              c___0 ++;
              }
            }
            while_break___10: /* CIL Label */ ;
            }
          }
        }
        {
#line 1548
        memset((void *)(cmd + cursor), 0, (size_t )(l - cursor));
#line 1549
        l = cursor;
        }
#line 1550
        goto while_continue___0;
      }
#line 1554
      if ((int )c == 4) {
#line 1556
        if (cli->state == 1) {
#line 1557
          goto while_break___0;
        } else
#line 1556
        if (cli->state == 3) {
#line 1557
          goto while_break___0;
        }
#line 1559
        if (l) {
#line 1560
          goto while_continue___0;
        }
#line 1562
        l = -1;
#line 1563
        goto while_break___0;
      }
#line 1567
      if ((int )c == 26) {
#line 1569
        if (cli->mode != 0) {
          {
#line 1571
          cli_clear_line(sockfd, cmd, l, cursor);
#line 1572
          cli_set_configmode(cli, 0, (char const   *)((void *)0));
#line 1573
          cli->showprompt = (char)1;
          }
        }
#line 1576
        goto while_continue___0;
      }
#line 1580
      if ((int )c == 9) {
#line 1583
        num_completions = 0;
#line 1585
        if (cli->state == 0) {
#line 1586
          goto while_continue___0;
        } else
#line 1585
        if (cli->state == 1) {
#line 1586
          goto while_continue___0;
        } else
#line 1585
        if (cli->state == 3) {
#line 1586
          goto while_continue___0;
        }
#line 1588
        if (cursor != l) {
#line 1588
          goto while_continue___0;
        }
        {
#line 1590
        num_completions = cli_get_completions(cli, (char const   *)cmd, completions,
                                              128);
        }
#line 1591
        if (num_completions == 0) {
          {
#line 1593
          _write(sockfd, (void const   *)"\a", (size_t )1);
          }
        } else
#line 1595
        if (num_completions == 1) {
          {
#line 1598
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 1598
            if (! (l > 0)) {
#line 1598
              goto while_break___11;
            }
#line 1600
            if ((int )*(cmd + (l - 1)) == 32) {
#line 1601
              goto while_break___11;
            } else
#line 1600
            if ((int )*(cmd + (l - 1)) == 124) {
#line 1601
              goto while_break___11;
            }
            {
#line 1602
            _write(sockfd, (void const   *)"\b", (size_t )1);
#line 1598
            l --;
#line 1598
            cursor --;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 1604
          strcpy((char */* __restrict  */)(cmd + l), (char const   */* __restrict  */)completions[0]);
#line 1605
          tmp___15 = strlen((char const   *)completions[0]);
#line 1605
          l = (int )((size_t )l + tmp___15);
#line 1606
          tmp___16 = l;
#line 1606
          l ++;
#line 1606
          *(cmd + tmp___16) = (char )' ';
#line 1607
          cursor = l;
#line 1608
          tmp___17 = strlen((char const   *)completions[0]);
#line 1608
          _write(sockfd, (void const   *)completions[0], tmp___17);
#line 1609
          _write(sockfd, (void const   *)" ", (size_t )1);
          }
        } else
#line 1611
        if (lastchar == 9) {
          {
#line 1615
          _write(sockfd, (void const   *)"\r\n", (size_t )2);
#line 1616
          i___1 = 0;
          }
          {
#line 1616
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 1616
            if (! (i___1 < num_completions)) {
#line 1616
              goto while_break___12;
            }
            {
#line 1618
            tmp___18 = strlen((char const   *)completions[i___1]);
#line 1618
            _write(sockfd, (void const   *)completions[i___1], tmp___18);
            }
#line 1619
            if (i___1 % 4 == 3) {
              {
#line 1620
              _write(sockfd, (void const   *)"\r\n", (size_t )2);
              }
            } else {
              {
#line 1622
              _write(sockfd, (void const   *)"     ", (size_t )1);
              }
            }
#line 1616
            i___1 ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 1624
          if (i___1 % 4 != 3) {
            {
#line 1624
            _write(sockfd, (void const   *)"\r\n", (size_t )2);
            }
          }
#line 1625
          cli->showprompt = (char)1;
        } else {
          {
#line 1630
          lastchar = (int )c;
#line 1631
          _write(sockfd, (void const   *)"\a", (size_t )1);
          }
        }
#line 1633
        goto while_continue___0;
      }
#line 1637
      if ((int )c == 16) {
#line 1637
        goto _L___1;
      } else
#line 1637
      if ((int )c == 14) {
        _L___1: /* CIL Label */ 
#line 1639
        history_found = 0;
#line 1641
        if (cli->state == 0) {
#line 1642
          goto while_continue___0;
        } else
#line 1641
        if (cli->state == 1) {
#line 1642
          goto while_continue___0;
        } else
#line 1641
        if (cli->state == 3) {
#line 1642
          goto while_continue___0;
        }
#line 1644
        if ((int )c == 16) {
#line 1646
          in_history --;
#line 1647
          if (in_history < 0) {
#line 1649
            in_history = 255;
            {
#line 1649
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1649
              if (! (in_history >= 0)) {
#line 1649
                goto while_break___13;
              }
#line 1651
              if (cli->history[in_history]) {
#line 1653
                history_found = 1;
#line 1654
                goto while_break___13;
              }
#line 1649
              in_history --;
            }
            while_break___13: /* CIL Label */ ;
            }
          } else
#line 1660
          if (cli->history[in_history]) {
#line 1660
            history_found = 1;
          }
        } else {
#line 1665
          in_history ++;
#line 1666
          if (in_history >= 256) {
#line 1666
            goto _L___0;
          } else
#line 1666
          if (! cli->history[in_history]) {
            _L___0: /* CIL Label */ 
#line 1668
            i___2 = 0;
#line 1669
            i___2 = 0;
            {
#line 1669
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 1669
              if (! (i___2 < 256)) {
#line 1669
                goto while_break___14;
              }
#line 1671
              if (cli->history[i___2]) {
#line 1673
                in_history = i___2;
#line 1674
                history_found = 1;
#line 1675
                goto while_break___14;
              }
#line 1669
              i___2 ++;
            }
            while_break___14: /* CIL Label */ ;
            }
          } else
#line 1681
          if (cli->history[in_history]) {
#line 1681
            history_found = 1;
          }
        }
#line 1684
        if (history_found) {
#line 1684
          if (cli->history[in_history]) {
            {
#line 1687
            cli_clear_line(sockfd, cmd, l, cursor);
#line 1688
            memset((void *)cmd, 0, (size_t )4096);
#line 1689
            strncpy((char */* __restrict  */)cmd, (char const   */* __restrict  */)cli->history[in_history],
                    (size_t )4095);
#line 1690
            tmp___19 = strlen((char const   *)cmd);
#line 1690
            cursor = (int )tmp___19;
#line 1690
            l = cursor;
#line 1691
            _write(sockfd, (void const   *)cmd, (size_t )l);
            }
          }
        }
#line 1694
        goto while_continue___0;
      }
#line 1698
      if ((int )c == 2) {
#line 1698
        goto _L___2;
      } else
#line 1698
      if ((int )c == 6) {
        _L___2: /* CIL Label */ 
#line 1700
        if ((int )c == 2) {
#line 1702
          if (cursor) {
#line 1704
            if (cli->state != 1) {
#line 1704
              if (cli->state != 3) {
                {
#line 1705
                _write(sockfd, (void const   *)"\b", (size_t )1);
                }
              }
            }
#line 1707
            cursor --;
          }
        } else
#line 1712
        if (cursor < l) {
#line 1714
          if (cli->state != 1) {
#line 1714
            if (cli->state != 3) {
              {
#line 1715
              _write(sockfd, (void const   *)(cmd + cursor), (size_t )1);
              }
            }
          }
#line 1717
          cursor ++;
        }
#line 1721
        goto while_continue___0;
      }
#line 1725
      if ((int )c == 1) {
#line 1727
        if (cursor) {
#line 1729
          if (cli->state != 1) {
#line 1729
            if (cli->state != 3) {
              {
#line 1731
              _write(sockfd, (void const   *)"\r", (size_t )1);
#line 1732
              show_prompt(cli, sockfd);
              }
            }
          }
#line 1735
          cursor = 0;
        }
#line 1738
        goto while_continue___0;
      }
#line 1742
      if ((int )c == 5) {
#line 1744
        if (cursor < l) {
#line 1746
          if (cli->state != 1) {
#line 1746
            if (cli->state != 3) {
              {
#line 1747
              _write(sockfd, (void const   *)(cmd + cursor), (size_t )(l - cursor));
              }
            }
          }
#line 1749
          cursor = l;
        }
#line 1752
        goto while_continue___0;
      }
#line 1756
      if (cursor == l) {
#line 1759
        *(cmd + cursor) = (char )c;
#line 1760
        if (l < 4095) {
#line 1762
          l ++;
#line 1763
          cursor ++;
        } else {
          {
#line 1767
          _write(sockfd, (void const   *)"\a", (size_t )1);
          }
#line 1768
          goto while_continue___0;
        }
      } else {
#line 1774
        if (insertmode) {
#line 1778
          if (l >= 4094) {
#line 1778
            l --;
          }
#line 1779
          i___3 = l;
          {
#line 1779
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 1779
            if (! (i___3 >= cursor)) {
#line 1779
              goto while_break___15;
            }
#line 1780
            *(cmd + (i___3 + 1)) = *(cmd + i___3);
#line 1779
            i___3 --;
          }
          while_break___15: /* CIL Label */ ;
          }
          {
#line 1782
          *(cmd + cursor) = (char )c;
#line 1784
          _write(sockfd, (void const   *)(cmd + cursor), (size_t )((l - cursor) + 1));
#line 1785
          i___3 = 0;
          }
          {
#line 1785
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1785
            if (! (i___3 < (l - cursor) + 1)) {
#line 1785
              goto while_break___16;
            }
            {
#line 1786
            _write(sockfd, (void const   *)"\b", (size_t )1);
#line 1785
            i___3 ++;
            }
          }
          while_break___16: /* CIL Label */ ;
          }
#line 1787
          l ++;
        } else {
#line 1791
          *(cmd + cursor) = (char )c;
        }
#line 1793
        cursor ++;
      }
#line 1796
      if (cli->state != 1) {
#line 1796
        if (cli->state != 3) {
#line 1798
          if ((int )c == 63) {
#line 1798
            if (cursor == l) {
              {
#line 1800
              _write(sockfd, (void const   *)"\r\n", (size_t )2);
#line 1801
              oldcmd = cmd;
#line 1802
              cursor = l - 1;
#line 1802
              oldl = cursor;
              }
#line 1803
              goto while_break___0;
            }
          }
          {
#line 1805
          _write(sockfd, (void const   *)(& c), (size_t )1);
          }
        }
      }
#line 1808
      oldcmd = (char *)0;
#line 1809
      oldl = 0;
#line 1810
      lastchar = (int )c;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1813
    if (l < 0) {
#line 1813
      goto while_break;
    }
#line 1815
    if (cli->state == 0) {
#line 1817
      if (l == 0) {
#line 1817
        goto while_continue;
      }
      {
#line 1820
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 1820
        if (username) {
          {
#line 1820
          free((void *)username);
#line 1820
          username = (char *)0;
          }
        }
#line 1820
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 1821
      username = strdup((char const   *)cmd);
      }
#line 1821
      if (! username) {
#line 1822
        return (0);
      }
#line 1823
      cli->state = 1;
#line 1824
      cli->showprompt = (char)1;
    } else
#line 1826
    if (cli->state == 1) {
#line 1829
      allowed = 0;
      {
#line 1831
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 1831
        if (password) {
          {
#line 1831
          free((void *)password);
#line 1831
          password = (char *)0;
          }
        }
#line 1831
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 1832
      password = strdup((char const   *)cmd);
      }
#line 1832
      if (! password) {
#line 1833
        return (0);
      }
#line 1834
      if (cli->auth_callback) {
        {
#line 1836
        tmp___20 = (*(cli->auth_callback))((char const   *)username, (char const   *)password);
        }
#line 1836
        if (tmp___20 == 0) {
#line 1837
          allowed ++;
        }
      }
#line 1840
      if (! allowed) {
#line 1843
        u = cli->users;
        {
#line 1843
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 1843
          if (! u) {
#line 1843
            goto while_break___19;
          }
          {
#line 1845
          tmp___21 = strcmp((char const   *)u->username, (char const   *)username);
          }
#line 1845
          if (! tmp___21) {
            {
#line 1845
            tmp___22 = pass_matches((char const   *)u->password, (char const   *)password);
            }
#line 1845
            if (tmp___22) {
#line 1847
              allowed ++;
#line 1848
              goto while_break___19;
            }
          }
#line 1843
          u = u->next;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
#line 1853
      if (allowed) {
        {
#line 1855
        cli_error(cli, " ");
#line 1856
        cli->state = 2;
        }
      } else {
        {
#line 1860
        cli_error(cli, "\n\nAccess denied");
        }
        {
#line 1861
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 1861
          if (username) {
            {
#line 1861
            free((void *)username);
#line 1861
            username = (char *)0;
            }
          }
#line 1861
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
        {
#line 1862
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1862
          if (password) {
            {
#line 1862
            free((void *)password);
#line 1862
            password = (char *)0;
            }
          }
#line 1862
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 1863
        cli->state = 0;
      }
#line 1866
      cli->showprompt = (char)1;
    } else
#line 1868
    if (cli->state == 3) {
#line 1870
      allowed___0 = 0;
#line 1871
      if (cli->enable_password) {
        {
#line 1874
        tmp___23 = pass_matches((char const   *)cli->enable_password, (char const   *)cmd);
        }
#line 1874
        if (tmp___23) {
#line 1875
          allowed___0 ++;
        }
      }
#line 1878
      if (! allowed___0) {
#line 1878
        if (cli->enable_callback) {
          {
#line 1881
          tmp___24 = (*(cli->enable_callback))((char const   *)cmd);
          }
#line 1881
          if (tmp___24) {
#line 1882
            allowed___0 ++;
          }
        }
      }
#line 1885
      if (allowed___0) {
        {
#line 1887
        cli->state = 4;
#line 1888
        cli_set_privilege(cli, 15);
        }
      } else {
        {
#line 1892
        cli_error(cli, "\n\nAccess denied");
#line 1893
        cli->state = 2;
        }
      }
    } else {
#line 1898
      if (l == 0) {
#line 1898
        goto while_continue;
      }
#line 1899
      if ((int )*(cmd + (l - 1)) != 63) {
        {
#line 1899
        tmp___25 = strcasecmp((char const   *)cmd, "history");
        }
#line 1899
        if (tmp___25 != 0) {
          {
#line 1900
          cli_add_history(cli, (char const   *)cmd);
          }
        }
      }
      {
#line 1902
      tmp___26 = cli_run_command(cli, (char const   *)cmd);
      }
#line 1902
      if (tmp___26 == -2) {
#line 1903
        goto while_break;
      }
    }
#line 1908
    if (cli->idle_timeout) {
      {
#line 1909
      time(& cli->last_action);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1912
  cli_free_history(cli);
  }
  {
#line 1913
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 1913
    if (username) {
      {
#line 1913
      free((void *)username);
#line 1913
      username = (char *)0;
      }
    }
#line 1913
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 1914
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 1914
    if (password) {
      {
#line 1914
      free((void *)password);
#line 1914
      password = (char *)0;
      }
    }
#line 1914
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 1915
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 1915
    if (cmd) {
      {
#line 1915
      free((void *)cmd);
#line 1915
      cmd = (char *)0;
      }
    }
#line 1915
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 1917
  fclose(cli->client);
#line 1918
  cli->client = (FILE *)0;
  }
#line 1919
  return (0);
}
}
#line 1922 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_file(struct cli_def *cli , FILE *fh , int privilege , int mode ) 
{ 
  int oldpriv ;
  int tmp ;
  int oldmode ;
  int tmp___0 ;
  char buf[4096] ;
  char *p ;
  char *cmd ;
  char *end ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1924
  tmp = cli_set_privilege(cli, privilege);
#line 1924
  oldpriv = tmp;
#line 1925
  tmp___0 = cli_set_configmode(cli, mode, (char const   *)((void *)0));
#line 1925
  oldmode = tmp___0;
  }
  {
#line 1928
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1934
    tmp___1 = fgets((char */* __restrict  */)(buf), 4095, (FILE */* __restrict  */)fh);
    }
#line 1934
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1935
      goto while_break;
    }
    {
#line 1937
    p = strpbrk((char const   *)(buf), "#\r\n");
    }
#line 1937
    if (p) {
#line 1938
      *p = (char)0;
    }
#line 1940
    cmd = buf;
    {
#line 1941
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1941
      tmp___2 = __ctype_b_loc();
      }
#line 1941
      if (! ((int const   )*(*tmp___2 + (int )*cmd) & 8192)) {
#line 1941
        goto while_break___0;
      }
#line 1942
      cmd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1944
    if (! *cmd) {
#line 1945
      goto while_continue;
    }
#line 1947
    end = cmd;
#line 1947
    p = end;
    {
#line 1947
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1947
      if (! *p) {
#line 1947
        goto while_break___1;
      }
      {
#line 1948
      tmp___3 = __ctype_b_loc();
      }
#line 1948
      if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 1949
        end = p;
      }
#line 1947
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1951
    end ++;
#line 1951
    *end = (char)0;
#line 1952
    tmp___4 = strcasecmp((char const   *)cmd, "quit");
    }
#line 1952
    if (tmp___4 == 0) {
#line 1953
      goto while_break;
    }
    {
#line 1955
    tmp___5 = cli_run_command(cli, (char const   *)cmd);
    }
#line 1955
    if (tmp___5 == -2) {
#line 1956
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1959
  cli_set_privilege(cli, oldpriv);
#line 1960
  cli_set_configmode(cli, oldmode, (char const   *)((void *)0));
  }
#line 1962
  return (0);
}
}
#line 1965 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static void _print(struct cli_def *cli , int print_mode , char const   *format , va_list ap ) 
{ 
  va_list aq ;
  int n ;
  char *p ;
  void *tmp ;
  char *next ;
  char *tmp___0 ;
  struct cli_filter *f ;
  struct cli_filter *tmp___1 ;
  int print ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 1971
  if (! cli) {
#line 1971
    return;
  }
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1975
    __builtin_va_copy(aq, ap);
#line 1976
    n = vsnprintf((char */* __restrict  */)cli->buffer, (size_t )cli->buf_size, (char const   */* __restrict  */)format,
                  ap);
    }
#line 1976
    if (n == -1) {
#line 1977
      return;
    }
#line 1979
    if ((unsigned int )n >= cli->buf_size) {
      {
#line 1981
      cli->buf_size = (unsigned int )(n + 1);
#line 1982
      tmp = realloc((void *)cli->buffer, (size_t )cli->buf_size);
#line 1982
      cli->buffer = (char *)tmp;
      }
#line 1983
      if (! cli->buffer) {
#line 1984
        return;
      }
      {
#line 1985
      __builtin_va_end(ap);
#line 1986
      __builtin_va_copy(ap, aq);
      }
#line 1987
      goto while_continue;
    }
#line 1989
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1993
  p = cli->buffer;
  {
#line 1994
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1996
    tmp___0 = strchr((char const   *)p, '\n');
#line 1996
    next = tmp___0;
    }
#line 1997
    if (print_mode & 1) {
#line 1997
      tmp___1 = cli->filters;
    } else {
#line 1997
      tmp___1 = (struct cli_filter *)0;
    }
#line 1997
    f = tmp___1;
#line 1998
    print = 1;
#line 2000
    if (next) {
#line 2001
      tmp___2 = next;
#line 2001
      next ++;
#line 2001
      *tmp___2 = (char)0;
    } else
#line 2002
    if (print_mode & 2) {
#line 2003
      goto while_break___0;
    }
    {
#line 2005
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2005
      if (print) {
#line 2005
        if (! f) {
#line 2005
          goto while_break___1;
        }
      } else {
#line 2005
        goto while_break___1;
      }
      {
#line 2007
      tmp___3 = (*(f->filter))(cli, (char const   *)p, f->data);
#line 2007
      print = tmp___3 == 0;
#line 2008
      f = f->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2010
    if (print) {
#line 2012
      if (cli->print_callback) {
        {
#line 2013
        (*(cli->print_callback))(cli, (char const   *)p);
        }
      } else
#line 2014
      if (cli->client) {
        {
#line 2015
        fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"%s\r\n",
                p);
        }
      }
    }
#line 2018
    p = next;
#line 1994
    if (! p) {
#line 1994
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2021
  if (p) {
#line 2021
    if (*p) {
#line 2023
      if ((unsigned long )p != (unsigned long )cli->buffer) {
        {
#line 2024
        tmp___4 = strlen((char const   *)p);
#line 2024
        memmove((void *)cli->buffer, (void const   *)p, tmp___4);
        }
      }
    } else {
#line 2026
      *(cli->buffer) = (char)0;
    }
  } else {
#line 2026
    *(cli->buffer) = (char)0;
  }
#line 2027
  return;
}
}
#line 2029 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void ( /* format attribute */  cli_bufprint)(struct cli_def *cli , char const   *format 
                                             , ...) 
{ 
  va_list ap ;

  {
  {
#line 2033
  __builtin_va_start(ap, format);
#line 2034
  _print(cli, 3, format, ap);
#line 2035
  __builtin_va_end(ap);
  }
#line 2036
  return;
}
}
#line 2038 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_vabufprint(struct cli_def *cli , char const   *format , va_list ap ) 
{ 


  {
  {
#line 2040
  _print(cli, 2, format, ap);
  }
#line 2041
  return;
}
}
#line 2043 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void ( /* format attribute */  cli_print)(struct cli_def *cli , char const   *format 
                                          , ...) 
{ 
  va_list ap ;

  {
  {
#line 2047
  __builtin_va_start(ap, format);
#line 2048
  _print(cli, 1, format, ap);
#line 2049
  __builtin_va_end(ap);
  }
#line 2050
  return;
}
}
#line 2052 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void ( /* format attribute */  cli_error)(struct cli_def *cli , char const   *format 
                                          , ...) 
{ 
  va_list ap ;

  {
  {
#line 2056
  __builtin_va_start(ap, format);
#line 2057
  _print(cli, 0, format, ap);
#line 2058
  __builtin_va_end(ap);
  }
#line 2059
  return;
}
}
#line 2070 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_match_filter_init(struct cli_def *cli , int argc , char **argv , struct cli_filter *filt ) 
{ 
  struct cli_match_filter_state *state ;
  int rflags ;
  int i ;
  char *p ;
  void *tmp ;
  int last ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 2077
  if (argc < 2) {
#line 2079
    if (cli->client) {
      {
#line 2080
      fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"Match filter requires an argument\r\n");
      }
    }
#line 2082
    return (-1);
  }
  {
#line 2085
  filt->filter = & cli_match_filter;
#line 2086
  tmp = calloc(sizeof(struct cli_match_filter_state ), (size_t )1);
#line 2086
  state = (struct cli_match_filter_state *)tmp;
#line 2086
  filt->data = (void *)state;
  }
#line 2088
  if ((int )*(*(argv + 0) + 0) == 105) {
#line 2088
    goto _L;
  } else
#line 2088
  if ((int )*(*(argv + 0) + 0) == 101) {
#line 2088
    if ((int )*(*(argv + 0) + 1) == 120) {
      _L: /* CIL Label */ 
#line 2090
      if ((int )*(*(argv + 0) + 0) == 101) {
#line 2091
        state->flags = 2;
      }
      {
#line 2093
      state->match.string = join_words(argc - 1, argv + 1);
      }
#line 2094
      return (0);
    }
  }
#line 2104
  state->flags = 1;
#line 2107
  rflags = ((1 << 1) << 1) << 1;
#line 2108
  if ((int )*(*(argv + 0) + 0) == 101) {
#line 2109
    rflags |= 1;
  }
#line 2111
  i = 1;
  {
#line 2112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2112
    if (i < argc - 1) {
#line 2112
      if ((int )*(*(argv + i) + 0) == 45) {
#line 2112
        if (! *(*(argv + i) + 1)) {
#line 2112
          goto while_break;
        }
      } else {
#line 2112
        goto while_break;
      }
    } else {
#line 2112
      goto while_break;
    }
    {
#line 2114
    last = 0;
#line 2115
    p = *(argv + i) + 1;
#line 2117
    tmp___0 = strspn((char const   *)p, "vie");
#line 2117
    tmp___1 = strlen((char const   *)p);
    }
#line 2117
    if (tmp___0 != tmp___1) {
#line 2118
      goto while_break;
    }
    {
#line 2120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2120
      if (! *p) {
#line 2120
        goto while_break___0;
      }
#line 2122
      tmp___2 = p;
#line 2122
      p ++;
      {
#line 2124
      if ((int )*tmp___2 == 118) {
#line 2124
        goto case_118;
      }
#line 2128
      if ((int )*tmp___2 == 105) {
#line 2128
        goto case_105;
      }
#line 2132
      if ((int )*tmp___2 == 101) {
#line 2132
        goto case_101;
      }
#line 2122
      goto switch_break;
      case_118: /* CIL Label */ 
#line 2125
      state->flags |= 2;
#line 2126
      goto switch_break;
      case_105: /* CIL Label */ 
#line 2129
      rflags |= 1 << 1;
#line 2130
      goto switch_break;
      case_101: /* CIL Label */ 
#line 2133
      last ++;
#line 2134
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2138
    i ++;
#line 2139
    if (last) {
#line 2140
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2143
  p = join_words(argc - i, argv + i);
#line 2144
  i = regcomp((regex_t */* __restrict  */)(& state->match.re), (char const   */* __restrict  */)p,
              rflags);
  }
#line 2144
  if (i) {
#line 2146
    if (cli->client) {
      {
#line 2147
      fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"Invalid pattern \"%s\"\r\n",
              p);
      }
    }
    {
#line 2149
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2149
      if (p) {
        {
#line 2149
        free((void *)p);
#line 2149
        p = (char *)0;
        }
      }
#line 2149
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2150
    return (-1);
  }
  {
#line 2153
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2153
    if (p) {
      {
#line 2153
      free((void *)p);
#line 2153
      p = (char *)0;
      }
    }
#line 2153
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2154
  return (0);
}
}
#line 2157 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_match_filter(struct cli_def *cli  __attribute__((__unused__)) , char const   *string ,
                     void *data ) 
{ 
  struct cli_match_filter_state *state ;
  int r ;
  int tmp ;
  char *tmp___0 ;

  {
#line 2159
  state = (struct cli_match_filter_state *)data;
#line 2160
  r = -1;
#line 2162
  if (! string) {
#line 2164
    if (state->flags & 1) {
      {
#line 2165
      regfree(& state->match.re);
      }
    } else {
      {
#line 2167
      free((void *)state->match.string);
      }
    }
    {
#line 2169
    free((void *)state);
    }
#line 2170
    return (0);
  }
#line 2173
  if (state->flags & 1) {
    {
#line 2175
    tmp = regexec((regex_t const   */* __restrict  */)(& state->match.re), (char const   */* __restrict  */)string,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 2175
    if (! tmp) {
#line 2176
      r = 0;
    }
  } else {
    {
#line 2180
    tmp___0 = strstr(string, (char const   *)state->match.string);
    }
#line 2180
    if (tmp___0) {
#line 2181
      r = 0;
    }
  }
#line 2184
  if (state->flags & 2) {
#line 2186
    if (r == 0) {
#line 2187
      r = -1;
    } else {
#line 2189
      r = 0;
    }
  }
#line 2192
  return (r);
}
}
#line 2201 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_range_filter_init(struct cli_def *cli , int argc , char **argv , struct cli_filter *filt ) 
{ 
  struct cli_range_filter_state *state ;
  char *from ;
  char *to ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 2204
  from = (char *)0;
#line 2205
  to = (char *)0;
#line 2207
  tmp = strncmp((char const   *)*(argv + 0), "bet", (size_t )3);
  }
#line 2207
  if (tmp) {
#line 2223
    if (argc < 2) {
#line 2225
      if (cli->client) {
        {
#line 2226
        fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"Begin filter requires an argument\r\n");
        }
      }
#line 2228
      return (-1);
    }
    {
#line 2231
    from = join_words(argc - 1, argv + 1);
    }
  } else {
#line 2209
    if (argc < 3) {
#line 2211
      if (cli->client) {
        {
#line 2212
        fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"Between filter requires 2 arguments\r\n");
        }
      }
#line 2214
      return (-1);
    }
    {
#line 2217
    from = strdup((char const   *)*(argv + 1));
    }
#line 2217
    if (! from) {
#line 2218
      return (-1);
    }
    {
#line 2219
    to = join_words(argc - 2, argv + 2);
    }
  }
  {
#line 2234
  filt->filter = & cli_range_filter;
#line 2235
  tmp___0 = calloc(sizeof(struct cli_range_filter_state ), (size_t )1);
#line 2235
  state = (struct cli_range_filter_state *)tmp___0;
#line 2235
  filt->data = (void *)state;
#line 2237
  state->from = from;
#line 2238
  state->to = to;
  }
#line 2240
  return (0);
}
}
#line 2243 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_range_filter(struct cli_def *cli  __attribute__((__unused__)) , char const   *string ,
                     void *data ) 
{ 
  struct cli_range_filter_state *state ;
  int r ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 2245
  state = (struct cli_range_filter_state *)data;
#line 2246
  r = -1;
#line 2248
  if (! string) {
    {
#line 2250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2250
      if (state->from) {
        {
#line 2250
        free((void *)state->from);
#line 2250
        state->from = (char *)0;
        }
      }
#line 2250
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2251
      if (state->to) {
        {
#line 2251
        free((void *)state->to);
#line 2251
        state->to = (char *)0;
        }
      }
#line 2251
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2252
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2252
      if (state) {
        {
#line 2252
        free((void *)state);
#line 2252
        state = (struct cli_range_filter_state *)0;
        }
      }
#line 2252
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2253
    return (0);
  }
#line 2256
  if (! state->matched) {
    {
#line 2257
    tmp = strstr(string, (char const   *)state->from);
    }
#line 2257
    if (tmp) {
#line 2257
      tmp___0 = 1;
    } else {
#line 2257
      tmp___0 = 0;
    }
#line 2257
    state->matched = tmp___0;
  }
#line 2259
  if (state->matched) {
#line 2261
    r = 0;
#line 2262
    if (state->to) {
      {
#line 2262
      tmp___1 = strstr(string, (char const   *)state->to);
      }
#line 2262
      if (tmp___1) {
#line 2263
        state->matched = 0;
      }
    }
  }
#line 2266
  return (r);
}
}
#line 2269 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_count_filter_init(struct cli_def *cli , int argc , char **argv  __attribute__((__unused__)) ,
                          struct cli_filter *filt ) 
{ 
  void *tmp ;

  {
#line 2271
  if (argc > 1) {
#line 2273
    if (cli->client) {
      {
#line 2274
      fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"Count filter does not take arguments\r\n");
      }
    }
#line 2276
    return (-1);
  }
  {
#line 2279
  filt->filter = & cli_count_filter;
#line 2280
  tmp = calloc(sizeof(int ), (size_t )1);
#line 2280
  filt->data = tmp;
  }
#line 2280
  if (! tmp) {
#line 2281
    return (-1);
  }
#line 2283
  return (0);
}
}
#line 2286 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
int cli_count_filter(struct cli_def *cli , char const   *string , void *data ) 
{ 
  int *count ;
  unsigned short const   **tmp ;

  {
#line 2288
  count = (int *)data;
#line 2290
  if (! string) {
#line 2293
    if (cli->client) {
      {
#line 2294
      fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"%d\r\n",
              *count);
      }
    }
    {
#line 2296
    free((void *)count);
    }
#line 2297
    return (0);
  }
  {
#line 2300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2300
    tmp = __ctype_b_loc();
    }
#line 2300
    if (! ((int const   )*(*tmp + (int )*string) & 8192)) {
#line 2300
      goto while_break;
    }
#line 2301
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2303
  if (*string) {
#line 2304
    (*count) ++;
  }
#line 2306
  return (-1);
}
}
#line 2309 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_print_callback(struct cli_def *cli , void (*callback)(struct cli_def * ,
                                                               char const   * ) ) 
{ 


  {
#line 2311
  cli->print_callback = callback;
#line 2312
  return;
}
}
#line 2314 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_idle_timeout(struct cli_def *cli , unsigned int seconds ) 
{ 


  {
#line 2316
  if (seconds < 1U) {
#line 2317
    seconds = 0U;
  }
  {
#line 2318
  cli->idle_timeout = (time_t )seconds;
#line 2319
  time(& cli->last_action);
  }
#line 2320
  return;
}
}
#line 2322 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_idle_timeout_callback(struct cli_def *cli , unsigned int seconds , int (*callback)(struct cli_def * ) ) 
{ 


  {
  {
#line 2324
  cli_set_idle_timeout(cli, seconds);
#line 2325
  cli->idle_timeout_callback = callback;
  }
#line 2326
  return;
}
}
#line 2328 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_telnet_protocol(struct cli_def *cli , int telnet_protocol ) 
{ 


  {
#line 2329
  cli->telnet_protocol = ! (! telnet_protocol);
#line 2330
  return;
}
}
#line 2332 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void cli_set_context(struct cli_def *cli , void *context ) 
{ 


  {
#line 2333
  cli->user_context = context;
#line 2334
  return;
}
}
#line 2336 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
void *cli_get_context(struct cli_def *cli ) 
{ 


  {
#line 2337
  return (cli->user_context);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static struct cli_filter_cmds filter_cmds___0[8]  = 
#line 132
  {      {"begin", "Begin with lines that match"}, 
        {"between", "Between lines that match"}, 
        {"count", "Count of lines"}, 
        {"exclude", "Exclude lines that match"}, 
        {"include", "Include lines that match"}, 
        {"grep", "Include lines that match regex (options: -v, -i, -e)"}, 
        {"egrep", "Include lines that match extended regex"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 144 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static ssize_t _write___0(int fd , void const   *buf , size_t count ) 
{ 
  size_t written ;
  ssize_t thisTime ;
  int *tmp ;

  {
#line 146
  written = (size_t )0;
#line 147
  thisTime = (ssize_t )0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (count != written)) {
#line 148
      goto while_break;
    }
    {
#line 150
    thisTime = write(fd, (void const   *)((char *)buf + written), count - written);
    }
#line 151
    if (thisTime == -1L) {
      {
#line 153
      tmp = __errno_location();
      }
#line 153
      if (*tmp == 4) {
#line 154
        goto while_continue;
      } else {
#line 156
        return ((ssize_t )-1);
      }
    }
#line 158
    written += (size_t )thisTime;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return ((ssize_t )written);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_build_shortest___0(struct cli_def *cli , struct cli_command *commands ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;
  char *cp ;
  char *pp ;
  unsigned int len ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 287
  c = commands;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! c) {
#line 287
      goto while_break;
    }
    {
#line 289
    tmp = strlen((char const   *)c->command);
#line 289
    c->unique_len = (unsigned int )tmp;
    }
#line 290
    if (c->mode != -1) {
#line 290
      if (c->mode != cli->mode) {
#line 291
        goto __Cont;
      } else {
#line 290
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 290
    if (c->privilege > cli->privilege) {
#line 291
      goto __Cont;
    }
#line 293
    c->unique_len = 1U;
#line 294
    p = commands;
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      if (! p) {
#line 294
        goto while_break___0;
      }
#line 296
      if ((unsigned long )c == (unsigned long )p) {
#line 297
        goto __Cont___0;
      }
#line 299
      if (p->mode != -1) {
#line 299
        if (p->mode != cli->mode) {
#line 300
          goto __Cont___0;
        } else {
#line 299
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 299
      if (p->privilege > cli->privilege) {
#line 300
        goto __Cont___0;
      }
#line 302
      cp = c->command;
#line 303
      pp = p->command;
#line 304
      len = 1U;
      {
#line 306
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 306
        if (*cp) {
#line 306
          if (*pp) {
#line 306
            tmp___0 = cp;
#line 306
            cp ++;
#line 306
            tmp___1 = pp;
#line 306
            pp ++;
#line 306
            if (! ((int )*tmp___0 == (int )*tmp___1)) {
#line 306
              goto while_break___1;
            }
          } else {
#line 306
            goto while_break___1;
          }
        } else {
#line 306
          goto while_break___1;
        }
#line 307
        len ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 309
      if (len > c->unique_len) {
#line 310
        c->unique_len = len;
      }
      __Cont___0: /* CIL Label */ 
#line 294
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    if (c->children) {
      {
#line 314
      cli_build_shortest___0(cli, c->children);
      }
    }
    __Cont: /* CIL Label */ 
#line 287
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (0);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static void cli_free_command___0(struct cli_command *cmd ) 
{ 
  struct cli_command *c ;
  struct cli_command *p ;

  {
#line 420
  c = cmd->children;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! c) {
#line 420
      goto while_break;
    }
    {
#line 422
    p = c->next;
#line 423
    cli_free_command___0(c);
#line 424
    c = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  free((void *)cmd->command);
  }
#line 428
  if (cmd->help) {
    {
#line 428
    free((void *)cmd->help);
    }
  }
  {
#line 429
  free((void *)cmd);
  }
#line 430
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_add_history___0(struct cli_def *cli , char const   *cmd ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 658
  i = 0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (i < 256)) {
#line 658
      goto while_break;
    }
#line 660
    if (! cli->history[i]) {
#line 662
      if (i == 0) {
#line 662
        goto _L;
      } else {
        {
#line 662
        tmp___0 = strcasecmp((char const   *)cli->history[i - 1], cmd);
        }
#line 662
        if (tmp___0) {
          _L: /* CIL Label */ 
          {
#line 663
          tmp = strdup(cmd);
#line 663
          cli->history[i] = tmp;
          }
#line 663
          if (! tmp) {
#line 664
            return (-1);
          }
        }
      }
#line 665
      return (0);
    }
#line 658
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  free((void *)cli->history[0]);
#line 670
  i = 0;
  }
  {
#line 670
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 670
    if (! (i < 255)) {
#line 670
      goto while_break___0;
    }
#line 671
    cli->history[i] = cli->history[i + 1];
#line 670
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 672
  tmp___1 = strdup(cmd);
#line 672
  cli->history[255] = tmp___1;
  }
#line 672
  if (! tmp___1) {
#line 673
    return (-1);
  }
#line 674
  return (0);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_parse_line___0(char const   *line , char **words , int max_words ) 
{ 
  int nwords ;
  char const   *p ;
  char const   *word_start ;
  int inquote ;
  unsigned short const   **tmp ;
  int len ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 689
  nwords = 0;
#line 690
  p = line;
#line 691
  word_start = (char const   *)0;
#line 692
  inquote = 0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! *p) {
#line 694
      goto while_break;
    }
    {
#line 696
    tmp = __ctype_b_loc();
    }
#line 696
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 698
      word_start = p;
#line 699
      goto while_break;
    }
#line 701
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 704
    if (! (nwords < max_words - 1)) {
#line 704
      goto while_break___0;
    }
#line 706
    if (! *p) {
#line 706
      goto _L___1;
    } else
#line 706
    if ((int const   )*p == (int const   )inquote) {
#line 706
      goto _L___1;
    } else
#line 706
    if (word_start) {
#line 706
      if (! inquote) {
        {
#line 706
        tmp___7 = __ctype_b_loc();
        }
#line 706
        if ((int const   )*(*tmp___7 + (int )*p) & 8192) {
#line 706
          goto _L___1;
        } else
#line 706
        if ((int const   )*p == 124) {
          _L___1: /* CIL Label */ 
#line 708
          if (word_start) {
            {
#line 710
            len = (int )(p - word_start);
#line 712
            tmp___1 = malloc((size_t )(len + 1));
#line 712
            tmp___0 = (char *)tmp___1;
#line 712
            *(words + nwords) = tmp___0;
#line 712
            memcpy((void */* __restrict  */)tmp___0, (void const   */* __restrict  */)word_start,
                   (size_t )len);
#line 713
            tmp___2 = nwords;
#line 713
            nwords ++;
#line 713
            *(*(words + tmp___2) + len) = (char)0;
            }
          }
#line 716
          if (! *p) {
#line 717
            goto while_break___0;
          }
#line 719
          if (inquote) {
#line 720
            p ++;
          }
#line 722
          inquote = 0;
#line 723
          word_start = (char const   *)0;
        } else {
#line 706
          goto _L___2;
        }
      } else {
#line 706
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 725
    if ((int const   )*p == 34) {
#line 727
      tmp___3 = p;
#line 727
      p ++;
#line 727
      inquote = (int )*tmp___3;
#line 728
      word_start = p;
    } else
#line 725
    if ((int const   )*p == 39) {
#line 727
      tmp___3 = p;
#line 727
      p ++;
#line 727
      inquote = (int )*tmp___3;
#line 728
      word_start = p;
    } else {
#line 732
      if (! word_start) {
#line 734
        if ((int const   )*p == 124) {
          {
#line 736
          tmp___4 = nwords;
#line 736
          nwords ++;
#line 736
          tmp___5 = strdup("|");
#line 736
          *(words + tmp___4) = tmp___5;
          }
#line 736
          if (! tmp___5) {
#line 737
            return (0);
          }
        } else {
          {
#line 739
          tmp___6 = __ctype_b_loc();
          }
#line 739
          if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 740
            word_start = p;
          }
        }
      }
#line 743
      p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 747
  return (nwords);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static char *join_words___0(int argc , char **argv ) 
{ 
  char *p ;
  int len ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 753
  len = 0;
#line 756
  i = 0;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    if (! (i < argc)) {
#line 756
      goto while_break;
    }
#line 758
    if (i) {
#line 759
      len ++;
    }
    {
#line 761
    tmp = strlen((char const   *)*(argv + i));
#line 761
    len = (int )((size_t )len + tmp);
#line 756
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 764
  tmp___0 = malloc((size_t )(len + 1));
#line 764
  p = (char *)tmp___0;
#line 765
  *(p + 0) = (char)0;
#line 767
  i = 0;
  }
  {
#line 767
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 767
    if (! (i < argc)) {
#line 767
      goto while_break___0;
    }
#line 769
    if (i) {
      {
#line 770
      strcat((char */* __restrict  */)p, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 772
    strcat((char */* __restrict  */)p, (char const   */* __restrict  */)*(argv + i));
#line 767
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 775
  return (p);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_find_command___0(struct cli_def *cli , struct cli_command *commands ,
                                int num_words , char **words , int start_word , int *filters ) 
{ 
  struct cli_command *c ;
  struct cli_command *again ;
  int c_words ;
  int l ;
  size_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int rc ;
  int f ;
  struct cli_filter **filt ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int n ;
  char **argv ;
  int argc ;
  int len ;
  size_t tmp___11 ;
  int i ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  struct cli_filter *filt___0 ;
  char const   *tmp___22 ;

  {
#line 781
  again = (struct cli_command *)((void *)0);
#line 782
  c_words = num_words;
#line 784
  if (*(filters + 0)) {
#line 785
    c_words = *(filters + 0);
  }
#line 788
  if (! *(words + start_word)) {
#line 789
    return (-1);
  }
  {
#line 791
  tmp___4 = strlen((char const   *)*(words + start_word));
  }
#line 791
  if ((int )*(*(words + start_word) + (tmp___4 - 1UL)) == 63) {
    {
#line 793
    tmp = strlen((char const   *)*(words + start_word));
#line 793
    l = (int )(tmp - 1UL);
    }
#line 795
    if (commands->parent) {
#line 795
      if ((commands->parent)->callback) {
#line 796
        if ((unsigned long )(commands->parent)->help != (unsigned long )((void *)0)) {
#line 796
          tmp___0 = (char const   *)(commands->parent)->help;
        } else {
#line 796
          tmp___0 = "";
        }
        {
#line 796
        tmp___1 = cli_command_name(cli, commands->parent);
#line 796
        cli_error(cli, "%-20s %s", tmp___1, tmp___0);
        }
      }
    }
#line 799
    c = commands;
    {
#line 799
    while (1) {
      while_continue: /* CIL Label */ ;
#line 799
      if (! c) {
#line 799
        goto while_break;
      }
      {
#line 801
      tmp___3 = strncasecmp((char const   *)c->command, (char const   *)*(words + start_word),
                            (size_t )l);
      }
#line 801
      if (tmp___3 == 0) {
#line 801
        if (c->callback) {
#line 801
          goto _L___0;
        } else
#line 801
        if (c->children) {
          _L___0: /* CIL Label */ 
#line 801
          if (cli->privilege >= c->privilege) {
#line 801
            if (c->mode == cli->mode) {
#line 801
              goto _L;
            } else
#line 801
            if (c->mode == -1) {
              _L: /* CIL Label */ 
#line 805
              if ((unsigned long )c->help != (unsigned long )((void *)0)) {
#line 805
                tmp___2 = (char const   *)c->help;
              } else {
#line 805
                tmp___2 = "";
              }
              {
#line 805
              cli_error(cli, "  %-20s %s", c->command, tmp___2);
              }
            }
          }
        }
      }
#line 799
      c = c->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 808
    return (0);
  }
#line 811
  c = commands;
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 811
    if (! c) {
#line 811
      goto while_break___0;
    }
#line 813
    if (cli->privilege < c->privilege) {
#line 814
      goto __Cont;
    }
    {
#line 816
    tmp___5 = strncasecmp((char const   *)c->command, (char const   *)*(words + start_word),
                          (size_t )c->unique_len);
    }
#line 816
    if (tmp___5) {
#line 817
      goto __Cont;
    }
    {
#line 819
    tmp___6 = strlen((char const   *)*(words + start_word));
#line 819
    tmp___7 = strncasecmp((char const   *)c->command, (char const   *)*(words + start_word),
                          tmp___6);
    }
#line 819
    if (tmp___7) {
#line 820
      goto __Cont;
    }
    AGAIN: 
#line 823
    if (c->mode == cli->mode) {
#line 823
      goto _L___1;
    } else
#line 823
    if (c->mode == -1) {
      _L___1: /* CIL Label */ 
#line 825
      rc = 0;
#line 827
      filt = & cli->filters;
#line 830
      if (! c->children) {
#line 833
        if (! c->callback) {
          {
#line 835
          tmp___8 = cli_command_name(cli, c);
#line 835
          cli_error(cli, "No callback for \"%s\"", tmp___8);
          }
#line 836
          return (-1);
        }
      } else {
#line 841
        if (start_word == c_words - 1) {
#line 843
          if (c->callback) {
#line 844
            goto CORRECT_CHECKS;
          }
          {
#line 846
          cli_error(cli, "Incomplete command");
          }
#line 847
          return (-1);
        }
        {
#line 849
        rc = cli_find_command___0(cli, c->children, num_words, words, start_word + 1,
                                  filters);
        }
#line 850
        if (rc == -3) {
#line 852
          if (c->callback) {
#line 854
            rc = 0;
#line 855
            goto CORRECT_CHECKS;
          } else {
#line 859
            if (commands->parent) {
#line 859
              tmp___9 = "argument";
            } else {
#line 859
              tmp___9 = "command";
            }
            {
#line 859
            cli_error(cli, "Invalid %s \"%s\"", tmp___9, *(words + start_word));
            }
          }
        }
#line 863
        return (rc);
      }
#line 866
      if (! c->callback) {
        {
#line 868
        tmp___10 = cli_command_name(cli, c);
#line 868
        cli_error(cli, "Internal server error processing \"%s\"", tmp___10);
        }
#line 869
        return (-1);
      }
      CORRECT_CHECKS: 
#line 873
      f = 0;
      {
#line 873
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 873
        if (rc == 0) {
#line 873
          if (! *(filters + f)) {
#line 873
            goto while_break___1;
          }
        } else {
#line 873
          goto while_break___1;
        }
#line 875
        n = num_words;
#line 880
        if (*(filters + (f + 1))) {
#line 881
          n = *(filters + (f + 1));
        }
#line 883
        if (*(filters + f) == n - 1) {
          {
#line 885
          cli_error(cli, "Missing filter");
          }
#line 886
          return (-1);
        }
        {
#line 889
        argv = (words + *(filters + f)) + 1;
#line 890
        argc = n - (*(filters + f) + 1);
#line 891
        tmp___11 = strlen((char const   *)*(argv + 0));
#line 891
        len = (int )tmp___11;
#line 892
        tmp___12 = strlen((char const   *)*(argv + (argc - 1)));
        }
#line 892
        if ((int )*(*(argv + (argc - 1)) + (tmp___12 - 1UL)) == 63) {
#line 894
          if (argc == 1) {
#line 897
            i = 0;
            {
#line 897
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 897
              if (! filter_cmds___0[i].cmd) {
#line 897
                goto while_break___2;
              }
              {
#line 898
              cli_error(cli, "  %-20s %s", filter_cmds___0[i].cmd, filter_cmds___0[i].help);
#line 897
              i ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
#line 902
            if ((int )*(*(argv + 0) + 0) != 99) {
              {
#line 903
              cli_error(cli, "  WORD");
              }
            }
#line 905
            if (argc > 2) {
              {
#line 906
              cli_error(cli, "  <cr>");
              }
            } else
#line 905
            if ((int )*(*(argv + 0) + 0) == 99) {
              {
#line 906
              cli_error(cli, "  <cr>");
              }
            }
          }
#line 909
          return (0);
        }
#line 912
        if ((int )*(*(argv + 0) + 0) == 98) {
#line 912
          if (len < 3) {
            {
#line 914
            cli_error(cli, "Ambiguous filter \"%s\" (begin, between)", *(argv + 0));
            }
#line 915
            return (-1);
          }
        }
        {
#line 917
        tmp___13 = calloc(sizeof(struct cli_filter ), (size_t )1);
#line 917
        *filt = (struct cli_filter *)tmp___13;
#line 919
        tmp___17 = strncmp("include", (char const   *)*(argv + 0), (size_t )len);
        }
#line 919
        if (tmp___17) {
          {
#line 919
          tmp___18 = strncmp("exclude", (char const   *)*(argv + 0), (size_t )len);
          }
#line 919
          if (tmp___18) {
            {
#line 919
            tmp___19 = strncmp("grep", (char const   *)*(argv + 0), (size_t )len);
            }
#line 919
            if (tmp___19) {
              {
#line 919
              tmp___20 = strncmp("egrep", (char const   *)*(argv + 0), (size_t )len);
              }
#line 919
              if (tmp___20) {
                {
#line 922
                tmp___15 = strncmp("begin", (char const   *)*(argv + 0), (size_t )len);
                }
#line 922
                if (tmp___15) {
                  {
#line 922
                  tmp___16 = strncmp("between", (char const   *)*(argv + 0), (size_t )len);
                  }
#line 922
                  if (tmp___16) {
                    {
#line 924
                    tmp___14 = strncmp("count", (char const   *)*(argv + 0), (size_t )len);
                    }
#line 924
                    if (tmp___14) {
                      {
#line 928
                      cli_error(cli, "Invalid filter \"%s\"", *(argv + 0));
#line 929
                      rc = -1;
                      }
                    } else {
                      {
#line 925
                      rc = cli_count_filter_init(cli, argc, argv, *filt);
                      }
                    }
                  } else {
                    {
#line 923
                    rc = cli_range_filter_init(cli, argc, argv, *filt);
                    }
                  }
                } else {
                  {
#line 923
                  rc = cli_range_filter_init(cli, argc, argv, *filt);
                  }
                }
              } else {
                {
#line 921
                rc = cli_match_filter_init(cli, argc, argv, *filt);
                }
              }
            } else {
              {
#line 921
              rc = cli_match_filter_init(cli, argc, argv, *filt);
              }
            }
          } else {
            {
#line 921
            rc = cli_match_filter_init(cli, argc, argv, *filt);
            }
          }
        } else {
          {
#line 921
          rc = cli_match_filter_init(cli, argc, argv, *filt);
          }
        }
#line 932
        if (rc == 0) {
#line 934
          filt = & (*filt)->next;
        } else {
          {
#line 938
          free((void *)*filt);
#line 939
          *filt = (struct cli_filter *)0;
          }
        }
#line 873
        f ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 943
      if (rc == 0) {
        {
#line 944
        tmp___21 = cli_command_name(cli, c);
#line 944
        rc = (*(c->callback))(cli, (char const   *)tmp___21, (words + start_word) + 1,
                              (c_words - start_word) - 1);
        }
      }
      {
#line 946
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 946
        if (! cli->filters) {
#line 946
          goto while_break___3;
        }
        {
#line 948
        filt___0 = cli->filters;
#line 951
        (*(filt___0->filter))(cli, (char const   *)((void *)0), filt___0->data);
#line 952
        cli->filters = filt___0->next;
#line 953
        free((void *)filt___0);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 956
      return (rc);
    } else
#line 958
    if (cli->mode > 1) {
#line 958
      if (c->mode == 1) {
#line 962
        again = c;
      }
    }
    __Cont: /* CIL Label */ 
#line 811
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 967
  if (again) {
    {
#line 969
    c = again;
#line 970
    cli_set_configmode(cli, 1, (char const   *)((void *)0));
    }
#line 971
    goto AGAIN;
  }
#line 974
  if (start_word == 0) {
#line 975
    if (commands->parent) {
#line 975
      tmp___22 = "argument";
    } else {
#line 975
      tmp___22 = "command";
    }
    {
#line 975
    cli_error(cli, "Invalid %s \"%s\"", tmp___22, *(words + start_word));
    }
  }
#line 977
  return (-3);
}
}
#line 1016 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int cli_get_completions___0(struct cli_def *cli , char const   *command , char **completions ,
                                   int max_completions ) 
{ 
  struct cli_command *c ;
  struct cli_command *n ;
  int num_words ;
  int i ;
  int k ;
  char *words[128] ;
  unsigned int tmp ;
  int filter ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned int len ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 1020
  k = 0;
#line 1021
  words[0] = (char *)0;
#line 1021
  tmp = 1U;
  {
#line 1021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1021
    if (tmp >= 128U) {
#line 1021
      goto while_break;
    }
#line 1021
    words[tmp] = (char *)0;
#line 1021
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1022
  filter = 0;
#line 1024
  if (! command) {
#line 1024
    return (0);
  }
  {
#line 1025
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1025
    tmp___0 = __ctype_b_loc();
    }
#line 1025
    if (! ((int const   )*(*tmp___0 + (int )*command) & 8192)) {
#line 1025
      goto while_break___0;
    }
#line 1026
    command ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1028
  num_words = cli_parse_line___0(command, words, (int )(sizeof(words) / sizeof(words[0])));
  }
#line 1029
  if (! *(command + 0)) {
#line 1030
    num_words ++;
  } else {
    {
#line 1029
    tmp___1 = strlen(command);
    }
#line 1029
    if ((int const   )*(command + (tmp___1 - 1UL)) == 32) {
#line 1030
      num_words ++;
    }
  }
#line 1032
  if (! num_words) {
#line 1033
    return (0);
  }
#line 1035
  i = 0;
  {
#line 1035
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1035
    if (! (i < num_words)) {
#line 1035
      goto while_break___1;
    }
#line 1037
    if (words[i]) {
#line 1037
      if ((int )*(words[i] + 0) == 124) {
#line 1038
        filter = i;
      }
    }
#line 1035
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1041
  if (filter) {
#line 1043
    len = 0U;
#line 1045
    if (filter < num_words - 1) {
#line 1046
      return (0);
    }
#line 1048
    if (filter == num_words - 1) {
      {
#line 1049
      tmp___2 = strlen((char const   *)words[num_words - 1]);
#line 1049
      len = (unsigned int )tmp___2;
      }
    }
#line 1051
    i = 0;
    {
#line 1051
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1051
      if (filter_cmds___0[i].cmd) {
#line 1051
        if (! (k < max_completions)) {
#line 1051
          goto while_break___2;
        }
      } else {
#line 1051
        goto while_break___2;
      }
#line 1053
      if (! len) {
#line 1054
        tmp___3 = k;
#line 1054
        k ++;
#line 1054
        *(completions + tmp___3) = (char *)filter_cmds___0[i].cmd;
      } else {
        {
#line 1053
        tmp___4 = strlen(filter_cmds___0[i].cmd);
        }
#line 1053
        if ((size_t )len < tmp___4) {
          {
#line 1053
          tmp___5 = strncmp(filter_cmds___0[i].cmd, (char const   *)words[num_words - 1],
                            (size_t )len);
          }
#line 1053
          if (! tmp___5) {
#line 1054
            tmp___3 = k;
#line 1054
            k ++;
#line 1054
            *(completions + tmp___3) = (char *)filter_cmds___0[i].cmd;
          }
        }
      }
#line 1051
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1057
    *(completions + k) = (char *)((void *)0);
#line 1058
    return (k);
  }
#line 1061
  c = cli->commands;
#line 1061
  i = 0;
  {
#line 1061
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1061
    if (c) {
#line 1061
      if (i < num_words) {
#line 1061
        if (! (k < max_completions)) {
#line 1061
          goto while_break___3;
        }
      } else {
#line 1061
        goto while_break___3;
      }
    } else {
#line 1061
      goto while_break___3;
    }
#line 1063
    n = c->next;
#line 1065
    if (cli->privilege < c->privilege) {
#line 1066
      goto __Cont;
    }
#line 1068
    if (c->mode != cli->mode) {
#line 1068
      if (c->mode != -1) {
#line 1069
        goto __Cont;
      }
    }
#line 1071
    if (words[i]) {
      {
#line 1071
      tmp___6 = strlen((char const   *)words[i]);
#line 1071
      tmp___7 = strncasecmp((char const   *)c->command, (char const   *)words[i],
                            tmp___6);
      }
#line 1071
      if (tmp___7) {
#line 1072
        goto __Cont;
      }
    }
#line 1074
    if (i < num_words - 1) {
      {
#line 1076
      tmp___8 = strlen((char const   *)words[i]);
      }
#line 1076
      if (tmp___8 < (size_t )c->unique_len) {
#line 1077
        goto __Cont;
      }
#line 1079
      n = c->children;
#line 1080
      i ++;
#line 1081
      goto __Cont;
    }
#line 1084
    tmp___9 = k;
#line 1084
    k ++;
#line 1084
    *(completions + tmp___9) = c->command;
    __Cont: /* CIL Label */ 
#line 1061
    c = n;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1087
  return (k);
}
}
#line 1090 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static void cli_clear_line___0(int sockfd , char *cmd , int l , int cursor ) 
{ 
  int i ;

  {
#line 1093
  if (cursor < l) {
#line 1095
    i = 0;
    {
#line 1095
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1095
      if (! (i < l - cursor)) {
#line 1095
        goto while_break;
      }
      {
#line 1096
      _write___0(sockfd, (void const   *)" ", (size_t )1);
#line 1095
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1098
  i = 0;
  {
#line 1098
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1098
    if (! (i < l)) {
#line 1098
      goto while_break___0;
    }
#line 1099
    *(cmd + i) = (char )'\b';
#line 1098
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1100
    if (! (i < l * 2)) {
#line 1100
      goto while_break___1;
    }
#line 1101
    *(cmd + i) = (char )' ';
#line 1100
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1102
    if (! (i < l * 3)) {
#line 1102
      goto while_break___2;
    }
#line 1103
    *(cmd + i) = (char )'\b';
#line 1102
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1104
  _write___0(sockfd, (void const   *)cmd, (size_t )i);
#line 1105
  memset((void *)cmd, 0, (size_t )i);
#line 1106
  cursor = 0;
#line 1106
  l = cursor;
  }
#line 1107
  return;
}
}
#line 1131 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int pass_matches___0(char const   *pass , char const   *try ) 
{ 
  int des ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1134
  tmp = strncasecmp(pass, "{crypt}", sizeof("{crypt}") - 1UL);
  }
#line 1134
  if (tmp) {
#line 1134
    tmp___0 = 0;
  } else {
#line 1134
    tmp___0 = 1;
  }
#line 1134
  des = tmp___0;
#line 1134
  if (des) {
#line 1135
    pass += sizeof("{crypt}") - 1UL;
  }
#line 1141
  if (des) {
    {
#line 1142
    tmp___1 = crypt(try, pass);
#line 1142
    try = (char const   *)tmp___1;
    }
  } else {
    {
#line 1141
    tmp___2 = strncmp(pass, "$1$", sizeof("$1$") - 1UL);
    }
#line 1141
    if (! tmp___2) {
      {
#line 1142
      tmp___1 = crypt(try, pass);
#line 1142
      try = (char const   *)tmp___1;
      }
    }
  }
  {
#line 1145
  tmp___3 = strcmp(pass, try);
  }
#line 1145
  if (tmp___3) {
#line 1145
    tmp___4 = 0;
  } else {
#line 1145
    tmp___4 = 1;
  }
#line 1145
  return (tmp___4);
}
}
#line 1150 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static int show_prompt___0(struct cli_def *cli , int sockfd ) 
{ 
  int len ;
  size_t tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 1152
  len = 0;
#line 1154
  if (cli->hostname) {
    {
#line 1155
    tmp = strlen((char const   *)cli->hostname);
#line 1155
    tmp___0 = write(sockfd, (void const   *)cli->hostname, tmp);
#line 1155
    len = (int )((ssize_t )len + tmp___0);
    }
  }
#line 1157
  if (cli->modestring) {
    {
#line 1158
    tmp___1 = strlen((char const   *)cli->modestring);
#line 1158
    tmp___2 = write(sockfd, (void const   *)cli->modestring, tmp___1);
#line 1158
    len = (int )((ssize_t )len + tmp___2);
    }
  }
  {
#line 1160
  tmp___3 = strlen((char const   *)cli->promptchar);
#line 1160
  tmp___4 = write(sockfd, (void const   *)cli->promptchar, tmp___3);
  }
#line 1160
  return ((int )((ssize_t )len + tmp___4));
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static char const   *negotiate___0  =    "\377\373\003\377\373\001\377\375\003\377\375\001";
#line 1965 "/home/june/repo/benchmarks/collector/temp/libcli-1.9.6/libcli.c"
static void _print___0(struct cli_def *cli , int print_mode , char const   *format ,
                       va_list ap ) 
{ 
  va_list aq ;
  int n ;
  char *p ;
  void *tmp ;
  char *next ;
  char *tmp___0 ;
  struct cli_filter *f ;
  struct cli_filter *tmp___1 ;
  int print ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 1971
  if (! cli) {
#line 1971
    return;
  }
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1975
    __builtin_va_copy(aq, ap);
#line 1976
    n = vsnprintf((char */* __restrict  */)cli->buffer, (size_t )cli->buf_size, (char const   */* __restrict  */)format,
                  ap);
    }
#line 1976
    if (n == -1) {
#line 1977
      return;
    }
#line 1979
    if ((unsigned int )n >= cli->buf_size) {
      {
#line 1981
      cli->buf_size = (unsigned int )(n + 1);
#line 1982
      tmp = realloc((void *)cli->buffer, (size_t )cli->buf_size);
#line 1982
      cli->buffer = (char *)tmp;
      }
#line 1983
      if (! cli->buffer) {
#line 1984
        return;
      }
      {
#line 1985
      __builtin_va_end(ap);
#line 1986
      __builtin_va_copy(ap, aq);
      }
#line 1987
      goto while_continue;
    }
#line 1989
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1993
  p = cli->buffer;
  {
#line 1994
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1996
    tmp___0 = strchr((char const   *)p, '\n');
#line 1996
    next = tmp___0;
    }
#line 1997
    if (print_mode & 1) {
#line 1997
      tmp___1 = cli->filters;
    } else {
#line 1997
      tmp___1 = (struct cli_filter *)0;
    }
#line 1997
    f = tmp___1;
#line 1998
    print = 1;
#line 2000
    if (next) {
#line 2001
      tmp___2 = next;
#line 2001
      next ++;
#line 2001
      *tmp___2 = (char)0;
    } else
#line 2002
    if (print_mode & 2) {
#line 2003
      goto while_break___0;
    }
    {
#line 2005
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2005
      if (print) {
#line 2005
        if (! f) {
#line 2005
          goto while_break___1;
        }
      } else {
#line 2005
        goto while_break___1;
      }
      {
#line 2007
      tmp___3 = (*(f->filter))(cli, (char const   *)p, f->data);
#line 2007
      print = tmp___3 == 0;
#line 2008
      f = f->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2010
    if (print) {
#line 2012
      if (cli->print_callback) {
        {
#line 2013
        (*(cli->print_callback))(cli, (char const   *)p);
        }
      } else
#line 2014
      if (cli->client) {
        {
#line 2015
        fprintf((FILE */* __restrict  */)cli->client, (char const   */* __restrict  */)"%s\r\n",
                p);
        }
      }
    }
#line 2018
    p = next;
#line 1994
    if (! p) {
#line 1994
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2021
  if (p) {
#line 2021
    if (*p) {
#line 2023
      if ((unsigned long )p != (unsigned long )cli->buffer) {
        {
#line 2024
        tmp___4 = strlen((char const   *)p);
#line 2024
        memmove((void *)cli->buffer, (void const   *)p, tmp___4);
        }
      }
    } else {
#line 2026
      *(cli->buffer) = (char)0;
    }
  } else {
#line 2026
    *(cli->buffer) = (char)0;
  }
#line 2027
  return;
}
}
