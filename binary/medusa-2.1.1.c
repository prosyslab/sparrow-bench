/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_18 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_18 pthread_mutex_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_16 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_16 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_19 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_19 pthread_mutexattr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_46 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_47 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_48 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_49 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_50 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_51 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_52 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_45 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_46 _kill ;
   struct __anonstruct__timer_47 _timer ;
   struct __anonstruct__rt_48 _rt ;
   struct __anonstruct__sigchld_49 _sigchld ;
   struct __anonstruct__sigfault_50 _sigfault ;
   struct __anonstruct__sigpoll_51 _sigpoll ;
   struct __anonstruct__sigsys_52 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_44 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_45 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_44 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_64 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_64 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_74 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_74 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 12 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.h"
typedef unsigned int uint_t;
#line 19
struct thr_pool;
#line 19 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.h"
typedef struct thr_pool thr_pool_t;
#line 97 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sPass {
   struct __sPass *psPassNext ;
   char *pPass ;
};
#line 97 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sPass sPass;
#line 111 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sUser {
   struct __sUser *psUserNext ;
   char *pUser ;
   struct __sPass *psPass ;
   struct __sPass *psPassCurrent ;
   struct __sPass *psPassPrevTmp ;
   char *pPass ;
   int iPassCnt ;
   int iLoginsDone ;
   int iPassStatus ;
   int iId ;
};
#line 111 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sUser sUser;
#line 131 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sHost {
   struct __sHost *psHostNext ;
   char *pHost ;
   int iUseSSL ;
   int iPortOverride ;
   int iTimeout ;
   int iRetryWait ;
   int iRetries ;
   sUser *psUser ;
   sUser *psUserCurrent ;
   sUser *psUserPrevTmp ;
   int iUserCnt ;
   int iUserPassCnt ;
   int iUsersDone ;
   int iUserStatus ;
   int iId ;
};
#line 131 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sHost sHost;
#line 154 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sCredentialSet {
   struct __sCredentialSet *psCredentialSetNext ;
   struct __sUser *psUser ;
   char *pPass ;
   int iStatus ;
};
#line 154 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sCredentialSet sCredentialSet;
#line 161
struct __sAudit;
#line 161 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sServer {
   struct __sAudit *psAudit ;
   struct __sHost *psHost ;
   char *pHostIP ;
   int iValidPairFound ;
   int iId ;
   int iLoginCnt ;
   int iLoginsDone ;
   sCredentialSet *psCredentialSetMissed ;
   sCredentialSet *psCredentialSetMissedCurrent ;
   sCredentialSet *psCredentialSetMissedTail ;
   int iCredentialsMissed ;
   pthread_mutex_t ptmMutex ;
};
#line 161 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sServer sServer;
#line 183 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sLogin {
   struct __sServer *psServer ;
   struct __sUser *psUser ;
   int iResult ;
   char *pErrorMsg ;
   int iId ;
   int iLoginsDone ;
};
#line 183 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sLogin sLogin;
#line 206 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sAudit {
   char *pOptHost ;
   char *pOptUser ;
   char *pOptPass ;
   char *pOptCombo ;
   char *pOptOutput ;
   char *pOptResume ;
   char *pModuleName ;
   char *pGlobalHost ;
   char *pGlobalUser ;
   char *pGlobalPass ;
   char *pGlobalCombo ;
   char *pHostFile ;
   char *pUserFile ;
   char *pPassFile ;
   char *pComboFile ;
   int iHostCnt ;
   int iUserCnt ;
   int iPassCnt ;
   int iComboCnt ;
   int iServerCnt ;
   int iLoginCnt ;
   int iHostsDone ;
   int iPortOverride ;
   int iUseSSL ;
   int iTimeout ;
   int iRetryWait ;
   int iRetries ;
   int iSocketWait ;
   int HostType ;
   int UserType ;
   int PassType ;
   int iShowModuleHelp ;
   char *pComboEntryTmp ;
   int iHostListFlag ;
   int iUserListFlag ;
   int iAuditFlag ;
   int iPasswordBlankFlag ;
   int iPasswordUsernameFlag ;
   int iFoundPairExitFlag ;
   int iParallelLoginFlag ;
   int iValidPairFound ;
   int iStatus ;
   sHost *psHostRoot ;
   thr_pool_t *server_pool ;
   pthread_mutex_t ptmMutex ;
};
#line 206 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sAudit sAudit;
#line 265 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
struct __sModuleStart {
   char *szModuleName ;
   sLogin *pLogin ;
   int argc ;
   char **argv ;
};
#line 265 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
typedef struct __sModuleStart sModuleStart;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_17 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_17 fd_set;
#line 53 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.h"
struct __sConnectParams {
   long nHost ;
   int nPort ;
   int nUseSSL ;
   float nSSLVersion ;
   int nProtocol ;
   int nType ;
   unsigned long nProxyStringIP ;
   int nProxyStringPort ;
   char *szProxyAuthentication ;
   int nTimeout ;
   int nRetries ;
   int nRetryWait ;
   int nSourcePort ;
};
#line 53 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.h"
typedef struct __sConnectParams sConnectParams;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_92 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_92 regmatch_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_21 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_20 {
   struct __anonstruct___data_21 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_20 pthread_cond_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_22 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_22 pthread_condattr_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 534 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_40 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 534 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_39 {
   struct __anonstruct___cancel_jmp_buf_40 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 534 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_39  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 753
struct __jmp_buf_tag;
#line 23 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
struct job;
#line 23 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
typedef struct job job_t;
#line 24 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
struct job {
   job_t *job_next ;
   void *(*job_func)(void * ) ;
   void *job_arg ;
};
#line 33
struct active;
#line 33 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
typedef struct active active_t;
#line 34 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
struct active {
   active_t *active_next ;
   pthread_t active_tid ;
};
#line 42 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
struct thr_pool {
   thr_pool_t *pool_forw ;
   thr_pool_t *pool_back ;
   pthread_mutex_t pool_mutex ;
   pthread_cond_t pool_busycv ;
   pthread_cond_t pool_workcv ;
   pthread_cond_t pool_waitcv ;
   active_t *pool_active ;
   job_t *pool_head ;
   job_t *pool_tail ;
   pthread_attr_t pool_attr ;
   int pool_flags ;
   uint_t pool_linger ;
   int pool_minimum ;
   int pool_maximum ;
   int pool_nthreads ;
   int pool_idle ;
};
#line 46 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
enum MODULE_STATE {
    MSTATE_NEW = 0,
    MSTATE_RUNNING = 1,
    MSTATE_EXITING = 2,
    MSTATE_COMPLETE = 3
} ;
#line 52 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
typedef unsigned char uint8;
#line 54 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
typedef unsigned long long ulonglong;
#line 55 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
typedef unsigned int uint32;
#line 56 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
typedef short int16;
#line 57 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
typedef signed char int8;
#line 48 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.h"
struct SHA1_CONTEXT {
   ulonglong Length ;
   uint32 Intermediate_Hash[5] ;
   int Computed ;
   int Corrupted ;
   int16 Message_Block_Index ;
   uint8 Message_Block[64] ;
};
#line 48 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.h"
typedef struct SHA1_CONTEXT SHA1_CONTEXT;
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 60 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
struct __MYSQL_DATA {
   int protoFlag ;
   int hashFlag ;
};
#line 60 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
typedef struct __MYSQL_DATA _MYSQL_DATA;
#line 300 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
struct rand_struct {
   unsigned long seed1 ;
   unsigned long seed2 ;
   unsigned long max_value ;
   double max_value_dbl ;
};
#line 327 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
typedef unsigned char uchar;
#line 331 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
typedef unsigned long ulong___0;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 57 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
struct __SNMP_DATA {
   int nVersion ;
   int nReadWrite ;
   int nReadTimeout ;
   int nSendDelay ;
};
#line 57 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
typedef struct __SNMP_DATA _SNMP_DATA;
#line 557 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
struct _SNMPV1_A {
   char ID ;
   char len ;
   char ver[3] ;
   char comid ;
   char comlen ;
};
#line 571 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
struct _SNMPV1_R {
   char type[2] ;
   char identid[2] ;
   char ident[4] ;
   char errstat[3] ;
   char errind[3] ;
   char objectid[2] ;
   char object[12] ;
   char value[3] ;
};
#line 622 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
struct _SNMPV1_A___0 {
   char ID ;
   char len ;
   char ver[3] ;
   char comid ;
   char comlen ;
};
#line 636 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
struct _SNMPV1_W {
   char type[2] ;
   char identid[2] ;
   char ident[4] ;
   char errstat[3] ;
   char errind[3] ;
   char objectid[2] ;
   char object[12] ;
   char value[2] ;
};
#line 52 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ftp.c"
struct __MODULE_DATA {
   sConnectParams *params ;
   int nAuthType ;
};
#line 52 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ftp.c"
typedef struct __MODULE_DATA _MODULE_DATA;
#line 43 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
typedef unsigned short uint16;
#line 47 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
struct __anonstruct_tSmbStrHeader_29 {
   uint16 len ;
   uint16 maxlen ;
   uint32 offset ;
};
#line 47 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
typedef struct __anonstruct_tSmbStrHeader_29 tSmbStrHeader;
#line 54 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
struct __anonstruct_tSmbNtlmAuthRequest_30 {
   char ident[8] ;
   uint32 msgType ;
   uint32 flags ;
   tSmbStrHeader host ;
   tSmbStrHeader domain ;
   uint8 buffer[1024] ;
   uint32 bufIndex ;
};
#line 54 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
typedef struct __anonstruct_tSmbNtlmAuthRequest_30 tSmbNtlmAuthRequest;
#line 65 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
struct __anonstruct_tSmbNtlmAuthChallenge_31 {
   char ident[8] ;
   uint32 msgType ;
   tSmbStrHeader uDomain ;
   uint32 flags ;
   uint8 challengeData[8] ;
   uint8 reserved[8] ;
   tSmbStrHeader emptyString ;
   uint8 buffer[1024] ;
   uint32 bufIndex ;
};
#line 65 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
typedef struct __anonstruct_tSmbNtlmAuthChallenge_31 tSmbNtlmAuthChallenge;
#line 78 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
struct __anonstruct_tSmbNtlmAuthResponse_32 {
   char ident[8] ;
   uint32 msgType ;
   tSmbStrHeader lmResponse ;
   tSmbStrHeader ntResponse ;
   tSmbStrHeader uDomain ;
   tSmbStrHeader uUser ;
   tSmbStrHeader uWks ;
   tSmbStrHeader sessionKey ;
   uint32 flags ;
   uint8 buffer[1024] ;
   uint32 bufIndex ;
};
#line 78 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
typedef struct __anonstruct_tSmbNtlmAuthResponse_32 tSmbNtlmAuthResponse;
#line 61 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
struct __MODULE_DATA___0 {
   char *szTag ;
   int nAuthType ;
   char *szDomain ;
};
#line 61 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
typedef struct __MODULE_DATA___0 _MODULE_DATA___0;
#line 67 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
struct __MODULE_DATA___1 {
   int nMode ;
};
#line 67 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
typedef struct __MODULE_DATA___1 _MODULE_DATA___1;
#line 46 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/cvs.c"
struct __CVS_DATA {
   char *szDir ;
};
#line 46 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/cvs.c"
typedef struct __CVS_DATA _CVS_DATA;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 50 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/wrapper.c"
struct __MODULE_DATA___2 {
   unsigned char *szCmd ;
   unsigned char *szCmdFull ;
   unsigned char *szCmdParam ;
   unsigned char *szCmdParamFull ;
   int iReadPipe[2] ;
   int iWritePipe[2] ;
   int nType ;
};
#line 50 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/wrapper.c"
typedef struct __MODULE_DATA___2 _MODULE_DATA___2;
#line 68 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pcanywhere.c"
struct __PCA_DATA {
   unsigned char domain[17] ;
};
#line 68 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pcanywhere.c"
typedef struct __PCA_DATA _PCA_DATA;
#line 56 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
struct __MODULE_DATA___3 {
   int nMode ;
   int nAuthType ;
   char *szDomain ;
};
#line 56 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
typedef struct __MODULE_DATA___3 _MODULE_DATA___3;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 286 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 62 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
FILE *pOutputFile  ;
#line 63 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
pthread_mutex_t ptmFileMutex  ;
#line 64 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
int iVerboseLevel  ;
#line 65 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.h"
int iErrorLevel  ;
#line 35 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-trace.c"
void writeVerbose(int iLevel , char *pMsg  , ...) 
{ 
  va_list ap ;
  char buf___8[512] ;
  char bufOut[1024] ;
  char temp[6] ;
  unsigned char cTemp ;
  int i ;

  {
#line 41
  i = 0;
#line 43
  if ((unsigned long )pMsg == (unsigned long )((void *)0)) {
    {
#line 44
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRITICAL: writeDebug() called with NULL message.\n");
    }
  } else
#line 46
  if (iLevel <= iVerboseLevel) {
    {
#line 47
    __builtin_va_start(ap, pMsg);
#line 48
    memset((void *)(bufOut), 0, (size_t )1024);
#line 49
    memset((void *)(buf___8), 0, (size_t )512);
#line 50
    vsnprintf((char */* __restrict  */)(buf___8), sizeof(buf___8) - 1UL, (char const   */* __restrict  */)pMsg,
              ap);
#line 57
    i = 0;
    }
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;
#line 57
      if (! ((unsigned long )i < sizeof(buf___8))) {
#line 57
        goto while_break;
      }
      {
#line 59
      memset((void *)(temp), 0, (size_t )6);
#line 60
      cTemp = (unsigned char )buf___8[i];
      }
#line 61
      if ((int )cTemp < 32) {
#line 61
        if ((int )cTemp > 0) {
#line 61
          if ((int )cTemp != 9) {
#line 61
            if ((int )cTemp != 10) {
#line 61
              if ((int )cTemp != 13) {
                {
#line 63
                sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"[%02X]",
                        (int )cTemp);
                }
              } else {
#line 61
                goto _L___2;
              }
            } else {
#line 61
              goto _L___2;
            }
          } else {
#line 61
            goto _L___2;
          }
        } else {
#line 61
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 61
      if ((int )cTemp > 126) {
        {
#line 63
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"[%02X]",
                (int )cTemp);
        }
      } else {
        {
#line 66
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%c",
                (int )cTemp);
        }
      }
      {
#line 68
      strncat((char */* __restrict  */)(bufOut), (char const   */* __restrict  */)(temp),
              (size_t )6);
#line 57
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 73
    if (iLevel == 4) {
#line 73
      goto case_4;
    }
#line 85
    if (iLevel == 5) {
#line 85
      goto case_5;
    }
#line 89
    if (iLevel == 3) {
#line 89
      goto case_3;
    }
#line 93
    if (iLevel == 6) {
#line 93
      goto case_6;
    }
#line 97
    if (iLevel == 1) {
#line 97
      goto case_1;
    }
#line 101
    if (iLevel == 2) {
#line 101
      goto case_2;
    }
#line 111
    if (iLevel == 0) {
#line 111
      goto case_0;
    }
#line 116
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 74
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"ACCOUNT FOUND: %s\n",
            bufOut);
    }
#line 76
    if ((unsigned long )pOutputFile != (unsigned long )((void *)0)) {
      {
#line 77
      pthread_mutex_lock(& ptmFileMutex);
#line 78
      fprintf((FILE */* __restrict  */)pOutputFile, (char const   */* __restrict  */)"ACCOUNT FOUND: %s\n",
              buf___8);
#line 79
      fflush(pOutputFile);
#line 80
      pthread_mutex_unlock(& ptmFileMutex);
      }
    }
    {
#line 83
    __builtin_va_end(ap);
    }
#line 84
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 86
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"ACCOUNT CHECK: %s\n",
            bufOut);
#line 87
    __builtin_va_end(ap);
    }
#line 88
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 90
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"IMPORTANT: %s\n",
            bufOut);
#line 91
    __builtin_va_end(ap);
    }
#line 92
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 94
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"GENERAL: %s\n",
            bufOut);
#line 95
    __builtin_va_end(ap);
    }
#line 96
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 98
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
            bufOut);
#line 99
    __builtin_va_end(ap);
    }
#line 100
    goto switch_break;
    case_2: /* CIL Label */ 
#line 102
    if ((unsigned long )pOutputFile != (unsigned long )((void *)0)) {
      {
#line 103
      pthread_mutex_lock(& ptmFileMutex);
#line 104
      fprintf((FILE */* __restrict  */)pOutputFile, (char const   */* __restrict  */)"%s",
              bufOut);
#line 105
      fflush(pOutputFile);
#line 106
      pthread_mutex_unlock(& ptmFileMutex);
      }
    }
    {
#line 109
    __builtin_va_end(ap);
    }
#line 110
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 112
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
            bufOut);
#line 113
    __builtin_va_end(ap);
#line 114
    exit(0);
    }
#line 115
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 117
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"UNKNOWN: %s\n",
            bufOut);
#line 118
    __builtin_va_end(ap);
    }
#line 119
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 123
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-trace.c"
void writeError(int iLevel , char *pMsg  , ...) 
{ 
  va_list ap ;
  char buf___8[4096] ;
  char bufOut[16384] ;
  char temp[6] ;
  unsigned char cTemp ;
  int i ;
  pthread_t tmp ;
  pthread_t tmp___0 ;
  pthread_t tmp___1 ;
  pthread_t tmp___2 ;
  pthread_t tmp___3 ;

  {
#line 132
  i = 0;
#line 134
  if ((unsigned long )pMsg == (unsigned long )((void *)0)) {
    {
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRITICAL: writeError() called with NULL message.\n");
    }
  } else
#line 137
  if (iLevel <= iErrorLevel) {
    {
#line 138
    __builtin_va_start(ap, pMsg);
#line 139
    memset((void *)(bufOut), 0, (size_t )16384);
#line 140
    memset((void *)(buf___8), 0, (size_t )4096);
#line 141
    vsnprintf((char */* __restrict  */)(buf___8), sizeof(buf___8), (char const   */* __restrict  */)pMsg,
              ap);
#line 144
    i = 0;
    }
    {
#line 144
    while (1) {
      while_continue: /* CIL Label */ ;
#line 144
      if (! ((unsigned long )i < sizeof(buf___8))) {
#line 144
        goto while_break;
      }
      {
#line 146
      memset((void *)(temp), 0, (size_t )6);
#line 147
      cTemp = (unsigned char )buf___8[i];
      }
#line 148
      if ((int )cTemp < 32) {
#line 148
        if ((int )cTemp > 0) {
          {
#line 150
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"[%02X]",
                  (int )cTemp);
          }
        } else {
#line 148
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 148
      if ((int )cTemp > 126) {
        {
#line 150
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"[%02X]",
                (int )cTemp);
        }
      } else {
        {
#line 153
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%c",
                (int )cTemp);
        }
      }
      {
#line 155
      strncat((char */* __restrict  */)(bufOut), (char const   */* __restrict  */)(temp),
              (size_t )6);
#line 144
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 160
    if (iLevel == 0) {
#line 160
      goto case_0;
    }
#line 165
    if (iLevel == 1) {
#line 165
      goto case_1;
    }
#line 168
    if (iLevel == 2) {
#line 168
      goto case_2;
    }
#line 171
    if (iLevel == 3) {
#line 171
      goto case_3;
    }
#line 174
    if (iLevel == 4) {
#line 174
      goto case_4;
    }
#line 177
    if (iLevel == 5) {
#line 177
      goto case_5;
    }
#line 180
    if (iLevel == 6) {
#line 180
      goto case_6;
    }
#line 183
    if (iLevel == 7) {
#line 183
      goto case_7;
    }
#line 186
    if (iLevel == 8) {
#line 186
      goto case_8;
    }
#line 189
    if (iLevel == 9) {
#line 189
      goto case_9;
    }
#line 192
    if (iLevel == 10) {
#line 192
      goto case_10;
    }
#line 195
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 161
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FATAL: %s\n",
            bufOut);
#line 162
    __builtin_va_end(ap);
#line 163
    exit(1);
    }
#line 164
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ALERT: ");
    }
#line 167
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRITICAL: ");
    }
#line 170
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: ");
    }
#line 173
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: ");
    }
#line 176
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NOTICE: ");
    }
#line 179
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INFO: ");
    }
#line 182
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 184
    tmp = pthread_self();
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG [%X]: ",
            (int )tmp);
    }
#line 185
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 187
    tmp___0 = pthread_self();
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG AUDIT [%X]: ",
            (int )tmp___0);
    }
#line 188
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 190
    tmp___1 = pthread_self();
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG SERVER [%X]: ",
            (int )tmp___1);
    }
#line 191
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 193
    tmp___2 = pthread_self();
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG MODULE [%X]: ",
            (int )tmp___2);
    }
#line 194
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 196
    tmp___3 = pthread_self();
#line 196
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"UNKNOWN ERROR [%X]: ",
            (int )tmp___3);
    }
#line 197
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            bufOut);
#line 201
    __builtin_va_end(ap);
    }
  }
#line 204
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-trace.c"
void writeErrorBin(int iLevel , char *pMsg , char *pData , int iLength ) 
{ 
  int i ;

  {
#line 211
  if (iLevel <= iErrorLevel) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DATA: %s ",
            pMsg);
#line 215
    i = 0;
    }
    {
#line 215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 215
      if (! (i < iLength)) {
#line 215
        goto while_break;
      }
      {
#line 216
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%2.2X",
              (int )*(pData + i) & 255);
#line 215
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 221
  return;
}
}
#line 10 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-ssl.h"
void init_crypto_locks(void) ;
#line 11
void kill_crypto_locks(void) ;
#line 80 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-ssl.c"
void init_crypto_locks(void) 
{ 


  {
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-ssl.c"
void kill_crypto_locks(void) 
{ 


  {
#line 96
  return;
}
}
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 44 "/home/wheatley/newnew/temp/medusa-2.1.1/src/listModules.c"
void listModules(char **arrPaths , int nTerminateNow ) 
{ 
  struct dirent **pdeEntry ;
  char *pszTarget ;
  int iLength ;
  void *pLibrary ;
  int (*pSummary)(char ** ) ;
  char *pszUsage ;
  char *pszLibName ;
  char *pszDir ;
  int i ;
  int j ;
  int k ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
#line 58
  pszTarget = (char *)((void *)0);
#line 59
  iLength = 0;
#line 60
  pLibrary = (void *)0;
#line 61
  pSummary = (int (*)(char ** ))((void *)0);
#line 62
  pszUsage = (char *)((void *)0);
#line 63
  pszLibName = (char *)((void *)0);
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < 3)) {
#line 66
      goto while_break;
    }
#line 69
    pszDir = *(arrPaths + i);
#line 70
    if ((unsigned long )pszDir == (unsigned long )((void *)0)) {
#line 72
      goto __Cont;
    } else {
      {
#line 76
      tmp = strlen((char const   *)pszDir);
#line 76
      iLength = (int )(tmp + 1UL);
#line 77
      tmp___0 = malloc((size_t )iLength);
#line 77
      pszTarget = (char *)tmp___0;
#line 78
      memset((void *)pszTarget, 0, (size_t )iLength);
#line 79
      tmp___1 = strlen((char const   *)pszDir);
#line 79
      strncpy((char */* __restrict  */)pszTarget, (char const   */* __restrict  */)pszDir,
              tmp___1);
#line 80
      iLength = 0;
      }
    }
    {
#line 83
    writeVerbose(1, "  Available modules in \"%s\" :", pszTarget);
#line 86
    k = scandir((char const   */* __restrict  */)pszTarget, (struct dirent ***/* __restrict  */)(& pdeEntry),
                (int (*)(struct dirent  const  * ))0, (int (*)(struct dirent  const  ** ,
                                                               struct dirent  const  ** ))(& alphasort));
    }
#line 86
    if (k < 0) {
#line 88
      if (nTerminateNow > 0) {
        {
#line 89
        writeVerbose(0, "\tCouldn\'t open directory \"%s\"", pszTarget);
        }
      } else {
        {
#line 91
        writeVerbose(1, "\tCouldn\'t open directory \"%s\"", pszTarget);
        }
      }
    } else {
#line 96
      j = -1;
      {
#line 97
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 97
        j ++;
#line 97
        if (! (j < k)) {
#line 97
          goto while_break___0;
        }
        {
#line 99
        tmp___2 = strlen((char const   *)((*(pdeEntry + j))->d_name));
#line 99
        iLength = (int )tmp___2;
        }
#line 100
        if (iLength > 4) {
          {
#line 103
          tmp___11 = strlen((char const   *)((*(pdeEntry + j))->d_name));
#line 103
          tmp___12 = strcmp((char const   *)(((*(pdeEntry + j))->d_name + tmp___11) - 4),
                            ".mod");
          }
#line 103
          if (tmp___12 == 0) {
            {
#line 106
            tmp___3 = strlen((char const   *)((*(pdeEntry + j))->d_name));
#line 106
            tmp___4 = strlen((char const   *)pszTarget);
#line 106
            iLength = (int )((tmp___3 + tmp___4) + 2UL);
#line 107
            tmp___5 = malloc((size_t )iLength);
#line 107
            pszLibName = (char *)tmp___5;
#line 108
            memset((void *)pszLibName, 0, (size_t )iLength);
#line 109
            tmp___6 = strlen((char const   *)pszTarget);
#line 109
            strncpy((char */* __restrict  */)pszLibName, (char const   */* __restrict  */)pszTarget,
                    tmp___6);
#line 110
            strncat((char */* __restrict  */)pszLibName, (char const   */* __restrict  */)"/",
                    (size_t )1);
#line 111
            tmp___7 = strlen((char const   *)((*(pdeEntry + j))->d_name));
#line 111
            strncat((char */* __restrict  */)pszLibName, (char const   */* __restrict  */)((*(pdeEntry + j))->d_name),
                    tmp___7);
#line 114
            pLibrary = dlopen((char const   *)pszLibName, 2);
            }
#line 116
            if ((unsigned long )pLibrary == (unsigned long )((void *)0)) {
              {
#line 118
              tmp___8 = dlerror();
#line 118
              writeVerbose(1, "    + %s : Couldn\'t load \"%s\" [%s]", (*(pdeEntry + j))->d_name,
                           pszLibName, tmp___8);
              }
            } else {
              {
#line 125
              tmp___9 = dlsym((void */* __restrict  */)pLibrary, (char const   */* __restrict  */)"summaryUsage");
#line 125
              pSummary = (int (*)(char ** ))tmp___9;
              }
#line 127
              if ((unsigned long )pSummary == (unsigned long )((void *)0)) {
                {
#line 129
                tmp___10 = dlerror();
#line 129
                writeVerbose(1, "    + %s : Invalid module %s [no export of summaryUsage() : %s]",
                             (*(pdeEntry + j))->d_name, pszLibName, tmp___10);
                }
              } else {
                {
#line 136
                pszUsage = (char *)((void *)0);
#line 137
                (*pSummary)(& pszUsage);
#line 138
                writeVerbose(1, "    + %s : %s", (*(pdeEntry + j))->d_name, pszUsage);
#line 139
                free((void *)pszUsage);
                }
              }
              {
#line 143
              dlclose(pLibrary);
              }
            }
            {
#line 146
            free((void *)pszLibName);
            }
          }
        }
        {
#line 153
        free((void *)*(pdeEntry + j));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 157
      writeVerbose(1, "");
      }
    }
    {
#line 161
    free((void *)pszTarget);
    }
    __Cont: /* CIL Label */ 
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if (nTerminateNow > 0) {
    {
#line 164
    writeVerbose(0, "");
    }
  }
#line 165
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 33 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.h"
thr_pool_t *thr_pool_create(uint_t min_threads , uint_t max_threads , uint_t linger ,
                            pthread_attr_t *attr ) ;
#line 50
int thr_pool_queue(thr_pool_t *pool , void *(*func)(void * ) , void *arg ) ;
#line 56
void thr_pool_wait(thr_pool_t *pool ) ;
#line 61
void thr_pool_destroy(thr_pool_t *pool ) ;
#line 32 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *szModuleName  ;
#line 33 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *szTempModuleParam  ;
#line 34 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *szModulePaths[3]  = {      (char *)"a",      (char *)"b",      (char *)"c"};
#line 35 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char **arrModuleParams  ;
#line 36 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int nModuleParamCount  ;
#line 38 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
sAudit *psAudit  =    (sAudit *)((void *)0);
#line 40 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
void freeModuleParams(void) 
{ 
  int i ;

  {
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < nModuleParamCount)) {
#line 44
      goto while_break;
    }
    {
#line 46
    free((void *)*(arrModuleParams + i));
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  free((void *)arrModuleParams);
  }
#line 50
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
void usage(void) 
{ 


  {
  {
#line 57
  writeVerbose(1, "");
#line 58
  writeVerbose(1, "Syntax: %s [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]",
               "Medusa");
#line 59
  writeVerbose(1, "  -h [TEXT]    : Target hostname or IP address");
#line 60
  writeVerbose(1, "  -H [FILE]    : File containing target hostnames or IP addresses");
#line 61
  writeVerbose(1, "  -u [TEXT]    : Username to test");
#line 62
  writeVerbose(1, "  -U [FILE]    : File containing usernames to test");
#line 63
  writeVerbose(1, "  -p [TEXT]    : Password to test");
#line 64
  writeVerbose(1, "  -P [FILE]    : File containing passwords to test");
#line 65
  writeVerbose(1, "  -C [FILE]    : File containing combo entries. See README for more information.");
#line 66
  writeVerbose(1, "  -O [FILE]    : File to append log information to");
#line 67
  writeVerbose(1, "  -e [n/s/ns]  : Additional password checks ([n] No Password, [s] Password = Username)");
#line 68
  writeVerbose(1, "  -M [TEXT]    : Name of the module to execute (without the .mod extension)");
#line 69
  writeVerbose(1, "  -m [TEXT]    : Parameter to pass to the module. This can be passed multiple times with a");
#line 70
  writeVerbose(1, "                 different parameter each time and they will all be sent to the module (i.e.");
#line 71
  writeVerbose(1, "                 -m Param1 -m Param2, etc.)");
#line 72
  writeVerbose(1, "  -d           : Dump all known modules");
#line 73
  writeVerbose(1, "  -n [NUM]     : Use for non-default TCP port number");
#line 74
  writeVerbose(1, "  -s           : Enable SSL");
#line 75
  writeVerbose(1, "  -g [NUM]     : Give up after trying to connect for NUM seconds (default 3)");
#line 76
  writeVerbose(1, "  -r [NUM]     : Sleep NUM seconds between retry attempts (default 3)");
#line 77
  writeVerbose(1, "  -R [NUM]     : Attempt NUM retries before giving up. The total number of attempts will be NUM + 1.");
#line 78
  writeVerbose(1, "  -c [NUM]     : Time to wait in usec to verify socket is available (default 500 usec).");
#line 79
  writeVerbose(1, "  -t [NUM]     : Total number of logins to be tested concurrently");
#line 80
  writeVerbose(1, "  -T [NUM]     : Total number of hosts to be tested concurrently");
#line 81
  writeVerbose(1, "  -L           : Parallelize logins using one username per thread. The default is to process ");
#line 82
  writeVerbose(1, "                 the entire username before proceeding.");
#line 83
  writeVerbose(1, "  -f           : Stop scanning host after first valid username/password found.");
#line 84
  writeVerbose(1, "  -F           : Stop audit after first valid username/password found on any host.");
#line 85
  writeVerbose(1, "  -b           : Suppress startup banner");
#line 86
  writeVerbose(1, "  -q           : Display module\'s usage information");
#line 87
  writeVerbose(1, "  -v [NUM]     : Verbose level [0 - 6 (more)]");
#line 88
  writeVerbose(1, "  -w [NUM]     : Error debug level [0 - 10 (more)]");
#line 89
  writeVerbose(1, "  -V           : Display version");
#line 90
  writeVerbose(1, "  -Z [TEXT]    : Resume scan based on map of previous scan");
#line 91
  writeVerbose(1, "\n");
  }
#line 92
  return;
}
}
#line 337
int invokeModule(char *pModuleName , sLogin *pLogin , int argc , char **argv ) ;
#line 98 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int checkOptions(int argc , char **argv , sAudit *_psAudit ) 
{ 
  int opt ;
  int ret ;
  int i ;
  int nIgnoreBanner ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  void *tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  void *tmp___44 ;
  size_t tmp___45 ;
  void *tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;

  {
#line 103
  ret = 0;
#line 104
  i = 0;
#line 105
  nIgnoreBanner = 0;
#line 108
  _psAudit->iServerCnt = 1;
#line 109
  _psAudit->iLoginCnt = 1;
#line 110
  _psAudit->iParallelLoginFlag = 2;
#line 111
  _psAudit->iPortOverride = 0;
#line 112
  _psAudit->iUseSSL = 0;
#line 113
  _psAudit->iTimeout = 3;
#line 114
  _psAudit->iRetryWait = 3;
#line 115
  _psAudit->iRetries = 3;
#line 116
  _psAudit->iSocketWait = 500;
#line 117
  _psAudit->iShowModuleHelp = 0;
#line 118
  iVerboseLevel = 5;
#line 119
  iErrorLevel = 5;
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < argc)) {
#line 121
      goto while_break;
    }
    {
#line 123
    tmp = strstr((char const   *)*(argv + i), "-b");
    }
#line 123
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 125
      nIgnoreBanner = 1;
#line 126
      goto while_break;
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if (nIgnoreBanner == 0) {
    {
#line 131
    writeVerbose(1, "%s v%s [%s] (C) %s %s\n", "Medusa", "2.1.1", "http://www.foofus.net",
                 "JoMo-Kun / Foofus Networks", "<jmk@foofus.net>");
    }
  }
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 133
    opt = getopt(argc, (char * const  *)argv, "h:H:u:U:p:P:C:O:e:M:m:g:r:R:c:t:T:n:bqdsLfFVv:w:Z:");
    }
#line 133
    if (! (opt != -1)) {
#line 133
      goto while_break___0;
    }
    {
#line 137
    if (opt == 104) {
#line 137
      goto case_104;
    }
#line 151
    if (opt == 72) {
#line 151
      goto case_72;
    }
#line 165
    if (opt == 117) {
#line 165
      goto case_117;
    }
#line 180
    if (opt == 85) {
#line 180
      goto case_85;
    }
#line 194
    if (opt == 112) {
#line 194
      goto case_112;
    }
#line 209
    if (opt == 80) {
#line 209
      goto case_80;
    }
#line 223
    if (opt == 67) {
#line 223
      goto case_67;
    }
#line 228
    if (opt == 79) {
#line 228
      goto case_79;
    }
#line 233
    if (opt == 101) {
#line 233
      goto case_101;
    }
#line 255
    if (opt == 115) {
#line 255
      goto case_115;
    }
#line 258
    if (opt == 76) {
#line 258
      goto case_76;
    }
#line 261
    if (opt == 102) {
#line 261
      goto case_102;
    }
#line 264
    if (opt == 70) {
#line 264
      goto case_70;
    }
#line 267
    if (opt == 116) {
#line 267
      goto case_116;
    }
#line 270
    if (opt == 84) {
#line 270
      goto case_84;
    }
#line 273
    if (opt == 110) {
#line 273
      goto case_110;
    }
#line 276
    if (opt == 118) {
#line 276
      goto case_118;
    }
#line 279
    if (opt == 119) {
#line 279
      goto case_119;
    }
#line 282
    if (opt == 86) {
#line 282
      goto case_86;
    }
#line 285
    if (opt == 77) {
#line 285
      goto case_77;
    }
#line 291
    if (opt == 109) {
#line 291
      goto case_109;
    }
#line 299
    if (opt == 100) {
#line 299
      goto case_100;
    }
#line 302
    if (opt == 98) {
#line 302
      goto case_98;
    }
#line 305
    if (opt == 113) {
#line 305
      goto case_113;
    }
#line 308
    if (opt == 103) {
#line 308
      goto case_103;
    }
#line 311
    if (opt == 114) {
#line 311
      goto case_114;
    }
#line 314
    if (opt == 82) {
#line 314
      goto case_82;
    }
#line 317
    if (opt == 99) {
#line 317
      goto case_99;
    }
#line 320
    if (opt == 90) {
#line 320
      goto case_90;
    }
#line 325
    goto switch_default;
    case_104: /* CIL Label */ 
#line 138
    if (_psAudit->HostType) {
      {
#line 140
      writeError(1, "Options \'h\' and \'H\' are mutually exclusive.");
#line 141
      ret = 1;
      }
    } else {
      {
#line 145
      tmp___0 = strlen((char const   *)optarg);
#line 145
      tmp___1 = malloc(tmp___0 + 1UL);
#line 145
      _psAudit->pGlobalHost = (char *)tmp___1;
#line 146
      tmp___2 = strlen((char const   *)optarg);
#line 146
      memset((void *)_psAudit->pGlobalHost, 0, tmp___2 + 1UL);
#line 147
      tmp___3 = strlen((char const   *)optarg);
#line 147
      strncpy((char */* __restrict  */)_psAudit->pGlobalHost, (char const   */* __restrict  */)optarg,
              tmp___3);
#line 148
      _psAudit->HostType = 1;
      }
    }
#line 150
    goto switch_break;
    case_72: /* CIL Label */ 
#line 152
    if (_psAudit->HostType) {
      {
#line 154
      writeError(1, "Options \'h\' and \'H\' are mutually exclusive.");
#line 155
      ret = 1;
      }
    } else {
      {
#line 159
      tmp___4 = strlen((char const   *)optarg);
#line 159
      tmp___5 = malloc(tmp___4 + 1UL);
#line 159
      _psAudit->pOptHost = (char *)tmp___5;
#line 160
      tmp___6 = strlen((char const   *)optarg);
#line 160
      memset((void *)_psAudit->pOptHost, 0, tmp___6 + 1UL);
#line 161
      tmp___7 = strlen((char const   *)optarg);
#line 161
      strncpy((char */* __restrict  */)_psAudit->pOptHost, (char const   */* __restrict  */)optarg,
              tmp___7);
#line 162
      _psAudit->HostType = 2;
      }
    }
#line 164
    goto switch_break;
    case_117: /* CIL Label */ 
#line 166
    if (_psAudit->UserType) {
      {
#line 168
      writeError(1, "Options \'u\' and \'U\' are mutually exclusive.");
#line 169
      ret = 1;
      }
    } else {
      {
#line 173
      tmp___8 = strlen((char const   *)optarg);
#line 173
      tmp___9 = malloc(tmp___8 + 1UL);
#line 173
      _psAudit->pGlobalUser = (char *)tmp___9;
#line 174
      tmp___10 = strlen((char const   *)optarg);
#line 174
      memset((void *)_psAudit->pGlobalUser, 0, tmp___10 + 1UL);
#line 175
      tmp___11 = strlen((char const   *)optarg);
#line 175
      strncpy((char */* __restrict  */)_psAudit->pGlobalUser, (char const   */* __restrict  */)optarg,
              tmp___11);
#line 176
      _psAudit->UserType = 1;
#line 177
      _psAudit->iUserCnt = 1;
      }
    }
#line 179
    goto switch_break;
    case_85: /* CIL Label */ 
#line 181
    if (_psAudit->UserType) {
      {
#line 183
      writeError(1, "Options \'u\' and \'U\' are mutually exclusive.");
#line 184
      ret = 1;
      }
    } else {
      {
#line 188
      tmp___12 = strlen((char const   *)optarg);
#line 188
      tmp___13 = malloc(tmp___12 + 1UL);
#line 188
      _psAudit->pOptUser = (char *)tmp___13;
#line 189
      tmp___14 = strlen((char const   *)optarg);
#line 189
      memset((void *)_psAudit->pOptUser, 0, tmp___14 + 1UL);
#line 190
      tmp___15 = strlen((char const   *)optarg);
#line 190
      strncpy((char */* __restrict  */)_psAudit->pOptUser, (char const   */* __restrict  */)optarg,
              tmp___15);
#line 191
      _psAudit->UserType = 2;
      }
    }
#line 193
    goto switch_break;
    case_112: /* CIL Label */ 
#line 195
    if (_psAudit->PassType) {
      {
#line 197
      writeError(1, "Options \'p\' and \'P\' are mutually exclusive.");
#line 198
      ret = 1;
      }
    } else {
      {
#line 202
      tmp___16 = strlen((char const   *)optarg);
#line 202
      tmp___17 = malloc(tmp___16 + 2UL);
#line 202
      _psAudit->pGlobalPass = (char *)tmp___17;
#line 203
      tmp___18 = strlen((char const   *)optarg);
#line 203
      memset((void *)_psAudit->pGlobalPass, 0, tmp___18 + 2UL);
#line 204
      tmp___19 = strlen((char const   *)optarg);
#line 204
      strncpy((char */* __restrict  */)_psAudit->pGlobalPass, (char const   */* __restrict  */)optarg,
              tmp___19);
#line 205
      _psAudit->PassType = 1;
#line 206
      _psAudit->iPassCnt = 1;
      }
    }
#line 208
    goto switch_break;
    case_80: /* CIL Label */ 
#line 210
    if (_psAudit->PassType) {
      {
#line 212
      writeError(1, "Options \'p\' and \'P\' are mutually exclusive.");
#line 213
      ret = 1;
      }
    } else {
      {
#line 217
      tmp___20 = strlen((char const   *)optarg);
#line 217
      tmp___21 = malloc(tmp___20 + 1UL);
#line 217
      _psAudit->pOptPass = (char *)tmp___21;
#line 218
      tmp___22 = strlen((char const   *)optarg);
#line 218
      memset((void *)_psAudit->pOptPass, 0, tmp___22 + 1UL);
#line 219
      tmp___23 = strlen((char const   *)optarg);
#line 219
      strncpy((char */* __restrict  */)_psAudit->pOptPass, (char const   */* __restrict  */)optarg,
              tmp___23);
#line 220
      _psAudit->PassType = 2;
      }
    }
#line 222
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 224
    tmp___24 = strlen((char const   *)optarg);
#line 224
    tmp___25 = malloc(tmp___24 + 1UL);
#line 224
    _psAudit->pOptCombo = (char *)tmp___25;
#line 225
    tmp___26 = strlen((char const   *)optarg);
#line 225
    memset((void *)_psAudit->pOptCombo, 0, tmp___26 + 1UL);
#line 226
    tmp___27 = strlen((char const   *)optarg);
#line 226
    strncpy((char */* __restrict  */)_psAudit->pOptCombo, (char const   */* __restrict  */)optarg,
            tmp___27);
    }
#line 227
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 229
    tmp___28 = strlen((char const   *)optarg);
#line 229
    tmp___29 = malloc(tmp___28 + 1UL);
#line 229
    _psAudit->pOptOutput = (char *)tmp___29;
#line 230
    tmp___30 = strlen((char const   *)optarg);
#line 230
    memset((void *)_psAudit->pOptOutput, 0, tmp___30 + 1UL);
#line 231
    tmp___31 = strlen((char const   *)optarg);
#line 231
    strncpy((char */* __restrict  */)_psAudit->pOptOutput, (char const   */* __restrict  */)optarg,
            tmp___31);
    }
#line 232
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 234
    tmp___35 = strcmp((char const   *)optarg, "n");
    }
#line 234
    if (tmp___35 == 0) {
#line 236
      _psAudit->iPasswordBlankFlag = 1;
#line 237
      _psAudit->iPasswordUsernameFlag = 0;
    } else {
      {
#line 239
      tmp___34 = strcmp((char const   *)optarg, "s");
      }
#line 239
      if (tmp___34 == 0) {
#line 241
        _psAudit->iPasswordBlankFlag = 0;
#line 242
        _psAudit->iPasswordUsernameFlag = 1;
      } else {
        {
#line 244
        tmp___32 = strcmp((char const   *)optarg, "ns");
        }
#line 244
        if (tmp___32 == 0) {
#line 246
          _psAudit->iPasswordBlankFlag = 1;
#line 247
          _psAudit->iPasswordUsernameFlag = 1;
        } else {
          {
#line 244
          tmp___33 = strcmp((char const   *)optarg, "sn");
          }
#line 244
          if (tmp___33 == 0) {
#line 246
            _psAudit->iPasswordBlankFlag = 1;
#line 247
            _psAudit->iPasswordUsernameFlag = 1;
          } else {
            {
#line 251
            writeError(1, "Option \'e\' requires value of n, s, or ns.");
#line 252
            ret = 1;
            }
          }
        }
      }
    }
#line 254
    goto switch_break;
    case_115: /* CIL Label */ 
#line 256
    _psAudit->iUseSSL = 1;
#line 257
    goto switch_break;
    case_76: /* CIL Label */ 
#line 259
    _psAudit->iParallelLoginFlag = 1;
#line 260
    goto switch_break;
    case_102: /* CIL Label */ 
#line 262
    _psAudit->iFoundPairExitFlag = 1;
#line 263
    goto switch_break;
    case_70: /* CIL Label */ 
#line 265
    _psAudit->iFoundPairExitFlag = 2;
#line 266
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 268
    _psAudit->iLoginCnt = atoi((char const   *)optarg);
    }
#line 269
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 271
    _psAudit->iServerCnt = atoi((char const   *)optarg);
    }
#line 272
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 274
    _psAudit->iPortOverride = atoi((char const   *)optarg);
    }
#line 275
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 277
    iVerboseLevel = atoi((char const   *)optarg);
    }
#line 278
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 280
    iErrorLevel = atoi((char const   *)optarg);
    }
#line 281
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 283
    writeVerbose(0, "");
    }
#line 284
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 286
    tmp___36 = strlen((char const   *)optarg);
#line 286
    tmp___37 = malloc(tmp___36 + 1UL);
#line 286
    szModuleName = (char *)tmp___37;
#line 287
    tmp___38 = strlen((char const   *)optarg);
#line 287
    memset((void *)szModuleName, 0, tmp___38 + 1UL);
#line 288
    tmp___39 = strlen((char const   *)optarg);
#line 288
    strncpy((char */* __restrict  */)szModuleName, (char const   */* __restrict  */)optarg,
            tmp___39);
#line 289
    _psAudit->pModuleName = szModuleName;
    }
#line 290
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 292
    nModuleParamCount ++;
#line 293
    tmp___40 = strlen((char const   *)optarg);
#line 293
    tmp___41 = malloc(tmp___40 + 1UL);
#line 293
    szTempModuleParam = (char *)tmp___41;
#line 294
    tmp___42 = strlen((char const   *)optarg);
#line 294
    memset((void *)szTempModuleParam, 0, tmp___42 + 1UL);
#line 295
    tmp___43 = strlen((char const   *)optarg);
#line 295
    strncpy((char */* __restrict  */)szTempModuleParam, (char const   */* __restrict  */)optarg,
            tmp___43);
#line 296
    tmp___44 = realloc((void *)arrModuleParams, (unsigned long )nModuleParamCount * sizeof(char *));
#line 296
    arrModuleParams = (char **)tmp___44;
#line 297
    *(arrModuleParams + (nModuleParamCount - 1)) = szTempModuleParam;
    }
#line 298
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 300
    listModules(szModulePaths, 1);
    }
#line 301
    goto switch_break;
    case_98: /* CIL Label */ 
#line 304
    goto switch_break;
    case_113: /* CIL Label */ 
#line 306
    _psAudit->iShowModuleHelp = 1;
#line 307
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 309
    _psAudit->iTimeout = atoi((char const   *)optarg);
    }
#line 310
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 312
    _psAudit->iRetryWait = atoi((char const   *)optarg);
    }
#line 313
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 315
    _psAudit->iRetries = atoi((char const   *)optarg);
    }
#line 316
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 318
    _psAudit->iSocketWait = atoi((char const   *)optarg);
    }
#line 319
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 321
    tmp___45 = strlen((char const   *)optarg);
#line 321
    tmp___46 = malloc(tmp___45 + 1UL);
#line 321
    _psAudit->pOptResume = (char *)tmp___46;
#line 322
    tmp___47 = strlen((char const   *)optarg);
#line 322
    memset((void *)_psAudit->pOptResume, 0, tmp___47 + 1UL);
#line 323
    tmp___48 = strlen((char const   *)optarg);
#line 323
    strncpy((char */* __restrict  */)_psAudit->pOptResume, (char const   */* __restrict  */)optarg,
            tmp___48);
    }
#line 324
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 326
    writeError(2, "Unknown error processing command-line options.");
#line 327
    ret = 1;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 331
  if (argc <= 1) {
#line 332
    ret = 1;
  }
#line 335
  if (_psAudit->iShowModuleHelp) {
    {
#line 337
    ret = invokeModule(_psAudit->pModuleName, (void *)0, (void *)0, (void *)0);
    }
#line 338
    if (ret < 0) {
      {
#line 340
      writeError(2, "invokeModule failed - see previous errors for an explanation");
      }
    }
  } else
#line 345
  if (_psAudit->HostType) {
#line 345
    goto _L___0;
  } else
#line 345
  if (_psAudit->pOptCombo) {
    _L___0: /* CIL Label */ 
#line 350
    if (_psAudit->UserType) {
#line 350
      goto _L;
    } else
#line 350
    if (_psAudit->pOptCombo) {
      _L: /* CIL Label */ 
#line 355
      if (! _psAudit->PassType) {
#line 355
        if (! _psAudit->pOptCombo) {
#line 355
          if (! _psAudit->iPasswordBlankFlag) {
#line 355
            if (! _psAudit->iPasswordUsernameFlag) {
              {
#line 357
              writeError(1, "Password information must be supplied.");
#line 358
              ret = 1;
              }
            }
          }
        }
      }
    } else {
      {
#line 352
      writeError(1, "User logon information must be supplied.");
#line 353
      ret = 1;
      }
    }
  } else {
    {
#line 347
    writeError(1, "Host information must be supplied.");
#line 348
    ret = 1;
    }
  }
#line 362
  return (ret);
}
}
#line 365 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int invokeModule(char *pModuleName , sLogin *pLogin , int argc , char **argv ) 
{ 
  void *pLibrary ;
  int iReturn ;
  int (*pGo)(sLogin * , int  , char ** ) ;
  void (*pUsage)() ;
  char *modPath ;
  int nPathLength ;
  int i ;
  int nSuccess ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 374
  nSuccess = 0;
#line 376
  iReturn = -1;
#line 377
  pLibrary = (void *)0;
#line 378
  pGo = (int (*)(sLogin * , int  , char ** ))((void *)0);
#line 379
  pUsage = (void (*)())((void *)0);
#line 381
  if ((unsigned long )((void *)0) == (unsigned long )pModuleName) {
    {
#line 383
    listModules(szModulePaths, 0);
#line 384
    writeError(2, "invokeModule called with no name");
    }
#line 385
    return (-1);
  }
#line 389
  i = 0;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i < 3)) {
#line 389
      goto while_break;
    }
#line 391
    if ((unsigned long )szModulePaths[i] != (unsigned long )((void *)0)) {
      {
#line 394
      writeError(7, "Trying module path of %s", szModulePaths[i]);
#line 395
      tmp = strlen((char const   *)szModulePaths[i]);
#line 395
      tmp___0 = strlen((char const   *)pModuleName);
#line 395
      tmp___1 = strlen(".mod");
#line 395
      nPathLength = (int )(((tmp + tmp___0) + tmp___1) + 2UL);
#line 396
      tmp___2 = malloc((size_t )nPathLength);
#line 396
      modPath = (char *)tmp___2;
#line 397
      memset((void *)modPath, 0, (size_t )nPathLength);
#line 398
      tmp___3 = strlen((char const   *)szModulePaths[i]);
#line 398
      strncpy((char */* __restrict  */)modPath, (char const   */* __restrict  */)szModulePaths[i],
              tmp___3);
#line 399
      strncat((char */* __restrict  */)modPath, (char const   */* __restrict  */)"/",
              (size_t )1);
#line 400
      tmp___4 = strlen((char const   *)pModuleName);
#line 400
      strncat((char */* __restrict  */)modPath, (char const   */* __restrict  */)pModuleName,
              tmp___4);
#line 401
      tmp___5 = strlen(".mod");
#line 401
      strncat((char */* __restrict  */)modPath, (char const   */* __restrict  */)".mod",
              tmp___5);
#line 404
      writeError(7, "Attempting to load %s", modPath);
#line 405
      pLibrary = dlopen((char const   *)modPath, 2);
      }
#line 407
      if ((unsigned long )pLibrary == (unsigned long )((void *)0)) {
#line 409
        goto __Cont;
      } else
#line 411
      if (! pLogin) {
        {
#line 413
        tmp___6 = dlsym((void */* __restrict  */)pLibrary, (char const   */* __restrict  */)"showUsage");
#line 413
        pUsage = (void (*)())tmp___6;
#line 415
        writeError(7, "Attempting to display usage information for module: %s", modPath);
        }
#line 417
        if ((unsigned long )pUsage == (unsigned long )((void *)0)) {
          {
#line 419
          tmp___7 = dlerror();
#line 419
          writeError(1, "Couldn\'t get a pointer to \"showUsage\" for module %s [%s]",
                     modPath, tmp___7);
          }
#line 420
          return (-1);
        } else {
          {
#line 424
          nSuccess = 1;
#line 425
          (*pUsage)();
          }
        }
        {
#line 427
        dlclose(pLibrary);
#line 428
        exit(0);
        }
      } else {
        {
#line 432
        tmp___8 = dlsym((void */* __restrict  */)pLibrary, (char const   */* __restrict  */)"go");
#line 432
        pGo = (int (*)(sLogin * , int  , char ** ))tmp___8;
        }
#line 434
        if ((unsigned long )pGo == (unsigned long )((void *)0)) {
          {
#line 436
          tmp___9 = dlerror();
#line 436
          writeError(1, "Couldn\'t get a pointer to \"go\" for module %s [%s]", modPath,
                     tmp___9);
          }
#line 437
          return (-1);
        } else {
          {
#line 441
          nSuccess = 1;
#line 442
          iReturn = (*pGo)(pLogin, argc, argv);
          }
#line 443
          goto while_break;
        }
        {
#line 445
        dlclose(pLibrary);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 389
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if (! nSuccess) {
    {
#line 452
    tmp___10 = dlerror();
#line 452
    writeVerbose(3, "Couldn\'t load \"%s\" [%s]. Place the module in the medusa directory, set the MEDUSA_MODULE_NAME environment variable or run the configure script again using --with-default-mod-path=[path].",
                 pModuleName, tmp___10);
#line 453
    iReturn = -1;
    }
  }
#line 456
  return (iReturn);
}
}
#line 463 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
void loadFile(char *pFile , char **pFileContent , int *iFileCnt ) 
{ 
  FILE *pfFile ;
  size_t stFileSize ;
  char tmp[16384] ;
  char *ptr ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 466
  stFileSize = (size_t )0;
#line 470
  *iFileCnt = 0;
#line 472
  pfFile = fopen((char const   */* __restrict  */)pFile, (char const   */* __restrict  */)"r");
  }
#line 472
  if ((unsigned long )pfFile == (unsigned long )((void *)0)) {
    {
#line 474
    tmp___0 = __errno_location();
#line 474
    tmp___1 = strerror(*tmp___0);
#line 474
    writeError(0, "Failed to open file %s - %s", pFile, tmp___1);
    }
  } else {
    {
#line 479
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 479
      tmp___4 = feof(pfFile);
      }
#line 479
      if (tmp___4) {
#line 479
        goto while_break;
      }
      {
#line 481
      tmp___3 = fgets((char */* __restrict  */)(tmp), 16384, (FILE */* __restrict  */)pfFile);
      }
#line 481
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 483
        if ((int )tmp[0] != 0) {
          {
#line 485
          tmp___2 = strlen((char const   *)(tmp));
#line 485
          stFileSize += tmp___2 + 1UL;
#line 486
          (*iFileCnt) ++;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 490
    rewind(pfFile);
#line 492
    tmp___5 = malloc(stFileSize + 1UL);
#line 492
    *pFileContent = (char *)tmp___5;
    }
#line 494
    if ((unsigned long )pFileContent == (unsigned long )((void *)0)) {
      {
#line 496
      writeError(0, "Failed to allocate memory for file %s.", pFile);
      }
    }
    {
#line 499
    memset((void *)*pFileContent, 0, stFileSize + 1UL);
#line 500
    ptr = *pFileContent;
    }
    {
#line 503
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 503
      tmp___13 = feof(pfFile);
      }
#line 503
      if (tmp___13) {
#line 503
        goto while_break___0;
      }
      {
#line 505
      tmp___12 = fgets((char */* __restrict  */)(tmp), 16384, (FILE */* __restrict  */)pfFile);
      }
#line 505
      if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 508
        if ((int )tmp[0] == 10) {
          {
#line 510
          (*iFileCnt) --;
#line 511
          writeError(7, "Ignoring blank line in file: %s. Resetting total count: %d.",
                     pFile, *iFileCnt);
          }
        } else
#line 508
        if ((int )tmp[0] == 13) {
          {
#line 510
          (*iFileCnt) --;
#line 511
          writeError(7, "Ignoring blank line in file: %s. Resetting total count: %d.",
                     pFile, *iFileCnt);
          }
        } else
#line 513
        if ((int )tmp[0] != 0) {
          {
#line 515
          tmp___7 = strlen((char const   *)(tmp));
          }
#line 515
          if ((int )tmp[tmp___7 - 1UL] == 10) {
            {
#line 515
            tmp___6 = strlen((char const   *)(tmp));
#line 515
            tmp[tmp___6 - 1UL] = (char )'\000';
            }
          }
          {
#line 516
          tmp___9 = strlen((char const   *)(tmp));
          }
#line 516
          if ((int )tmp[tmp___9 - 1UL] == 13) {
            {
#line 516
            tmp___8 = strlen((char const   *)(tmp));
#line 516
            tmp[tmp___8 - 1UL] = (char )'\000';
            }
          }
          {
#line 517
          tmp___10 = strlen((char const   *)(tmp));
#line 517
          memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(tmp),
                 tmp___10 + 1UL);
#line 518
          tmp___11 = strlen((char const   *)(tmp));
#line 518
          ptr += tmp___11 + 1UL;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 522
    *ptr = (char )'\000';
  }
#line 525
  if (*iFileCnt == 0) {
    {
#line 527
    writeError(0, "Error loading user supplied file (%s) -- file may be empty.", pFile);
    }
  }
  {
#line 530
  free((void *)pFile);
  }
#line 531
  return;
}
}
#line 554 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int processComboFile(sAudit **_psAudit ) 
{ 
  int ret ;
  int iColonCount ;
  char *pComboTmp ;
  int tmp ;

  {
  {
#line 556
  ret = 0;
#line 556
  iColonCount = 0;
#line 559
  writeError(7, "[processComboFile] Processing user supplied combo file.");
#line 561
  pComboTmp = (*_psAudit)->pGlobalCombo;
#line 565
  writeError(7, "[processComboFile] PwDump file check.");
  }
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! ((int )*pComboTmp != 0)) {
#line 566
      goto while_break;
    }
    {
#line 568
    tmp = strcmp((char const   *)pComboTmp, ":::");
    }
#line 568
    if (tmp == 0) {
#line 570
      iColonCount += 3;
#line 571
      pComboTmp += 3;
    } else
#line 573
    if ((int )*pComboTmp == 58) {
#line 575
      iColonCount ++;
#line 576
      pComboTmp ++;
    } else {
#line 580
      pComboTmp ++;
    }
#line 583
    if (iColonCount == 6) {
#line 583
      if ((int )*pComboTmp == 0) {
        {
#line 584
        writeError(7, "[processComboFile] Combo format scan detected PwDump file.");
        }
#line 586
        if ((*_psAudit)->HostType != 1) {
#line 586
          if ((*_psAudit)->HostType != 2) {
            {
#line 588
            writeError(0, "Combo format used requires host information via (-h/-H).");
            }
          }
        }
#line 591
        if ((*_psAudit)->UserType != 1) {
#line 591
          if ((*_psAudit)->UserType != 2) {
#line 593
            (*_psAudit)->UserType = 4;
          }
        }
#line 596
        (*_psAudit)->PassType = 4;
#line 598
        return (ret);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  if (! (iColonCount == 2)) {
#line 602
    if (! (iColonCount == 3)) {
      {
#line 604
      writeError(7, "[processComboFile] Number of colons detected in first entry: %d",
                 iColonCount);
#line 605
      writeError(0, "Invalid combo file format.");
      }
    }
  }
#line 608
  pComboTmp = (*_psAudit)->pGlobalCombo;
#line 610
  if ((int )*pComboTmp == 58) {
    {
#line 612
    writeError(7, "[processComboFile] No host combo field specified.");
    }
#line 613
    if ((*_psAudit)->HostType != 1) {
#line 613
      if ((*_psAudit)->HostType != 2) {
        {
#line 615
        writeError(0, "Combo format used requires host information via (-h/-H).");
        }
      }
    }
  } else {
    {
#line 620
    writeError(7, "[processComboFile] Host combo field specified.");
#line 621
    (*_psAudit)->HostType = 3;
    }
    {
#line 623
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 623
      if (! ((int )*pComboTmp != 58)) {
#line 623
        goto while_break___0;
      }
#line 625
      if ((unsigned long )pComboTmp == (unsigned long )((void *)0)) {
        {
#line 627
        writeError(0, "Failed to process combo file. Incorrect format.");
        }
      }
#line 630
      pComboTmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 633
  pComboTmp ++;
#line 635
  if ((int )*pComboTmp == 58) {
    {
#line 637
    writeError(7, "[processComboFile] No user combo field specified.");
    }
#line 638
    if ((*_psAudit)->UserType != 1) {
#line 638
      if ((*_psAudit)->UserType != 2) {
        {
#line 640
        writeError(0, "Combo format used requires user information via (-u/-U).");
        }
      }
    }
  } else {
    {
#line 645
    writeError(7, "[processComboFile] User combo field specified.");
#line 646
    (*_psAudit)->UserType = 3;
    }
    {
#line 648
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 648
      if (! ((int )*pComboTmp != 58)) {
#line 648
        goto while_break___1;
      }
#line 650
      if ((unsigned long )pComboTmp == (unsigned long )((void *)0)) {
        {
#line 652
        writeError(0, "Failed to process combo file. Incorrect format.");
        }
      }
#line 655
      pComboTmp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 658
  pComboTmp ++;
#line 660
  if ((int )*pComboTmp == 0) {
    {
#line 662
    writeError(7, "[processComboFile] No password combo field specified.");
    }
#line 663
    if ((*_psAudit)->PassType != 1) {
#line 663
      if ((*_psAudit)->PassType != 2) {
#line 663
        if ((*_psAudit)->iPasswordBlankFlag == 0) {
#line 663
          if ((*_psAudit)->iPasswordUsernameFlag == 0) {
            {
#line 666
            writeError(0, "Combo format used requires password information via (-p/-P).");
            }
          }
        }
      }
    }
  } else {
    {
#line 671
    writeError(7, "[processComboFile] Password combo field specified.");
#line 672
    (*_psAudit)->PassType = 3;
    }
  }
#line 675
  return (ret);
}
}
#line 684 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *findNextHost(sAudit *_psAudit , char *_pHost ) 
{ 


  {
#line 687
  if (_psAudit->pGlobalCombo) {
    {
#line 689
    writeError(7, "[findNextHost] Process global combo file.");
    }
#line 691
    if (_psAudit->iUserListFlag == 1) {
#line 691
      if (_psAudit->iHostListFlag == 1) {
        {
#line 693
        writeError(7, "[findNextHost] Advance to next entry in combo list.");
        }
        {
#line 695
        while (1) {
          while_continue: /* CIL Label */ ;
#line 695
          if (! ((int )*(_psAudit->pGlobalCombo) != 0)) {
#line 695
            goto while_break;
          }
#line 696
          (_psAudit->pGlobalCombo) ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 697
        (_psAudit->pGlobalCombo) ++;
        {
#line 700
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 700
          if (! ((int )*(_psAudit->pGlobalCombo) != 0)) {
#line 700
            goto while_break___0;
          }
#line 701
          (_psAudit->pGlobalCombo) ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 702
        (_psAudit->pGlobalCombo) ++;
        {
#line 705
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 705
          if (! ((int )*(_psAudit->pGlobalCombo) != 0)) {
#line 705
            goto while_break___1;
          }
#line 706
          (_psAudit->pGlobalCombo) ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 707
        (_psAudit->pGlobalCombo) ++;
#line 709
        if ((int )*(_psAudit->pGlobalCombo) == 0) {
#line 711
          _psAudit->iAuditFlag = 1;
        } else {
#line 715
          _psAudit->iAuditFlag = 0;
        }
      }
    }
#line 720
    if ((unsigned long )_psAudit->pComboEntryTmp == (unsigned long )((void *)0)) {
#line 720
      goto _L;
    } else
#line 720
    if (_psAudit->iUserListFlag == 1) {
#line 720
      if (_psAudit->iHostListFlag == 1) {
        _L: /* CIL Label */ 
        {
#line 722
        writeError(7, "[findNextHost] Convert \':\' to \'\\0\' in combo entries.");
#line 723
        _psAudit->pComboEntryTmp = _psAudit->pGlobalCombo;
        }
#line 725
        if ((int )*(_psAudit->pComboEntryTmp) != 0) {
          {
#line 728
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 728
            if (! ((int )*(_psAudit->pComboEntryTmp) != 58)) {
#line 728
              goto while_break___2;
            }
#line 729
            (_psAudit->pComboEntryTmp) ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 730
          memset((void *)_psAudit->pComboEntryTmp, 0, (size_t )1);
          }
          {
#line 733
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 733
            if (! ((int )*(_psAudit->pComboEntryTmp) != 58)) {
#line 733
              goto while_break___3;
            }
#line 734
            (_psAudit->pComboEntryTmp) ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 735
          memset((void *)_psAudit->pComboEntryTmp, 0, (size_t )1);
          }
        }
      }
    }
#line 739
    _psAudit->pComboEntryTmp = _psAudit->pGlobalCombo;
  } else
#line 743
  if (_psAudit->iUserListFlag == 1) {
#line 743
    if (_psAudit->iHostListFlag == 1) {
#line 745
      _psAudit->iAuditFlag = 1;
    }
  }
#line 749
  _psAudit->iHostListFlag = 1;
#line 751
  if (_psAudit->iAuditFlag == 1) {
#line 753
    _pHost = (char *)((void *)0);
  } else
#line 755
  if (_psAudit->HostType == 3) {
#line 757
    if ((int )*(_psAudit->pGlobalCombo) == 0) {
#line 759
      _pHost = (char *)((void *)0);
    } else {
#line 763
      _pHost = _psAudit->pGlobalCombo;
    }
  } else
#line 766
  if (_psAudit->HostType == 2) {
#line 768
    if ((int )*(_psAudit->pGlobalHost) != 0) {
#line 770
      _pHost = _psAudit->pGlobalHost;
      {
#line 773
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 773
        if (! ((int )*(_psAudit->pGlobalHost) != 0)) {
#line 773
          goto while_break___4;
        }
#line 774
        (_psAudit->pGlobalHost) ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 775
      (_psAudit->pGlobalHost) ++;
#line 777
      if ((int )*(_psAudit->pGlobalHost) != 0) {
#line 779
        _psAudit->iHostListFlag = 0;
      } else {
#line 784
        _psAudit->pGlobalHost = _psAudit->pHostFile;
      }
    }
  } else
#line 788
  if (_psAudit->HostType == 1) {
#line 790
    _pHost = _psAudit->pGlobalHost;
#line 791
    _psAudit->iAuditFlag = 1;
  } else {
    {
#line 795
    writeError(0, "[findNextHost] HostType not properly defined.");
    }
  }
#line 798
  return (_pHost);
}
}
#line 807 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *findNextUser(sAudit *_psAudit , char *_pUser ) 
{ 
  char *pComboTmp ;

  {
#line 811
  _psAudit->iUserListFlag = 1;
#line 813
  if (_psAudit->UserType == 3) {
#line 816
    if (_psAudit->pGlobalCombo) {
#line 818
      pComboTmp = _psAudit->pComboEntryTmp;
      {
#line 819
      while (1) {
        while_continue: /* CIL Label */ ;
#line 819
        if (! ((int )*pComboTmp != 0)) {
#line 819
          goto while_break;
        }
#line 820
        pComboTmp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 821
      pComboTmp ++;
    }
#line 824
    if ((unsigned long )_pUser != (unsigned long )((void *)0)) {
#line 825
      _pUser = (char *)((void *)0);
    } else {
#line 827
      _pUser = pComboTmp;
    }
    {
#line 829
    writeError(7, "[findNextUser] Combo User: %s", _pUser);
    }
  } else
#line 831
  if (_psAudit->UserType == 4) {
#line 833
    if ((unsigned long )_pUser != (unsigned long )((void *)0)) {
#line 834
      _pUser = (char *)((void *)0);
    } else {
#line 836
      _pUser = _psAudit->pComboEntryTmp;
    }
    {
#line 838
    writeError(7, "[findNextUser] PwDump User: %s", _pUser);
    }
  } else
#line 840
  if (_psAudit->UserType == 2) {
#line 842
    _pUser = _psAudit->pGlobalUser;
#line 844
    if ((int )*(_psAudit->pGlobalUser) != 0) {
      {
#line 847
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 847
        if (! ((int )*(_psAudit->pGlobalUser) != 0)) {
#line 847
          goto while_break___0;
        }
#line 848
        (_psAudit->pGlobalUser) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 849
      (_psAudit->pGlobalUser) ++;
#line 851
      _psAudit->iUserListFlag = 0;
    } else {
#line 856
      _psAudit->pGlobalUser = _psAudit->pUserFile;
#line 857
      _pUser = (char *)((void *)0);
    }
    {
#line 860
    writeError(7, "[findNextUser] L_FILE User: %s", _pUser);
    }
  } else
#line 862
  if (_psAudit->UserType == 1) {
#line 864
    if ((unsigned long )_pUser != (unsigned long )((void *)0)) {
#line 865
      _pUser = (char *)((void *)0);
    } else {
#line 867
      _pUser = _psAudit->pGlobalUser;
    }
  } else {
    {
#line 871
    writeError(0, "[findNextUser] UserType (%d) not properly defined.", _psAudit->UserType);
    }
  }
#line 874
  return (_pUser);
}
}
#line 881 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *findLocalPass(sAudit *_psAudit ) 
{ 
  char *pPass ;
  char *pComboTmp ;

  {
#line 886
  if (_psAudit->PassType == 3) {
#line 886
    goto _L;
  } else
#line 886
  if (_psAudit->PassType == 4) {
    _L: /* CIL Label */ 
#line 889
    if (_psAudit->pGlobalCombo) {
#line 891
      pComboTmp = _psAudit->pComboEntryTmp;
      {
#line 893
      while (1) {
        while_continue: /* CIL Label */ ;
#line 893
        if (! ((int )*pComboTmp != 0)) {
#line 893
          goto while_break;
        }
#line 894
        pComboTmp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 895
      pComboTmp ++;
      {
#line 897
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 897
        if (! ((int )*pComboTmp != 0)) {
#line 897
          goto while_break___0;
        }
#line 898
        pComboTmp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 899
      pComboTmp ++;
    }
    {
#line 902
    pPass = pComboTmp;
#line 903
    writeError(7, "[findLocalPass] pPass: %s", pPass);
    }
  } else {
#line 907
    pPass = (char *)((void *)0);
  }
#line 910
  return (pPass);
}
}
#line 913 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int loadLoginInfo(sAudit *_psAudit ) 
{ 
  sHost *psHost ;
  sHost *psHostPrevTmp ;
  char *pHost ;
  sUser *psUser ;
  char *pUser ;
  sPass *psPass ;
  char *pPass ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;

  {
#line 917
  psHost = (sHost *)((void *)0);
#line 918
  psHostPrevTmp = (sHost *)((void *)0);
#line 919
  pHost = (char *)((void *)0);
#line 921
  psUser = (sUser *)((void *)0);
#line 922
  pUser = (char *)((void *)0);
#line 924
  psPass = (sPass *)((void *)0);
#line 925
  pPass = (char *)((void *)0);
#line 928
  _psAudit->iHostCnt = 0;
#line 929
  _psAudit->iHostsDone = 0;
  {
#line 931
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 931
    pHost = findNextHost(_psAudit, pHost);
    }
#line 931
    if (! pHost) {
#line 931
      goto while_break;
    }
#line 934
    psHost = _psAudit->psHostRoot;
    {
#line 935
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 935
      if (! psHost) {
#line 935
        goto while_break___0;
      }
      {
#line 937
      tmp = strcmp((char const   *)pHost, (char const   *)psHost->pHost);
      }
#line 937
      if (tmp) {
#line 938
        psHost = psHost->psHostNext;
      } else {
#line 940
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 944
    if ((unsigned long )psHost == (unsigned long )((void *)0)) {
      {
#line 946
      (_psAudit->iHostCnt) ++;
#line 947
      tmp___0 = malloc(sizeof(sHost ));
#line 947
      psHost = (sHost *)tmp___0;
#line 948
      memset((void *)psHost, 0, sizeof(sHost ));
      }
#line 951
      if ((unsigned long )_psAudit->psHostRoot == (unsigned long )((void *)0)) {
#line 953
        _psAudit->psHostRoot = psHost;
#line 954
        psHostPrevTmp = _psAudit->psHostRoot;
      } else {
#line 958
        psHostPrevTmp->psHostNext = psHost;
#line 959
        psHostPrevTmp = psHost;
      }
      {
#line 962
      tmp___1 = strlen((char const   *)pHost);
#line 962
      tmp___2 = malloc(tmp___1 + 1UL);
#line 962
      psHost->pHost = (char *)tmp___2;
#line 963
      tmp___3 = strlen((char const   *)pHost);
#line 963
      memset((void *)psHost->pHost, 0, tmp___3 + 1UL);
#line 964
      tmp___4 = strlen((char const   *)pHost);
#line 964
      strncpy((char */* __restrict  */)psHost->pHost, (char const   */* __restrict  */)pHost,
              tmp___4 + 1UL);
#line 965
      psHost->iPortOverride = _psAudit->iPortOverride;
#line 966
      psHost->iUseSSL = _psAudit->iUseSSL;
#line 967
      psHost->iTimeout = _psAudit->iTimeout;
#line 968
      psHost->iRetryWait = _psAudit->iRetryWait;
#line 969
      psHost->iRetries = _psAudit->iRetries;
#line 970
      psHost->iUserCnt = 0;
#line 971
      psHost->iId = _psAudit->iHostCnt;
      }
    }
    {
#line 974
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 974
      pUser = findNextUser(_psAudit, pUser);
      }
#line 974
      if (! pUser) {
#line 974
        goto while_break___1;
      }
#line 977
      psUser = psHost->psUser;
      {
#line 978
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 978
        if (! psUser) {
#line 978
          goto while_break___2;
        }
        {
#line 980
        tmp___5 = strcmp((char const   *)pUser, (char const   *)psUser->pUser);
        }
#line 980
        if (tmp___5) {
#line 981
          psUser = psUser->psUserNext;
        } else {
#line 983
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 987
      if ((unsigned long )psUser == (unsigned long )((void *)0)) {
        {
#line 989
        (psHost->iUserCnt) ++;
#line 990
        tmp___6 = malloc(sizeof(sUser ));
#line 990
        psUser = (sUser *)tmp___6;
#line 991
        memset((void *)psUser, 0, sizeof(sUser ));
        }
#line 993
        if (psHost->psUserPrevTmp) {
#line 996
          (psHost->psUserPrevTmp)->psUserNext = psUser;
        } else {
#line 1001
          psHost->psUser = psUser;
        }
        {
#line 1004
        psHost->psUserPrevTmp = psUser;
#line 1006
        tmp___7 = strlen((char const   *)pUser);
#line 1006
        tmp___8 = malloc(tmp___7 + 1UL);
#line 1006
        psUser->pUser = (char *)tmp___8;
#line 1007
        tmp___9 = strlen((char const   *)pUser);
#line 1007
        memset((void *)psUser->pUser, 0, tmp___9 + 1UL);
#line 1008
        tmp___10 = strlen((char const   *)pUser);
#line 1008
        strncpy((char */* __restrict  */)psUser->pUser, (char const   */* __restrict  */)pUser,
                tmp___10);
#line 1009
        psUser->iPassCnt = _psAudit->iPassCnt;
#line 1010
        psUser->iPassStatus = 0;
#line 1011
        psUser->iId = psHost->iUserCnt;
#line 1012
        psHost->iUserPassCnt += _psAudit->iPassCnt;
        }
#line 1014
        if (_psAudit->iPasswordUsernameFlag) {
#line 1015
          (psHost->iUserPassCnt) ++;
#line 1016
          (psUser->iPassCnt) ++;
        }
#line 1019
        if (_psAudit->iPasswordBlankFlag) {
#line 1020
          (psHost->iUserPassCnt) ++;
#line 1021
          (psUser->iPassCnt) ++;
        }
      }
      {
#line 1025
      pPass = findLocalPass(_psAudit);
      }
#line 1026
      if (pPass) {
        {
#line 1028
        tmp___11 = malloc(sizeof(sPass ));
#line 1028
        psPass = (sPass *)tmp___11;
#line 1029
        memset((void *)psPass, 0, sizeof(sPass ));
#line 1030
        tmp___12 = strlen((char const   *)pPass);
#line 1030
        tmp___13 = malloc(tmp___12 + 1UL);
#line 1030
        psPass->pPass = (char *)tmp___13;
#line 1031
        tmp___14 = strlen((char const   *)pPass);
#line 1031
        memset((void *)psPass->pPass, 0, tmp___14 + 1UL);
#line 1032
        tmp___15 = strlen((char const   *)pPass);
#line 1032
        strncpy((char */* __restrict  */)psPass->pPass, (char const   */* __restrict  */)pPass,
                tmp___15);
#line 1033
        (psUser->iPassCnt) ++;
#line 1034
        (psHost->iUserPassCnt) ++;
        }
#line 1036
        if (psUser->psPassPrevTmp) {
#line 1039
          (psUser->psPassPrevTmp)->psPassNext = psPass;
        } else {
#line 1044
          psUser->psPass = psPass;
#line 1045
          psUser->psPassCurrent = psPass;
        }
#line 1048
        psUser->psPassPrevTmp = psPass;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1053
  return (0);
}
}
#line 1060 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
char *getNextPass(sLogin *_psLogin ) 
{ 
  sAudit *_psAudit ;
  sUser *_psUser ;
  char *pPass ;

  {
#line 1062
  _psAudit = (_psLogin->psServer)->psAudit;
#line 1063
  _psUser = _psLogin->psUser;
#line 1064
  pPass = (char *)((void *)0);
#line 1067
  if (_psUser->iPassStatus != 5) {
#line 1067
    if (_psUser->iPassStatus != 6) {
#line 1070
      if (_psUser->iPassStatus == 0) {
#line 1071
        _psUser->iPassStatus = 1;
      }
#line 1074
      if (_psUser->iPassStatus == 1) {
#line 1074
        goto _L___0;
      } else
#line 1074
      if (_psUser->iPassStatus == 2) {
        _L___0: /* CIL Label */ 
#line 1076
        if (_psUser->iPassStatus == 1) {
#line 1076
          if (_psAudit->iPasswordBlankFlag) {
#line 1078
            pPass = (char *)"";
#line 1079
            _psUser->iPassStatus = 2;
          } else {
#line 1076
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1081
        if (_psAudit->iPasswordUsernameFlag) {
#line 1083
          pPass = _psUser->pUser;
#line 1084
          _psUser->iPassStatus = 3;
        } else {
#line 1088
          _psUser->iPassStatus = 3;
        }
      }
#line 1092
      if ((unsigned long )pPass == (unsigned long )((void *)0)) {
#line 1095
        if (_psUser->iPassStatus == 3) {
#line 1095
          if (_psUser->psPassCurrent) {
#line 1097
            pPass = (_psUser->psPassCurrent)->pPass;
#line 1098
            _psUser->psPassCurrent = (_psUser->psPassCurrent)->psPassNext;
          } else {
#line 1095
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1101
        if (_psAudit->pGlobalPass) {
#line 1103
          _psUser->iPassStatus = 4;
#line 1105
          if (_psUser->pPass) {
            {
#line 1107
            while (1) {
              while_continue: /* CIL Label */ ;
#line 1107
              if (! ((int )*(_psUser->pPass) != 0)) {
#line 1107
                goto while_break;
              }
#line 1108
              (_psUser->pPass) ++;
            }
            while_break: /* CIL Label */ ;
            }
#line 1109
            (_psUser->pPass) ++;
#line 1111
            if ((int )*(_psUser->pPass) != 0) {
#line 1113
              pPass = _psUser->pPass;
            } else {
#line 1118
              _psUser->iPassStatus = 5;
#line 1119
              (((_psLogin->psServer)->psHost)->iUsersDone) ++;
            }
          } else {
#line 1124
            _psUser->pPass = _psAudit->pGlobalPass;
#line 1125
            pPass = _psUser->pPass;
          }
        } else {
#line 1131
          _psUser->iPassStatus = 5;
#line 1132
          (((_psLogin->psServer)->psHost)->iUsersDone) ++;
        }
      }
    }
  }
#line 1137
  return (pPass);
}
}
#line 1145 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int getNextNormalCredSet(sLogin *_psLogin , sCredentialSet *_psCredSet ) 
{ 
  int nUserListChecked ;
  char *tmp ;

  {
#line 1147
  nUserListChecked = 0;
#line 1149
  _psCredSet->iStatus = 1;
#line 1152
  if ((unsigned long )_psLogin->psUser == (unsigned long )((void *)0)) {
    {
#line 1154
    writeError(7, "[getNextNormalCred] Initial credential set request for login module.");
#line 1156
    ((_psLogin->psServer)->psHost)->iUserStatus = 1;
#line 1157
    _psCredSet->iStatus = 2;
    }
#line 1160
    if (((_psLogin->psServer)->psAudit)->iParallelLoginFlag == 2) {
#line 1162
      if ((unsigned long )((_psLogin->psServer)->psHost)->psUserCurrent == (unsigned long )((void *)0)) {
#line 1163
        ((_psLogin->psServer)->psHost)->psUserCurrent = ((_psLogin->psServer)->psHost)->psUser;
      }
#line 1165
      _psLogin->psUser = ((_psLogin->psServer)->psHost)->psUserCurrent;
#line 1167
      if (_psLogin->psUser) {
        {
#line 1168
        writeError(7, "[getNextNormalCred] (PARALLEL_LOGINS_PASSWORD) setting user: %s",
                   (_psLogin->psUser)->pUser);
        }
      }
    } else {
#line 1174
      if ((unsigned long )((_psLogin->psServer)->psHost)->psUserCurrent == (unsigned long )((void *)0)) {
        {
#line 1176
        writeError(7, "[getNextNormalCred] Assigning initial user for host being tested.");
#line 1177
        ((_psLogin->psServer)->psHost)->psUserCurrent = ((_psLogin->psServer)->psHost)->psUser;
#line 1178
        _psLogin->psUser = ((_psLogin->psServer)->psHost)->psUserCurrent;
        }
      } else {
        {
#line 1183
        writeError(7, "[getNextNormalCred] Assigning next available user for host being tested.");
#line 1184
        _psLogin->psUser = (((_psLogin->psServer)->psHost)->psUserCurrent)->psUserNext;
#line 1185
        ((_psLogin->psServer)->psHost)->psUserCurrent = _psLogin->psUser;
        }
      }
#line 1188
      if (_psLogin->psUser) {
        {
#line 1189
        writeError(7, "[getNextNormalCred] (PARALLEL_LOGINS_USER) setting NEW user: %s",
                   (_psLogin->psUser)->pUser);
        }
      }
    }
  }
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (_psLogin->psUser) {
      {
#line 1194
      tmp = getNextPass(_psLogin);
#line 1194
      _psCredSet->pPass = tmp;
      }
#line 1194
      if (! ((unsigned long )tmp == (unsigned long )((void *)0))) {
#line 1194
        goto while_break;
      }
    } else {
#line 1194
      goto while_break;
    }
#line 1197
    if ((_psLogin->psUser)->iPassStatus == 5) {
#line 1197
      goto _L;
    } else
#line 1197
    if ((_psLogin->psUser)->iPassStatus == 6) {
      _L: /* CIL Label */ 
      {
#line 1199
      writeError(6, "Login Module: %d - Current user password list is complete, selecting next user.",
                 _psLogin->iId);
      }
#line 1201
      if ((unsigned long )((_psLogin->psServer)->psHost)->psUserCurrent == (unsigned long )((void *)0)) {
#line 1203
        _psLogin->psUser = (struct __sUser *)((void *)0);
      } else {
#line 1207
        _psLogin->psUser = (((_psLogin->psServer)->psHost)->psUserCurrent)->psUserNext;
#line 1208
        ((_psLogin->psServer)->psHost)->psUserCurrent = _psLogin->psUser;
      }
#line 1211
      if ((unsigned long )_psLogin->psUser == (unsigned long )((void *)0)) {
#line 1214
        if (nUserListChecked == 0) {
          {
#line 1216
          writeError(6, "Login Module: %d - Current user password list is complete, rescanning userlist for unfinished credentials.",
                     _psLogin->iId);
#line 1217
          _psLogin->psUser = ((_psLogin->psServer)->psHost)->psUser;
#line 1218
          ((_psLogin->psServer)->psHost)->psUserCurrent = _psLogin->psUser;
#line 1219
          nUserListChecked = 1;
          }
        } else {
          {
#line 1223
          writeError(6, "Login Module: %d - No more user accounts available for testing.",
                     _psLogin->iId);
#line 1224
          _psCredSet->iStatus = 3;
          }
        }
      } else {
        {
#line 1229
        writeError(6, "Login Module: %d - Selecting next password for user: %s", _psLogin->iId,
                   (_psLogin->psUser)->pUser);
#line 1230
        _psCredSet->iStatus = 2;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  if ((unsigned long )_psLogin->psUser == (unsigned long )((void *)0)) {
    {
#line 1238
    writeError(6, "Login Module: %d - No more users/passwords available in the normal queue.",
               _psLogin->iId);
#line 1240
    ((_psLogin->psServer)->psHost)->iUserStatus = 2;
    }
  } else
#line 1235
  if ((unsigned long )_psCredSet->pPass == (unsigned long )((void *)0)) {
    {
#line 1238
    writeError(6, "Login Module: %d - No more users/passwords available in the normal queue.",
               _psLogin->iId);
#line 1240
    ((_psLogin->psServer)->psHost)->iUserStatus = 2;
    }
  }
#line 1243
  _psCredSet->psUser = _psLogin->psUser;
#line 1245
  return (0);
}
}
#line 1260 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int getNextMissedCredSet(sLogin *_psLogin , sCredentialSet *_psCredSet ) 
{ 
  sCredentialSet *psCredSetMissed ;

  {
  {
#line 1262
  psCredSetMissed = (sCredentialSet *)((void *)0);
#line 1264
  writeError(7, "Retrieving the next available credential set from list of previously missed sets.");
#line 1267
  psCredSetMissed = (_psLogin->psServer)->psCredentialSetMissedCurrent;
  }
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (psCredSetMissed) {
#line 1268
      if (! ((psCredSetMissed->psUser)->iPassStatus == 6)) {
#line 1268
        goto while_break;
      }
    } else {
#line 1268
      goto while_break;
    }
#line 1270
    psCredSetMissed = ((_psLogin->psServer)->psCredentialSetMissedCurrent)->psCredentialSetNext;
#line 1271
    (_psLogin->psServer)->psCredentialSetMissedCurrent = psCredSetMissed;
  }
  while_break: /* CIL Label */ ;
  }
#line 1275
  if (psCredSetMissed) {
#line 1277
    _psCredSet->psUser = psCredSetMissed->psUser;
#line 1278
    _psCredSet->pPass = psCredSetMissed->pPass;
#line 1279
    (_psLogin->psServer)->psCredentialSetMissedCurrent = psCredSetMissed->psCredentialSetNext;
#line 1281
    if ((unsigned long )_psLogin->psUser == (unsigned long )_psCredSet->psUser) {
#line 1282
      _psCredSet->iStatus = 1;
    } else {
#line 1284
      _psCredSet->iStatus = 2;
    }
    {
#line 1286
    ((_psLogin->psServer)->iCredentialsMissed) --;
#line 1288
    writeError(7, "Login Module: %d - Selected next credential set from list of previously missed sets (%s/%s).",
               _psLogin->iId, (_psCredSet->psUser)->pUser, _psCredSet->pPass);
    }
  } else {
    {
#line 1292
    writeError(6, "Login Module: %d - No additional missed users/passwords, setting credential status to CREDENTIAL_DONE.",
               _psLogin->iId);
#line 1293
    _psCredSet->iStatus = 3;
#line 1294
    ((_psLogin->psServer)->psHost)->iUserStatus = 3;
    }
  }
#line 1297
  _psLogin->psUser = _psCredSet->psUser;
#line 1299
  return (0);
}
}
#line 1308 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int getNextCredSet(sLogin *_psLogin , sCredentialSet *_psCredSet ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1310
  if ((unsigned long )_psCredSet == (unsigned long )((void *)0)) {
    {
#line 1311
    writeError(0, "getNextCredSet() called, but not supplied allocated memory for _psCredSet");
    }
  }
  {
#line 1313
  memset((void *)_psCredSet, 0, sizeof(sCredentialSet ));
#line 1314
  pthread_mutex_lock(& (_psLogin->psServer)->ptmMutex);
  }
#line 1317
  if (((_psLogin->psServer)->psAudit)->iStatus == 1) {
    {
#line 1319
    writeError(6, "Audit aborting... notifying login module: %d", _psLogin->iId);
#line 1320
    _psCredSet->iStatus = 3;
    }
  } else
#line 1323
  if ((_psLogin->psServer)->iValidPairFound) {
#line 1323
    if (((_psLogin->psServer)->psAudit)->iFoundPairExitFlag == 1) {
      {
#line 1325
      writeError(6, "Exiting Login Module: %d [Stop Host Scan After Valid Pair Found Enabled]",
                 _psLogin->iId);
#line 1326
      _psCredSet->iStatus = 3;
      }
    } else {
#line 1323
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1329
  if (((_psLogin->psServer)->psAudit)->iValidPairFound) {
#line 1329
    if (((_psLogin->psServer)->psAudit)->iFoundPairExitFlag == 2) {
      {
#line 1331
      writeError(6, "Exiting Login Module: %d [Stop Audit Scans After Valid Pair Found Enabled]",
                 _psLogin->iId);
#line 1332
      _psCredSet->iStatus = 3;
      }
    } else {
#line 1329
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1339
    if (((_psLogin->psServer)->psHost)->iUserStatus == 1) {
#line 1339
      goto case_1;
    }
#line 1339
    if (((_psLogin->psServer)->psHost)->iUserStatus == 0) {
#line 1339
      goto case_1;
    }
#line 1350
    if (((_psLogin->psServer)->psHost)->iUserStatus == 2) {
#line 1350
      goto case_2;
    }
#line 1355
    if (((_psLogin->psServer)->psHost)->iUserStatus == 3) {
#line 1355
      goto case_3;
    }
#line 1359
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1341
    tmp = getNextNormalCredSet(_psLogin, _psCredSet);
    }
#line 1341
    if (tmp != 0) {
      {
#line 1342
      writeError(0, "getNextNormalCredSet() function call failed.");
      }
    }
#line 1345
    if (((_psLogin->psServer)->psHost)->iUserStatus == 2) {
      {
#line 1346
      tmp___0 = getNextMissedCredSet(_psLogin, _psCredSet);
      }
#line 1346
      if (tmp___0 != 0) {
        {
#line 1347
        writeError(0, "getNextMissedCredSet() function call failed.");
        }
      }
    }
#line 1349
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1352
    tmp___1 = getNextMissedCredSet(_psLogin, _psCredSet);
    }
#line 1352
    if (tmp___1 != 0) {
      {
#line 1353
      writeError(0, "getNextMissedCredSet() function call failed.");
      }
    }
#line 1354
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1356
    writeError(6, "Login Module: %d - No additional users/passwords, setting credential status to CREDENTIAL_DONE.",
               _psLogin->iId);
#line 1357
    _psCredSet->iStatus = 3;
    }
#line 1358
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1360
    writeError(7, "Login Module: %d - Entered undefined state (%d) within getNextCredSet()",
               _psLogin->iId, ((_psLogin->psServer)->psHost)->iUserStatus);
    }
#line 1361
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1365
  pthread_mutex_unlock(& (_psLogin->psServer)->ptmMutex);
  }
#line 1367
  return (0);
}
}
#line 1373 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int setPassResult(sLogin *_psLogin , char *_pPass ) 
{ 


  {
  {
#line 1375
  pthread_mutex_lock(& (_psLogin->psServer)->ptmMutex);
#line 1377
  writeVerbose(5, "[%s] Host: %s (%d of %d, %d complete) User: %s (%d of %d, %d complete) Password: %s (%d of %d complete)",
               ((_psLogin->psServer)->psAudit)->pModuleName, ((_psLogin->psServer)->psHost)->pHost,
               ((_psLogin->psServer)->psHost)->iId, ((_psLogin->psServer)->psAudit)->iHostCnt,
               ((_psLogin->psServer)->psAudit)->iHostsDone, (_psLogin->psUser)->pUser,
               (_psLogin->psUser)->iId, ((_psLogin->psServer)->psHost)->iUserCnt,
               ((_psLogin->psServer)->psHost)->iUsersDone, _pPass, (_psLogin->psUser)->iLoginsDone + 1,
               (_psLogin->psUser)->iPassCnt);
#line 1393
  (_psLogin->iLoginsDone) ++;
#line 1394
  ((_psLogin->psUser)->iLoginsDone) ++;
#line 1394
  ((_psLogin->psServer)->iLoginsDone) ++;
  }
  {
#line 1399
  if (_psLogin->iResult == 2) {
#line 1399
    goto case_2;
  }
#line 1413
  if (_psLogin->iResult == 3) {
#line 1413
    goto case_3;
  }
#line 1423
  if (_psLogin->iResult == 4) {
#line 1423
    goto case_4;
  }
#line 1435
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1400
  if (_psLogin->pErrorMsg) {
    {
#line 1401
    writeVerbose(4, "[%s] Host: %s User: %s Password: %s [SUCCESS (%s)]", ((_psLogin->psServer)->psAudit)->pModuleName,
                 ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser,
                 _pPass, _psLogin->pErrorMsg);
#line 1402
    free((void *)_psLogin->pErrorMsg);
#line 1403
    _psLogin->pErrorMsg = (char *)((void *)0);
    }
  } else {
    {
#line 1406
    writeVerbose(4, "[%s] Host: %s User: %s Password: %s [SUCCESS]", ((_psLogin->psServer)->psAudit)->pModuleName,
                 ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser,
                 _pPass);
    }
  }
#line 1408
  ((_psLogin->psServer)->psAudit)->iValidPairFound = 1;
#line 1409
  (_psLogin->psServer)->iValidPairFound = 1;
#line 1410
  (_psLogin->psUser)->iPassStatus = 6;
#line 1411
  (((_psLogin->psServer)->psHost)->iUsersDone) ++;
#line 1412
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1414
  if (_psLogin->pErrorMsg) {
    {
#line 1415
    writeError(6, "[%s] Host: %s User: %s [FAILED (%s)]", ((_psLogin->psServer)->psAudit)->pModuleName,
               ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser, _psLogin->pErrorMsg);
#line 1416
    free((void *)_psLogin->pErrorMsg);
#line 1417
    _psLogin->pErrorMsg = (char *)((void *)0);
    }
  } else {
    {
#line 1420
    writeError(6, "[%s] Host: %s User: %s [FAILED]", ((_psLogin->psServer)->psAudit)->pModuleName,
               ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser);
    }
  }
#line 1422
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1424
  if (_psLogin->pErrorMsg) {
    {
#line 1425
    writeVerbose(4, "[%s] Host: %s User: %s Password: %s [ERROR (%s)]", ((_psLogin->psServer)->psAudit)->pModuleName,
                 ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser,
                 _pPass, _psLogin->pErrorMsg);
#line 1426
    free((void *)_psLogin->pErrorMsg);
#line 1427
    _psLogin->pErrorMsg = (char *)((void *)0);
    }
  } else {
    {
#line 1430
    writeVerbose(4, "[%s] Host: %s User: %s Password: %s [ERROR]", ((_psLogin->psServer)->psAudit)->pModuleName,
                 ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser,
                 _pPass);
    }
  }
#line 1432
  (_psLogin->psUser)->iPassStatus = 6;
#line 1433
  (((_psLogin->psServer)->psHost)->iUsersDone) ++;
#line 1434
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1436
  writeError(6, "[%s] Host: %s User: %s [UNKNOWN %d]", ((_psLogin->psServer)->psAudit)->pModuleName,
             ((_psLogin->psServer)->psHost)->pHost, (_psLogin->psUser)->pUser, _psLogin->iResult);
  }
#line 1437
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1440
  pthread_mutex_unlock(& (_psLogin->psServer)->ptmMutex);
  }
#line 1441
  return (0);
}
}
#line 1454 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int addMissedCredSet(sLogin *_psLogin , sCredentialSet *_psCredSet ) 
{ 
  sCredentialSet *psCredSetMissed ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1456
  psCredSetMissed = (sCredentialSet *)((void *)0);
#line 1458
  pthread_mutex_lock(& (_psLogin->psServer)->ptmMutex);
#line 1460
  writeError(5, "[%s] Host: %s - Login thread (%d) prematurely ended. The current number of parallel login threads may exceed what this service can reasonably handle. The total number of threads for this host will be decreased.",
             ((_psLogin->psServer)->psAudit)->pModuleName, ((_psLogin->psServer)->psHost)->pHost,
             _psLogin->iId);
  }
#line 1466
  if ((_psLogin->psServer)->iLoginCnt > 1) {
#line 1467
    ((_psLogin->psServer)->iLoginCnt) --;
  }
  {
#line 1469
  writeError(5, "[%s] Host: %s User: %s Password: %s - The noted credentials have been added to the end of the queue for testing.",
             ((_psLogin->psServer)->psAudit)->pModuleName, ((_psLogin->psServer)->psHost)->pHost,
             (_psCredSet->psUser)->pUser, _psCredSet->pPass);
#line 1477
  tmp = malloc(sizeof(sCredentialSet ));
#line 1477
  psCredSetMissed = (sCredentialSet *)tmp;
#line 1478
  memset((void *)psCredSetMissed, 0, sizeof(sCredentialSet ));
#line 1480
  psCredSetMissed->psUser = _psCredSet->psUser;
#line 1482
  tmp___0 = strlen((char const   *)_psCredSet->pPass);
#line 1482
  tmp___1 = malloc(tmp___0 + 1UL);
#line 1482
  psCredSetMissed->pPass = (char *)tmp___1;
#line 1483
  tmp___2 = strlen((char const   *)_psCredSet->pPass);
#line 1483
  memset((void *)psCredSetMissed->pPass, 0, tmp___2 + 1UL);
#line 1484
  tmp___3 = strlen((char const   *)_psCredSet->pPass);
#line 1484
  strncpy((char */* __restrict  */)psCredSetMissed->pPass, (char const   */* __restrict  */)_psCredSet->pPass,
          tmp___3);
  }
#line 1487
  if ((unsigned long )(_psLogin->psServer)->psCredentialSetMissed == (unsigned long )((void *)0)) {
#line 1489
    (_psLogin->psServer)->psCredentialSetMissed = psCredSetMissed;
#line 1490
    (_psLogin->psServer)->psCredentialSetMissedCurrent = psCredSetMissed;
  } else {
#line 1493
    ((_psLogin->psServer)->psCredentialSetMissedTail)->psCredentialSetNext = psCredSetMissed;
  }
  {
#line 1495
  (_psLogin->psServer)->psCredentialSetMissedTail = psCredSetMissed;
#line 1497
  ((_psLogin->psServer)->iCredentialsMissed) ++;
#line 1499
  pthread_mutex_unlock(& (_psLogin->psServer)->ptmMutex);
  }
#line 1500
  return (0);
}
}
#line 1503 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
void *startModule(void *pParams ) 
{ 
  int64_t nRet ;
  sModuleStart *modParams ;
  int tmp ;

  {
#line 1505
  nRet = (int64_t )0;
#line 1506
  modParams = (sModuleStart *)pParams;
#line 1507
  if ((unsigned long )((void *)0) == (unsigned long )modParams) {
    {
#line 1509
    writeError(0, "Bad pointer passed to invokeModule");
#line 1510
    nRet = (int64_t )-1;
    }
#line 1511
    return ((void *)nRet);
  }
  {
#line 1514
  writeError(7, "startModule iId: %d pLogin: %X modParams->argv: %X modParams: %X",
             (modParams->pLogin)->iId, modParams->pLogin, modParams->argv, modParams);
#line 1516
  tmp = invokeModule(modParams->szModuleName, modParams->pLogin, modParams->argc,
                     modParams->argv);
#line 1516
  nRet = (int64_t )tmp;
  }
#line 1517
  if (nRet < 0L) {
    {
#line 1519
    writeVerbose(0, "invokeModule failed - see previous errors for an explanation");
#line 1520
    nRet = (int64_t )-1;
    }
#line 1521
    return ((void *)nRet);
  }
#line 1524
  return ((void *)nRet);
}
}
#line 1533 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
void *startLoginThreadPool(void *arg ) 
{ 
  sServer *_psServer ;
  thr_pool_t *login_pool ;
  sLogin *psLogin ;
  unsigned long __lengthofpsLogin ;
  void *tmp ;
  sModuleStart *modParams ;
  unsigned long __lengthofmodParams ;
  void *tmp___0 ;
  int iLoginId ;
  int iLoginCnt ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  int errcode ;
  void *ptr ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1535
  _psServer = (sServer *)arg;
#line 1536
  login_pool = (thr_pool_t *)((void *)0);
#line 1537
  __lengthofpsLogin = (unsigned long )(_psServer->psAudit)->iLoginCnt;
#line 1537
  tmp = __builtin_alloca(sizeof(*psLogin) * __lengthofpsLogin);
#line 1537
  psLogin = (sLogin *)tmp;
#line 1538
  __lengthofmodParams = (unsigned long )(_psServer->psAudit)->iLoginCnt;
#line 1538
  tmp___0 = __builtin_alloca(sizeof(*modParams) * __lengthofmodParams);
#line 1538
  modParams = (sModuleStart *)tmp___0;
#line 1539
  iLoginId = 0;
#line 1540
  iLoginCnt = (_psServer->psAudit)->iLoginCnt;
#line 1546
  writeError(9, "Server ID: %d Host: %s iUserPassCnt: %d iLoginCnt: %d", _psServer->iId,
             (_psServer->psHost)->pHost, (_psServer->psHost)->iUserPassCnt, iLoginCnt);
  }
#line 1549
  if (iLoginCnt > (_psServer->psHost)->iUserPassCnt) {
#line 1550
    iLoginCnt = (_psServer->psHost)->iUserPassCnt;
  }
  {
#line 1552
  login_pool = thr_pool_create((uint_t )0, (uint_t )iLoginCnt, (uint_t )1, (pthread_attr_t *)((void *)0));
  }
#line 1552
  if ((unsigned long )login_pool == (unsigned long )((void *)0)) {
    {
#line 1554
    writeError(0, "Failed to create root login thread pool for host: %s", (_psServer->psHost)->pHost);
    }
  }
  {
#line 1558
  tmp___1 = malloc((size_t )100);
#line 1558
  _psServer->pHostIP = (char *)tmp___1;
#line 1559
  memset((void *)_psServer->pHostIP, 0, (size_t )100);
#line 1561
  memset((void *)(& hints), 0, sizeof(hints));
#line 1562
  hints.ai_family = 0;
#line 1563
  hints.ai_socktype = 1;
#line 1564
  hints.ai_flags |= 2;
#line 1566
  errcode = getaddrinfo((char const   */* __restrict  */)(_psServer->psHost)->pHost,
                        (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                        (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1567
  if (errcode != 0) {
    {
#line 1569
    tmp___2 = gai_strerror(errcode);
#line 1569
    writeError(2, "Failed to resolve hostname: %s - %s", (_psServer->psHost)->pHost,
               tmp___2);
    }
#line 1570
    return;
  }
#line 1573
  if ((unsigned long )res->ai_next != (unsigned long )((void *)0)) {
    {
#line 1574
    writeError(3, "Hostname resolved to multiple addresses. Selecting first address for testing.");
    }
  }
  {
#line 1576
  inet_ntop(res->ai_family, (void const   */* __restrict  */)((res->ai_addr)->sa_data),
            (char */* __restrict  */)_psServer->pHostIP, (socklen_t )100);
  }
  {
#line 1580
  if (res->ai_family == 2) {
#line 1580
    goto case_2;
  }
#line 1583
  if (res->ai_family == 10) {
#line 1583
    goto case_10;
  }
#line 1578
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1581
  ptr = (void *)(& ((struct sockaddr_in *)res->ai_addr)->sin_addr);
#line 1582
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1584
  ptr = (void *)(& ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr);
#line 1585
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1588
  inet_ntop(res->ai_family, (void const   */* __restrict  */)ptr, (char */* __restrict  */)_psServer->pHostIP,
            (socklen_t )100);
  }
#line 1589
  if (res->ai_family == 10) {
#line 1589
    tmp___3 = 6;
  } else {
#line 1589
    tmp___3 = 4;
  }
  {
#line 1589
  writeError(9, "Set IPv%d address: %s (%s)", tmp___3, _psServer->pHostIP, res->ai_canonname);
#line 1590
  freeaddrinfo(res);
#line 1593
  iLoginId = 0;
  }
  {
#line 1593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1593
    if (! (iLoginId < iLoginCnt)) {
#line 1593
      goto while_break;
    }
    {
#line 1595
    writeError(9, "Adding new login task (%d) to server queue (%d)", iLoginId, _psServer->iId);
#line 1597
    (psLogin + iLoginId)->iId = iLoginId;
#line 1598
    (psLogin + iLoginId)->psServer = _psServer;
#line 1599
    (psLogin + iLoginId)->iResult = 1;
#line 1600
    (psLogin + iLoginId)->pErrorMsg = (char *)((void *)0);
#line 1601
    (psLogin + iLoginId)->iLoginsDone = 0;
#line 1602
    (psLogin + iLoginId)->psUser = (struct __sUser *)((void *)0);
#line 1604
    (modParams + iLoginId)->szModuleName = szModuleName;
#line 1605
    (modParams + iLoginId)->pLogin = psLogin + iLoginId;
#line 1606
    (modParams + iLoginId)->argc = nModuleParamCount;
#line 1607
    (modParams + iLoginId)->argv = arrModuleParams;
#line 1609
    tmp___4 = thr_pool_queue(login_pool, & startModule, (void *)(modParams + iLoginId));
    }
#line 1609
    if (tmp___4 < 0) {
      {
#line 1611
      writeError(2, "Failed to add module launch task to login thread pool for server queue: %d.",
                 _psServer->iId);
      }
#line 1612
      return;
    }
#line 1593
    iLoginId ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1617
  writeError(9, "waiting for server %d login pool to end", _psServer->iId);
#line 1618
  thr_pool_wait(login_pool);
#line 1635
  iLoginId = 0;
  }
#line 1636
  if ((_psServer->psAudit)->iStatus != 1) {
#line 1636
    if (_psServer->iCredentialsMissed > 0) {
      {
#line 1638
      writeError(9, "Adding new clean-up login task to server queue (%d) for %d missed logins",
                 _psServer->iId, _psServer->iCredentialsMissed);
#line 1640
      (_psServer->psHost)->iUserStatus = 2;
#line 1641
      (psLogin + iLoginId)->iResult = 1;
#line 1642
      (psLogin + iLoginId)->pErrorMsg = (char *)((void *)0);
#line 1643
      (psLogin + iLoginId)->psUser = (struct __sUser *)((void *)0);
#line 1645
      tmp___5 = thr_pool_queue(login_pool, & startModule, (void *)(modParams + iLoginId));
      }
#line 1645
      if (tmp___5 < 0) {
        {
#line 1647
        writeError(2, "Failed to add module launch task to login thread pool for server queue: %d.",
                   _psServer->iId);
        }
#line 1648
        return;
      }
      {
#line 1652
      writeError(9, "waiting for server %d login pool to end", _psServer->iId);
#line 1653
      thr_pool_wait(login_pool);
      }
    }
  }
  {
#line 1656
  writeError(9, "destroying server %d login pool", _psServer->iId);
#line 1657
  thr_pool_destroy(login_pool);
#line 1660
  pthread_mutex_lock(& (_psServer->psAudit)->ptmMutex);
#line 1661
  ((_psServer->psAudit)->iHostsDone) ++;
#line 1662
  pthread_mutex_unlock(& (_psServer->psAudit)->ptmMutex);
  }
#line 1668
  if ((_psServer->psAudit)->iStatus != 1) {
#line 1668
    if ((_psServer->psHost)->iUserStatus == 1) {
      {
#line 1670
      writeError(9, "Server thread exiting and server\'s userlist testing was marked as in progress. Was this host prematurely aborted?");
#line 1671
      (_psServer->psHost)->iUserStatus = 4;
      }
    } else
#line 1668
    if ((_psServer->psHost)->iUserStatus == 2) {
      {
#line 1670
      writeError(9, "Server thread exiting and server\'s userlist testing was marked as in progress. Was this host prematurely aborted?");
#line 1671
      (_psServer->psHost)->iUserStatus = 4;
      }
    }
  }
  {
#line 1674
  writeError(9, "exiting server: %d", _psServer->iId);
#line 1676
  free((void *)_psServer->pHostIP);
  }
#line 1678
  return;
}
}
#line 1687 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int startServerThreadPool(sAudit *_psAudit ) 
{ 
  sServer *psServer ;
  unsigned long __lengthofpsServer ;
  void *tmp ;
  sHost *psHost ;
  int iServerId ;
  sUser *psUser ;
  char *szResumeMap ;
  char *szUserMap ;
  int nAddHost ;
  int nUserMapSize ;
  int nFirstNewHostFound ;
  int nFirstNewUserFound ;
  char szTmp[11] ;
  char szTmp1[11] ;
  char szTmp2[11] ;
  thr_pool_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
  {
#line 1689
  __lengthofpsServer = (unsigned long )_psAudit->iHostCnt;
#line 1689
  tmp = __builtin_alloca(sizeof(*psServer) * __lengthofpsServer);
#line 1689
  psServer = (sServer *)tmp;
#line 1694
  szResumeMap = (char *)((void *)0);
#line 1695
  szUserMap = (char *)((void *)0);
#line 1704
  writeVerbose(6, "Parallel Hosts: %d Parallel Logins: %d", _psAudit->iServerCnt,
               _psAudit->iLoginCnt);
#line 1706
  writeVerbose(6, "Total Hosts: %d ", _psAudit->iHostCnt);
  }
#line 1707
  if (_psAudit->iUserCnt == 0) {
    {
#line 1707
    writeVerbose(6, "Total Users: [combo]");
    }
  } else {
    {
#line 1708
    writeVerbose(6, "Total Users: %d", _psAudit->iUserCnt);
    }
  }
#line 1709
  if (_psAudit->iPassCnt == 0) {
    {
#line 1709
    writeVerbose(6, "Total Passwords: [combo]");
    }
  } else {
    {
#line 1710
    writeVerbose(6, "Total Passwords: %d", _psAudit->iPassCnt);
    }
  }
#line 1713
  if (_psAudit->iServerCnt > _psAudit->iHostCnt) {
#line 1714
    _psAudit->iServerCnt = _psAudit->iHostCnt;
  }
  {
#line 1717
  init_crypto_locks();
#line 1719
  tmp___0 = thr_pool_create((uint_t )0, (uint_t )_psAudit->iServerCnt, (uint_t )1,
                            (pthread_attr_t *)((void *)0));
#line 1719
  _psAudit->server_pool = tmp___0;
  }
#line 1719
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 1721
    writeError(3, "Failed to create root server thread pool.");
    }
#line 1722
    return (-1);
  }
  {
#line 1726
  memset((void *)psServer, 0, sizeof(sServer ) * (unsigned long )_psAudit->iHostCnt);
#line 1727
  psHost = _psAudit->psHostRoot;
#line 1729
  nFirstNewHostFound = 0;
#line 1732
  iServerId = 0;
  }
  {
#line 1732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1732
    if (! (iServerId < _psAudit->iHostCnt)) {
#line 1732
      goto while_break;
    }
#line 1735
    nAddHost = 1;
#line 1736
    if (_psAudit->pOptResume) {
      {
#line 1738
      memset((void *)(szTmp), 0, (size_t )11);
#line 1739
      memset((void *)(szTmp1), 0, (size_t )11);
#line 1740
      snprintf((char */* __restrict  */)(szTmp), (size_t )10, (char const   */* __restrict  */)"h%d.",
               psHost->iId);
#line 1741
      snprintf((char */* __restrict  */)(szTmp1), (size_t )10, (char const   */* __restrict  */)"h%du",
               psHost->iId);
      }
#line 1743
      if (nFirstNewHostFound == 1) {
        {
#line 1745
        writeError(9, "[Host Resume] Adding host: %d (we\'ve passed the point of the previous run)",
                   psHost->iId);
        }
      } else {
        {
#line 1747
        szResumeMap = strstr((char const   *)_psAudit->pOptResume, (char const   *)(szTmp1));
        }
#line 1747
        if (szResumeMap) {
          {
#line 1749
          writeError(9, "[Host Resume] Adding host: %d (host was located in resume map)",
                     psHost->iId);
#line 1752
          tmp___5 = index((char const   *)(szResumeMap + 1), 104);
          }
#line 1752
          if (tmp___5) {
            {
#line 1753
            tmp___1 = index((char const   *)(szResumeMap + 1), 104);
#line 1753
            nUserMapSize = (int )(tmp___1 - szResumeMap);
            }
          } else {
            {
#line 1754
            tmp___4 = index((char const   *)(szResumeMap + 1), 46);
            }
#line 1754
            if (tmp___4) {
              {
#line 1755
              tmp___2 = index((char const   *)(szResumeMap + 1), 46);
#line 1755
              nUserMapSize = (int )(tmp___2 - szResumeMap);
              }
            } else {
              {
#line 1757
              tmp___3 = strlen((char const   *)szResumeMap);
#line 1757
              nUserMapSize = (int )tmp___3;
              }
            }
          }
#line 1759
          if (nUserMapSize < 4) {
            {
#line 1760
            writeError(0, "Error extacting user resume map for host: %d", psHost->iId);
            }
          }
          {
#line 1762
          tmp___6 = malloc((size_t )(nUserMapSize + 1));
#line 1762
          szUserMap = (char *)tmp___6;
#line 1763
          memset((void *)szUserMap, 0, (size_t )(nUserMapSize + 1));
#line 1764
          strncpy((char */* __restrict  */)szUserMap, (char const   */* __restrict  */)szResumeMap,
                  (size_t )nUserMapSize);
#line 1765
          writeError(9, "[Host Resume] Host: %d - Processing host\'s user resume map: %s",
                     psHost->iId, szUserMap);
#line 1768
          nFirstNewUserFound = 0;
#line 1769
          psUser = psHost->psUser;
          }
          {
#line 1770
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1770
            if (! psUser) {
#line 1770
              goto while_break___0;
            }
            {
#line 1772
            memset((void *)(szTmp), 0, (size_t )11);
#line 1773
            memset((void *)(szTmp1), 0, (size_t )11);
#line 1774
            snprintf((char */* __restrict  */)(szTmp), (size_t )10, (char const   */* __restrict  */)"u%du",
                     psUser->iId);
#line 1775
            snprintf((char */* __restrict  */)(szTmp1), (size_t )10, (char const   */* __restrict  */)"u%dh",
                     psUser->iId);
#line 1776
            snprintf((char */* __restrict  */)(szTmp2), (size_t )10, (char const   */* __restrict  */)"u%d.",
                     psUser->iId);
            }
#line 1778
            if (nFirstNewUserFound == 1) {
              {
#line 1780
              writeError(9, "[User Resume] Adding user: %d (we\'ve passed the point of the previous run)",
                         psUser->iId);
              }
            } else {
              {
#line 1782
              tmp___9 = strstr((char const   *)szResumeMap, (char const   *)(szTmp));
              }
#line 1782
              if (tmp___9) {
                {
#line 1784
                writeError(9, "[User Resume] Adding user: %d (user was located in resume map)",
                           psUser->iId);
                }
              } else {
                {
#line 1786
                tmp___7 = strstr((char const   *)szResumeMap, (char const   *)(szTmp1));
                }
#line 1786
                if (tmp___7) {
                  {
#line 1788
                  writeError(9, "[User Resume] Adding user: %d (user was located in resume map and identified as first untouched account)",
                             psUser->iId);
#line 1789
                  nFirstNewUserFound = 1;
                  }
                } else {
                  {
#line 1786
                  tmp___8 = strstr((char const   *)szResumeMap, (char const   *)(szTmp2));
                  }
#line 1786
                  if (tmp___8) {
                    {
#line 1788
                    writeError(9, "[User Resume] Adding user: %d (user was located in resume map and identified as first untouched account)",
                               psUser->iId);
#line 1789
                    nFirstNewUserFound = 1;
                    }
                  } else {
                    {
#line 1793
                    writeError(9, "[User Resume] Skipping user: %d (user has already been tested)",
                               psUser->iId);
#line 1794
                    psUser->iPassStatus = 5;
                    }
                  }
                }
              }
            }
#line 1797
            psUser = psUser->psUserNext;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 1800
          tmp___10 = strstr((char const   *)_psAudit->pOptResume, (char const   *)(szTmp));
          }
#line 1800
          if (tmp___10) {
            {
#line 1802
            writeError(9, "[Host Resume] Adding host: %d (host was located in resume map and identified as first untouched system)",
                       psHost->iId);
#line 1803
            nFirstNewHostFound = 1;
            }
          } else {
            {
#line 1807
            writeError(9, "[Host Resume] Skipping host: %d (host has already been tested)",
                       psHost->iId);
#line 1808
            nAddHost = 0;
#line 1809
            psHost->iUserStatus = 3;
            }
          }
        }
      }
    }
#line 1813
    if (nAddHost) {
      {
#line 1815
      writeError(8, "adding new server (%d) to queue", iServerId);
#line 1817
      tmp___13 = pthread_mutex_init(& (psServer + iServerId)->ptmMutex, (pthread_mutexattr_t const   *)((void *)0));
      }
#line 1817
      if (tmp___13 != 0) {
        {
#line 1818
        tmp___11 = __errno_location();
#line 1818
        tmp___12 = strerror(*tmp___11);
#line 1818
        writeError(0, "Server (%d) mutex initialization failed - %s\n", iServerId,
                   tmp___12);
        }
      }
      {
#line 1820
      (psServer + iServerId)->psAudit = _psAudit;
#line 1821
      (psServer + iServerId)->iId = iServerId;
#line 1822
      (psServer + iServerId)->psHost = psHost;
#line 1823
      (psServer + iServerId)->iLoginCnt = _psAudit->iLoginCnt;
#line 1824
      (psServer + iServerId)->iLoginsDone = 0;
#line 1825
      (psServer + iServerId)->iCredentialsMissed = 0;
#line 1828
      tmp___14 = thr_pool_queue(_psAudit->server_pool, & startLoginThreadPool, (void *)(psServer + iServerId));
      }
#line 1828
      if (tmp___14 < 0) {
        {
#line 1830
        writeError(3, "Failed to add host task to server thread pool.");
        }
#line 1831
        return (-1);
      }
    }
#line 1835
    psHost = psHost->psHostNext;
#line 1732
    iServerId ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1839
  writeError(8, "waiting for server pool to end");
#line 1840
  thr_pool_wait(_psAudit->server_pool);
#line 1841
  writeError(8, "destroying server pool");
#line 1842
  thr_pool_destroy(_psAudit->server_pool);
#line 1845
  iServerId = 0;
  }
  {
#line 1845
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1845
    if (! (iServerId < _psAudit->iHostCnt)) {
#line 1845
      goto while_break___1;
    }
    {
#line 1847
    tmp___17 = pthread_mutex_init(& (psServer + iServerId)->ptmMutex, (pthread_mutexattr_t const   *)((void *)0));
    }
#line 1847
    if (tmp___17 != 0) {
      {
#line 1848
      tmp___15 = __errno_location();
#line 1848
      tmp___16 = strerror(*tmp___15);
#line 1848
      writeError(0, "Server (%d) mutex destroy call failed - %s\n", iServerId, tmp___16);
      }
    }
#line 1845
    iServerId ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1851
  kill_crypto_locks();
  }
#line 1853
  return (0);
}
}
#line 1863 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
void sigint_handler(int sig ) 
{ 
  sHost *psHost ;
  sUser *psUser ;
  char szTmp[11] ;
  char *szResumeMap ;
  int nResumeMapSize ;
  int nItemByteSize ;
  struct sigaction sig_action ;
  double tmp ;
  double tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1868
  szResumeMap = (char *)((void *)0);
#line 1869
  nResumeMapSize = 0;
#line 1870
  nItemByteSize = 0;
#line 1877
  sig_action.sa_flags = 0;
#line 1878
  sigemptyset(& sig_action.sa_mask);
#line 1879
  sigaddset(& sig_action.sa_mask, 2);
#line 1880
  sig_action.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 1881
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sig_action), (struct sigaction */* __restrict  */)0);
#line 1882
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_action.sa_mask), (sigset_t */* __restrict  */)0);
#line 1885
  writeError(1, "Medusa received SIGINT - Sending notification to login threads that we are are aborting.");
#line 1886
  psAudit->iStatus = 1;
#line 1888
  writeError(6, "Waiting for login threads to terminate...");
#line 1889
  thr_pool_wait(psAudit->server_pool);
  }
#line 1909
  if (psAudit->iHostCnt > psAudit->iUserCnt) {
    {
#line 1910
    tmp = log10((double )psAudit->iHostCnt);
#line 1910
    nItemByteSize = (1 + (int )tmp) + 1;
    }
  } else {
    {
#line 1912
    tmp___0 = log10((double )psAudit->iUserCnt);
#line 1912
    nItemByteSize = (1 + (int )tmp___0) + 1;
    }
  }
  {
#line 1914
  nResumeMapSize = nItemByteSize * ((psAudit->iServerCnt * psAudit->iLoginCnt + psAudit->iServerCnt) + 1) + 1;
#line 1915
  tmp___1 = malloc((size_t )(nResumeMapSize + 1));
#line 1915
  szResumeMap = (char *)tmp___1;
#line 1916
  memset((void *)szResumeMap, 0, (size_t )(nResumeMapSize + 1));
#line 1917
  memset((void *)(szTmp), 0, (size_t )11);
#line 1919
  psHost = psAudit->psHostRoot;
  }
  {
#line 1920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1920
    if (psHost) {
#line 1920
      if (! (psHost->iUserStatus != 0)) {
#line 1920
        goto while_break;
      }
    } else {
#line 1920
      goto while_break;
    }
#line 1923
    if (psHost->iUserStatus != 3) {
#line 1923
      if (psHost->iUserStatus != 4) {
        {
#line 1925
        writeError(7, "Incomplete Host: %d", psHost->iId);
#line 1926
        memset((void *)(szTmp), 0, (size_t )11);
#line 1927
        snprintf((char */* __restrict  */)(szTmp), (size_t )10, (char const   */* __restrict  */)"h%d",
                 psHost->iId);
#line 1928
        strncat((char */* __restrict  */)szResumeMap, (char const   */* __restrict  */)(szTmp),
                (size_t )10);
#line 1931
        psUser = psHost->psUser;
        }
        {
#line 1932
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1932
          if (psUser) {
#line 1932
            if (! (psUser->iPassStatus != 0)) {
#line 1932
              goto while_break___0;
            }
          } else {
#line 1932
            goto while_break___0;
          }
#line 1934
          if (psUser->iPassStatus == 5) {
            {
#line 1935
            writeError(7, "Complete User: %d", psUser->iId);
            }
          } else
#line 1934
          if (psUser->iPassStatus == 6) {
            {
#line 1935
            writeError(7, "Complete User: %d", psUser->iId);
            }
          } else {
            {
#line 1938
            writeError(7, "Incomplete User: %d", psUser->iId);
#line 1939
            memset((void *)(szTmp), 0, (size_t )11);
#line 1940
            snprintf((char */* __restrict  */)(szTmp), (size_t )10, (char const   */* __restrict  */)"u%d",
                     psUser->iId);
#line 1941
            strncat((char */* __restrict  */)szResumeMap, (char const   */* __restrict  */)(szTmp),
                    (size_t )10);
            }
          }
#line 1944
          psUser = psUser->psUserNext;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1948
        if (psUser) {
#line 1948
          if (psUser->iPassStatus == 0) {
            {
#line 1950
            writeError(7, "First New User: %d", psUser->iId);
#line 1951
            memset((void *)(szTmp), 0, (size_t )11);
#line 1952
            snprintf((char */* __restrict  */)(szTmp), (size_t )10, (char const   */* __restrict  */)"u%d",
                     psUser->iId);
#line 1953
            strncat((char */* __restrict  */)szResumeMap, (char const   */* __restrict  */)(szTmp),
                    (size_t )10);
            }
          }
        }
      } else {
        {
#line 1958
        writeError(7, "Complete Host: %d", psHost->iId);
        }
      }
    } else {
      {
#line 1958
      writeError(7, "Complete Host: %d", psHost->iId);
      }
    }
#line 1961
    psHost = psHost->psHostNext;
  }
  while_break: /* CIL Label */ ;
  }
#line 1965
  if (psHost) {
#line 1965
    if (psHost->iUserStatus == 0) {
      {
#line 1967
      writeError(7, "First New Host: %d", psHost->iId);
#line 1968
      memset((void *)(szTmp), 0, (size_t )11);
#line 1969
      snprintf((char */* __restrict  */)(szTmp), (size_t )8, (char const   */* __restrict  */)"h%d",
               psHost->iId);
#line 1970
      strncat((char */* __restrict  */)szResumeMap, (char const   */* __restrict  */)(szTmp),
              (size_t )8);
      }
    }
  }
  {
#line 1974
  strncat((char */* __restrict  */)szResumeMap, (char const   */* __restrict  */)".",
          (size_t )1);
#line 1976
  writeError(1, "To resume scan, add the following to your original command: \"-Z %s\"",
             szResumeMap);
#line 1978
  free((void *)szResumeMap);
#line 1980
  exit(0);
  }
}
}
#line 1983 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa.c"
int main(int argc , char **argv , char **envp ) 
{ 
  struct sigaction sig_action ;
  int iExitStatus ;
  int i ;
  struct tm *tm_ptr ;
  time_t the_time ;
  char time_buf[256] ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1994
  sig_action.sa_flags = 0;
#line 1995
  sigemptyset(& sig_action.sa_mask);
#line 1996
  sigaddset(& sig_action.sa_mask, 2);
#line 1997
  sig_action.__sigaction_handler.sa_handler = & sigint_handler;
#line 1998
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sig_action), (struct sigaction */* __restrict  */)0);
#line 2004
  szModuleName = (char *)((void *)0);
#line 2005
  szModulePaths[0] = getenv("MEDUSA_MODULE_PATH");
#line 2006
  szModulePaths[1] = (char *)".";
#line 2008
  szModulePaths[2] = (char *)"/usr/local/lib/medusa/modules";
#line 2013
  szTempModuleParam = (char *)((void *)0);
#line 2014
  tmp = malloc(sizeof(char *));
#line 2014
  arrModuleParams = (char **)tmp;
#line 2015
  memset((void *)arrModuleParams, 0, sizeof(char *));
#line 2016
  nModuleParamCount = 0;
#line 2019
  tmp___0 = malloc(sizeof(sAudit ));
#line 2019
  psAudit = (sAudit *)tmp___0;
#line 2020
  memset((void *)psAudit, 0, sizeof(sAudit ));
#line 2022
  tmp___3 = pthread_mutex_init(& psAudit->ptmMutex, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 2022
  if (tmp___3 != 0) {
    {
#line 2023
    tmp___1 = __errno_location();
#line 2023
    tmp___2 = strerror(*tmp___1);
#line 2023
    writeError(0, "Audit mutex initialization failed - %s\n", tmp___2);
    }
  }
  {
#line 2026
  tmp___4 = checkOptions(argc, argv, psAudit);
  }
#line 2026
  if (tmp___4) {
    {
#line 2028
    usage();
#line 2029
    exit(1);
    }
  }
#line 2032
  i = 0;
  {
#line 2032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2032
    if (! (i < nModuleParamCount)) {
#line 2032
      goto while_break;
    }
    {
#line 2034
    writeVerbose(6, "Module parameter: %s", *(arrModuleParams + i));
#line 2032
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2037
  if ((unsigned long )szModuleName == (unsigned long )((void *)0)) {
    {
#line 2039
    writeVerbose(0, "You must specify a module to execute using -M MODULE_NAME");
#line 2040
    freeModuleParams();
#line 2041
    exit(1);
    }
  }
#line 2044
  if (psAudit->HostType == 2) {
    {
#line 2046
    loadFile(psAudit->pOptHost, & psAudit->pHostFile, & psAudit->iHostCnt);
#line 2047
    psAudit->pGlobalHost = psAudit->pHostFile;
    }
  }
#line 2050
  if (psAudit->UserType == 2) {
    {
#line 2052
    loadFile(psAudit->pOptUser, & psAudit->pUserFile, & psAudit->iUserCnt);
#line 2053
    psAudit->pGlobalUser = psAudit->pUserFile;
    }
  }
#line 2056
  if (psAudit->PassType == 2) {
    {
#line 2058
    loadFile(psAudit->pOptPass, & psAudit->pPassFile, & psAudit->iPassCnt);
#line 2059
    psAudit->pGlobalPass = psAudit->pPassFile;
    }
  }
#line 2062
  if ((unsigned long )psAudit->pOptCombo != (unsigned long )((void *)0)) {
    {
#line 2064
    loadFile(psAudit->pOptCombo, & psAudit->pComboFile, & psAudit->iComboCnt);
#line 2065
    psAudit->pGlobalCombo = psAudit->pComboFile;
#line 2066
    tmp___5 = processComboFile(& psAudit);
    }
#line 2066
    if (tmp___5) {
      {
#line 2068
      exit(iExitStatus);
      }
    }
  }
  {
#line 2072
  tmp___6 = loadLoginInfo(psAudit);
  }
#line 2072
  if (tmp___6 == 0) {
    {
#line 2073
    writeError(7, "Successfully loaded login information.");
    }
  } else {
    {
#line 2075
    writeError(0, "Failed to load login information.");
    }
  }
#line 2077
  if ((unsigned long )psAudit->pOptCombo != (unsigned long )((void *)0)) {
    {
#line 2077
    free((void *)psAudit->pComboFile);
    }
  }
#line 2078
  if ((unsigned long )psAudit->pHostFile != (unsigned long )((void *)0)) {
    {
#line 2078
    free((void *)psAudit->pHostFile);
    }
  }
#line 2079
  if ((unsigned long )psAudit->pUserFile != (unsigned long )((void *)0)) {
    {
#line 2079
    free((void *)psAudit->pUserFile);
    }
  }
#line 2081
  if ((unsigned long )psAudit->pOptOutput != (unsigned long )((void *)0)) {
    {
#line 2083
    pOutputFile = fopen((char const   */* __restrict  */)psAudit->pOptOutput, (char const   */* __restrict  */)"a+");
    }
#line 2083
    if ((unsigned long )pOutputFile == (unsigned long )((void *)0)) {
      {
#line 2085
      tmp___7 = __errno_location();
#line 2085
      tmp___8 = strerror(*tmp___7);
#line 2085
      writeError(0, "Failed to open output file %s - %s", psAudit->pOptOutput, tmp___8);
      }
    } else {
      {
#line 2089
      tmp___11 = pthread_mutex_init(& ptmFileMutex, (pthread_mutexattr_t const   *)((void *)0));
      }
#line 2089
      if (tmp___11 != 0) {
        {
#line 2090
        tmp___9 = __errno_location();
#line 2090
        tmp___10 = strerror(*tmp___9);
#line 2090
        writeError(0, "File mutex initialization failed - %s\n", tmp___10);
        }
      }
      {
#line 2093
      time(& the_time);
#line 2094
      tm_ptr = localtime((time_t const   *)(& the_time));
#line 2095
      strftime((char */* __restrict  */)(time_buf), (size_t )256, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
               (struct tm  const  */* __restrict  */)tm_ptr);
#line 2096
      writeVerbose(2, "# Medusa v.%s (%s)\n", "2.1.1", time_buf);
#line 2097
      writeVerbose(2, "# ");
#line 2099
      i = 0;
      }
      {
#line 2099
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2099
        if (! (i < argc)) {
#line 2099
          goto while_break___0;
        }
        {
#line 2101
        writeVerbose(2, "%s ", *(argv + i));
#line 2099
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2103
      writeVerbose(2, "\n");
      }
    }
  }
  {
#line 2108
  tmp___12 = startServerThreadPool(psAudit);
  }
#line 2108
  if (tmp___12 == 0) {
    {
#line 2111
    time(& the_time);
#line 2112
    tm_ptr = localtime((time_t const   *)(& the_time));
#line 2113
    strftime((char */* __restrict  */)(time_buf), (size_t )256, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
             (struct tm  const  */* __restrict  */)tm_ptr);
#line 2115
    writeVerbose(2, "# Medusa has finished (%s).\n", time_buf);
#line 2116
    writeVerbose(6, "Medusa has finished.");
#line 2117
    iExitStatus = 0;
    }
  } else {
    {
#line 2122
    time(& the_time);
#line 2123
    tm_ptr = localtime((time_t const   *)(& the_time));
#line 2124
    strftime((char */* __restrict  */)(time_buf), (size_t )256, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
             (struct tm  const  */* __restrict  */)tm_ptr);
#line 2126
    writeVerbose(2, "# Medusa failed (%s).\n", time_buf);
#line 2127
    writeError(2, "Medusa failed.");
#line 2128
    iExitStatus = 1;
    }
  }
#line 2132
  if ((unsigned long )psAudit->pOptOutput != (unsigned long )((void *)0)) {
    {
#line 2132
    tmp___15 = pthread_mutex_destroy(& ptmFileMutex);
    }
#line 2132
    if (tmp___15 != 0) {
      {
#line 2133
      tmp___13 = __errno_location();
#line 2133
      tmp___14 = strerror(*tmp___13);
#line 2133
      writeError(0, "File mutex destroy call failed - %s\n", tmp___14);
      }
    }
  }
  {
#line 2135
  tmp___18 = pthread_mutex_destroy(& psAudit->ptmMutex);
  }
#line 2135
  if (tmp___18 != 0) {
    {
#line 2136
    tmp___16 = __errno_location();
#line 2136
    tmp___17 = strerror(*tmp___16);
#line 2136
    writeError(0, "Audit mutex destroy call failed - %s\n", tmp___17);
    }
  }
  {
#line 2138
  free((void *)psAudit->pPassFile);
#line 2139
  free((void *)psAudit);
  }
#line 2141
  if ((unsigned long )szModuleName != (unsigned long )((void *)0)) {
    {
#line 2142
    free((void *)szModuleName);
    }
  }
  {
#line 2144
  freeModuleParams();
#line 2146
  exit(iExitStatus);
  }
}
}
#line 29 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.h"
int base64_encode(char const   *str , int length , char *b64store ) ;
#line 30
int base64_decode(char const   *base64 , char *to ) ;
#line 31
char *basic_authentication_encode(char const   *user , char const   *passwd ) ;
#line 40 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.c"
static char tbl[64]  = 
#line 40 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.c"
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/'};
#line 37 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.c"
int base64_encode(char const   *str , int length , char *b64store ) 
{ 
  int i ;
  unsigned char const   *s ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char tmp___3 ;

  {
#line 51
  s = (unsigned char const   *)str;
#line 52
  p = b64store;
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < length)) {
#line 55
      goto while_break;
    }
#line 57
    tmp = p;
#line 57
    p ++;
#line 57
    *tmp = tbl[(int const   )*(s + 0) >> 2];
#line 58
    tmp___0 = p;
#line 58
    p ++;
#line 58
    *tmp___0 = tbl[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 59
    tmp___1 = p;
#line 59
    p ++;
#line 59
    *tmp___1 = tbl[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 60
    tmp___2 = p;
#line 60
    p ++;
#line 60
    *tmp___2 = tbl[(int const   )*(s + 2) & 63];
#line 61
    s += 3;
#line 55
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (i == length + 1) {
#line 66
    *(p - 1) = (char )'=';
  } else
#line 67
  if (i == length + 2) {
#line 68
    tmp___3 = (char )'=';
#line 68
    *(p - 2) = tmp___3;
#line 68
    *(p - 1) = tmp___3;
  }
#line 71
  *p = (char )'\000';
#line 73
  return ((int )(p - b64store));
}
}
#line 100 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.c"
static short base64_char_to_value[128]  = 
#line 100
  {      (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)62, 
        (short)-1,      (short)-1,      (short)-1,      (short)63, 
        (short)52,      (short)53,      (short)54,      (short)55, 
        (short)56,      (short)57,      (short)58,      (short)59, 
        (short)60,      (short)61,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)0,      (short)1,      (short)2, 
        (short)3,      (short)4,      (short)5,      (short)6, 
        (short)7,      (short)8,      (short)9,      (short)10, 
        (short)11,      (short)12,      (short)13,      (short)14, 
        (short)15,      (short)16,      (short)17,      (short)18, 
        (short)19,      (short)20,      (short)21,      (short)22, 
        (short)23,      (short)24,      (short)25,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)26,      (short)27,      (short)28, 
        (short)29,      (short)30,      (short)31,      (short)32, 
        (short)33,      (short)34,      (short)35,      (short)36, 
        (short)37,      (short)38,      (short)39,      (short)40, 
        (short)41,      (short)42,      (short)43,      (short)44, 
        (short)45,      (short)46,      (short)47,      (short)48, 
        (short)49,      (short)50,      (short)51,      (short)-1, 
        (short)-1,      (short)-1,      (short)-1,      (short)-1};
#line 95 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.c"
int base64_decode(char const   *base64 , char *to ) 
{ 
  char const   *p ;
  char *q ;
  unsigned char c ;
  unsigned long value ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
#line 117
  p = base64;
#line 118
  q = to;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 126
      tmp = p;
#line 126
      p ++;
#line 126
      c = (unsigned char )*tmp;
#line 126
      if ((int )c != 0) {
#line 126
        if (((int )c & 128) == 0) {
#line 126
          if ((int )base64_char_to_value[c] >= 0) {
#line 126
            goto while_break___0;
          } else {
#line 126
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 126
        if ((int )c == 61) {
#line 126
          goto while_break___0;
        }
      } else {
#line 126
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    if (! c) {
#line 128
      goto while_break;
    }
#line 129
    if ((int )c == 61) {
#line 130
      return (-1);
    }
#line 131
    value = (unsigned long )((int )base64_char_to_value[c] << 18);
    {
#line 134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 134
      tmp___0 = p;
#line 134
      p ++;
#line 134
      c = (unsigned char )*tmp___0;
#line 134
      if ((int )c != 0) {
#line 134
        if (((int )c & 128) == 0) {
#line 134
          if ((int )base64_char_to_value[c] >= 0) {
#line 134
            goto while_break___1;
          } else {
#line 134
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 134
        if ((int )c == 61) {
#line 134
          goto while_break___1;
        }
      } else {
#line 134
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    if (! c) {
#line 136
      return (-1);
    }
#line 137
    if ((int )c == 61) {
#line 138
      return (-1);
    }
#line 139
    value |= (unsigned long )((int )base64_char_to_value[c] << 12);
#line 140
    tmp___1 = q;
#line 140
    q ++;
#line 140
    *tmp___1 = (char )(value >> 16);
    {
#line 143
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 143
      tmp___2 = p;
#line 143
      p ++;
#line 143
      c = (unsigned char )*tmp___2;
#line 143
      if ((int )c != 0) {
#line 143
        if (((int )c & 128) == 0) {
#line 143
          if ((int )base64_char_to_value[c] >= 0) {
#line 143
            goto while_break___2;
          } else {
#line 143
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 143
        if ((int )c == 61) {
#line 143
          goto while_break___2;
        }
      } else {
#line 143
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 144
    if (! c) {
#line 145
      return (-1);
    }
#line 147
    if ((int )c == 61) {
      {
#line 149
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 149
        tmp___3 = p;
#line 149
        p ++;
#line 149
        c = (unsigned char )*tmp___3;
#line 149
        if ((int )c != 0) {
#line 149
          if (((int )c & 128) == 0) {
#line 149
            if ((int )base64_char_to_value[c] >= 0) {
#line 149
              goto while_break___3;
            } else {
#line 149
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 149
          if ((int )c == 61) {
#line 149
            goto while_break___3;
          }
        } else {
#line 149
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 150
      if (! c) {
#line 151
        return (-1);
      }
#line 152
      if ((int )c != 61) {
#line 153
        return (-1);
      }
#line 154
      goto while_continue;
    }
#line 157
    value |= (unsigned long )((int )base64_char_to_value[c] << 6);
#line 158
    tmp___4 = q;
#line 158
    q ++;
#line 158
    *tmp___4 = (char )(255UL & (value >> 8));
    {
#line 161
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 161
      tmp___5 = p;
#line 161
      p ++;
#line 161
      c = (unsigned char )*tmp___5;
#line 161
      if ((int )c != 0) {
#line 161
        if (((int )c & 128) == 0) {
#line 161
          if ((int )base64_char_to_value[c] >= 0) {
#line 161
            goto while_break___4;
          } else {
#line 161
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 161
        if ((int )c == 61) {
#line 161
          goto while_break___4;
        }
      } else {
#line 161
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 162
    if (! c) {
#line 163
      return (-1);
    }
#line 164
    if ((int )c == 61) {
#line 165
      goto while_continue;
    }
#line 167
    value |= (unsigned long )base64_char_to_value[c];
#line 168
    tmp___6 = q;
#line 168
    q ++;
#line 168
    *tmp___6 = (char )(255UL & value);
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return ((int )(q - to));
}
}
#line 177 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-utils.c"
char *basic_authentication_encode(char const   *user , char const   *passwd ) 
{ 
  char *t1 ;
  char *t2 ;
  int len1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 180
  tmp = strlen(user);
#line 180
  tmp___0 = strlen(passwd);
#line 180
  len1 = (int )((tmp + 1UL) + tmp___0);
#line 182
  tmp___1 = __builtin_alloca((unsigned long )(len1 + 1));
#line 182
  t1 = (char *)tmp___1;
#line 183
  sprintf((char */* __restrict  */)t1, (char const   */* __restrict  */)"%s:%s", user,
          passwd);
#line 185
  tmp___2 = malloc((size_t )(4 * ((len1 + 2) / 3) + 1));
#line 185
  t2 = (char *)tmp___2;
#line 186
  base64_encode((char const   *)t1, len1, t2);
  }
#line 188
  return (t2);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 70 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.h"
int medusaConnect(sConnectParams *pParams ) ;
#line 71
int medusaConnectSSL(sConnectParams *pParams ) ;
#line 72
int medusaConnectSocketSSL(sConnectParams *pParams , int hSocket ) ;
#line 73
int medusaConnectTCP(sConnectParams *pParams ) ;
#line 74
int medusaConnectUDP(sConnectParams *pParams ) ;
#line 75
int medusaDisconnect(int hSocket ) ;
#line 76
int medusaDataReadyWritingTimed(int socket___0 , time_t sec , time_t usec ) ;
#line 77
int medusaDataReadyWriting(int socket___0 ) ;
#line 78
int medusaDataReadyTimed(int socket___0 , time_t sec , time_t usec ) ;
#line 79
int medusaDataReady(int socket___0 ) ;
#line 80
int medusaReceive(int socket___0 , char *buf___8 , int length ) ;
#line 81
char *medusaReceiveRaw(int socket___0 , int *nBufferSize ) ;
#line 82
char *medusaReceiveRawDelay(int socket___0 , int *nBufferSize , int nReceiveDelay1 ,
                            int nReceiveDelay2 ) ;
#line 83
char *medusaReceiveLine(int socket___0 , int *nBufferSize ) ;
#line 84
char *medusaReceiveLineDelay(int socket___0 , int *nBufferSize , int nReceiveDelay1 ,
                             int nReceiveDelay2 ) ;
#line 85
int medusaReceiveRegex(int hSocket , unsigned char **szBufReceive , int *nBufReceive ,
                       char const   *regex ) ;
#line 86
int medusaSend(int socket___0 , char *buf___8 , int size , int options ) ;
#line 87
int makeToLower(char *buf___8 ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 84 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
void initConnectionParams(sLogin *pLogin , sConnectParams *pParams ) 
{ 
  in_addr_t tmp ;

  {
  {
#line 86
  tmp = inet_addr((char const   *)(pLogin->psServer)->pHostIP);
#line 86
  pParams->nHost = (long )tmp;
  }
#line 87
  if (((pLogin->psServer)->psHost)->iPortOverride != 0) {
#line 90
    pParams->nPort = ((pLogin->psServer)->psHost)->iPortOverride;
  }
#line 92
  pParams->nUseSSL = ((pLogin->psServer)->psHost)->iUseSSL;
#line 93
  pParams->nTimeout = ((pLogin->psServer)->psHost)->iTimeout;
#line 94
  pParams->nRetryWait = ((pLogin->psServer)->psHost)->iRetryWait;
#line 95
  pParams->nRetries = ((pLogin->psServer)->psHost)->iRetries;
#line 96
  if (pParams->nProtocol == 0) {
#line 97
    pParams->nProtocol = 1;
  }
#line 98
  if (pParams->nType == 0) {
#line 99
    pParams->nType = 6;
  }
#line 100
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaConnectInternal(unsigned long nHost , int nPort , int nProtocol , int nType ,
                          int nWaitTime , int nRetries , int nRetryWait , unsigned long nProxyStringIP ,
                          int nProxyStringPort , char *szProxyAuthentication , int nSourcePort ) 
{ 
  int s ;
  int ret ;
  int nFail ;
  struct sockaddr_in target ;
  struct sockaddr_in source ;
  char *buf___8 ;
  char *tmpptr ;
  char out[16] ;
  long flag ;
  int nOpt ;
  int nSize ;
  fd_set myset ;
  struct timeval tv ;
  int nUseProxy ;
  int tmp ;
  int bind_ok ;
  int *tmp___0 ;
  __uid_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  pthread_t tmp___11 ;
  int __d0 ;
  int __d1 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;

  {
#line 104
  ret = -1;
#line 105
  nFail = 0;
#line 107
  tmpptr = (char *)((void *)0);
#line 113
  if (nProxyStringIP > 0UL) {
#line 113
    tmp = 1;
  } else {
#line 113
    tmp = 0;
  }
  {
#line 113
  nUseProxy = tmp;
#line 115
  s = socket(2, nProtocol, nType);
  }
#line 116
  if (s >= 0) {
#line 119
    if (nSourcePort != 0) {
      {
#line 120
      bind_ok = 0;
#line 122
      source.sin_family = (sa_family_t )2;
#line 123
      source.sin_port = htons((uint16_t )nSourcePort);
#line 124
      source.sin_addr.s_addr = (in_addr_t )0;
      }
      {
#line 127
      while (1) {
        while_continue: /* CIL Label */ ;
#line 127
        if (! bind_ok) {
#line 127
          if (! (nSourcePort >= 512)) {
#line 127
            goto while_break;
          }
        } else {
#line 127
          goto while_break;
        }
        {
#line 129
        tmp___3 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& source)),
                       (socklen_t )sizeof(source));
        }
#line 129
        if (tmp___3 == -1) {
          {
#line 131
          tmp___2 = __errno_location();
          }
#line 131
          if (*tmp___2 == 98) {
            {
#line 133
            writeError(7, "Port %d in use trying next lower port.", nSourcePort);
#line 134
            nSourcePort --;
#line 135
            source.sin_port = htons((uint16_t )nSourcePort);
            }
          } else {
            {
#line 139
            tmp___0 = __errno_location();
            }
#line 139
            if (*tmp___0 == 13) {
              {
#line 139
              tmp___1 = getuid();
              }
#line 139
              if (tmp___1 > 0U) {
                {
#line 141
                writeError(3, "Source port for this service requires root privileges.");
                }
#line 142
                return (-1);
              }
            }
          }
        } else {
#line 147
          bind_ok = 1;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 152
    if (nUseProxy > 0) {
      {
#line 154
      target.sin_port = htons((uint16_t )nProxyStringPort);
#line 155
      memcpy((void */* __restrict  */)(& target.sin_addr.s_addr), (void const   */* __restrict  */)(& nProxyStringIP),
             sizeof(unsigned long ));
      }
    } else {
      {
#line 159
      target.sin_port = htons((uint16_t )nPort);
#line 160
      memcpy((void */* __restrict  */)(& target.sin_addr.s_addr), (void const   */* __restrict  */)(& nHost),
             sizeof(unsigned long ));
      }
    }
    {
#line 162
    target.sin_family = (sa_family_t )2;
#line 165
    tmp___6 = fcntl(s, 3, (void *)0);
#line 165
    flag = (long )tmp___6;
    }
#line 165
    if (flag < 0L) {
      {
#line 167
      tmp___4 = __errno_location();
#line 167
      tmp___5 = strerror(*tmp___4);
#line 167
      writeError(3, "Error fcntl(..., F_GETFL) (%s)", tmp___5);
      }
#line 168
      return (-1);
    }
    {
#line 170
    flag |= 2048L;
#line 171
    tmp___9 = fcntl(s, 4, flag);
    }
#line 171
    if (tmp___9 < 0) {
      {
#line 173
      tmp___7 = __errno_location();
#line 173
      tmp___8 = strerror(*tmp___7);
#line 173
      writeError(3, "Error fcntl(..., F_SETFL) (%s)", tmp___8);
      }
#line 174
      return (-1);
    }
    {
#line 177
    nFail = 0;
#line 178
    ret = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& target)), (socklen_t )sizeof(struct sockaddr_in ));
#line 179
    tmp___19 = __errno_location();
    }
#line 179
    if (*tmp___19 == 115) {
      {
#line 181
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 183
        if (nFail > 0) {
#line 183
          if (nFail <= nRetries) {
            {
#line 185
            tmp___10 = inet_ntop(2, (void const   */* __restrict  */)(& target.sin_addr),
                                 (char */* __restrict  */)(out), (socklen_t )sizeof(out));
#line 185
            tmp___11 = pthread_self();
#line 185
            writeError(3, "Thread %X: Host: %s Cannot connect [unreachable], retrying (%d of %d retries)",
                       (int )tmp___11, tmp___10, nFail, nRetries);
#line 186
            sleep((unsigned int )nRetryWait);
            }
          } else {
#line 183
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 188
        if (nFail > nRetries) {
#line 189
          return (-1);
        }
#line 191
        tv.tv_sec = (__time_t )nWaitTime;
#line 192
        tv.tv_usec = (__suseconds_t )0;
        {
#line 193
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 193
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& myset.__fds_bits[0]): "memory");
#line 193
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 194
        myset.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 195
        ret = select(s + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& myset),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 196
        if (ret < 0) {
          {
#line 196
          tmp___18 = __errno_location();
          }
#line 196
          if (*tmp___18 != 4) {
            {
#line 198
            tmp___12 = __errno_location();
#line 198
            tmp___13 = strerror(*tmp___12);
#line 198
            writeError(3, "Error connecting to host: %s", tmp___13);
            }
#line 199
            return (-1);
          } else {
#line 196
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 201
        if (ret > 0) {
          {
#line 203
          nSize = (int )sizeof(int );
#line 204
          tmp___16 = getsockopt(s, 1, 4, (void */* __restrict  */)((void *)(& nOpt)),
                                (socklen_t */* __restrict  */)(& nSize));
          }
#line 204
          if (tmp___16 < 0) {
            {
#line 206
            tmp___14 = __errno_location();
#line 206
            tmp___15 = strerror(*tmp___14);
#line 206
            writeError(3, "Error in getsockopt() %s", tmp___15);
            }
#line 207
            return (-1);
          }
#line 209
          if (nOpt != 0) {
            {
#line 212
            tmp___17 = inet_ntop(2, (void const   */* __restrict  */)(& target.sin_addr),
                                 (char */* __restrict  */)(out), (socklen_t )sizeof(out));
#line 212
            writeVerbose(6, "Unable to connect (invalid socket): unreachable destination - %s",
                         tmp___17);
            }
#line 213
            return (-1);
          }
#line 217
          ret = 0;
#line 218
          goto while_break___0;
        } else {
#line 222
          nFail ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 226
    if (ret != 0) {
      {
#line 228
      writeVerbose(6, "Unable to connect: unreachable destination");
#line 230
      ret = -1;
      }
#line 231
      return (ret);
    } else
#line 226
    if (nFail > nRetries) {
      {
#line 228
      writeVerbose(6, "Unable to connect: unreachable destination");
#line 230
      ret = -1;
      }
#line 231
      return (ret);
    }
    {
#line 235
    tmp___22 = fcntl(s, 3, (void *)0);
#line 235
    flag = (long )tmp___22;
    }
#line 235
    if (flag < 0L) {
      {
#line 237
      tmp___20 = __errno_location();
#line 237
      tmp___21 = strerror(*tmp___20);
#line 237
      writeError(3, "Error fcntl(..., F_GETFL) (%s)", tmp___21);
      }
#line 238
      return (-1);
    }
    {
#line 240
    flag &= -2049L;
#line 241
    tmp___25 = fcntl(s, 4, flag);
    }
#line 241
    if (tmp___25 < 0) {
      {
#line 243
      tmp___23 = __errno_location();
#line 243
      tmp___24 = strerror(*tmp___23);
#line 243
      writeError(3, "Error fcntl(..., F_SETFL) (%s)", tmp___24);
      }
#line 244
      return (-1);
    }
    {
#line 246
    ret = s;
#line 248
    writeError(7, "Connected (internal)");
    }
#line 250
    if (nUseProxy > 0) {
      {
#line 252
      tmp___26 = malloc((size_t )4096);
#line 252
      buf___8 = (char *)tmp___26;
#line 253
      memset((void *)buf___8, 0, (size_t )4096);
#line 254
      memset((void *)(& target), 0, sizeof(struct sockaddr_in ));
#line 255
      memcpy((void */* __restrict  */)(& target.sin_addr.s_addr), (void const   */* __restrict  */)(& nHost),
             sizeof(unsigned long ));
#line 256
      target.sin_family = (sa_family_t )2;
      }
#line 258
      if ((unsigned long )szProxyAuthentication == (unsigned long )((void *)0)) {
        {
#line 259
        tmp___27 = inet_ntop(2, (void const   */* __restrict  */)(& target.sin_addr),
                             (char */* __restrict  */)(out), (socklen_t )sizeof(out));
#line 259
        snprintf((char */* __restrict  */)buf___8, (size_t )4095, (char const   */* __restrict  */)"CONNECT %s:%d HTTP/1.0\r\n\r\n",
                 tmp___27, nPort);
        }
      } else {
        {
#line 261
        tmp___28 = inet_ntop(2, (void const   */* __restrict  */)(& target.sin_addr),
                             (char */* __restrict  */)(out), (socklen_t )sizeof(out));
#line 261
        snprintf((char */* __restrict  */)buf___8, (size_t )4095, (char const   */* __restrict  */)"CONNECT %s:%d HTTP/1.0\r\nProxy-Authorization: Basic %s\r\n\r\n",
                 tmp___28, nPort, szProxyAuthentication);
        }
      }
      {
#line 264
      tmp___29 = strlen((char const   *)buf___8);
#line 264
      send(s, (void const   *)buf___8, tmp___29, 0);
#line 265
      recv(s, (void *)buf___8, (size_t )4096, 0);
#line 267
      tmp___30 = strlen("HTTP/");
#line 267
      tmp___31 = strncmp("HTTP/", (char const   *)buf___8, tmp___30);
      }
#line 267
      if (tmp___31 == 0) {
        {
#line 267
        tmpptr = index((char const   *)buf___8, ' ');
        }
#line 267
        if ((unsigned long )tmpptr != (unsigned long )((void *)0)) {
#line 267
          tmpptr ++;
#line 267
          if ((int )*tmpptr == 50) {
            {
#line 269
            writeError(7, "Connected (with proxy)");
            }
          } else {
            {
#line 274
            writeError(3, "CONNECT call to proxy failed with code %c%c%c", (int )*tmpptr,
                       (int )*(tmpptr + 1), (int )*(tmpptr + 2));
#line 276
            close(s);
#line 277
            ret = -1;
#line 278
            free((void *)buf___8);
            }
#line 280
            return (ret);
          }
        } else {
          {
#line 274
          writeError(3, "CONNECT call to proxy failed with code %c%c%c", (int )*tmpptr,
                     (int )*(tmpptr + 1), (int )*(tmpptr + 2));
#line 276
          close(s);
#line 277
          ret = -1;
#line 278
          free((void *)buf___8);
          }
#line 280
          return (ret);
        }
      } else {
        {
#line 274
        writeError(3, "CONNECT call to proxy failed with code %c%c%c", (int )*tmpptr,
                   (int )*(tmpptr + 1), (int )*(tmpptr + 2));
#line 276
        close(s);
#line 277
        ret = -1;
#line 278
        free((void *)buf___8);
        }
#line 280
        return (ret);
      }
      {
#line 282
      free((void *)buf___8);
      }
    }
#line 284
    nFail = 0;
#line 286
    return (ret);
  }
#line 289
  return (ret);
}
}
#line 385 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaReceiveInternal(int socket___0 , char *buf___8 , int length ) 
{ 
  ssize_t tmp ;

  {
  {
#line 424
  tmp = recv(socket___0, (void *)buf___8, (size_t )length, 0);
  }
#line 424
  return ((int )tmp);
}
}
#line 432 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
char *medusaReceiveDataInternal(int socket___0 , int *nBufferSize , int nConvertNullsToSpaces ,
                                int nReceiveDelay1 , int nReceiveDelay2 ) 
{ 
  unsigned int BUFFER_SIZE___0 ;
  char *szBufReceive ;
  char *szBufReceiveTmp ;
  int nBufReceive ;
  int nBufReceiveTmp ;
  int BufReceiveIndex ;
  int bSocketStatus ;
  int nReceiveDelay1sec ;
  int nReceiveDelay1usec ;
  int nReceiveDelay2sec ;
  int nReceiveDelay2usec ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 452
  BUFFER_SIZE___0 = 576U;
#line 455
  nBufReceive = 0;
#line 455
  nBufReceiveTmp = 0;
#line 455
  BufReceiveIndex = 0;
#line 456
  bSocketStatus = 0;
#line 457
  nReceiveDelay1sec = 0;
#line 457
  nReceiveDelay1usec = 0;
#line 458
  nReceiveDelay2sec = 0;
#line 458
  nReceiveDelay2usec = 0;
#line 460
  *nBufferSize = 0;
#line 462
  tmp = malloc((size_t )(BUFFER_SIZE___0 + 1U));
#line 462
  szBufReceive = (char *)tmp;
#line 463
  memset((void *)szBufReceive, 0, (size_t )(BUFFER_SIZE___0 + 1U));
#line 465
  nReceiveDelay1sec = nReceiveDelay1 / 1000000;
#line 466
  nReceiveDelay1usec = nReceiveDelay1 % 1000000;
#line 467
  nReceiveDelay2sec = nReceiveDelay2 / 1000000;
#line 468
  nReceiveDelay2usec = nReceiveDelay2 % 1000000;
#line 470
  bSocketStatus = medusaDataReadyTimed(socket___0, (time_t )nReceiveDelay1sec, (time_t )nReceiveDelay1usec);
  }
#line 471
  if (bSocketStatus > 0) {
    {
#line 473
    writeError(7, "Data receive: Data waiting.");
#line 474
    nBufReceive = medusaReceive(socket___0, szBufReceive, (int )BUFFER_SIZE___0);
    }
#line 475
    if (nBufReceive <= 0) {
      {
#line 477
      writeError(7, "Data receive: Socket indicated data present, but none found.");
#line 478
      free((void *)szBufReceive);
      }
#line 479
      return ((char *)((void *)0));
    }
  } else
#line 482
  if (bSocketStatus == 0) {
    {
#line 484
    writeError(7, "Data receive: No data.");
#line 485
    free((void *)szBufReceive);
    }
#line 486
    return ((char *)((void *)0));
  } else {
    {
#line 490
    writeError(3, "Data receive: Failed to read from network socket.");
#line 491
    free((void *)szBufReceive);
    }
#line 492
    return ((char *)((void *)0));
  }
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 496
    tmp___2 = medusaDataReadyTimed(socket___0, (time_t )nReceiveDelay2sec, (time_t )nReceiveDelay2usec);
    }
#line 496
    if (! (tmp___2 > 0)) {
#line 496
      goto while_break;
    }
    {
#line 498
    tmp___0 = malloc((size_t )(BUFFER_SIZE___0 + 1U));
#line 498
    szBufReceiveTmp = (char *)tmp___0;
#line 499
    memset((void *)szBufReceiveTmp, 0, (size_t )(BUFFER_SIZE___0 + 1U));
#line 500
    nBufReceiveTmp = medusaReceive(socket___0, szBufReceiveTmp, (int )BUFFER_SIZE___0);
    }
#line 501
    if (nBufReceiveTmp <= 0) {
      {
#line 503
      writeError(7, "Data receive: No additional data.");
#line 504
      free((void *)szBufReceiveTmp);
      }
#line 505
      goto while_break;
    }
#line 508
    if ((unsigned int )(nBufReceive + nBufReceiveTmp) > BUFFER_SIZE___0) {
      {
#line 510
      writeError(7, "Additional data received. Increasing receive buffer %d bytes to %d.",
                 nBufReceiveTmp, (nBufReceive + nBufReceiveTmp) + 1);
#line 511
      tmp___1 = realloc((void *)szBufReceive, (size_t )((nBufReceive + nBufReceiveTmp) + 1));
#line 511
      szBufReceive = (char *)tmp___1;
      }
    }
    {
#line 514
    memcpy((void */* __restrict  */)(szBufReceive + nBufReceive), (void const   */* __restrict  */)szBufReceiveTmp,
           (size_t )nBufReceiveTmp);
#line 515
    nBufReceive += nBufReceiveTmp;
#line 517
    nBufReceiveTmp = 0;
#line 518
    free((void *)szBufReceiveTmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  *(szBufReceive + nBufReceive) = (char)0;
#line 524
  if (nConvertNullsToSpaces != 0) {
#line 525
    BufReceiveIndex = 0;
    {
#line 525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 525
      if (! (BufReceiveIndex < nBufReceive)) {
#line 525
        goto while_break___0;
      }
#line 526
      if ((int )*(szBufReceive + BufReceiveIndex) == 0) {
#line 527
        *(szBufReceive + BufReceiveIndex) = (char)32;
      }
#line 525
      BufReceiveIndex ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 529
  writeError(7, "Formatted data received (size %d): %s", nBufReceive, szBufReceive);
#line 531
  *nBufferSize = nBufReceive;
  }
#line 532
  return (szBufReceive);
}
}
#line 535 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaSendInternal(int socket___0 , char *buf___8 , int size , int options ) 
{ 
  int nRet ;
  char *bufReceive ;
  int nReceiveBufferSize ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 549
  bufReceive = (char *)((void *)0);
#line 550
  nReceiveBufferSize = 0;
#line 562
  tmp = send(socket___0, (void const   *)buf___8, (size_t )size, options);
#line 562
  nRet = (int )tmp;
  }
#line 563
  if (nRet < 0) {
    {
#line 565
    tmp___0 = __errno_location();
#line 565
    tmp___1 = strerror(*tmp___0);
#line 565
    writeError(3, "Error in send() %s", tmp___1);
    }
  }
#line 568
  return (nRet);
}
}
#line 577 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaConnect(sConnectParams *pParams ) 
{ 


  {
  {
#line 579
  medusaConnectInternal((unsigned long )pParams->nHost, pParams->nPort, pParams->nProtocol,
                        pParams->nType, pParams->nTimeout, pParams->nRetries, pParams->nRetryWait,
                        pParams->nProxyStringIP, pParams->nProxyStringPort, pParams->szProxyAuthentication,
                        pParams->nSourcePort);
  }
#line 581
  return (0);
}
}
#line 583 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaConnectSSL(sConnectParams *pParams ) 
{ 
  int tmp ;

  {
  {
#line 595
  writeError(3, "Trying to connect via SSL, but medusa was not compiled with OPENSSL support. Using non-SSL connection.");
#line 596
  pParams->nUseSSL = 0;
#line 597
  tmp = medusaConnect(pParams);
  }
#line 597
  return (tmp);
}
}
#line 603 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaConnectSocketSSL(sConnectParams *pParams , int hSocket ) 
{ 


  {
  {
#line 618
  writeError(3, "Trying to connect via SSL, but medusa was not compiled with OPENSSL support.");
#line 619
  pParams->nUseSSL = 0;
  }
#line 620
  return (-1);
}
}
#line 624 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaConnectTCP(sConnectParams *pParams ) 
{ 
  int tmp ;

  {
  {
#line 626
  pParams->nProtocol = 1;
#line 627
  pParams->nType = 6;
#line 628
  tmp = medusaConnect(pParams);
  }
#line 628
  return (tmp);
}
}
#line 631 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaConnectUDP(sConnectParams *pParams ) 
{ 
  int tmp ;

  {
  {
#line 634
  pParams->nProtocol = 2;
#line 635
  pParams->nType = 17;
#line 636
  tmp = medusaConnect(pParams);
  }
#line 636
  return (tmp);
}
}
#line 639 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaDisconnect(int hSocket ) 
{ 


  {
  {
#line 663
  close(hSocket);
#line 664
  writeError(7, "Disconnect successful");
  }
#line 665
  return (-1);
}
}
#line 669 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaDataReadyWritingTimed(int socket___0 , time_t sec , time_t usec ) 
{ 
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 674
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 675
  fds.__fds_bits[socket___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket___0 % (8 * (int )sizeof(__fd_mask ));
#line 676
  tv.tv_sec = sec;
#line 677
  tv.tv_usec = usec;
#line 679
  tmp = select(socket___0 + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 679
  return (tmp);
}
}
#line 682 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaDataReadyWriting(int socket___0 ) 
{ 
  int tmp ;

  {
  {
#line 684
  tmp = medusaDataReadyWritingTimed(socket___0, (time_t )30, (time_t )0);
  }
#line 684
  return (tmp);
}
}
#line 687 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaDataReadyTimed(int socket___0 , time_t sec , time_t usec ) 
{ 
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 692
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  fds.__fds_bits[socket___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket___0 % (8 * (int )sizeof(__fd_mask ));
#line 694
  tv.tv_sec = sec;
#line 695
  tv.tv_usec = usec;
#line 697
  tmp = select(socket___0 + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 697
  return (tmp);
}
}
#line 700 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaDataReady(int socket___0 ) 
{ 
  int tmp ;

  {
  {
#line 702
  tmp = medusaDataReadyTimed(socket___0, (time_t )0, (time_t )0);
  }
#line 702
  return (tmp);
}
}
#line 706 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaCheckSocket(int socket___0 , int usec ) 
{ 
  int tmp ;

  {
  {
#line 708
  writeError(7, "wait time: %d", usec);
#line 710
  tmp = medusaDataReadyTimed(socket___0, (time_t )0, (time_t )usec);
  }
#line 710
  if (tmp == 0) {
#line 711
    return (1);
  } else {
#line 713
    return (0);
  }
}
}
#line 716 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaReceive(int socket___0 , char *buf___8 , int length ) 
{ 
  int ret ;

  {
  {
#line 720
  ret = medusaReceiveInternal(socket___0, buf___8, length);
#line 721
  writeError(7, "Data received (%d): %s", ret, buf___8);
  }
#line 722
  return (ret);
}
}
#line 725 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
char *medusaReceiveRaw(int socket___0 , int *nBufferSize ) 
{ 
  char *tmp ;

  {
  {
#line 727
  tmp = medusaReceiveDataInternal(socket___0, nBufferSize, 0, 20000000, 0);
  }
#line 727
  return (tmp);
}
}
#line 730 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
char *medusaReceiveRawDelay(int socket___0 , int *nBufferSize , int nReceiveDelay1 ,
                            int nReceiveDelay2 ) 
{ 
  char *tmp ;

  {
  {
#line 732
  tmp = medusaReceiveDataInternal(socket___0, nBufferSize, 0, nReceiveDelay1, nReceiveDelay2);
  }
#line 732
  return (tmp);
}
}
#line 735 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
char *medusaReceiveLine(int socket___0 , int *nBufferSize ) 
{ 
  char *tmp ;

  {
  {
#line 737
  tmp = medusaReceiveDataInternal(socket___0, nBufferSize, 1, 20000000, 0);
  }
#line 737
  return (tmp);
}
}
#line 740 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
char *medusaReceiveLineDelay(int socket___0 , int *nBufferSize , int nReceiveDelay1 ,
                             int nReceiveDelay2 ) 
{ 
  char *tmp ;

  {
  {
#line 742
  tmp = medusaReceiveDataInternal(socket___0, nBufferSize, 1, nReceiveDelay1, nReceiveDelay2);
  }
#line 742
  return (tmp);
}
}
#line 755 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaReceiveRegex(int hSocket , unsigned char **szBufReceive , int *nBufReceive ,
                       char const   *regex ) 
{ 
  char *szBufReceiveTmp ;
  int nBufReceiveTmp ;
  regex_t preg ;
  int errcode ;
  char errmsg[512] ;
  char const   *error ;
  int erroffset ;
  int nAttempt ;
  unsigned int BUFFER_SIZE___0 ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 757
  szBufReceiveTmp = (char *)((void *)0);
#line 758
  nBufReceiveTmp = 0;
#line 760
  errcode = 1;
#line 762
  error = (char const   *)((void *)0);
#line 763
  erroffset = 0;
#line 764
  nAttempt = 1;
#line 765
  BUFFER_SIZE___0 = 576U;
#line 767
  writeError(7, "Regural expession: \"%s\"", regex);
#line 768
  errcode = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)regex,
                    (1 | (1 << 1)) | (((1 << 1) << 1) << 1));
  }
#line 769
  if (errcode) {
    {
#line 771
    memset((void *)(errmsg), 0, (size_t )512);
#line 772
    regerror(errcode, (regex_t const   */* __restrict  */)(& preg), (char */* __restrict  */)(errmsg),
             (size_t )512);
#line 773
    writeError(3, "Regex compilation failed: %s", errmsg);
    }
#line 774
    return (-1);
  }
  {
#line 777
  tmp = medusaReceiveDataInternal(hSocket, nBufReceive, 0, 20000000, 0);
#line 777
  *szBufReceive = (unsigned char *)tmp;
  }
#line 778
  if ((unsigned long )*szBufReceive == (unsigned long )((void *)0)) {
#line 779
    return (-1);
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 783
    errcode = regexec((regex_t const   */* __restrict  */)(& preg), (char const   */* __restrict  */)*szBufReceive,
                      (size_t )0, (regmatch_t */* __restrict  */)0, 0);
    }
#line 784
    if (errcode == 1) {
      {
#line 786
      writeError(7, "Failed to match regex. Checking for additional data.");
#line 789
      tmp___2 = medusaDataReadyTimed(hSocket, (time_t )0, (time_t )(20000 * nAttempt));
      }
#line 789
      if (tmp___2 > 0) {
        {
#line 791
        tmp___0 = malloc((size_t )(BUFFER_SIZE___0 + 1U));
#line 791
        szBufReceiveTmp = (char *)tmp___0;
#line 792
        memset((void *)szBufReceiveTmp, 0, (size_t )(BUFFER_SIZE___0 + 1U));
#line 794
        nBufReceiveTmp = medusaReceive(hSocket, szBufReceiveTmp, (int )BUFFER_SIZE___0);
        }
#line 795
        if (nBufReceiveTmp <= 0) {
          {
#line 797
          writeError(7, "Data receive: No additional data.");
#line 798
          free((void *)szBufReceiveTmp);
          }
#line 799
          goto while_break;
        }
#line 802
        if ((unsigned int )(*nBufReceive + nBufReceiveTmp) > BUFFER_SIZE___0) {
          {
#line 804
          writeError(7, "Additional data received. Increasing receive buffer %d bytes to %d.",
                     nBufReceiveTmp, (*nBufReceive + nBufReceiveTmp) + 1);
#line 805
          tmp___1 = realloc((void *)*szBufReceive, (size_t )((*nBufReceive + nBufReceiveTmp) + 1));
#line 805
          *szBufReceive = (unsigned char *)tmp___1;
          }
        }
        {
#line 808
        memcpy((void */* __restrict  */)(*szBufReceive + *nBufReceive), (void const   */* __restrict  */)szBufReceiveTmp,
               (size_t )nBufReceiveTmp);
#line 809
        *nBufReceive += nBufReceiveTmp;
#line 811
        nBufReceiveTmp = 0;
#line 812
        free((void *)szBufReceiveTmp);
        }
      } else {
        {
#line 817
        writeError(7, "No additional data found (attempt %d/5)", nAttempt);
#line 818
        nAttempt ++;
        }
      }
    } else {
      {
#line 823
      regfree(& preg);
#line 824
      writeError(7, "Successfully matched regex.");
      }
#line 825
      return (0);
    }
#line 781
    if (! (nAttempt <= 5)) {
#line 781
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 829
  regfree(& preg);
#line 830
  writeError(3, "Failed to match regex pattern within server\'s response.");
  }
#line 831
  return (-1);
}
}
#line 834 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int medusaSend(int socket___0 , char *buf___8 , int size , int options ) 
{ 
  char *debugbuf ;
  unsigned long __lengthofdebugbuf ;
  void *tmp ;
  int k ;
  int tmp___0 ;

  {
  {
#line 836
  __lengthofdebugbuf = (unsigned long )(size + 1);
#line 836
  tmp = __builtin_alloca(sizeof(*debugbuf) * __lengthofdebugbuf);
#line 836
  debugbuf = (char *)tmp;
#line 839
  memset((void *)debugbuf, 0, (size_t )(size + 1));
#line 840
  k = 0;
  }
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (k < size)) {
#line 840
      goto while_break;
    }
#line 841
    if ((int )*(buf___8 + k) == 0) {
#line 842
      *(debugbuf + k) = (char)32;
    } else {
#line 844
      *(debugbuf + k) = *(buf___8 + k);
    }
#line 840
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 845
  writeError(7, "Data sent: %s", debugbuf);
#line 847
  tmp___0 = medusaSendInternal(socket___0, buf___8, size, options);
  }
#line 847
  return (tmp___0);
}
}
#line 850 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-net.c"
int makeToLower(char *buf___8 ) 
{ 
  int tmp ;

  {
#line 852
  if ((unsigned long )buf___8 == (unsigned long )((void *)0)) {
#line 853
    return (1);
  }
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if (! ((int )*(buf___8 + 0) != 0)) {
#line 855
      goto while_break;
    }
    {
#line 857
    tmp = tolower((int )*(buf___8 + 0));
#line 857
    *(buf___8 + 0) = (char )tmp;
#line 858
    buf___8 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  return (1);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 301
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 310
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 316
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getguardsize)(pthread_attr_t const   *__attr ,
                                                                                                                  size_t *__guardsize ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setguardsize)(pthread_attr_t *__attr ,
                                                                                                                size_t __guardsize ) ;
#line 327
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedparam)(pthread_attr_t const   * __restrict  __attr ,
                                                                                                                   struct sched_param * __restrict  __param ) ;
#line 332
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t * __restrict  __attr ,
                                                                                                                   struct sched_param  const  * __restrict  __param ) ;
#line 337
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getschedpolicy)(pthread_attr_t const   * __restrict  __attr ,
                                                                                                                    int * __restrict  __policy ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                                                  int __policy ) ;
#line 346
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getinheritsched)(pthread_attr_t const   * __restrict  __attr ,
                                                                                                                     int * __restrict  __inherit ) ;
#line 351
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setinheritsched)(pthread_attr_t *__attr ,
                                                                                                                   int __inherit ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_getscope)(pthread_attr_t const   * __restrict  __attr ,
                                                                                                              int * __restrict  __scope ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                                                            int __scope ) ;
#line 392
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2,3), __leaf__)) pthread_attr_getstack)(pthread_attr_t const   * __restrict  __attr ,
                                                                                                                void ** __restrict  __stackaddr ,
                                                                                                                size_t * __restrict  __stacksize ) ;
#line 400
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setstack)(pthread_attr_t *__attr ,
                                                                                                            void *__stackaddr ,
                                                                                                            size_t __stacksize ) ;
#line 517
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 521
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 524
extern int pthread_cancel(pthread_t __th ) ;
#line 691
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 703
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 744
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 754
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 992
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 1011
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 66 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static thr_pool_t *thr_pools  =    (thr_pool_t *)((void *)0);
#line 69 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static pthread_mutex_t thr_pool_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 72 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static sigset_t fillset  ;
#line 74
static void *worker_thread(void *arg ) ;
#line 76 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static int create_worker(thr_pool_t *pool ) 
{ 
  sigset_t oset ;
  int error ;
  pthread_t *ppthread ;
  void *tmp ;

  {
  {
#line 85
  tmp = malloc(sizeof(pthread_t ));
#line 85
  ppthread = (pthread_t *)tmp;
#line 86
  memset((void *)ppthread, 0, sizeof(pthread_t ));
#line 88
  pthread_sigmask(2, (__sigset_t const   */* __restrict  */)(& fillset), (__sigset_t */* __restrict  */)(& oset));
#line 89
  error = pthread_create((pthread_t */* __restrict  */)ppthread, (pthread_attr_t const   */* __restrict  */)(& pool->pool_attr),
                         & worker_thread, (void */* __restrict  */)pool);
#line 90
  pthread_sigmask(2, (__sigset_t const   */* __restrict  */)(& oset), (__sigset_t */* __restrict  */)((void *)0));
#line 92
  free((void *)ppthread);
  }
#line 94
  return (error);
}
}
#line 105 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static void worker_cleanup(thr_pool_t *pool ) 
{ 
  int tmp ;

  {
#line 108
  (pool->pool_nthreads) --;
#line 109
  if (pool->pool_flags & 2) {
#line 110
    if (pool->pool_nthreads == 0) {
      {
#line 111
      pthread_cond_broadcast(& pool->pool_busycv);
      }
    }
  } else
#line 112
  if ((unsigned long )pool->pool_head != (unsigned long )((void *)0)) {
#line 112
    if (pool->pool_nthreads < pool->pool_maximum) {
      {
#line 112
      tmp = create_worker(pool);
      }
#line 112
      if (tmp == 0) {
#line 115
        (pool->pool_nthreads) ++;
      }
    }
  }
  {
#line 117
  pthread_mutex_unlock(& pool->pool_mutex);
  }
#line 118
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static void notify_waiters(thr_pool_t *pool ) 
{ 


  {
#line 123
  if ((unsigned long )pool->pool_head == (unsigned long )((void *)0)) {
#line 123
    if ((unsigned long )pool->pool_active == (unsigned long )((void *)0)) {
      {
#line 124
      pool->pool_flags &= -2;
#line 125
      pthread_cond_broadcast(& pool->pool_waitcv);
      }
    }
  }
#line 127
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static void job_cleanup(thr_pool_t *pool ) 
{ 
  pthread_t my_tid ;
  pthread_t tmp ;
  active_t *activep ;
  active_t **activepp ;

  {
  {
#line 135
  tmp = pthread_self();
#line 135
  my_tid = tmp;
#line 139
  pthread_mutex_lock(& pool->pool_mutex);
#line 140
  activepp = & pool->pool_active;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    activep = *activepp;
#line 140
    if (! ((unsigned long )activep != (unsigned long )((void *)0))) {
#line 140
      goto while_break;
    }
#line 143
    if (activep->active_tid == my_tid) {
#line 144
      *activepp = activep->active_next;
#line 145
      goto while_break;
    }
#line 140
    activepp = & activep->active_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (pool->pool_flags & 1) {
    {
#line 149
    notify_waiters(pool);
    }
  }
#line 150
  return;
}
}
#line 152 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static void *worker_thread(void *arg ) 
{ 
  thr_pool_t *pool ;
  int timedout ;
  job_t *job ;
  void *(*func)(void * ) ;
  active_t active ;
  struct timespec ts ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int __not_first_call___0 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 155
  pool = (thr_pool_t *)arg;
#line 167
  pthread_mutex_lock(& pool->pool_mutex);
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    __cancel_routine = (void (*)(void * ))((void *)(& worker_cleanup));
#line 168
    __cancel_arg = (void *)pool;
#line 168
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 168
    __not_first_call = tmp;
#line 168
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 168
    if (tmp___0) {
      {
#line 168
      (*__cancel_routine)(__cancel_arg);
#line 168
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 168
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 169
      active.active_tid = pthread_self();
      }
      {
#line 170
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 176
        pthread_sigmask(2, (__sigset_t const   */* __restrict  */)(& fillset), (__sigset_t */* __restrict  */)((void *)0));
#line 177
        pthread_setcanceltype(0, (int *)((void *)0));
#line 178
        pthread_setcancelstate(0, (int *)((void *)0));
#line 180
        timedout = 0;
#line 181
        (pool->pool_idle) ++;
        }
#line 182
        if (pool->pool_flags & 1) {
          {
#line 183
          notify_waiters(pool);
          }
        }
        {
#line 184
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 184
          if ((unsigned long )pool->pool_head == (unsigned long )((void *)0)) {
#line 184
            if (! (! (pool->pool_flags & 2))) {
#line 184
              goto while_break___2;
            }
          } else {
#line 184
            goto while_break___2;
          }
#line 186
          if (pool->pool_nthreads <= pool->pool_minimum) {
            {
#line 187
            pthread_cond_wait((pthread_cond_t */* __restrict  */)(& pool->pool_workcv),
                              (pthread_mutex_t */* __restrict  */)(& pool->pool_mutex));
            }
          } else {
            {
#line 195
            clock_gettime(0, & ts);
#line 197
            ts.tv_sec += (__time_t )pool->pool_linger;
            }
#line 198
            if (pool->pool_linger == 0U) {
#line 201
              timedout = 1;
#line 202
              goto while_break___2;
            } else {
              {
#line 198
              tmp___1 = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& pool->pool_workcv),
                                               (pthread_mutex_t */* __restrict  */)(& pool->pool_mutex),
                                               (struct timespec  const  */* __restrict  */)(& ts));
              }
#line 198
              if (tmp___1 == 110) {
#line 201
                timedout = 1;
#line 202
                goto while_break___2;
              }
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 206
        (pool->pool_idle) --;
#line 207
        if (pool->pool_flags & 2) {
#line 208
          goto while_break___1;
        }
#line 209
        job = pool->pool_head;
#line 209
        if ((unsigned long )job != (unsigned long )((void *)0)) {
#line 210
          timedout = 0;
#line 211
          func = job->job_func;
#line 212
          arg = job->job_arg;
#line 213
          pool->pool_head = job->job_next;
#line 214
          if ((unsigned long )job == (unsigned long )pool->pool_tail) {
#line 215
            pool->pool_tail = (job_t *)((void *)0);
          }
          {
#line 216
          active.active_next = pool->pool_active;
#line 217
          pool->pool_active = & active;
#line 218
          pthread_mutex_unlock(& pool->pool_mutex);
          }
          {
#line 219
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 219
            __cancel_routine___0 = (void (*)(void * ))((void *)(& job_cleanup));
#line 219
            __cancel_arg___0 = (void *)pool;
#line 219
            tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf___0.__cancel_jmp_buf)),
                                  0);
#line 219
            __not_first_call___0 = tmp___2;
#line 219
            tmp___3 = __builtin_expect((long )__not_first_call___0, 0L);
            }
#line 219
            if (tmp___3) {
              {
#line 219
              (*__cancel_routine___0)(__cancel_arg___0);
#line 219
              __pthread_unwind_next(& __cancel_buf___0);
              }
            }
            {
#line 219
            __pthread_register_cancel(& __cancel_buf___0);
            }
            {
#line 219
            while (1) {
              while_continue___4: /* CIL Label */ ;
              {
#line 220
              free((void *)job);
#line 224
              (*func)(arg);
              }
              {
#line 230
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 230
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 219
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 230
            __pthread_unregister_cancel(& __cancel_buf___0);
#line 230
            (*__cancel_routine___0)(__cancel_arg___0);
            }
#line 219
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 232
        if (timedout) {
#line 232
          if (pool->pool_nthreads > pool->pool_minimum) {
#line 238
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 241
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 241
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 168
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 241
    __pthread_unregister_cancel(& __cancel_buf);
#line 241
    (*__cancel_routine)(__cancel_arg);
    }
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return ((void *)0);
}
}
#line 245 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
static void clone_attributes(pthread_attr_t *new_attr , pthread_attr_t *old_attr ) 
{ 
  struct sched_param param ;
  void *addr ;
  size_t size ;
  int value ;

  {
  {
#line 253
  pthread_attr_init(new_attr);
  }
#line 255
  if ((unsigned long )old_attr != (unsigned long )((void *)0)) {
    {
#line 256
    pthread_attr_getstack((pthread_attr_t const   */* __restrict  */)old_attr, (void **/* __restrict  */)(& addr),
                          (size_t */* __restrict  */)(& size));
#line 258
    pthread_attr_setstack(new_attr, (void *)0, size);
#line 260
    pthread_attr_getscope((pthread_attr_t const   */* __restrict  */)old_attr, (int */* __restrict  */)(& value));
#line 261
    pthread_attr_setscope(new_attr, value);
#line 263
    pthread_attr_getinheritsched((pthread_attr_t const   */* __restrict  */)old_attr,
                                 (int */* __restrict  */)(& value));
#line 264
    pthread_attr_setinheritsched(new_attr, value);
#line 266
    pthread_attr_getschedpolicy((pthread_attr_t const   */* __restrict  */)old_attr,
                                (int */* __restrict  */)(& value));
#line 267
    pthread_attr_setschedpolicy(new_attr, value);
#line 269
    pthread_attr_getschedparam((pthread_attr_t const   */* __restrict  */)old_attr,
                               (struct sched_param */* __restrict  */)(& param));
#line 270
    pthread_attr_setschedparam((pthread_attr_t */* __restrict  */)new_attr, (struct sched_param  const  */* __restrict  */)(& param));
#line 272
    pthread_attr_getguardsize((pthread_attr_t const   *)old_attr, & size);
#line 273
    pthread_attr_setguardsize(new_attr, size);
    }
  }
  {
#line 277
  pthread_attr_setdetachstate(new_attr, 1);
  }
#line 278
  return;
}
}
#line 280 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
thr_pool_t *thr_pool_create(uint_t min_threads , uint_t max_threads , uint_t linger ,
                            pthread_attr_t *attr ) 
{ 
  thr_pool_t *pool ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 286
  sigfillset(& fillset);
  }
#line 288
  if (min_threads > max_threads) {
    {
#line 289
    tmp = __errno_location();
#line 289
    *tmp = 22;
    }
#line 290
    return ((thr_pool_t *)((void *)0));
  } else
#line 288
  if (max_threads < 1U) {
    {
#line 289
    tmp = __errno_location();
#line 289
    *tmp = 22;
    }
#line 290
    return ((thr_pool_t *)((void *)0));
  }
  {
#line 293
  tmp___1 = malloc(sizeof(*pool));
#line 293
  pool = (thr_pool_t *)tmp___1;
  }
#line 293
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
    {
#line 294
    tmp___0 = __errno_location();
#line 294
    *tmp___0 = 12;
    }
#line 295
    return ((thr_pool_t *)((void *)0));
  }
  {
#line 297
  pthread_mutex_init(& pool->pool_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 298
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& pool->pool_busycv), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 299
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& pool->pool_workcv), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 300
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& pool->pool_waitcv), (pthread_condattr_t const   */* __restrict  */)((void *)0));
#line 301
  pool->pool_active = (active_t *)((void *)0);
#line 302
  pool->pool_head = (job_t *)((void *)0);
#line 303
  pool->pool_tail = (job_t *)((void *)0);
#line 304
  pool->pool_flags = 0;
#line 305
  pool->pool_linger = linger;
#line 306
  pool->pool_minimum = (int )min_threads;
#line 307
  pool->pool_maximum = (int )max_threads;
#line 308
  pool->pool_nthreads = 0;
#line 309
  pool->pool_idle = 0;
#line 318
  clone_attributes(& pool->pool_attr, attr);
#line 321
  pthread_mutex_lock(& thr_pool_lock);
  }
#line 322
  if ((unsigned long )thr_pools == (unsigned long )((void *)0)) {
#line 323
    pool->pool_forw = pool;
#line 324
    pool->pool_back = pool;
#line 325
    thr_pools = pool;
  } else {
#line 327
    (thr_pools->pool_back)->pool_forw = pool;
#line 328
    pool->pool_forw = thr_pools;
#line 329
    pool->pool_back = thr_pools->pool_back;
#line 330
    thr_pools->pool_back = pool;
  }
  {
#line 332
  pthread_mutex_unlock(& thr_pool_lock);
  }
#line 334
  return (pool);
}
}
#line 337 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
int thr_pool_queue(thr_pool_t *pool , void *(*func)(void * ) , void *arg ) 
{ 
  job_t *job ;
  int *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 342
  tmp___0 = malloc(sizeof(*job));
#line 342
  job = (job_t *)tmp___0;
  }
#line 342
  if ((unsigned long )job == (unsigned long )((void *)0)) {
    {
#line 343
    tmp = __errno_location();
#line 343
    *tmp = 12;
    }
#line 344
    return (-1);
  }
  {
#line 346
  job->job_next = (job_t *)((void *)0);
#line 347
  job->job_func = func;
#line 348
  job->job_arg = arg;
#line 350
  pthread_mutex_lock(& pool->pool_mutex);
  }
#line 352
  if ((unsigned long )pool->pool_head == (unsigned long )((void *)0)) {
#line 353
    pool->pool_head = job;
  } else {
#line 355
    (pool->pool_tail)->job_next = job;
  }
#line 356
  pool->pool_tail = job;
#line 358
  if (pool->pool_idle > 0) {
    {
#line 359
    pthread_cond_signal(& pool->pool_workcv);
    }
  } else
#line 360
  if (pool->pool_nthreads < pool->pool_maximum) {
    {
#line 360
    tmp___1 = create_worker(pool);
    }
#line 360
    if (tmp___1 == 0) {
#line 362
      (pool->pool_nthreads) ++;
    }
  }
  {
#line 364
  pthread_mutex_unlock(& pool->pool_mutex);
  }
#line 365
  return (0);
}
}
#line 368 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
void thr_pool_wait(thr_pool_t *pool ) 
{ 
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 371
  pthread_mutex_lock(& pool->pool_mutex);
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 372
    __cancel_routine = (void (*)(void * ))((void *)(& pthread_mutex_unlock));
#line 372
    __cancel_arg = (void *)(& pool->pool_mutex);
#line 372
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 372
    __not_first_call = tmp;
#line 372
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 372
    if (tmp___0) {
      {
#line 372
      (*__cancel_routine)(__cancel_arg);
#line 372
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 372
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 373
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 373
        if (! ((unsigned long )pool->pool_head != (unsigned long )((void *)0))) {
#line 373
          if (! ((unsigned long )pool->pool_active != (unsigned long )((void *)0))) {
#line 373
            goto while_break___1;
          }
        }
        {
#line 374
        pool->pool_flags |= 1;
#line 375
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& pool->pool_waitcv),
                          (pthread_mutex_t */* __restrict  */)(& pool->pool_mutex));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 377
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 377
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 372
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 377
    __pthread_unregister_cancel(& __cancel_buf);
#line 377
    (*__cancel_routine)(__cancel_arg);
    }
#line 372
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/medusa-2.1.1/src/medusa-thread-pool.c"
void thr_pool_destroy(thr_pool_t *pool ) 
{ 
  active_t *activep ;
  job_t *job ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 386
  pthread_mutex_lock(& pool->pool_mutex);
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 387
    __cancel_routine = (void (*)(void * ))((void *)(& pthread_mutex_unlock));
#line 387
    __cancel_arg = (void *)(& pool->pool_mutex);
#line 387
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 387
    __not_first_call = tmp;
#line 387
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 387
    if (tmp___0) {
      {
#line 387
      (*__cancel_routine)(__cancel_arg);
#line 387
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 387
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 390
      pool->pool_flags |= 2;
#line 391
      pthread_cond_broadcast(& pool->pool_workcv);
#line 394
      activep = pool->pool_active;
      }
      {
#line 394
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 394
        if (! ((unsigned long )activep != (unsigned long )((void *)0))) {
#line 394
          goto while_break___1;
        }
        {
#line 397
        pthread_cancel(activep->active_tid);
#line 394
        activep = activep->active_next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 400
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 400
        if (! ((unsigned long )pool->pool_active != (unsigned long )((void *)0))) {
#line 400
          goto while_break___2;
        }
        {
#line 401
        pool->pool_flags |= 1;
#line 402
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& pool->pool_waitcv),
                          (pthread_mutex_t */* __restrict  */)(& pool->pool_mutex));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 406
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 406
        if (! (pool->pool_nthreads != 0)) {
#line 406
          goto while_break___3;
        }
        {
#line 407
        pthread_cond_wait((pthread_cond_t */* __restrict  */)(& pool->pool_busycv),
                          (pthread_mutex_t */* __restrict  */)(& pool->pool_mutex));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 409
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 409
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 387
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 409
    __pthread_unregister_cancel(& __cancel_buf);
#line 409
    (*__cancel_routine)(__cancel_arg);
    }
#line 387
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 414
  pthread_mutex_lock(& thr_pool_lock);
  }
#line 415
  if ((unsigned long )thr_pools == (unsigned long )pool) {
#line 416
    thr_pools = pool->pool_forw;
  }
#line 417
  if ((unsigned long )thr_pools == (unsigned long )pool) {
#line 418
    thr_pools = (thr_pool_t *)((void *)0);
  } else {
#line 420
    (pool->pool_back)->pool_forw = pool->pool_forw;
#line 421
    (pool->pool_forw)->pool_back = pool->pool_back;
  }
  {
#line 423
  pthread_mutex_unlock(& thr_pool_lock);
#line 428
  job = pool->pool_head;
  }
  {
#line 428
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 428
    if (! ((unsigned long )job != (unsigned long )((void *)0))) {
#line 428
      goto while_break___5;
    }
    {
#line 429
    pool->pool_head = job->job_next;
#line 430
    free((void *)job);
#line 428
    job = pool->pool_head;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 432
  pthread_attr_destroy(& pool->pool_attr);
#line 433
  free((void *)pool);
  }
#line 434
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/module.h"
int getParamNumber(void) ;
#line 47
void summaryUsage(char **ppszSummary ) ;
#line 48
void showUsage(void) ;
#line 49
int go(sLogin *logins , int argc , char **argv ) ;
#line 55 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
int tryLogin(int hSocket , sLogin **psLogin , char *szLogin , char *szPassword ) ;
#line 56
int initModule(sLogin *psLogin ) ;
#line 59 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
int getParamNumber(void) 
{ 


  {
#line 61
  return (0);
}
}
#line 65 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
void summaryUsage(char **ppszSummary ) 
{ 
  int iLength ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 68
  iLength = 0;
#line 70
  if ((unsigned long )*ppszSummary == (unsigned long )((void *)0)) {
    {
#line 72
    tmp = strlen("Brute force module for RLOGIN sessions");
#line 72
    tmp___0 = strlen("2.0");
#line 72
    tmp___1 = strlen("%s : version %s");
#line 72
    iLength = (int )(((tmp + tmp___0) + tmp___1) + 1UL);
#line 73
    tmp___2 = malloc((size_t )iLength);
#line 73
    *ppszSummary = (char *)tmp___2;
#line 74
    memset((void *)*ppszSummary, 0, (size_t )iLength);
#line 75
    snprintf((char */* __restrict  */)*ppszSummary, (size_t )iLength, (char const   */* __restrict  */)"%s : version %s",
             "Brute force module for RLOGIN sessions", "2.0");
    }
  } else {
    {
#line 79
    writeError(3, "%s reports an error in summaryUsage() : ppszSummary must be NULL when called",
               "rlogin.mod");
    }
  }
#line 81
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
void showUsage(void) 
{ 


  {
  {
#line 86
  writeVerbose(1, "%s (%s) %s :: %s\n", "rlogin.mod", "2.0", "pMonkey <pmonkey@foofus.net>",
               "Brute force module for RLOGIN sessions");
  }
#line 87
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
int go(sLogin *logins , int argc , char **argv ) 
{ 


  {
#line 94
  if (! ((0 <= argc) <= 3)) {
    {
#line 97
    writeError(3, "%s is expecting 0 parameters, but it was passed %d", "rlogin.mod",
               argc);
    }
  } else {
    {
#line 101
    writeError(10, "OMG teh %s module has been called!!", "rlogin.mod");
#line 103
    initModule(logins);
    }
  }
#line 106
  return (0);
}
}
#line 109 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
int initModule(sLogin *psLogin ) 
{ 
  int hSocket ;
  enum MODULE_STATE nState ;
  sCredentialSet *psCredSet ;
  sConnectParams params ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 111
  hSocket = -1;
#line 112
  nState = (enum MODULE_STATE )0;
#line 113
  psCredSet = (sCredentialSet *)((void *)0);
#line 116
  tmp = malloc(sizeof(sCredentialSet ));
#line 116
  psCredSet = (sCredentialSet *)tmp;
#line 117
  memset((void *)psCredSet, 0, sizeof(sCredentialSet ));
#line 119
  tmp___0 = getNextCredSet(psLogin, psCredSet);
  }
#line 119
  if (tmp___0 == -1) {
    {
#line 121
    writeError(3, "[%s] Error retrieving next credential set to test.", "rlogin.mod");
#line 122
    nState = (enum MODULE_STATE )3;
    }
  } else
#line 124
  if (psCredSet->psUser) {
    {
#line 126
    writeError(10, "[%s] module started for host: %s user: %s", "rlogin.mod", (psLogin->psServer)->pHostIP,
               (psCredSet->psUser)->pUser);
    }
  } else {
    {
#line 130
    writeError(10, "[%s] module started for host: %s - no more available users to test.",
               "rlogin.mod");
#line 131
    nState = (enum MODULE_STATE )3;
    }
  }
  {
#line 134
  memset((void *)(& params), 0, sizeof(sConnectParams ));
  }
#line 135
  if (((psLogin->psServer)->psAudit)->iPortOverride > 0) {
#line 136
    params.nPort = ((psLogin->psServer)->psAudit)->iPortOverride;
  } else
#line 137
  if (((psLogin->psServer)->psHost)->iUseSSL > 0) {
    {
#line 138
    writeError(10, "[%s] module asked for RLOGIN/SSL. Don\'t know if such a thing exists...\n");
    }
  } else {
#line 140
    params.nPort = 513;
  }
  {
#line 141
  params.nSourcePort = 1023;
#line 142
  initConnectionParams(psLogin, & params);
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! ((unsigned int )nState != 3U)) {
#line 144
      goto while_break;
    }
    {
#line 148
    if ((unsigned int )nState == 0U) {
#line 148
      goto case_0;
    }
#line 168
    if ((unsigned int )nState == 1U) {
#line 168
      goto case_1;
    }
#line 195
    if ((unsigned int )nState == 2U) {
#line 195
      goto case_2;
    }
#line 201
    goto switch_default;
    case_0: /* CIL Label */ 
#line 150
    if (hSocket > 0) {
      {
#line 151
      medusaDisconnect(hSocket);
      }
    }
#line 153
    if (((psLogin->psServer)->psHost)->iUseSSL > 0) {
      {
#line 154
      hSocket = medusaConnectSSL(& params);
      }
    } else {
      {
#line 156
      hSocket = medusaConnect(& params);
      }
    }
#line 158
    if (hSocket < 0) {
      {
#line 160
      writeError(5, "%s: failed to connect, port %d was not open on %s", "rlogin.mod",
                 params.nPort, (psLogin->psServer)->pHostIP);
#line 161
      psLogin->iResult = 1;
      }
#line 162
      return (-1);
    }
    {
#line 165
    writeError(10, "Connected");
#line 166
    nState = (enum MODULE_STATE )1;
    }
#line 167
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 169
    tmp___1 = tryLogin(hSocket, & psLogin, (psCredSet->psUser)->pUser, psCredSet->pPass);
#line 169
    nState = (enum MODULE_STATE )tmp___1;
    }
#line 171
    if (psLogin->iResult != 1) {
      {
#line 173
      tmp___2 = getNextCredSet(psLogin, psCredSet);
      }
#line 173
      if (tmp___2 == -1) {
        {
#line 175
        writeError(3, "[%s] Error retrieving next credential set to test.", "rlogin.mod");
#line 176
        nState = (enum MODULE_STATE )2;
        }
      } else
#line 180
      if (psCredSet->iStatus == 3) {
        {
#line 182
        writeError(10, "[%s] No more available credential sets to test.", "rlogin.mod");
#line 183
        nState = (enum MODULE_STATE )2;
        }
      } else
#line 185
      if (psCredSet->iStatus == 2) {
        {
#line 187
        writeError(10, "[%s] Starting testing for new user: %s.", "rlogin.mod", (psCredSet->psUser)->pUser);
#line 188
        nState = (enum MODULE_STATE )0;
        }
      } else {
        {
#line 191
        writeError(10, "[%s] Next credential set - user: %s password: %s", "rlogin.mod",
                   (psCredSet->psUser)->pUser, psCredSet->pPass);
        }
      }
    }
#line 194
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (hSocket > 0) {
      {
#line 197
      medusaDisconnect(hSocket);
      }
    }
#line 198
    hSocket = -1;
#line 199
    nState = (enum MODULE_STATE )3;
#line 200
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 202
    writeError(2, "Unknown %s module state %d", "rlogin.mod", (unsigned int )nState);
    }
#line 203
    if (hSocket > 0) {
      {
#line 204
      medusaDisconnect(hSocket);
      }
    }
#line 205
    hSocket = -1;
#line 206
    psLogin->iResult = 1;
#line 207
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  if ((unsigned long )psCredSet != (unsigned long )((void *)0)) {
    {
#line 211
    free((void *)psCredSet);
#line 211
    psCredSet = (sCredentialSet *)((void *)0);
    }
  }
#line 212
  return (0);
}
}
#line 217 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/rlogin.c"
int tryLogin(int hSocket , sLogin **psLogin , char *szLogin , char *szPassword ) 
{ 
  int iRet ;
  unsigned char bufSend[300] ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 223
  nReceiveBufferSize = 0;
#line 226
  memset((void *)(bufSend), 0, sizeof(bufSend));
#line 227
  bufSend[0] = (unsigned char)0;
#line 228
  tmp = strlen((char const   *)szLogin);
#line 228
  strncpy((char */* __restrict  */)(bufSend + 1), (char const   */* __restrict  */)szLogin,
          tmp);
#line 229
  tmp___0 = strlen((char const   *)szLogin);
#line 229
  bufSend[tmp___0 + 1UL] = (unsigned char)0;
#line 230
  tmp___1 = strlen((char const   *)szLogin);
#line 230
  tmp___2 = strlen((char const   *)szLogin);
#line 230
  strncpy((char */* __restrict  */)((bufSend + 2) + tmp___2), (char const   */* __restrict  */)szLogin,
          tmp___1);
#line 231
  tmp___3 = strlen((char const   *)szLogin);
#line 231
  tmp___4 = strlen((char const   *)szLogin);
#line 231
  bufSend[((tmp___3 + 1UL) + tmp___4) + 1UL] = (unsigned char)0;
#line 232
  tmp___5 = strlen((char const   *)szLogin);
#line 232
  tmp___6 = strlen((char const   *)szLogin);
#line 232
  strncpy((char */* __restrict  */)(((((bufSend + 1) + tmp___5) + 1) + tmp___6) + 1),
          (char const   */* __restrict  */)"xterm", (size_t )5);
#line 233
  tmp___7 = strlen((char const   *)szLogin);
#line 233
  tmp___8 = strlen((char const   *)szLogin);
#line 233
  bufSend[(((tmp___7 + 1UL) + tmp___8) + 1UL) + 7UL] = (unsigned char)0;
#line 235
  tmp___9 = strlen((char const   *)szLogin);
#line 235
  tmp___10 = strlen((char const   *)szLogin);
#line 235
  tmp___11 = medusaSend(hSocket, (char *)(bufSend), (int )((((tmp___9 + 1UL) + tmp___10) + 1UL) + 7UL),
                        0);
  }
#line 235
  if (tmp___11 < 0) {
    {
#line 237
    writeError(3, "%s failed: medusaSend was not successful", "rlogin.mod");
    }
  }
  {
#line 240
  nReceiveBufferSize = 0;
#line 241
  tmp___12 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 241
  bufReceive = (unsigned char *)tmp___12;
  }
#line 242
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 244
    writeError(3, "%s failed: medusaReceive returned no data.", "rlogin.mod");
    }
#line 245
    return (-1);
  }
  {
#line 248
  tmp___13 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 248
  bufReceive = (unsigned char *)tmp___13;
  }
#line 249
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 251
    writeError(3, "%s failed: medusaReceive returned no data.", "rlogin.mod");
    }
#line 252
    return (-1);
  } else {
    {
#line 254
    tmp___19 = strstr((char const   *)bufReceive, "Incorrect");
    }
#line 254
    if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
      {
#line 256
      writeError(10, "%s : Login attempt failed here.", "rlogin.mod");
#line 257
      (*psLogin)->iResult = 3;
#line 258
      iRet = 0;
      }
    } else {
      {
#line 260
      tmp___18 = strstr((char const   *)bufReceive, "Password");
      }
#line 260
      if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
        {
#line 262
        writeError(10, "%s : Login attempt asked for password.", "rlogin.mod");
#line 263
        sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"%s\r",
                szPassword);
#line 264
        tmp___14 = strlen((char const   *)(bufSend));
#line 264
        tmp___15 = medusaSend(hSocket, (char *)(bufSend), (int )tmp___14, 0);
        }
#line 264
        if (tmp___15 < 0) {
          {
#line 266
          writeError(3, "%s failed: medusaSend was not successful", "rlogin.mod");
          }
        }
        {
#line 269
        nReceiveBufferSize = 0;
#line 270
        tmp___16 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 270
        bufReceive = (unsigned char *)tmp___16;
        }
#line 271
        if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
          {
#line 273
          writeError(3, "%s failed: medusaReceive returned no data.", "rlogin.mod");
          }
#line 274
          return (-1);
        } else {
          {
#line 276
          tmp___17 = strstr((char const   *)bufReceive, "incorrect");
          }
#line 276
          if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
            {
#line 278
            writeError(10, "%s : Login attempt failed here.", "rlogin.mod");
#line 279
            (*psLogin)->iResult = 3;
#line 280
            iRet = 0;
            }
          } else {
            {
#line 284
            writeError(10, "%s : Login attempt succeeded via password send.", "rlogin.mod");
#line 285
            (*psLogin)->iResult = 2;
#line 286
            iRet = 2;
            }
          }
        }
      } else {
        {
#line 292
        writeError(6, "%s : Login attempt succeeded via .rhosts", "rlogin.mod");
#line 293
        (*psLogin)->iResult = 2;
#line 294
        iRet = 2;
        }
      }
    }
  }
#line 297
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 297
    free((void *)bufReceive);
#line 297
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 298
  setPassResult(*psLogin, szPassword);
  }
#line 300
  return (iRet);
}
}
#line 50 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) bzero)(void *__s ,
                                                                             size_t __n ) ;
#line 68 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
static void SHA1PadMessage(SHA1_CONTEXT *context ) ;
#line 69
static void SHA1ProcessMessageBlock(SHA1_CONTEXT *context ) ;
#line 89 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
uint32 const   sha_const_key[5]  = {      (uint32 const   )1732584193,      (uint32 const   )4023233417U,      (uint32 const   )2562383102U,      (uint32 const   )271733878, 
        (uint32 const   )3285377520U};
#line 99 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
int sha1_reset(SHA1_CONTEXT *context ) 
{ 


  {
#line 102
  if (! context) {
#line 103
    return (1);
  }
#line 106
  context->Length = (ulonglong )0;
#line 107
  context->Message_Block_Index = (int16 )0;
#line 109
  context->Intermediate_Hash[0] = (uint32 )sha_const_key[0];
#line 110
  context->Intermediate_Hash[1] = (uint32 )sha_const_key[1];
#line 111
  context->Intermediate_Hash[2] = (uint32 )sha_const_key[2];
#line 112
  context->Intermediate_Hash[3] = (uint32 )sha_const_key[3];
#line 113
  context->Intermediate_Hash[4] = (uint32 )sha_const_key[4];
#line 115
  context->Computed = 0;
#line 116
  context->Corrupted = 0;
#line 118
  return (0);
}
}
#line 139 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
int sha1_result(SHA1_CONTEXT *context , uint8 *Message_Digest ) 
{ 
  int i ;

  {
#line 145
  if (! context) {
#line 146
    return (1);
  } else
#line 145
  if (! Message_Digest) {
#line 146
    return (1);
  }
#line 148
  if (context->Corrupted) {
#line 149
    return (context->Corrupted);
  }
#line 152
  if (! context->Computed) {
    {
#line 154
    SHA1PadMessage(context);
#line 156
    bzero((void *)((char *)(context->Message_Block)), (size_t )64);
#line 157
    context->Length = (ulonglong )0;
#line 158
    context->Computed = 1;
    }
  }
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < 20)) {
#line 161
      goto while_break;
    }
#line 162
    *(Message_Digest + i) = (uint8 )((int8 )(context->Intermediate_Hash[i >> 2] >> 8 * (3 - (i & 3))));
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return (0);
}
}
#line 183 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
int sha1_input(SHA1_CONTEXT *context , uint8 const   *message_array , unsigned int length ) 
{ 
  int tmp ;
  int16 tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 186
  if (! length) {
#line 187
    return (0);
  }
#line 191
  if (! context) {
#line 192
    return (1);
  } else
#line 191
  if (! message_array) {
#line 192
    return (1);
  }
#line 193
  if (context->Computed) {
#line 194
    tmp = 3;
#line 194
    context->Corrupted = tmp;
#line 194
    return (tmp);
  }
#line 195
  if (context->Corrupted) {
#line 196
    return (context->Corrupted);
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    tmp___2 = length;
#line 199
    length --;
#line 199
    if (! tmp___2) {
#line 199
      goto while_break;
    }
#line 201
    tmp___0 = context->Message_Block_Index;
#line 201
    context->Message_Block_Index = (int16 )((int )context->Message_Block_Index + 1);
#line 201
    context->Message_Block[tmp___0] = (uint8 )((int const   )*message_array & 255);
#line 203
    context->Length += 8ULL;
#line 210
    if (context->Length == 0ULL) {
#line 211
      tmp___1 = 1;
#line 211
      context->Corrupted = tmp___1;
#line 211
      return (tmp___1);
    }
#line 214
    if ((int )context->Message_Block_Index == 64) {
      {
#line 216
      SHA1ProcessMessageBlock(context);
      }
    }
#line 218
    message_array ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (0);
}
}
#line 237 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
static uint32 const   K[4]  = {      (uint32 const   )1518500249,      (uint32 const   )1859775393,      (uint32 const   )2400959708U,      (uint32 const   )3395469782U};
#line 246 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
static void SHA1ProcessMessageBlock(SHA1_CONTEXT *context ) 
{ 
  int t ;
  uint32 temp ;
  uint32 W[80] ;
  uint32 A___2 ;
  uint32 B___2 ;
  uint32 C___2 ;
  uint32 D___2 ;
  uint32 E ;
  int index___0 ;

  {
#line 258
  t = 0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (t < 16)) {
#line 258
      goto while_break;
    }
#line 260
    index___0 = t * 4;
#line 261
    W[t] = (uint32 )((int )context->Message_Block[index___0] << 24);
#line 262
    W[t] |= (unsigned int )((int )context->Message_Block[index___0 + 1] << 16);
#line 263
    W[t] |= (unsigned int )((int )context->Message_Block[index___0 + 2] << 8);
#line 264
    W[t] |= (unsigned int )context->Message_Block[index___0 + 3];
#line 258
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  t = 16;
  {
#line 268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 268
    if (! (t < 80)) {
#line 268
      goto while_break___0;
    }
#line 270
    W[t] = ((((W[t - 3] ^ W[t - 8]) ^ W[t - 14]) ^ W[t - 16]) << 1) | ((((W[t - 3] ^ W[t - 8]) ^ W[t - 14]) ^ W[t - 16]) >> 31);
#line 268
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 273
  A___2 = context->Intermediate_Hash[0];
#line 274
  B___2 = context->Intermediate_Hash[1];
#line 275
  C___2 = context->Intermediate_Hash[2];
#line 276
  D___2 = context->Intermediate_Hash[3];
#line 277
  E = context->Intermediate_Hash[4];
#line 279
  t = 0;
  {
#line 279
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 279
    if (! (t < 20)) {
#line 279
      goto while_break___1;
    }
#line 281
    temp = (((((A___2 << 5) | (A___2 >> 27)) + ((B___2 & C___2) | (~ B___2 & D___2))) + E) + W[t]) + (unsigned int )K[0];
#line 282
    E = D___2;
#line 283
    D___2 = C___2;
#line 284
    C___2 = (B___2 << 30) | (B___2 >> 2);
#line 285
    B___2 = A___2;
#line 286
    A___2 = temp;
#line 279
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 289
  t = 20;
  {
#line 289
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 289
    if (! (t < 40)) {
#line 289
      goto while_break___2;
    }
#line 291
    temp = (((((A___2 << 5) | (A___2 >> 27)) + ((B___2 ^ C___2) ^ D___2)) + E) + W[t]) + (unsigned int )K[1];
#line 292
    E = D___2;
#line 293
    D___2 = C___2;
#line 294
    C___2 = (B___2 << 30) | (B___2 >> 2);
#line 295
    B___2 = A___2;
#line 296
    A___2 = temp;
#line 289
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 299
  t = 40;
  {
#line 299
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 299
    if (! (t < 60)) {
#line 299
      goto while_break___3;
    }
#line 301
    temp = (((((A___2 << 5) | (A___2 >> 27)) + (((B___2 & C___2) | (B___2 & D___2)) | (C___2 & D___2))) + E) + W[t]) + (unsigned int )K[2];
#line 303
    E = D___2;
#line 304
    D___2 = C___2;
#line 305
    C___2 = (B___2 << 30) | (B___2 >> 2);
#line 306
    B___2 = A___2;
#line 307
    A___2 = temp;
#line 299
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 310
  t = 60;
  {
#line 310
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 310
    if (! (t < 80)) {
#line 310
      goto while_break___4;
    }
#line 312
    temp = (((((A___2 << 5) | (A___2 >> 27)) + ((B___2 ^ C___2) ^ D___2)) + E) + W[t]) + (unsigned int )K[3];
#line 313
    E = D___2;
#line 314
    D___2 = C___2;
#line 315
    C___2 = (B___2 << 30) | (B___2 >> 2);
#line 316
    B___2 = A___2;
#line 317
    A___2 = temp;
#line 310
    t ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 320
  context->Intermediate_Hash[0] += A___2;
#line 321
  context->Intermediate_Hash[1] += B___2;
#line 322
  context->Intermediate_Hash[2] += C___2;
#line 323
  context->Intermediate_Hash[3] += D___2;
#line 324
  context->Intermediate_Hash[4] += E;
#line 326
  context->Message_Block_Index = (int16 )0;
#line 327
  return;
}
}
#line 349 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/sha1.c"
static void SHA1PadMessage(SHA1_CONTEXT *context ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 358
  i = (int )context->Message_Block_Index;
#line 360
  if (i > 55) {
    {
#line 362
    tmp = i;
#line 362
    i ++;
#line 362
    context->Message_Block[tmp] = (uint8 )128;
#line 363
    bzero((void *)((char *)(& context->Message_Block[i])), sizeof(context->Message_Block[0]) * (unsigned long )(64 - i));
#line 365
    context->Message_Block_Index = (int16 )64;
#line 368
    SHA1ProcessMessageBlock(context);
#line 370
    bzero((void *)((char *)(& context->Message_Block[0])), sizeof(context->Message_Block[0]) * 56UL);
#line 372
    context->Message_Block_Index = (int16 )56;
    }
  } else {
    {
#line 376
    tmp___0 = i;
#line 376
    i ++;
#line 376
    context->Message_Block[tmp___0] = (uint8 )128;
#line 377
    bzero((void *)((char *)(& context->Message_Block[i])), sizeof(context->Message_Block[0]) * (unsigned long )(56 - i));
#line 379
    context->Message_Block_Index = (int16 )56;
    }
  }
  {
#line 386
  context->Message_Block[56] = (uint8 )((int8 )(context->Length >> 56));
#line 387
  context->Message_Block[57] = (uint8 )((int8 )(context->Length >> 48));
#line 388
  context->Message_Block[58] = (uint8 )((int8 )(context->Length >> 40));
#line 389
  context->Message_Block[59] = (uint8 )((int8 )(context->Length >> 32));
#line 390
  context->Message_Block[60] = (uint8 )((int8 )(context->Length >> 24));
#line 391
  context->Message_Block[61] = (uint8 )((int8 )(context->Length >> 16));
#line 392
  context->Message_Block[62] = (uint8 )((int8 )(context->Length >> 8));
#line 393
  context->Message_Block[63] = (uint8 )((int8 )context->Length);
#line 395
  SHA1ProcessMessageBlock(context);
  }
#line 396
  return;
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 359 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 283 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
int MySQLSessionQuit(int hSocket ) 
{ 
  char com_quit_packet[5] ;
  int tmp ;

  {
  {
#line 285
  com_quit_packet[0] = (char)1;
#line 285
  com_quit_packet[1] = (char)0;
#line 285
  com_quit_packet[2] = (char)0;
#line 285
  com_quit_packet[3] = (char)0;
#line 285
  com_quit_packet[4] = (char)1;
#line 287
  tmp = medusaSend(hSocket, com_quit_packet, 5, 0);
  }
#line 287
  if (tmp < 0) {
    {
#line 289
    writeError(3, "%s failed: medusaSend was not successful", "mysql.mod");
    }
#line 290
    return (-1);
  }
#line 293
  return (0);
}
}
#line 305 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
void randominit(struct rand_struct *rand_st , unsigned long seed1 , unsigned long seed2 ) 
{ 


  {
#line 308
  rand_st->max_value = 1073741823UL;
#line 309
  rand_st->max_value_dbl = (double )rand_st->max_value;
#line 310
  rand_st->seed1 = seed1 % rand_st->max_value;
#line 311
  rand_st->seed2 = seed2 % rand_st->max_value;
#line 312
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
double rnd(struct rand_struct *rand_st ) 
{ 


  {
#line 316
  rand_st->seed1 = (rand_st->seed1 * 3UL + rand_st->seed2) % rand_st->max_value;
#line 317
  rand_st->seed2 = ((rand_st->seed1 + rand_st->seed2) + 33UL) % rand_st->max_value;
#line 318
  return ((double )rand_st->seed1 / rand_st->max_value_dbl);
}
}
#line 341 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
void hash_password(ulong___0 *result , char const   *password , uint password_len ) 
{ 
  register ulong___0 nr ;
  register ulong___0 add ;
  register ulong___0 nr2 ;
  ulong___0 tmp ;
  char const   *password_end ;

  {
#line 343
  nr = (ulong___0 )1345345333L;
#line 343
  add = (ulong___0 )7;
#line 343
  nr2 = (ulong___0 )305419889L;
#line 345
  password_end = password + password_len;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! ((unsigned long )password < (unsigned long )password_end)) {
#line 346
      goto while_break;
    }
#line 348
    if ((int const   )*password == 32) {
#line 349
      goto __Cont;
    } else
#line 348
    if ((int const   )*password == 9) {
#line 349
      goto __Cont;
    }
#line 350
    tmp = (ulong___0 )((uchar )*password);
#line 351
    nr ^= ((nr & 63UL) + add) * tmp + (nr << 8);
#line 352
    nr2 += (nr2 << 8) ^ nr;
#line 353
    add += tmp;
    __Cont: /* CIL Label */ 
#line 346
    password ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  *(result + 0) = nr & ((1UL << 31) - 1UL);
#line 356
  *(result + 1) = nr2 & ((1UL << 31) - 1UL);
#line 357
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
void octet2hex(char *to , uint8 const   *str , unsigned int len ) 
{ 
  char _dig_vec_upper[37] ;
  uint8 const   *str_end ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 361
  _dig_vec_upper[0] = (char )'0';
#line 361
  _dig_vec_upper[1] = (char )'1';
#line 361
  _dig_vec_upper[2] = (char )'2';
#line 361
  _dig_vec_upper[3] = (char )'3';
#line 361
  _dig_vec_upper[4] = (char )'4';
#line 361
  _dig_vec_upper[5] = (char )'5';
#line 361
  _dig_vec_upper[6] = (char )'6';
#line 361
  _dig_vec_upper[7] = (char )'7';
#line 361
  _dig_vec_upper[8] = (char )'8';
#line 361
  _dig_vec_upper[9] = (char )'9';
#line 361
  _dig_vec_upper[10] = (char )'A';
#line 361
  _dig_vec_upper[11] = (char )'B';
#line 361
  _dig_vec_upper[12] = (char )'C';
#line 361
  _dig_vec_upper[13] = (char )'D';
#line 361
  _dig_vec_upper[14] = (char )'E';
#line 361
  _dig_vec_upper[15] = (char )'F';
#line 361
  _dig_vec_upper[16] = (char )'G';
#line 361
  _dig_vec_upper[17] = (char )'H';
#line 361
  _dig_vec_upper[18] = (char )'I';
#line 361
  _dig_vec_upper[19] = (char )'J';
#line 361
  _dig_vec_upper[20] = (char )'K';
#line 361
  _dig_vec_upper[21] = (char )'L';
#line 361
  _dig_vec_upper[22] = (char )'M';
#line 361
  _dig_vec_upper[23] = (char )'N';
#line 361
  _dig_vec_upper[24] = (char )'O';
#line 361
  _dig_vec_upper[25] = (char )'P';
#line 361
  _dig_vec_upper[26] = (char )'Q';
#line 361
  _dig_vec_upper[27] = (char )'R';
#line 361
  _dig_vec_upper[28] = (char )'S';
#line 361
  _dig_vec_upper[29] = (char )'T';
#line 361
  _dig_vec_upper[30] = (char )'U';
#line 361
  _dig_vec_upper[31] = (char )'V';
#line 361
  _dig_vec_upper[32] = (char )'W';
#line 361
  _dig_vec_upper[33] = (char )'X';
#line 361
  _dig_vec_upper[34] = (char )'Y';
#line 361
  _dig_vec_upper[35] = (char )'Z';
#line 361
  _dig_vec_upper[36] = (char )'\000';
#line 362
  str_end = str + len;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! ((unsigned long )str != (unsigned long )str_end)) {
#line 363
      goto while_break;
    }
#line 365
    tmp = to;
#line 365
    to ++;
#line 365
    *tmp = _dig_vec_upper[((int const   )*str & 240) >> 4];
#line 366
    tmp___0 = to;
#line 366
    to ++;
#line 366
    *tmp___0 = _dig_vec_upper[(int const   )*str & 15];
#line 363
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  *to = (char )'\000';
#line 369
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
void hex2octet(uint8 *to , char const   *str , uint len ) 
{ 
  char const   *str_end ;
  register char tmp ;
  char const   *tmp___2 ;
  char const   *tmp___5 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  uint8 *tmp___18 ;
  char const   *tmp___21 ;
  char const   *tmp___24 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;

  {
#line 373
  str_end = str + len;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! ((unsigned long )str < (unsigned long )str_end)) {
#line 374
      goto while_break;
    }
#line 376
    tmp___16 = str;
#line 376
    str ++;
#line 376
    if ((int const   )*tmp___16 >= 48) {
#line 376
      tmp___17 = str;
#line 376
      str ++;
#line 376
      if ((int const   )*tmp___17 <= 57) {
#line 376
        tmp___2 = str;
#line 376
        str ++;
#line 376
        tmp___15 = (int const   )*tmp___2 - 48;
      } else {
#line 376
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 376
      tmp___13 = str;
#line 376
      str ++;
#line 376
      if ((int const   )*tmp___13 >= 65) {
#line 376
        tmp___14 = str;
#line 376
        str ++;
#line 376
        if ((int const   )*tmp___14 <= 90) {
#line 376
          tmp___5 = str;
#line 376
          str ++;
#line 376
          tmp___12 = ((int const   )*tmp___5 - 65) + 10;
        } else {
#line 376
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 376
        tmp___10 = str;
#line 376
        str ++;
#line 376
        if ((int const   )*tmp___10 >= 97) {
#line 376
          tmp___11 = str;
#line 376
          str ++;
#line 376
          if ((int const   )*tmp___11 <= 122) {
#line 376
            tmp___8 = str;
#line 376
            str ++;
#line 376
            tmp___9 = ((int const   )*tmp___8 - 97) + 10;
          } else {
#line 376
            tmp___9 = (int const   )'\177';
          }
        } else {
#line 376
          tmp___9 = (int const   )'\177';
        }
#line 376
        tmp___12 = tmp___9;
      }
#line 376
      tmp___15 = tmp___12;
    }
#line 376
    tmp = (char )tmp___15;
#line 377
    tmp___18 = to;
#line 377
    to ++;
#line 377
    tmp___35 = str;
#line 377
    str ++;
#line 377
    if ((int const   )*tmp___35 >= 48) {
#line 377
      tmp___36 = str;
#line 377
      str ++;
#line 377
      if ((int const   )*tmp___36 <= 57) {
#line 377
        tmp___21 = str;
#line 377
        str ++;
#line 377
        tmp___34 = (int const   )*tmp___21 - 48;
      } else {
#line 377
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 377
      tmp___32 = str;
#line 377
      str ++;
#line 377
      if ((int const   )*tmp___32 >= 65) {
#line 377
        tmp___33 = str;
#line 377
        str ++;
#line 377
        if ((int const   )*tmp___33 <= 90) {
#line 377
          tmp___24 = str;
#line 377
          str ++;
#line 377
          tmp___31 = ((int const   )*tmp___24 - 65) + 10;
        } else {
#line 377
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 377
        tmp___29 = str;
#line 377
        str ++;
#line 377
        if ((int const   )*tmp___29 >= 97) {
#line 377
          tmp___30 = str;
#line 377
          str ++;
#line 377
          if ((int const   )*tmp___30 <= 122) {
#line 377
            tmp___27 = str;
#line 377
            str ++;
#line 377
            tmp___28 = ((int const   )*tmp___27 - 97) + 10;
          } else {
#line 377
            tmp___28 = (int const   )'\177';
          }
        } else {
#line 377
          tmp___28 = (int const   )'\177';
        }
#line 377
        tmp___31 = tmp___28;
      }
#line 377
      tmp___34 = tmp___31;
    }
#line 377
    *tmp___18 = (uint8 )(((int )tmp << 4) | (int )tmp___34);
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return;
}
}
#line 381 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
static void my_crypt(char *to , uchar const   *s1 , uchar const   *s2 , uint len ) 
{ 
  uint8 const   *s1_end ;
  char *tmp ;
  uchar const   *tmp___0 ;
  uchar const   *tmp___1 ;

  {
#line 383
  s1_end = s1 + len;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! ((unsigned long )s1 < (unsigned long )s1_end)) {
#line 384
      goto while_break;
    }
#line 385
    tmp = to;
#line 385
    to ++;
#line 385
    tmp___0 = s1;
#line 385
    s1 ++;
#line 385
    tmp___1 = s2;
#line 385
    s2 ++;
#line 385
    *tmp = (char )((int const   )*tmp___0 ^ (int const   )*tmp___1);
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  return;
}
}
#line 388 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
double my_rnd(struct rand_struct *rand_st ) 
{ 


  {
#line 390
  rand_st->seed1 = (rand_st->seed1 * 3UL + rand_st->seed2) % rand_st->max_value;
#line 391
  rand_st->seed2 = ((rand_st->seed1 + rand_st->seed2) + 33UL) % rand_st->max_value;
#line 392
  return ((double )rand_st->seed1 / rand_st->max_value_dbl);
}
}
#line 395 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
void scramble_323(char *to , _MYSQL_DATA *_psSessionData , char const   *message ,
                  char const   *password ) 
{ 
  struct rand_struct rand_st ;
  ulong___0 hash_pass[2] ;
  ulong___0 hash_message[2] ;
  char extra ;
  char *to_start ;
  char const   *message_end ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;

  {
#line 400
  if (password) {
#line 400
    if (*(password + 0)) {
#line 402
      to_start = to;
#line 403
      message_end = message + 8;
#line 406
      if (_psSessionData->hashFlag == 2) {
        {
#line 408
        tmp = strlen(password);
        }
#line 408
        if (tmp != 16UL) {
          {
#line 409
          writeError(3, "[%s] Invalid Hash Type (Old Style Hash Required)", "mysql.mod");
          }
        }
        {
#line 411
        sscanf((char const   */* __restrict  */)password, (char const   */* __restrict  */)"%08lx%08lx",
               & hash_pass[0], & hash_pass[1]);
        }
      } else {
        {
#line 414
        tmp___0 = strlen(password);
#line 414
        hash_password(hash_pass, password, (uint )tmp___0);
        }
      }
      {
#line 416
      hash_password(hash_message, message, (uint )8);
#line 417
      randominit(& rand_st, hash_pass[0] ^ hash_message[0], hash_pass[1] ^ hash_message[1]);
      }
      {
#line 418
      while (1) {
        while_continue: /* CIL Label */ ;
#line 418
        if (! ((unsigned long )message < (unsigned long )message_end)) {
#line 418
          goto while_break;
        }
        {
#line 419
        tmp___1 = to;
#line 419
        to ++;
#line 419
        tmp___2 = my_rnd(& rand_st);
#line 419
        tmp___3 = floor(tmp___2 * (double )31);
#line 419
        *tmp___1 = (char )(tmp___3 + (double )64);
#line 418
        message ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 420
      tmp___4 = my_rnd(& rand_st);
#line 420
      tmp___5 = floor(tmp___4 * (double )31);
#line 420
      extra = (char )tmp___5;
      }
      {
#line 421
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 421
        if (! ((unsigned long )to_start != (unsigned long )to)) {
#line 421
          goto while_break___0;
        }
#line 422
        tmp___6 = to_start;
#line 422
        to_start ++;
#line 422
        *tmp___6 = (char )((int )*tmp___6 ^ (int )extra);
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 424
  *to = (char)0;
#line 425
  return;
}
}
#line 427 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
void scramble(char *to , _MYSQL_DATA *_psSessionData , char const   *message , char const   *password ) 
{ 
  SHA1_CONTEXT sha1_context ;
  uint8 hash_stage1[20] ;
  uint8 hash_stage2[20] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 433
  sha1_reset(& sha1_context);
  }
#line 440
  if (_psSessionData->hashFlag == 2) {
    {
#line 441
    tmp = strncmp(password, "*", (size_t )1);
    }
#line 441
    if (tmp == 0) {
      {
#line 441
      tmp___0 = strlen(password);
      }
#line 441
      if (tmp___0 == 41UL) {
        {
#line 442
        writeError(3, "[%s] MySQL 4.1 and above use a SHA1-based authentication scheme which does not appear to be susceptible to pass-the-hash style attacks.",
                   "mysql.mod");
        }
      }
    }
  }
  {
#line 445
  tmp___1 = strlen(password);
#line 445
  sha1_input(& sha1_context, (uint8 *)password, tmp___1);
#line 446
  sha1_result(& sha1_context, hash_stage1);
#line 448
  sha1_reset(& sha1_context);
#line 449
  sha1_input(& sha1_context, hash_stage1, 20);
#line 450
  sha1_result(& sha1_context, hash_stage2);
#line 452
  sha1_reset(& sha1_context);
#line 453
  sha1_input(& sha1_context, (uint8 const   *)message, 20);
#line 454
  sha1_input(& sha1_context, hash_stage2, 20);
#line 456
  sha1_result(& sha1_context, (uint8 *)to);
#line 457
  my_crypt(to, (uchar const   *)to, (uchar const   *)(hash_stage1), (uint )20);
  }
#line 458
  return;
}
}
#line 462 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
int MySQLPrepareAuthOld(_MYSQL_DATA *_psSessionData , char *szLogin , char *szPassword ,
                        char *szSessionSalt , unsigned char **szResponse , unsigned long *iResponseLength ) 
{ 
  unsigned char *response ;
  int login_len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int response_len ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 466
  tmp___2 = strlen((char const   *)szLogin);
  }
#line 466
  if (tmp___2 > 16UL) {
#line 466
    tmp___1 = (size_t )16;
  } else {
    {
#line 466
    tmp___0 = strlen((char const   *)szLogin);
#line 466
    tmp___1 = tmp___0;
    }
  }
  {
#line 466
  login_len = (int )tmp___1;
#line 467
  response_len = ((9 + login_len) + 1) + 8;
#line 475
  tmp___3 = malloc((size_t )(response_len + 1));
#line 475
  response = (unsigned char *)tmp___3;
#line 476
  memset((void *)response, 0, (size_t )(response_len + 1));
#line 478
  *(response + 0) = (unsigned char )(response_len - 4);
#line 479
  *(response + 1) = (unsigned char)0;
#line 480
  *(response + 2) = (unsigned char)0;
#line 481
  *(response + 3) = (unsigned char)1;
#line 483
  *(response + 4) = (unsigned char)133;
#line 484
  *(response + 5) = (unsigned char)36;
#line 486
  *(response + 6) = (unsigned char)0;
#line 487
  *(response + 7) = (unsigned char)0;
#line 488
  *(response + 8) = (unsigned char)0;
#line 490
  strncpy((char */* __restrict  */)(response + 9), (char const   */* __restrict  */)szLogin,
          (size_t )login_len);
#line 492
  *(response + (9 + login_len)) = (unsigned char )'\000';
#line 494
  tmp___4 = strcmp((char const   *)szPassword, "");
  }
#line 494
  if (tmp___4 != 0) {
    {
#line 495
    scramble_323((char *)(response + ((9 + login_len) + 1)), _psSessionData, (char const   *)szSessionSalt,
                 (char const   *)szPassword);
    }
  }
#line 497
  *iResponseLength = (unsigned long )response_len;
#line 498
  *szResponse = response;
#line 499
  return (0);
}
}
#line 508 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
int MySQLPrepareAuthNewOld(_MYSQL_DATA *_psSessionData , char *szLogin , char *szPassword ,
                           char *szSessionSalt , unsigned char **szResponse , unsigned long *iResponseLength ) 
{ 
  unsigned char *response ;
  int login_len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int response_len ;
  void *tmp___3 ;

  {
  {
#line 512
  tmp___2 = strlen((char const   *)szLogin);
  }
#line 512
  if (tmp___2 > 16UL) {
#line 512
    tmp___1 = (size_t )16;
  } else {
    {
#line 512
    tmp___0 = strlen((char const   *)szLogin);
#line 512
    tmp___1 = tmp___0;
    }
  }
  {
#line 512
  login_len = (int )tmp___1;
#line 513
  response_len = 13;
#line 517
  tmp___3 = malloc((size_t )(response_len + 1));
#line 517
  response = (unsigned char *)tmp___3;
#line 518
  memset((void *)response, 0, (size_t )(response_len + 1));
#line 520
  *(response + 0) = (unsigned char )(response_len - 4);
#line 521
  *(response + 3) = (unsigned char)3;
#line 522
  scramble_323((char *)(response + 4), _psSessionData, (char const   *)szSessionSalt,
               (char const   *)szPassword);
#line 524
  *iResponseLength = (unsigned long )response_len;
#line 525
  *szResponse = response;
  }
#line 526
  return (0);
}
}
#line 530 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
int MySQLPrepareAuth(_MYSQL_DATA *_psSessionData , char *szLogin , char *szPassword ,
                     char *szSessionSalt , unsigned char **szResponse , unsigned long *iResponseLength ) 
{ 
  unsigned char *response ;
  int login_len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int response_len ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 534
  tmp___2 = strlen((char const   *)szLogin);
  }
#line 534
  if (tmp___2 > 16UL) {
#line 534
    tmp___1 = (size_t )16;
  } else {
    {
#line 534
    tmp___0 = strlen((char const   *)szLogin);
#line 534
    tmp___1 = tmp___0;
    }
  }
  {
#line 534
  login_len = (int )tmp___1;
#line 535
  response_len = ((36 + login_len) + 1) + 1;
#line 544
  tmp___3 = strcmp((char const   *)szPassword, "");
  }
#line 544
  if (tmp___3 != 0) {
#line 545
    response_len += 20;
  }
  {
#line 547
  tmp___4 = malloc((size_t )(response_len + 1));
#line 547
  response = (unsigned char *)tmp___4;
#line 548
  memset((void *)response, 0, (size_t )(response_len + 1));
#line 550
  *(response + 0) = (unsigned char )(response_len - 4);
#line 551
  *(response + 1) = (unsigned char)0;
#line 552
  *(response + 2) = (unsigned char)0;
#line 553
  *(response + 3) = (unsigned char)1;
#line 556
  *(response + 4) = (unsigned char)5;
#line 558
  *(response + 5) = (unsigned char)166;
#line 559
  *(response + 6) = (unsigned char)3;
#line 560
  *(response + 7) = (unsigned char)0;
#line 562
  *(response + 8) = (unsigned char)0;
#line 563
  *(response + 9) = (unsigned char)0;
#line 564
  *(response + 10) = (unsigned char)0;
#line 565
  *(response + 11) = (unsigned char)1;
#line 567
  *(response + 12) = (unsigned char)33;
#line 569
  strncpy((char */* __restrict  */)(response + 36), (char const   */* __restrict  */)szLogin,
          (size_t )login_len);
#line 571
  tmp___5 = strcmp((char const   *)szPassword, "");
  }
#line 571
  if (tmp___5 == 0) {
#line 573
    *(response + ((36 + login_len) + 1)) = (unsigned char)0;
  } else {
    {
#line 577
    *(response + ((36 + login_len) + 1)) = (unsigned char)20;
#line 580
    scramble((char *)(response + (((36 + login_len) + 1) + 1)), _psSessionData, (char const   *)szSessionSalt,
             (char const   *)szPassword);
    }
  }
#line 583
  *iResponseLength = (unsigned long )response_len;
#line 584
  *szResponse = response;
#line 585
  return (0);
}
}
#line 588 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/mysql.c"
int MySQLSessionInit(int hSocket , unsigned char **szSessionSalt ) 
{ 
  unsigned char *bufReceive ;
  unsigned char *szServerVersion ;
  int nReceiveBufferSize ;
  int newerauth ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 592
  nReceiveBufferSize = 0;
#line 593
  newerauth = 0;
#line 595
  tmp = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 595
  bufReceive = (unsigned char *)tmp;
  }
#line 596
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 598
    writeError(3, "%s failed: medusaReceive returned no data.", "mysql.mod");
    }
#line 599
    return (-1);
  }
#line 603
  if ((int )*(bufReceive + 4) == 255) {
    {
#line 605
    tmp___0 = strstr((char const   *)(bufReceive + 7), "is not allowed to connect to this MySQL server");
    }
#line 605
    if (tmp___0) {
      {
#line 607
      writeError(4, "%s: Server responded that host is not allowed to connect to MySQL service.",
                 "mysql.mod");
      }
#line 608
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 608
        free((void *)bufReceive);
#line 608
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 609
      return (-1);
    } else {
      {
#line 613
      writeError(3, "%s: Failed to retrieve server version: %s", "mysql.mod", bufReceive + 7);
      }
#line 614
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 614
        free((void *)bufReceive);
#line 614
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 615
      return (-1);
    }
  }
#line 619
  if ((int )*(bufReceive + 4) < 10) {
    {
#line 621
    writeError(3, "%s: Server responded requesting protocol version (%d). Version 10 support required.",
               "mysql.mod", (int )*(bufReceive + 4));
    }
#line 622
    if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
      {
#line 622
      free((void *)bufReceive);
#line 622
      bufReceive = (unsigned char *)((void *)0);
      }
    }
#line 623
    return (-1);
  } else
#line 625
  if ((int )*(bufReceive + 4) > 10) {
    {
#line 627
    writeError(4, "%s: Server responded requesting protocol version (%d). Support for versions >10 is unknown.",
               "mysql.mod", (int )*(bufReceive + 4));
    }
  }
  {
#line 631
  szServerVersion = bufReceive + 5;
#line 633
  tmp___1 = strstr((char const   *)szServerVersion, "3.");
  }
#line 633
  if (! tmp___1) {
    {
#line 633
    tmp___2 = strstr((char const   *)szServerVersion, "4.");
    }
#line 633
    if (! tmp___2) {
      {
#line 633
      tmp___3 = strstr((char const   *)szServerVersion, "5.");
      }
#line 633
      if (! tmp___3) {
        {
#line 635
        writeError(3, "%s: Server responded requesting version (%d). Only versions 3.x, 4.x, and 5.x are currently supported.",
                   "mysql.mod", szServerVersion);
        }
#line 636
        if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
          {
#line 636
          free((void *)bufReceive);
#line 636
          bufReceive = (unsigned char *)((void *)0);
          }
        }
#line 637
        return (-1);
      }
    }
  }
  {
#line 640
  tmp___4 = strstr((char const   *)szServerVersion, "4.1");
  }
#line 640
  if (tmp___4) {
    {
#line 642
    newerauth = 1;
#line 643
    writeError(10, "%s: Server version %s is using newer auth method.", "mysql.mod",
               szServerVersion);
    }
  } else {
    {
#line 640
    tmp___5 = strstr((char const   *)szServerVersion, "5.");
    }
#line 640
    if (tmp___5) {
      {
#line 642
      newerauth = 1;
#line 643
      writeError(10, "%s: Server version %s is using newer auth method.", "mysql.mod",
                 szServerVersion);
      }
    }
  }
#line 646
  if (newerauth) {
    {
#line 649
    tmp___6 = malloc((size_t )22);
#line 649
    *szSessionSalt = (unsigned char *)tmp___6;
#line 650
    memset((void *)*szSessionSalt, 0, (size_t )22);
#line 651
    tmp___7 = strlen((char const   *)szServerVersion);
#line 651
    memcpy((void */* __restrict  */)*szSessionSalt, (void const   */* __restrict  */)((bufReceive + tmp___7) + 10),
           (size_t )9);
#line 652
    tmp___8 = strlen((char const   *)szServerVersion);
#line 652
    memcpy((void */* __restrict  */)(*szSessionSalt + 8), (void const   */* __restrict  */)((bufReceive + tmp___8) + 37),
           (size_t )12);
#line 654
    tmp___9 = strlen((char const   *)*szSessionSalt);
    }
#line 654
    if (tmp___9 != 20UL) {
      {
#line 656
      writeError(3, "%s: Failed to retrieve valid session salt.", "mysql.mod");
      }
#line 657
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 657
        free((void *)bufReceive);
#line 657
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 658
      return (-1);
    } else {
      {
#line 662
      writeError(10, "%s: Retrieved session salt: %s", "mysql.mod", *szSessionSalt);
      }
    }
  } else {
    {
#line 668
    tmp___10 = malloc((size_t )10);
#line 668
    *szSessionSalt = (unsigned char *)tmp___10;
#line 669
    memset((void *)*szSessionSalt, 0, (size_t )10);
#line 670
    tmp___11 = strlen((char const   *)szServerVersion);
#line 670
    memcpy((void */* __restrict  */)*szSessionSalt, (void const   */* __restrict  */)((bufReceive + tmp___11) + 10),
           (size_t )9);
#line 672
    tmp___12 = strlen((char const   *)*szSessionSalt);
    }
#line 672
    if (tmp___12 != 8UL) {
      {
#line 673
      writeError(3, "%s: Failed to retrieve valid session salt.", "mysql.mod");
      }
#line 674
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 674
        free((void *)bufReceive);
#line 674
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 675
      return (-1);
    } else {
      {
#line 679
      writeError(10, "%s: Retrieved session salt: %s.", "mysql.mod", *szSessionSalt);
      }
    }
  }
#line 683
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 683
    free((void *)bufReceive);
#line 683
    bufReceive = (unsigned char *)((void *)0);
    }
  }
#line 684
  return (0);
}
}
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 74 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int sendRead(int hSocket , _SNMP_DATA *_psSessionData , char *szPassword ) ;
#line 75
int sendWrite(int hSocket , _SNMP_DATA *_psSessionData , char *szPassword , char *szLocation ) ;
#line 76
int receiveRequest(int hSocket , _SNMP_DATA *_psSessionData , int *nPassCount , char ***arrszPassList ,
                   char **szLocation ) ;
#line 427 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int parseLength(int nReceiveBufferSize , unsigned char *bufReceive ) 
{ 
  int nLength ;
  int nOctets ;

  {
#line 429
  nLength = 0;
#line 430
  nOctets = 0;
#line 432
  if ((int )*(bufReceive + 0) == 48) {
#line 434
    if ((int )*(bufReceive + 1) & 128) {
#line 436
      nOctets = (int )*(bufReceive + 1) & 127;
#line 439
      if (nOctets == 1) {
#line 440
        nLength = (int )*(bufReceive + 2);
      } else
#line 441
      if (nOctets == 2) {
#line 442
        nLength = ((int )*(bufReceive + 2) << 8) + (int )*(bufReceive + 3);
      } else
#line 443
      if (nOctets == 3) {
#line 444
        nLength = (((int )*(bufReceive + 2) << 16) + ((int )*(bufReceive + 3) << 8)) + (int )*(bufReceive + 4);
      } else
#line 445
      if (nOctets == 4) {
#line 446
        nLength = ((((int )*(bufReceive + 2) << 24) + ((int )*(bufReceive + 3) << 16)) + ((int )*(bufReceive + 4) << 8)) + (int )*(bufReceive + 5);
      }
#line 448
      if (nLength > 0) {
#line 448
        if ((int )*(bufReceive + (2 + nOctets)) == 2) {
#line 448
          if ((int )*(bufReceive + ((2 + nOctets) + 1)) == 1) {
            {
#line 449
            writeError(10, "[%s] Multi-octet mode length: %d", "snmp.mod", nLength);
            }
          } else {
            {
#line 452
            writeError(3, "[%s] Failed to parse length or SNMP version (multi-octet mode).",
                       "snmp.mod");
#line 453
            nLength = -1;
            }
          }
        } else {
          {
#line 452
          writeError(3, "[%s] Failed to parse length or SNMP version (multi-octet mode).",
                     "snmp.mod");
#line 453
          nLength = -1;
          }
        }
      } else {
        {
#line 452
        writeError(3, "[%s] Failed to parse length or SNMP version (multi-octet mode).",
                   "snmp.mod");
#line 453
        nLength = -1;
        }
      }
    } else
#line 456
    if ((int )*(bufReceive + 2) == 2) {
#line 456
      if ((int )*(bufReceive + 3) == 1) {
        {
#line 458
        nLength = (int )*(bufReceive + 1);
#line 459
        writeError(10, "[%s] Single octet mode length: %d", "snmp.mod", nLength);
        }
      } else {
        {
#line 463
        writeError(3, "[%s] Failed to parse length or SNMP version.", "snmp.mod");
#line 464
        nLength = -1;
        }
      }
    } else {
      {
#line 463
      writeError(3, "[%s] Failed to parse length or SNMP version.", "snmp.mod");
#line 464
      nLength = -1;
      }
    }
  }
#line 468
  return (nLength);
}
}
#line 472 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int countResponses(int nReceiveBufferSize , unsigned char *bufReceive ) 
{ 
  int i ;
  int nLength ;
  int nResponseCount ;

  {
#line 474
  i = 0;
#line 475
  nLength = 0;
#line 476
  nResponseCount = 0;
#line 478
  i = 0;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i < nReceiveBufferSize)) {
#line 478
      goto while_break;
    }
#line 479
    if ((int )*(bufReceive + i) == 48) {
      {
#line 481
      nLength = parseLength(nReceiveBufferSize - i, bufReceive + i);
      }
#line 482
      if (nLength > 0) {
        {
#line 484
        writeError(10, "[%s] Located start of SNMP response (%d bytes).", "snmp.mod",
                   nLength);
#line 485
        nResponseCount ++;
#line 486
        i += nLength;
        }
      }
    }
#line 478
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 491
  return (nResponseCount);
}
}
#line 494 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int processResponse(int nReceiveBufferSize , unsigned char *bufReceive , int *nSNMPLength ,
                    char **szPassword , char **szLocation ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 497
  writeError(10, "[%s] Parsing SNMP response data.", "snmp.mod");
#line 499
  i = 0;
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < nReceiveBufferSize)) {
#line 499
      goto while_break;
    }
    {
#line 500
    *nSNMPLength = parseLength(nReceiveBufferSize - i, bufReceive + i);
    }
#line 501
    if (*nSNMPLength > 0) {
      {
#line 503
      writeError(10, "[%s] Located start of SNMP response (%d bytes).", "snmp.mod",
                 *nSNMPLength);
      }
      {
#line 505
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 505
        if (! (i < nReceiveBufferSize)) {
#line 505
          goto while_break___0;
        }
#line 506
        if ((int )*(bufReceive + i) == 4) {
          {
#line 507
          writeError(10, "[%s] Located start of SNMP community string.", "snmp.mod");
          }
#line 508
          if ((int )*(bufReceive + (i + 1)) > 0) {
            {
#line 510
            writeError(10, "[%s] Located SNMP community string size: %d.", "snmp.mod",
                       (int )*(bufReceive + (i + 1)));
#line 511
            tmp = malloc((size_t )((int )*(bufReceive + (i + 1)) + 1));
#line 511
            *szPassword = (char *)tmp;
#line 512
            memset((void *)*szPassword, 0, (size_t )((int )*(bufReceive + (i + 1)) + 1));
#line 513
            memcpy((void */* __restrict  */)*szPassword, (void const   */* __restrict  */)((bufReceive + i) + 2),
                   (size_t )*(bufReceive + (i + 1)));
#line 514
            writeError(10, "[%s] Located community string: %s.", "snmp.mod", *szPassword);
            }
          } else {
            {
#line 518
            writeError(10, "[%s] Failed to locate community string.", "snmp.mod");
            }
#line 519
            return (-1);
          }
#line 522
          i += (int )*(bufReceive + (i + 1));
          {
#line 522
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 522
            if (! (i + 2 < nReceiveBufferSize)) {
#line 522
              goto while_break___1;
            }
#line 523
            if ((int )*(bufReceive + i) == 162) {
              {
#line 524
              writeError(10, "[%s] Located PDU Response.", "snmp.mod");
              }
              {
#line 525
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 525
                if (! (i + 2 < nReceiveBufferSize)) {
#line 525
                  goto while_break___2;
                }
#line 526
                if ((int )*(bufReceive + i) == 2) {
                  {
#line 527
                  writeError(10, "[%s] Located ID.", "snmp.mod");
#line 528
                  i += (int )*(bufReceive + (i + 1));
                  }
                  {
#line 528
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
#line 528
                    if (! (i + 2 < nReceiveBufferSize)) {
#line 528
                      goto while_break___3;
                    }
#line 529
                    if ((int )*(bufReceive + i) == 2) {
#line 529
                      if ((int )*(bufReceive + (i + 1)) == 1) {
#line 529
                        if ((int )*(bufReceive + (i + 2)) == 0) {
                          {
#line 530
                          writeError(10, "[%s] Located success status flag.", "snmp.mod");
#line 532
                          tmp___0 = malloc((size_t )((int )*(bufReceive + (((i + 6) + 14) + 1)) + 1));
#line 532
                          *szLocation = (char *)tmp___0;
#line 533
                          memset((void *)*szLocation, 0, (size_t )((int )*(bufReceive + (((i + 6) + 14) + 1)) + 1));
#line 534
                          memcpy((void */* __restrict  */)*szLocation, (void const   */* __restrict  */)((((bufReceive + i) + 6) + 14) + 2),
                                 (size_t )*(bufReceive + (((i + 6) + 14) + 1)));
#line 536
                          writeError(10, "[%s] sysLocation: %s.", "snmp.mod", *szLocation);
                          }
#line 537
                          return (0);
                        }
                      }
                    }
#line 528
                    i ++;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                }
#line 525
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 522
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 505
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  return (-1);
}
}
#line 552 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int sendRead(int hSocket , _SNMP_DATA *_psSessionData , char *szPassword ) 
{ 
  unsigned char *bufSend ;
  int nSendBufferSize ;
  struct _SNMPV1_A snmpv1_a ;
  struct _SNMPV1_R snmpv1_r ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 555
  nSendBufferSize = 0;
#line 557
  snmpv1_a.ID = (char )'0';
#line 557
  snmpv1_a.len = (char )'\000';
#line 557
  snmpv1_a.ver[0] = (char )'\002';
#line 557
  snmpv1_a.ver[1] = (char )'\001';
#line 557
  snmpv1_a.ver[2] = (char )'\000';
#line 557
  snmpv1_a.comid = (char )'\004';
#line 557
  snmpv1_a.comlen = (char )'\000';
#line 571
  snmpv1_r.type[0] = (char )'\240';
#line 571
  snmpv1_r.type[1] = (char )'\034';
#line 571
  snmpv1_r.identid[0] = (char )'\002';
#line 571
  snmpv1_r.identid[1] = (char )'\004';
#line 571
  snmpv1_r.ident[0] = (char )'o';
#line 571
  snmpv1_r.ident[1] = (char )'g';
#line 571
  snmpv1_r.ident[2] = (char )'N';
#line 571
  snmpv1_r.ident[3] = (char )'\341';
#line 571
  snmpv1_r.errstat[0] = (char )'\002';
#line 571
  snmpv1_r.errstat[1] = (char )'\001';
#line 571
  snmpv1_r.errstat[2] = (char )'\000';
#line 571
  snmpv1_r.errind[0] = (char )'\002';
#line 571
  snmpv1_r.errind[1] = (char )'\001';
#line 571
  snmpv1_r.errind[2] = (char )'\000';
#line 571
  snmpv1_r.objectid[0] = (char )'0';
#line 571
  snmpv1_r.objectid[1] = (char )'\016';
#line 571
  snmpv1_r.object[0] = (char )'0';
#line 571
  snmpv1_r.object[1] = (char )'\f';
#line 571
  snmpv1_r.object[2] = (char )'\006';
#line 571
  snmpv1_r.object[3] = (char )'\b';
#line 571
  snmpv1_r.object[4] = (char )'+';
#line 571
  snmpv1_r.object[5] = (char )'\006';
#line 571
  snmpv1_r.object[6] = (char )'\001';
#line 571
  snmpv1_r.object[7] = (char )'\002';
#line 571
  snmpv1_r.object[8] = (char )'\001';
#line 571
  snmpv1_r.object[9] = (char )'\001';
#line 571
  snmpv1_r.object[10] = (char )'\006';
#line 571
  snmpv1_r.object[11] = (char )'\000';
#line 571
  snmpv1_r.value[0] = (char )'\005';
#line 571
  snmpv1_r.value[1] = (char )'\000';
#line 571
  snmpv1_r.value[2] = (char )'\000';
#line 591
  if (_psSessionData->nVersion == 2) {
#line 592
    snmpv1_a.ver[2] = (char )'\001';
  }
  {
#line 595
  tmp = strlen((char const   *)szPassword);
#line 595
  nSendBufferSize = (int )((sizeof(snmpv1_a) + sizeof(snmpv1_r)) + tmp);
#line 596
  tmp___0 = strlen((char const   *)szPassword);
#line 596
  snmpv1_a.comlen = (char )tmp___0;
#line 597
  snmpv1_a.len = (char )(nSendBufferSize - 3);
#line 599
  tmp___1 = malloc((size_t )nSendBufferSize);
#line 599
  bufSend = (unsigned char *)tmp___1;
#line 600
  memset((void *)bufSend, 0, (size_t )nSendBufferSize);
#line 601
  memcpy((void */* __restrict  */)bufSend, (void const   */* __restrict  */)(& snmpv1_a),
         sizeof(snmpv1_a));
#line 602
  tmp___2 = strlen((char const   *)szPassword);
#line 602
  memcpy((void */* __restrict  */)(bufSend + sizeof(snmpv1_a)), (void const   */* __restrict  */)szPassword,
         tmp___2);
#line 603
  tmp___3 = strlen((char const   *)szPassword);
#line 603
  memcpy((void */* __restrict  */)((bufSend + sizeof(snmpv1_a)) + tmp___3), (void const   */* __restrict  */)(& snmpv1_r),
         sizeof(snmpv1_r));
#line 605
  writeError(10, "[%s] Sending GET request for system.sysLocation.", "snmp.mod");
#line 606
  tmp___4 = medusaSend(hSocket, (char *)bufSend, nSendBufferSize - 1, 0);
  }
#line 606
  if (tmp___4 < 0) {
    {
#line 608
    writeError(3, "%s failed: medusaSend was not successful", "snmp.mod");
#line 609
    free((void *)bufSend);
    }
#line 610
    return (-1);
  }
  {
#line 612
  free((void *)bufSend);
  }
#line 614
  return (1);
}
}
#line 617 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int sendWrite(int hSocket , _SNMP_DATA *_psSessionData , char *szPassword , char *szLocation ) 
{ 
  unsigned char *bufSend ;
  int nSendBufferSize ;
  struct _SNMPV1_A___0 snmpv1_a ;
  struct _SNMPV1_W snmpv1_w ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;

  {
#line 620
  nSendBufferSize = 0;
#line 622
  snmpv1_a.ID = (char )'0';
#line 622
  snmpv1_a.len = (char )'\000';
#line 622
  snmpv1_a.ver[0] = (char )'\002';
#line 622
  snmpv1_a.ver[1] = (char )'\001';
#line 622
  snmpv1_a.ver[2] = (char )'\000';
#line 622
  snmpv1_a.comid = (char )'\004';
#line 622
  snmpv1_a.comlen = (char )'\000';
#line 636
  snmpv1_w.type[0] = (char )'\243';
#line 636
  snmpv1_w.type[1] = (char )' ';
#line 636
  snmpv1_w.identid[0] = (char )'\002';
#line 636
  snmpv1_w.identid[1] = (char )'\004';
#line 636
  snmpv1_w.ident[0] = (char )'o';
#line 636
  snmpv1_w.ident[1] = (char )'g';
#line 636
  snmpv1_w.ident[2] = (char )'N';
#line 636
  snmpv1_w.ident[3] = (char )'\341';
#line 636
  snmpv1_w.errstat[0] = (char )'\002';
#line 636
  snmpv1_w.errstat[1] = (char )'\001';
#line 636
  snmpv1_w.errstat[2] = (char )'\000';
#line 636
  snmpv1_w.errind[0] = (char )'\002';
#line 636
  snmpv1_w.errind[1] = (char )'\001';
#line 636
  snmpv1_w.errind[2] = (char )'\000';
#line 636
  snmpv1_w.objectid[0] = (char )'0';
#line 636
  snmpv1_w.objectid[1] = (char )'\f';
#line 636
  snmpv1_w.object[0] = (char )'0';
#line 636
  snmpv1_w.object[1] = (char )'\f';
#line 636
  snmpv1_w.object[2] = (char )'\006';
#line 636
  snmpv1_w.object[3] = (char )'\b';
#line 636
  snmpv1_w.object[4] = (char )'+';
#line 636
  snmpv1_w.object[5] = (char )'\006';
#line 636
  snmpv1_w.object[6] = (char )'\001';
#line 636
  snmpv1_w.object[7] = (char )'\002';
#line 636
  snmpv1_w.object[8] = (char )'\001';
#line 636
  snmpv1_w.object[9] = (char )'\001';
#line 636
  snmpv1_w.object[10] = (char )'\006';
#line 636
  snmpv1_w.object[11] = (char )'\000';
#line 636
  snmpv1_w.value[0] = (char )'\004';
#line 636
  snmpv1_w.value[1] = (char )'\000';
#line 656
  if (_psSessionData->nVersion == 2) {
#line 657
    snmpv1_a.ver[2] = (char )'\001';
  }
#line 659
  if ((unsigned long )szLocation == (unsigned long )((void *)0)) {
#line 660
    szLocation = (char *)"";
  }
  {
#line 662
  tmp = strlen((char const   *)szPassword);
#line 662
  tmp___0 = strlen((char const   *)szLocation);
#line 662
  nSendBufferSize = (int )((((sizeof(snmpv1_a) + sizeof(snmpv1_w)) + tmp) + tmp___0) + 1UL);
#line 663
  tmp___1 = strlen((char const   *)szPassword);
#line 663
  snmpv1_a.comlen = (char )tmp___1;
#line 664
  snmpv1_a.len = (char )(nSendBufferSize - 3);
#line 666
  tmp___2 = malloc((size_t )nSendBufferSize);
#line 666
  bufSend = (unsigned char *)tmp___2;
#line 667
  memset((void *)bufSend, 0, (size_t )nSendBufferSize);
#line 668
  memcpy((void */* __restrict  */)bufSend, (void const   */* __restrict  */)(& snmpv1_a),
         sizeof(snmpv1_a));
#line 669
  tmp___3 = strlen((char const   *)szPassword);
#line 669
  memcpy((void */* __restrict  */)(bufSend + sizeof(snmpv1_a)), (void const   */* __restrict  */)szPassword,
         tmp___3);
#line 670
  tmp___4 = strlen((char const   *)szPassword);
#line 670
  memcpy((void */* __restrict  */)((bufSend + sizeof(snmpv1_a)) + tmp___4), (void const   */* __restrict  */)(& snmpv1_w),
         sizeof(snmpv1_w));
#line 671
  tmp___5 = strlen((char const   *)szLocation);
#line 671
  tmp___6 = strlen((char const   *)szPassword);
#line 671
  memset((void *)(((bufSend + sizeof(snmpv1_a)) + tmp___6) + 1), (int )(28UL + tmp___5),
         (size_t )1);
#line 672
  tmp___7 = strlen((char const   *)szLocation);
#line 672
  tmp___8 = strlen((char const   *)szPassword);
#line 672
  memset((void *)(((bufSend + sizeof(snmpv1_a)) + tmp___8) + 15), (int )(14UL + tmp___7),
         (size_t )1);
#line 673
  tmp___9 = strlen((char const   *)szLocation);
#line 673
  tmp___10 = strlen((char const   *)szPassword);
#line 673
  memset((void *)(((bufSend + sizeof(snmpv1_a)) + tmp___10) + 17), (int )(12UL + tmp___9),
         (size_t )1);
#line 674
  tmp___11 = strlen((char const   *)szLocation);
#line 674
  tmp___12 = strlen((char const   *)szPassword);
#line 674
  memset((void *)((((bufSend + sizeof(snmpv1_a)) + tmp___12) + sizeof(snmpv1_w)) - 1),
         (int )tmp___11, (size_t )1);
#line 675
  tmp___13 = strlen((char const   *)szLocation);
#line 675
  tmp___14 = strlen((char const   *)szPassword);
#line 675
  strncpy((char */* __restrict  */)(((bufSend + sizeof(snmpv1_a)) + tmp___14) + sizeof(snmpv1_w)),
          (char const   */* __restrict  */)szLocation, tmp___13);
#line 677
  writeError(10, "[%s] Sending SET request for system.sysLocation.", "snmp.mod");
#line 678
  tmp___15 = medusaSend(hSocket, (char *)bufSend, nSendBufferSize - 1, 0);
  }
#line 678
  if (tmp___15 < 0) {
    {
#line 680
    writeError(3, "%s failed: medusaSend was not successful", "snmp.mod");
#line 681
    free((void *)bufSend);
    }
#line 682
    return (-1);
  }
  {
#line 684
  free((void *)bufSend);
  }
#line 686
  return (0);
}
}
#line 689 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/snmp.c"
int receiveRequest(int hSocket , _SNMP_DATA *_psSessionData , int *nPassCount , char ***arrszPassList ,
                   char **szLocation ) 
{ 
  unsigned char *bufReceive ;
  unsigned char *bufReceiveTmp ;
  int i ;
  int nReceiveBufferSize ;
  int nReceiveBufferSizeTmp ;
  int nResponse ;
  int nSNMPLength ;
  char *szPasswordTmp1 ;
  char *szPasswordTmp2 ;
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 694
  szPasswordTmp1 = (char *)((void *)0);
#line 695
  szPasswordTmp2 = (char *)((void *)0);
#line 697
  nReceiveBufferSize = 0;
#line 698
  tmp = medusaReceiveRawDelay(hSocket, & nReceiveBufferSize, _psSessionData->nReadTimeout,
                              _psSessionData->nReadTimeout);
#line 698
  bufReceive = (unsigned char *)tmp;
  }
#line 699
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 701
    writeError(10, "[%s] No data received. Possible incorrect community string.",
               "snmp.mod");
    }
#line 702
    return (-1);
  }
  {
#line 705
  *nPassCount = countResponses(nReceiveBufferSize, bufReceive);
  }
#line 706
  if (*nPassCount <= 0) {
    {
#line 708
    writeError(3, "[%s] Responses received, however, no community strings were located.",
               "snmp.mod");
    }
#line 709
    return (-1);
  } else {
    {
#line 713
    writeError(10, "[%s] Creating password array for %d entries.", "snmp.mod", *nPassCount);
#line 714
    tmp___0 = malloc((unsigned long )*nPassCount * sizeof(char *));
#line 714
    *arrszPassList = (char **)tmp___0;
#line 715
    memset((void *)*arrszPassList, 0, (unsigned long )*nPassCount * sizeof(char *));
    }
  }
#line 718
  bufReceiveTmp = bufReceive;
#line 719
  nReceiveBufferSizeTmp = nReceiveBufferSize;
#line 720
  i = 0;
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! (i < *nPassCount)) {
#line 720
      goto while_break;
    }
    {
#line 722
    writeError(10, "[%s] Retrieving data for response: %d.", "snmp.mod", i + 1);
#line 723
    nResponse = processResponse(nReceiveBufferSizeTmp, bufReceiveTmp, & nSNMPLength,
                                *arrszPassList + i, szLocation);
    }
#line 724
    if (nResponse == 0) {
      {
#line 726
      writeError(10, "[%s] Retrieved SNMP data (%d bytes). Community String: %s Location: %s.",
                 "snmp.mod", nSNMPLength, *(*arrszPassList + i), *szLocation);
      }
    } else {
      {
#line 729
      writeError(3, "[%s] Error processing SNMP response (%d).", "snmp.mod", i + 1);
      }
    }
#line 731
    bufReceiveTmp += nSNMPLength + 2;
#line 732
    nReceiveBufferSizeTmp -= nSNMPLength + 2;
#line 720
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 735
  free((void *)bufReceive);
  }
#line 737
  return (nResponse);
}
}
#line 67 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ftp.c"
int initAuthSSL(int hSocket , _MODULE_DATA *_psSessionData ) ;
#line 373 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ftp.c"
int initAuthSSL(int hSocket , _MODULE_DATA *_psSessionData ) 
{ 
  unsigned char bufSend[300] ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 376
  bufReceive = (unsigned char *)((void *)0);
#line 379
  writeError(5, "[%s] Establishing Explicit FTPS (FTP/SSL) session.", "ftp.mod");
#line 381
  memset((void *)(bufSend), 0, (size_t )300);
#line 382
  sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"AUTH TLS\r\n");
#line 383
  tmp = strlen((char const   *)(bufSend));
#line 383
  tmp___0 = medusaSend(hSocket, (char *)(bufSend), (int )tmp, 0);
  }
#line 383
  if (tmp___0 < 0) {
    {
#line 385
    writeError(3, "[%s] failed: medusaSend was not successful", "ftp.mod");
    }
#line 386
    return (-1);
  }
  {
#line 389
  nReceiveBufferSize = 0;
#line 390
  tmp___1 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "^[0-9]{3,3}-.*\r\n[0-9]{3,3} .*\r\n|^[0-9]{3,3} .*\r\n");
  }
#line 390
  if (tmp___1 == -1) {
#line 390
    goto _L;
  } else
#line 390
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 392
    writeError(10, "[%s] failed: Server sent unknown or no response. Exiting...",
               "ftp.mod");
    }
#line 393
    if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
      {
#line 393
      free((void *)bufReceive);
#line 393
      bufReceive = (unsigned char *)((void *)0);
      }
    }
#line 394
    return (-1);
  }
  {
#line 398
  tmp___3 = strncmp((char const   *)bufReceive, "234 ", (size_t )4);
  }
#line 398
  if (tmp___3 == 0) {
#line 400
    if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
      {
#line 400
      free((void *)bufReceive);
#line 400
      bufReceive = (unsigned char *)((void *)0);
      }
    }
    {
#line 402
    tmp___2 = medusaConnectSocketSSL(_psSessionData->params, hSocket);
    }
#line 402
    if (tmp___2 < 0) {
      {
#line 404
      writeError(3, "[%s] Failed to establish SSL connection.", "ftp.mod");
      }
#line 405
      return (-1);
    }
  } else {
    {
#line 410
    writeError(3, "[%s] Failed to establish SSL connection. Server sent response: %c%c%c",
               "ftp.mod", (int )*(bufReceive + 0), (int )*(bufReceive + 1), (int )*(bufReceive + 2));
    }
#line 411
    return (-1);
  }
#line 414
  return (0);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 101 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.h"
void buildAuthRequest(tSmbNtlmAuthRequest *request , long flags , char *host , char *domain ) ;
#line 109
void buildAuthResponse(tSmbNtlmAuthChallenge *challenge , tSmbNtlmAuthResponse *response ,
                       long flags , char *user , char *password , char *domainname ,
                       char *host ) ;
#line 112
void dumpAuthRequest(tSmbNtlmAuthRequest *request ) ;
#line 113
void dumpAuthChallenge(tSmbNtlmAuthChallenge *challenge ) ;
#line 114
void dumpAuthResponse(tSmbNtlmAuthResponse *response ) ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 A  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 B  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 C  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 D  ;
#line 291 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 F(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 293
  return ((X & Y) | (~ X & Z));
}
}
#line 296 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 G(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 298
  return (((X & Y) | (X & Z)) | (Y & Z));
}
}
#line 301 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 H(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 303
  return ((X ^ Y) ^ Z);
}
}
#line 306 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 lshift(uint32 x , int s ) 
{ 


  {
#line 308
  x &= 4294967295U;
#line 309
  return (((x << s) & 4294967295U) | (x >> (32 - s)));
}
}
#line 317 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void mdfour64(uint32 *M ) 
{ 
  int j ;
  uint32 AA ;
  uint32 BB ;
  uint32 CC ;
  uint32 DD ;
  uint32 X[16] ;
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  uint32 tmp___10 ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;
  uint32 tmp___13 ;
  uint32 tmp___14 ;
  uint32 tmp___15 ;
  uint32 tmp___16 ;
  uint32 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint32 tmp___21 ;
  uint32 tmp___22 ;
  uint32 tmp___23 ;
  uint32 tmp___24 ;
  uint32 tmp___25 ;
  uint32 tmp___26 ;
  uint32 tmp___27 ;
  uint32 tmp___28 ;
  uint32 tmp___29 ;
  uint32 tmp___30 ;
  uint32 tmp___31 ;
  uint32 tmp___32 ;
  uint32 tmp___33 ;
  uint32 tmp___34 ;
  uint32 tmp___35 ;
  uint32 tmp___36 ;
  uint32 tmp___37 ;
  uint32 tmp___38 ;
  uint32 tmp___39 ;
  uint32 tmp___40 ;
  uint32 tmp___41 ;
  uint32 tmp___42 ;
  uint32 tmp___43 ;
  uint32 tmp___44 ;
  uint32 tmp___45 ;
  uint32 tmp___46 ;

  {
#line 323
  j = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (j < 16)) {
#line 323
      goto while_break;
    }
#line 324
    X[j] = *(M + j);
#line 323
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  AA = A;
#line 326
  BB = B;
#line 326
  CC = C;
#line 326
  DD = D;
#line 328
  tmp = F(B, C, D);
#line 328
  A = lshift((A + tmp) + X[0], 3);
#line 328
  tmp___0 = F(A, B, C);
#line 328
  D = lshift((D + tmp___0) + X[1], 7);
#line 329
  tmp___1 = F(D, A, B);
#line 329
  C = lshift((C + tmp___1) + X[2], 11);
#line 329
  tmp___2 = F(C, D, A);
#line 329
  B = lshift((B + tmp___2) + X[3], 19);
#line 330
  tmp___3 = F(B, C, D);
#line 330
  A = lshift((A + tmp___3) + X[4], 3);
#line 330
  tmp___4 = F(A, B, C);
#line 330
  D = lshift((D + tmp___4) + X[5], 7);
#line 331
  tmp___5 = F(D, A, B);
#line 331
  C = lshift((C + tmp___5) + X[6], 11);
#line 331
  tmp___6 = F(C, D, A);
#line 331
  B = lshift((B + tmp___6) + X[7], 19);
#line 332
  tmp___7 = F(B, C, D);
#line 332
  A = lshift((A + tmp___7) + X[8], 3);
#line 332
  tmp___8 = F(A, B, C);
#line 332
  D = lshift((D + tmp___8) + X[9], 7);
#line 333
  tmp___9 = F(D, A, B);
#line 333
  C = lshift((C + tmp___9) + X[10], 11);
#line 333
  tmp___10 = F(C, D, A);
#line 333
  B = lshift((B + tmp___10) + X[11], 19);
#line 334
  tmp___11 = F(B, C, D);
#line 334
  A = lshift((A + tmp___11) + X[12], 3);
#line 334
  tmp___12 = F(A, B, C);
#line 334
  D = lshift((D + tmp___12) + X[13], 7);
#line 335
  tmp___13 = F(D, A, B);
#line 335
  C = lshift((C + tmp___13) + X[14], 11);
#line 335
  tmp___14 = F(C, D, A);
#line 335
  B = lshift((B + tmp___14) + X[15], 19);
#line 337
  tmp___15 = G(B, C, D);
#line 337
  A = lshift(((A + tmp___15) + X[0]) + 1518500249U, 3);
#line 337
  tmp___16 = G(A, B, C);
#line 337
  D = lshift(((D + tmp___16) + X[4]) + 1518500249U, 5);
#line 338
  tmp___17 = G(D, A, B);
#line 338
  C = lshift(((C + tmp___17) + X[8]) + 1518500249U, 9);
#line 338
  tmp___18 = G(C, D, A);
#line 338
  B = lshift(((B + tmp___18) + X[12]) + 1518500249U, 13);
#line 339
  tmp___19 = G(B, C, D);
#line 339
  A = lshift(((A + tmp___19) + X[1]) + 1518500249U, 3);
#line 339
  tmp___20 = G(A, B, C);
#line 339
  D = lshift(((D + tmp___20) + X[5]) + 1518500249U, 5);
#line 340
  tmp___21 = G(D, A, B);
#line 340
  C = lshift(((C + tmp___21) + X[9]) + 1518500249U, 9);
#line 340
  tmp___22 = G(C, D, A);
#line 340
  B = lshift(((B + tmp___22) + X[13]) + 1518500249U, 13);
#line 341
  tmp___23 = G(B, C, D);
#line 341
  A = lshift(((A + tmp___23) + X[2]) + 1518500249U, 3);
#line 341
  tmp___24 = G(A, B, C);
#line 341
  D = lshift(((D + tmp___24) + X[6]) + 1518500249U, 5);
#line 342
  tmp___25 = G(D, A, B);
#line 342
  C = lshift(((C + tmp___25) + X[10]) + 1518500249U, 9);
#line 342
  tmp___26 = G(C, D, A);
#line 342
  B = lshift(((B + tmp___26) + X[14]) + 1518500249U, 13);
#line 343
  tmp___27 = G(B, C, D);
#line 343
  A = lshift(((A + tmp___27) + X[3]) + 1518500249U, 3);
#line 343
  tmp___28 = G(A, B, C);
#line 343
  D = lshift(((D + tmp___28) + X[7]) + 1518500249U, 5);
#line 344
  tmp___29 = G(D, A, B);
#line 344
  C = lshift(((C + tmp___29) + X[11]) + 1518500249U, 9);
#line 344
  tmp___30 = G(C, D, A);
#line 344
  B = lshift(((B + tmp___30) + X[15]) + 1518500249U, 13);
#line 346
  tmp___31 = H(B, C, D);
#line 346
  A = lshift(((A + tmp___31) + X[0]) + 1859775393U, 3);
#line 346
  tmp___32 = H(A, B, C);
#line 346
  D = lshift(((D + tmp___32) + X[8]) + 1859775393U, 9);
#line 347
  tmp___33 = H(D, A, B);
#line 347
  C = lshift(((C + tmp___33) + X[4]) + 1859775393U, 11);
#line 347
  tmp___34 = H(C, D, A);
#line 347
  B = lshift(((B + tmp___34) + X[12]) + 1859775393U, 15);
#line 348
  tmp___35 = H(B, C, D);
#line 348
  A = lshift(((A + tmp___35) + X[2]) + 1859775393U, 3);
#line 348
  tmp___36 = H(A, B, C);
#line 348
  D = lshift(((D + tmp___36) + X[10]) + 1859775393U, 9);
#line 349
  tmp___37 = H(D, A, B);
#line 349
  C = lshift(((C + tmp___37) + X[6]) + 1859775393U, 11);
#line 349
  tmp___38 = H(C, D, A);
#line 349
  B = lshift(((B + tmp___38) + X[14]) + 1859775393U, 15);
#line 350
  tmp___39 = H(B, C, D);
#line 350
  A = lshift(((A + tmp___39) + X[1]) + 1859775393U, 3);
#line 350
  tmp___40 = H(A, B, C);
#line 350
  D = lshift(((D + tmp___40) + X[9]) + 1859775393U, 9);
#line 351
  tmp___41 = H(D, A, B);
#line 351
  C = lshift(((C + tmp___41) + X[5]) + 1859775393U, 11);
#line 351
  tmp___42 = H(C, D, A);
#line 351
  B = lshift(((B + tmp___42) + X[13]) + 1859775393U, 15);
#line 352
  tmp___43 = H(B, C, D);
#line 352
  A = lshift(((A + tmp___43) + X[3]) + 1859775393U, 3);
#line 352
  tmp___44 = H(A, B, C);
#line 352
  D = lshift(((D + tmp___44) + X[11]) + 1859775393U, 9);
#line 353
  tmp___45 = H(D, A, B);
#line 353
  C = lshift(((C + tmp___45) + X[7]) + 1859775393U, 11);
#line 353
  tmp___46 = H(C, D, A);
#line 353
  B = lshift(((B + tmp___46) + X[15]) + 1859775393U, 15);
#line 355
  A += AA;
#line 355
  B += BB;
#line 355
  C += CC;
#line 355
  D += DD;
#line 357
  A &= 4294967295U;
#line 357
  B &= 4294967295U;
#line 358
  C &= 4294967295U;
#line 358
  D &= 4294967295U;
#line 360
  j = 0;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (j < 16)) {
#line 360
      goto while_break___0;
    }
#line 361
    X[j] = (uint32 )0;
#line 360
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void copy64(uint32 *M , unsigned char *in ) 
{ 
  int i ;

  {
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 16)) {
#line 368
      goto while_break;
    }
#line 369
    *(M + i) = (uint32 )(((((int )*(in + (i * 4 + 3)) << 24) | ((int )*(in + (i * 4 + 2)) << 16)) | ((int )*(in + (i * 4 + 1)) << 8)) | (int )*(in + i * 4));
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void copy4(unsigned char *out , uint32 x ) 
{ 


  {
#line 375
  *(out + 0) = (unsigned char )(x & 255U);
#line 376
  *(out + 1) = (unsigned char )((x >> 8) & 255U);
#line 377
  *(out + 2) = (unsigned char )((x >> 16) & 255U);
#line 378
  *(out + 3) = (unsigned char )((x >> 24) & 255U);
#line 379
  return;
}
}
#line 382 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void mdfour(unsigned char *out , unsigned char *in , int n ) 
{ 
  unsigned char buf___8[128] ;
  uint32 M[16] ;
  uint32 b ;
  int i ;

  {
#line 386
  b = (uint32 )(n * 8);
#line 389
  A = (uint32 )1732584193;
#line 390
  B = 4023233417U;
#line 391
  C = 2562383102U;
#line 392
  D = (uint32 )271733878;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (n > 64)) {
#line 394
      goto while_break;
    }
    {
#line 395
    copy64(M, in);
#line 396
    mdfour64(M);
#line 397
    in += 64;
#line 398
    n -= 64;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  i = 0;
  {
#line 401
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 401
    if (! (i < 128)) {
#line 401
      goto while_break___0;
    }
#line 402
    buf___8[i] = (unsigned char)0;
#line 401
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 403
  memcpy((void */* __restrict  */)(buf___8), (void const   */* __restrict  */)in,
         (size_t )n);
#line 404
  buf___8[n] = (unsigned char)128;
  }
#line 406
  if (n <= 55) {
    {
#line 407
    copy4(buf___8 + 56, b);
#line 408
    copy64(M, buf___8);
#line 409
    mdfour64(M);
    }
  } else {
    {
#line 411
    copy4(buf___8 + 120, b);
#line 412
    copy64(M, buf___8);
#line 413
    mdfour64(M);
#line 414
    copy64(M, buf___8 + 64);
#line 415
    mdfour64(M);
    }
  }
#line 418
  i = 0;
  {
#line 418
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 418
    if (! (i < 128)) {
#line 418
      goto while_break___1;
    }
#line 419
    buf___8[i] = (unsigned char)0;
#line 418
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 420
  copy64(M, buf___8);
#line 422
  copy4(out, A);
#line 423
  copy4(out + 4, B);
#line 424
  copy4(out + 8, C);
#line 425
  copy4(out + 12, D);
#line 427
  D = (uint32 )0;
#line 427
  C = D;
#line 427
  B = C;
#line 427
  A = B;
  }
#line 428
  return;
}
}
#line 437 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm1[56]  = 
#line 437
  {      (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)63,      (unsigned char)55,      (unsigned char)47,      (unsigned char)39, 
        (unsigned char)31,      (unsigned char)23,      (unsigned char)15,      (unsigned char)7, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4};
#line 446 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm2[48]  = 
#line 446
  {      (unsigned char)14,      (unsigned char)17,      (unsigned char)11,      (unsigned char)24, 
        (unsigned char)1,      (unsigned char)5,      (unsigned char)3,      (unsigned char)28, 
        (unsigned char)15,      (unsigned char)6,      (unsigned char)21,      (unsigned char)10, 
        (unsigned char)23,      (unsigned char)19,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)26,      (unsigned char)8,      (unsigned char)16,      (unsigned char)7, 
        (unsigned char)27,      (unsigned char)20,      (unsigned char)13,      (unsigned char)2, 
        (unsigned char)41,      (unsigned char)52,      (unsigned char)31,      (unsigned char)37, 
        (unsigned char)47,      (unsigned char)55,      (unsigned char)30,      (unsigned char)40, 
        (unsigned char)51,      (unsigned char)45,      (unsigned char)33,      (unsigned char)48, 
        (unsigned char)44,      (unsigned char)49,      (unsigned char)39,      (unsigned char)56, 
        (unsigned char)34,      (unsigned char)53,      (unsigned char)46,      (unsigned char)42, 
        (unsigned char)50,      (unsigned char)36,      (unsigned char)29,      (unsigned char)32};
#line 455 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm3[64]  = 
#line 455
  {      (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)64,      (unsigned char)56,      (unsigned char)48,      (unsigned char)40, 
        (unsigned char)32,      (unsigned char)24,      (unsigned char)16,      (unsigned char)8, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)63,      (unsigned char)55,      (unsigned char)47,      (unsigned char)39, 
        (unsigned char)31,      (unsigned char)23,      (unsigned char)15,      (unsigned char)7};
#line 464 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm4[48]  = 
#line 464
  {      (unsigned char)32,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)8,      (unsigned char)9, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)12,      (unsigned char)13, 
        (unsigned char)14,      (unsigned char)15,      (unsigned char)16,      (unsigned char)17, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)22,      (unsigned char)23,      (unsigned char)24,      (unsigned char)25, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)28,      (unsigned char)29, 
        (unsigned char)30,      (unsigned char)31,      (unsigned char)32,      (unsigned char)1};
#line 473 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm5[32]  = 
#line 473
  {      (unsigned char)16,      (unsigned char)7,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)29,      (unsigned char)12,      (unsigned char)28,      (unsigned char)17, 
        (unsigned char)1,      (unsigned char)15,      (unsigned char)23,      (unsigned char)26, 
        (unsigned char)5,      (unsigned char)18,      (unsigned char)31,      (unsigned char)10, 
        (unsigned char)2,      (unsigned char)8,      (unsigned char)24,      (unsigned char)14, 
        (unsigned char)32,      (unsigned char)27,      (unsigned char)3,      (unsigned char)9, 
        (unsigned char)19,      (unsigned char)13,      (unsigned char)30,      (unsigned char)6, 
        (unsigned char)22,      (unsigned char)11,      (unsigned char)4,      (unsigned char)25};
#line 482 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm6[64]  = 
#line 482
  {      (unsigned char)40,      (unsigned char)8,      (unsigned char)48,      (unsigned char)16, 
        (unsigned char)56,      (unsigned char)24,      (unsigned char)64,      (unsigned char)32, 
        (unsigned char)39,      (unsigned char)7,      (unsigned char)47,      (unsigned char)15, 
        (unsigned char)55,      (unsigned char)23,      (unsigned char)63,      (unsigned char)31, 
        (unsigned char)38,      (unsigned char)6,      (unsigned char)46,      (unsigned char)14, 
        (unsigned char)54,      (unsigned char)22,      (unsigned char)62,      (unsigned char)30, 
        (unsigned char)37,      (unsigned char)5,      (unsigned char)45,      (unsigned char)13, 
        (unsigned char)53,      (unsigned char)21,      (unsigned char)61,      (unsigned char)29, 
        (unsigned char)36,      (unsigned char)4,      (unsigned char)44,      (unsigned char)12, 
        (unsigned char)52,      (unsigned char)20,      (unsigned char)60,      (unsigned char)28, 
        (unsigned char)35,      (unsigned char)3,      (unsigned char)43,      (unsigned char)11, 
        (unsigned char)51,      (unsigned char)19,      (unsigned char)59,      (unsigned char)27, 
        (unsigned char)34,      (unsigned char)2,      (unsigned char)42,      (unsigned char)10, 
        (unsigned char)50,      (unsigned char)18,      (unsigned char)58,      (unsigned char)26, 
        (unsigned char)33,      (unsigned char)1,      (unsigned char)41,      (unsigned char)9, 
        (unsigned char)49,      (unsigned char)17,      (unsigned char)57,      (unsigned char)25};
#line 491 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char sc[16]  = 
#line 491
  {      (unsigned char)1,      (unsigned char)1,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)1};
#line 493 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char sbox[8][4][16]  = 
#line 493
  { { {          (unsigned char)14,          (unsigned char)4,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)2,          (unsigned char)15,          (unsigned char)11,          (unsigned char)8, 
                (unsigned char)3,          (unsigned char)10,          (unsigned char)6,          (unsigned char)12, 
                (unsigned char)5,          (unsigned char)9,          (unsigned char)0,          (unsigned char)7}, 
     {          (unsigned char)0,          (unsigned char)15,          (unsigned char)7,          (unsigned char)4, 
                (unsigned char)14,          (unsigned char)2,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)10,          (unsigned char)6,          (unsigned char)12,          (unsigned char)11, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)3,          (unsigned char)8}, 
     {          (unsigned char)4,          (unsigned char)1,          (unsigned char)14,          (unsigned char)8, 
                (unsigned char)13,          (unsigned char)6,          (unsigned char)2,          (unsigned char)11, 
                (unsigned char)15,          (unsigned char)12,          (unsigned char)9,          (unsigned char)7, 
                (unsigned char)3,          (unsigned char)10,          (unsigned char)5,          (unsigned char)0}, 
     {          (unsigned char)15,          (unsigned char)12,          (unsigned char)8,          (unsigned char)2, 
                (unsigned char)4,          (unsigned char)9,          (unsigned char)1,          (unsigned char)7, 
                (unsigned char)5,          (unsigned char)11,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)10,          (unsigned char)0,          (unsigned char)6,          (unsigned char)13}}, 
   { {          (unsigned char)15,          (unsigned char)1,          (unsigned char)8,          (unsigned char)14, 
                (unsigned char)6,          (unsigned char)11,          (unsigned char)3,          (unsigned char)4, 
                (unsigned char)9,          (unsigned char)7,          (unsigned char)2,          (unsigned char)13, 
                (unsigned char)12,          (unsigned char)0,          (unsigned char)5,          (unsigned char)10}, 
     {          (unsigned char)3,          (unsigned char)13,          (unsigned char)4,          (unsigned char)7, 
                (unsigned char)15,          (unsigned char)2,          (unsigned char)8,          (unsigned char)14, 
                (unsigned char)12,          (unsigned char)0,          (unsigned char)1,          (unsigned char)10, 
                (unsigned char)6,          (unsigned char)9,          (unsigned char)11,          (unsigned char)5}, 
     {          (unsigned char)0,          (unsigned char)14,          (unsigned char)7,          (unsigned char)11, 
                (unsigned char)10,          (unsigned char)4,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)5,          (unsigned char)8,          (unsigned char)12,          (unsigned char)6, 
                (unsigned char)9,          (unsigned char)3,          (unsigned char)2,          (unsigned char)15}, 
     {          (unsigned char)13,          (unsigned char)8,          (unsigned char)10,          (unsigned char)1, 
                (unsigned char)3,          (unsigned char)15,          (unsigned char)4,          (unsigned char)2, 
                (unsigned char)11,          (unsigned char)6,          (unsigned char)7,          (unsigned char)12, 
                (unsigned char)0,          (unsigned char)5,          (unsigned char)14,          (unsigned char)9}}, 
   { {          (unsigned char)10,          (unsigned char)0,          (unsigned char)9,          (unsigned char)14, 
                (unsigned char)6,          (unsigned char)3,          (unsigned char)15,          (unsigned char)5, 
                (unsigned char)1,          (unsigned char)13,          (unsigned char)12,          (unsigned char)7, 
                (unsigned char)11,          (unsigned char)4,          (unsigned char)2,          (unsigned char)8}, 
     {          (unsigned char)13,          (unsigned char)7,          (unsigned char)0,          (unsigned char)9, 
                (unsigned char)3,          (unsigned char)4,          (unsigned char)6,          (unsigned char)10, 
                (unsigned char)2,          (unsigned char)8,          (unsigned char)5,          (unsigned char)14, 
                (unsigned char)12,          (unsigned char)11,          (unsigned char)15,          (unsigned char)1}, 
     {          (unsigned char)13,          (unsigned char)6,          (unsigned char)4,          (unsigned char)9, 
                (unsigned char)8,          (unsigned char)15,          (unsigned char)3,          (unsigned char)0, 
                (unsigned char)11,          (unsigned char)1,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)5,          (unsigned char)10,          (unsigned char)14,          (unsigned char)7}, 
     {          (unsigned char)1,          (unsigned char)10,          (unsigned char)13,          (unsigned char)0, 
                (unsigned char)6,          (unsigned char)9,          (unsigned char)8,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)15,          (unsigned char)14,          (unsigned char)3, 
                (unsigned char)11,          (unsigned char)5,          (unsigned char)2,          (unsigned char)12}}, 
   { {          (unsigned char)7,          (unsigned char)13,          (unsigned char)14,          (unsigned char)3, 
                (unsigned char)0,          (unsigned char)6,          (unsigned char)9,          (unsigned char)10, 
                (unsigned char)1,          (unsigned char)2,          (unsigned char)8,          (unsigned char)5, 
                (unsigned char)11,          (unsigned char)12,          (unsigned char)4,          (unsigned char)15}, 
     {          (unsigned char)13,          (unsigned char)8,          (unsigned char)11,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)0,          (unsigned char)3, 
                (unsigned char)4,          (unsigned char)7,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)1,          (unsigned char)10,          (unsigned char)14,          (unsigned char)9}, 
     {          (unsigned char)10,          (unsigned char)6,          (unsigned char)9,          (unsigned char)0, 
                (unsigned char)12,          (unsigned char)11,          (unsigned char)7,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)1,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)5,          (unsigned char)2,          (unsigned char)8,          (unsigned char)4}, 
     {          (unsigned char)3,          (unsigned char)15,          (unsigned char)0,          (unsigned char)6, 
                (unsigned char)10,          (unsigned char)1,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)9,          (unsigned char)4,          (unsigned char)5,          (unsigned char)11, 
                (unsigned char)12,          (unsigned char)7,          (unsigned char)2,          (unsigned char)14}}, 
   { {          (unsigned char)2,          (unsigned char)12,          (unsigned char)4,          (unsigned char)1, 
                (unsigned char)7,          (unsigned char)10,          (unsigned char)11,          (unsigned char)6, 
                (unsigned char)8,          (unsigned char)5,          (unsigned char)3,          (unsigned char)15, 
                (unsigned char)13,          (unsigned char)0,          (unsigned char)14,          (unsigned char)9}, 
     {          (unsigned char)14,          (unsigned char)11,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)4,          (unsigned char)7,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)5,          (unsigned char)0,          (unsigned char)15,          (unsigned char)10, 
                (unsigned char)3,          (unsigned char)9,          (unsigned char)8,          (unsigned char)6}, 
     {          (unsigned char)4,          (unsigned char)2,          (unsigned char)1,          (unsigned char)11, 
                (unsigned char)10,          (unsigned char)13,          (unsigned char)7,          (unsigned char)8, 
                (unsigned char)15,          (unsigned char)9,          (unsigned char)12,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)3,          (unsigned char)0,          (unsigned char)14}, 
     {          (unsigned char)11,          (unsigned char)8,          (unsigned char)12,          (unsigned char)7, 
                (unsigned char)1,          (unsigned char)14,          (unsigned char)2,          (unsigned char)13, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)0,          (unsigned char)9, 
                (unsigned char)10,          (unsigned char)4,          (unsigned char)5,          (unsigned char)3}}, 
   { {          (unsigned char)12,          (unsigned char)1,          (unsigned char)10,          (unsigned char)15, 
                (unsigned char)9,          (unsigned char)2,          (unsigned char)6,          (unsigned char)8, 
                (unsigned char)0,          (unsigned char)13,          (unsigned char)3,          (unsigned char)4, 
                (unsigned char)14,          (unsigned char)7,          (unsigned char)5,          (unsigned char)11}, 
     {          (unsigned char)10,          (unsigned char)15,          (unsigned char)4,          (unsigned char)2, 
                (unsigned char)7,          (unsigned char)12,          (unsigned char)9,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)1,          (unsigned char)13,          (unsigned char)14, 
                (unsigned char)0,          (unsigned char)11,          (unsigned char)3,          (unsigned char)8}, 
     {          (unsigned char)9,          (unsigned char)14,          (unsigned char)15,          (unsigned char)5, 
                (unsigned char)2,          (unsigned char)8,          (unsigned char)12,          (unsigned char)3, 
                (unsigned char)7,          (unsigned char)0,          (unsigned char)4,          (unsigned char)10, 
                (unsigned char)1,          (unsigned char)13,          (unsigned char)11,          (unsigned char)6}, 
     {          (unsigned char)4,          (unsigned char)3,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)15,          (unsigned char)10, 
                (unsigned char)11,          (unsigned char)14,          (unsigned char)1,          (unsigned char)7, 
                (unsigned char)6,          (unsigned char)0,          (unsigned char)8,          (unsigned char)13}}, 
   { {          (unsigned char)4,          (unsigned char)11,          (unsigned char)2,          (unsigned char)14, 
                (unsigned char)15,          (unsigned char)0,          (unsigned char)8,          (unsigned char)13, 
                (unsigned char)3,          (unsigned char)12,          (unsigned char)9,          (unsigned char)7, 
                (unsigned char)5,          (unsigned char)10,          (unsigned char)6,          (unsigned char)1}, 
     {          (unsigned char)13,          (unsigned char)0,          (unsigned char)11,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)9,          (unsigned char)1,          (unsigned char)10, 
                (unsigned char)14,          (unsigned char)3,          (unsigned char)5,          (unsigned char)12, 
                (unsigned char)2,          (unsigned char)15,          (unsigned char)8,          (unsigned char)6}, 
     {          (unsigned char)1,          (unsigned char)4,          (unsigned char)11,          (unsigned char)13, 
                (unsigned char)12,          (unsigned char)3,          (unsigned char)7,          (unsigned char)14, 
                (unsigned char)10,          (unsigned char)15,          (unsigned char)6,          (unsigned char)8, 
                (unsigned char)0,          (unsigned char)5,          (unsigned char)9,          (unsigned char)2}, 
     {          (unsigned char)6,          (unsigned char)11,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)1,          (unsigned char)4,          (unsigned char)10,          (unsigned char)7, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)0,          (unsigned char)15, 
                (unsigned char)14,          (unsigned char)2,          (unsigned char)3,          (unsigned char)12}}, 
   { {          (unsigned char)13,          (unsigned char)2,          (unsigned char)8,          (unsigned char)4, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)11,          (unsigned char)1, 
                (unsigned char)10,          (unsigned char)9,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)5,          (unsigned char)0,          (unsigned char)12,          (unsigned char)7}, 
     {          (unsigned char)1,          (unsigned char)15,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)10,          (unsigned char)3,          (unsigned char)7,          (unsigned char)4, 
                (unsigned char)12,          (unsigned char)5,          (unsigned char)6,          (unsigned char)11, 
                (unsigned char)0,          (unsigned char)14,          (unsigned char)9,          (unsigned char)2}, 
     {          (unsigned char)7,          (unsigned char)11,          (unsigned char)4,          (unsigned char)1, 
                (unsigned char)9,          (unsigned char)12,          (unsigned char)14,          (unsigned char)2, 
                (unsigned char)0,          (unsigned char)6,          (unsigned char)10,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)3,          (unsigned char)5,          (unsigned char)8}, 
     {          (unsigned char)2,          (unsigned char)1,          (unsigned char)14,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)10,          (unsigned char)8,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)12,          (unsigned char)9,          (unsigned char)0, 
                (unsigned char)3,          (unsigned char)5,          (unsigned char)6,          (unsigned char)11}}};
#line 534 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void permute(char *out , char *in , unsigned char *p , int n ) 
{ 
  int i ;

  {
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < n)) {
#line 537
      goto while_break;
    }
#line 538
    *(out + i) = *(in + ((int )*(p + i) - 1));
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 541 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void l_shift(char *d , int count , int n ) 
{ 
  char out[64] ;
  int i ;

  {
#line 545
  i = 0;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < n)) {
#line 545
      goto while_break;
    }
#line 546
    out[i] = *(d + (i + count) % n);
#line 545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  i = 0;
  {
#line 547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 547
    if (! (i < n)) {
#line 547
      goto while_break___0;
    }
#line 548
    *(d + i) = out[i];
#line 547
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  return;
}
}
#line 551 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void concat(char *out , char *in1 , char *in2 , int l1 , int l2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    tmp___1 = l1;
#line 553
    l1 --;
#line 553
    if (! tmp___1) {
#line 553
      goto while_break;
    }
#line 554
    tmp = out;
#line 554
    out ++;
#line 554
    tmp___0 = in1;
#line 554
    in1 ++;
#line 554
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 555
    tmp___4 = l2;
#line 555
    l2 --;
#line 555
    if (! tmp___4) {
#line 555
      goto while_break___0;
    }
#line 556
    tmp___2 = out;
#line 556
    out ++;
#line 556
    tmp___3 = in2;
#line 556
    in2 ++;
#line 556
    *tmp___2 = *tmp___3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 559 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void xor(char *out , char *in1 , char *in2 , int n ) 
{ 
  int i ;

  {
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (i < n)) {
#line 562
      goto while_break;
    }
#line 563
    *(out + i) = (char )((int )*(in1 + i) ^ (int )*(in2 + i));
#line 562
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return;
}
}
#line 566 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void dohash(char *out , char *in , char *key , int forw ) 
{ 
  int i ;
  int j ;
  int k ;
  char pk1[56] ;
  char c[28] ;
  char d[28] ;
  char cd[56] ;
  char ki[16][48] ;
  char pd1[64] ;
  char l[32] ;
  char r[32] ;
  char rl[64] ;
  char er[48] ;
  char erk[48] ;
  char b[8][6] ;
  char cb[32] ;
  char pcb[32] ;
  char r2[32] ;
  int tmp ;
  int m ;
  int n ;

  {
  {
#line 578
  permute(pk1, key, perm1, 56);
#line 580
  i = 0;
  }
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (i < 28)) {
#line 580
      goto while_break;
    }
#line 581
    c[i] = pk1[i];
#line 580
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (i < 28)) {
#line 583
      goto while_break___0;
    }
#line 584
    d[i] = pk1[i + 28];
#line 583
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 586
    if (! (i < 16)) {
#line 586
      goto while_break___1;
    }
    {
#line 587
    l_shift(c, (int )sc[i], 28);
#line 588
    l_shift(d, (int )sc[i], 28);
#line 590
    concat(cd, c, d, 28, 28);
#line 591
    permute(ki[i], cd, perm2, 48);
#line 586
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 594
  permute(pd1, in, perm3, 64);
#line 596
  j = 0;
  }
  {
#line 596
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 596
    if (! (j < 32)) {
#line 596
      goto while_break___2;
    }
#line 598
    l[j] = pd1[j];
#line 599
    r[j] = pd1[j + 32];
#line 596
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 602
  i = 0;
  {
#line 602
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 602
    if (! (i < 16)) {
#line 602
      goto while_break___3;
    }
    {
#line 611
    permute(er, r, perm4, 48);
    }
#line 613
    if (forw) {
#line 613
      tmp = i;
    } else {
#line 613
      tmp = 15 - i;
    }
    {
#line 613
    xor(erk, er, ki[tmp], 48);
#line 615
    j = 0;
    }
    {
#line 615
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 615
      if (! (j < 8)) {
#line 615
        goto while_break___4;
      }
#line 616
      k = 0;
      {
#line 616
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 616
        if (! (k < 6)) {
#line 616
          goto while_break___5;
        }
#line 617
        b[j][k] = erk[j * 6 + k];
#line 616
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 615
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 619
    j = 0;
    {
#line 619
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 619
      if (! (j < 8)) {
#line 619
        goto while_break___6;
      }
#line 621
      m = ((int )b[j][0] << 1) | (int )b[j][5];
#line 623
      n = ((((int )b[j][1] << 3) | ((int )b[j][2] << 2)) | ((int )b[j][3] << 1)) | (int )b[j][4];
#line 625
      k = 0;
      {
#line 625
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 625
        if (! (k < 4)) {
#line 625
          goto while_break___7;
        }
#line 626
        if ((int )sbox[j][m][n] & (1 << (3 - k))) {
#line 626
          b[j][k] = (char)1;
        } else {
#line 626
          b[j][k] = (char)0;
        }
#line 625
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 619
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 629
    j = 0;
    {
#line 629
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 629
      if (! (j < 8)) {
#line 629
        goto while_break___8;
      }
#line 630
      k = 0;
      {
#line 630
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 630
        if (! (k < 4)) {
#line 630
          goto while_break___9;
        }
#line 631
        cb[j * 4 + k] = b[j][k];
#line 630
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 629
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 633
    permute(pcb, cb, perm5, 32);
#line 635
    xor(r2, l, pcb, 32);
#line 637
    j = 0;
    }
    {
#line 637
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 637
      if (! (j < 32)) {
#line 637
        goto while_break___10;
      }
#line 638
      l[j] = r[j];
#line 637
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 640
    j = 0;
    {
#line 640
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 640
      if (! (j < 32)) {
#line 640
        goto while_break___11;
      }
#line 641
      r[j] = r2[j];
#line 640
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 602
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 644
  concat(rl, r, l, 32, 32);
#line 646
  permute(out, rl, perm6, 64);
  }
#line 647
  return;
}
}
#line 649 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void str_to_key(unsigned char *str , unsigned char *key ) 
{ 
  int i ;

  {
#line 653
  *(key + 0) = (unsigned char )((int )*(str + 0) >> 1);
#line 654
  *(key + 1) = (unsigned char )((((int )*(str + 0) & 1) << 6) | ((int )*(str + 1) >> 2));
#line 655
  *(key + 2) = (unsigned char )((((int )*(str + 1) & 3) << 5) | ((int )*(str + 2) >> 3));
#line 656
  *(key + 3) = (unsigned char )((((int )*(str + 2) & 7) << 4) | ((int )*(str + 3) >> 4));
#line 657
  *(key + 4) = (unsigned char )((((int )*(str + 3) & 15) << 3) | ((int )*(str + 4) >> 5));
#line 658
  *(key + 5) = (unsigned char )((((int )*(str + 4) & 31) << 2) | ((int )*(str + 5) >> 6));
#line 659
  *(key + 6) = (unsigned char )((((int )*(str + 5) & 63) << 1) | ((int )*(str + 6) >> 7));
#line 660
  *(key + 7) = (unsigned char )((int )*(str + 6) & 127);
#line 661
  i = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (i < 8)) {
#line 661
      goto while_break;
    }
#line 662
    *(key + i) = (unsigned char )((int )*(key + i) << 1);
#line 661
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  return;
}
}
#line 666 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void smbhash(unsigned char *out , unsigned char *in , unsigned char *key ,
                    int forw ) 
{ 
  int i ;
  char outb[64] ;
  char inb[64] ;
  char keyb[64] ;
  unsigned char key2___5[8] ;

  {
  {
#line 674
  str_to_key(key, key2___5);
#line 676
  i = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < 64)) {
#line 676
      goto while_break;
    }
#line 677
    if ((int )*(in + i / 8) & (1 << (7 - i % 8))) {
#line 677
      inb[i] = (char)1;
    } else {
#line 677
      inb[i] = (char)0;
    }
#line 678
    if ((int )key2___5[i / 8] & (1 << (7 - i % 8))) {
#line 678
      keyb[i] = (char)1;
    } else {
#line 678
      keyb[i] = (char)0;
    }
#line 679
    outb[i] = (char)0;
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 682
  dohash(outb, inb, keyb, forw);
#line 684
  i = 0;
  }
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 684
    if (! (i < 8)) {
#line 684
      goto while_break___0;
    }
#line 685
    *(out + i) = (unsigned char)0;
#line 684
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 688
  i = 0;
  {
#line 688
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 688
    if (! (i < 64)) {
#line 688
      goto while_break___1;
    }
#line 689
    if (outb[i]) {
#line 690
      *(out + i / 8) = (unsigned char )((int )*(out + i / 8) | (1 << (7 - i % 8)));
    }
#line 688
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 692
  return;
}
}
#line 694 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void E_P16(unsigned char *p14 , unsigned char *p16 ) 
{ 
  unsigned char sp8[8] ;

  {
  {
#line 696
  sp8[0] = (unsigned char)75;
#line 696
  sp8[1] = (unsigned char)71;
#line 696
  sp8[2] = (unsigned char)83;
#line 696
  sp8[3] = (unsigned char)33;
#line 696
  sp8[4] = (unsigned char)64;
#line 696
  sp8[5] = (unsigned char)35;
#line 696
  sp8[6] = (unsigned char)36;
#line 696
  sp8[7] = (unsigned char)37;
#line 697
  smbhash(p16, sp8, p14, 1);
#line 698
  smbhash(p16 + 8, sp8, p14 + 7, 1);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void E_P24(unsigned char *p21 , unsigned char *c8 , unsigned char *p24 ) 
{ 


  {
  {
#line 703
  smbhash(p24, c8, p21, 1);
#line 704
  smbhash(p24 + 8, c8, p21 + 7, 1);
#line 705
  smbhash(p24 + 16, c8, p21 + 14, 1);
  }
#line 706
  return;
}
}
#line 708 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void D_P16(unsigned char *p14 , unsigned char *in , unsigned char *out ) 
{ 


  {
  {
#line 710
  smbhash(out, in, p14, 0);
#line 711
  smbhash(out + 8, in + 8, p14 + 7, 0);
  }
#line 712
  return;
}
}
#line 714 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void E_old_pw_hash(unsigned char *p14 , unsigned char *in , unsigned char *out ) 
{ 


  {
  {
#line 716
  smbhash(out, in, p14, 1);
#line 717
  smbhash(out + 8, in + 8, p14 + 7, 1);
  }
#line 718
  return;
}
}
#line 720 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void cred_hash1(unsigned char *out , unsigned char *in , unsigned char *key ) 
{ 
  unsigned char buf___8[8] ;

  {
  {
#line 724
  smbhash(buf___8, in, key, 1);
#line 725
  smbhash(out, buf___8, key + 9, 1);
  }
#line 726
  return;
}
}
#line 731 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char key2[8]  ;
#line 728 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void cred_hash2(unsigned char *out , unsigned char *in , unsigned char *key ) 
{ 
  unsigned char buf___8[8] ;

  {
  {
#line 733
  smbhash(buf___8, in, key, 1);
#line 734
  key2[0] = *(key + 7);
#line 735
  smbhash(out, buf___8, key2, 1);
  }
#line 736
  return;
}
}
#line 740 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char key2___0[8]  ;
#line 738 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void cred_hash3(unsigned char *out , unsigned char *in , unsigned char *key , int forw ) 
{ 


  {
  {
#line 742
  smbhash(out, in, key, forw);
#line 743
  key2___0[0] = *(key + 7);
#line 744
  smbhash(out + 8, in + 8, key2___0, forw);
  }
#line 745
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void SamOEMhash(unsigned char *data , unsigned char *key , int val ) 
{ 
  unsigned char s_box[256] ;
  unsigned char index_i ;
  unsigned char index_j ;
  unsigned char j ;
  int ind ;
  unsigned char tc ;
  unsigned char tc___0 ;
  unsigned char t ;
  int tmp ;

  {
#line 750
  index_i = (unsigned char)0;
#line 751
  index_j = (unsigned char)0;
#line 752
  j = (unsigned char)0;
#line 755
  ind = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (ind < 256)) {
#line 755
      goto while_break;
    }
#line 757
    s_box[ind] = (unsigned char )ind;
#line 755
    ind ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  ind = 0;
  {
#line 760
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 760
    if (! (ind < 256)) {
#line 760
      goto while_break___0;
    }
#line 764
    j = (unsigned char )((int )j + ((int )s_box[ind] + (int )*(key + ind % 16)));
#line 766
    tc = s_box[ind];
#line 767
    s_box[ind] = s_box[j];
#line 768
    s_box[j] = tc;
#line 760
    ind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 770
  ind = 0;
  {
#line 770
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 770
    if (val) {
#line 770
      tmp = 516;
    } else {
#line 770
      tmp = 16;
    }
#line 770
    if (! (ind < tmp)) {
#line 770
      goto while_break___1;
    }
#line 775
    index_i = (unsigned char )((int )index_i + 1);
#line 776
    index_j = (unsigned char )((int )index_j + (int )s_box[index_i]);
#line 778
    tc___0 = s_box[index_i];
#line 779
    s_box[index_i] = s_box[index_j];
#line 780
    s_box[index_j] = tc___0;
#line 782
    t = (unsigned char )((int )s_box[index_i] + (int )s_box[index_j]);
#line 783
    *(data + ind) = (unsigned char )((int )*(data + ind) ^ (int )s_box[t]);
#line 770
    ind ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 785
  return;
}
}
#line 793 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
char *StrnCpy(char *dest , char const   *src , size_t n ) 
{ 
  char *d ;
  size_t tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 795
  d = dest;
#line 796
  if (! dest) {
#line 796
    return ((char *)((void *)0));
  }
#line 797
  if (! src) {
#line 798
    *dest = (char)0;
#line 799
    return (dest);
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    tmp = n;
#line 802
    n --;
#line 802
    if (tmp) {
#line 802
      tmp___0 = d;
#line 802
      d ++;
#line 802
      tmp___2 = src;
#line 802
      src ++;
#line 802
      tmp___1 = (char )*tmp___2;
#line 802
      *tmp___0 = tmp___1;
#line 802
      if (! tmp___1) {
#line 802
        goto while_break;
      }
    } else {
#line 802
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 803
  *d = (char)0;
#line 804
  return (dest);
}
}
#line 807 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
size_t skip_multibyte_char(char c ) 
{ 


  {
#line 809
  return ((size_t )0);
}
}
#line 820 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
char *safe_strcpy(char *dest , char const   *src , size_t maxlength ) 
{ 
  size_t len ;

  {
#line 824
  if (! dest) {
    {
#line 825
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 825
      printf((char const   */* __restrict  */)"ERROR: NULL dest in safe_strcpy\n");
      }
#line 825
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 826
    return ((char *)((void *)0));
  }
#line 829
  if (! src) {
#line 830
    *dest = (char)0;
#line 831
    return (dest);
  }
  {
#line 834
  len = strlen(src);
  }
#line 836
  if (len > maxlength) {
    {
#line 837
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 837
      printf((char const   */* __restrict  */)"ERROR: string overflow by %d in safe_strcpy [%.50s]\n",
             (int )(len - maxlength), src);
      }
#line 837
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 839
    len = maxlength;
  }
  {
#line 842
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, len);
#line 843
  *(dest + len) = (char)0;
  }
#line 844
  return (dest);
}
}
#line 847 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void strupper(char *s ) 
{ 
  size_t skip ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! *s) {
#line 849
      goto while_break;
    }
    {
#line 851
    tmp = skip_multibyte_char(*s);
#line 851
    skip = tmp;
    }
#line 852
    if (skip != 0UL) {
#line 853
      s += skip;
    } else {
      {
#line 856
      tmp___1 = __ctype_b_loc();
      }
#line 856
      if ((int const   )*(*tmp___1 + (int )*s) & 512) {
        {
#line 857
        tmp___0 = toupper((int )*s);
#line 857
        *s = (char )tmp___0;
        }
      }
#line 858
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  return;
}
}
#line 863
void SMBOWFencrypt(unsigned char *passwd , unsigned char *c8 , unsigned char *p24 ) ;
#line 871 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void SMBencrypt(unsigned char *passwd , unsigned char *c8 , unsigned char *p24 ) 
{ 
  unsigned char p14[15] ;
  unsigned char p21[21] ;

  {
  {
#line 875
  memset((void *)(p21), '\000', (size_t )21);
#line 876
  memset((void *)(p14), '\000', (size_t )14);
#line 877
  StrnCpy((char *)(p14), (char const   *)((char *)passwd), (size_t )14);
#line 879
  strupper((char *)(p14));
#line 880
  E_P16(p14, p21);
#line 882
  SMBOWFencrypt((unsigned char *)(p21), c8, (unsigned char *)p24);
  }
#line 890
  return;
}
}
#line 893 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static int _my_wcslen(short *str ) 
{ 
  int len ;
  short *tmp ;

  {
#line 895
  len = 0;
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    tmp = str;
#line 896
    str ++;
#line 896
    if (! ((int )*tmp != 0)) {
#line 896
      goto while_break;
    }
#line 897
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (len);
}
}
#line 907 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static int _my_mbstowcs(short *dst , unsigned char *src , int len ) 
{ 
  int i ;
  short val ;

  {
#line 912
  i = 0;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! (i < len)) {
#line 912
      goto while_break;
    }
#line 913
    val = (short )*src;
#line 914
    *((unsigned char *)dst + 0) = (unsigned char )((int )((uint16 )val) & 255);
#line 914
    *((unsigned char *)dst + 1) = (unsigned char )((int )((uint16 )val) >> 8);
#line 915
    dst ++;
#line 916
    src ++;
#line 917
    if ((int )val == 0) {
#line 918
      goto while_break;
    }
#line 912
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (i);
}
}
#line 926 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void E_md4hash(unsigned char *passwd , unsigned char *p16 ) 
{ 
  int len ;
  short wpwd[129] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 932
  tmp = strlen((char const   *)((char *)passwd));
#line 932
  len = (int )tmp;
  }
#line 933
  if (len > 128) {
#line 934
    len = 128;
  }
  {
#line 936
  _my_mbstowcs(wpwd, passwd, len);
#line 937
  wpwd[len] = (short)0;
#line 939
  tmp___0 = _my_wcslen(wpwd);
#line 939
  len = (int )((unsigned long )tmp___0 * sizeof(short ));
#line 941
  mdfour(p16, (unsigned char *)(wpwd), len);
  }
#line 942
  return;
}
}
#line 945 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void nt_lm_owf_gen(char *pwd , unsigned char *nt_p16 , unsigned char *p16 ) 
{ 
  char passwd[130] ;

  {
  {
#line 949
  memset((void *)(passwd), '\000', (size_t )130);
#line 950
  safe_strcpy(passwd, (char const   *)pwd, sizeof(passwd) - 1UL);
#line 953
  memset((void *)nt_p16, '\000', (size_t )16);
#line 954
  E_md4hash((unsigned char *)(passwd), (unsigned char *)nt_p16);
#line 963
  passwd[14] = (char )'\000';
#line 964
  strupper(passwd);
#line 968
  memset((void *)p16, '\000', (size_t )16);
#line 969
  E_P16((unsigned char *)(passwd), (unsigned char *)p16);
#line 977
  memset((void *)(passwd), '\000', sizeof(passwd));
  }
#line 978
  return;
}
}
#line 981 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void SMBOWFencrypt(unsigned char *passwd , unsigned char *c8 , unsigned char *p24 ) 
{ 
  unsigned char p21[21] ;

  {
  {
#line 985
  memset((void *)(p21), '\000', (size_t )21);
#line 987
  memcpy((void */* __restrict  */)(p21), (void const   */* __restrict  */)passwd,
         (size_t )16);
#line 988
  E_P24(p21, c8, (unsigned char *)p24);
  }
#line 989
  return;
}
}
#line 992 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void NTLMSSPOWFencrypt(unsigned char *passwd , unsigned char *ntlmchalresp , unsigned char *p24 ) 
{ 
  unsigned char p21[21] ;

  {
  {
#line 996
  memset((void *)(p21), '\000', (size_t )21);
#line 997
  memcpy((void */* __restrict  */)(p21), (void const   */* __restrict  */)passwd,
         (size_t )8);
#line 998
  memset((void *)(p21 + 8), 189, (size_t )8);
#line 1000
  E_P24(p21, ntlmchalresp, (unsigned char *)p24);
  }
#line 1007
  return;
}
}
#line 1010 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void SMBNTencrypt(unsigned char *passwd , unsigned char *c8 , unsigned char *p24 ) 
{ 
  unsigned char p21[21] ;

  {
  {
#line 1014
  memset((void *)(p21), '\000', (size_t )21);
#line 1016
  E_md4hash(passwd, p21);
#line 1017
  SMBOWFencrypt((unsigned char *)(p21), c8, (unsigned char *)p24);
  }
#line 1025
  return;
}
}
#line 1101 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void dumpRaw(FILE *fp , unsigned char *buf___8 , size_t len ) 
{ 
  int i ;

  {
#line 1105
  i = 0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1105
    if (! (i < (int )len)) {
#line 1105
      goto while_break;
    }
    {
#line 1106
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%02x ",
            (int )*(buf___8 + i));
#line 1105
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1108
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 1109
  return;
}
}
#line 1114 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static char buf[1024]  ;
#line 1111 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static char *unicodeToString(char *p , size_t len ) 
{ 
  int i ;

  {
#line 1116
  if (! (len + 1UL < sizeof(buf))) {
    {
#line 1116
    __assert_fail("len+1 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1116U, "unicodeToString");
    }
  }
#line 1118
  i = 0;
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1118
    if (! (i < (int )len)) {
#line 1118
      goto while_break;
    }
#line 1120
    buf[i] = (char )((int )*p & 127);
#line 1121
    p += 2;
#line 1118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1124
  buf[i] = (char )'\000';
#line 1125
  return (buf);
}
}
#line 1130 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char buf___0[1024]  ;
#line 1128 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char *strToUnicode(char *p ) 
{ 
  size_t l ;
  size_t tmp ;
  int i ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1131
  tmp = strlen((char const   *)p);
#line 1131
  l = tmp;
#line 1132
  i = 0;
  }
#line 1134
  if (! (l * 2UL < sizeof(buf___0))) {
    {
#line 1134
    __assert_fail("l*2 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1134U, "strToUnicode");
    }
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    tmp___3 = l;
#line 1136
    l --;
#line 1136
    if (! tmp___3) {
#line 1136
      goto while_break;
    }
#line 1138
    tmp___0 = i;
#line 1138
    i ++;
#line 1138
    tmp___1 = p;
#line 1138
    p ++;
#line 1138
    buf___0[tmp___0] = (unsigned char )*tmp___1;
#line 1139
    tmp___2 = i;
#line 1139
    i ++;
#line 1139
    buf___0[tmp___2] = (unsigned char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  return (buf___0);
}
}
#line 1147 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char buf___1[1024]  ;
#line 1145 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char *toString(char *p , size_t len ) 
{ 


  {
#line 1149
  if (! (len + 1UL < sizeof(buf___1))) {
    {
#line 1149
    __assert_fail("len+1 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1149U, "toString");
    }
  }
  {
#line 1151
  memcpy((void */* __restrict  */)(buf___1), (void const   */* __restrict  */)p, len);
#line 1152
  buf___1[len] = (unsigned char)0;
  }
#line 1153
  return (buf___1);
}
}
#line 1157 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void buildAuthRequest(tSmbNtlmAuthRequest *request , long flags , char *host , char *domain ) 
{ 
  char *h ;
  char *p ;
  size_t tmp ;
  char *p___0 ;
  int len ;
  size_t tmp___0 ;
  uint16 tmp___1 ;
  size_t tmp___2 ;
  char *p___1 ;
  int len___0 ;
  size_t tmp___3 ;
  uint16 tmp___4 ;

  {
#line 1159
  h = (char *)((void *)0);
#line 1160
  p = (char *)((void *)0);
#line 1162
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1162
    host = (char *)"";
  }
#line 1163
  if ((unsigned long )domain == (unsigned long )((void *)0)) {
#line 1163
    domain = (char *)"";
  }
  {
#line 1165
  h = strdup((char const   *)host);
#line 1166
  p = strchr((char const   *)h, '@');
  }
#line 1167
  if (p) {
#line 1169
    if (! domain) {
#line 1170
      domain = p + 1;
    }
#line 1171
    *p = (char )'\000';
  }
#line 1174
  if (flags == 0L) {
#line 1174
    flags = 45575L;
  }
  {
#line 1175
  request->bufIndex = (uint32 )0;
#line 1176
  memcpy((void */* __restrict  */)(request->ident), (void const   */* __restrict  */)"NTLMSSP\000\000\000",
         (size_t )8);
#line 1177
  *((unsigned char *)(& request->msgType) + 0) = (unsigned char)1;
#line 1177
  *((unsigned char *)(& request->msgType) + 1) = (unsigned char )(1U >> 8);
#line 1177
  *((unsigned char *)(& request->msgType) + 2) = (unsigned char )((1U >> 16) & 255U);
#line 1177
  *((unsigned char *)(& request->msgType) + 3) = (unsigned char )((1U >> 16) >> 8);
#line 1178
  *((unsigned char *)(& request->flags) + 0) = (unsigned char )(((uint32 )flags & 65535U) & 255U);
#line 1178
  *((unsigned char *)(& request->flags) + 1) = (unsigned char )(((uint32 )flags & 65535U) >> 8);
#line 1178
  *((unsigned char *)(& request->flags) + 2) = (unsigned char )(((uint32 )flags >> 16) & 255U);
#line 1178
  *((unsigned char *)(& request->flags) + 3) = (unsigned char )(((uint32 )flags >> 16) >> 8);
#line 1180
  tmp = strlen((char const   *)host);
  }
#line 1180
  if (! (tmp < 128UL)) {
    {
#line 1180
    __assert_fail("strlen(host) < 128", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1180U, "buildAuthRequest");
    }
  }
#line 1181
  p___0 = h;
#line 1181
  len = 0;
#line 1181
  if (p___0) {
    {
#line 1181
    tmp___0 = strlen((char const   *)p___0);
#line 1181
    len = (int )tmp___0;
    }
  }
#line 1181
  if ((unsigned char *)p___0) {
#line 1181
    if (len) {
      {
#line 1181
      *((unsigned char *)(& request->host.len) + 0) = (unsigned char )((int )((uint16 )len) & 255);
#line 1181
      *((unsigned char *)(& request->host.len) + 1) = (unsigned char )((int )((uint16 )len) >> 8);
#line 1181
      *((unsigned char *)(& request->host.maxlen) + 0) = (unsigned char )((int )((uint16 )len) & 255);
#line 1181
      *((unsigned char *)(& request->host.maxlen) + 1) = (unsigned char )((int )((uint16 )len) >> 8);
#line 1181
      *((unsigned char *)(& request->host.offset) + 0) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) & 65535U) & 255U);
#line 1181
      *((unsigned char *)(& request->host.offset) + 1) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) & 65535U) >> 8);
#line 1181
      *((unsigned char *)(& request->host.offset) + 2) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) >> 16) & 255U);
#line 1181
      *((unsigned char *)(& request->host.offset) + 3) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) >> 16) >> 8);
#line 1181
      memcpy((void */* __restrict  */)(request->buffer + request->bufIndex), (void const   */* __restrict  */)((unsigned char *)p___0),
             (size_t )len);
#line 1181
      request->bufIndex += (uint32 )len;
      }
    } else {
#line 1181
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1181
    tmp___1 = (uint16 )0;
#line 1181
    request->host.maxlen = tmp___1;
#line 1181
    request->host.len = tmp___1;
#line 1181
    *((unsigned char *)(& request->host.offset) + 0) = (unsigned char )((request->bufIndex & 65535U) & 255U);
#line 1181
    *((unsigned char *)(& request->host.offset) + 1) = (unsigned char )((request->bufIndex & 65535U) >> 8);
#line 1181
    *((unsigned char *)(& request->host.offset) + 2) = (unsigned char )((request->bufIndex >> 16) & 255U);
#line 1181
    *((unsigned char *)(& request->host.offset) + 3) = (unsigned char )((request->bufIndex >> 16) >> 8);
  }
  {
#line 1183
  tmp___2 = strlen((char const   *)domain);
  }
#line 1183
  if (! (tmp___2 < 128UL)) {
    {
#line 1183
    __assert_fail("strlen(domain) < 128", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1183U, "buildAuthRequest");
    }
  }
#line 1184
  p___1 = domain;
#line 1184
  len___0 = 0;
#line 1184
  if (p___1) {
    {
#line 1184
    tmp___3 = strlen((char const   *)p___1);
#line 1184
    len___0 = (int )tmp___3;
    }
  }
#line 1184
  if ((unsigned char *)p___1) {
#line 1184
    if (len___0) {
      {
#line 1184
      *((unsigned char *)(& request->domain.len) + 0) = (unsigned char )((int )((uint16 )len___0) & 255);
#line 1184
      *((unsigned char *)(& request->domain.len) + 1) = (unsigned char )((int )((uint16 )len___0) >> 8);
#line 1184
      *((unsigned char *)(& request->domain.maxlen) + 0) = (unsigned char )((int )((uint16 )len___0) & 255);
#line 1184
      *((unsigned char *)(& request->domain.maxlen) + 1) = (unsigned char )((int )((uint16 )len___0) >> 8);
#line 1184
      *((unsigned char *)(& request->domain.offset) + 0) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) & 65535U) & 255U);
#line 1184
      *((unsigned char *)(& request->domain.offset) + 1) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) & 65535U) >> 8);
#line 1184
      *((unsigned char *)(& request->domain.offset) + 2) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) >> 16) & 255U);
#line 1184
      *((unsigned char *)(& request->domain.offset) + 3) = (unsigned char )(((uint32 )((request->buffer - (uint8 *)request) + (long )request->bufIndex) >> 16) >> 8);
#line 1184
      memcpy((void */* __restrict  */)(request->buffer + request->bufIndex), (void const   */* __restrict  */)((unsigned char *)p___1),
             (size_t )len___0);
#line 1184
      request->bufIndex += (uint32 )len___0;
      }
    } else {
#line 1184
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1184
    tmp___4 = (uint16 )0;
#line 1184
    request->domain.maxlen = tmp___4;
#line 1184
    request->domain.len = tmp___4;
#line 1184
    *((unsigned char *)(& request->domain.offset) + 0) = (unsigned char )((request->bufIndex & 65535U) & 255U);
#line 1184
    *((unsigned char *)(& request->domain.offset) + 1) = (unsigned char )((request->bufIndex & 65535U) >> 8);
#line 1184
    *((unsigned char *)(& request->domain.offset) + 2) = (unsigned char )((request->bufIndex >> 16) & 255U);
#line 1184
    *((unsigned char *)(& request->domain.offset) + 3) = (unsigned char )((request->bufIndex >> 16) >> 8);
  }
  {
#line 1186
  free((void *)h);
  }
#line 1187
  return;
}
}
#line 1190 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void buildAuthResponse(tSmbNtlmAuthChallenge *challenge , tSmbNtlmAuthResponse *response ,
                       long flags , char *user , char *password , char *domainname ,
                       char *host ) 
{ 
  uint8 lmRespData[24] ;
  uint8 ntRespData[24] ;
  char *u ;
  char *tmp ;
  char *p ;
  char *tmp___0 ;
  char *w ;
  char *d ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *domain ;
  uint16 tmp___3 ;
  uint16 tmp___4 ;
  size_t tmp___5 ;
  char *p___0 ;
  unsigned char *b ;
  int len ;
  size_t tmp___6 ;
  uint16 tmp___7 ;
  size_t tmp___8 ;
  char *p___1 ;
  unsigned char *b___0 ;
  int len___0 ;
  size_t tmp___9 ;
  uint16 tmp___10 ;
  size_t tmp___11 ;
  char *p___2 ;
  unsigned char *b___1 ;
  int len___1 ;
  size_t tmp___12 ;
  uint16 tmp___13 ;
  char *p___3 ;
  int len___2 ;
  size_t tmp___14 ;
  uint16 tmp___15 ;

  {
  {
#line 1194
  tmp = strdup((char const   *)user);
#line 1194
  u = tmp;
#line 1195
  tmp___0 = strchr((char const   *)u, '@');
#line 1195
  p = tmp___0;
#line 1196
  w = (char *)((void *)0);
#line 1197
  tmp___1 = unicodeToString((char *)challenge + (((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 0) | ((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 2) | ((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 3) << 8)) << 16)),
                            (size_t )(((unsigned int )*((unsigned char *)(& challenge->uDomain.len) + 0) | ((unsigned int )*((unsigned char *)(& challenge->uDomain.len) + 1) << 8)) / 2U));
#line 1197
  tmp___2 = strdup((char const   *)tmp___1);
#line 1197
  d = tmp___2;
#line 1198
  domain = d;
  }
#line 1200
  if ((unsigned long )domainname != (unsigned long )((void *)0)) {
#line 1200
    domain = domainname;
  }
#line 1202
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1202
    host = (char *)"";
  }
  {
#line 1203
  w = strdup((char const   *)host);
  }
#line 1205
  if (p) {
#line 1207
    domain = p + 1;
#line 1208
    *p = (char )'\000';
  }
  {
#line 1211
  SMBencrypt((unsigned char *)password, challenge->challengeData, lmRespData);
#line 1212
  SMBNTencrypt((unsigned char *)password, challenge->challengeData, ntRespData);
#line 1214
  response->bufIndex = (uint32 )0;
#line 1215
  memcpy((void */* __restrict  */)(response->ident), (void const   */* __restrict  */)"NTLMSSP\000\000\000",
         (size_t )8);
#line 1216
  *((unsigned char *)(& response->msgType) + 0) = (unsigned char)3;
#line 1216
  *((unsigned char *)(& response->msgType) + 1) = (unsigned char )(3U >> 8);
#line 1216
  *((unsigned char *)(& response->msgType) + 2) = (unsigned char )((3U >> 16) & 255U);
#line 1216
  *((unsigned char *)(& response->msgType) + 3) = (unsigned char )((3U >> 16) >> 8);
  }
#line 1218
  if (lmRespData) {
    {
#line 1218
    *((unsigned char *)(& response->lmResponse.len) + 0) = (unsigned char)24;
#line 1218
    *((unsigned char *)(& response->lmResponse.len) + 1) = (unsigned char )(24 >> 8);
#line 1218
    *((unsigned char *)(& response->lmResponse.maxlen) + 0) = (unsigned char)24;
#line 1218
    *((unsigned char *)(& response->lmResponse.maxlen) + 1) = (unsigned char )(24 >> 8);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 0) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) & 255U);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 1) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) >> 8);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 2) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) & 255U);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 3) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) >> 8);
#line 1218
    memcpy((void */* __restrict  */)(response->buffer + response->bufIndex), (void const   */* __restrict  */)(lmRespData),
           (size_t )24);
#line 1218
    response->bufIndex += 24U;
    }
  } else {
#line 1218
    tmp___3 = (uint16 )0;
#line 1218
    response->lmResponse.maxlen = tmp___3;
#line 1218
    response->lmResponse.len = tmp___3;
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 0) = (unsigned char )((response->bufIndex & 65535U) & 255U);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 1) = (unsigned char )((response->bufIndex & 65535U) >> 8);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 2) = (unsigned char )((response->bufIndex >> 16) & 255U);
#line 1218
    *((unsigned char *)(& response->lmResponse.offset) + 3) = (unsigned char )((response->bufIndex >> 16) >> 8);
  }
#line 1219
  if (ntRespData) {
    {
#line 1219
    *((unsigned char *)(& response->ntResponse.len) + 0) = (unsigned char)24;
#line 1219
    *((unsigned char *)(& response->ntResponse.len) + 1) = (unsigned char )(24 >> 8);
#line 1219
    *((unsigned char *)(& response->ntResponse.maxlen) + 0) = (unsigned char)24;
#line 1219
    *((unsigned char *)(& response->ntResponse.maxlen) + 1) = (unsigned char )(24 >> 8);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 0) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) & 255U);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 1) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) >> 8);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 2) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) & 255U);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 3) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) >> 8);
#line 1219
    memcpy((void */* __restrict  */)(response->buffer + response->bufIndex), (void const   */* __restrict  */)(ntRespData),
           (size_t )24);
#line 1219
    response->bufIndex += 24U;
    }
  } else {
#line 1219
    tmp___4 = (uint16 )0;
#line 1219
    response->ntResponse.maxlen = tmp___4;
#line 1219
    response->ntResponse.len = tmp___4;
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 0) = (unsigned char )((response->bufIndex & 65535U) & 255U);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 1) = (unsigned char )((response->bufIndex & 65535U) >> 8);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 2) = (unsigned char )((response->bufIndex >> 16) & 255U);
#line 1219
    *((unsigned char *)(& response->ntResponse.offset) + 3) = (unsigned char )((response->bufIndex >> 16) >> 8);
  }
  {
#line 1221
  tmp___5 = strlen((char const   *)domain);
  }
#line 1221
  if (! (tmp___5 < 128UL)) {
    {
#line 1221
    __assert_fail("strlen(domain) < 128", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1221U, "buildAuthResponse");
    }
  }
#line 1222
  p___0 = domain;
#line 1222
  b = (unsigned char *)((void *)0);
#line 1222
  len = 0;
#line 1222
  if (p___0) {
    {
#line 1222
    tmp___6 = strlen((char const   *)p___0);
#line 1222
    len = (int )tmp___6;
#line 1222
    b = strToUnicode(p___0);
    }
  }
#line 1222
  if (b) {
#line 1222
    if (len * 2) {
      {
#line 1222
      *((unsigned char *)(& response->uDomain.len) + 0) = (unsigned char )((int )((uint16 )(len * 2)) & 255);
#line 1222
      *((unsigned char *)(& response->uDomain.len) + 1) = (unsigned char )((int )((uint16 )(len * 2)) >> 8);
#line 1222
      *((unsigned char *)(& response->uDomain.maxlen) + 0) = (unsigned char )((int )((uint16 )(len * 2)) & 255);
#line 1222
      *((unsigned char *)(& response->uDomain.maxlen) + 1) = (unsigned char )((int )((uint16 )(len * 2)) >> 8);
#line 1222
      *((unsigned char *)(& response->uDomain.offset) + 0) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) & 255U);
#line 1222
      *((unsigned char *)(& response->uDomain.offset) + 1) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) >> 8);
#line 1222
      *((unsigned char *)(& response->uDomain.offset) + 2) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) & 255U);
#line 1222
      *((unsigned char *)(& response->uDomain.offset) + 3) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) >> 8);
#line 1222
      memcpy((void */* __restrict  */)(response->buffer + response->bufIndex), (void const   */* __restrict  */)b,
             (size_t )(len * 2));
#line 1222
      response->bufIndex += (uint32 )(len * 2);
      }
    } else {
#line 1222
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1222
    tmp___7 = (uint16 )0;
#line 1222
    response->uDomain.maxlen = tmp___7;
#line 1222
    response->uDomain.len = tmp___7;
#line 1222
    *((unsigned char *)(& response->uDomain.offset) + 0) = (unsigned char )((response->bufIndex & 65535U) & 255U);
#line 1222
    *((unsigned char *)(& response->uDomain.offset) + 1) = (unsigned char )((response->bufIndex & 65535U) >> 8);
#line 1222
    *((unsigned char *)(& response->uDomain.offset) + 2) = (unsigned char )((response->bufIndex >> 16) & 255U);
#line 1222
    *((unsigned char *)(& response->uDomain.offset) + 3) = (unsigned char )((response->bufIndex >> 16) >> 8);
  }
  {
#line 1224
  tmp___8 = strlen((char const   *)u);
  }
#line 1224
  if (! (tmp___8 < 128UL)) {
    {
#line 1224
    __assert_fail("strlen(u) < 128", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1224U, "buildAuthResponse");
    }
  }
#line 1225
  p___1 = u;
#line 1225
  b___0 = (unsigned char *)((void *)0);
#line 1225
  len___0 = 0;
#line 1225
  if (p___1) {
    {
#line 1225
    tmp___9 = strlen((char const   *)p___1);
#line 1225
    len___0 = (int )tmp___9;
#line 1225
    b___0 = strToUnicode(p___1);
    }
  }
#line 1225
  if (b___0) {
#line 1225
    if (len___0 * 2) {
      {
#line 1225
      *((unsigned char *)(& response->uUser.len) + 0) = (unsigned char )((int )((uint16 )(len___0 * 2)) & 255);
#line 1225
      *((unsigned char *)(& response->uUser.len) + 1) = (unsigned char )((int )((uint16 )(len___0 * 2)) >> 8);
#line 1225
      *((unsigned char *)(& response->uUser.maxlen) + 0) = (unsigned char )((int )((uint16 )(len___0 * 2)) & 255);
#line 1225
      *((unsigned char *)(& response->uUser.maxlen) + 1) = (unsigned char )((int )((uint16 )(len___0 * 2)) >> 8);
#line 1225
      *((unsigned char *)(& response->uUser.offset) + 0) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) & 255U);
#line 1225
      *((unsigned char *)(& response->uUser.offset) + 1) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) >> 8);
#line 1225
      *((unsigned char *)(& response->uUser.offset) + 2) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) & 255U);
#line 1225
      *((unsigned char *)(& response->uUser.offset) + 3) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) >> 8);
#line 1225
      memcpy((void */* __restrict  */)(response->buffer + response->bufIndex), (void const   */* __restrict  */)b___0,
             (size_t )(len___0 * 2));
#line 1225
      response->bufIndex += (uint32 )(len___0 * 2);
      }
    } else {
#line 1225
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1225
    tmp___10 = (uint16 )0;
#line 1225
    response->uUser.maxlen = tmp___10;
#line 1225
    response->uUser.len = tmp___10;
#line 1225
    *((unsigned char *)(& response->uUser.offset) + 0) = (unsigned char )((response->bufIndex & 65535U) & 255U);
#line 1225
    *((unsigned char *)(& response->uUser.offset) + 1) = (unsigned char )((response->bufIndex & 65535U) >> 8);
#line 1225
    *((unsigned char *)(& response->uUser.offset) + 2) = (unsigned char )((response->bufIndex >> 16) & 255U);
#line 1225
    *((unsigned char *)(& response->uUser.offset) + 3) = (unsigned char )((response->bufIndex >> 16) >> 8);
  }
  {
#line 1227
  tmp___11 = strlen((char const   *)w);
  }
#line 1227
  if (! (tmp___11 < 128UL)) {
    {
#line 1227
    __assert_fail("strlen(w) < 128", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1227U, "buildAuthResponse");
    }
  }
#line 1228
  p___2 = w;
#line 1228
  b___1 = (unsigned char *)((void *)0);
#line 1228
  len___1 = 0;
#line 1228
  if (p___2) {
    {
#line 1228
    tmp___12 = strlen((char const   *)p___2);
#line 1228
    len___1 = (int )tmp___12;
#line 1228
    b___1 = strToUnicode(p___2);
    }
  }
#line 1228
  if (b___1) {
#line 1228
    if (len___1 * 2) {
      {
#line 1228
      *((unsigned char *)(& response->uWks.len) + 0) = (unsigned char )((int )((uint16 )(len___1 * 2)) & 255);
#line 1228
      *((unsigned char *)(& response->uWks.len) + 1) = (unsigned char )((int )((uint16 )(len___1 * 2)) >> 8);
#line 1228
      *((unsigned char *)(& response->uWks.maxlen) + 0) = (unsigned char )((int )((uint16 )(len___1 * 2)) & 255);
#line 1228
      *((unsigned char *)(& response->uWks.maxlen) + 1) = (unsigned char )((int )((uint16 )(len___1 * 2)) >> 8);
#line 1228
      *((unsigned char *)(& response->uWks.offset) + 0) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) & 255U);
#line 1228
      *((unsigned char *)(& response->uWks.offset) + 1) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) >> 8);
#line 1228
      *((unsigned char *)(& response->uWks.offset) + 2) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) & 255U);
#line 1228
      *((unsigned char *)(& response->uWks.offset) + 3) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) >> 8);
#line 1228
      memcpy((void */* __restrict  */)(response->buffer + response->bufIndex), (void const   */* __restrict  */)b___1,
             (size_t )(len___1 * 2));
#line 1228
      response->bufIndex += (uint32 )(len___1 * 2);
      }
    } else {
#line 1228
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 1228
    tmp___13 = (uint16 )0;
#line 1228
    response->uWks.maxlen = tmp___13;
#line 1228
    response->uWks.len = tmp___13;
#line 1228
    *((unsigned char *)(& response->uWks.offset) + 0) = (unsigned char )((response->bufIndex & 65535U) & 255U);
#line 1228
    *((unsigned char *)(& response->uWks.offset) + 1) = (unsigned char )((response->bufIndex & 65535U) >> 8);
#line 1228
    *((unsigned char *)(& response->uWks.offset) + 2) = (unsigned char )((response->bufIndex >> 16) & 255U);
#line 1228
    *((unsigned char *)(& response->uWks.offset) + 3) = (unsigned char )((response->bufIndex >> 16) >> 8);
  }
#line 1230
  p___3 = (char *)((void *)0);
#line 1230
  len___2 = 0;
#line 1230
  if (p___3) {
    {
#line 1230
    tmp___14 = strlen((char const   *)p___3);
#line 1230
    len___2 = (int )tmp___14;
    }
  }
#line 1230
  if ((unsigned char *)p___3) {
#line 1230
    if (len___2) {
      {
#line 1230
      *((unsigned char *)(& response->sessionKey.len) + 0) = (unsigned char )((int )((uint16 )len___2) & 255);
#line 1230
      *((unsigned char *)(& response->sessionKey.len) + 1) = (unsigned char )((int )((uint16 )len___2) >> 8);
#line 1230
      *((unsigned char *)(& response->sessionKey.maxlen) + 0) = (unsigned char )((int )((uint16 )len___2) & 255);
#line 1230
      *((unsigned char *)(& response->sessionKey.maxlen) + 1) = (unsigned char )((int )((uint16 )len___2) >> 8);
#line 1230
      *((unsigned char *)(& response->sessionKey.offset) + 0) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) & 255U);
#line 1230
      *((unsigned char *)(& response->sessionKey.offset) + 1) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) & 65535U) >> 8);
#line 1230
      *((unsigned char *)(& response->sessionKey.offset) + 2) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) & 255U);
#line 1230
      *((unsigned char *)(& response->sessionKey.offset) + 3) = (unsigned char )(((uint32 )((response->buffer - (uint8 *)response) + (long )response->bufIndex) >> 16) >> 8);
#line 1230
      memcpy((void */* __restrict  */)(response->buffer + response->bufIndex), (void const   */* __restrict  */)((unsigned char *)p___3),
             (size_t )len___2);
#line 1230
      response->bufIndex += (uint32 )len___2;
      }
    } else {
#line 1230
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
#line 1230
    tmp___15 = (uint16 )0;
#line 1230
    response->sessionKey.maxlen = tmp___15;
#line 1230
    response->sessionKey.len = tmp___15;
#line 1230
    *((unsigned char *)(& response->sessionKey.offset) + 0) = (unsigned char )((response->bufIndex & 65535U) & 255U);
#line 1230
    *((unsigned char *)(& response->sessionKey.offset) + 1) = (unsigned char )((response->bufIndex & 65535U) >> 8);
#line 1230
    *((unsigned char *)(& response->sessionKey.offset) + 2) = (unsigned char )((response->bufIndex >> 16) & 255U);
#line 1230
    *((unsigned char *)(& response->sessionKey.offset) + 3) = (unsigned char )((response->bufIndex >> 16) >> 8);
  }
#line 1232
  if (flags != 0L) {
#line 1232
    challenge->flags = (uint32 )flags;
  }
#line 1233
  response->flags = challenge->flags;
#line 1235
  if (d) {
    {
#line 1235
    free((void *)d);
    }
  }
#line 1236
  if (u) {
    {
#line 1236
    free((void *)u);
    }
  }
#line 1237
  return;
}
}
#line 1240 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void dumpAuthRequest(tSmbNtlmAuthRequest *request ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 1242
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NTLM Request:\n");
#line 1243
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Ident = %s\n",
          request->ident);
#line 1244
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      mType = %d\n",
          ((unsigned int )*((unsigned char *)(& request->msgType) + 0) | ((unsigned int )*((unsigned char *)(& request->msgType) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& request->msgType) + 2) | ((unsigned int )*((unsigned char *)(& request->msgType) + 3) << 8)) << 16));
#line 1245
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Flags = %08x\n",
          ((unsigned int )*((unsigned char *)(& request->flags) + 0) | ((unsigned int )*((unsigned char *)(& request->flags) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& request->flags) + 2) | ((unsigned int )*((unsigned char *)(& request->flags) + 3) << 8)) << 16));
#line 1246
  tmp = toString((char *)request + (((unsigned int )*((unsigned char *)(& request->host.offset) + 0) | ((unsigned int )*((unsigned char *)(& request->host.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& request->host.offset) + 2) | ((unsigned int )*((unsigned char *)(& request->host.offset) + 3) << 8)) << 16)),
                 (size_t )((unsigned int )*((unsigned char *)(& request->host.len) + 0) | ((unsigned int )*((unsigned char *)(& request->host.len) + 1) << 8)));
#line 1246
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       Host = %s\n",
          tmp);
#line 1247
  tmp___0 = toString((char *)request + (((unsigned int )*((unsigned char *)(& request->domain.offset) + 0) | ((unsigned int )*((unsigned char *)(& request->domain.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& request->domain.offset) + 2) | ((unsigned int )*((unsigned char *)(& request->domain.offset) + 3) << 8)) << 16)),
                     (size_t )((unsigned int )*((unsigned char *)(& request->domain.len) + 0) | ((unsigned int )*((unsigned char *)(& request->domain.len) + 1) << 8)));
#line 1247
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     Domain = %s\n",
          tmp___0);
  }
#line 1248
  return;
}
}
#line 1250 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void dumpAuthChallenge(tSmbNtlmAuthChallenge *challenge ) 
{ 
  char *tmp ;

  {
  {
#line 1252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NTLM Challenge:\n");
#line 1253
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Ident = %s\n",
          challenge->ident);
#line 1254
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      mType = %d\n",
          ((unsigned int )*((unsigned char *)(& challenge->msgType) + 0) | ((unsigned int )*((unsigned char *)(& challenge->msgType) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& challenge->msgType) + 2) | ((unsigned int )*((unsigned char *)(& challenge->msgType) + 3) << 8)) << 16));
#line 1255
  tmp = unicodeToString((char *)challenge + (((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 0) | ((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 2) | ((unsigned int )*((unsigned char *)(& challenge->uDomain.offset) + 3) << 8)) << 16)),
                        (size_t )(((unsigned int )*((unsigned char *)(& challenge->uDomain.len) + 0) | ((unsigned int )*((unsigned char *)(& challenge->uDomain.len) + 1) << 8)) / 2U));
#line 1255
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     Domain = %s\n",
          tmp);
#line 1256
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Flags = %08x\n",
          ((unsigned int )*((unsigned char *)(& challenge->flags) + 0) | ((unsigned int )*((unsigned char *)(& challenge->flags) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& challenge->flags) + 2) | ((unsigned int )*((unsigned char *)(& challenge->flags) + 3) << 8)) << 16));
#line 1257
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Challenge = ");
#line 1257
  dumpRaw(stderr, challenge->challengeData, (size_t )8);
#line 1258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Uncomplete!! parse optional parameters\n");
  }
#line 1259
  return;
}
}
#line 1261 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
void dumpAuthResponse(tSmbNtlmAuthResponse *response ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NTLM Response:\n");
#line 1264
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Ident = %s\n",
          response->ident);
#line 1265
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      mType = %d\n",
          ((unsigned int )*((unsigned char *)(& response->msgType) + 0) | ((unsigned int )*((unsigned char *)(& response->msgType) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->msgType) + 2) | ((unsigned int )*((unsigned char *)(& response->msgType) + 3) << 8)) << 16));
#line 1266
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     LmResp = ");
#line 1266
  dumpRaw(stderr, (unsigned char *)response + (((unsigned int )*((unsigned char *)(& response->lmResponse.offset) + 0) | ((unsigned int )*((unsigned char *)(& response->lmResponse.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->lmResponse.offset) + 2) | ((unsigned int )*((unsigned char *)(& response->lmResponse.offset) + 3) << 8)) << 16)),
          (size_t )((unsigned int )*((unsigned char *)(& response->lmResponse.len) + 0) | ((unsigned int )*((unsigned char *)(& response->lmResponse.len) + 1) << 8)));
#line 1267
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     NTResp = ");
#line 1267
  dumpRaw(stderr, (unsigned char *)response + (((unsigned int )*((unsigned char *)(& response->ntResponse.offset) + 0) | ((unsigned int )*((unsigned char *)(& response->ntResponse.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->ntResponse.offset) + 2) | ((unsigned int )*((unsigned char *)(& response->ntResponse.offset) + 3) << 8)) << 16)),
          (size_t )((unsigned int )*((unsigned char *)(& response->ntResponse.len) + 0) | ((unsigned int )*((unsigned char *)(& response->ntResponse.len) + 1) << 8)));
#line 1268
  tmp = unicodeToString((char *)response + (((unsigned int )*((unsigned char *)(& response->uDomain.offset) + 0) | ((unsigned int )*((unsigned char *)(& response->uDomain.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->uDomain.offset) + 2) | ((unsigned int )*((unsigned char *)(& response->uDomain.offset) + 3) << 8)) << 16)),
                        (size_t )(((unsigned int )*((unsigned char *)(& response->uDomain.len) + 0) | ((unsigned int )*((unsigned char *)(& response->uDomain.len) + 1) << 8)) / 2U));
#line 1268
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     Domain = %s\n",
          tmp);
#line 1269
  tmp___0 = unicodeToString((char *)response + (((unsigned int )*((unsigned char *)(& response->uUser.offset) + 0) | ((unsigned int )*((unsigned char *)(& response->uUser.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->uUser.offset) + 2) | ((unsigned int )*((unsigned char *)(& response->uUser.offset) + 3) << 8)) << 16)),
                            (size_t )(((unsigned int )*((unsigned char *)(& response->uUser.len) + 0) | ((unsigned int )*((unsigned char *)(& response->uUser.len) + 1) << 8)) / 2U));
#line 1269
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       User = %s\n",
          tmp___0);
#line 1270
  tmp___1 = unicodeToString((char *)response + (((unsigned int )*((unsigned char *)(& response->uWks.offset) + 0) | ((unsigned int )*((unsigned char *)(& response->uWks.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->uWks.offset) + 2) | ((unsigned int )*((unsigned char *)(& response->uWks.offset) + 3) << 8)) << 16)),
                            (size_t )(((unsigned int )*((unsigned char *)(& response->uWks.len) + 0) | ((unsigned int )*((unsigned char *)(& response->uWks.len) + 1) << 8)) / 2U));
#line 1270
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        Wks = %s\n",
          tmp___1);
#line 1271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       sKey = ");
#line 1271
  dumpRaw(stderr, (unsigned char *)response + (((unsigned int )*((unsigned char *)(& response->sessionKey.offset) + 0) | ((unsigned int )*((unsigned char *)(& response->sessionKey.offset) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->sessionKey.offset) + 2) | ((unsigned int )*((unsigned char *)(& response->sessionKey.offset) + 3) << 8)) << 16)),
          (size_t )((unsigned int )*((unsigned char *)(& response->sessionKey.len) + 0) | ((unsigned int )*((unsigned char *)(& response->sessionKey.len) + 1) << 8)));
#line 1272
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Flags = %08x\n",
          ((unsigned int )*((unsigned char *)(& response->flags) + 0) | ((unsigned int )*((unsigned char *)(& response->flags) + 1) << 8)) | (((unsigned int )*((unsigned char *)(& response->flags) + 2) | ((unsigned int )*((unsigned char *)(& response->flags) + 3) << 8)) << 16));
  }
#line 1273
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
int initConnection(_MODULE_DATA___0 *_psSessionData , int hSocket , sConnectParams *params ) ;
#line 361 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
int initConnection(_MODULE_DATA___0 *_psSessionData , int hSocket , sConnectParams *params ) 
{ 
  unsigned char *bufSend ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  int nSendBufferSize ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
  {
#line 363
  bufSend = (unsigned char *)((void *)0);
#line 364
  bufReceive = (unsigned char *)((void *)0);
#line 365
  nReceiveBufferSize = 0;
#line 366
  nSendBufferSize = 0;
#line 369
  tmp___1 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "^\\* OK .*\r\n");
  }
#line 369
  if (tmp___1 == -1) {
    {
#line 371
    writeError(3, "[%s] Failed to retrieve IMAP server banner. Exiting...", "imap.mod");
    }
#line 372
    return (-1);
  } else
#line 369
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 371
    writeError(3, "[%s] Failed to retrieve IMAP server banner. Exiting...", "imap.mod");
    }
#line 372
    return (-1);
  } else {
    {
#line 374
    tmp___0 = strstr((char const   *)bufReceive, "* OK ");
    }
#line 374
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
#line 376
      writeError(10, "[%s] Received IMAP server banner: %s", "imap.mod", bufReceive);
      }
#line 377
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 377
        free((void *)bufReceive);
#line 377
        bufReceive = (unsigned char *)((void *)0);
        }
      }
    } else {
      {
#line 379
      tmp = strstr((char const   *)bufReceive, "* BYE Connection refused");
      }
#line 379
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        {
#line 381
        writeError(3, "[%s] IMAP server refused connection. Is SSL required?", "imap.mod");
        }
#line 382
        if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
          {
#line 382
          free((void *)bufReceive);
#line 382
          bufReceive = (unsigned char *)((void *)0);
          }
        }
#line 383
        return (-1);
      } else {
        {
#line 387
        writeError(3, "[%s] Failed to retrieve IMAP server banner.", "imap.mod");
        }
#line 388
        if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
          {
#line 388
          free((void *)bufReceive);
#line 388
          bufReceive = (unsigned char *)((void *)0);
          }
        }
#line 389
        return (-1);
      }
    }
  }
  {
#line 393
  writeError(10, "[%s] Sending IMAP CAPABILITIES request.", "imap.mod");
#line 394
  tmp___2 = strlen((char const   *)_psSessionData->szTag);
#line 394
  nSendBufferSize = (int )(tmp___2 + 13UL);
#line 395
  tmp___3 = malloc((size_t )(nSendBufferSize + 1));
#line 395
  bufSend = (unsigned char *)tmp___3;
#line 396
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 397
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s CAPABILITY\r\n",
          _psSessionData->szTag);
#line 399
  tmp___4 = strlen((char const   *)bufSend);
#line 399
  tmp___5 = medusaSend(hSocket, (char *)bufSend, (int )tmp___4, 0);
  }
#line 399
  if (tmp___5 < 0) {
    {
#line 401
    writeError(3, "[%s] Failed: medusaSend was not successful", "imap.mod");
    }
#line 402
    if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
      {
#line 402
      free((void *)bufSend);
#line 402
      bufSend = (unsigned char *)((void *)0);
      }
    }
#line 403
    return (-1);
  }
#line 405
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 405
    free((void *)bufSend);
#line 405
    bufSend = (unsigned char *)((void *)0);
    }
  }
  {
#line 407
  nReceiveBufferSize = 0;
#line 408
  tmp___6 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "OK .*\r\n");
  }
#line 408
  if (tmp___6 == -1) {
    {
#line 410
    writeError(3, "[%s] Failed: No OK message received for CAPABILITY request.", "imap.mod");
    }
#line 411
    return (-1);
  } else
#line 408
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 410
    writeError(3, "[%s] Failed: No OK message received for CAPABILITY request.", "imap.mod");
    }
#line 411
    return (-1);
  }
#line 415
  if (params->nUseSSL == 0) {
    {
#line 415
    tmp___19 = strstr((char const   *)bufReceive, "STARTTLS");
    }
#line 415
    if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
#line 417
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 417
        free((void *)bufReceive);
#line 417
        bufReceive = (unsigned char *)((void *)0);
        }
      }
      {
#line 419
      writeError(10, "[%s] Initiating STARTTLS session.", "imap.mod");
#line 421
      tmp___7 = strlen((char const   *)_psSessionData->szTag);
#line 421
      tmp___8 = malloc((tmp___7 + 11UL) + 1UL);
#line 421
      bufSend = (unsigned char *)tmp___8;
#line 422
      tmp___9 = strlen((char const   *)_psSessionData->szTag);
#line 422
      memset((void *)bufSend, 0, (tmp___9 + 11UL) + 1UL);
#line 423
      sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s STARTTLS\r\n",
              _psSessionData->szTag);
#line 424
      tmp___10 = strlen((char const   *)bufSend);
#line 424
      tmp___11 = medusaSend(hSocket, (char *)bufSend, (int )tmp___10, 0);
      }
#line 424
      if (tmp___11 < 0) {
        {
#line 426
        writeError(3, "[%s] failed: medusaSend was not successful", "imap.mod");
        }
#line 427
        if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
          {
#line 427
          free((void *)bufSend);
#line 427
          bufSend = (unsigned char *)((void *)0);
          }
        }
#line 428
        return (-1);
      }
#line 430
      if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
        {
#line 430
        free((void *)bufSend);
#line 430
        bufSend = (unsigned char *)((void *)0);
        }
      }
      {
#line 432
      nReceiveBufferSize = 0;
#line 433
      tmp___18 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "OK .*\r\n");
      }
#line 433
      if (tmp___18 == -1) {
        {
#line 435
        writeError(3, "[%s] Failed: No OK message received for STARTTLS request.",
                   "imap.mod");
        }
#line 436
        return (-1);
      } else
#line 433
      if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
        {
#line 435
        writeError(3, "[%s] Failed: No OK message received for STARTTLS request.",
                   "imap.mod");
        }
#line 436
        return (-1);
      } else {
#line 441
        if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
          {
#line 441
          free((void *)bufReceive);
#line 441
          bufReceive = (unsigned char *)((void *)0);
          }
        }
        {
#line 443
        params->nSSLVersion = (float )3.1;
#line 444
        tmp___12 = medusaConnectSocketSSL(params, hSocket);
        }
#line 444
        if (tmp___12 < 0) {
          {
#line 446
          writeError(3, "[%s] Failed to establish TLSv1 connection.", "imap.mod");
          }
#line 447
          return (-1);
        }
        {
#line 451
        writeError(10, "[%s] Sending IMAP CAPABILITIES request.", "imap.mod");
#line 452
        tmp___13 = strlen((char const   *)_psSessionData->szTag);
#line 452
        nSendBufferSize = (int )(tmp___13 + 13UL);
#line 453
        tmp___14 = malloc((size_t )(nSendBufferSize + 1));
#line 453
        bufSend = (unsigned char *)tmp___14;
#line 454
        memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 455
        sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s CAPABILITY\r\n",
                _psSessionData->szTag);
#line 457
        tmp___15 = strlen((char const   *)bufSend);
#line 457
        tmp___16 = medusaSend(hSocket, (char *)bufSend, (int )tmp___15, 0);
        }
#line 457
        if (tmp___16 < 0) {
          {
#line 459
          writeError(3, "[%s] Failed: medusaSend was not successful", "imap.mod");
          }
#line 460
          if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
            {
#line 460
            free((void *)bufSend);
#line 460
            bufSend = (unsigned char *)((void *)0);
            }
          }
#line 461
          return (-1);
        }
#line 463
        if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
          {
#line 463
          free((void *)bufSend);
#line 463
          bufSend = (unsigned char *)((void *)0);
          }
        }
        {
#line 465
        nReceiveBufferSize = 0;
#line 466
        tmp___17 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize,
                                      "OK .*\r\n");
        }
#line 466
        if (tmp___17 == -1) {
          {
#line 468
          writeError(3, "[%s] Failed: No OK message received for CAPABILITY request.",
                     "imap.mod");
          }
#line 469
          return (-1);
        } else
#line 466
        if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
          {
#line 468
          writeError(3, "[%s] Failed: No OK message received for CAPABILITY request.",
                     "imap.mod");
          }
#line 469
          return (-1);
        }
      }
    }
  }
#line 475
  if (_psSessionData->nAuthType != 0) {
    {
#line 477
    writeError(10, "[%s] Ignoring server requested AUTH type and using user-specified value.",
               "imap.mod");
    }
  } else {
    {
#line 479
    tmp___22 = strstr((char const   *)bufReceive, "AUTH=LOGIN");
    }
#line 479
    if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
      {
#line 481
      writeError(10, "Server requested authentication type: LOGIN");
#line 482
      _psSessionData->nAuthType = 1;
      }
    } else {
      {
#line 484
      tmp___21 = strstr((char const   *)bufReceive, "AUTH=PLAIN");
      }
#line 484
      if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
        {
#line 486
        writeError(10, "Server requested authentication type: PLAIN");
#line 487
        _psSessionData->nAuthType = 2;
        }
      } else {
        {
#line 489
        tmp___20 = strstr((char const   *)bufReceive, "AUTH=NTLM");
        }
#line 489
        if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
          {
#line 491
          writeError(10, "Server requested authentication type: NTLM");
#line 492
          _psSessionData->nAuthType = 3;
          }
        } else {
          {
#line 496
          writeError(3, "[%s] Failed: Server did not respond that it supported any of the authentication types we handle (PLAIN, LOGIN, NTLM). Use the AUTH module option to force the use of an authentication type.",
                     "imap.mod");
          }
#line 497
          return (-1);
        }
      }
    }
  }
#line 500
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 500
    free((void *)bufReceive);
#line 500
    bufReceive = (unsigned char *)((void *)0);
    }
  }
#line 501
  return (0);
}
}
#line 505 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
int sendAuthLogin(int hSocket , _MODULE_DATA___0 *_psSessionData , char *szLogin ,
                  char *szPassword ) 
{ 
  unsigned char *bufSend ;
  unsigned char *szEncodedAuth ;
  int nSendBufferSize ;
  int nRet ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 507
  bufSend = (unsigned char *)((void *)0);
#line 508
  szEncodedAuth = (unsigned char *)((void *)0);
#line 509
  nSendBufferSize = 0;
#line 510
  nRet = 0;
#line 512
  tmp = strlen((char const   *)_psSessionData->szTag);
#line 512
  tmp___0 = strlen((char const   *)szLogin);
#line 512
  tmp___1 = strlen((char const   *)szPassword);
#line 512
  nSendBufferSize = (int )((((((tmp + 7UL) + tmp___0) + 1UL) + tmp___1) + 4UL) + 2UL);
#line 513
  tmp___2 = malloc((size_t )(nSendBufferSize + 1));
#line 513
  bufSend = (unsigned char *)tmp___2;
#line 514
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
  }
#line 516
  if (_psSessionData->szDomain) {
    {
#line 518
    writeError(10, "[%s] Sending authenticate login value: %s\\\\%s %s", "imap.mod",
               _psSessionData->szDomain, szLogin, szPassword);
#line 519
    sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s LOGIN \"%s\\\\%s\" \"%s\"\r\n",
            _psSessionData->szTag, _psSessionData->szDomain, szLogin, szPassword);
    }
  } else {
    {
#line 523
    writeError(10, "[%s] Sending authenticate login value: %s %s", "imap.mod", szLogin,
               szPassword);
#line 524
    sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s LOGIN \"%s\" \"%s\"\r\n",
            _psSessionData->szTag, szLogin, szPassword);
    }
  }
  {
#line 527
  tmp___3 = strlen((char const   *)bufSend);
#line 527
  tmp___4 = medusaSend(hSocket, (char *)bufSend, (int )tmp___3, 0);
  }
#line 527
  if (tmp___4 < 0) {
    {
#line 529
    writeError(3, "%s failed: medusaSend was not successful", "imap.mod");
#line 530
    nRet = -1;
    }
  }
#line 533
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 533
    free((void *)bufSend);
#line 533
    bufSend = (unsigned char *)((void *)0);
    }
  }
#line 534
  return (nRet);
}
}
#line 538 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
int sendAuthPlain(int hSocket , _MODULE_DATA___0 *_psSessionData , char *szLogin ,
                  char *szPassword ) 
{ 
  unsigned char *bufSend ;
  unsigned char *bufReceive ;
  unsigned char *szTmp ;
  unsigned char *szEncodedAuth ;
  int nSendBufferSize ;
  int nReceiveBufferSize ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;

  {
  {
#line 540
  bufSend = (unsigned char *)((void *)0);
#line 541
  bufReceive = (unsigned char *)((void *)0);
#line 542
  szTmp = (unsigned char *)((void *)0);
#line 543
  szEncodedAuth = (unsigned char *)((void *)0);
#line 544
  nSendBufferSize = 0;
#line 545
  nReceiveBufferSize = 0;
#line 548
  tmp = strlen((char const   *)_psSessionData->szTag);
#line 548
  nSendBufferSize = (int )(tmp + 21UL);
#line 549
  tmp___0 = malloc((size_t )(nSendBufferSize + 1));
#line 549
  bufSend = (unsigned char *)tmp___0;
#line 550
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 551
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s AUTHENTICATE PLAIN\r\n",
          _psSessionData->szTag);
#line 553
  tmp___1 = strlen((char const   *)bufSend);
#line 553
  tmp___2 = medusaSend(hSocket, (char *)bufSend, (int )tmp___1, 0);
  }
#line 553
  if (tmp___2 < 0) {
    {
#line 555
    writeError(3, "%s failed: medusaSend was not successful", "imap.mod");
    }
  }
#line 557
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 557
    free((void *)bufSend);
#line 557
    bufSend = (unsigned char *)((void *)0);
    }
  }
  {
#line 559
  nReceiveBufferSize = 0;
#line 560
  tmp___3 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+.*\r\n");
  }
#line 560
  if (tmp___3 == -1) {
    {
#line 562
    writeError(3, "[%s] IMAP server did not respond with \"+\" to AUTHENTICATE PLAIN request.",
               "imap.mod");
#line 563
    writeError(3, "[%s] IMAP server sent the following response: %s", "imap.mod",
               bufReceive);
    }
#line 564
    return (-1);
  } else
#line 560
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 562
    writeError(3, "[%s] IMAP server did not respond with \"+\" to AUTHENTICATE PLAIN request.",
               "imap.mod");
#line 563
    writeError(3, "[%s] IMAP server sent the following response: %s", "imap.mod",
               bufReceive);
    }
#line 564
    return (-1);
  }
  {
#line 568
  tmp___4 = strlen((char const   *)szLogin);
#line 568
  tmp___5 = strlen((char const   *)szLogin);
#line 568
  tmp___6 = strlen((char const   *)szPassword);
#line 568
  nSendBufferSize = (int )((((tmp___4 + 1UL) + tmp___5) + 1UL) + tmp___6);
#line 570
  tmp___7 = malloc((size_t )(nSendBufferSize + 1));
#line 570
  szTmp = (unsigned char *)tmp___7;
#line 571
  memset((void *)szTmp, 0, (size_t )(nSendBufferSize + 1));
#line 574
  tmp___8 = strlen((char const   *)szLogin);
#line 574
  memcpy((void */* __restrict  */)szTmp, (void const   */* __restrict  */)szLogin,
         tmp___8);
#line 575
  tmp___9 = strlen((char const   *)szLogin);
#line 575
  tmp___10 = strlen((char const   *)szLogin);
#line 575
  memcpy((void */* __restrict  */)((szTmp + tmp___10) + 1), (void const   */* __restrict  */)szLogin,
         tmp___9);
#line 576
  tmp___11 = strlen((char const   *)szPassword);
#line 576
  tmp___12 = strlen((char const   *)szLogin);
#line 576
  tmp___13 = strlen((char const   *)szLogin);
#line 576
  memcpy((void */* __restrict  */)((((szTmp + tmp___12) + 1) + tmp___13) + 1), (void const   */* __restrict  */)szPassword,
         tmp___11);
#line 578
  tmp___14 = malloc((size_t )(2 * nSendBufferSize + 1));
#line 578
  szEncodedAuth = (unsigned char *)tmp___14;
#line 579
  memset((void *)szEncodedAuth, 0, (size_t )(2 * nSendBufferSize + 1));
#line 580
  base64_encode((char const   *)szTmp, nSendBufferSize, (char *)szEncodedAuth);
  }
#line 581
  if ((unsigned long )szTmp != (unsigned long )((void *)0)) {
    {
#line 581
    free((void *)szTmp);
#line 581
    szTmp = (unsigned char *)((void *)0);
    }
  }
  {
#line 583
  writeError(10, "[%s] Sending authenticate plain value: %s", "imap.mod", szEncodedAuth);
#line 584
  tmp___15 = strlen((char const   *)szEncodedAuth);
#line 584
  nSendBufferSize = (int )(tmp___15 + 2UL);
#line 585
  tmp___16 = malloc((size_t )(nSendBufferSize + 1));
#line 585
  bufSend = (unsigned char *)tmp___16;
#line 586
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 587
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s\r\n",
          szEncodedAuth);
  }
#line 588
  if ((unsigned long )szEncodedAuth != (unsigned long )((void *)0)) {
    {
#line 588
    free((void *)szEncodedAuth);
#line 588
    szEncodedAuth = (unsigned char *)((void *)0);
    }
  }
  {
#line 590
  tmp___17 = strlen((char const   *)bufSend);
#line 590
  tmp___18 = medusaSend(hSocket, (char *)bufSend, (int )tmp___17, 0);
  }
#line 590
  if (tmp___18 < 0) {
    {
#line 592
    writeError(3, "%s failed: medusaSend was not successful", "imap.mod");
    }
#line 593
    return (-1);
  }
#line 596
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 596
    free((void *)bufSend);
#line 596
    bufSend = (unsigned char *)((void *)0);
    }
  }
#line 597
  return (0);
}
}
#line 608 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/imap.c"
int sendAuthNTLM(int hSocket , _MODULE_DATA___0 *_psSessionData , char *szLogin ,
                 char *szPassword ) 
{ 
  unsigned char *bufSend ;
  unsigned char *bufReceive ;
  int nSendBufferSize ;
  int nReceiveBufferSize ;
  tSmbNtlmAuthRequest sTmpReq ;
  tSmbNtlmAuthChallenge sTmpChall ;
  tSmbNtlmAuthResponse sTmpResp ;
  unsigned char *szTmpBuf ;
  unsigned char *szTmpBuf64 ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 610
  bufSend = (unsigned char *)((void *)0);
#line 611
  bufReceive = (unsigned char *)((void *)0);
#line 612
  nSendBufferSize = 0;
#line 613
  nReceiveBufferSize = 0;
#line 617
  szTmpBuf = (unsigned char *)((void *)0);
#line 618
  szTmpBuf64 = (unsigned char *)((void *)0);
#line 621
  tmp = strlen((char const   *)_psSessionData->szTag);
#line 621
  nSendBufferSize = (int )(tmp + 21UL);
#line 622
  tmp___0 = malloc((size_t )(nSendBufferSize + 1));
#line 622
  bufSend = (unsigned char *)tmp___0;
#line 623
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 624
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s AUTHENTICATE NTLM\r\n",
          _psSessionData->szTag);
#line 626
  tmp___1 = strlen((char const   *)bufSend);
#line 626
  tmp___2 = medusaSend(hSocket, (char *)bufSend, (int )tmp___1, 0);
  }
#line 626
  if (tmp___2 < 0) {
    {
#line 628
    writeError(3, "%s failed: medusaSend was not successful", "imap.mod");
    }
  }
#line 630
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 630
    free((void *)bufSend);
#line 630
    bufSend = (unsigned char *)((void *)0);
    }
  }
  {
#line 633
  nReceiveBufferSize = 0;
#line 634
  tmp___3 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+\r\n");
  }
#line 634
  if (tmp___3 == -1) {
    {
#line 636
    writeError(3, "[%s] IMAP server did not respond with \"+\" to AUTHENTICATE NTLM request.",
               "imap.mod");
#line 637
    writeError(3, "[%s] IMAP server sent the following response: %s", "imap.mod",
               bufReceive);
    }
#line 638
    return (-1);
  } else
#line 634
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 636
    writeError(3, "[%s] IMAP server did not respond with \"+\" to AUTHENTICATE NTLM request.",
               "imap.mod");
#line 637
    writeError(3, "[%s] IMAP server sent the following response: %s", "imap.mod",
               bufReceive);
    }
#line 638
    return (-1);
  }
#line 640
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 640
    free((void *)bufReceive);
#line 640
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 643
  buildAuthRequest(& sTmpReq, 0L, (char *)((void *)0), (char *)((void *)0));
#line 645
  tmp___4 = malloc((size_t )(2L * ((sTmpReq.buffer - (uint8 *)(& sTmpReq)) + (long )sTmpReq.bufIndex) + 2L));
#line 645
  szTmpBuf64 = (unsigned char *)tmp___4;
#line 646
  memset((void *)szTmpBuf64, 0, (size_t )(2L * ((sTmpReq.buffer - (uint8 *)(& sTmpReq)) + (long )sTmpReq.bufIndex) + 2L));
#line 648
  base64_encode((char const   *)((char *)(& sTmpReq)), (int )((sTmpReq.buffer - (uint8 *)(& sTmpReq)) + (long )sTmpReq.bufIndex),
                (char *)szTmpBuf64);
#line 649
  writeError(10, "[%s] Sending initial challenge (B64 Encoded): %s", "imap.mod", szTmpBuf64);
#line 651
  tmp___5 = strlen((char const   *)szTmpBuf64);
#line 651
  nSendBufferSize = (int )(tmp___5 + 2UL);
#line 652
  tmp___6 = malloc((size_t )(nSendBufferSize + 1));
#line 652
  bufSend = (unsigned char *)tmp___6;
#line 653
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 654
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s\r\n",
          szTmpBuf64);
  }
#line 656
  if ((unsigned long )szTmpBuf64 != (unsigned long )((void *)0)) {
    {
#line 656
    free((void *)szTmpBuf64);
#line 656
    szTmpBuf64 = (unsigned char *)((void *)0);
    }
  }
  {
#line 658
  tmp___7 = strlen((char const   *)bufSend);
#line 658
  tmp___8 = medusaSend(hSocket, (char *)bufSend, (int )tmp___7, 0);
  }
#line 658
  if (tmp___8 < 0) {
    {
#line 660
    writeError(3, "[%s] failed: medusaSend was not successful", "imap.mod");
    }
#line 661
    return (-1);
  }
#line 663
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 663
    free((void *)bufSend);
#line 663
    bufSend = (unsigned char *)((void *)0);
    }
  }
  {
#line 667
  nReceiveBufferSize = 0;
#line 668
  tmp___9 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+ .*\r\n");
  }
#line 668
  if (tmp___9 == -1) {
    {
#line 670
    writeError(3, "[%s] Server did not send valid Type-2 challenge response.", "imap.mod");
    }
#line 671
    return (-1);
  } else
#line 668
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 670
    writeError(3, "[%s] Server did not send valid Type-2 challenge response.", "imap.mod");
    }
#line 671
    return (-1);
  }
  {
#line 674
  tmp___10 = index((char const   *)bufReceive, '\r');
#line 674
  szTmpBuf = (unsigned char *)tmp___10;
#line 675
  *(szTmpBuf + 0) = (unsigned char )'\000';
#line 677
  writeError(10, "[%s] NTLM Challenge (B64 Encoded): %s", "imap.mod", bufReceive + 2);
#line 678
  base64_decode((char const   *)(bufReceive + 2), (char *)(& sTmpChall));
  }
#line 680
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 680
    free((void *)bufReceive);
#line 680
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 684
  buildAuthResponse(& sTmpChall, & sTmpResp, 0L, szLogin, szPassword, _psSessionData->szDomain,
                    (char *)((void *)0));
#line 686
  tmp___11 = malloc((size_t )(2L * ((sTmpResp.buffer - (uint8 *)(& sTmpResp)) + (long )sTmpResp.bufIndex) + 2L));
#line 686
  szTmpBuf64 = (unsigned char *)tmp___11;
#line 687
  memset((void *)szTmpBuf64, 0, (size_t )(2L * ((sTmpResp.buffer - (uint8 *)(& sTmpResp)) + (long )sTmpResp.bufIndex) + 2L));
#line 689
  base64_encode((char const   *)((char *)(& sTmpResp)), (int )((sTmpResp.buffer - (uint8 *)(& sTmpResp)) + (long )sTmpResp.bufIndex),
                (char *)szTmpBuf64);
#line 690
  writeError(10, "[%s] NTLM Response (B64 Encoded): %s", "imap.mod", szTmpBuf64);
#line 692
  tmp___12 = strlen((char const   *)szTmpBuf64);
#line 692
  nSendBufferSize = (int )(tmp___12 + 2UL);
#line 693
  tmp___13 = malloc((size_t )(nSendBufferSize + 1));
#line 693
  bufSend = (unsigned char *)tmp___13;
#line 694
  memset((void *)bufSend, 0, (size_t )(nSendBufferSize + 1));
#line 695
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s\r\n",
          szTmpBuf64);
#line 697
  tmp___14 = medusaSend(hSocket, (char *)bufSend, nSendBufferSize, 0);
  }
#line 697
  if (tmp___14 < 0) {
    {
#line 699
    writeError(3, "[%s] failed: medusaSend was not successful", "imap.mod");
    }
#line 700
    return (-1);
  }
#line 703
  if ((unsigned long )szTmpBuf64 != (unsigned long )((void *)0)) {
    {
#line 703
    free((void *)szTmpBuf64);
#line 703
    szTmpBuf64 = (unsigned char *)((void *)0);
    }
  }
#line 704
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 704
    free((void *)bufSend);
#line 704
    bufSend = (unsigned char *)((void *)0);
    }
  }
#line 709
  return (0);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 71 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
unsigned int const   BUFFER_SIZE  =    (unsigned int const   )300;
#line 72 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
char const   *KNOWN_PROMPTS  =    ">#$%/?";
#line 74 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
int const   KNOWN_PWD_SIZE  =    (int const   )4;
#line 75 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
char const   *KNOWN_PWD_PROMPTS[4]  = {      "assword",      "asscode",      "ennwort",      "ASSWORD"};
#line 77 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
int const   KNOWN_LOGIN_SIZE  =    (int const   )3;
#line 78 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
char const   *KNOWN_LOGIN_PROMPTS[3]  = {      "login:",      "sername:",      "User"};
#line 91
int tryLoginAS400(int hSocket , sLogin **psLogin , _MODULE_DATA___1 *_psSessionData ,
                  char *szLogin , char *szPassword ) ;
#line 93
int processIAClogout(int hSocket , _MODULE_DATA___1 *_psSessionData ) ;
#line 94
void processIAC(int hSocket , _MODULE_DATA___1 *_psSessionData , char **buffer , int *nReceiveBufferSize ) ;
#line 278
extern int ( /* missing proto */  strcasestr)() ;
#line 620 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
int tryLoginAS400(int hSocket , sLogin **psLogin , _MODULE_DATA___1 *_psSessionData ,
                  char *szLogin , char *szPassword ) 
{ 
  char *bufSend ;
  unsigned long __lengthofbufSend ;
  void *tmp ;
  char *bufReceive ;
  int nSendBufferSize ;
  int nReceiveBufferSize ;
  int iRet ;
  char szUser[11] ;
  char szPass[129] ;
  char szErrorMsg[100] ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  void *tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;

  {
  {
#line 622
  __lengthofbufSend = (unsigned long )BUFFER_SIZE;
#line 622
  tmp = __builtin_alloca(sizeof(*bufSend) * __lengthofbufSend);
#line 622
  bufSend = (char *)tmp;
#line 624
  nSendBufferSize = 0;
#line 624
  nReceiveBufferSize = 0;
#line 625
  iRet = -1;
  }
#line 630
  if (hSocket <= 0) {
    {
#line 632
    writeError(3, "%s failed: socket was invalid", "telnet.mod");
#line 633
    (*psLogin)->iResult = 1;
#line 634
    setPassResult(*psLogin, szPassword);
    }
#line 635
    return (2);
  }
  {
#line 658
  memset((void *)bufSend, 0, (size_t )BUFFER_SIZE);
#line 659
  memset((void *)(szUser), 0, (size_t )11);
#line 660
  memset((void *)(szPass), 0, (size_t )129);
#line 662
  strncpy((char */* __restrict  */)(szUser), (char const   */* __restrict  */)szLogin,
          (size_t )10);
#line 663
  strncpy((char */* __restrict  */)(szPass), (char const   */* __restrict  */)szPassword,
          (size_t )128);
#line 665
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"%s\t%s\r",
          szUser, szPass);
#line 666
  tmp___0 = strlen((char const   *)bufSend);
#line 666
  nSendBufferSize = (int )(tmp___0 + 1UL);
#line 668
  tmp___1 = medusaSend(hSocket, bufSend, nSendBufferSize, 0);
  }
#line 668
  if (tmp___1 < 0) {
    {
#line 670
    writeError(3, "%s failed: medusaSend was not successful", "telnet.mod");
#line 671
    (*psLogin)->iResult = 1;
#line 672
    setPassResult(*psLogin, szPassword);
    }
#line 673
    return (2);
  }
  {
#line 677
  bufReceive = medusaReceiveLineDelay(hSocket, & nReceiveBufferSize, 20000000, (int )(0.5 * (double )1000000));
  }
#line 678
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 680
    writeError(3, "[%s] Timeout waiting for response from server after sending password",
               "telnet.mod");
#line 681
    (*psLogin)->iResult = 1;
#line 682
    setPassResult(*psLogin, szPassword);
    }
#line 683
    return (2);
  }
  {
#line 686
  tmp___37 = strstr((char const   *)bufReceive, "CPF1120");
  }
#line 686
  if ((unsigned long )tmp___37 != (unsigned long )((void *)0)) {
    {
#line 688
    sprintf((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1120 - User %s does not exist.",
            szUser);
#line 689
    writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 690
    tmp___2 = strlen((char const   *)(szErrorMsg));
#line 690
    tmp___3 = malloc(tmp___2 + 1UL);
#line 690
    (*psLogin)->pErrorMsg = (char *)tmp___3;
#line 691
    tmp___4 = strlen((char const   *)(szErrorMsg));
#line 691
    memset((void *)(*psLogin)->pErrorMsg, 0, tmp___4 + 1UL);
#line 692
    tmp___5 = strlen((char const   *)(szErrorMsg));
#line 692
    strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
            tmp___5);
#line 693
    (*psLogin)->iResult = 4;
#line 694
    iRet = 2;
    }
  } else {
    {
#line 696
    tmp___36 = strstr((char const   *)bufReceive, "CPF1116");
    }
#line 696
    if ((unsigned long )tmp___36 != (unsigned long )((void *)0)) {
      {
#line 698
      strcpy((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1116 - Next not valid sign-on attempt varies off device.");
#line 699
      writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 700
      tmp___6 = strlen((char const   *)(szErrorMsg));
#line 700
      tmp___7 = malloc(tmp___6 + 1UL);
#line 700
      (*psLogin)->pErrorMsg = (char *)tmp___7;
#line 701
      tmp___8 = strlen((char const   *)(szErrorMsg));
#line 701
      memset((void *)(*psLogin)->pErrorMsg, 0, tmp___8 + 1UL);
#line 702
      tmp___9 = strlen((char const   *)(szErrorMsg));
#line 702
      strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
              tmp___9);
#line 703
      (*psLogin)->iResult = 3;
#line 704
      iRet = 0;
      }
    } else {
      {
#line 706
      tmp___35 = strstr((char const   *)bufReceive, "CPF1392");
      }
#line 706
      if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
        {
#line 708
        strcpy((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1392 - Next not valid sign-on disables user profile.");
#line 709
        writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 710
        tmp___10 = strlen((char const   *)(szErrorMsg));
#line 710
        tmp___11 = malloc(tmp___10 + 1UL);
#line 710
        (*psLogin)->pErrorMsg = (char *)tmp___11;
#line 711
        tmp___12 = strlen((char const   *)(szErrorMsg));
#line 711
        memset((void *)(*psLogin)->pErrorMsg, 0, tmp___12 + 1UL);
#line 712
        tmp___13 = strlen((char const   *)(szErrorMsg));
#line 712
        strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
                tmp___13);
#line 713
        (*psLogin)->iResult = 4;
#line 714
        iRet = 2;
        }
      } else {
        {
#line 729
        tmp___34 = strstr((char const   *)bufReceive, "CPF1394");
        }
#line 729
        if ((unsigned long )tmp___34 != (unsigned long )((void *)0)) {
          {
#line 731
          sprintf((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1394 - User profile %s cannot sign on.",
                  szUser);
#line 732
          writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 733
          tmp___14 = strlen((char const   *)(szErrorMsg));
#line 733
          tmp___15 = malloc(tmp___14 + 1UL);
#line 733
          (*psLogin)->pErrorMsg = (char *)tmp___15;
#line 734
          tmp___16 = strlen((char const   *)(szErrorMsg));
#line 734
          memset((void *)(*psLogin)->pErrorMsg, 0, tmp___16 + 1UL);
#line 735
          tmp___17 = strlen((char const   *)(szErrorMsg));
#line 735
          strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
                  tmp___17);
#line 736
          (*psLogin)->iResult = 4;
#line 737
          iRet = 2;
          }
        } else {
          {
#line 739
          tmp___33 = strstr((char const   *)bufReceive, "CPF1118");
          }
#line 739
          if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
            {
#line 741
            sprintf((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1118 - No password associated with user %s.",
                    szUser);
#line 742
            writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 743
            tmp___18 = strlen((char const   *)(szErrorMsg));
#line 743
            tmp___19 = malloc(tmp___18 + 1UL);
#line 743
            (*psLogin)->pErrorMsg = (char *)tmp___19;
#line 744
            tmp___20 = strlen((char const   *)(szErrorMsg));
#line 744
            memset((void *)(*psLogin)->pErrorMsg, 0, tmp___20 + 1UL);
#line 745
            tmp___21 = strlen((char const   *)(szErrorMsg));
#line 745
            strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
                    tmp___21);
#line 746
            (*psLogin)->iResult = 2;
#line 747
            iRet = 2;
            }
          } else {
            {
#line 749
            tmp___32 = strstr((char const   *)bufReceive, "CPF1109");
            }
#line 749
            if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
              {
#line 751
              strcpy((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1109 - Not authorized to subsystem.");
#line 752
              writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 753
              tmp___22 = strlen((char const   *)(szErrorMsg));
#line 753
              tmp___23 = malloc(tmp___22 + 1UL);
#line 753
              (*psLogin)->pErrorMsg = (char *)tmp___23;
#line 754
              tmp___24 = strlen((char const   *)(szErrorMsg));
#line 754
              memset((void *)(*psLogin)->pErrorMsg, 0, tmp___24 + 1UL);
#line 755
              tmp___25 = strlen((char const   *)(szErrorMsg));
#line 755
              strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
                      tmp___25);
#line 756
              (*psLogin)->iResult = 2;
#line 757
              iRet = 2;
              }
            } else {
              {
#line 759
              tmp___31 = strstr((char const   *)bufReceive, "CPF1110");
              }
#line 759
              if ((unsigned long )tmp___31 != (unsigned long )((void *)0)) {
                {
#line 761
                strcpy((char */* __restrict  */)(szErrorMsg), (char const   */* __restrict  */)"CPF1110 - Not authorized to work station.");
#line 762
                writeError(3, "[%s] %s", "telnet.mod", szErrorMsg);
#line 763
                tmp___26 = strlen((char const   *)(szErrorMsg));
#line 763
                tmp___27 = malloc(tmp___26 + 1UL);
#line 763
                (*psLogin)->pErrorMsg = (char *)tmp___27;
#line 764
                tmp___28 = strlen((char const   *)(szErrorMsg));
#line 764
                memset((void *)(*psLogin)->pErrorMsg, 0, tmp___28 + 1UL);
#line 765
                tmp___29 = strlen((char const   *)(szErrorMsg));
#line 765
                strncpy((char */* __restrict  */)(*psLogin)->pErrorMsg, (char const   */* __restrict  */)(szErrorMsg),
                        tmp___29);
#line 766
                (*psLogin)->iResult = 2;
#line 767
                iRet = 2;
                }
              } else {
                {
#line 769
                tmp___30 = strstr((char const   *)bufReceive, "CPF1107");
                }
#line 769
                if ((unsigned long )tmp___30 != (unsigned long )((void *)0)) {
                  {
#line 771
                  writeError(6, "[%s] CPF1107 - Password not correct for user profile.",
                             "telnet.mod");
#line 772
                  (*psLogin)->iResult = 3;
#line 773
                  iRet = 0;
                  }
                } else {
#line 777
                  (*psLogin)->iResult = 2;
#line 778
                  iRet = 2;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 781
  setPassResult(*psLogin, szPass);
  }
#line 783
  return (iRet);
}
}
#line 791 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
int processIAClogout(int hSocket , _MODULE_DATA___1 *_psSessionData ) 
{ 
  unsigned char bufSend[3] ;
  char *bufReceive ;
  int nReceiveBufferSize ;
  int tmp ;

  {
  {
#line 793
  bufSend[0] = (unsigned char)255;
#line 793
  bufSend[1] = (unsigned char)253;
#line 793
  bufSend[2] = (unsigned char)18;
#line 794
  bufReceive = (char *)((void *)0);
#line 795
  nReceiveBufferSize = 0;
#line 797
  writeError(10, "[%s] Sending IAC DO LOGOUT command.", "telnet.mod");
#line 798
  tmp = medusaSend(hSocket, (char *)(bufSend), 3, 0);
  }
#line 798
  if (tmp < 0) {
    {
#line 800
    writeError(3, "%s failed: medusaSend was not successful", "telnet.mod");
    }
#line 801
    return (-1);
  }
#line 813
  return (0);
}
}
#line 816 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/telnet.c"
void processIAC(int hSocket , _MODULE_DATA___1 *_psSessionData , char **buffer , int *nReceiveBufferSize ) 
{ 
  unsigned char *bufTemp ;

  {
#line 818
  bufTemp = (unsigned char *)*buffer;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! ((int )*bufTemp == 255)) {
#line 821
      goto while_break;
    }
    {
#line 823
    writeError(10, "Handling IAC Command...");
    }
#line 825
    if ((int )*(bufTemp + 1) == 252) {
#line 825
      goto _L;
    } else
#line 825
    if ((int )*(bufTemp + 1) == 254) {
      _L: /* CIL Label */ 
#line 825
      if ((int )*(bufTemp + 2) == 34) {
        {
#line 827
        writeError(10, "TELNETD peer does not like linemode");
        }
      }
    }
#line 830
    if ((int )*(bufTemp + 1) == 251) {
#line 833
      if (_psSessionData->nMode == 1) {
#line 834
        if ((int )*(bufTemp + 2) == 1) {
#line 835
          *(bufTemp + 1) = (unsigned char)253;
        } else
#line 834
        if ((int )*(bufTemp + 2) == 3) {
#line 835
          *(bufTemp + 1) = (unsigned char)253;
        } else {
#line 837
          *(bufTemp + 1) = (unsigned char)254;
        }
      } else {
#line 839
        *(bufTemp + 1) = (unsigned char)254;
      }
      {
#line 841
      medusaSend(hSocket, (char *)bufTemp, 3, 0);
      }
    } else
#line 843
    if ((int )*(bufTemp + 1) == 253) {
      {
#line 845
      *(bufTemp + 1) = (unsigned char)252;
#line 846
      medusaSend(hSocket, (char *)bufTemp, 3, 0);
      }
    }
#line 849
    bufTemp += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if ((int )*bufTemp == 0) {
    {
#line 854
    writeError(10, "Getting more data");
#line 855
    free((void *)*buffer);
#line 857
    *nReceiveBufferSize = 0;
#line 858
    *buffer = medusaReceiveLineDelay(hSocket, nReceiveBufferSize, 20000000, (int )(0.5 * (double )1000000));
    }
#line 859
    if ((unsigned long )*buffer != (unsigned long )((void *)0)) {
#line 860
      *(*buffer + *nReceiveBufferSize) = (char)0;
    } else {
#line 864
      *buffer = (char *)((void *)0);
#line 865
      return;
    }
    {
#line 868
    writeError(10, "Next pass buffer: %s", *buffer);
    }
#line 869
    if ((int )((unsigned char )*(*(buffer + 0))) == 255) {
      {
#line 871
      writeError(10, "More commands waiting...");
      }
    }
  }
#line 874
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/smtp-vrfy.c"
int sayHELO(int hSocket , _CVS_DATA *_psSessionData ) ;
#line 63
int sayQUIT(int hSocket ) ;
#line 325 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/smtp-vrfy.c"
int sayHELO(int hSocket , _CVS_DATA *_psSessionData ) 
{ 
  unsigned char bufSend[300] ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  int nStatus ;
  int nBannerStatus ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 329
  nReceiveBufferSize = 0;
#line 331
  nBannerStatus = 0;
#line 334
  memset((void *)(bufSend), 0, sizeof(bufSend));
#line 335
  sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"HELO %.250s\r\n",
          _psSessionData->szDir);
#line 337
  tmp = strlen((char const   *)(bufSend));
#line 337
  tmp___0 = medusaSend(hSocket, (char *)(bufSend), (int )tmp, 0);
  }
#line 337
  if (tmp___0 < 0) {
    {
#line 339
    writeError(3, "%s failed: medusaSend was not successful", "smtp-vrfy.mod");
    }
  }
#line 342
  bufReceive = (unsigned char *)((void *)0);
#line 343
  nReceiveBufferSize = 0;
#line 344
  nStatus = -1;
#line 345
  nBannerStatus = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 346
    tmp___3 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 346
    bufReceive = (unsigned char *)tmp___3;
    }
#line 346
    if (! bufReceive) {
#line 346
      goto while_break;
    }
    {
#line 359
    tmp___1 = strstr((char const   *)bufReceive, "250 ");
    }
#line 359
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 360
      nBannerStatus = 1;
    }
#line 362
    if (nBannerStatus > 0) {
      {
#line 362
      tmp___2 = strstr((char const   *)bufReceive, "\r\n");
      }
#line 362
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 363
        nBannerStatus = 2;
      }
    }
#line 365
    if (nBannerStatus > 1) {
      {
#line 367
      writeError(10, "[%s] Server sent \'250\' code.", "smtp-vrfy.mod");
#line 368
      nStatus = 0;
      }
#line 369
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 369
        free((void *)bufReceive);
#line 369
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 370
      goto while_break;
    }
#line 373
    if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
      {
#line 373
      free((void *)bufReceive);
#line 373
      bufReceive = (unsigned char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 376
    free((void *)bufReceive);
#line 376
    bufReceive = (unsigned char *)((void *)0);
    }
  }
#line 377
  return (nStatus);
}
}
#line 380 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/smtp-vrfy.c"
int sayQUIT(int hSocket ) 
{ 
  unsigned char bufSend[300] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 384
  memset((void *)(bufSend), 0, sizeof(bufSend));
#line 385
  sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"QUIT\r\n");
#line 387
  tmp = strlen((char const   *)(bufSend));
#line 387
  tmp___0 = medusaSend(hSocket, (char *)(bufSend), (int )tmp, 0);
  }
#line 387
  if (tmp___0 < 0) {
    {
#line 389
    writeError(3, "%s failed: medusaSend was not successful", "smtp-vrfy.mod");
    }
  }
#line 392
  return (0);
}
}
#line 64 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/nntp.c"
int terminateConnection(int hSocket , sLogin **psLogin ) ;
#line 231 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/nntp.c"
int terminateConnection(int hSocket , sLogin **psLogin ) 
{ 
  unsigned char bufSend[300] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 235
  memset((void *)(bufSend), 0, sizeof(bufSend));
#line 236
  sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"QUIT\r\n");
#line 238
  tmp = strlen((char const   *)(bufSend));
#line 238
  tmp___0 = medusaSend(hSocket, (char *)(bufSend), (int )tmp, 0);
  }
#line 238
  if (tmp___0 < 0) {
    {
#line 240
    writeError(3, "[%s] failed: medusaSend was not successful", "nntp.mod");
    }
  }
  {
#line 243
  medusaDisconnect(hSocket);
  }
#line 244
  return (0);
}
}
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 342 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/wrapper.c"
int initProcess(_MODULE_DATA___2 *_psSessionData , sLogin *psLogin ) ;
#line 374
int closeProcess(_MODULE_DATA___2 *_psSessionData ) ;
#line 397 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/wrapper.c"
int initProcess(_MODULE_DATA___2 *_psSessionData , sLogin *psLogin ) 
{ 
  pid_t fork_result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  FILE *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 401
  tmp___4 = pipe((int *)(_psSessionData->iReadPipe));
  }
#line 401
  if (tmp___4 == 0) {
    {
#line 401
    tmp___5 = pipe((int *)(_psSessionData->iWritePipe));
    }
#line 401
    if (tmp___5 == 0) {
      {
#line 402
      fork_result = fork();
      }
#line 403
      if (fork_result == -1) {
        {
#line 404
        writeError(3, "Failed to fork management process.");
        }
#line 405
        return (-1);
      }
#line 408
      if (fork_result == 0) {
        {
#line 409
        writeError(10, "Child process sucessfully forked");
#line 412
        close(_psSessionData->iWritePipe[1]);
#line 413
        close(_psSessionData->iReadPipe[0]);
#line 416
        tmp = dup2(_psSessionData->iWritePipe[0], 0);
        }
#line 416
        if (tmp < 0) {
          {
#line 418
          writeError(3, "dup2() Mapping pipe to child\'s STDIN failed.");
#line 419
          exit(1);
          }
        }
        {
#line 422
        tmp___0 = dup2(_psSessionData->iReadPipe[1], 2);
        }
#line 422
        if (tmp___0 < 0) {
          {
#line 424
          writeError(3, "dup2() Mapping pipe to child\'s STDOUT failed.");
#line 425
          exit(1);
          }
        }
        {
#line 428
        tmp___1 = dup2(_psSessionData->iReadPipe[1], 1);
        }
#line 428
        if (tmp___1 < 0) {
          {
#line 430
          writeError(3, "dup2() Mapping pipe to child\'s STDOUT failed.");
#line 431
          exit(1);
          }
        }
        {
#line 447
        close(_psSessionData->iWritePipe[0]);
#line 448
        close(_psSessionData->iReadPipe[1]);
#line 451
        tmp___3 = fopen((char const   */* __restrict  */)_psSessionData->szCmd, (char const   */* __restrict  */)"r");
        }
#line 451
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
          {
#line 454
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"LOGIN_CHILD_FILE_ERROR\n");
          }
        } else {
          {
#line 460
          tmp___2 = system((char const   *)_psSessionData->szCmdFull);
          }
#line 460
          if (tmp___2 < 0) {
            {
#line 461
            writeError(3, "[%s] system() call return error", "wrapper.mod");
            }
          }
        }
        {
#line 465
        sleep(5U);
#line 467
        exit(0);
        }
      } else {
        {
#line 470
        writeError(10, "Parent process sucessfully forked");
#line 473
        close(_psSessionData->iReadPipe[1]);
#line 474
        close(_psSessionData->iWritePipe[0]);
        }
      }
    } else {
      {
#line 479
      writeError(0, "Failed to create communication pipes.");
      }
    }
  } else {
    {
#line 479
    writeError(0, "Failed to create communication pipes.");
    }
  }
#line 482
  return (0);
}
}
#line 485 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/wrapper.c"
int closeProcess(_MODULE_DATA___2 *_psSessionData ) 
{ 


  {
  {
#line 487
  writeError(10, "Parent process completed. Closing communication pipes.");
#line 489
  close(_psSessionData->iWritePipe[1]);
#line 490
  close(_psSessionData->iReadPipe[0]);
  }
#line 491
  return (0);
}
}
#line 294 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pcanywhere.c"
void pcaEncrypt(char *plaintext , char *ciphertext , int key , int offset ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 298
  writeError(10, "pcaEncrypt [plaintext]: %s", plaintext);
#line 300
  tmp___0 = strlen((char const   *)plaintext);
  }
#line 300
  if (tmp___0 > 0UL) {
#line 302
    *(ciphertext + 0) = (char )((int )*(plaintext + 0) ^ key);
#line 304
    i = 1;
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 304
      tmp = strlen((char const   *)plaintext);
      }
#line 304
      if (! ((size_t )i < tmp)) {
#line 304
        goto while_break;
      }
#line 305
      *(ciphertext + i) = (char )(((int )*(ciphertext + (i - 1)) ^ (int )*(plaintext + i)) ^ (i - offset));
#line 304
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 308
  writeError(10, "pcaEncrypt [ciphertext]: %s", ciphertext);
  }
#line 309
  return;
}
}
#line 311 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pcanywhere.c"
int pcaUserAuth(int hSocket , char *szDomain , char *szLogin , char *szPassword ) 
{ 
  unsigned char *szTmp ;
  unsigned char bufSend[16384] ;
  int nSendBufferSize ;
  unsigned char bufSend1[7] ;
  int nSendBufferSize1 ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  char clogin[128] ;
  unsigned int tmp ;
  char cpass[128] ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;

  {
#line 316
  nSendBufferSize = 0;
#line 317
  bufSend1[0] = (unsigned char)111;
#line 317
  bufSend1[1] = (unsigned char)98;
#line 317
  bufSend1[2] = (unsigned char)1;
#line 317
  bufSend1[3] = (unsigned char)2;
#line 317
  bufSend1[4] = (unsigned char)0;
#line 317
  bufSend1[5] = (unsigned char)0;
#line 317
  bufSend1[6] = (unsigned char)0;
#line 318
  nSendBufferSize1 = 7;
#line 320
  nReceiveBufferSize = 0;
#line 322
  clogin[0] = (char )'\000';
#line 322
  tmp = 1U;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (tmp >= 128U) {
#line 322
      goto while_break;
    }
#line 322
    clogin[tmp] = (char)0;
#line 322
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  cpass[0] = (char )'\000';
#line 323
  tmp___0 = 1U;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (tmp___0 >= 128U) {
#line 323
      goto while_break___0;
    }
#line 323
    cpass[tmp___0] = (char)0;
#line 323
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 329
  writeError(10, "%s: Retrieving login prompt.", "pcanywhere.mod");
#line 330
  tmp___1 = medusaSend(hSocket, (char *)(bufSend1), nSendBufferSize1, 0);
  }
#line 330
  if (tmp___1 < 0) {
    {
#line 332
    writeError(3, "%s failed: medusaSend was not successful", "pcanywhere.mod");
    }
#line 333
    return (-1);
  }
  {
#line 341
  sleep(1U);
#line 343
  nReceiveBufferSize = 0;
#line 344
  tmp___2 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 344
  bufReceive = (unsigned char *)tmp___2;
  }
#line 345
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 347
    writeError(3, "%s failed: medusaReceive returned no data.", "pcanywhere.mod");
    }
#line 348
    return (-1);
  } else {
    {
#line 350
    tmp___20 = strstr((char const   *)(bufReceive + 6), "Enter login name:");
    }
#line 350
    if (tmp___20) {
      {
#line 352
      writeError(6, "%s: Host sent native PcAnywhere authentication prompt.", "pcanywhere.mod");
#line 353
      pcaEncrypt(szLogin, clogin, 171, 1);
#line 354
      pcaEncrypt(szPassword, cpass, 171, 1);
#line 356
      memset((void *)(bufSend), 0, (size_t )300);
#line 357
      bufSend[0] = (unsigned char)6;
#line 358
      tmp___3 = strlen((char const   *)(clogin));
#line 358
      bufSend[1] = (unsigned char )tmp___3;
#line 359
      strncpy((char */* __restrict  */)(bufSend + 2), (char const   */* __restrict  */)(clogin),
              (size_t )297);
#line 360
      tmp___4 = strlen((char const   *)(clogin));
#line 360
      nSendBufferSize = (int )(tmp___4 + 2UL);
      }
    } else {
      {
#line 362
      tmp___19 = strstr((char const   *)(bufReceive + 6), "Enter user name:");
      }
#line 362
      if (tmp___19) {
        {
#line 364
        writeError(6, "%s: Host sent NT authentication prompt.", "pcanywhere.mod");
#line 365
        tmp___18 = strlen((char const   *)szDomain);
        }
#line 365
        if (tmp___18 > 0UL) {
          {
#line 371
          tmp___5 = strlen((char const   *)szDomain);
#line 371
          tmp___6 = strlen((char const   *)szLogin);
#line 371
          tmp___7 = malloc(((tmp___5 + 1UL) + tmp___6) + 1UL);
#line 371
          szTmp = (unsigned char *)tmp___7;
#line 372
          tmp___8 = strlen((char const   *)szDomain);
#line 372
          tmp___9 = strlen((char const   *)szLogin);
#line 372
          memset((void *)szTmp, 0, ((tmp___8 + 1UL) + tmp___9) + 1UL);
#line 373
          tmp___10 = strlen((char const   *)szDomain);
#line 373
          strncpy((char */* __restrict  */)szTmp, (char const   */* __restrict  */)szDomain,
                  tmp___10);
#line 374
          tmp___11 = strlen((char const   *)szDomain);
#line 374
          memset((void *)(szTmp + tmp___11), '\\', (size_t )1);
#line 375
          tmp___12 = strlen((char const   *)szLogin);
#line 375
          tmp___13 = strlen((char const   *)szDomain);
#line 375
          strncpy((char */* __restrict  */)((szTmp + tmp___13) + 1), (char const   */* __restrict  */)szLogin,
                  tmp___12);
#line 376
          pcaEncrypt((char *)szTmp, clogin, 171, 1);
#line 377
          writeError(10, "%s: Setting domain\\user value: %s", "pcanywhere.mod", szTmp);
          }
#line 378
          if ((unsigned long )szTmp != (unsigned long )((void *)0)) {
            {
#line 378
            free((void *)szTmp);
#line 378
            szTmp = (unsigned char *)((void *)0);
            }
          }
          {
#line 380
          memset((void *)(bufSend), 0, (size_t )300);
#line 381
          bufSend[0] = (unsigned char)6;
#line 382
          tmp___14 = strlen((char const   *)(clogin));
#line 382
          bufSend[1] = (unsigned char )tmp___14;
#line 383
          strncpy((char */* __restrict  */)(bufSend + 2), (char const   */* __restrict  */)(clogin),
                  (size_t )297);
#line 384
          tmp___15 = strlen((char const   *)(clogin));
#line 384
          nSendBufferSize = (int )(tmp___15 + 2UL);
          }
        } else {
          {
#line 388
          pcaEncrypt(szLogin, clogin, 247, 0);
#line 390
          memset((void *)(bufSend), 0, (size_t )300);
#line 391
          bufSend[0] = (unsigned char)6;
#line 392
          tmp___16 = strlen((char const   *)(clogin));
#line 392
          bufSend[1] = (unsigned char )(tmp___16 + 1UL);
#line 393
          bufSend[2] = (unsigned char)247;
#line 394
          strncpy((char */* __restrict  */)(bufSend + 3), (char const   */* __restrict  */)(clogin),
                  (size_t )296);
#line 395
          tmp___17 = strlen((char const   *)(clogin));
#line 395
          nSendBufferSize = (int )(tmp___17 + 3UL);
          }
        }
        {
#line 398
        pcaEncrypt(szPassword, cpass, 171, 1);
        }
      } else
#line 400
      if (bufReceive + 6) {
        {
#line 402
        writeError(3, "%s: Server responded with unknown login prompt: %s", "pcanywhere.mod",
                   bufReceive + 6);
        }
#line 403
        if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
          {
#line 403
          free((void *)bufReceive);
#line 403
          bufReceive = (unsigned char *)((void *)0);
          }
        }
#line 404
        return (-1);
      } else {
        {
#line 408
        writeError(3, "%s: Server failed to respond with login prompt.", "pcanywhere.mod");
        }
#line 409
        if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
          {
#line 409
          free((void *)bufReceive);
#line 409
          bufReceive = (unsigned char *)((void *)0);
          }
        }
#line 410
        return (-1);
      }
    }
  }
#line 413
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 413
    free((void *)bufReceive);
#line 413
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 416
  writeError(10, "%s: Sending username.", "pcanywhere.mod");
#line 417
  tmp___21 = medusaSend(hSocket, (char *)(bufSend), nSendBufferSize, 0);
  }
#line 417
  if (tmp___21 < 0) {
    {
#line 419
    writeError(3, "%s failed: medusaSend was not successful", "pcanywhere.mod");
    }
#line 420
    return (-1);
  }
  {
#line 426
  nReceiveBufferSize = 0;
#line 427
  tmp___22 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 427
  bufReceive = (unsigned char *)tmp___22;
  }
#line 428
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 430
    writeError(3, "%s failed: medusaReceive returned no data.", "pcanywhere.mod");
    }
#line 431
    return (-1);
  } else {
    {
#line 433
    tmp___23 = strstr((char const   *)(bufReceive + 6), "Enter password:");
    }
#line 433
    if (tmp___23) {
      {
#line 435
      writeError(10, "%s: Retrieved \"Enter password:\"", "pcanywhere.mod");
      }
    } else {
      {
#line 439
      writeError(3, "%s: Server did not send: \"Enter password:\"", "pcanywhere.mod");
      }
#line 440
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 440
        free((void *)bufReceive);
#line 440
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 441
      return (-1);
    }
  }
#line 444
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 444
    free((void *)bufReceive);
#line 444
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 447
  memset((void *)(bufSend), 0, (size_t )300);
#line 448
  bufSend[0] = (unsigned char)6;
#line 449
  tmp___24 = strlen((char const   *)(cpass));
#line 449
  bufSend[1] = (unsigned char )tmp___24;
#line 450
  strncpy((char */* __restrict  */)(bufSend + 2), (char const   */* __restrict  */)(cpass),
          (size_t )297);
#line 451
  tmp___25 = strlen((char const   *)(cpass));
#line 451
  nSendBufferSize = (int )(tmp___25 + 2UL);
#line 453
  writeError(10, "%s: Sending password.", "pcanywhere.mod");
#line 454
  tmp___26 = medusaSend(hSocket, (char *)(bufSend), nSendBufferSize, 0);
  }
#line 454
  if (tmp___26 < 0) {
    {
#line 456
    writeError(3, "%s failed: medusaSend was not successful", "pcanywhere.mod");
    }
#line 457
    return (-1);
  }
#line 459
  return (0);
}
}
#line 461 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pcanywhere.c"
int pcaNegCrypt(int hSocket ) 
{ 
  unsigned char bufSend[14] ;
  int nSendBufferSize ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 463
  bufSend[0] = (unsigned char)111;
#line 463
  bufSend[1] = (unsigned char)97;
#line 463
  bufSend[2] = (unsigned char)0;
#line 463
  bufSend[3] = (unsigned char)9;
#line 463
  bufSend[4] = (unsigned char)0;
#line 463
  bufSend[5] = (unsigned char)254;
#line 463
  bufSend[6] = (unsigned char)0;
#line 463
  bufSend[7] = (unsigned char)0;
#line 463
  bufSend[8] = (unsigned char)255;
#line 463
  bufSend[9] = (unsigned char)255;
#line 463
  bufSend[10] = (unsigned char)0;
#line 463
  bufSend[11] = (unsigned char)0;
#line 463
  bufSend[12] = (unsigned char)0;
#line 463
  bufSend[13] = (unsigned char)0;
#line 464
  nSendBufferSize = 14;
#line 466
  nReceiveBufferSize = 0;
#line 471
  writeError(10, "%s: Checking encryption level.", "pcanywhere.mod");
#line 472
  tmp = medusaSend(hSocket, (char *)(bufSend), nSendBufferSize, 0);
  }
#line 472
  if (tmp < 0) {
    {
#line 474
    writeError(3, "%s failed: medusaSend was not successful", "pcanywhere.mod");
    }
#line 475
    return (-1);
  }
  {
#line 478
  nReceiveBufferSize = 0;
#line 479
  tmp___0 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 479
  bufReceive = (unsigned char *)tmp___0;
  }
#line 480
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 482
    writeError(3, "%s failed: medusaReceive returned no data.", "pcanywhere.mod");
    }
#line 483
    return (-1);
  } else {
    {
#line 485
    tmp___1 = strstr((char const   *)(bufReceive + 28), "Host is denying connection");
    }
#line 485
    if (tmp___1) {
      {
#line 487
      writeError(3, "%s: PcAnywhere host denied connection. Host requires encryption which is currently not supported.",
                 "pcanywhere.mod");
      }
#line 488
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 488
        free((void *)bufReceive);
#line 488
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 489
      return (-1);
    }
  }
#line 492
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 492
    free((void *)bufReceive);
#line 492
    bufReceive = (unsigned char *)((void *)0);
    }
  }
#line 493
  return (0);
}
}
#line 496 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pcanywhere.c"
int pcaSessionInit(int hSocket ) 
{ 
  unsigned char bufSend1[4] ;
  int nSendBufferSize1 ;
  unsigned char bufSend2[3] ;
  int nSendBufferSize2 ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 498
  bufSend1[0] = (unsigned char)0;
#line 498
  bufSend1[1] = (unsigned char)0;
#line 498
  bufSend1[2] = (unsigned char)0;
#line 498
  bufSend1[3] = (unsigned char)0;
#line 499
  nSendBufferSize1 = 4;
#line 500
  bufSend2[0] = (unsigned char)111;
#line 500
  bufSend2[1] = (unsigned char)6;
#line 500
  bufSend2[2] = (unsigned char)255;
#line 501
  nSendBufferSize2 = 3;
#line 503
  nReceiveBufferSize = 0;
#line 508
  writeError(10, "%s: Retrieving RCA banner.", "pcanywhere.mod");
#line 509
  tmp = medusaSend(hSocket, (char *)(bufSend1), nSendBufferSize1, 0);
  }
#line 509
  if (tmp < 0) {
    {
#line 511
    writeError(3, "%s failed: medusaSend was not successful", "pcanywhere.mod");
    }
#line 512
    return (-1);
  }
  {
#line 515
  nReceiveBufferSize = 0;
#line 516
  tmp___0 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 516
  bufReceive = (unsigned char *)tmp___0;
  }
#line 517
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 520
    writeError(3, "%s: Failed to retrieve host banner. Is someone currently connected via PcAnywhere?",
               "pcanywhere.mod");
    }
#line 521
    return (-1);
  } else {
    {
#line 523
    tmp___1 = strstr((char const   *)(bufReceive + 11), "Please press <Enter>...");
    }
#line 523
    if (tmp___1) {
      {
#line 525
      writeError(10, "%s: Retrieved \"Please press <Enter>...\"", "pcanywhere.mod");
      }
    } else {
      {
#line 529
      writeError(3, "%s: Server did not send: \"Please press <Enter>...\"", "pcanywhere.mod");
      }
#line 530
      if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
        {
#line 530
        free((void *)bufReceive);
#line 530
        bufReceive = (unsigned char *)((void *)0);
        }
      }
#line 531
      return (-1);
    }
  }
#line 534
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 534
    free((void *)bufReceive);
#line 534
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 539
  writeError(10, "%s: Sending unknown packet.", "pcanywhere.mod");
#line 540
  tmp___2 = medusaSend(hSocket, (char *)(bufSend2), nSendBufferSize2, 0);
  }
#line 540
  if (tmp___2 < 0) {
    {
#line 542
    writeError(3, "%s failed: medusaSend was not successful", "pcanywhere.mod");
    }
#line 543
    return (-1);
  }
  {
#line 546
  nReceiveBufferSize = 0;
#line 547
  tmp___3 = medusaReceiveRaw(hSocket, & nReceiveBufferSize);
#line 547
  bufReceive = (unsigned char *)tmp___3;
  }
#line 548
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 550
    writeError(3, "%s failed: medusaReceive returned no data.", "pcanywhere.mod");
    }
#line 551
    return (-1);
  }
#line 554
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 554
    free((void *)bufReceive);
#line 554
    bufReceive = (unsigned char *)((void *)0);
    }
  }
#line 555
  return (0);
}
}
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 A___0  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 B___0  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 C___0  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 D___0  ;
#line 291 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 F___0(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 293
  return ((X & Y) | (~ X & Z));
}
}
#line 296 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 G___0(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 298
  return (((X & Y) | (X & Z)) | (Y & Z));
}
}
#line 301 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 H___0(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 303
  return ((X ^ Y) ^ Z);
}
}
#line 306 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 lshift___0(uint32 x , int s ) 
{ 


  {
#line 308
  x &= 4294967295U;
#line 309
  return (((x << s) & 4294967295U) | (x >> (32 - s)));
}
}
#line 317 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void mdfour64___0(uint32 *M ) 
{ 
  int j ;
  uint32 AA ;
  uint32 BB ;
  uint32 CC ;
  uint32 DD ;
  uint32 X[16] ;
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  uint32 tmp___10 ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;
  uint32 tmp___13 ;
  uint32 tmp___14 ;
  uint32 tmp___15 ;
  uint32 tmp___16 ;
  uint32 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint32 tmp___21 ;
  uint32 tmp___22 ;
  uint32 tmp___23 ;
  uint32 tmp___24 ;
  uint32 tmp___25 ;
  uint32 tmp___26 ;
  uint32 tmp___27 ;
  uint32 tmp___28 ;
  uint32 tmp___29 ;
  uint32 tmp___30 ;
  uint32 tmp___31 ;
  uint32 tmp___32 ;
  uint32 tmp___33 ;
  uint32 tmp___34 ;
  uint32 tmp___35 ;
  uint32 tmp___36 ;
  uint32 tmp___37 ;
  uint32 tmp___38 ;
  uint32 tmp___39 ;
  uint32 tmp___40 ;
  uint32 tmp___41 ;
  uint32 tmp___42 ;
  uint32 tmp___43 ;
  uint32 tmp___44 ;
  uint32 tmp___45 ;
  uint32 tmp___46 ;

  {
#line 323
  j = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (j < 16)) {
#line 323
      goto while_break;
    }
#line 324
    X[j] = *(M + j);
#line 323
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  AA = A___0;
#line 326
  BB = B___0;
#line 326
  CC = C___0;
#line 326
  DD = D___0;
#line 328
  tmp = F___0(B___0, C___0, D___0);
#line 328
  A___0 = lshift___0((A___0 + tmp) + X[0], 3);
#line 328
  tmp___0 = F___0(A___0, B___0, C___0);
#line 328
  D___0 = lshift___0((D___0 + tmp___0) + X[1], 7);
#line 329
  tmp___1 = F___0(D___0, A___0, B___0);
#line 329
  C___0 = lshift___0((C___0 + tmp___1) + X[2], 11);
#line 329
  tmp___2 = F___0(C___0, D___0, A___0);
#line 329
  B___0 = lshift___0((B___0 + tmp___2) + X[3], 19);
#line 330
  tmp___3 = F___0(B___0, C___0, D___0);
#line 330
  A___0 = lshift___0((A___0 + tmp___3) + X[4], 3);
#line 330
  tmp___4 = F___0(A___0, B___0, C___0);
#line 330
  D___0 = lshift___0((D___0 + tmp___4) + X[5], 7);
#line 331
  tmp___5 = F___0(D___0, A___0, B___0);
#line 331
  C___0 = lshift___0((C___0 + tmp___5) + X[6], 11);
#line 331
  tmp___6 = F___0(C___0, D___0, A___0);
#line 331
  B___0 = lshift___0((B___0 + tmp___6) + X[7], 19);
#line 332
  tmp___7 = F___0(B___0, C___0, D___0);
#line 332
  A___0 = lshift___0((A___0 + tmp___7) + X[8], 3);
#line 332
  tmp___8 = F___0(A___0, B___0, C___0);
#line 332
  D___0 = lshift___0((D___0 + tmp___8) + X[9], 7);
#line 333
  tmp___9 = F___0(D___0, A___0, B___0);
#line 333
  C___0 = lshift___0((C___0 + tmp___9) + X[10], 11);
#line 333
  tmp___10 = F___0(C___0, D___0, A___0);
#line 333
  B___0 = lshift___0((B___0 + tmp___10) + X[11], 19);
#line 334
  tmp___11 = F___0(B___0, C___0, D___0);
#line 334
  A___0 = lshift___0((A___0 + tmp___11) + X[12], 3);
#line 334
  tmp___12 = F___0(A___0, B___0, C___0);
#line 334
  D___0 = lshift___0((D___0 + tmp___12) + X[13], 7);
#line 335
  tmp___13 = F___0(D___0, A___0, B___0);
#line 335
  C___0 = lshift___0((C___0 + tmp___13) + X[14], 11);
#line 335
  tmp___14 = F___0(C___0, D___0, A___0);
#line 335
  B___0 = lshift___0((B___0 + tmp___14) + X[15], 19);
#line 337
  tmp___15 = G___0(B___0, C___0, D___0);
#line 337
  A___0 = lshift___0(((A___0 + tmp___15) + X[0]) + 1518500249U, 3);
#line 337
  tmp___16 = G___0(A___0, B___0, C___0);
#line 337
  D___0 = lshift___0(((D___0 + tmp___16) + X[4]) + 1518500249U, 5);
#line 338
  tmp___17 = G___0(D___0, A___0, B___0);
#line 338
  C___0 = lshift___0(((C___0 + tmp___17) + X[8]) + 1518500249U, 9);
#line 338
  tmp___18 = G___0(C___0, D___0, A___0);
#line 338
  B___0 = lshift___0(((B___0 + tmp___18) + X[12]) + 1518500249U, 13);
#line 339
  tmp___19 = G___0(B___0, C___0, D___0);
#line 339
  A___0 = lshift___0(((A___0 + tmp___19) + X[1]) + 1518500249U, 3);
#line 339
  tmp___20 = G___0(A___0, B___0, C___0);
#line 339
  D___0 = lshift___0(((D___0 + tmp___20) + X[5]) + 1518500249U, 5);
#line 340
  tmp___21 = G___0(D___0, A___0, B___0);
#line 340
  C___0 = lshift___0(((C___0 + tmp___21) + X[9]) + 1518500249U, 9);
#line 340
  tmp___22 = G___0(C___0, D___0, A___0);
#line 340
  B___0 = lshift___0(((B___0 + tmp___22) + X[13]) + 1518500249U, 13);
#line 341
  tmp___23 = G___0(B___0, C___0, D___0);
#line 341
  A___0 = lshift___0(((A___0 + tmp___23) + X[2]) + 1518500249U, 3);
#line 341
  tmp___24 = G___0(A___0, B___0, C___0);
#line 341
  D___0 = lshift___0(((D___0 + tmp___24) + X[6]) + 1518500249U, 5);
#line 342
  tmp___25 = G___0(D___0, A___0, B___0);
#line 342
  C___0 = lshift___0(((C___0 + tmp___25) + X[10]) + 1518500249U, 9);
#line 342
  tmp___26 = G___0(C___0, D___0, A___0);
#line 342
  B___0 = lshift___0(((B___0 + tmp___26) + X[14]) + 1518500249U, 13);
#line 343
  tmp___27 = G___0(B___0, C___0, D___0);
#line 343
  A___0 = lshift___0(((A___0 + tmp___27) + X[3]) + 1518500249U, 3);
#line 343
  tmp___28 = G___0(A___0, B___0, C___0);
#line 343
  D___0 = lshift___0(((D___0 + tmp___28) + X[7]) + 1518500249U, 5);
#line 344
  tmp___29 = G___0(D___0, A___0, B___0);
#line 344
  C___0 = lshift___0(((C___0 + tmp___29) + X[11]) + 1518500249U, 9);
#line 344
  tmp___30 = G___0(C___0, D___0, A___0);
#line 344
  B___0 = lshift___0(((B___0 + tmp___30) + X[15]) + 1518500249U, 13);
#line 346
  tmp___31 = H___0(B___0, C___0, D___0);
#line 346
  A___0 = lshift___0(((A___0 + tmp___31) + X[0]) + 1859775393U, 3);
#line 346
  tmp___32 = H___0(A___0, B___0, C___0);
#line 346
  D___0 = lshift___0(((D___0 + tmp___32) + X[8]) + 1859775393U, 9);
#line 347
  tmp___33 = H___0(D___0, A___0, B___0);
#line 347
  C___0 = lshift___0(((C___0 + tmp___33) + X[4]) + 1859775393U, 11);
#line 347
  tmp___34 = H___0(C___0, D___0, A___0);
#line 347
  B___0 = lshift___0(((B___0 + tmp___34) + X[12]) + 1859775393U, 15);
#line 348
  tmp___35 = H___0(B___0, C___0, D___0);
#line 348
  A___0 = lshift___0(((A___0 + tmp___35) + X[2]) + 1859775393U, 3);
#line 348
  tmp___36 = H___0(A___0, B___0, C___0);
#line 348
  D___0 = lshift___0(((D___0 + tmp___36) + X[10]) + 1859775393U, 9);
#line 349
  tmp___37 = H___0(D___0, A___0, B___0);
#line 349
  C___0 = lshift___0(((C___0 + tmp___37) + X[6]) + 1859775393U, 11);
#line 349
  tmp___38 = H___0(C___0, D___0, A___0);
#line 349
  B___0 = lshift___0(((B___0 + tmp___38) + X[14]) + 1859775393U, 15);
#line 350
  tmp___39 = H___0(B___0, C___0, D___0);
#line 350
  A___0 = lshift___0(((A___0 + tmp___39) + X[1]) + 1859775393U, 3);
#line 350
  tmp___40 = H___0(A___0, B___0, C___0);
#line 350
  D___0 = lshift___0(((D___0 + tmp___40) + X[9]) + 1859775393U, 9);
#line 351
  tmp___41 = H___0(D___0, A___0, B___0);
#line 351
  C___0 = lshift___0(((C___0 + tmp___41) + X[5]) + 1859775393U, 11);
#line 351
  tmp___42 = H___0(C___0, D___0, A___0);
#line 351
  B___0 = lshift___0(((B___0 + tmp___42) + X[13]) + 1859775393U, 15);
#line 352
  tmp___43 = H___0(B___0, C___0, D___0);
#line 352
  A___0 = lshift___0(((A___0 + tmp___43) + X[3]) + 1859775393U, 3);
#line 352
  tmp___44 = H___0(A___0, B___0, C___0);
#line 352
  D___0 = lshift___0(((D___0 + tmp___44) + X[11]) + 1859775393U, 9);
#line 353
  tmp___45 = H___0(D___0, A___0, B___0);
#line 353
  C___0 = lshift___0(((C___0 + tmp___45) + X[7]) + 1859775393U, 11);
#line 353
  tmp___46 = H___0(C___0, D___0, A___0);
#line 353
  B___0 = lshift___0(((B___0 + tmp___46) + X[15]) + 1859775393U, 15);
#line 355
  A___0 += AA;
#line 355
  B___0 += BB;
#line 355
  C___0 += CC;
#line 355
  D___0 += DD;
#line 357
  A___0 &= 4294967295U;
#line 357
  B___0 &= 4294967295U;
#line 358
  C___0 &= 4294967295U;
#line 358
  D___0 &= 4294967295U;
#line 360
  j = 0;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (j < 16)) {
#line 360
      goto while_break___0;
    }
#line 361
    X[j] = (uint32 )0;
#line 360
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void copy64___0(uint32 *M , unsigned char *in ) 
{ 
  int i ;

  {
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 16)) {
#line 368
      goto while_break;
    }
#line 369
    *(M + i) = (uint32 )(((((int )*(in + (i * 4 + 3)) << 24) | ((int )*(in + (i * 4 + 2)) << 16)) | ((int )*(in + (i * 4 + 1)) << 8)) | (int )*(in + i * 4));
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void copy4___0(unsigned char *out , uint32 x ) 
{ 


  {
#line 375
  *(out + 0) = (unsigned char )(x & 255U);
#line 376
  *(out + 1) = (unsigned char )((x >> 8) & 255U);
#line 377
  *(out + 2) = (unsigned char )((x >> 16) & 255U);
#line 378
  *(out + 3) = (unsigned char )((x >> 24) & 255U);
#line 379
  return;
}
}
#line 437 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm1___0[56]  = 
#line 437
  {      (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)63,      (unsigned char)55,      (unsigned char)47,      (unsigned char)39, 
        (unsigned char)31,      (unsigned char)23,      (unsigned char)15,      (unsigned char)7, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4};
#line 446 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm2___0[48]  = 
#line 446
  {      (unsigned char)14,      (unsigned char)17,      (unsigned char)11,      (unsigned char)24, 
        (unsigned char)1,      (unsigned char)5,      (unsigned char)3,      (unsigned char)28, 
        (unsigned char)15,      (unsigned char)6,      (unsigned char)21,      (unsigned char)10, 
        (unsigned char)23,      (unsigned char)19,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)26,      (unsigned char)8,      (unsigned char)16,      (unsigned char)7, 
        (unsigned char)27,      (unsigned char)20,      (unsigned char)13,      (unsigned char)2, 
        (unsigned char)41,      (unsigned char)52,      (unsigned char)31,      (unsigned char)37, 
        (unsigned char)47,      (unsigned char)55,      (unsigned char)30,      (unsigned char)40, 
        (unsigned char)51,      (unsigned char)45,      (unsigned char)33,      (unsigned char)48, 
        (unsigned char)44,      (unsigned char)49,      (unsigned char)39,      (unsigned char)56, 
        (unsigned char)34,      (unsigned char)53,      (unsigned char)46,      (unsigned char)42, 
        (unsigned char)50,      (unsigned char)36,      (unsigned char)29,      (unsigned char)32};
#line 455 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm3___0[64]  = 
#line 455
  {      (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)64,      (unsigned char)56,      (unsigned char)48,      (unsigned char)40, 
        (unsigned char)32,      (unsigned char)24,      (unsigned char)16,      (unsigned char)8, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)63,      (unsigned char)55,      (unsigned char)47,      (unsigned char)39, 
        (unsigned char)31,      (unsigned char)23,      (unsigned char)15,      (unsigned char)7};
#line 464 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm4___0[48]  = 
#line 464
  {      (unsigned char)32,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)8,      (unsigned char)9, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)12,      (unsigned char)13, 
        (unsigned char)14,      (unsigned char)15,      (unsigned char)16,      (unsigned char)17, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)22,      (unsigned char)23,      (unsigned char)24,      (unsigned char)25, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)28,      (unsigned char)29, 
        (unsigned char)30,      (unsigned char)31,      (unsigned char)32,      (unsigned char)1};
#line 473 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm5___0[32]  = 
#line 473
  {      (unsigned char)16,      (unsigned char)7,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)29,      (unsigned char)12,      (unsigned char)28,      (unsigned char)17, 
        (unsigned char)1,      (unsigned char)15,      (unsigned char)23,      (unsigned char)26, 
        (unsigned char)5,      (unsigned char)18,      (unsigned char)31,      (unsigned char)10, 
        (unsigned char)2,      (unsigned char)8,      (unsigned char)24,      (unsigned char)14, 
        (unsigned char)32,      (unsigned char)27,      (unsigned char)3,      (unsigned char)9, 
        (unsigned char)19,      (unsigned char)13,      (unsigned char)30,      (unsigned char)6, 
        (unsigned char)22,      (unsigned char)11,      (unsigned char)4,      (unsigned char)25};
#line 482 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm6___0[64]  = 
#line 482
  {      (unsigned char)40,      (unsigned char)8,      (unsigned char)48,      (unsigned char)16, 
        (unsigned char)56,      (unsigned char)24,      (unsigned char)64,      (unsigned char)32, 
        (unsigned char)39,      (unsigned char)7,      (unsigned char)47,      (unsigned char)15, 
        (unsigned char)55,      (unsigned char)23,      (unsigned char)63,      (unsigned char)31, 
        (unsigned char)38,      (unsigned char)6,      (unsigned char)46,      (unsigned char)14, 
        (unsigned char)54,      (unsigned char)22,      (unsigned char)62,      (unsigned char)30, 
        (unsigned char)37,      (unsigned char)5,      (unsigned char)45,      (unsigned char)13, 
        (unsigned char)53,      (unsigned char)21,      (unsigned char)61,      (unsigned char)29, 
        (unsigned char)36,      (unsigned char)4,      (unsigned char)44,      (unsigned char)12, 
        (unsigned char)52,      (unsigned char)20,      (unsigned char)60,      (unsigned char)28, 
        (unsigned char)35,      (unsigned char)3,      (unsigned char)43,      (unsigned char)11, 
        (unsigned char)51,      (unsigned char)19,      (unsigned char)59,      (unsigned char)27, 
        (unsigned char)34,      (unsigned char)2,      (unsigned char)42,      (unsigned char)10, 
        (unsigned char)50,      (unsigned char)18,      (unsigned char)58,      (unsigned char)26, 
        (unsigned char)33,      (unsigned char)1,      (unsigned char)41,      (unsigned char)9, 
        (unsigned char)49,      (unsigned char)17,      (unsigned char)57,      (unsigned char)25};
#line 491 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char sc___0[16]  = 
#line 491
  {      (unsigned char)1,      (unsigned char)1,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)1};
#line 493 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char sbox___0[8][4][16]  = 
#line 493
  { { {          (unsigned char)14,          (unsigned char)4,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)2,          (unsigned char)15,          (unsigned char)11,          (unsigned char)8, 
                (unsigned char)3,          (unsigned char)10,          (unsigned char)6,          (unsigned char)12, 
                (unsigned char)5,          (unsigned char)9,          (unsigned char)0,          (unsigned char)7}, 
     {          (unsigned char)0,          (unsigned char)15,          (unsigned char)7,          (unsigned char)4, 
                (unsigned char)14,          (unsigned char)2,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)10,          (unsigned char)6,          (unsigned char)12,          (unsigned char)11, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)3,          (unsigned char)8}, 
     {          (unsigned char)4,          (unsigned char)1,          (unsigned char)14,          (unsigned char)8, 
                (unsigned char)13,          (unsigned char)6,          (unsigned char)2,          (unsigned char)11, 
                (unsigned char)15,          (unsigned char)12,          (unsigned char)9,          (unsigned char)7, 
                (unsigned char)3,          (unsigned char)10,          (unsigned char)5,          (unsigned char)0}, 
     {          (unsigned char)15,          (unsigned char)12,          (unsigned char)8,          (unsigned char)2, 
                (unsigned char)4,          (unsigned char)9,          (unsigned char)1,          (unsigned char)7, 
                (unsigned char)5,          (unsigned char)11,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)10,          (unsigned char)0,          (unsigned char)6,          (unsigned char)13}}, 
   { {          (unsigned char)15,          (unsigned char)1,          (unsigned char)8,          (unsigned char)14, 
                (unsigned char)6,          (unsigned char)11,          (unsigned char)3,          (unsigned char)4, 
                (unsigned char)9,          (unsigned char)7,          (unsigned char)2,          (unsigned char)13, 
                (unsigned char)12,          (unsigned char)0,          (unsigned char)5,          (unsigned char)10}, 
     {          (unsigned char)3,          (unsigned char)13,          (unsigned char)4,          (unsigned char)7, 
                (unsigned char)15,          (unsigned char)2,          (unsigned char)8,          (unsigned char)14, 
                (unsigned char)12,          (unsigned char)0,          (unsigned char)1,          (unsigned char)10, 
                (unsigned char)6,          (unsigned char)9,          (unsigned char)11,          (unsigned char)5}, 
     {          (unsigned char)0,          (unsigned char)14,          (unsigned char)7,          (unsigned char)11, 
                (unsigned char)10,          (unsigned char)4,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)5,          (unsigned char)8,          (unsigned char)12,          (unsigned char)6, 
                (unsigned char)9,          (unsigned char)3,          (unsigned char)2,          (unsigned char)15}, 
     {          (unsigned char)13,          (unsigned char)8,          (unsigned char)10,          (unsigned char)1, 
                (unsigned char)3,          (unsigned char)15,          (unsigned char)4,          (unsigned char)2, 
                (unsigned char)11,          (unsigned char)6,          (unsigned char)7,          (unsigned char)12, 
                (unsigned char)0,          (unsigned char)5,          (unsigned char)14,          (unsigned char)9}}, 
   { {          (unsigned char)10,          (unsigned char)0,          (unsigned char)9,          (unsigned char)14, 
                (unsigned char)6,          (unsigned char)3,          (unsigned char)15,          (unsigned char)5, 
                (unsigned char)1,          (unsigned char)13,          (unsigned char)12,          (unsigned char)7, 
                (unsigned char)11,          (unsigned char)4,          (unsigned char)2,          (unsigned char)8}, 
     {          (unsigned char)13,          (unsigned char)7,          (unsigned char)0,          (unsigned char)9, 
                (unsigned char)3,          (unsigned char)4,          (unsigned char)6,          (unsigned char)10, 
                (unsigned char)2,          (unsigned char)8,          (unsigned char)5,          (unsigned char)14, 
                (unsigned char)12,          (unsigned char)11,          (unsigned char)15,          (unsigned char)1}, 
     {          (unsigned char)13,          (unsigned char)6,          (unsigned char)4,          (unsigned char)9, 
                (unsigned char)8,          (unsigned char)15,          (unsigned char)3,          (unsigned char)0, 
                (unsigned char)11,          (unsigned char)1,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)5,          (unsigned char)10,          (unsigned char)14,          (unsigned char)7}, 
     {          (unsigned char)1,          (unsigned char)10,          (unsigned char)13,          (unsigned char)0, 
                (unsigned char)6,          (unsigned char)9,          (unsigned char)8,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)15,          (unsigned char)14,          (unsigned char)3, 
                (unsigned char)11,          (unsigned char)5,          (unsigned char)2,          (unsigned char)12}}, 
   { {          (unsigned char)7,          (unsigned char)13,          (unsigned char)14,          (unsigned char)3, 
                (unsigned char)0,          (unsigned char)6,          (unsigned char)9,          (unsigned char)10, 
                (unsigned char)1,          (unsigned char)2,          (unsigned char)8,          (unsigned char)5, 
                (unsigned char)11,          (unsigned char)12,          (unsigned char)4,          (unsigned char)15}, 
     {          (unsigned char)13,          (unsigned char)8,          (unsigned char)11,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)0,          (unsigned char)3, 
                (unsigned char)4,          (unsigned char)7,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)1,          (unsigned char)10,          (unsigned char)14,          (unsigned char)9}, 
     {          (unsigned char)10,          (unsigned char)6,          (unsigned char)9,          (unsigned char)0, 
                (unsigned char)12,          (unsigned char)11,          (unsigned char)7,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)1,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)5,          (unsigned char)2,          (unsigned char)8,          (unsigned char)4}, 
     {          (unsigned char)3,          (unsigned char)15,          (unsigned char)0,          (unsigned char)6, 
                (unsigned char)10,          (unsigned char)1,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)9,          (unsigned char)4,          (unsigned char)5,          (unsigned char)11, 
                (unsigned char)12,          (unsigned char)7,          (unsigned char)2,          (unsigned char)14}}, 
   { {          (unsigned char)2,          (unsigned char)12,          (unsigned char)4,          (unsigned char)1, 
                (unsigned char)7,          (unsigned char)10,          (unsigned char)11,          (unsigned char)6, 
                (unsigned char)8,          (unsigned char)5,          (unsigned char)3,          (unsigned char)15, 
                (unsigned char)13,          (unsigned char)0,          (unsigned char)14,          (unsigned char)9}, 
     {          (unsigned char)14,          (unsigned char)11,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)4,          (unsigned char)7,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)5,          (unsigned char)0,          (unsigned char)15,          (unsigned char)10, 
                (unsigned char)3,          (unsigned char)9,          (unsigned char)8,          (unsigned char)6}, 
     {          (unsigned char)4,          (unsigned char)2,          (unsigned char)1,          (unsigned char)11, 
                (unsigned char)10,          (unsigned char)13,          (unsigned char)7,          (unsigned char)8, 
                (unsigned char)15,          (unsigned char)9,          (unsigned char)12,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)3,          (unsigned char)0,          (unsigned char)14}, 
     {          (unsigned char)11,          (unsigned char)8,          (unsigned char)12,          (unsigned char)7, 
                (unsigned char)1,          (unsigned char)14,          (unsigned char)2,          (unsigned char)13, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)0,          (unsigned char)9, 
                (unsigned char)10,          (unsigned char)4,          (unsigned char)5,          (unsigned char)3}}, 
   { {          (unsigned char)12,          (unsigned char)1,          (unsigned char)10,          (unsigned char)15, 
                (unsigned char)9,          (unsigned char)2,          (unsigned char)6,          (unsigned char)8, 
                (unsigned char)0,          (unsigned char)13,          (unsigned char)3,          (unsigned char)4, 
                (unsigned char)14,          (unsigned char)7,          (unsigned char)5,          (unsigned char)11}, 
     {          (unsigned char)10,          (unsigned char)15,          (unsigned char)4,          (unsigned char)2, 
                (unsigned char)7,          (unsigned char)12,          (unsigned char)9,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)1,          (unsigned char)13,          (unsigned char)14, 
                (unsigned char)0,          (unsigned char)11,          (unsigned char)3,          (unsigned char)8}, 
     {          (unsigned char)9,          (unsigned char)14,          (unsigned char)15,          (unsigned char)5, 
                (unsigned char)2,          (unsigned char)8,          (unsigned char)12,          (unsigned char)3, 
                (unsigned char)7,          (unsigned char)0,          (unsigned char)4,          (unsigned char)10, 
                (unsigned char)1,          (unsigned char)13,          (unsigned char)11,          (unsigned char)6}, 
     {          (unsigned char)4,          (unsigned char)3,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)15,          (unsigned char)10, 
                (unsigned char)11,          (unsigned char)14,          (unsigned char)1,          (unsigned char)7, 
                (unsigned char)6,          (unsigned char)0,          (unsigned char)8,          (unsigned char)13}}, 
   { {          (unsigned char)4,          (unsigned char)11,          (unsigned char)2,          (unsigned char)14, 
                (unsigned char)15,          (unsigned char)0,          (unsigned char)8,          (unsigned char)13, 
                (unsigned char)3,          (unsigned char)12,          (unsigned char)9,          (unsigned char)7, 
                (unsigned char)5,          (unsigned char)10,          (unsigned char)6,          (unsigned char)1}, 
     {          (unsigned char)13,          (unsigned char)0,          (unsigned char)11,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)9,          (unsigned char)1,          (unsigned char)10, 
                (unsigned char)14,          (unsigned char)3,          (unsigned char)5,          (unsigned char)12, 
                (unsigned char)2,          (unsigned char)15,          (unsigned char)8,          (unsigned char)6}, 
     {          (unsigned char)1,          (unsigned char)4,          (unsigned char)11,          (unsigned char)13, 
                (unsigned char)12,          (unsigned char)3,          (unsigned char)7,          (unsigned char)14, 
                (unsigned char)10,          (unsigned char)15,          (unsigned char)6,          (unsigned char)8, 
                (unsigned char)0,          (unsigned char)5,          (unsigned char)9,          (unsigned char)2}, 
     {          (unsigned char)6,          (unsigned char)11,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)1,          (unsigned char)4,          (unsigned char)10,          (unsigned char)7, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)0,          (unsigned char)15, 
                (unsigned char)14,          (unsigned char)2,          (unsigned char)3,          (unsigned char)12}}, 
   { {          (unsigned char)13,          (unsigned char)2,          (unsigned char)8,          (unsigned char)4, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)11,          (unsigned char)1, 
                (unsigned char)10,          (unsigned char)9,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)5,          (unsigned char)0,          (unsigned char)12,          (unsigned char)7}, 
     {          (unsigned char)1,          (unsigned char)15,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)10,          (unsigned char)3,          (unsigned char)7,          (unsigned char)4, 
                (unsigned char)12,          (unsigned char)5,          (unsigned char)6,          (unsigned char)11, 
                (unsigned char)0,          (unsigned char)14,          (unsigned char)9,          (unsigned char)2}, 
     {          (unsigned char)7,          (unsigned char)11,          (unsigned char)4,          (unsigned char)1, 
                (unsigned char)9,          (unsigned char)12,          (unsigned char)14,          (unsigned char)2, 
                (unsigned char)0,          (unsigned char)6,          (unsigned char)10,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)3,          (unsigned char)5,          (unsigned char)8}, 
     {          (unsigned char)2,          (unsigned char)1,          (unsigned char)14,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)10,          (unsigned char)8,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)12,          (unsigned char)9,          (unsigned char)0, 
                (unsigned char)3,          (unsigned char)5,          (unsigned char)6,          (unsigned char)11}}};
#line 534 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void permute___0(char *out , char *in , unsigned char *p , int n ) 
{ 
  int i ;

  {
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < n)) {
#line 537
      goto while_break;
    }
#line 538
    *(out + i) = *(in + ((int )*(p + i) - 1));
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 541 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void l_shift___0(char *d , int count , int n ) 
{ 
  char out[64] ;
  int i ;

  {
#line 545
  i = 0;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < n)) {
#line 545
      goto while_break;
    }
#line 546
    out[i] = *(d + (i + count) % n);
#line 545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  i = 0;
  {
#line 547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 547
    if (! (i < n)) {
#line 547
      goto while_break___0;
    }
#line 548
    *(d + i) = out[i];
#line 547
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  return;
}
}
#line 551 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void concat___0(char *out , char *in1 , char *in2 , int l1 , int l2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    tmp___1 = l1;
#line 553
    l1 --;
#line 553
    if (! tmp___1) {
#line 553
      goto while_break;
    }
#line 554
    tmp = out;
#line 554
    out ++;
#line 554
    tmp___0 = in1;
#line 554
    in1 ++;
#line 554
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 555
    tmp___4 = l2;
#line 555
    l2 --;
#line 555
    if (! tmp___4) {
#line 555
      goto while_break___0;
    }
#line 556
    tmp___2 = out;
#line 556
    out ++;
#line 556
    tmp___3 = in2;
#line 556
    in2 ++;
#line 556
    *tmp___2 = *tmp___3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 559 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void xor___0(char *out , char *in1 , char *in2 , int n ) 
{ 
  int i ;

  {
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (i < n)) {
#line 562
      goto while_break;
    }
#line 563
    *(out + i) = (char )((int )*(in1 + i) ^ (int )*(in2 + i));
#line 562
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return;
}
}
#line 566 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void dohash___0(char *out , char *in , char *key , int forw ) 
{ 
  int i ;
  int j ;
  int k ;
  char pk1[56] ;
  char c[28] ;
  char d[28] ;
  char cd[56] ;
  char ki[16][48] ;
  char pd1[64] ;
  char l[32] ;
  char r[32] ;
  char rl[64] ;
  char er[48] ;
  char erk[48] ;
  char b[8][6] ;
  char cb[32] ;
  char pcb[32] ;
  char r2[32] ;
  int tmp ;
  int m ;
  int n ;

  {
  {
#line 578
  permute___0(pk1, key, perm1___0, 56);
#line 580
  i = 0;
  }
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (i < 28)) {
#line 580
      goto while_break;
    }
#line 581
    c[i] = pk1[i];
#line 580
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (i < 28)) {
#line 583
      goto while_break___0;
    }
#line 584
    d[i] = pk1[i + 28];
#line 583
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 586
    if (! (i < 16)) {
#line 586
      goto while_break___1;
    }
    {
#line 587
    l_shift___0(c, (int )sc___0[i], 28);
#line 588
    l_shift___0(d, (int )sc___0[i], 28);
#line 590
    concat___0(cd, c, d, 28, 28);
#line 591
    permute___0(ki[i], cd, perm2___0, 48);
#line 586
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 594
  permute___0(pd1, in, perm3___0, 64);
#line 596
  j = 0;
  }
  {
#line 596
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 596
    if (! (j < 32)) {
#line 596
      goto while_break___2;
    }
#line 598
    l[j] = pd1[j];
#line 599
    r[j] = pd1[j + 32];
#line 596
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 602
  i = 0;
  {
#line 602
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 602
    if (! (i < 16)) {
#line 602
      goto while_break___3;
    }
    {
#line 611
    permute___0(er, r, perm4___0, 48);
    }
#line 613
    if (forw) {
#line 613
      tmp = i;
    } else {
#line 613
      tmp = 15 - i;
    }
    {
#line 613
    xor___0(erk, er, ki[tmp], 48);
#line 615
    j = 0;
    }
    {
#line 615
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 615
      if (! (j < 8)) {
#line 615
        goto while_break___4;
      }
#line 616
      k = 0;
      {
#line 616
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 616
        if (! (k < 6)) {
#line 616
          goto while_break___5;
        }
#line 617
        b[j][k] = erk[j * 6 + k];
#line 616
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 615
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 619
    j = 0;
    {
#line 619
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 619
      if (! (j < 8)) {
#line 619
        goto while_break___6;
      }
#line 621
      m = ((int )b[j][0] << 1) | (int )b[j][5];
#line 623
      n = ((((int )b[j][1] << 3) | ((int )b[j][2] << 2)) | ((int )b[j][3] << 1)) | (int )b[j][4];
#line 625
      k = 0;
      {
#line 625
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 625
        if (! (k < 4)) {
#line 625
          goto while_break___7;
        }
#line 626
        if ((int )sbox___0[j][m][n] & (1 << (3 - k))) {
#line 626
          b[j][k] = (char)1;
        } else {
#line 626
          b[j][k] = (char)0;
        }
#line 625
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 619
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 629
    j = 0;
    {
#line 629
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 629
      if (! (j < 8)) {
#line 629
        goto while_break___8;
      }
#line 630
      k = 0;
      {
#line 630
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 630
        if (! (k < 4)) {
#line 630
          goto while_break___9;
        }
#line 631
        cb[j * 4 + k] = b[j][k];
#line 630
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 629
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 633
    permute___0(pcb, cb, perm5___0, 32);
#line 635
    xor___0(r2, l, pcb, 32);
#line 637
    j = 0;
    }
    {
#line 637
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 637
      if (! (j < 32)) {
#line 637
        goto while_break___10;
      }
#line 638
      l[j] = r[j];
#line 637
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 640
    j = 0;
    {
#line 640
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 640
      if (! (j < 32)) {
#line 640
        goto while_break___11;
      }
#line 641
      r[j] = r2[j];
#line 640
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 602
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 644
  concat___0(rl, r, l, 32, 32);
#line 646
  permute___0(out, rl, perm6___0, 64);
  }
#line 647
  return;
}
}
#line 649 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void str_to_key___0(unsigned char *str , unsigned char *key ) 
{ 
  int i ;

  {
#line 653
  *(key + 0) = (unsigned char )((int )*(str + 0) >> 1);
#line 654
  *(key + 1) = (unsigned char )((((int )*(str + 0) & 1) << 6) | ((int )*(str + 1) >> 2));
#line 655
  *(key + 2) = (unsigned char )((((int )*(str + 1) & 3) << 5) | ((int )*(str + 2) >> 3));
#line 656
  *(key + 3) = (unsigned char )((((int )*(str + 2) & 7) << 4) | ((int )*(str + 3) >> 4));
#line 657
  *(key + 4) = (unsigned char )((((int )*(str + 3) & 15) << 3) | ((int )*(str + 4) >> 5));
#line 658
  *(key + 5) = (unsigned char )((((int )*(str + 4) & 31) << 2) | ((int )*(str + 5) >> 6));
#line 659
  *(key + 6) = (unsigned char )((((int )*(str + 5) & 63) << 1) | ((int )*(str + 6) >> 7));
#line 660
  *(key + 7) = (unsigned char )((int )*(str + 6) & 127);
#line 661
  i = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (i < 8)) {
#line 661
      goto while_break;
    }
#line 662
    *(key + i) = (unsigned char )((int )*(key + i) << 1);
#line 661
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  return;
}
}
#line 666 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void smbhash___0(unsigned char *out , unsigned char *in , unsigned char *key ,
                        int forw ) 
{ 
  int i ;
  char outb[64] ;
  char inb[64] ;
  char keyb[64] ;
  unsigned char key2___5[8] ;

  {
  {
#line 674
  str_to_key___0(key, key2___5);
#line 676
  i = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < 64)) {
#line 676
      goto while_break;
    }
#line 677
    if ((int )*(in + i / 8) & (1 << (7 - i % 8))) {
#line 677
      inb[i] = (char)1;
    } else {
#line 677
      inb[i] = (char)0;
    }
#line 678
    if ((int )key2___5[i / 8] & (1 << (7 - i % 8))) {
#line 678
      keyb[i] = (char)1;
    } else {
#line 678
      keyb[i] = (char)0;
    }
#line 679
    outb[i] = (char)0;
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 682
  dohash___0(outb, inb, keyb, forw);
#line 684
  i = 0;
  }
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 684
    if (! (i < 8)) {
#line 684
      goto while_break___0;
    }
#line 685
    *(out + i) = (unsigned char)0;
#line 684
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 688
  i = 0;
  {
#line 688
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 688
    if (! (i < 64)) {
#line 688
      goto while_break___1;
    }
#line 689
    if (outb[i]) {
#line 690
      *(out + i / 8) = (unsigned char )((int )*(out + i / 8) | (1 << (7 - i % 8)));
    }
#line 688
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 692
  return;
}
}
#line 731 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char key2___1[8]  ;
#line 740 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char key2___2[8]  ;
#line 893 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static int _my_wcslen___0(short *str ) 
{ 
  int len ;
  short *tmp ;

  {
#line 895
  len = 0;
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    tmp = str;
#line 896
    str ++;
#line 896
    if (! ((int )*tmp != 0)) {
#line 896
      goto while_break;
    }
#line 897
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (len);
}
}
#line 907 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static int _my_mbstowcs___0(short *dst , unsigned char *src , int len ) 
{ 
  int i ;
  short val ;

  {
#line 912
  i = 0;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! (i < len)) {
#line 912
      goto while_break;
    }
#line 913
    val = (short )*src;
#line 914
    *((unsigned char *)dst + 0) = (unsigned char )((int )((uint16 )val) & 255);
#line 914
    *((unsigned char *)dst + 1) = (unsigned char )((int )((uint16 )val) >> 8);
#line 915
    dst ++;
#line 916
    src ++;
#line 917
    if ((int )val == 0) {
#line 918
      goto while_break;
    }
#line 912
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (i);
}
}
#line 1101 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void dumpRaw___0(FILE *fp , unsigned char *buf___8 , size_t len ) 
{ 
  int i ;

  {
#line 1105
  i = 0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1105
    if (! (i < (int )len)) {
#line 1105
      goto while_break;
    }
    {
#line 1106
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%02x ",
            (int )*(buf___8 + i));
#line 1105
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1108
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 1109
  return;
}
}
#line 1114 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static char buf___2[1024]  ;
#line 1111 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static char *unicodeToString___0(char *p , size_t len ) 
{ 
  int i ;

  {
#line 1116
  if (! (len + 1UL < sizeof(buf___2))) {
    {
#line 1116
    __assert_fail("len+1 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1116U, "unicodeToString");
    }
  }
#line 1118
  i = 0;
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1118
    if (! (i < (int )len)) {
#line 1118
      goto while_break;
    }
#line 1120
    buf___2[i] = (char )((int )*p & 127);
#line 1121
    p += 2;
#line 1118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1124
  buf___2[i] = (char )'\000';
#line 1125
  return (buf___2);
}
}
#line 1130 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char buf___3[1024]  ;
#line 1128 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char *strToUnicode___0(char *p ) 
{ 
  size_t l ;
  size_t tmp ;
  int i ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1131
  tmp = strlen((char const   *)p);
#line 1131
  l = tmp;
#line 1132
  i = 0;
  }
#line 1134
  if (! (l * 2UL < sizeof(buf___3))) {
    {
#line 1134
    __assert_fail("l*2 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1134U, "strToUnicode");
    }
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    tmp___3 = l;
#line 1136
    l --;
#line 1136
    if (! tmp___3) {
#line 1136
      goto while_break;
    }
#line 1138
    tmp___0 = i;
#line 1138
    i ++;
#line 1138
    tmp___1 = p;
#line 1138
    p ++;
#line 1138
    buf___3[tmp___0] = (unsigned char )*tmp___1;
#line 1139
    tmp___2 = i;
#line 1139
    i ++;
#line 1139
    buf___3[tmp___2] = (unsigned char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  return (buf___3);
}
}
#line 1147 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char buf___4[1024]  ;
#line 1145 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char *toString___0(char *p , size_t len ) 
{ 


  {
#line 1149
  if (! (len + 1UL < sizeof(buf___4))) {
    {
#line 1149
    __assert_fail("len+1 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1149U, "toString");
    }
  }
  {
#line 1151
  memcpy((void */* __restrict  */)(buf___4), (void const   */* __restrict  */)p, len);
#line 1152
  buf___4[len] = (unsigned char)0;
  }
#line 1153
  return (buf___4);
}
}
#line 72 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
int getAuthType(int hSocket , _MODULE_DATA___3 *_psSessionData ) ;
#line 406 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
int getAuthType(int hSocket , _MODULE_DATA___3 *_psSessionData ) 
{ 
  unsigned char *bufReceive ;
  unsigned char *bufSend ;
  int nSendBufferSize ;
  int nReceiveBufferSize ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 410
  nSendBufferSize = 0;
#line 411
  nReceiveBufferSize = 0;
#line 413
  tmp = malloc((size_t )7);
#line 413
  bufSend = (unsigned char *)tmp;
#line 414
  memset((void *)bufSend, 0, (size_t )7);
#line 415
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"CAPA\r\n");
#line 417
  tmp___0 = strlen((char const   *)bufSend);
#line 417
  tmp___1 = medusaSend(hSocket, (char *)bufSend, (int )tmp___0, 0);
  }
#line 417
  if (tmp___1 < 0) {
    {
#line 419
    writeError(3, "%s failed: medusaSend was not successful", "pop3.mod");
    }
#line 420
    return (-1);
  }
#line 422
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 422
    free((void *)bufSend);
#line 422
    bufSend = (unsigned char *)((void *)0);
    }
  }
  {
#line 424
  tmp___8 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+OK.*\r\n\\.*\r\n|-ERR.*\r\n");
  }
#line 424
  if (tmp___8 == -1) {
    {
#line 426
    writeError(3, "[%s] Failed: Server did not respond that it supported any of the authentication types we handle (USER, LOGIN, and NTLM). Use the AUTH module option to force the use of an authentication type: %s",
               "pop3.mod", bufReceive);
    }
#line 427
    return (-1);
  } else
#line 424
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 426
    writeError(3, "[%s] Failed: Server did not respond that it supported any of the authentication types we handle (USER, LOGIN, and NTLM). Use the AUTH module option to force the use of an authentication type: %s",
               "pop3.mod", bufReceive);
    }
#line 427
    return (-1);
  } else {
    {
#line 429
    tmp___7 = strstr((char const   *)bufReceive, "USER");
    }
#line 429
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {
#line 431
      writeError(10, "Server requested authentication type: USER (clear-text)");
#line 432
      _psSessionData->nAuthType = 1;
      }
    } else {
      {
#line 434
      tmp___6 = strstr((char const   *)bufReceive, "SASL");
      }
#line 434
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        {
#line 436
        tmp___4 = strstr((char const   *)bufReceive, "PLAIN");
        }
#line 436
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
          {
#line 438
          writeError(10, "Server requested authentication type: SASL PLAIN");
#line 439
          _psSessionData->nAuthType = 2;
          }
        } else {
          {
#line 441
          tmp___3 = strstr((char const   *)bufReceive, "LOGIN");
          }
#line 441
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            {
#line 443
            writeError(10, "Server requested authentication type: SASL LOGIN");
#line 444
            _psSessionData->nAuthType = 3;
            }
          } else {
            {
#line 446
            tmp___2 = strstr((char const   *)bufReceive, "NTLM");
            }
#line 446
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
              {
#line 448
              writeError(10, "Server requested authentication type: SASL NTLM");
#line 449
              _psSessionData->nAuthType = 4;
              }
            } else {
              {
#line 453
              writeError(3, "[%s] Server requested unsupported SASL method.", "pop3.mod");
              }
#line 454
              return (-1);
            }
          }
        }
      } else {
        {
#line 457
        tmp___5 = strstr((char const   *)bufReceive, "-ERR");
        }
#line 457
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
          {
#line 459
          writeError(3, "[%s] Server did not understand CAPA request. Defaulting to USER authentication type, use \"-m AUTH\" option to specify alternative method.",
                     "pop3.mod");
#line 460
          _psSessionData->nAuthType = 1;
          }
        }
      }
    }
  }
#line 463
  return (0);
}
}
#line 466 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
int sendAuthUSER(int hSocket , _MODULE_DATA___3 *_psSessionData , char *szLogin ,
                 char *szPassword ) 
{ 
  unsigned char bufSend[300] ;
  unsigned char *bufReceive ;
  int nReceiveBufferSize ;
  int nRet ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 469
  bufReceive = (unsigned char *)((void *)0);
#line 470
  nReceiveBufferSize = 0;
#line 471
  nRet = -1;
#line 473
  writeError(10, "[%s] Initiating USER (clear-text) Authentication Attempt.", "pop3.mod");
#line 476
  memset((void *)(bufSend), 0, sizeof(bufSend));
  }
#line 478
  if (_psSessionData->szDomain) {
    {
#line 479
    sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"USER %.100s@%.150s\r\n",
            szLogin, _psSessionData->szDomain);
    }
  } else {
    {
#line 481
    sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"USER %.250s\r\n",
            szLogin);
    }
  }
  {
#line 483
  tmp = strlen((char const   *)(bufSend));
#line 483
  tmp___0 = medusaSend(hSocket, (char *)(bufSend), (int )tmp, 0);
  }
#line 483
  if (tmp___0 < 0) {
    {
#line 485
    writeError(3, "%s failed: medusaSend was not successful", "pop3.mod");
    }
  }
  {
#line 488
  nReceiveBufferSize = 0;
#line 489
  tmp___4 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+OK.*\r\n|-ERR.*\r\n");
  }
#line 489
  if (tmp___4 == -1) {
    {
#line 491
    writeError(3, "[%s] Failed: Server did not respond as expected to USER authentication attempt: %s",
               "pop3.mod", bufReceive);
    }
#line 492
    return (-1);
  } else
#line 489
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 491
    writeError(3, "[%s] Failed: Server did not respond as expected to USER authentication attempt: %s",
               "pop3.mod", bufReceive);
    }
#line 492
    return (-1);
  } else {
    {
#line 494
    tmp___3 = strstr((char const   *)bufReceive, " signing off.");
    }
#line 494
    if (tmp___3) {
      {
#line 496
      writeError(10, "[%s] Server informed us it was signing off. Restarting connection.",
                 "pop3.mod");
#line 497
      nRet = 0;
      }
#line 498
      return (nRet);
    } else {
      {
#line 500
      tmp___2 = strstr((char const   *)bufReceive, "ERR Cleartext login on this server requires the use of transport level security (SSL/TLS)");
      }
#line 500
      if (tmp___2) {
        {
#line 502
        writeError(3, "[%s] Server requires use of SSL/TLS.", "pop3.mod");
        }
#line 503
        return (-1);
      } else {
        {
#line 505
        tmp___1 = strstr((char const   *)bufReceive, "ERR Clear text passwords have been disabled for this protocol.");
        }
#line 505
        if (tmp___1) {
          {
#line 507
          writeError(3, "[%s] Server does not accept clear-text password authentication.",
                     "pop3.mod");
          }
#line 508
          return (-1);
        }
      }
    }
  }
  {
#line 512
  memset((void *)(bufSend), 0, sizeof(bufSend));
#line 513
  sprintf((char */* __restrict  */)(bufSend), (char const   */* __restrict  */)"PASS %.250s\r\n",
          szPassword);
#line 515
  tmp___5 = strlen((char const   *)(bufSend));
#line 515
  tmp___6 = medusaSend(hSocket, (char *)(bufSend), (int )tmp___5, 0);
  }
#line 515
  if (tmp___6 < 0) {
    {
#line 517
    writeError(3, "%s failed: medusaSend was not successful", "pop3.mod");
    }
  }
#line 520
  return (0);
}
}
#line 531 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
int sendAuthPLAIN(int hSocket , _MODULE_DATA___3 *_psSessionData , char *szLogin ,
                  char *szPassword ) 
{ 
  unsigned char *bufReceive ;
  unsigned char *bufSend ;
  unsigned char *szTmpBuf ;
  unsigned char *szTmpBuf64 ;
  int nSendBufferSize ;
  int nReceiveBufferSize ;
  int nRet ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;

  {
  {
#line 533
  bufReceive = (unsigned char *)((void *)0);
#line 534
  bufSend = (unsigned char *)((void *)0);
#line 535
  szTmpBuf = (unsigned char *)((void *)0);
#line 536
  szTmpBuf64 = (unsigned char *)((void *)0);
#line 537
  nSendBufferSize = 0;
#line 538
  nReceiveBufferSize = 0;
#line 539
  nRet = 0;
#line 541
  writeError(10, "[%s] Initiating PLAIN Authentication Attempt.", "pop3.mod");
#line 544
  tmp = strlen((char const   *)szLogin);
#line 544
  tmp___0 = strlen((char const   *)szLogin);
#line 544
  tmp___1 = strlen((char const   *)szPassword);
#line 544
  nSendBufferSize = (int )((((tmp + 1UL) + tmp___0) + 1UL) + tmp___1);
#line 545
  tmp___2 = malloc((size_t )(nSendBufferSize + 1));
#line 545
  szTmpBuf = (unsigned char *)tmp___2;
#line 546
  memset((void *)szTmpBuf, 0, (size_t )(nSendBufferSize + 1));
#line 547
  tmp___3 = strlen((char const   *)szLogin);
#line 547
  strncpy((char */* __restrict  */)szTmpBuf, (char const   */* __restrict  */)szLogin,
          tmp___3);
#line 548
  tmp___4 = strlen((char const   *)szLogin);
#line 548
  tmp___5 = strlen((char const   *)szLogin);
#line 548
  strncpy((char */* __restrict  */)((szTmpBuf + tmp___5) + 1), (char const   */* __restrict  */)szLogin,
          tmp___4);
#line 549
  tmp___6 = strlen((char const   *)szPassword);
#line 549
  tmp___7 = strlen((char const   *)szLogin);
#line 549
  tmp___8 = strlen((char const   *)szLogin);
#line 549
  strncpy((char */* __restrict  */)((((szTmpBuf + tmp___7) + 1) + tmp___8) + 1), (char const   */* __restrict  */)szPassword,
          tmp___6);
#line 551
  tmp___9 = malloc((size_t )((2 * nSendBufferSize + 2) + 1));
#line 551
  szTmpBuf64 = (unsigned char *)tmp___9;
#line 552
  memset((void *)szTmpBuf64, 0, (size_t )((2 * nSendBufferSize + 2) + 1));
#line 553
  base64_encode((char const   *)szTmpBuf, nSendBufferSize, (char *)szTmpBuf64);
  }
#line 554
  if ((unsigned long )szTmpBuf != (unsigned long )((void *)0)) {
    {
#line 554
    free((void *)szTmpBuf);
#line 554
    szTmpBuf = (unsigned char *)((void *)0);
    }
  }
  {
#line 556
  tmp___10 = strlen((char const   *)szTmpBuf64);
#line 556
  tmp___11 = malloc(((11UL + tmp___10) + 2UL) + 1UL);
#line 556
  bufSend = (unsigned char *)tmp___11;
#line 557
  tmp___12 = strlen((char const   *)szTmpBuf64);
#line 557
  memset((void *)bufSend, 0, ((11UL + tmp___12) + 2UL) + 1UL);
#line 559
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"AUTH PLAIN %s\r\n",
          szTmpBuf64);
  }
#line 560
  if ((unsigned long )szTmpBuf64 != (unsigned long )((void *)0)) {
    {
#line 560
    free((void *)szTmpBuf64);
#line 560
    szTmpBuf64 = (unsigned char *)((void *)0);
    }
  }
  {
#line 562
  tmp___13 = strlen((char const   *)bufSend);
#line 562
  tmp___14 = medusaSend(hSocket, (char *)bufSend, (int )tmp___13, 0);
  }
#line 562
  if (tmp___14 < 0) {
    {
#line 564
    writeError(3, "[%s] Failed: medusaSend was not successful", "pop3.mod");
    }
  }
#line 566
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 566
    free((void *)bufSend);
#line 566
    bufSend = (unsigned char *)((void *)0);
    }
  }
#line 568
  return (0);
}
}
#line 580 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/pop3.c"
int sendAuthLOGIN(int hSocket , _MODULE_DATA___3 *_psSessionData , char *szLogin ,
                  char *szPassword ) 
{ 
  unsigned char *bufReceive ;
  unsigned char *bufSend ;
  unsigned char *szPrompt ;
  unsigned char *szTmpBuf ;
  int nSendBufferSize ;
  int nReceiveBufferSize ;
  int nRet ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;

  {
  {
#line 582
  bufReceive = (unsigned char *)((void *)0);
#line 583
  bufSend = (unsigned char *)((void *)0);
#line 584
  szPrompt = (unsigned char *)((void *)0);
#line 585
  szTmpBuf = (unsigned char *)((void *)0);
#line 586
  nSendBufferSize = 0;
#line 587
  nReceiveBufferSize = 0;
#line 588
  nRet = 0;
#line 590
  writeError(10, "[%s] Initiating LOGIN Authentication Attempt.", "pop3.mod");
#line 593
  tmp = malloc((size_t )13);
#line 593
  bufSend = (unsigned char *)tmp;
#line 594
  memset((void *)bufSend, 0, (size_t )13);
#line 595
  sprintf((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"AUTH LOGIN\r\n");
#line 597
  tmp___0 = strlen((char const   *)bufSend);
#line 597
  tmp___1 = medusaSend(hSocket, (char *)bufSend, (int )tmp___0, 0);
  }
#line 597
  if (tmp___1 < 0) {
    {
#line 599
    writeError(3, "[%s] Failed: medusaSend was not successful", "pop3.mod");
    }
  }
#line 601
  if ((unsigned long )bufSend != (unsigned long )((void *)0)) {
    {
#line 601
    free((void *)bufSend);
#line 601
    bufSend = (unsigned char *)((void *)0);
    }
  }
  {
#line 604
  nReceiveBufferSize = 0;
#line 605
  tmp___3 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+ .*\r\n|-ERR.*\r\n");
  }
#line 605
  if (tmp___3 == -1) {
    {
#line 607
    writeError(3, "[%s] POP3 server did not respond with \"+ \" to AUTH LOGIN request.",
               "pop3.mod");
    }
#line 608
    return (-1);
  } else
#line 605
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 607
    writeError(3, "[%s] POP3 server did not respond with \"+ \" to AUTH LOGIN request.",
               "pop3.mod");
    }
#line 608
    return (-1);
  } else {
    {
#line 610
    tmp___2 = strstr((char const   *)bufReceive, "-ERR The specified authentication package is not supported.");
    }
#line 610
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 612
      writeError(3, "[%s] Server response: The specified authentication package is not supported.",
                 "pop3.mod");
      }
#line 613
      return (-1);
    }
  }
  {
#line 616
  tmp___4 = index((char const   *)bufReceive, '\r');
#line 616
  szTmpBuf = (unsigned char *)tmp___4;
#line 617
  *(szTmpBuf + 0) = (unsigned char )'\000';
#line 618
  tmp___5 = strlen((char const   *)(bufReceive + 2));
#line 618
  tmp___6 = malloc(tmp___5 + 1UL);
#line 618
  szPrompt = (unsigned char *)tmp___6;
#line 619
  tmp___7 = strlen((char const   *)(bufReceive + 2));
#line 619
  memset((void *)szPrompt, 0, tmp___7 + 1UL);
#line 621
  base64_decode((char const   *)(bufReceive + 2), (char *)szPrompt);
  }
#line 622
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 622
    free((void *)bufReceive);
#line 622
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 624
  writeError(10, "[%s] POP3 server sent the following prompt: %s", "pop3.mod", szPrompt);
  }
#line 625
  if ((unsigned long )szPrompt != (unsigned long )((void *)0)) {
    {
#line 625
    free((void *)szPrompt);
#line 625
    szPrompt = (unsigned char *)((void *)0);
    }
  }
  {
#line 630
  tmp___8 = strlen((char const   *)szLogin);
#line 630
  tmp___9 = malloc(((2UL * tmp___8 + 2UL) + 2UL) + 1UL);
#line 630
  bufSend = (unsigned char *)tmp___9;
#line 631
  tmp___10 = strlen((char const   *)szLogin);
#line 631
  memset((void *)bufSend, 0, ((2UL * tmp___10 + 2UL) + 2UL) + 1UL);
#line 632
  tmp___11 = strlen((char const   *)szLogin);
#line 632
  base64_encode((char const   *)szLogin, (int )tmp___11, (char *)bufSend);
#line 633
  strncat((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"\r\n",
          (size_t )2);
#line 635
  tmp___12 = strlen((char const   *)bufSend);
#line 635
  tmp___13 = medusaSend(hSocket, (char *)bufSend, (int )tmp___12, 0);
  }
#line 635
  if (tmp___13 < 0) {
    {
#line 637
    writeError(3, "[%s] Failed: medusaSend was not successful", "pop3.mod");
    }
  }
  {
#line 641
  nReceiveBufferSize = 0;
#line 642
  tmp___14 = medusaReceiveRegex(hSocket, & bufReceive, & nReceiveBufferSize, "\\+ .*\r\n");
  }
#line 642
  if (tmp___14 == -1) {
    {
#line 644
    writeError(3, "[%s] POP3 server did not respond with \"+ \" to AUTH LOGIN request.",
               "pop3.mod");
    }
#line 645
    return (-1);
  } else
#line 642
  if ((unsigned long )bufReceive == (unsigned long )((void *)0)) {
    {
#line 644
    writeError(3, "[%s] POP3 server did not respond with \"+ \" to AUTH LOGIN request.",
               "pop3.mod");
    }
#line 645
    return (-1);
  }
  {
#line 648
  tmp___15 = index((char const   *)bufReceive, '\r');
#line 648
  szTmpBuf = (unsigned char *)tmp___15;
#line 649
  *(szTmpBuf + 0) = (unsigned char )'\000';
#line 650
  tmp___16 = strlen((char const   *)(bufReceive + 2));
#line 650
  tmp___17 = malloc(tmp___16 + 1UL);
#line 650
  szPrompt = (unsigned char *)tmp___17;
#line 651
  tmp___18 = strlen((char const   *)(bufReceive + 2));
#line 651
  memset((void *)szPrompt, 0, tmp___18 + 1UL);
#line 653
  base64_decode((char const   *)(bufReceive + 2), (char *)szPrompt);
  }
#line 654
  if ((unsigned long )bufReceive != (unsigned long )((void *)0)) {
    {
#line 654
    free((void *)bufReceive);
#line 654
    bufReceive = (unsigned char *)((void *)0);
    }
  }
  {
#line 656
  writeError(10, "[%s] POP3 server sent the following prompt: %s", "pop3.mod", szPrompt);
  }
#line 657
  if ((unsigned long )szPrompt != (unsigned long )((void *)0)) {
    {
#line 657
    free((void *)szPrompt);
#line 657
    szPrompt = (unsigned char *)((void *)0);
    }
  }
  {
#line 662
  tmp___19 = strlen((char const   *)szPassword);
#line 662
  tmp___20 = malloc(((2UL * tmp___19 + 2UL) + 2UL) + 1UL);
#line 662
  bufSend = (unsigned char *)tmp___20;
#line 663
  tmp___21 = strlen((char const   *)szPassword);
#line 663
  memset((void *)bufSend, 0, ((2UL * tmp___21 + 2UL) + 2UL) + 1UL);
#line 664
  tmp___22 = strlen((char const   *)szPassword);
#line 664
  base64_encode((char const   *)szPassword, (int )tmp___22, (char *)bufSend);
#line 665
  strncat((char */* __restrict  */)bufSend, (char const   */* __restrict  */)"\r\n",
          (size_t )2);
#line 667
  tmp___23 = strlen((char const   *)bufSend);
#line 667
  tmp___24 = medusaSend(hSocket, (char *)bufSend, (int )tmp___23, 0);
  }
#line 667
  if (tmp___24 < 0) {
    {
#line 669
    writeError(3, "[%s] Failed: medusaSend was not successful", "pop3.mod");
    }
  }
#line 672
  return (0);
}
}
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 A___1  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 B___1  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 C___1  ;
#line 289 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 D___1  ;
#line 291 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 F___1(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 293
  return ((X & Y) | (~ X & Z));
}
}
#line 296 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 G___1(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 298
  return (((X & Y) | (X & Z)) | (Y & Z));
}
}
#line 301 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 H___1(uint32 X , uint32 Y , uint32 Z ) 
{ 


  {
#line 303
  return ((X ^ Y) ^ Z);
}
}
#line 306 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static uint32 lshift___1(uint32 x , int s ) 
{ 


  {
#line 308
  x &= 4294967295U;
#line 309
  return (((x << s) & 4294967295U) | (x >> (32 - s)));
}
}
#line 317 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void mdfour64___1(uint32 *M ) 
{ 
  int j ;
  uint32 AA ;
  uint32 BB ;
  uint32 CC ;
  uint32 DD ;
  uint32 X[16] ;
  uint32 tmp ;
  uint32 tmp___0 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint32 tmp___5 ;
  uint32 tmp___6 ;
  uint32 tmp___7 ;
  uint32 tmp___8 ;
  uint32 tmp___9 ;
  uint32 tmp___10 ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;
  uint32 tmp___13 ;
  uint32 tmp___14 ;
  uint32 tmp___15 ;
  uint32 tmp___16 ;
  uint32 tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;
  uint32 tmp___20 ;
  uint32 tmp___21 ;
  uint32 tmp___22 ;
  uint32 tmp___23 ;
  uint32 tmp___24 ;
  uint32 tmp___25 ;
  uint32 tmp___26 ;
  uint32 tmp___27 ;
  uint32 tmp___28 ;
  uint32 tmp___29 ;
  uint32 tmp___30 ;
  uint32 tmp___31 ;
  uint32 tmp___32 ;
  uint32 tmp___33 ;
  uint32 tmp___34 ;
  uint32 tmp___35 ;
  uint32 tmp___36 ;
  uint32 tmp___37 ;
  uint32 tmp___38 ;
  uint32 tmp___39 ;
  uint32 tmp___40 ;
  uint32 tmp___41 ;
  uint32 tmp___42 ;
  uint32 tmp___43 ;
  uint32 tmp___44 ;
  uint32 tmp___45 ;
  uint32 tmp___46 ;

  {
#line 323
  j = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (j < 16)) {
#line 323
      goto while_break;
    }
#line 324
    X[j] = *(M + j);
#line 323
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  AA = A___1;
#line 326
  BB = B___1;
#line 326
  CC = C___1;
#line 326
  DD = D___1;
#line 328
  tmp = F___1(B___1, C___1, D___1);
#line 328
  A___1 = lshift___1((A___1 + tmp) + X[0], 3);
#line 328
  tmp___0 = F___1(A___1, B___1, C___1);
#line 328
  D___1 = lshift___1((D___1 + tmp___0) + X[1], 7);
#line 329
  tmp___1 = F___1(D___1, A___1, B___1);
#line 329
  C___1 = lshift___1((C___1 + tmp___1) + X[2], 11);
#line 329
  tmp___2 = F___1(C___1, D___1, A___1);
#line 329
  B___1 = lshift___1((B___1 + tmp___2) + X[3], 19);
#line 330
  tmp___3 = F___1(B___1, C___1, D___1);
#line 330
  A___1 = lshift___1((A___1 + tmp___3) + X[4], 3);
#line 330
  tmp___4 = F___1(A___1, B___1, C___1);
#line 330
  D___1 = lshift___1((D___1 + tmp___4) + X[5], 7);
#line 331
  tmp___5 = F___1(D___1, A___1, B___1);
#line 331
  C___1 = lshift___1((C___1 + tmp___5) + X[6], 11);
#line 331
  tmp___6 = F___1(C___1, D___1, A___1);
#line 331
  B___1 = lshift___1((B___1 + tmp___6) + X[7], 19);
#line 332
  tmp___7 = F___1(B___1, C___1, D___1);
#line 332
  A___1 = lshift___1((A___1 + tmp___7) + X[8], 3);
#line 332
  tmp___8 = F___1(A___1, B___1, C___1);
#line 332
  D___1 = lshift___1((D___1 + tmp___8) + X[9], 7);
#line 333
  tmp___9 = F___1(D___1, A___1, B___1);
#line 333
  C___1 = lshift___1((C___1 + tmp___9) + X[10], 11);
#line 333
  tmp___10 = F___1(C___1, D___1, A___1);
#line 333
  B___1 = lshift___1((B___1 + tmp___10) + X[11], 19);
#line 334
  tmp___11 = F___1(B___1, C___1, D___1);
#line 334
  A___1 = lshift___1((A___1 + tmp___11) + X[12], 3);
#line 334
  tmp___12 = F___1(A___1, B___1, C___1);
#line 334
  D___1 = lshift___1((D___1 + tmp___12) + X[13], 7);
#line 335
  tmp___13 = F___1(D___1, A___1, B___1);
#line 335
  C___1 = lshift___1((C___1 + tmp___13) + X[14], 11);
#line 335
  tmp___14 = F___1(C___1, D___1, A___1);
#line 335
  B___1 = lshift___1((B___1 + tmp___14) + X[15], 19);
#line 337
  tmp___15 = G___1(B___1, C___1, D___1);
#line 337
  A___1 = lshift___1(((A___1 + tmp___15) + X[0]) + 1518500249U, 3);
#line 337
  tmp___16 = G___1(A___1, B___1, C___1);
#line 337
  D___1 = lshift___1(((D___1 + tmp___16) + X[4]) + 1518500249U, 5);
#line 338
  tmp___17 = G___1(D___1, A___1, B___1);
#line 338
  C___1 = lshift___1(((C___1 + tmp___17) + X[8]) + 1518500249U, 9);
#line 338
  tmp___18 = G___1(C___1, D___1, A___1);
#line 338
  B___1 = lshift___1(((B___1 + tmp___18) + X[12]) + 1518500249U, 13);
#line 339
  tmp___19 = G___1(B___1, C___1, D___1);
#line 339
  A___1 = lshift___1(((A___1 + tmp___19) + X[1]) + 1518500249U, 3);
#line 339
  tmp___20 = G___1(A___1, B___1, C___1);
#line 339
  D___1 = lshift___1(((D___1 + tmp___20) + X[5]) + 1518500249U, 5);
#line 340
  tmp___21 = G___1(D___1, A___1, B___1);
#line 340
  C___1 = lshift___1(((C___1 + tmp___21) + X[9]) + 1518500249U, 9);
#line 340
  tmp___22 = G___1(C___1, D___1, A___1);
#line 340
  B___1 = lshift___1(((B___1 + tmp___22) + X[13]) + 1518500249U, 13);
#line 341
  tmp___23 = G___1(B___1, C___1, D___1);
#line 341
  A___1 = lshift___1(((A___1 + tmp___23) + X[2]) + 1518500249U, 3);
#line 341
  tmp___24 = G___1(A___1, B___1, C___1);
#line 341
  D___1 = lshift___1(((D___1 + tmp___24) + X[6]) + 1518500249U, 5);
#line 342
  tmp___25 = G___1(D___1, A___1, B___1);
#line 342
  C___1 = lshift___1(((C___1 + tmp___25) + X[10]) + 1518500249U, 9);
#line 342
  tmp___26 = G___1(C___1, D___1, A___1);
#line 342
  B___1 = lshift___1(((B___1 + tmp___26) + X[14]) + 1518500249U, 13);
#line 343
  tmp___27 = G___1(B___1, C___1, D___1);
#line 343
  A___1 = lshift___1(((A___1 + tmp___27) + X[3]) + 1518500249U, 3);
#line 343
  tmp___28 = G___1(A___1, B___1, C___1);
#line 343
  D___1 = lshift___1(((D___1 + tmp___28) + X[7]) + 1518500249U, 5);
#line 344
  tmp___29 = G___1(D___1, A___1, B___1);
#line 344
  C___1 = lshift___1(((C___1 + tmp___29) + X[11]) + 1518500249U, 9);
#line 344
  tmp___30 = G___1(C___1, D___1, A___1);
#line 344
  B___1 = lshift___1(((B___1 + tmp___30) + X[15]) + 1518500249U, 13);
#line 346
  tmp___31 = H___1(B___1, C___1, D___1);
#line 346
  A___1 = lshift___1(((A___1 + tmp___31) + X[0]) + 1859775393U, 3);
#line 346
  tmp___32 = H___1(A___1, B___1, C___1);
#line 346
  D___1 = lshift___1(((D___1 + tmp___32) + X[8]) + 1859775393U, 9);
#line 347
  tmp___33 = H___1(D___1, A___1, B___1);
#line 347
  C___1 = lshift___1(((C___1 + tmp___33) + X[4]) + 1859775393U, 11);
#line 347
  tmp___34 = H___1(C___1, D___1, A___1);
#line 347
  B___1 = lshift___1(((B___1 + tmp___34) + X[12]) + 1859775393U, 15);
#line 348
  tmp___35 = H___1(B___1, C___1, D___1);
#line 348
  A___1 = lshift___1(((A___1 + tmp___35) + X[2]) + 1859775393U, 3);
#line 348
  tmp___36 = H___1(A___1, B___1, C___1);
#line 348
  D___1 = lshift___1(((D___1 + tmp___36) + X[10]) + 1859775393U, 9);
#line 349
  tmp___37 = H___1(D___1, A___1, B___1);
#line 349
  C___1 = lshift___1(((C___1 + tmp___37) + X[6]) + 1859775393U, 11);
#line 349
  tmp___38 = H___1(C___1, D___1, A___1);
#line 349
  B___1 = lshift___1(((B___1 + tmp___38) + X[14]) + 1859775393U, 15);
#line 350
  tmp___39 = H___1(B___1, C___1, D___1);
#line 350
  A___1 = lshift___1(((A___1 + tmp___39) + X[1]) + 1859775393U, 3);
#line 350
  tmp___40 = H___1(A___1, B___1, C___1);
#line 350
  D___1 = lshift___1(((D___1 + tmp___40) + X[9]) + 1859775393U, 9);
#line 351
  tmp___41 = H___1(D___1, A___1, B___1);
#line 351
  C___1 = lshift___1(((C___1 + tmp___41) + X[5]) + 1859775393U, 11);
#line 351
  tmp___42 = H___1(C___1, D___1, A___1);
#line 351
  B___1 = lshift___1(((B___1 + tmp___42) + X[13]) + 1859775393U, 15);
#line 352
  tmp___43 = H___1(B___1, C___1, D___1);
#line 352
  A___1 = lshift___1(((A___1 + tmp___43) + X[3]) + 1859775393U, 3);
#line 352
  tmp___44 = H___1(A___1, B___1, C___1);
#line 352
  D___1 = lshift___1(((D___1 + tmp___44) + X[11]) + 1859775393U, 9);
#line 353
  tmp___45 = H___1(D___1, A___1, B___1);
#line 353
  C___1 = lshift___1(((C___1 + tmp___45) + X[7]) + 1859775393U, 11);
#line 353
  tmp___46 = H___1(C___1, D___1, A___1);
#line 353
  B___1 = lshift___1(((B___1 + tmp___46) + X[15]) + 1859775393U, 15);
#line 355
  A___1 += AA;
#line 355
  B___1 += BB;
#line 355
  C___1 += CC;
#line 355
  D___1 += DD;
#line 357
  A___1 &= 4294967295U;
#line 357
  B___1 &= 4294967295U;
#line 358
  C___1 &= 4294967295U;
#line 358
  D___1 &= 4294967295U;
#line 360
  j = 0;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (j < 16)) {
#line 360
      goto while_break___0;
    }
#line 361
    X[j] = (uint32 )0;
#line 360
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void copy64___1(uint32 *M , unsigned char *in ) 
{ 
  int i ;

  {
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 16)) {
#line 368
      goto while_break;
    }
#line 369
    *(M + i) = (uint32 )(((((int )*(in + (i * 4 + 3)) << 24) | ((int )*(in + (i * 4 + 2)) << 16)) | ((int )*(in + (i * 4 + 1)) << 8)) | (int )*(in + i * 4));
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void copy4___1(unsigned char *out , uint32 x ) 
{ 


  {
#line 375
  *(out + 0) = (unsigned char )(x & 255U);
#line 376
  *(out + 1) = (unsigned char )((x >> 8) & 255U);
#line 377
  *(out + 2) = (unsigned char )((x >> 16) & 255U);
#line 378
  *(out + 3) = (unsigned char )((x >> 24) & 255U);
#line 379
  return;
}
}
#line 437 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm1___1[56]  = 
#line 437
  {      (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)63,      (unsigned char)55,      (unsigned char)47,      (unsigned char)39, 
        (unsigned char)31,      (unsigned char)23,      (unsigned char)15,      (unsigned char)7, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4};
#line 446 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm2___1[48]  = 
#line 446
  {      (unsigned char)14,      (unsigned char)17,      (unsigned char)11,      (unsigned char)24, 
        (unsigned char)1,      (unsigned char)5,      (unsigned char)3,      (unsigned char)28, 
        (unsigned char)15,      (unsigned char)6,      (unsigned char)21,      (unsigned char)10, 
        (unsigned char)23,      (unsigned char)19,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)26,      (unsigned char)8,      (unsigned char)16,      (unsigned char)7, 
        (unsigned char)27,      (unsigned char)20,      (unsigned char)13,      (unsigned char)2, 
        (unsigned char)41,      (unsigned char)52,      (unsigned char)31,      (unsigned char)37, 
        (unsigned char)47,      (unsigned char)55,      (unsigned char)30,      (unsigned char)40, 
        (unsigned char)51,      (unsigned char)45,      (unsigned char)33,      (unsigned char)48, 
        (unsigned char)44,      (unsigned char)49,      (unsigned char)39,      (unsigned char)56, 
        (unsigned char)34,      (unsigned char)53,      (unsigned char)46,      (unsigned char)42, 
        (unsigned char)50,      (unsigned char)36,      (unsigned char)29,      (unsigned char)32};
#line 455 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm3___1[64]  = 
#line 455
  {      (unsigned char)58,      (unsigned char)50,      (unsigned char)42,      (unsigned char)34, 
        (unsigned char)26,      (unsigned char)18,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)44,      (unsigned char)36, 
        (unsigned char)28,      (unsigned char)20,      (unsigned char)12,      (unsigned char)4, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)46,      (unsigned char)38, 
        (unsigned char)30,      (unsigned char)22,      (unsigned char)14,      (unsigned char)6, 
        (unsigned char)64,      (unsigned char)56,      (unsigned char)48,      (unsigned char)40, 
        (unsigned char)32,      (unsigned char)24,      (unsigned char)16,      (unsigned char)8, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)41,      (unsigned char)33, 
        (unsigned char)25,      (unsigned char)17,      (unsigned char)9,      (unsigned char)1, 
        (unsigned char)59,      (unsigned char)51,      (unsigned char)43,      (unsigned char)35, 
        (unsigned char)27,      (unsigned char)19,      (unsigned char)11,      (unsigned char)3, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)45,      (unsigned char)37, 
        (unsigned char)29,      (unsigned char)21,      (unsigned char)13,      (unsigned char)5, 
        (unsigned char)63,      (unsigned char)55,      (unsigned char)47,      (unsigned char)39, 
        (unsigned char)31,      (unsigned char)23,      (unsigned char)15,      (unsigned char)7};
#line 464 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm4___1[48]  = 
#line 464
  {      (unsigned char)32,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)8,      (unsigned char)9, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)12,      (unsigned char)13, 
        (unsigned char)14,      (unsigned char)15,      (unsigned char)16,      (unsigned char)17, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)22,      (unsigned char)23,      (unsigned char)24,      (unsigned char)25, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)28,      (unsigned char)29, 
        (unsigned char)30,      (unsigned char)31,      (unsigned char)32,      (unsigned char)1};
#line 473 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm5___1[32]  = 
#line 473
  {      (unsigned char)16,      (unsigned char)7,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)29,      (unsigned char)12,      (unsigned char)28,      (unsigned char)17, 
        (unsigned char)1,      (unsigned char)15,      (unsigned char)23,      (unsigned char)26, 
        (unsigned char)5,      (unsigned char)18,      (unsigned char)31,      (unsigned char)10, 
        (unsigned char)2,      (unsigned char)8,      (unsigned char)24,      (unsigned char)14, 
        (unsigned char)32,      (unsigned char)27,      (unsigned char)3,      (unsigned char)9, 
        (unsigned char)19,      (unsigned char)13,      (unsigned char)30,      (unsigned char)6, 
        (unsigned char)22,      (unsigned char)11,      (unsigned char)4,      (unsigned char)25};
#line 482 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char perm6___1[64]  = 
#line 482
  {      (unsigned char)40,      (unsigned char)8,      (unsigned char)48,      (unsigned char)16, 
        (unsigned char)56,      (unsigned char)24,      (unsigned char)64,      (unsigned char)32, 
        (unsigned char)39,      (unsigned char)7,      (unsigned char)47,      (unsigned char)15, 
        (unsigned char)55,      (unsigned char)23,      (unsigned char)63,      (unsigned char)31, 
        (unsigned char)38,      (unsigned char)6,      (unsigned char)46,      (unsigned char)14, 
        (unsigned char)54,      (unsigned char)22,      (unsigned char)62,      (unsigned char)30, 
        (unsigned char)37,      (unsigned char)5,      (unsigned char)45,      (unsigned char)13, 
        (unsigned char)53,      (unsigned char)21,      (unsigned char)61,      (unsigned char)29, 
        (unsigned char)36,      (unsigned char)4,      (unsigned char)44,      (unsigned char)12, 
        (unsigned char)52,      (unsigned char)20,      (unsigned char)60,      (unsigned char)28, 
        (unsigned char)35,      (unsigned char)3,      (unsigned char)43,      (unsigned char)11, 
        (unsigned char)51,      (unsigned char)19,      (unsigned char)59,      (unsigned char)27, 
        (unsigned char)34,      (unsigned char)2,      (unsigned char)42,      (unsigned char)10, 
        (unsigned char)50,      (unsigned char)18,      (unsigned char)58,      (unsigned char)26, 
        (unsigned char)33,      (unsigned char)1,      (unsigned char)41,      (unsigned char)9, 
        (unsigned char)49,      (unsigned char)17,      (unsigned char)57,      (unsigned char)25};
#line 491 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char sc___1[16]  = 
#line 491
  {      (unsigned char)1,      (unsigned char)1,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)1};
#line 493 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char sbox___1[8][4][16]  = 
#line 493
  { { {          (unsigned char)14,          (unsigned char)4,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)2,          (unsigned char)15,          (unsigned char)11,          (unsigned char)8, 
                (unsigned char)3,          (unsigned char)10,          (unsigned char)6,          (unsigned char)12, 
                (unsigned char)5,          (unsigned char)9,          (unsigned char)0,          (unsigned char)7}, 
     {          (unsigned char)0,          (unsigned char)15,          (unsigned char)7,          (unsigned char)4, 
                (unsigned char)14,          (unsigned char)2,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)10,          (unsigned char)6,          (unsigned char)12,          (unsigned char)11, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)3,          (unsigned char)8}, 
     {          (unsigned char)4,          (unsigned char)1,          (unsigned char)14,          (unsigned char)8, 
                (unsigned char)13,          (unsigned char)6,          (unsigned char)2,          (unsigned char)11, 
                (unsigned char)15,          (unsigned char)12,          (unsigned char)9,          (unsigned char)7, 
                (unsigned char)3,          (unsigned char)10,          (unsigned char)5,          (unsigned char)0}, 
     {          (unsigned char)15,          (unsigned char)12,          (unsigned char)8,          (unsigned char)2, 
                (unsigned char)4,          (unsigned char)9,          (unsigned char)1,          (unsigned char)7, 
                (unsigned char)5,          (unsigned char)11,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)10,          (unsigned char)0,          (unsigned char)6,          (unsigned char)13}}, 
   { {          (unsigned char)15,          (unsigned char)1,          (unsigned char)8,          (unsigned char)14, 
                (unsigned char)6,          (unsigned char)11,          (unsigned char)3,          (unsigned char)4, 
                (unsigned char)9,          (unsigned char)7,          (unsigned char)2,          (unsigned char)13, 
                (unsigned char)12,          (unsigned char)0,          (unsigned char)5,          (unsigned char)10}, 
     {          (unsigned char)3,          (unsigned char)13,          (unsigned char)4,          (unsigned char)7, 
                (unsigned char)15,          (unsigned char)2,          (unsigned char)8,          (unsigned char)14, 
                (unsigned char)12,          (unsigned char)0,          (unsigned char)1,          (unsigned char)10, 
                (unsigned char)6,          (unsigned char)9,          (unsigned char)11,          (unsigned char)5}, 
     {          (unsigned char)0,          (unsigned char)14,          (unsigned char)7,          (unsigned char)11, 
                (unsigned char)10,          (unsigned char)4,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)5,          (unsigned char)8,          (unsigned char)12,          (unsigned char)6, 
                (unsigned char)9,          (unsigned char)3,          (unsigned char)2,          (unsigned char)15}, 
     {          (unsigned char)13,          (unsigned char)8,          (unsigned char)10,          (unsigned char)1, 
                (unsigned char)3,          (unsigned char)15,          (unsigned char)4,          (unsigned char)2, 
                (unsigned char)11,          (unsigned char)6,          (unsigned char)7,          (unsigned char)12, 
                (unsigned char)0,          (unsigned char)5,          (unsigned char)14,          (unsigned char)9}}, 
   { {          (unsigned char)10,          (unsigned char)0,          (unsigned char)9,          (unsigned char)14, 
                (unsigned char)6,          (unsigned char)3,          (unsigned char)15,          (unsigned char)5, 
                (unsigned char)1,          (unsigned char)13,          (unsigned char)12,          (unsigned char)7, 
                (unsigned char)11,          (unsigned char)4,          (unsigned char)2,          (unsigned char)8}, 
     {          (unsigned char)13,          (unsigned char)7,          (unsigned char)0,          (unsigned char)9, 
                (unsigned char)3,          (unsigned char)4,          (unsigned char)6,          (unsigned char)10, 
                (unsigned char)2,          (unsigned char)8,          (unsigned char)5,          (unsigned char)14, 
                (unsigned char)12,          (unsigned char)11,          (unsigned char)15,          (unsigned char)1}, 
     {          (unsigned char)13,          (unsigned char)6,          (unsigned char)4,          (unsigned char)9, 
                (unsigned char)8,          (unsigned char)15,          (unsigned char)3,          (unsigned char)0, 
                (unsigned char)11,          (unsigned char)1,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)5,          (unsigned char)10,          (unsigned char)14,          (unsigned char)7}, 
     {          (unsigned char)1,          (unsigned char)10,          (unsigned char)13,          (unsigned char)0, 
                (unsigned char)6,          (unsigned char)9,          (unsigned char)8,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)15,          (unsigned char)14,          (unsigned char)3, 
                (unsigned char)11,          (unsigned char)5,          (unsigned char)2,          (unsigned char)12}}, 
   { {          (unsigned char)7,          (unsigned char)13,          (unsigned char)14,          (unsigned char)3, 
                (unsigned char)0,          (unsigned char)6,          (unsigned char)9,          (unsigned char)10, 
                (unsigned char)1,          (unsigned char)2,          (unsigned char)8,          (unsigned char)5, 
                (unsigned char)11,          (unsigned char)12,          (unsigned char)4,          (unsigned char)15}, 
     {          (unsigned char)13,          (unsigned char)8,          (unsigned char)11,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)0,          (unsigned char)3, 
                (unsigned char)4,          (unsigned char)7,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)1,          (unsigned char)10,          (unsigned char)14,          (unsigned char)9}, 
     {          (unsigned char)10,          (unsigned char)6,          (unsigned char)9,          (unsigned char)0, 
                (unsigned char)12,          (unsigned char)11,          (unsigned char)7,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)1,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)5,          (unsigned char)2,          (unsigned char)8,          (unsigned char)4}, 
     {          (unsigned char)3,          (unsigned char)15,          (unsigned char)0,          (unsigned char)6, 
                (unsigned char)10,          (unsigned char)1,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)9,          (unsigned char)4,          (unsigned char)5,          (unsigned char)11, 
                (unsigned char)12,          (unsigned char)7,          (unsigned char)2,          (unsigned char)14}}, 
   { {          (unsigned char)2,          (unsigned char)12,          (unsigned char)4,          (unsigned char)1, 
                (unsigned char)7,          (unsigned char)10,          (unsigned char)11,          (unsigned char)6, 
                (unsigned char)8,          (unsigned char)5,          (unsigned char)3,          (unsigned char)15, 
                (unsigned char)13,          (unsigned char)0,          (unsigned char)14,          (unsigned char)9}, 
     {          (unsigned char)14,          (unsigned char)11,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)4,          (unsigned char)7,          (unsigned char)13,          (unsigned char)1, 
                (unsigned char)5,          (unsigned char)0,          (unsigned char)15,          (unsigned char)10, 
                (unsigned char)3,          (unsigned char)9,          (unsigned char)8,          (unsigned char)6}, 
     {          (unsigned char)4,          (unsigned char)2,          (unsigned char)1,          (unsigned char)11, 
                (unsigned char)10,          (unsigned char)13,          (unsigned char)7,          (unsigned char)8, 
                (unsigned char)15,          (unsigned char)9,          (unsigned char)12,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)3,          (unsigned char)0,          (unsigned char)14}, 
     {          (unsigned char)11,          (unsigned char)8,          (unsigned char)12,          (unsigned char)7, 
                (unsigned char)1,          (unsigned char)14,          (unsigned char)2,          (unsigned char)13, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)0,          (unsigned char)9, 
                (unsigned char)10,          (unsigned char)4,          (unsigned char)5,          (unsigned char)3}}, 
   { {          (unsigned char)12,          (unsigned char)1,          (unsigned char)10,          (unsigned char)15, 
                (unsigned char)9,          (unsigned char)2,          (unsigned char)6,          (unsigned char)8, 
                (unsigned char)0,          (unsigned char)13,          (unsigned char)3,          (unsigned char)4, 
                (unsigned char)14,          (unsigned char)7,          (unsigned char)5,          (unsigned char)11}, 
     {          (unsigned char)10,          (unsigned char)15,          (unsigned char)4,          (unsigned char)2, 
                (unsigned char)7,          (unsigned char)12,          (unsigned char)9,          (unsigned char)5, 
                (unsigned char)6,          (unsigned char)1,          (unsigned char)13,          (unsigned char)14, 
                (unsigned char)0,          (unsigned char)11,          (unsigned char)3,          (unsigned char)8}, 
     {          (unsigned char)9,          (unsigned char)14,          (unsigned char)15,          (unsigned char)5, 
                (unsigned char)2,          (unsigned char)8,          (unsigned char)12,          (unsigned char)3, 
                (unsigned char)7,          (unsigned char)0,          (unsigned char)4,          (unsigned char)10, 
                (unsigned char)1,          (unsigned char)13,          (unsigned char)11,          (unsigned char)6}, 
     {          (unsigned char)4,          (unsigned char)3,          (unsigned char)2,          (unsigned char)12, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)15,          (unsigned char)10, 
                (unsigned char)11,          (unsigned char)14,          (unsigned char)1,          (unsigned char)7, 
                (unsigned char)6,          (unsigned char)0,          (unsigned char)8,          (unsigned char)13}}, 
   { {          (unsigned char)4,          (unsigned char)11,          (unsigned char)2,          (unsigned char)14, 
                (unsigned char)15,          (unsigned char)0,          (unsigned char)8,          (unsigned char)13, 
                (unsigned char)3,          (unsigned char)12,          (unsigned char)9,          (unsigned char)7, 
                (unsigned char)5,          (unsigned char)10,          (unsigned char)6,          (unsigned char)1}, 
     {          (unsigned char)13,          (unsigned char)0,          (unsigned char)11,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)9,          (unsigned char)1,          (unsigned char)10, 
                (unsigned char)14,          (unsigned char)3,          (unsigned char)5,          (unsigned char)12, 
                (unsigned char)2,          (unsigned char)15,          (unsigned char)8,          (unsigned char)6}, 
     {          (unsigned char)1,          (unsigned char)4,          (unsigned char)11,          (unsigned char)13, 
                (unsigned char)12,          (unsigned char)3,          (unsigned char)7,          (unsigned char)14, 
                (unsigned char)10,          (unsigned char)15,          (unsigned char)6,          (unsigned char)8, 
                (unsigned char)0,          (unsigned char)5,          (unsigned char)9,          (unsigned char)2}, 
     {          (unsigned char)6,          (unsigned char)11,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)1,          (unsigned char)4,          (unsigned char)10,          (unsigned char)7, 
                (unsigned char)9,          (unsigned char)5,          (unsigned char)0,          (unsigned char)15, 
                (unsigned char)14,          (unsigned char)2,          (unsigned char)3,          (unsigned char)12}}, 
   { {          (unsigned char)13,          (unsigned char)2,          (unsigned char)8,          (unsigned char)4, 
                (unsigned char)6,          (unsigned char)15,          (unsigned char)11,          (unsigned char)1, 
                (unsigned char)10,          (unsigned char)9,          (unsigned char)3,          (unsigned char)14, 
                (unsigned char)5,          (unsigned char)0,          (unsigned char)12,          (unsigned char)7}, 
     {          (unsigned char)1,          (unsigned char)15,          (unsigned char)13,          (unsigned char)8, 
                (unsigned char)10,          (unsigned char)3,          (unsigned char)7,          (unsigned char)4, 
                (unsigned char)12,          (unsigned char)5,          (unsigned char)6,          (unsigned char)11, 
                (unsigned char)0,          (unsigned char)14,          (unsigned char)9,          (unsigned char)2}, 
     {          (unsigned char)7,          (unsigned char)11,          (unsigned char)4,          (unsigned char)1, 
                (unsigned char)9,          (unsigned char)12,          (unsigned char)14,          (unsigned char)2, 
                (unsigned char)0,          (unsigned char)6,          (unsigned char)10,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)3,          (unsigned char)5,          (unsigned char)8}, 
     {          (unsigned char)2,          (unsigned char)1,          (unsigned char)14,          (unsigned char)7, 
                (unsigned char)4,          (unsigned char)10,          (unsigned char)8,          (unsigned char)13, 
                (unsigned char)15,          (unsigned char)12,          (unsigned char)9,          (unsigned char)0, 
                (unsigned char)3,          (unsigned char)5,          (unsigned char)6,          (unsigned char)11}}};
#line 534 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void permute___1(char *out , char *in , unsigned char *p , int n ) 
{ 
  int i ;

  {
#line 537
  i = 0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (i < n)) {
#line 537
      goto while_break;
    }
#line 538
    *(out + i) = *(in + ((int )*(p + i) - 1));
#line 537
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 541 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void l_shift___1(char *d , int count , int n ) 
{ 
  char out[64] ;
  int i ;

  {
#line 545
  i = 0;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < n)) {
#line 545
      goto while_break;
    }
#line 546
    out[i] = *(d + (i + count) % n);
#line 545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  i = 0;
  {
#line 547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 547
    if (! (i < n)) {
#line 547
      goto while_break___0;
    }
#line 548
    *(d + i) = out[i];
#line 547
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  return;
}
}
#line 551 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void concat___1(char *out , char *in1 , char *in2 , int l1 , int l2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    tmp___1 = l1;
#line 553
    l1 --;
#line 553
    if (! tmp___1) {
#line 553
      goto while_break;
    }
#line 554
    tmp = out;
#line 554
    out ++;
#line 554
    tmp___0 = in1;
#line 554
    in1 ++;
#line 554
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 555
    tmp___4 = l2;
#line 555
    l2 --;
#line 555
    if (! tmp___4) {
#line 555
      goto while_break___0;
    }
#line 556
    tmp___2 = out;
#line 556
    out ++;
#line 556
    tmp___3 = in2;
#line 556
    in2 ++;
#line 556
    *tmp___2 = *tmp___3;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 559 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void xor___1(char *out , char *in1 , char *in2 , int n ) 
{ 
  int i ;

  {
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (i < n)) {
#line 562
      goto while_break;
    }
#line 563
    *(out + i) = (char )((int )*(in1 + i) ^ (int )*(in2 + i));
#line 562
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return;
}
}
#line 566 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void dohash___1(char *out , char *in , char *key , int forw ) 
{ 
  int i ;
  int j ;
  int k ;
  char pk1[56] ;
  char c[28] ;
  char d[28] ;
  char cd[56] ;
  char ki[16][48] ;
  char pd1[64] ;
  char l[32] ;
  char r[32] ;
  char rl[64] ;
  char er[48] ;
  char erk[48] ;
  char b[8][6] ;
  char cb[32] ;
  char pcb[32] ;
  char r2[32] ;
  int tmp ;
  int m ;
  int n ;

  {
  {
#line 578
  permute___1(pk1, key, perm1___1, 56);
#line 580
  i = 0;
  }
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (i < 28)) {
#line 580
      goto while_break;
    }
#line 581
    c[i] = pk1[i];
#line 580
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (i < 28)) {
#line 583
      goto while_break___0;
    }
#line 584
    d[i] = pk1[i + 28];
#line 583
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 586
    if (! (i < 16)) {
#line 586
      goto while_break___1;
    }
    {
#line 587
    l_shift___1(c, (int )sc___1[i], 28);
#line 588
    l_shift___1(d, (int )sc___1[i], 28);
#line 590
    concat___1(cd, c, d, 28, 28);
#line 591
    permute___1(ki[i], cd, perm2___1, 48);
#line 586
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 594
  permute___1(pd1, in, perm3___1, 64);
#line 596
  j = 0;
  }
  {
#line 596
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 596
    if (! (j < 32)) {
#line 596
      goto while_break___2;
    }
#line 598
    l[j] = pd1[j];
#line 599
    r[j] = pd1[j + 32];
#line 596
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 602
  i = 0;
  {
#line 602
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 602
    if (! (i < 16)) {
#line 602
      goto while_break___3;
    }
    {
#line 611
    permute___1(er, r, perm4___1, 48);
    }
#line 613
    if (forw) {
#line 613
      tmp = i;
    } else {
#line 613
      tmp = 15 - i;
    }
    {
#line 613
    xor___1(erk, er, ki[tmp], 48);
#line 615
    j = 0;
    }
    {
#line 615
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 615
      if (! (j < 8)) {
#line 615
        goto while_break___4;
      }
#line 616
      k = 0;
      {
#line 616
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 616
        if (! (k < 6)) {
#line 616
          goto while_break___5;
        }
#line 617
        b[j][k] = erk[j * 6 + k];
#line 616
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 615
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 619
    j = 0;
    {
#line 619
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 619
      if (! (j < 8)) {
#line 619
        goto while_break___6;
      }
#line 621
      m = ((int )b[j][0] << 1) | (int )b[j][5];
#line 623
      n = ((((int )b[j][1] << 3) | ((int )b[j][2] << 2)) | ((int )b[j][3] << 1)) | (int )b[j][4];
#line 625
      k = 0;
      {
#line 625
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 625
        if (! (k < 4)) {
#line 625
          goto while_break___7;
        }
#line 626
        if ((int )sbox___1[j][m][n] & (1 << (3 - k))) {
#line 626
          b[j][k] = (char)1;
        } else {
#line 626
          b[j][k] = (char)0;
        }
#line 625
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 619
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 629
    j = 0;
    {
#line 629
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 629
      if (! (j < 8)) {
#line 629
        goto while_break___8;
      }
#line 630
      k = 0;
      {
#line 630
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 630
        if (! (k < 4)) {
#line 630
          goto while_break___9;
        }
#line 631
        cb[j * 4 + k] = b[j][k];
#line 630
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 629
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 633
    permute___1(pcb, cb, perm5___1, 32);
#line 635
    xor___1(r2, l, pcb, 32);
#line 637
    j = 0;
    }
    {
#line 637
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 637
      if (! (j < 32)) {
#line 637
        goto while_break___10;
      }
#line 638
      l[j] = r[j];
#line 637
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 640
    j = 0;
    {
#line 640
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 640
      if (! (j < 32)) {
#line 640
        goto while_break___11;
      }
#line 641
      r[j] = r2[j];
#line 640
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 602
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 644
  concat___1(rl, r, l, 32, 32);
#line 646
  permute___1(out, rl, perm6___1, 64);
  }
#line 647
  return;
}
}
#line 649 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void str_to_key___1(unsigned char *str , unsigned char *key ) 
{ 
  int i ;

  {
#line 653
  *(key + 0) = (unsigned char )((int )*(str + 0) >> 1);
#line 654
  *(key + 1) = (unsigned char )((((int )*(str + 0) & 1) << 6) | ((int )*(str + 1) >> 2));
#line 655
  *(key + 2) = (unsigned char )((((int )*(str + 1) & 3) << 5) | ((int )*(str + 2) >> 3));
#line 656
  *(key + 3) = (unsigned char )((((int )*(str + 2) & 7) << 4) | ((int )*(str + 3) >> 4));
#line 657
  *(key + 4) = (unsigned char )((((int )*(str + 3) & 15) << 3) | ((int )*(str + 4) >> 5));
#line 658
  *(key + 5) = (unsigned char )((((int )*(str + 4) & 31) << 2) | ((int )*(str + 5) >> 6));
#line 659
  *(key + 6) = (unsigned char )((((int )*(str + 5) & 63) << 1) | ((int )*(str + 6) >> 7));
#line 660
  *(key + 7) = (unsigned char )((int )*(str + 6) & 127);
#line 661
  i = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (i < 8)) {
#line 661
      goto while_break;
    }
#line 662
    *(key + i) = (unsigned char )((int )*(key + i) << 1);
#line 661
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  return;
}
}
#line 666 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void smbhash___1(unsigned char *out , unsigned char *in , unsigned char *key ,
                        int forw ) 
{ 
  int i ;
  char outb[64] ;
  char inb[64] ;
  char keyb[64] ;
  unsigned char key2___5[8] ;

  {
  {
#line 674
  str_to_key___1(key, key2___5);
#line 676
  i = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < 64)) {
#line 676
      goto while_break;
    }
#line 677
    if ((int )*(in + i / 8) & (1 << (7 - i % 8))) {
#line 677
      inb[i] = (char)1;
    } else {
#line 677
      inb[i] = (char)0;
    }
#line 678
    if ((int )key2___5[i / 8] & (1 << (7 - i % 8))) {
#line 678
      keyb[i] = (char)1;
    } else {
#line 678
      keyb[i] = (char)0;
    }
#line 679
    outb[i] = (char)0;
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 682
  dohash___1(outb, inb, keyb, forw);
#line 684
  i = 0;
  }
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 684
    if (! (i < 8)) {
#line 684
      goto while_break___0;
    }
#line 685
    *(out + i) = (unsigned char)0;
#line 684
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 688
  i = 0;
  {
#line 688
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 688
    if (! (i < 64)) {
#line 688
      goto while_break___1;
    }
#line 689
    if (outb[i]) {
#line 690
      *(out + i / 8) = (unsigned char )((int )*(out + i / 8) | (1 << (7 - i % 8)));
    }
#line 688
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 692
  return;
}
}
#line 731 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char key2___3[8]  ;
#line 740 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char key2___4[8]  ;
#line 893 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static int _my_wcslen___1(short *str ) 
{ 
  int len ;
  short *tmp ;

  {
#line 895
  len = 0;
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    tmp = str;
#line 896
    str ++;
#line 896
    if (! ((int )*tmp != 0)) {
#line 896
      goto while_break;
    }
#line 897
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (len);
}
}
#line 907 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static int _my_mbstowcs___1(short *dst , unsigned char *src , int len ) 
{ 
  int i ;
  short val ;

  {
#line 912
  i = 0;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! (i < len)) {
#line 912
      goto while_break;
    }
#line 913
    val = (short )*src;
#line 914
    *((unsigned char *)dst + 0) = (unsigned char )((int )((uint16 )val) & 255);
#line 914
    *((unsigned char *)dst + 1) = (unsigned char )((int )((uint16 )val) >> 8);
#line 915
    dst ++;
#line 916
    src ++;
#line 917
    if ((int )val == 0) {
#line 918
      goto while_break;
    }
#line 912
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (i);
}
}
#line 1101 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static void dumpRaw___1(FILE *fp , unsigned char *buf___8 , size_t len ) 
{ 
  int i ;

  {
#line 1105
  i = 0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1105
    if (! (i < (int )len)) {
#line 1105
      goto while_break;
    }
    {
#line 1106
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%02x ",
            (int )*(buf___8 + i));
#line 1105
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1108
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 1109
  return;
}
}
#line 1114 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static char buf___5[1024]  ;
#line 1111 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static char *unicodeToString___1(char *p , size_t len ) 
{ 
  int i ;

  {
#line 1116
  if (! (len + 1UL < sizeof(buf___5))) {
    {
#line 1116
    __assert_fail("len+1 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1116U, "unicodeToString");
    }
  }
#line 1118
  i = 0;
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1118
    if (! (i < (int )len)) {
#line 1118
      goto while_break;
    }
#line 1120
    buf___5[i] = (char )((int )*p & 127);
#line 1121
    p += 2;
#line 1118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1124
  buf___5[i] = (char )'\000';
#line 1125
  return (buf___5);
}
}
#line 1130 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char buf___6[1024]  ;
#line 1128 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char *strToUnicode___1(char *p ) 
{ 
  size_t l ;
  size_t tmp ;
  int i ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1131
  tmp = strlen((char const   *)p);
#line 1131
  l = tmp;
#line 1132
  i = 0;
  }
#line 1134
  if (! (l * 2UL < sizeof(buf___6))) {
    {
#line 1134
    __assert_fail("l*2 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1134U, "strToUnicode");
    }
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    tmp___3 = l;
#line 1136
    l --;
#line 1136
    if (! tmp___3) {
#line 1136
      goto while_break;
    }
#line 1138
    tmp___0 = i;
#line 1138
    i ++;
#line 1138
    tmp___1 = p;
#line 1138
    p ++;
#line 1138
    buf___6[tmp___0] = (unsigned char )*tmp___1;
#line 1139
    tmp___2 = i;
#line 1139
    i ++;
#line 1139
    buf___6[tmp___2] = (unsigned char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  return (buf___6);
}
}
#line 1147 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char buf___7[1024]  ;
#line 1145 "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c"
static unsigned char *toString___1(char *p , size_t len ) 
{ 


  {
#line 1149
  if (! (len + 1UL < sizeof(buf___7))) {
    {
#line 1149
    __assert_fail("len+1 < sizeof buf", "/home/wheatley/newnew/temp/medusa-2.1.1/src/modsrc/ntlm.c",
                  1149U, "toString");
    }
  }
  {
#line 1151
  memcpy((void */* __restrict  */)(buf___7), (void const   */* __restrict  */)p, len);
#line 1152
  buf___7[len] = (unsigned char)0;
  }
#line 1153
  return (buf___7);
}
}
