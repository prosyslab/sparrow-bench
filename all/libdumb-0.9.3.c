/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 140 "include/dumb.h"
typedef int sample_t;
#line 162
struct DUMBFILE;
#line 162 "include/dumb.h"
typedef struct DUMBFILE DUMBFILE;
#line 203
struct DUH;
#line 203 "include/dumb.h"
typedef struct DUH DUH;
#line 219
struct DUH_SIGRENDERER;
#line 219 "include/dumb.h"
typedef struct DUH_SIGRENDERER DUH_SIGRENDERER;
#line 486 "include/dumb.h"
typedef void sigdata_t;
#line 487 "include/dumb.h"
typedef void sigrenderer_t;
#line 522 "include/dumb.h"
struct DUH_SIGTYPE_DESC {
   long type ;
   sigdata_t *(*load_sigdata)(DUH *duh , DUMBFILE *file ) ;
   sigrenderer_t *(*start_sigrenderer)(DUH *duh , sigdata_t *sigdata , int n_channels ,
                                       long pos ) ;
   void (*sigrenderer_set_sigparam)(sigrenderer_t *sigrenderer , unsigned char id ,
                                    long value ) ;
   long (*sigrenderer_generate_samples)(sigrenderer_t *sigrenderer , float volume ,
                                        float delta , long size , sample_t **samples ) ;
   void (*sigrenderer_get_current_sample)(sigrenderer_t *sigrenderer , float volume ,
                                          sample_t *samples ) ;
   void (*end_sigrenderer)(sigrenderer_t *sigrenderer ) ;
   void (*unload_sigdata)(sigdata_t *sigdata ) ;
};
#line 522 "include/dumb.h"
typedef struct DUH_SIGTYPE_DESC DUH_SIGTYPE_DESC;
#line 38 "include/internal/dumb.h"
struct DUH_SIGNAL {
   sigdata_t *sigdata ;
   DUH_SIGTYPE_DESC *desc ;
};
#line 38 "include/internal/dumb.h"
typedef struct DUH_SIGNAL DUH_SIGNAL;
#line 46 "include/internal/dumb.h"
struct DUH {
   long length ;
   int n_tags ;
   char *(*tag)[2] ;
   int n_signals ;
   DUH_SIGNAL **signal ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 353 "include/dumb.h"
struct DUMB_IT_SIGDATA;
#line 353 "include/dumb.h"
typedef struct DUMB_IT_SIGDATA DUMB_IT_SIGDATA;
#line 354
struct DUMB_IT_SIGRENDERER;
#line 354 "include/dumb.h"
typedef struct DUMB_IT_SIGRENDERER DUMB_IT_SIGRENDERER;
#line 571
struct DUMB_CLICK_REMOVER;
#line 571 "include/dumb.h"
typedef struct DUMB_CLICK_REMOVER DUMB_CLICK_REMOVER;
#line 595
struct DUMB_RESAMPLER;
#line 595 "include/dumb.h"
typedef struct DUMB_RESAMPLER DUMB_RESAMPLER;
#line 599 "include/dumb.h"
union __anonunion_x_25 {
   sample_t x24[6] ;
   short x16[6] ;
   signed char x8[6] ;
};
#line 599 "include/dumb.h"
struct DUMB_RESAMPLER {
   void *src ;
   long pos ;
   int subpos ;
   long start ;
   long end ;
   int dir ;
   void (*pickup)(DUMB_RESAMPLER *resampler , void *data ) ;
   void *pickup_data ;
   int min_quality ;
   int max_quality ;
   union __anonunion_x_25 x ;
   int overshot ;
};
#line 87 "include/internal/it.h"
struct IT_MIDI;
#line 87 "include/internal/it.h"
typedef struct IT_MIDI IT_MIDI;
#line 88
struct IT_FILTER_STATE;
#line 88 "include/internal/it.h"
typedef struct IT_FILTER_STATE IT_FILTER_STATE;
#line 89
struct IT_ENVELOPE;
#line 89 "include/internal/it.h"
typedef struct IT_ENVELOPE IT_ENVELOPE;
#line 90
struct IT_INSTRUMENT;
#line 90 "include/internal/it.h"
typedef struct IT_INSTRUMENT IT_INSTRUMENT;
#line 91
struct IT_SAMPLE;
#line 91 "include/internal/it.h"
typedef struct IT_SAMPLE IT_SAMPLE;
#line 92
struct IT_ENTRY;
#line 92 "include/internal/it.h"
typedef struct IT_ENTRY IT_ENTRY;
#line 93
struct IT_PATTERN;
#line 93 "include/internal/it.h"
typedef struct IT_PATTERN IT_PATTERN;
#line 94
struct IT_PLAYING_ENVELOPE;
#line 94 "include/internal/it.h"
typedef struct IT_PLAYING_ENVELOPE IT_PLAYING_ENVELOPE;
#line 95
struct IT_PLAYING;
#line 95 "include/internal/it.h"
typedef struct IT_PLAYING IT_PLAYING;
#line 96
struct IT_CHANNEL;
#line 96 "include/internal/it.h"
typedef struct IT_CHANNEL IT_CHANNEL;
#line 97
struct IT_CHECKPOINT;
#line 97 "include/internal/it.h"
typedef struct IT_CHECKPOINT IT_CHECKPOINT;
#line 98
struct IT_CALLBACKS;
#line 98 "include/internal/it.h"
typedef struct IT_CALLBACKS IT_CALLBACKS;
#line 102 "include/internal/it.h"
struct IT_MIDI {
   unsigned char SFmacro[16][16] ;
   unsigned char SFmacrolen[16] ;
   unsigned short SFmacroz[16] ;
   unsigned char Zmacro[128][16] ;
   unsigned char Zmacrolen[128] ;
};
#line 113 "include/internal/it.h"
struct IT_FILTER_STATE {
   sample_t currsample ;
   sample_t prevsample ;
};
#line 125 "include/internal/it.h"
struct IT_ENVELOPE {
   unsigned char flags ;
   unsigned char n_nodes ;
   unsigned char loop_start ;
   unsigned char loop_end ;
   unsigned char sus_loop_start ;
   unsigned char sus_loop_end ;
   signed char node_y[25] ;
   unsigned short node_t[25] ;
};
#line 153 "include/internal/it.h"
struct IT_INSTRUMENT {
   unsigned char name[27] ;
   unsigned char filename[14] ;
   int fadeout ;
   IT_ENVELOPE volume_envelope ;
   IT_ENVELOPE pan_envelope ;
   IT_ENVELOPE pitch_envelope ;
   unsigned char new_note_action ;
   unsigned char dup_check_type ;
   unsigned char dup_check_action ;
   unsigned char pp_separation ;
   unsigned char pp_centre ;
   unsigned char global_volume ;
   unsigned char default_pan ;
   unsigned char random_volume ;
   unsigned char random_pan ;
   unsigned char filter_cutoff ;
   unsigned char filter_resonance ;
   unsigned char map_note[120] ;
   unsigned short map_sample[120] ;
};
#line 196 "include/internal/it.h"
struct IT_SAMPLE {
   unsigned char name[29] ;
   unsigned char filename[14] ;
   unsigned char flags ;
   unsigned char global_volume ;
   unsigned char default_volume ;
   unsigned char default_pan ;
   long length ;
   long loop_start ;
   long loop_end ;
   long C5_speed ;
   long sus_loop_start ;
   long sus_loop_end ;
   unsigned char vibrato_speed ;
   unsigned char vibrato_depth ;
   unsigned char vibrato_rate ;
   unsigned char vibrato_waveform ;
   void *data ;
};
#line 339 "include/internal/it.h"
struct IT_ENTRY {
   unsigned char channel ;
   unsigned char mask ;
   unsigned char note ;
   unsigned char instrument ;
   unsigned char volpan ;
   unsigned char effect ;
   unsigned char effectvalue ;
};
#line 352 "include/internal/it.h"
struct IT_PATTERN {
   int n_rows ;
   int n_entries ;
   IT_ENTRY *entry ;
};
#line 376 "include/internal/it.h"
struct DUMB_IT_SIGDATA {
   unsigned char name[29] ;
   unsigned char *song_message ;
   int n_orders ;
   int n_instruments ;
   int n_samples ;
   int n_patterns ;
   int flags ;
   int global_volume ;
   int mixing_volume ;
   int speed ;
   int tempo ;
   int pan_separation ;
   unsigned char channel_pan[64] ;
   unsigned char channel_volume[64] ;
   unsigned char *order ;
   unsigned char restart_position ;
   IT_INSTRUMENT *instrument ;
   IT_SAMPLE *sample ;
   IT_PATTERN *pattern ;
   IT_MIDI *midi ;
   IT_CHECKPOINT *checkpoint ;
};
#line 412 "include/internal/it.h"
struct IT_PLAYING_ENVELOPE {
   int next_node ;
   int tick ;
   int value ;
};
#line 426 "include/internal/it.h"
struct IT_PLAYING {
   int flags ;
   IT_CHANNEL *channel ;
   IT_SAMPLE *sample ;
   IT_INSTRUMENT *instrument ;
   IT_INSTRUMENT *env_instrument ;
   unsigned short sampnum ;
   unsigned char instnum ;
   unsigned char channel_volume ;
   unsigned char volume ;
   unsigned short pan ;
   unsigned char note ;
   unsigned char filter_cutoff ;
   unsigned char filter_resonance ;
   unsigned short true_filter_cutoff ;
   unsigned char true_filter_resonance ;
   unsigned char vibrato_speed ;
   unsigned char vibrato_depth ;
   unsigned char vibrato_n ;
   unsigned char vibrato_time ;
   unsigned char tremolo_speed ;
   unsigned char tremolo_depth ;
   unsigned char tremolo_time ;
   unsigned char sample_vibrato_time ;
   int sample_vibrato_depth ;
   int slide ;
   float delta ;
   IT_PLAYING_ENVELOPE volume_envelope ;
   IT_PLAYING_ENVELOPE pan_envelope ;
   IT_PLAYING_ENVELOPE pitch_envelope ;
   int fadeoutcount ;
   IT_FILTER_STATE filter_state[2] ;
   DUMB_RESAMPLER resampler ;
   long time_lost ;
};
#line 492 "include/internal/it.h"
struct IT_CHANNEL {
   int flags ;
   unsigned char volume ;
   signed char volslide ;
   signed char xm_volslide ;
   signed char panslide ;
   unsigned char pan ;
   unsigned short truepan ;
   unsigned char channelvolume ;
   signed char channelvolslide ;
   unsigned char instrument ;
   unsigned char note ;
   unsigned char SFmacro ;
   unsigned char filter_cutoff ;
   unsigned char filter_resonance ;
   unsigned char key_off_count ;
   unsigned char note_cut_count ;
   unsigned char note_delay_count ;
   IT_ENTRY *note_delay_entry ;
   int arpeggio ;
   unsigned char retrig ;
   unsigned char xm_retrig ;
   int retrig_tick ;
   unsigned char tremor ;
   unsigned char tremor_time ;
   int portamento ;
   int toneporta ;
   unsigned char destnote ;
   unsigned short sample ;
   unsigned char truenote ;
   unsigned char midi_state ;
   signed char lastvolslide ;
   unsigned char lastDKL ;
   unsigned char lastEF ;
   unsigned char lastG ;
   unsigned char lastHspeed ;
   unsigned char lastHdepth ;
   unsigned char lastRspeed ;
   unsigned char lastRdepth ;
   unsigned char lastI ;
   unsigned char lastJ ;
   unsigned char lastN ;
   unsigned char lastO ;
   unsigned char high_offset ;
   unsigned char lastP ;
   unsigned char lastQ ;
   unsigned char lastS ;
   unsigned char pat_loop_row ;
   unsigned char pat_loop_count ;
   unsigned char pat_loop_end_row ;
   unsigned char lastW ;
   unsigned char xm_lastE1 ;
   unsigned char xm_lastE2 ;
   unsigned char xm_lastEA ;
   unsigned char xm_lastEB ;
   unsigned char xm_lastX1 ;
   unsigned char xm_lastX2 ;
   IT_PLAYING *playing ;
};
#line 577 "include/internal/it.h"
struct DUMB_IT_SIGRENDERER {
   DUMB_IT_SIGDATA *sigdata ;
   int n_channels ;
   unsigned char globalvolume ;
   signed char globalvolslide ;
   unsigned char tempo ;
   signed char temposlide ;
   IT_CHANNEL channel[64] ;
   IT_PLAYING *playing[192] ;
   int tick ;
   int speed ;
   int rowcount ;
   int order ;
   int row ;
   int processorder ;
   int processrow ;
   int breakrow ;
   int pat_loop_row ;
   int n_rows ;
   IT_ENTRY *entry_start ;
   IT_ENTRY *entry ;
   IT_ENTRY *entry_end ;
   long time_left ;
   int sub_time_left ;
   DUMB_CLICK_REMOVER **click_remover ;
   IT_CALLBACKS *callbacks ;
};
#line 620 "include/internal/it.h"
struct IT_CHECKPOINT {
   IT_CHECKPOINT *next ;
   long time ;
   DUMB_IT_SIGRENDERER *sigrenderer ;
};
#line 629 "include/internal/it.h"
struct IT_CALLBACKS {
   int (*loop)(void *data ) ;
   void *loop_data ;
   int (*xm_speed_zero)(void *data ) ;
   void *xm_speed_zero_data ;
   int (*midi)(void *data , int channel , unsigned char byte ) ;
   void *midi_data ;
};
#line 441 "include/dumb.h"
struct DUMB_IT_CHANNEL_STATE;
#line 441 "include/dumb.h"
typedef struct DUMB_IT_CHANNEL_STATE DUMB_IT_CHANNEL_STATE;
#line 443 "include/dumb.h"
struct DUMB_IT_CHANNEL_STATE {
   int channel ;
   int sample ;
   int freq ;
   float volume ;
   unsigned char pan ;
   signed char subpan ;
   unsigned char filter_cutoff ;
   unsigned char filter_subcutoff ;
   unsigned char filter_resonance ;
};
#line 3109 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
struct IT_TO_MIX {
   IT_PLAYING *playing ;
   float volume ;
};
#line 3109 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
typedef struct IT_TO_MIX IT_TO_MIX;
#line 152 "include/dumb.h"
struct DUMBFILE_SYSTEM {
   void *(*open)(char const   *filename ) ;
   int (*skip)(void *f , long n ) ;
   int (*getc)(void *f ) ;
   long (*getnc)(char *ptr , long n , void *f ) ;
   void (*close)(void *f ) ;
};
#line 152 "include/dumb.h"
typedef struct DUMBFILE_SYSTEM DUMBFILE_SYSTEM;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
struct DUMBFILE {
   DUMBFILE_SYSTEM *dfs ;
   void *file ;
   long pos ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumbout.c"
union __anonunion_buffer_29 {
   short s16[8192] ;
   char s8[16384] ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
typedef unsigned char byte;
#line 49 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
typedef unsigned short word;
#line 799 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
struct IT_COMPONENT {
   unsigned char type ;
   unsigned char n ;
   long offset ;
   short sampfirst ;
   short sampnext ;
};
#line 799 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
typedef struct IT_COMPONENT IT_COMPONENT;
#line 26 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
struct DUMB_CLICK;
#line 26 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
typedef struct DUMB_CLICK DUMB_CLICK;
#line 29 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
struct DUMB_CLICK_REMOVER {
   DUMB_CLICK *click ;
   int n_clicks ;
   int offset ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
struct DUMB_CLICK {
   DUMB_CLICK *next ;
   long pos ;
   sample_t step ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/atexit.c"
struct DUMB_ATEXIT_PROC {
   struct DUMB_ATEXIT_PROC *next ;
   void (*proc)(void) ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/atexit.c"
typedef struct DUMB_ATEXIT_PROC DUMB_ATEXIT_PROC;
#line 221 "include/dumb.h"
extern DUH_SIGRENDERER *duh_start_sigrenderer(DUH *duh , int sig , int n_channels ,
                                              long pos ) ;
#line 274
extern int duh_sigrenderer_get_n_channels(DUH_SIGRENDERER *sigrenderer ) ;
#line 275
extern long duh_sigrenderer_get_position(DUH_SIGRENDERER *sigrenderer ) ;
#line 292
extern long duh_sigrenderer_generate_samples(DUH_SIGRENDERER *sigrenderer , float volume ,
                                             float delta , long size , sample_t **samples ) ;
#line 300
extern void duh_end_sigrenderer(DUH_SIGRENDERER *sigrenderer ) ;
#line 305
long duh_render(DUH_SIGRENDERER *sigrenderer , int bits , int unsign , float volume ,
                float delta , long size , void *sptr ) ;
#line 326
DUH_SIGRENDERER *duh_start_renderer(DUH *duh , int n_channels , long pos )  __attribute__((__deprecated__)) ;
#line 329
int duh_renderer_get_n_channels(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 330
long duh_renderer_get_position(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 333
void duh_end_renderer(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 336
DUH_SIGRENDERER *duh_renderer_encapsulate_sigrenderer(DUH_SIGRENDERER *sigrenderer )  __attribute__((__deprecated__)) ;
#line 337
DUH_SIGRENDERER *duh_renderer_get_sigrenderer(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 338
DUH_SIGRENDERER *duh_renderer_decompose_to_sigrenderer(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 560
extern sample_t **allocate_sample_buffer(int n_channels , long length ) ;
#line 561
extern void destroy_sample_buffer(sample_t **samples ) ;
#line 566
extern void dumb_silence(sample_t *samples , long length ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
DUH_SIGRENDERER *duh_start_renderer(DUH *duh , int n_channels , long pos )  __attribute__((__deprecated__)) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
DUH_SIGRENDERER *duh_start_renderer(DUH *duh , int n_channels , long pos ) 
{ 
  DUH_SIGRENDERER *tmp ;

  {
  {
#line 78
  tmp = duh_start_sigrenderer(duh, 0, n_channels, pos);
  }
#line 78
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
long duh_render(DUH_SIGRENDERER *sigrenderer , int bits , int unsign , float volume ,
                float delta , long size , void *sptr ) 
{ 
  long n ;
  sample_t **sampptr ;
  int n_channels ;
  int signconv ;
  int tmp ;
  int f ;
  int tmp___1 ;
  int tmp___2 ;
  char signconv___0 ;
  int tmp___3 ;
  int f___0 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 99
  if (! sigrenderer) {
#line 100
    return (0L);
  }
  {
#line 102
  n_channels = duh_sigrenderer_get_n_channels(sigrenderer);
#line 110
  sampptr = allocate_sample_buffer(n_channels, size);
  }
#line 112
  if (! sampptr) {
#line 113
    return (0L);
  }
  {
#line 115
  dumb_silence(*(sampptr + 0), (long )n_channels * size);
#line 117
  size = duh_sigrenderer_generate_samples(sigrenderer, volume, delta, size, sampptr);
  }
#line 119
  if (bits == 16) {
#line 120
    if (unsign) {
#line 120
      tmp = 32768;
    } else {
#line 120
      tmp = 0;
    }
#line 120
    signconv = tmp;
#line 122
    n = 0L;
    {
#line 122
    while (1) {
      while_continue: /* CIL Label */ ;
#line 122
      if (! (n < size * (long )n_channels)) {
#line 122
        goto while_break;
      }
#line 123
      f = (*(*(sampptr + 0) + n) + 128) >> 8;
#line 123
      if (f < 32767) {
#line 123
        tmp___2 = f;
      } else {
#line 123
        tmp___2 = 32767;
      }
#line 123
      if (-32768 > tmp___2) {
#line 123
        f = -32768;
      } else {
#line 123
        if (f < 32767) {
#line 123
          tmp___1 = f;
        } else {
#line 123
          tmp___1 = 32767;
        }
#line 123
        f = tmp___1;
      }
#line 123
      *((short *)sptr + n) = (short )(f ^ signconv);
#line 122
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 126
    if (unsign) {
#line 126
      tmp___3 = 128;
    } else {
#line 126
      tmp___3 = 0;
    }
#line 126
    signconv___0 = (char )tmp___3;
#line 128
    n = 0L;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! (n < size * (long )n_channels)) {
#line 128
        goto while_break___0;
      }
#line 129
      f___0 = (*(*(sampptr + 0) + n) + 32768) >> 16;
#line 129
      if (f___0 < 127) {
#line 129
        tmp___6 = f___0;
      } else {
#line 129
        tmp___6 = 127;
      }
#line 129
      if (-128 > tmp___6) {
#line 129
        f___0 = -128;
      } else {
#line 129
        if (f___0 < 127) {
#line 129
          tmp___5 = f___0;
        } else {
#line 129
          tmp___5 = 127;
        }
#line 129
        f___0 = tmp___5;
      }
#line 129
      *((char *)sptr + n) = (char )((int )((char )f___0) ^ (int )signconv___0);
#line 128
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 133
  destroy_sample_buffer(sampptr);
  }
#line 135
  return (size);
}
}
#line 141
int duh_renderer_get_n_channels(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
int duh_renderer_get_n_channels(DUH_SIGRENDERER *dr ) 
{ 
  int tmp ;

  {
  {
#line 143
  tmp = duh_sigrenderer_get_n_channels(dr);
  }
#line 143
  return (tmp);
}
}
#line 149
long duh_renderer_get_position(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
long duh_renderer_get_position(DUH_SIGRENDERER *dr ) 
{ 
  long tmp ;

  {
  {
#line 151
  tmp = duh_sigrenderer_get_position(dr);
  }
#line 151
  return (tmp);
}
}
#line 157
void duh_end_renderer(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 157 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
void duh_end_renderer(DUH_SIGRENDERER *dr ) 
{ 


  {
  {
#line 159
  duh_end_sigrenderer(dr);
  }
#line 160
  return;
}
}
#line 165
DUH_SIGRENDERER *duh_renderer_encapsulate_sigrenderer(DUH_SIGRENDERER *sigrenderer )  __attribute__((__deprecated__)) ;
#line 165 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
DUH_SIGRENDERER *duh_renderer_encapsulate_sigrenderer(DUH_SIGRENDERER *sigrenderer ) 
{ 


  {
#line 167
  return (sigrenderer);
}
}
#line 173
DUH_SIGRENDERER *duh_renderer_get_sigrenderer(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
DUH_SIGRENDERER *duh_renderer_get_sigrenderer(DUH_SIGRENDERER *dr ) 
{ 


  {
#line 175
  return (dr);
}
}
#line 181
DUH_SIGRENDERER *duh_renderer_decompose_to_sigrenderer(DUH_SIGRENDERER *dr )  __attribute__((__deprecated__)) ;
#line 181 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/rendduh.c"
DUH_SIGRENDERER *duh_renderer_decompose_to_sigrenderer(DUH_SIGRENDERER *dr ) 
{ 


  {
#line 183
  return (dr);
}
}
#line 166 "include/dumb.h"
DUMBFILE *dumbfile_open(char const   *filename ) ;
#line 186
int dumbfile_close(DUMBFILE *f ) ;
#line 209
DUH *load_duh(char const   *filename ) ;
#line 210
extern DUH *read_duh(DUMBFILE *f ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/loadduh.c"
DUH *load_duh(char const   *filename ) 
{ 
  DUH *duh ;
  DUMBFILE *f ;
  DUMBFILE *tmp ;

  {
  {
#line 32
  tmp = dumbfile_open(filename);
#line 32
  f = tmp;
  }
#line 34
  if (! f) {
#line 35
    return ((DUH *)((void *)0));
  }
  {
#line 37
  duh = read_duh(f);
#line 39
  dumbfile_close(f);
  }
#line 41
  return (duh);
}
}
#line 382 "include/dumb.h"
DUH *dumb_load_mod_quick(char const   *filename ) ;
#line 387
extern DUH *dumb_read_mod_quick(DUMBFILE *f ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/loadmod.c"
DUH *dumb_load_mod_quick(char const   *filename ) 
{ 
  DUH *duh ;
  DUMBFILE *f ;
  DUMBFILE *tmp ;

  {
  {
#line 32
  tmp = dumbfile_open(filename);
#line 32
  f = tmp;
  }
#line 34
  if (! f) {
#line 35
    return ((DUH *)((void *)0));
  }
  {
#line 37
  duh = dumb_read_mod_quick(f);
#line 39
  dumbfile_close(f);
  }
#line 41
  return (duh);
}
}
#line 369 "include/dumb.h"
DUH *dumb_load_it(char const   *filename ) ;
#line 379
DUH *dumb_load_it_quick(char const   *filename ) ;
#line 390
void dumb_it_do_initial_runthrough(DUH *duh ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itload2.c"
DUH *dumb_load_it(char const   *filename ) 
{ 
  DUH *duh ;
  DUH *tmp ;

  {
  {
#line 26
  tmp = dumb_load_it_quick(filename);
#line 26
  duh = tmp;
#line 27
  dumb_it_do_initial_runthrough(duh);
  }
#line 28
  return (duh);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 729 "include/internal/it.h"
int _dumb_it_fix_invalid_orders(DUMB_IT_SIGDATA *sigdata ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itorder.c"
int _dumb_it_fix_invalid_orders(DUMB_IT_SIGDATA *sigdata ) 
{ 
  int i ;
  int found_some ;
  int first_invalid ;
  int last_invalid ;
  int tmp ;
  IT_PATTERN *new_pattern ;
  void *tmp___0 ;

  {
#line 38
  found_some = 0;
#line 40
  first_invalid = sigdata->n_patterns;
#line 41
  if (sigdata->flags & 64) {
#line 41
    tmp = 255;
  } else {
#line 41
    tmp = 253;
  }
#line 41
  last_invalid = tmp;
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < sigdata->n_orders)) {
#line 43
      goto while_break;
    }
#line 44
    if ((int )*(sigdata->order + i) >= first_invalid) {
#line 44
      if ((int )*(sigdata->order + i) <= last_invalid) {
#line 45
        *(sigdata->order + i) = (unsigned char )sigdata->n_patterns;
#line 46
        found_some = 1;
      }
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (found_some) {
    {
#line 51
    tmp___0 = realloc((void *)sigdata->pattern, sizeof(*(sigdata->pattern)) * (unsigned long )(sigdata->n_patterns + 1));
#line 51
    new_pattern = (IT_PATTERN *)tmp___0;
    }
#line 52
    if (! new_pattern) {
#line 53
      return (-1);
    }
#line 55
    (new_pattern + sigdata->n_patterns)->n_rows = 64;
#line 56
    (new_pattern + sigdata->n_patterns)->n_entries = 0;
#line 57
    (new_pattern + sigdata->n_patterns)->entry = (IT_ENTRY *)((void *)0);
#line 58
    sigdata->pattern = new_pattern;
#line 59
    (sigdata->n_patterns) ++;
  }
#line 62
  return (0);
}
}
#line 384 "include/dumb.h"
DUH *dumb_read_it_quick(DUMBFILE *f ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itload.c"
DUH *dumb_load_it_quick(char const   *filename ) 
{ 
  DUH *duh ;
  DUMBFILE *f ;
  DUMBFILE *tmp ;

  {
  {
#line 32
  tmp = dumbfile_open(filename);
#line 32
  f = tmp;
  }
#line 34
  if (! f) {
#line 35
    return ((DUH *)((void *)0));
  }
  {
#line 37
  duh = dumb_read_it_quick(f);
#line 39
  dumbfile_close(f);
  }
#line 41
  return (duh);
}
}
#line 374 "include/dumb.h"
DUH *dumb_read_it(DUMBFILE *f ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread2.c"
DUH *dumb_read_it(DUMBFILE *f ) 
{ 
  DUH *duh ;
  DUH *tmp ;

  {
  {
#line 26
  tmp = dumb_read_it_quick(f);
#line 26
  duh = tmp;
#line 27
  dumb_it_do_initial_runthrough(duh);
  }
#line 28
  return (duh);
}
}
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x )  __asm__("__exp_finite")  ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y )  __asm__("__pow_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gamma)(double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) lgamma_r)(double  ,
                                                                                  int *__signgamp )  __asm__("__lgamma_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammaf)(float __d ) ;
#line 271
extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__)) lgammaf_r)(float  ,
                                                                                  int *__signgamp )  __asm__("__lgammaf_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammal)(long double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) lgammal_r)(long double  ,
                                                                                        int *__signgamp )  __asm__("__lgammal_r_finite")  ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) 
{ 
  int __local_signgam ;
  double tmp ;

  {
  {
#line 259
  __local_signgam = 0;
#line 260
  tmp = lgamma_r(__d, & __local_signgam);
  }
#line 260
  return ((double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 265
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float tmp ;

  {
  {
#line 268
  __local_signgam = 0;
#line 269
  tmp = lgammaf_r(__d, & __local_signgam);
  }
#line 269
  return ((float __attribute__((__gnu_inline__))  )tmp);
}
}
#line 275
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 275 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double tmp ;

  {
  {
#line 278
  __local_signgam = 0;
#line 279
  tmp = lgammal_r(__d, & __local_signgam);
  }
#line 279
  return ((long double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 427
extern double __gamma_r_finite(double  , int * ) ;
#line 428
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 428 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) 
{ 
  int __local_signgam ;
  double __res ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 430
  __local_signgam = 0;
#line 431
  tmp = __gamma_r_finite(__d, & __local_signgam);
#line 431
  __res = tmp;
  }
#line 432
  if (__local_signgam < 0) {
#line 432
    tmp___0 = - __res;
  } else {
#line 432
    tmp___0 = __res;
  }
#line 432
  return ((double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 434
extern float __gammaf_r_finite(float  , int * ) ;
#line 435
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 435 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float __res ;
  float tmp ;
  float tmp___0 ;

  {
  {
#line 437
  __local_signgam = 0;
#line 438
  tmp = __gammaf_r_finite(__d, & __local_signgam);
#line 438
  __res = tmp;
  }
#line 439
  if (__local_signgam < 0) {
#line 439
    tmp___0 = - __res;
  } else {
#line 439
    tmp___0 = __res;
  }
#line 439
  return ((float __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 442
extern long double __gammal_r_finite(long double  , int * ) ;
#line 443
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 443 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double __res ;
  long double tmp ;
  long double tmp___0 ;

  {
  {
#line 445
  __local_signgam = 0;
#line 449
  tmp = __gammal_r_finite(__d, & __local_signgam);
#line 449
  __res = tmp;
  }
#line 451
  if (__local_signgam < 0) {
#line 451
    tmp___0 = - __res;
  } else {
#line 451
    tmp___0 = __res;
  }
#line 451
  return ((long double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 351 "include/dumb.h"
int dumb_it_max_to_mix ;
#line 356
DUMB_IT_SIGDATA *duh_get_it_sigdata(DUH *duh ) ;
#line 357
DUH_SIGRENDERER *duh_encapsulate_it_sigrenderer(DUMB_IT_SIGRENDERER *it_sigrenderer ,
                                                int n_channels , long pos ) ;
#line 358
DUMB_IT_SIGRENDERER *duh_get_it_sigrenderer(DUH_SIGRENDERER *sigrenderer ) ;
#line 360
DUH_SIGRENDERER *dumb_it_start_at_order(DUH *duh , int n_channels , int startorder ) ;
#line 362
void dumb_it_set_loop_callback(DUMB_IT_SIGRENDERER *sigrenderer , int (*callback)(void *data ) ,
                               void *data ) ;
#line 363
void dumb_it_set_xm_speed_zero_callback(DUMB_IT_SIGRENDERER *sigrenderer , int (*callback)(void *data ) ,
                                        void *data ) ;
#line 364
void dumb_it_set_midi_callback(DUMB_IT_SIGRENDERER *sigrenderer , int (*callback)(void *data ,
                                                                                  int channel ,
                                                                                  unsigned char midi_byte ) ,
                               void *data ) ;
#line 366
int dumb_it_callback_terminate(void *data ) ;
#line 367
int dumb_it_callback_midi_block(void *data , int channel , unsigned char midi_byte ) ;
#line 389
long dumb_it_build_checkpoints(DUMB_IT_SIGDATA *sigdata ) ;
#line 462
void dumb_it_sr_get_channel_state(DUMB_IT_SIGRENDERER *sr , int channel , DUMB_IT_CHANNEL_STATE *state ) ;
#line 542
extern DUH_SIGRENDERER *duh_encapsulate_raw_sigrenderer(sigrenderer_t *vsigrenderer ,
                                                        DUH_SIGTYPE_DESC *desc , int n_channels ,
                                                        long pos ) ;
#line 543
extern sigrenderer_t *duh_get_raw_sigrenderer(DUH_SIGRENDERER *sigrenderer , long type ) ;
#line 574
void dumb_record_click(DUMB_CLICK_REMOVER *cr , long pos , sample_t step ) ;
#line 579
DUMB_CLICK_REMOVER **dumb_create_click_remover_array(int n ) ;
#line 582
void dumb_remove_clicks_array(int n , DUMB_CLICK_REMOVER **cr , sample_t **samples ,
                              long length , float halflife ) ;
#line 583
void dumb_click_remover_get_offset_array(int n , DUMB_CLICK_REMOVER **cr , sample_t *offset ) ;
#line 584
void dumb_destroy_click_remover_array(int n , DUMB_CLICK_REMOVER **cr ) ;
#line 655
extern void dumb_reset_resampler_n(int n , DUMB_RESAMPLER *resampler , void *src ,
                                   int src_channels , long pos , long start , long end ) ;
#line 657
extern long dumb_resample_n_1_1(int n , DUMB_RESAMPLER *resampler , sample_t *dst ,
                                long dst_size , float volume , float delta ) ;
#line 658
extern long dumb_resample_n_1_2(int n , DUMB_RESAMPLER *resampler , sample_t *dst ,
                                long dst_size , float volume_left , float volume_right ,
                                float delta ) ;
#line 659
extern long dumb_resample_n_2_1(int n , DUMB_RESAMPLER *resampler , sample_t *dst ,
                                long dst_size , float volume_left , float volume_right ,
                                float delta ) ;
#line 660
extern long dumb_resample_n_2_2(int n , DUMB_RESAMPLER *resampler , sample_t *dst ,
                                long dst_size , float volume_left , float volume_right ,
                                float delta ) ;
#line 661
extern void dumb_resample_get_current_sample_n_1_1(int n , DUMB_RESAMPLER *resampler ,
                                                   float volume , sample_t *dst ) ;
#line 662
extern void dumb_resample_get_current_sample_n_1_2(int n , DUMB_RESAMPLER *resampler ,
                                                   float volume_left , float volume_right ,
                                                   sample_t *dst ) ;
#line 663
extern void dumb_resample_get_current_sample_n_2_1(int n , DUMB_RESAMPLER *resampler ,
                                                   float volume_left , float volume_right ,
                                                   sample_t *dst ) ;
#line 664
extern void dumb_resample_get_current_sample_n_2_2(int n , DUMB_RESAMPLER *resampler ,
                                                   float volume_left , float volume_right ,
                                                   sample_t *dst ) ;
#line 679
void duh_set_length(DUH *duh , long length ) ;
#line 655 "include/internal/it.h"
void _dumb_it_end_sigrenderer(sigrenderer_t *vsigrenderer ) ;
#line 656
void _dumb_it_unload_sigdata(sigdata_t *vsigdata ) ;
#line 658
DUH_SIGTYPE_DESC _dumb_sigtype_it ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static IT_PLAYING *dup_playing(IT_PLAYING *src , IT_CHANNEL *dstchannel , IT_CHANNEL *srcchannel ) 
{ 
  IT_PLAYING *dst ;
  void *tmp ;

  {
#line 32
  if (! src) {
#line 32
    return ((IT_PLAYING *)((void *)0));
  }
  {
#line 34
  tmp = malloc(sizeof(*dst));
#line 34
  dst = (IT_PLAYING *)tmp;
  }
#line 35
  if (! dst) {
#line 35
    return ((IT_PLAYING *)((void *)0));
  }
#line 37
  dst->flags = src->flags;
#line 40
  dst->channel = dstchannel + (src->channel - srcchannel);
#line 41
  dst->sample = src->sample;
#line 42
  dst->instrument = src->instrument;
#line 43
  dst->env_instrument = src->env_instrument;
#line 45
  dst->sampnum = src->sampnum;
#line 46
  dst->instnum = src->instnum;
#line 48
  dst->channel_volume = src->channel_volume;
#line 50
  dst->volume = src->volume;
#line 51
  dst->pan = src->pan;
#line 53
  dst->note = src->note;
#line 55
  dst->filter_cutoff = src->filter_cutoff;
#line 56
  dst->filter_resonance = src->filter_resonance;
#line 58
  dst->true_filter_cutoff = src->true_filter_cutoff;
#line 59
  dst->true_filter_resonance = src->true_filter_resonance;
#line 61
  dst->vibrato_speed = src->vibrato_speed;
#line 62
  dst->vibrato_depth = src->vibrato_depth;
#line 63
  dst->vibrato_n = src->vibrato_n;
#line 64
  dst->vibrato_time = src->vibrato_time;
#line 66
  dst->tremolo_speed = src->tremolo_speed;
#line 67
  dst->tremolo_depth = src->tremolo_depth;
#line 68
  dst->tremolo_time = src->tremolo_time;
#line 70
  dst->sample_vibrato_time = src->sample_vibrato_time;
#line 71
  dst->sample_vibrato_depth = src->sample_vibrato_depth;
#line 73
  dst->slide = src->slide;
#line 74
  dst->delta = src->delta;
#line 76
  dst->volume_envelope = src->volume_envelope;
#line 77
  dst->pan_envelope = src->pan_envelope;
#line 78
  dst->pitch_envelope = src->pitch_envelope;
#line 80
  dst->fadeoutcount = src->fadeoutcount;
#line 82
  dst->filter_state[0] = src->filter_state[0];
#line 83
  dst->filter_state[1] = src->filter_state[1];
#line 85
  dst->resampler = src->resampler;
#line 86
  dst->resampler.pickup_data = (void *)dst;
#line 87
  dst->time_lost = src->time_lost;
#line 89
  return (dst);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void dup_channel(IT_CHANNEL *dst , IT_CHANNEL *src ) 
{ 


  {
  {
#line 96
  dst->flags = src->flags;
#line 98
  dst->volume = src->volume;
#line 99
  dst->volslide = src->volslide;
#line 100
  dst->xm_volslide = src->xm_volslide;
#line 101
  dst->panslide = src->panslide;
#line 103
  dst->pan = src->pan;
#line 104
  dst->truepan = src->truepan;
#line 106
  dst->channelvolume = src->channelvolume;
#line 107
  dst->channelvolslide = src->channelvolslide;
#line 109
  dst->instrument = src->instrument;
#line 110
  dst->note = src->note;
#line 112
  dst->SFmacro = src->SFmacro;
#line 114
  dst->filter_cutoff = src->filter_cutoff;
#line 115
  dst->filter_resonance = src->filter_resonance;
#line 117
  dst->key_off_count = src->key_off_count;
#line 118
  dst->note_cut_count = src->note_cut_count;
#line 119
  dst->note_delay_count = src->note_delay_count;
#line 120
  dst->note_delay_entry = src->note_delay_entry;
#line 122
  dst->arpeggio = src->arpeggio;
#line 123
  dst->retrig = src->retrig;
#line 124
  dst->xm_retrig = src->xm_retrig;
#line 125
  dst->retrig_tick = src->retrig_tick;
#line 127
  dst->tremor_time = src->tremor_time;
#line 129
  dst->portamento = src->portamento;
#line 130
  dst->toneporta = src->toneporta;
#line 131
  dst->destnote = src->destnote;
#line 133
  dst->sample = src->sample;
#line 134
  dst->truenote = src->truenote;
#line 136
  dst->midi_state = src->midi_state;
#line 138
  dst->lastvolslide = src->lastvolslide;
#line 139
  dst->lastDKL = src->lastDKL;
#line 140
  dst->lastEF = src->lastEF;
#line 141
  dst->lastG = src->lastG;
#line 142
  dst->lastHspeed = src->lastHspeed;
#line 143
  dst->lastHdepth = src->lastHdepth;
#line 144
  dst->lastRspeed = src->lastRspeed;
#line 145
  dst->lastRdepth = src->lastRdepth;
#line 146
  dst->lastI = src->lastI;
#line 147
  dst->lastJ = src->lastJ;
#line 148
  dst->lastN = src->lastN;
#line 149
  dst->lastO = src->lastO;
#line 150
  dst->high_offset = src->high_offset;
#line 151
  dst->lastP = src->lastP;
#line 152
  dst->lastQ = src->lastQ;
#line 153
  dst->lastS = src->lastS;
#line 154
  dst->pat_loop_row = src->pat_loop_row;
#line 155
  dst->pat_loop_count = src->pat_loop_count;
#line 156
  dst->pat_loop_end_row = src->pat_loop_end_row;
#line 157
  dst->lastW = src->lastW;
#line 159
  dst->xm_lastE1 = src->xm_lastE1;
#line 160
  dst->xm_lastE2 = src->xm_lastE2;
#line 161
  dst->xm_lastEA = src->xm_lastEA;
#line 162
  dst->xm_lastEB = src->xm_lastEB;
#line 163
  dst->xm_lastX1 = src->xm_lastX1;
#line 164
  dst->xm_lastX2 = src->xm_lastX2;
#line 166
  dst->playing = dup_playing(src->playing, dst, src);
  }
#line 167
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static DUMB_IT_SIGRENDERER *dup_sigrenderer(DUMB_IT_SIGRENDERER *src , int n_channels ,
                                            IT_CALLBACKS *callbacks ) 
{ 
  DUMB_IT_SIGRENDERER *dst ;
  int i ;
  void *tmp ;

  {
#line 179
  if (! src) {
#line 180
    if (callbacks) {
      {
#line 180
      free((void *)callbacks);
      }
    }
#line 181
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 184
  tmp = malloc(sizeof(*dst));
#line 184
  dst = (DUMB_IT_SIGRENDERER *)tmp;
  }
#line 185
  if (! dst) {
#line 186
    if (callbacks) {
      {
#line 186
      free((void *)callbacks);
      }
    }
#line 187
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
#line 190
  dst->sigdata = src->sigdata;
#line 192
  dst->n_channels = n_channels;
#line 194
  dst->globalvolume = src->globalvolume;
#line 195
  dst->globalvolslide = src->globalvolslide;
#line 197
  dst->tempo = src->tempo;
#line 198
  dst->temposlide = src->temposlide;
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < 64)) {
#line 200
      goto while_break;
    }
    {
#line 201
    dup_channel(& dst->channel[i], & src->channel[i]);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! (i < 192)) {
#line 203
      goto while_break___0;
    }
    {
#line 204
    dst->playing[i] = dup_playing(src->playing[i], dst->channel, src->channel);
#line 203
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 206
  dst->tick = src->tick;
#line 207
  dst->speed = src->speed;
#line 208
  dst->rowcount = src->rowcount;
#line 210
  dst->order = src->order;
#line 211
  dst->row = src->row;
#line 212
  dst->processorder = src->processorder;
#line 213
  dst->processrow = src->processrow;
#line 214
  dst->breakrow = src->breakrow;
#line 215
  dst->pat_loop_row = src->pat_loop_row;
#line 217
  dst->n_rows = src->n_rows;
#line 219
  dst->entry_start = src->entry_start;
#line 220
  dst->entry = src->entry;
#line 221
  dst->entry_end = src->entry_end;
#line 223
  dst->time_left = src->time_left;
#line 224
  dst->sub_time_left = src->sub_time_left;
#line 226
  dst->click_remover = (DUMB_CLICK_REMOVER **)((void *)0);
#line 228
  dst->callbacks = callbacks;
#line 230
  return (dst);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static IT_MIDI default_midi  =    {{{(unsigned char)240, (unsigned char)240, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0}, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}}, {(unsigned char)4, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    {(unsigned short)8, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, {{(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0}, {(unsigned char)240, (unsigned char)240,
                                               (unsigned char)1, (unsigned char)8,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)16, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)24,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)32, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)40,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)48, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)56,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)64, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)72,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)80, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)88,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)96, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)104,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)112, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)120,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
    {(unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4,
     (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4,
     (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4,
     (unsigned char)4, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0}};
#line 416 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_reset_filter_state(IT_FILTER_STATE *state ) 
{ 


  {
#line 418
  state->currsample = 0;
#line 419
  state->prevsample = 0;
#line 420
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_filter(DUMB_CLICK_REMOVER *cr , IT_FILTER_STATE *state , sample_t *dst ,
                      long pos , sample_t *src , long size , int step , int sampfreq ,
                      int cutoff , int resonance ) 
{ 
  sample_t currsample ;
  sample_t prevsample ;
  float a ;
  float b ;
  float c ;
  long datasize ;
  float inv_angle ;
  double tmp ;
  float loss ;
  double tmp___0 ;
  float d ;
  float e ;
  int ai ;
  int bi ;
  int ci ;
  int i ;
  sample_t startstep ;
  sample_t newsample ;
  sample_t endstep ;

  {
  {
#line 433
  currsample = state->currsample;
#line 434
  prevsample = state->prevsample;
#line 441
  tmp = pow(0.5, 0.25 + (double )cutoff * (1.0 / (double )(24 << 8)));
#line 441
  inv_angle = (float )(((double )sampfreq * tmp) * (1.0 / (((double )2 * 3.14159265358979323846) * 110.0)));
#line 442
  tmp___0 = exp((double )resonance * ((- 2.30258509299 * 1.2) / 128.0));
#line 442
  loss = (float )tmp___0;
#line 449
  d = (1.0f - loss) / inv_angle;
  }
#line 450
  if (d > 2.0f) {
#line 450
    d = 2.0f;
  }
#line 451
  d = (loss - d) * inv_angle;
#line 452
  e = inv_angle * inv_angle;
#line 453
  a = 1.0f / ((1.0f + d) + e);
#line 454
  c = - e * a;
#line 455
  b = (1.0f - a) - c;
#line 463
  dst += pos * (long )step;
#line 464
  datasize = size * (long )step;
#line 471
  ai = (int )(a * (float )(1 << 28));
#line 472
  bi = (int )(b * (float )(1 << 28));
#line 473
  ci = (int )(c * (float )(1 << 28));
#line 476
  if (cr) {
    {
#line 477
    startstep = ((int )((long long )(*(src + 0) << 4) * (long long )ai >> 32) + (int )((long long )(currsample << 4) * (long long )bi >> 32)) + (int )((long long )(prevsample << 4) * (long long )ci >> 32);
#line 478
    dumb_record_click(cr, pos, startstep);
    }
  }
#line 481
  i = 0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((long )i < datasize)) {
#line 481
      goto while_break;
    }
#line 483
    newsample = ((int )((long long )(*(src + i) << 4) * (long long )ai >> 32) + (int )((long long )(currsample << 4) * (long long )bi >> 32)) + (int )((long long )(prevsample << 4) * (long long )ci >> 32);
#line 484
    prevsample = currsample;
#line 485
    currsample = newsample;
#line 487
    *(dst + i) += currsample;
#line 481
    i += step;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  if (cr) {
    {
#line 491
    endstep = ((int )((long long )(*(src + datasize) << 4) * (long long )ai >> 32) + (int )((long long )(currsample << 4) * (long long )bi >> 32)) + (int )((long long )(prevsample << 4) * (long long )ci >> 32);
#line 492
    dumb_record_click(cr, pos + size, - endstep);
    }
  }
#line 530
  state->currsample = currsample;
#line 531
  state->prevsample = prevsample;
#line 532
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static signed char it_sine[256]  = 
#line 538
  {      (signed char)0,      (signed char)2,      (signed char)3,      (signed char)5, 
        (signed char)6,      (signed char)8,      (signed char)9,      (signed char)11, 
        (signed char)12,      (signed char)14,      (signed char)16,      (signed char)17, 
        (signed char)19,      (signed char)20,      (signed char)22,      (signed char)23, 
        (signed char)24,      (signed char)26,      (signed char)27,      (signed char)29, 
        (signed char)30,      (signed char)32,      (signed char)33,      (signed char)34, 
        (signed char)36,      (signed char)37,      (signed char)38,      (signed char)39, 
        (signed char)41,      (signed char)42,      (signed char)43,      (signed char)44, 
        (signed char)45,      (signed char)46,      (signed char)47,      (signed char)48, 
        (signed char)49,      (signed char)50,      (signed char)51,      (signed char)52, 
        (signed char)53,      (signed char)54,      (signed char)55,      (signed char)56, 
        (signed char)56,      (signed char)57,      (signed char)58,      (signed char)59, 
        (signed char)59,      (signed char)60,      (signed char)60,      (signed char)61, 
        (signed char)61,      (signed char)62,      (signed char)62,      (signed char)62, 
        (signed char)63,      (signed char)63,      (signed char)63,      (signed char)64, 
        (signed char)64,      (signed char)64,      (signed char)64,      (signed char)64, 
        (signed char)64,      (signed char)64,      (signed char)64,      (signed char)64, 
        (signed char)64,      (signed char)64,      (signed char)63,      (signed char)63, 
        (signed char)63,      (signed char)62,      (signed char)62,      (signed char)62, 
        (signed char)61,      (signed char)61,      (signed char)60,      (signed char)60, 
        (signed char)59,      (signed char)59,      (signed char)58,      (signed char)57, 
        (signed char)56,      (signed char)56,      (signed char)55,      (signed char)54, 
        (signed char)53,      (signed char)52,      (signed char)51,      (signed char)50, 
        (signed char)49,      (signed char)48,      (signed char)47,      (signed char)46, 
        (signed char)45,      (signed char)44,      (signed char)43,      (signed char)42, 
        (signed char)41,      (signed char)39,      (signed char)38,      (signed char)37, 
        (signed char)36,      (signed char)34,      (signed char)33,      (signed char)32, 
        (signed char)30,      (signed char)29,      (signed char)27,      (signed char)26, 
        (signed char)24,      (signed char)23,      (signed char)22,      (signed char)20, 
        (signed char)19,      (signed char)17,      (signed char)16,      (signed char)14, 
        (signed char)12,      (signed char)11,      (signed char)9,      (signed char)8, 
        (signed char)6,      (signed char)5,      (signed char)3,      (signed char)2, 
        (signed char)0,      (signed char)-2,      (signed char)-3,      (signed char)-5, 
        (signed char)-6,      (signed char)-8,      (signed char)-9,      (signed char)-11, 
        (signed char)-12,      (signed char)-14,      (signed char)-16,      (signed char)-17, 
        (signed char)-19,      (signed char)-20,      (signed char)-22,      (signed char)-23, 
        (signed char)-24,      (signed char)-26,      (signed char)-27,      (signed char)-29, 
        (signed char)-30,      (signed char)-32,      (signed char)-33,      (signed char)-34, 
        (signed char)-36,      (signed char)-37,      (signed char)-38,      (signed char)-39, 
        (signed char)-41,      (signed char)-42,      (signed char)-43,      (signed char)-44, 
        (signed char)-45,      (signed char)-46,      (signed char)-47,      (signed char)-48, 
        (signed char)-49,      (signed char)-50,      (signed char)-51,      (signed char)-52, 
        (signed char)-53,      (signed char)-54,      (signed char)-55,      (signed char)-56, 
        (signed char)-56,      (signed char)-57,      (signed char)-58,      (signed char)-59, 
        (signed char)-59,      (signed char)-60,      (signed char)-60,      (signed char)-61, 
        (signed char)-61,      (signed char)-62,      (signed char)-62,      (signed char)-62, 
        (signed char)-63,      (signed char)-63,      (signed char)-63,      (signed char)-64, 
        (signed char)-64,      (signed char)-64,      (signed char)-64,      (signed char)-64, 
        (signed char)-64,      (signed char)-64,      (signed char)-64,      (signed char)-64, 
        (signed char)-64,      (signed char)-64,      (signed char)-63,      (signed char)-63, 
        (signed char)-63,      (signed char)-62,      (signed char)-62,      (signed char)-62, 
        (signed char)-61,      (signed char)-61,      (signed char)-60,      (signed char)-60, 
        (signed char)-59,      (signed char)-59,      (signed char)-58,      (signed char)-57, 
        (signed char)-56,      (signed char)-56,      (signed char)-55,      (signed char)-54, 
        (signed char)-53,      (signed char)-52,      (signed char)-51,      (signed char)-50, 
        (signed char)-49,      (signed char)-48,      (signed char)-47,      (signed char)-46, 
        (signed char)-45,      (signed char)-44,      (signed char)-43,      (signed char)-42, 
        (signed char)-41,      (signed char)-39,      (signed char)-38,      (signed char)-37, 
        (signed char)-36,      (signed char)-34,      (signed char)-33,      (signed char)-32, 
        (signed char)-30,      (signed char)-29,      (signed char)-27,      (signed char)-26, 
        (signed char)-24,      (signed char)-23,      (signed char)-22,      (signed char)-20, 
        (signed char)-19,      (signed char)-17,      (signed char)-16,      (signed char)-14, 
        (signed char)-12,      (signed char)-11,      (signed char)-9,      (signed char)-8, 
        (signed char)-6,      (signed char)-5,      (signed char)-3,      (signed char)-2};
#line 614 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void reset_tick_counts(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;

  {
#line 618
  i = 0;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (i < 64)) {
#line 618
      goto while_break;
    }
#line 619
    channel = & sigrenderer->channel[i];
#line 620
    channel->key_off_count = (unsigned char)0;
#line 621
    channel->note_cut_count = (unsigned char)0;
#line 622
    channel->note_delay_count = (unsigned char)0;
#line 618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 624
  return;
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void reset_effects(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;

  {
#line 632
  sigrenderer->globalvolslide = (signed char)0;
#line 633
  sigrenderer->temposlide = (signed char)0;
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < 64)) {
#line 635
      goto while_break;
    }
#line 636
    channel = & sigrenderer->channel[i];
#line 637
    channel->volslide = (signed char)0;
#line 638
    channel->xm_volslide = (signed char)0;
#line 639
    channel->panslide = (signed char)0;
#line 640
    channel->channelvolslide = (signed char)0;
#line 641
    channel->arpeggio = 0;
#line 642
    channel->retrig = (unsigned char)0;
#line 643
    if (channel->xm_retrig) {
#line 644
      channel->xm_retrig = (unsigned char)0;
#line 645
      channel->retrig_tick = 0;
    }
#line 647
    channel->tremor_time = (unsigned char )((int )channel->tremor_time & 127);
#line 648
    channel->portamento = 0;
#line 649
    channel->toneporta = 0;
#line 650
    if (channel->playing) {
#line 651
      (channel->playing)->vibrato_n = (unsigned char)0;
#line 652
      (channel->playing)->tremolo_speed = (unsigned char)0;
#line 653
      (channel->playing)->tremolo_depth = (unsigned char)0;
    }
#line 635
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return;
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_tremor(IT_CHANNEL *channel ) 
{ 


  {
#line 662
  if ((int )channel->tremor_time & 128) {
#line 662
    if (channel->playing) {
#line 663
      if ((int )channel->tremor_time == 128) {
#line 664
        channel->tremor_time = (unsigned char )(((int )channel->lastI >> 4) | 192);
      } else
#line 665
      if ((int )channel->tremor_time == 192) {
#line 666
        channel->tremor_time = (unsigned char )(((int )channel->lastI & 15) | 128);
      } else {
#line 668
        channel->tremor_time = (unsigned char )((int )channel->tremor_time - 1);
      }
    }
  }
#line 670
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_pickup_loop(DUMB_RESAMPLER *resampler , void *data ) 
{ 


  {
#line 676
  resampler->pos -= resampler->end - resampler->start;
#line 677
  ((IT_PLAYING *)data)->time_lost += resampler->end - resampler->start;
#line 678
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_pickup_pingpong_loop(DUMB_RESAMPLER *resampler , void *data ) 
{ 


  {
#line 684
  if (resampler->dir < 0) {
#line 685
    resampler->pos = ((resampler->start << 1) - 1L) - resampler->pos;
#line 686
    resampler->subpos ^= 65535;
#line 687
    resampler->dir = 1;
#line 688
    ((IT_PLAYING *)data)->time_lost += (resampler->end - resampler->start) << 1;
  } else {
#line 690
    resampler->pos = ((resampler->end << 1) - 1L) - resampler->pos;
#line 691
    resampler->subpos ^= 65535;
#line 692
    resampler->dir = -1;
  }
#line 694
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_pickup_stop_at_end(DUMB_RESAMPLER *resampler , void *data ) 
{ 


  {
#line 702
  if (resampler->dir < 0) {
#line 703
    resampler->pos = ((resampler->start << 1) - 1L) - resampler->pos;
#line 704
    resampler->subpos ^= 65535;
#line 710
    resampler->dir = 1;
  } else {
#line 712
    resampler->dir = 0;
  }
#line 713
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_playing_update_resamplers(IT_PLAYING *playing ) 
{ 


  {
#line 719
  if ((int )(playing->sample)->flags & 32) {
#line 719
    if (! (playing->flags & 2)) {
#line 720
      playing->resampler.start = (playing->sample)->sus_loop_start;
#line 721
      playing->resampler.end = (playing->sample)->sus_loop_end;
#line 722
      if ((int )(playing->sample)->flags & 128) {
#line 723
        playing->resampler.pickup = & it_pickup_pingpong_loop;
      } else {
#line 725
        playing->resampler.pickup = & it_pickup_loop;
      }
    } else {
#line 719
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 726
  if ((int )(playing->sample)->flags & 16) {
#line 727
    playing->resampler.start = (playing->sample)->loop_start;
#line 728
    playing->resampler.end = (playing->sample)->loop_end;
#line 729
    if ((int )(playing->sample)->flags & 64) {
#line 730
      playing->resampler.pickup = & it_pickup_pingpong_loop;
    } else {
#line 732
      playing->resampler.pickup = & it_pickup_loop;
    }
  } else {
#line 734
    if ((int )(playing->sample)->flags & 32) {
#line 735
      playing->resampler.start = (playing->sample)->sus_loop_start;
    } else {
#line 737
      playing->resampler.start = 0L;
    }
#line 738
    playing->resampler.end = (playing->sample)->length;
#line 739
    playing->resampler.pickup = & it_pickup_stop_at_end;
  }
#line 742
  return;
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_playing_reset_resamplers(IT_PLAYING *playing , long pos ) 
{ 
  int bits ;
  int tmp ;
  int channels ;
  int tmp___0 ;

  {
#line 749
  if ((int )(playing->sample)->flags & 2) {
#line 749
    tmp = 16;
  } else {
#line 749
    tmp = 8;
  }
#line 749
  bits = tmp;
#line 750
  if ((int )(playing->sample)->flags & 4) {
#line 750
    tmp___0 = 2;
  } else {
#line 750
    tmp___0 = 1;
  }
  {
#line 750
  channels = tmp___0;
#line 751
  dumb_reset_resampler_n(bits, & playing->resampler, (playing->sample)->data, channels,
                         pos, 0L, 0L);
#line 752
  playing->resampler.pickup_data = (void *)playing;
#line 753
  playing->time_lost = 0L;
#line 754
  playing->flags &= -9;
#line 755
  it_playing_update_resamplers(playing);
  }
#line 756
  return;
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_retrig(IT_CHANNEL *channel ) 
{ 


  {
#line 762
  if (channel->xm_retrig) {
#line 763
    (channel->retrig_tick) --;
#line 764
    if (channel->retrig_tick <= 0) {
#line 765
      if (channel->playing) {
        {
#line 765
        it_playing_reset_resamplers(channel->playing, 0L);
        }
      }
#line 766
      channel->retrig_tick = (int )channel->xm_retrig;
    }
  } else
#line 768
  if ((int )channel->retrig & 15) {
#line 769
    (channel->retrig_tick) --;
#line 770
    if (channel->retrig_tick <= 0) {
#line 771
      if (! ((int )channel->retrig < 16)) {
#line 772
        if ((int )channel->retrig < 32) {
#line 773
          channel->volume = (unsigned char )((int )channel->volume - 1);
#line 774
          if ((int )channel->volume > 64) {
#line 774
            channel->volume = (unsigned char)0;
          }
        } else
#line 775
        if ((int )channel->retrig < 48) {
#line 776
          channel->volume = (unsigned char )((int )channel->volume - 2);
#line 777
          if ((int )channel->volume > 64) {
#line 777
            channel->volume = (unsigned char)0;
          }
        } else
#line 778
        if ((int )channel->retrig < 64) {
#line 779
          channel->volume = (unsigned char )((int )channel->volume - 4);
#line 780
          if ((int )channel->volume > 64) {
#line 780
            channel->volume = (unsigned char)0;
          }
        } else
#line 781
        if ((int )channel->retrig < 80) {
#line 782
          channel->volume = (unsigned char )((int )channel->volume - 8);
#line 783
          if ((int )channel->volume > 64) {
#line 783
            channel->volume = (unsigned char)0;
          }
        } else
#line 784
        if ((int )channel->retrig < 96) {
#line 785
          channel->volume = (unsigned char )((int )channel->volume - 16);
#line 786
          if ((int )channel->volume > 64) {
#line 786
            channel->volume = (unsigned char)0;
          }
        } else
#line 787
        if ((int )channel->retrig < 112) {
#line 788
          channel->volume = (unsigned char )((int )channel->volume << 1);
#line 789
          channel->volume = (unsigned char )((int )channel->volume / 3);
        } else
#line 790
        if ((int )channel->retrig < 128) {
#line 791
          channel->volume = (unsigned char )((int )channel->volume >> 1);
        } else
#line 792
        if (! ((int )channel->retrig < 144)) {
#line 793
          if ((int )channel->retrig < 160) {
#line 794
            channel->volume = (unsigned char )((int )channel->volume + 1);
#line 795
            if ((int )channel->volume > 64) {
#line 795
              channel->volume = (unsigned char)64;
            }
          } else
#line 796
          if ((int )channel->retrig < 176) {
#line 797
            channel->volume = (unsigned char )((int )channel->volume + 2);
#line 798
            if ((int )channel->volume > 64) {
#line 798
              channel->volume = (unsigned char)64;
            }
          } else
#line 799
          if ((int )channel->retrig < 192) {
#line 800
            channel->volume = (unsigned char )((int )channel->volume + 4);
#line 801
            if ((int )channel->volume > 64) {
#line 801
              channel->volume = (unsigned char)64;
            }
          } else
#line 802
          if ((int )channel->retrig < 208) {
#line 803
            channel->volume = (unsigned char )((int )channel->volume + 8);
#line 804
            if ((int )channel->volume > 64) {
#line 804
              channel->volume = (unsigned char)64;
            }
          } else
#line 805
          if ((int )channel->retrig < 224) {
#line 806
            channel->volume = (unsigned char )((int )channel->volume + 16);
#line 807
            if ((int )channel->volume > 64) {
#line 807
              channel->volume = (unsigned char)64;
            }
          } else
#line 808
          if ((int )channel->retrig < 240) {
#line 809
            channel->volume = (unsigned char )((int )channel->volume * 3);
#line 810
            channel->volume = (unsigned char )((int )channel->volume >> 1);
#line 811
            if ((int )channel->volume > 64) {
#line 811
              channel->volume = (unsigned char)64;
            }
          } else {
#line 813
            channel->volume = (unsigned char )((int )channel->volume << 1);
#line 814
            if ((int )channel->volume > 64) {
#line 814
              channel->volume = (unsigned char)64;
            }
          }
        }
      }
#line 816
      if (channel->playing) {
        {
#line 816
        it_playing_reset_resamplers(channel->playing, 0L);
        }
      }
#line 817
      channel->retrig_tick = (int )channel->retrig & 15;
    }
  }
#line 820
  return;
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_smooth_effects(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;
  IT_PLAYING *playing ;

  {
#line 828
  i = 0;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! (i < 64)) {
#line 828
      goto while_break;
    }
#line 829
    channel = & sigrenderer->channel[i];
#line 830
    playing = channel->playing;
#line 832
    if (playing) {
#line 833
      playing->vibrato_time = (unsigned char )((int )playing->vibrato_time + (int )playing->vibrato_n * ((int )playing->vibrato_speed << 2));
#line 835
      playing->tremolo_time = (unsigned char )((int )playing->tremolo_time + ((int )playing->tremolo_speed << 2));
    }
#line 828
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  return;
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_effects(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;
  IT_PLAYING *playing ;
  int tmp___0 ;
  int tmp___1 ;
  int currpitch ;
  int destpitch ;
  float amiga_multiplier ;
  float deltanote ;
  double tmp___2 ;
  float deltaslid ;
  float destdelta ;
  double tmp___3 ;

  {
#line 846
  if (sigrenderer->globalvolslide) {
#line 847
    sigrenderer->globalvolume = (unsigned char )((int )sigrenderer->globalvolume + (int )sigrenderer->globalvolslide);
#line 848
    if ((int )sigrenderer->globalvolume > 128) {
#line 849
      if ((int )sigrenderer->globalvolslide >= 0) {
#line 850
        sigrenderer->globalvolume = (unsigned char)128;
      } else {
#line 852
        sigrenderer->globalvolume = (unsigned char)0;
      }
    }
  }
#line 856
  if (sigrenderer->temposlide) {
#line 857
    sigrenderer->tempo = (unsigned char )((int )sigrenderer->tempo + (int )sigrenderer->temposlide);
#line 858
    if ((int )sigrenderer->tempo < 32) {
#line 859
      if ((int )sigrenderer->temposlide >= 0) {
#line 860
        sigrenderer->tempo = (unsigned char)255;
      } else {
#line 862
        sigrenderer->tempo = (unsigned char)32;
      }
    }
  }
#line 866
  i = 0;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (i < 64)) {
#line 866
      goto while_break;
    }
#line 867
    channel = & sigrenderer->channel[i];
#line 868
    playing = channel->playing;
#line 870
    if (channel->xm_volslide) {
#line 871
      channel->volume = (unsigned char )((int )channel->volume + (int )channel->xm_volslide);
#line 872
      if ((int )channel->volume > 64) {
#line 873
        if ((int )channel->xm_volslide >= 0) {
#line 874
          channel->volume = (unsigned char)64;
        } else {
#line 876
          channel->volume = (unsigned char)0;
        }
      }
    }
#line 880
    if (channel->volslide) {
#line 881
      channel->volume = (unsigned char )((int )channel->volume + (int )channel->volslide);
#line 882
      if ((int )channel->volume > 64) {
#line 883
        if ((int )channel->volslide >= 0) {
#line 884
          channel->volume = (unsigned char)64;
        } else {
#line 886
          channel->volume = (unsigned char)0;
        }
      }
    }
#line 890
    if (channel->panslide) {
#line 890
      if (! ((int )channel->pan > 64)) {
#line 891
        if ((sigrenderer->sigdata)->flags & 64) {
#line 892
          if ((int )channel->panslide == -128) {
#line 893
            channel->truepan = (unsigned short)32;
          } else {
#line 895
            if ((int )channel->truepan + (int )channel->panslide * 64 < 16352) {
#line 895
              tmp___1 = (int )channel->truepan + (int )channel->panslide * 64;
            } else {
#line 895
              tmp___1 = 16352;
            }
#line 895
            if (32 > tmp___1) {
#line 895
              channel->truepan = (unsigned short)32;
            } else {
#line 895
              if ((int )channel->truepan + (int )channel->panslide * 64 < 16352) {
#line 895
                tmp___0 = (int )channel->truepan + (int )channel->panslide * 64;
              } else {
#line 895
                tmp___0 = 16352;
              }
#line 895
              channel->truepan = (unsigned short )tmp___0;
            }
          }
        } else {
#line 897
          channel->pan = (unsigned char )((int )channel->pan + (int )channel->panslide);
#line 898
          if ((int )channel->pan > 64) {
#line 899
            if ((int )channel->panslide >= 0) {
#line 900
              channel->pan = (unsigned char)64;
            } else {
#line 902
              channel->pan = (unsigned char)0;
            }
          }
#line 904
          channel->truepan = (unsigned short )((int )channel->pan << 8);
        }
      }
    }
#line 908
    if (channel->channelvolslide) {
#line 909
      channel->channelvolume = (unsigned char )((int )channel->channelvolume + (int )channel->channelvolslide);
#line 910
      if ((int )channel->channelvolume > 64) {
#line 911
        if ((int )channel->channelvolslide >= 0) {
#line 912
          channel->channelvolume = (unsigned char)64;
        } else {
#line 914
          channel->channelvolume = (unsigned char)0;
        }
      }
#line 916
      if (channel->playing) {
#line 917
        (channel->playing)->channel_volume = channel->channelvolume;
      }
    }
    {
#line 920
    update_tremor(channel);
#line 922
    channel->arpeggio = (channel->arpeggio << 4) | (channel->arpeggio >> 8);
#line 923
    channel->arpeggio &= 4095;
#line 925
    update_retrig(channel);
    }
#line 927
    if (playing) {
#line 928
      playing->slide += channel->portamento;
#line 930
      if ((sigrenderer->sigdata)->flags & 8) {
#line 931
        if (channel->toneporta) {
#line 931
          if ((int )channel->destnote < 120) {
#line 932
            currpitch = (((int )playing->note - 60) << 8) + playing->slide;
#line 933
            destpitch = ((int )channel->destnote - 60) << 8;
#line 934
            if (currpitch > destpitch) {
#line 935
              currpitch -= channel->toneporta;
#line 936
              if (currpitch < destpitch) {
#line 937
                currpitch = destpitch;
#line 938
                channel->destnote = (unsigned char)255;
              }
            } else
#line 940
            if (currpitch < destpitch) {
#line 941
              currpitch += channel->toneporta;
#line 942
              if (currpitch > destpitch) {
#line 943
                currpitch = destpitch;
#line 944
                channel->destnote = (unsigned char)255;
              }
            }
#line 947
            playing->slide = currpitch - (((int )playing->note - 60) << 8);
          }
        }
      } else
#line 950
      if (channel->toneporta) {
#line 950
        if ((int )channel->destnote < 120) {
          {
#line 951
          amiga_multiplier = (float )(playing->sample)->C5_speed * (1.0f / (float )(8.0 * 7159090.5));
#line 953
          tmp___2 = pow(1.059463094359295309843105314939748495817, (double )(60 - (int )playing->note));
#line 953
          deltanote = (float )tmp___2;
#line 956
          deltaslid = deltanote - (float )playing->slide * amiga_multiplier;
#line 958
          tmp___3 = pow(1.059463094359295309843105314939748495817, (double )(60 - (int )channel->destnote));
#line 958
          destdelta = (float )tmp___3;
          }
#line 959
          if (deltaslid < destdelta) {
#line 960
            playing->slide -= channel->toneporta;
#line 961
            deltaslid = deltanote - (float )playing->slide * amiga_multiplier;
#line 962
            if (deltaslid > destdelta) {
#line 963
              playing->note = channel->destnote;
#line 964
              playing->slide = 0;
#line 965
              channel->destnote = (unsigned char)255;
            }
          } else {
#line 968
            playing->slide += channel->toneporta;
#line 969
            deltaslid = deltanote - (float )playing->slide * amiga_multiplier;
#line 970
            if (deltaslid < destdelta) {
#line 971
              playing->note = channel->destnote;
#line 972
              playing->slide = 0;
#line 973
              channel->destnote = (unsigned char)255;
            }
          }
        }
      }
    }
#line 866
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  update_smooth_effects(sigrenderer);
  }
#line 982
  return;
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int update_pattern_variables(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  IT_CHANNEL *channel ;
  unsigned char effectvalue ;
  unsigned char v ;

  {
#line 990
  channel = & sigrenderer->channel[(int )entry->channel];
#line 992
  if ((int )entry->mask & 8) {
    {
#line 994
    if ((int )entry->effect == 2) {
#line 994
      goto case_2;
    }
#line 1000
    if ((int )entry->effect == 19) {
#line 1000
      goto case_19;
    }
#line 993
    goto switch_break;
    case_2: /* CIL Label */ 
#line 995
    sigrenderer->breakrow = 0;
#line 996
    sigrenderer->processorder = (int )entry->effectvalue - 1;
#line 997
    sigrenderer->processrow = 65534;
#line 998
    goto switch_break;
    case_19: /* CIL Label */ 
#line 1002
    effectvalue = entry->effectvalue;
#line 1003
    if ((int )effectvalue == 0) {
#line 1004
      effectvalue = channel->lastS;
    }
#line 1005
    channel->lastS = effectvalue;
    {
#line 1008
    if ((int )effectvalue >> 4 == 11) {
#line 1008
      goto case_11;
    }
#line 1071
    if ((int )effectvalue >> 4 == 14) {
#line 1071
      goto case_14;
    }
#line 1006
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 1010
    v = (unsigned char )((int )effectvalue & 15);
#line 1011
    if ((int )v == 0) {
#line 1012
      channel->pat_loop_row = (unsigned char )sigrenderer->processrow;
    } else
#line 1014
    if ((int )channel->pat_loop_count == 0) {
#line 1015
      channel->pat_loop_count = v;
#line 1016
      sigrenderer->breakrow = (int )channel->pat_loop_row;
#line 1017
      if ((sigrenderer->sigdata)->flags & 64) {
#line 1019
        if (sigrenderer->processrow < 65534) {
#line 1021
          if (sigrenderer->processrow < (int )channel->pat_loop_end_row) {
#line 1022
            sigrenderer->processorder = 65534;
          } else {
#line 1024
            sigrenderer->processorder = 65535;
          }
#line 1025
          channel->pat_loop_end_row = (unsigned char )sigrenderer->processrow;
#line 1026
          sigrenderer->processrow = 65535;
        }
      } else {
#line 1030
        sigrenderer->processorder = 65535;
#line 1031
        sigrenderer->processrow = 65534;
      }
#line 1033
      return (1);
    } else {
#line 1034
      channel->pat_loop_count = (unsigned char )((int )channel->pat_loop_count - 1);
#line 1034
      if (channel->pat_loop_count) {
#line 1035
        sigrenderer->breakrow = (int )channel->pat_loop_row;
#line 1036
        if ((sigrenderer->sigdata)->flags & 64) {
#line 1038
          if (sigrenderer->processrow < 65534) {
#line 1040
            if (sigrenderer->processrow < (int )channel->pat_loop_end_row) {
#line 1041
              sigrenderer->processorder = 65534;
            } else {
#line 1043
              sigrenderer->processorder = 65535;
            }
#line 1044
            channel->pat_loop_end_row = (unsigned char )sigrenderer->processrow;
#line 1045
            sigrenderer->processrow = 65535;
          }
        } else {
#line 1049
          sigrenderer->processorder = 65535;
#line 1050
          sigrenderer->processrow = 65534;
        }
#line 1052
        return (1);
      } else
#line 1053
      if ((sigrenderer->sigdata)->flags & 64) {
#line 1054
        channel->pat_loop_end_row = (unsigned char)0;
      } else {
#line 1067
        channel->pat_loop_row = (unsigned char )(sigrenderer->processrow + 1);
      }
    }
#line 1070
    goto switch_break___0;
    case_14: /* CIL Label */ 
#line 1072
    sigrenderer->rowcount = 1 + ((int )effectvalue & 15);
#line 1073
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 1079
  return (0);
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void instrument_to_sample(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 


  {
#line 1090
  if (sigdata->flags & 4) {
#line 1091
    if ((int )channel->instrument >= 1) {
#line 1091
      if ((int )channel->instrument <= sigdata->n_instruments) {
#line 1092
        if ((int )channel->note < 120) {
#line 1093
          channel->sample = (sigdata->instrument + ((int )channel->instrument - 1))->map_sample[channel->note];
#line 1094
          channel->truenote = (sigdata->instrument + ((int )channel->instrument - 1))->map_note[channel->note];
        } else {
#line 1096
          channel->sample = (unsigned short)0;
        }
      } else {
#line 1098
        channel->sample = (unsigned short)0;
      }
    } else {
#line 1098
      channel->sample = (unsigned short)0;
    }
  } else {
#line 1100
    channel->sample = (unsigned short )channel->instrument;
#line 1101
    channel->truenote = channel->note;
  }
#line 1103
  if ((int )channel->sample >= 1) {
#line 1103
    if ((int )channel->sample <= sigdata->n_samples) {
#line 1103
      if (! ((int )(sigdata->sample + ((int )channel->sample - 1))->flags & 1)) {
#line 1104
        channel->sample = (unsigned short)0;
      }
    } else {
#line 1104
      channel->sample = (unsigned short)0;
    }
  } else {
#line 1104
    channel->sample = (unsigned short)0;
  }
#line 1105
  return;
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void fix_sample_looping(IT_PLAYING *playing ) 
{ 


  {
#line 1111
  if (((int )(playing->sample)->flags & 48) == 48) {
#line 1113
    if (playing->resampler.dir < 0) {
#line 1114
      playing->resampler.pos = (((playing->sample)->sus_loop_end << 1) - 1L) - playing->resampler.pos;
#line 1115
      playing->resampler.subpos ^= 65535;
#line 1116
      playing->resampler.dir = 1;
    }
#line 1119
    playing->resampler.pos += playing->time_lost;
  }
#line 1121
  return;
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_compatible_gxx_retrigger(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 


  {
  {
#line 1127
  (channel->playing)->volume_envelope.next_node = 0;
#line 1128
  (channel->playing)->volume_envelope.tick = 0;
#line 1129
  (channel->playing)->pan_envelope.next_node = 0;
#line 1130
  (channel->playing)->pan_envelope.tick = 0;
#line 1131
  (channel->playing)->pitch_envelope.next_node = 0;
#line 1132
  (channel->playing)->pitch_envelope.tick = 0;
#line 1133
  (channel->playing)->fadeoutcount = 1024;
#line 1135
  (channel->playing)->flags &= -16;
#line 1136
  it_playing_update_resamplers(channel->playing);
  }
#line 1138
  if (channel->sample) {
#line 1139
    if (sigdata->flags & 4) {
#line 1140
      (channel->playing)->env_instrument = sigdata->instrument + ((int )channel->instrument - 1);
    }
  }
#line 1141
  return;
}
}
#line 1145 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_note_off(IT_PLAYING *playing ) 
{ 


  {
#line 1147
  if (playing) {
    {
#line 1148
    playing->flags |= 3;
#line 1149
    fix_sample_looping(playing);
#line 1150
    it_playing_update_resamplers(playing);
    }
#line 1151
    if (playing->instrument) {
#line 1152
      if (((int )(playing->instrument)->volume_envelope.flags & 3) != 1) {
#line 1153
        playing->flags |= 4;
      }
    }
  }
#line 1155
  return;
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void xm_note_off(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 


  {
#line 1161
  if (channel->playing) {
#line 1162
    if (! ((int )(sigdata->instrument + ((int )channel->instrument - 1))->volume_envelope.flags & 1)) {
#line 1165
      channel->volume = (unsigned char)0;
    }
    {
#line 1166
    (channel->playing)->flags |= 6;
#line 1167
    it_playing_update_resamplers(channel->playing);
    }
  }
#line 1169
  return;
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_retrigger_note(DUMB_IT_SIGRENDERER *sigrenderer , IT_CHANNEL *channel ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  unsigned char nna ;
  int i ;
  void *tmp ;

  {
#line 1175
  sigdata = sigrenderer->sigdata;
#line 1179
  if (channel->playing) {
#line 1181
    if ((int )channel->note == 255) {
#line 1182
      nna = (unsigned char)2;
    } else
#line 1183
    if ((int )channel->note >= 120) {
#line 1184
      nna = (unsigned char)0;
    } else
#line 1183
    if (! (channel->playing)->instrument) {
#line 1184
      nna = (unsigned char)0;
    } else
#line 1183
    if ((channel->playing)->flags & 8) {
#line 1184
      nna = (unsigned char)0;
    } else {
#line 1186
      nna = ((channel->playing)->instrument)->new_note_action;
    }
    {
#line 1199
    if ((int )nna == 0) {
#line 1199
      goto case_0;
    }
#line 1203
    if ((int )nna == 2) {
#line 1203
      goto case_2;
    }
#line 1206
    if ((int )nna == 3) {
#line 1206
      goto case_3;
    }
#line 1198
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1200
    free((void *)channel->playing);
#line 1201
    channel->playing = (IT_PLAYING *)((void *)0);
    }
#line 1202
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1204
    it_note_off(channel->playing);
    }
#line 1205
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1207
    (channel->playing)->flags |= 5;
#line 1208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1212
  if ((int )channel->sample == 0) {
#line 1213
    return;
  } else
#line 1212
  if ((int )channel->note >= 120) {
#line 1213
    return;
  }
#line 1215
  channel->destnote = (unsigned char)255;
#line 1217
  if (channel->playing) {
#line 1218
    i = 0;
    {
#line 1218
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1218
      if (! (i < 192)) {
#line 1218
        goto while_break;
      }
#line 1219
      if (! sigrenderer->playing[i]) {
#line 1220
        sigrenderer->playing[i] = channel->playing;
#line 1221
        channel->playing = (IT_PLAYING *)((void *)0);
#line 1222
        goto while_break;
      }
#line 1218
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1241
  if (channel->playing) {
    {
#line 1242
    free((void *)channel->playing);
    }
  }
  {
#line 1244
  tmp = malloc(sizeof(*(channel->playing)));
#line 1244
  channel->playing = (IT_PLAYING *)tmp;
  }
#line 1246
  if (! channel->playing) {
#line 1247
    return;
  }
#line 1249
  (channel->playing)->flags = 0;
#line 1250
  (channel->playing)->channel = channel;
#line 1251
  (channel->playing)->sample = sigdata->sample + ((int )channel->sample - 1);
#line 1252
  if (sigdata->flags & 4) {
#line 1253
    (channel->playing)->instrument = sigdata->instrument + ((int )channel->instrument - 1);
  } else {
#line 1255
    (channel->playing)->instrument = (IT_INSTRUMENT *)((void *)0);
  }
  {
#line 1256
  (channel->playing)->env_instrument = (channel->playing)->instrument;
#line 1257
  (channel->playing)->sampnum = channel->sample;
#line 1258
  (channel->playing)->instnum = channel->instrument;
#line 1259
  (channel->playing)->channel_volume = channel->channelvolume;
#line 1260
  (channel->playing)->note = channel->truenote;
#line 1261
  (channel->playing)->filter_cutoff = (unsigned char)127;
#line 1262
  (channel->playing)->filter_resonance = (unsigned char)0;
#line 1263
  (channel->playing)->true_filter_cutoff = (unsigned short )(127 << 8);
#line 1264
  (channel->playing)->true_filter_resonance = (unsigned char)0;
#line 1265
  (channel->playing)->vibrato_speed = (unsigned char)0;
#line 1266
  (channel->playing)->vibrato_depth = (unsigned char)0;
#line 1267
  (channel->playing)->vibrato_n = (unsigned char)0;
#line 1268
  (channel->playing)->vibrato_time = (unsigned char)0;
#line 1269
  (channel->playing)->tremolo_speed = (unsigned char)0;
#line 1270
  (channel->playing)->tremolo_depth = (unsigned char)0;
#line 1271
  (channel->playing)->tremolo_time = (unsigned char)0;
#line 1272
  (channel->playing)->sample_vibrato_time = (unsigned char)0;
#line 1273
  (channel->playing)->sample_vibrato_depth = 0;
#line 1274
  (channel->playing)->slide = 0;
#line 1275
  (channel->playing)->volume_envelope.next_node = 0;
#line 1276
  (channel->playing)->volume_envelope.tick = 0;
#line 1277
  (channel->playing)->pan_envelope.next_node = 0;
#line 1278
  (channel->playing)->pan_envelope.tick = 0;
#line 1279
  (channel->playing)->pitch_envelope.next_node = 0;
#line 1280
  (channel->playing)->pitch_envelope.tick = 0;
#line 1281
  (channel->playing)->fadeoutcount = 1024;
#line 1282
  it_reset_filter_state(& (channel->playing)->filter_state[0]);
#line 1283
  it_reset_filter_state(& (channel->playing)->filter_state[1]);
#line 1284
  it_playing_reset_resamplers(channel->playing, 0L);
  }
#line 1287
  return;
}
}
#line 1291 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void get_default_volpan(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 
  int pan ;
  IT_INSTRUMENT *instrument ;

  {
#line 1293
  if ((int )channel->sample == 0) {
#line 1294
    return;
  }
#line 1296
  channel->volume = (sigdata->sample + ((int )channel->sample - 1))->default_volume;
#line 1298
  if (sigdata->flags & 64) {
#line 1299
    if (! (sigdata->flags & 128)) {
#line 1300
      channel->truepan = (unsigned short )(32 + (int )(sigdata->sample + ((int )channel->sample - 1))->default_pan * 64);
    }
#line 1301
    return;
  }
#line 1305
  pan = (int )(sigdata->sample + ((int )channel->sample - 1))->default_pan;
#line 1306
  if (pan >= 128) {
#line 1306
    if (pan <= 192) {
#line 1307
      channel->pan = (unsigned char )(pan - 128);
#line 1308
      return;
    }
  }
#line 1312
  if (sigdata->flags & 4) {
#line 1313
    instrument = sigdata->instrument + ((int )channel->instrument - 1);
#line 1314
    if ((int )instrument->default_pan <= 64) {
#line 1315
      channel->pan = instrument->default_pan;
    }
#line 1316
    if ((int )instrument->filter_cutoff >= 128) {
#line 1317
      channel->filter_cutoff = (unsigned char )((int )instrument->filter_cutoff - 128);
    }
#line 1318
    if ((int )instrument->filter_resonance >= 128) {
#line 1319
      channel->filter_resonance = (unsigned char )((int )instrument->filter_resonance - 128);
    }
  }
#line 1321
  return;
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void get_true_pan(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 
  IT_INSTRUMENT *instrument ;
  int truepan ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1327
  channel->truepan = (unsigned short )((int )channel->pan << 8);
#line 1329
  if (! ((int )channel->truepan > 64 << 8)) {
#line 1329
    if (sigdata->flags & 4) {
#line 1330
      instrument = sigdata->instrument + ((int )channel->instrument - 1);
#line 1331
      truepan = (int )channel->truepan;
#line 1332
      truepan += ((int )channel->note - (int )instrument->pp_centre) * (int )instrument->pp_separation << 5;
#line 1333
      if (truepan < 64 << 8) {
#line 1333
        tmp___2 = truepan;
      } else {
#line 1333
        tmp___2 = 64 << 8;
      }
#line 1333
      if (0 > tmp___2) {
#line 1333
        tmp___1 = 0;
      } else {
#line 1333
        if (truepan < 64 << 8) {
#line 1333
          tmp___0 = truepan;
        } else {
#line 1333
          tmp___0 = 64 << 8;
        }
#line 1333
        tmp___1 = tmp___0;
      }
#line 1333
      channel->truepan = (unsigned short )tmp___1;
    }
  }
#line 1335
  return;
}
}
#line 1339 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void post_process_it_volpan(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  IT_CHANNEL *channel ;
  unsigned char v ;
  unsigned char v___0 ;
  unsigned char v___1 ;
  unsigned char v___2 ;
  unsigned char v___3 ;

  {
#line 1341
  channel = & sigrenderer->channel[(int )entry->channel];
#line 1343
  if ((int )entry->mask & 4) {
#line 1344
    if (! ((int )entry->volpan <= 84)) {
#line 1348
      if ((int )entry->volpan <= 94) {
#line 1350
        v = (unsigned char )((int )entry->volpan - 85);
#line 1351
        if ((int )v == 0) {
#line 1352
          v = (unsigned char )channel->lastvolslide;
        }
#line 1353
        channel->lastvolslide = (signed char )v;
#line 1355
        channel->volslide = (signed char )v;
      } else
#line 1356
      if ((int )entry->volpan <= 104) {
#line 1358
        v___0 = (unsigned char )((int )entry->volpan - 95);
#line 1359
        if ((int )v___0 == 0) {
#line 1360
          v___0 = (unsigned char )channel->lastvolslide;
        }
#line 1361
        channel->lastvolslide = (signed char )v___0;
#line 1363
        channel->volslide = (signed char )(- ((int )v___0));
      } else
#line 1364
      if ((int )entry->volpan <= 114) {
#line 1366
        v___1 = (unsigned char )(((int )entry->volpan - 105) << 2);
#line 1367
        if ((int )v___1 == 0) {
#line 1368
          v___1 = channel->lastEF;
        }
#line 1369
        channel->lastEF = v___1;
#line 1370
        channel->portamento -= (int )v___1 << 4;
      } else
#line 1371
      if ((int )entry->volpan <= 124) {
#line 1373
        v___2 = (unsigned char )(((int )entry->volpan - 115) << 2);
#line 1374
        if ((int )v___2 == 0) {
#line 1375
          v___2 = channel->lastEF;
        }
#line 1376
        channel->lastEF = v___2;
#line 1377
        channel->portamento += (int )v___2 << 4;
      } else
#line 1378
      if (! ((int )entry->volpan <= 202)) {
#line 1381
        if ((int )entry->volpan <= 212) {
#line 1384
          v___3 = (unsigned char )((int )entry->volpan - 203);
#line 1385
          if ((int )v___3 == 0) {
#line 1386
            v___3 = channel->lastHdepth;
          } else {
#line 1388
            v___3 = (unsigned char )((int )v___3 << 2);
#line 1389
            channel->lastHdepth = v___3;
          }
#line 1391
          if (channel->playing) {
#line 1392
            (channel->playing)->vibrato_speed = channel->lastHspeed;
#line 1393
            (channel->playing)->vibrato_depth = v___3;
#line 1394
            (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
          }
        }
      }
    }
  }
#line 1398
  return;
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_send_midi(DUMB_IT_SIGRENDERER *sigrenderer , IT_CHANNEL *channel ,
                         unsigned char midi_byte ) 
{ 
  int tmp ;
  int i ;

  {
#line 1404
  if ((sigrenderer->callbacks)->midi) {
    {
#line 1405
    tmp = (*((sigrenderer->callbacks)->midi))((sigrenderer->callbacks)->midi_data,
                                              (int )(channel - sigrenderer->channel),
                                              midi_byte);
    }
#line 1405
    if (tmp) {
#line 1406
      return;
    }
  }
  {
#line 1409
  if ((int )channel->midi_state == 4) {
#line 1409
    goto case_4;
  }
#line 1413
  if ((int )channel->midi_state == 3) {
#line 1413
    goto case_3;
  }
#line 1417
  if ((int )channel->midi_state == 2) {
#line 1417
    goto case_2;
  }
#line 1425
  goto switch_default;
  case_4: /* CIL Label */ 
#line 1410
  if ((int )midi_byte < 128) {
#line 1410
    channel->filter_resonance = midi_byte;
  }
#line 1411
  channel->midi_state = (unsigned char)0;
#line 1412
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1414
  if ((int )midi_byte < 128) {
#line 1414
    channel->filter_cutoff = midi_byte;
  }
#line 1415
  channel->midi_state = (unsigned char)0;
#line 1416
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1418
  if ((int )midi_byte == 0) {
#line 1419
    channel->midi_state = (unsigned char)3;
  } else
#line 1420
  if ((int )midi_byte == 1) {
#line 1421
    channel->midi_state = (unsigned char)4;
  } else {
#line 1423
    channel->midi_state = (unsigned char)0;
  }
#line 1424
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1427
  if ((int )midi_byte == 240) {
#line 1427
    goto case_240;
  }
#line 1432
  if ((int )midi_byte == 255) {
#line 1432
    goto case_255;
  }
#line 1432
  if ((int )midi_byte == 252) {
#line 1432
    goto case_255;
  }
#line 1432
  if ((int )midi_byte == 250) {
#line 1432
    goto case_255;
  }
#line 1443
  goto switch_default___0;
  case_240: /* CIL Label */ 
#line 1428
  channel->midi_state = (unsigned char )((int )channel->midi_state + 1);
#line 1429
  goto switch_break___0;
  case_255: /* CIL Label */ 
  case_252: /* CIL Label */ 
  case_250: /* CIL Label */ 
#line 1436
  i = 0;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! (i < 64)) {
#line 1436
      goto while_break;
    }
#line 1437
    sigrenderer->channel[i].filter_cutoff = (unsigned char)127;
#line 1438
    sigrenderer->channel[i].filter_resonance = (unsigned char)0;
#line 1436
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 1444
  channel->midi_state = (unsigned char)0;
#line 1445
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1448
  return;
}
}
#line 1452 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void xm_envelope_calculate_value(IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 
  int ys ;
  int ts ;
  int te ;
  int ye ;
  int t ;

  {
#line 1454
  if (pe->next_node <= 0) {
#line 1455
    pe->value = (int )envelope->node_y[0] << 8;
  } else
#line 1456
  if (pe->next_node >= (int )envelope->n_nodes) {
#line 1457
    pe->value = (int )envelope->node_y[(int )envelope->n_nodes - 1] << 8;
  } else {
#line 1459
    ys = (int )envelope->node_y[pe->next_node - 1] << 8;
#line 1460
    ts = (int )envelope->node_t[pe->next_node - 1];
#line 1461
    te = (int )envelope->node_t[pe->next_node];
#line 1463
    if (ts == te) {
#line 1464
      pe->value = ys;
    } else {
#line 1466
      ye = (int )envelope->node_y[pe->next_node] << 8;
#line 1467
      t = pe->tick;
#line 1469
      pe->value = ys + ((ye - ys) * (t - ts)) / (te - ts);
    }
  }
#line 1472
  return;
}
}
#line 1477 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_effects(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry , int ignore_cxx ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_CHANNEL *channel ;
  int tmp ;
  int tmp___0 ;
  unsigned char v ;
  unsigned char v___0 ;
  unsigned char v___1 ;
  unsigned char v___2 ;
  unsigned char v___3 ;
  unsigned char v___4 ;
  unsigned char v___5 ;
  unsigned char speed ;
  unsigned char depth ;
  unsigned char v___6 ;
  unsigned char v___7 ;
  unsigned char v___8 ;
  unsigned char v___9 ;
  int offset ;
  IT_PLAYING *playing ;
  IT_SAMPLE *sample ;
  int end ;
  unsigned char v___10 ;
  int p ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char v___11 ;
  unsigned char tmp___5 ;
  unsigned char speed___0 ;
  unsigned char depth___0 ;
  unsigned char effectvalue ;
  unsigned char v___12 ;
  unsigned char speed___1 ;
  unsigned char depth___1 ;
  unsigned char v___13 ;
  IT_MIDI *midi ;
  IT_MIDI *tmp___6 ;
  int n ;
  int i ;
  int n___0 ;
  int i___0 ;
  int j ;
  int tmp___7 ;
  IT_ENVELOPE *envelope ;
  IT_PLAYING_ENVELOPE *pe ;

  {
#line 1479
  sigdata = sigrenderer->sigdata;
#line 1481
  channel = & sigrenderer->channel[(int )entry->channel];
#line 1483
  if ((int )entry->mask & 8) {
    {
#line 1504
    if ((int )entry->effect == 1) {
#line 1504
      goto case_1;
    }
#line 1514
    if ((int )entry->effect == 3) {
#line 1514
      goto case_3;
    }
#line 1520
    if ((int )entry->effect == 11) {
#line 1520
      goto case_11;
    }
#line 1528
    if ((int )entry->effect == 12) {
#line 1528
      goto case_12;
    }
#line 1528
    if ((int )entry->effect == 4) {
#line 1528
      goto case_12;
    }
#line 1558
    if ((int )entry->effect == 29) {
#line 1558
      goto case_29;
    }
#line 1568
    if ((int )entry->effect == 30) {
#line 1568
      goto case_30;
    }
#line 1578
    if ((int )entry->effect == 5) {
#line 1578
      goto case_5;
    }
#line 1607
    if ((int )entry->effect == 6) {
#line 1607
      goto case_6;
    }
#line 1636
    if ((int )entry->effect == 27) {
#line 1636
      goto case_27;
    }
#line 1648
    if ((int )entry->effect == 28) {
#line 1648
      goto case_28;
    }
#line 1660
    if ((int )entry->effect == 32) {
#line 1660
      goto case_32;
    }
#line 1664
    if ((int )entry->effect == 8) {
#line 1664
      goto case_8;
    }
#line 1687
    if ((int )entry->effect == 9) {
#line 1687
      goto case_9;
    }
#line 1701
    if ((int )entry->effect == 10) {
#line 1701
      goto case_10;
    }
#line 1715
    if ((int )entry->effect == 13) {
#line 1715
      goto case_13;
    }
#line 1727
    if ((int )entry->effect == 14) {
#line 1727
      goto case_14;
    }
#line 1751
    if ((int )entry->effect == 15) {
#line 1751
      goto case_15;
    }
#line 1784
    if ((int )entry->effect == 16) {
#line 1784
      goto case_16;
    }
#line 1821
    if ((int )entry->effect == 17) {
#line 1821
      goto case_17;
    }
#line 1843
    if ((int )entry->effect == 31) {
#line 1843
      goto case_31;
    }
#line 1848
    if ((int )entry->effect == 18) {
#line 1848
      goto case_18;
    }
#line 1864
    if ((int )entry->effect == 19) {
#line 1864
      goto case_19;
    }
#line 1917
    if ((int )entry->effect == 20) {
#line 1917
      goto case_20;
    }
#line 1931
    if ((int )entry->effect == 21) {
#line 1931
      goto case_21;
    }
#line 1952
    if ((int )entry->effect == 22) {
#line 1952
      goto case_22;
    }
#line 1960
    if ((int )entry->effect == 23) {
#line 1960
      goto case_23;
    }
#line 1981
    if ((int )entry->effect == 24) {
#line 1981
      goto case_24;
    }
#line 1990
    if ((int )entry->effect == 26) {
#line 1990
      goto case_26;
    }
#line 2008
    if ((int )entry->effect == 33) {
#line 2008
      goto case_33;
    }
#line 1484
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1505
    if (entry->effectvalue) {
#line 1506
      tmp = (int )entry->effectvalue;
#line 1506
      sigrenderer->speed = tmp;
#line 1506
      sigrenderer->tick = tmp;
    } else
#line 1507
    if (sigdata->flags & 64) {
#line 1508
      sigrenderer->speed = 0;
#line 1509
      if ((sigrenderer->callbacks)->xm_speed_zero) {
        {
#line 1509
        tmp___0 = (*((sigrenderer->callbacks)->xm_speed_zero))((sigrenderer->callbacks)->xm_speed_zero_data);
        }
#line 1509
        if (tmp___0) {
#line 1510
          return (1);
        }
      }
    }
#line 1512
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1515
    if (ignore_cxx) {
#line 1515
      goto switch_break;
    }
#line 1516
    sigrenderer->breakrow = (int )entry->effectvalue;
#line 1517
    sigrenderer->processrow = 65534;
#line 1518
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1521
    if (channel->playing) {
#line 1522
      (channel->playing)->vibrato_speed = channel->lastHspeed;
#line 1523
      (channel->playing)->vibrato_depth = channel->lastHdepth;
#line 1524
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
    case_12: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1531
    v = entry->effectvalue;
#line 1532
    if (! (sigdata->flags & 128)) {
#line 1533
      if ((int )v == 0) {
#line 1534
        v = channel->lastDKL;
      }
#line 1535
      channel->lastDKL = v;
    }
#line 1537
    if (((int )v & 15) == 0) {
#line 1538
      channel->volslide = (signed char )((int )v >> 4);
#line 1539
      if ((int )channel->volslide == 15) {
#line 1539
        if (! (sigdata->flags & 64)) {
#line 1540
          channel->volume = (unsigned char )((int )channel->volume + 15);
#line 1541
          if ((int )channel->volume > 64) {
#line 1541
            channel->volume = (unsigned char)64;
          }
        }
      }
    } else
#line 1543
    if (((int )v & 240) == 0) {
#line 1544
      channel->volslide = (signed char )(- ((int )v));
#line 1545
      if ((int )channel->volslide == -15) {
#line 1545
        if (! (sigdata->flags & 64)) {
#line 1546
          channel->volume = (unsigned char )((int )channel->volume - 15);
#line 1547
          if ((int )channel->volume > 64) {
#line 1547
            channel->volume = (unsigned char)0;
          }
        }
      }
    } else
#line 1549
    if (((int )v & 15) == 15) {
#line 1550
      channel->volume = (unsigned char )((int )channel->volume + ((int )v >> 4));
#line 1551
      if ((int )channel->volume > 64) {
#line 1551
        channel->volume = (unsigned char)64;
      }
    } else
#line 1552
    if (((int )v & 240) == 240) {
#line 1553
      channel->volume = (unsigned char )((int )channel->volume - ((int )v & 15));
#line 1554
      if ((int )channel->volume > 64) {
#line 1554
        channel->volume = (unsigned char)0;
      }
    }
#line 1557
    goto switch_break;
    case_29: /* CIL Label */ 
#line 1560
    v___0 = entry->effectvalue;
#line 1561
    if ((int )v___0 == 0) {
#line 1562
      v___0 = channel->xm_lastEB;
    }
#line 1563
    channel->xm_lastEB = v___0;
#line 1564
    channel->volume = (unsigned char )((int )channel->volume - (int )v___0);
#line 1565
    if ((int )channel->volume > 64) {
#line 1565
      channel->volume = (unsigned char)0;
    }
#line 1567
    goto switch_break;
    case_30: /* CIL Label */ 
#line 1570
    v___1 = entry->effectvalue;
#line 1571
    if ((int )v___1 == 0) {
#line 1572
      v___1 = channel->xm_lastEA;
    }
#line 1573
    channel->xm_lastEA = v___1;
#line 1574
    channel->volume = (unsigned char )((int )channel->volume + (int )v___1);
#line 1575
    if ((int )channel->volume > 64) {
#line 1575
      channel->volume = (unsigned char)64;
    }
#line 1577
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1580
    v___2 = entry->effectvalue;
#line 1581
    if (sigdata->flags & 64) {
#line 1582
      if (! (sigdata->flags & 128)) {
#line 1583
        if ((int )v___2 == 240) {
#line 1584
          v___2 = (unsigned char )((int )v___2 | (int )channel->xm_lastE2);
        } else
#line 1585
        if ((int )v___2 >= 240) {
#line 1586
          channel->xm_lastE2 = (unsigned char )((int )v___2 & 15);
        } else
#line 1587
        if ((int )v___2 == 224) {
#line 1588
          v___2 = (unsigned char )((int )v___2 | (int )channel->xm_lastX2);
        } else {
#line 1590
          channel->xm_lastX2 = (unsigned char )((int )v___2 & 15);
        }
      }
    } else {
#line 1593
      if ((int )v___2 == 0) {
#line 1594
        v___2 = channel->lastEF;
      }
#line 1595
      channel->lastEF = v___2;
    }
#line 1597
    if (channel->playing) {
#line 1598
      if (((int )v___2 & 240) == 240) {
#line 1599
        (channel->playing)->slide -= ((int )v___2 & 15) << 4;
      } else
#line 1600
      if (((int )v___2 & 240) == 224) {
#line 1601
        (channel->playing)->slide -= ((int )v___2 & 15) << 2;
      } else {
#line 1603
        channel->portamento -= (int )v___2 << 4;
      }
    }
#line 1606
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1609
    v___3 = entry->effectvalue;
#line 1610
    if (sigdata->flags & 64) {
#line 1611
      if (! (sigdata->flags & 128)) {
#line 1612
        if ((int )v___3 == 240) {
#line 1613
          v___3 = (unsigned char )((int )v___3 | (int )channel->xm_lastE1);
        } else
#line 1614
        if ((int )v___3 >= 240) {
#line 1615
          channel->xm_lastE1 = (unsigned char )((int )v___3 & 15);
        } else
#line 1616
        if ((int )v___3 == 224) {
#line 1617
          v___3 = (unsigned char )((int )v___3 | (int )channel->xm_lastX1);
        } else {
#line 1619
          channel->xm_lastX1 = (unsigned char )((int )v___3 & 15);
        }
      }
    } else {
#line 1622
      if ((int )v___3 == 0) {
#line 1623
        v___3 = channel->lastEF;
      }
#line 1624
      channel->lastEF = v___3;
    }
#line 1626
    if (channel->playing) {
#line 1627
      if (((int )v___3 & 240) == 240) {
#line 1628
        (channel->playing)->slide += ((int )v___3 & 15) << 4;
      } else
#line 1629
      if (((int )v___3 & 240) == 224) {
#line 1630
        (channel->playing)->slide += ((int )v___3 & 15) << 2;
      } else {
#line 1632
        channel->portamento += (int )v___3 << 4;
      }
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1638
    v___4 = entry->effectvalue;
#line 1639
    if (! (sigdata->flags & 128)) {
#line 1640
      if ((int )v___4 == 0) {
#line 1641
        v___4 = channel->lastJ;
      }
#line 1642
      channel->lastJ = v___4;
    }
#line 1644
    if (channel->playing) {
#line 1645
      channel->portamento -= (int )v___4 << 4;
    }
#line 1647
    goto switch_break;
    case_28: /* CIL Label */ 
#line 1650
    v___5 = entry->effectvalue;
#line 1651
    if (! (sigdata->flags & 128)) {
#line 1652
      if ((int )v___5 == 0) {
#line 1653
        v___5 = channel->lastEF;
      }
#line 1654
      channel->lastEF = v___5;
    }
#line 1656
    if (channel->playing) {
#line 1657
      channel->portamento += (int )v___5 << 4;
    }
#line 1659
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1661
    channel->key_off_count = entry->effectvalue;
#line 1662
    if (! channel->key_off_count) {
      {
#line 1662
      xm_note_off(sigdata, channel);
      }
    }
#line 1663
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1666
    speed = (unsigned char )((int )entry->effectvalue >> 4);
#line 1667
    depth = (unsigned char )((int )entry->effectvalue & 15);
#line 1668
    if ((int )speed == 0) {
#line 1669
      speed = channel->lastHspeed;
    }
#line 1670
    channel->lastHspeed = speed;
#line 1671
    if ((int )depth == 0) {
#line 1672
      depth = channel->lastHdepth;
    } else {
#line 1674
      if (sigdata->flags & 16) {
#line 1675
        depth = (unsigned char )((int )depth << 3);
      } else {
#line 1677
        depth = (unsigned char )((int )depth << 2);
      }
#line 1678
      channel->lastHdepth = depth;
    }
#line 1680
    if (channel->playing) {
#line 1681
      (channel->playing)->vibrato_speed = speed;
#line 1682
      (channel->playing)->vibrato_depth = depth;
#line 1683
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
#line 1686
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1689
    v___6 = entry->effectvalue;
#line 1690
    if ((int )v___6 == 0) {
#line 1691
      v___6 = channel->lastI;
    } else
#line 1692
    if (! (sigdata->flags & 16)) {
#line 1693
      if ((int )v___6 & 240) {
#line 1693
        v___6 = (unsigned char )((int )v___6 - 16);
      }
#line 1694
      if ((int )v___6 & 15) {
#line 1694
        v___6 = (unsigned char )((int )v___6 - 1);
      }
    }
    {
#line 1696
    channel->lastI = v___6;
#line 1697
    channel->tremor_time = (unsigned char )((int )channel->tremor_time | 128);
#line 1699
    update_tremor(channel);
    }
#line 1700
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1703
    v___7 = entry->effectvalue;
#line 1707
    if (! (sigdata->flags & 64)) {
#line 1708
      if ((int )v___7 == 0) {
#line 1709
        v___7 = channel->lastJ;
      }
#line 1710
      channel->lastJ = v___7;
    }
#line 1712
    channel->arpeggio = (int )v___7;
#line 1714
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1716
    if (sigdata->flags & 64) {
#line 1717
      if ((int )entry->effectvalue < 64) {
#line 1717
        channel->volume = entry->effectvalue;
      } else {
#line 1717
        channel->volume = (unsigned char)64;
      }
    } else
#line 1718
    if ((int )entry->effectvalue <= 64) {
#line 1719
      channel->channelvolume = entry->effectvalue;
    } else {
#line 1722
      channel->channelvolume = (unsigned char)64;
    }
#line 1724
    if (channel->playing) {
#line 1725
      (channel->playing)->channel_volume = channel->channelvolume;
    }
#line 1726
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1729
    v___8 = entry->effectvalue;
#line 1730
    if ((int )v___8 == 0) {
#line 1731
      v___8 = channel->lastN;
    }
#line 1732
    channel->lastN = v___8;
#line 1733
    if (((int )v___8 & 15) == 0) {
#line 1734
      channel->channelvolslide = (signed char )((int )v___8 >> 4);
    } else
#line 1735
    if (((int )v___8 & 240) == 0) {
#line 1736
      channel->channelvolslide = (signed char )(- ((int )v___8));
    } else {
#line 1738
      if (((int )v___8 & 15) == 15) {
#line 1739
        channel->channelvolume = (unsigned char )((int )channel->channelvolume + ((int )v___8 >> 4));
#line 1740
        if ((int )channel->channelvolume > 64) {
#line 1740
          channel->channelvolume = (unsigned char)64;
        }
      } else
#line 1741
      if (((int )v___8 & 240) == 240) {
#line 1742
        channel->channelvolume = (unsigned char )((int )channel->channelvolume - ((int )v___8 & 15));
#line 1743
        if ((int )channel->channelvolume > 64) {
#line 1743
          channel->channelvolume = (unsigned char)0;
        }
      } else {
#line 1745
        goto switch_break;
      }
#line 1746
      if (channel->playing) {
#line 1747
        (channel->playing)->channel_volume = channel->channelvolume;
      }
    }
#line 1750
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1753
    v___9 = entry->effectvalue;
#line 1754
    if (sigdata->flags & 128) {
#line 1755
      if ((int )v___9 == 0) {
#line 1755
        goto switch_break;
      }
    } else {
#line 1757
      if ((int )v___9 == 0) {
#line 1758
        v___9 = channel->lastO;
      }
#line 1759
      channel->lastO = v___9;
    }
#line 1764
    if ((int )entry->mask & 1) {
#line 1765
      if (channel->playing) {
#line 1766
        offset = ((int )channel->high_offset << 16) | ((int )v___9 << 8);
#line 1767
        playing = channel->playing;
#line 1768
        sample = playing->sample;
#line 1770
        if ((int )sample->flags & 32) {
#line 1770
          if (! (playing->flags & 2)) {
#line 1771
            end = (int )sample->sus_loop_end;
          } else {
#line 1770
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1772
        if ((int )sample->flags & 16) {
#line 1773
          end = (int )sample->loop_end;
        } else {
#line 1775
          end = (int )sample->length;
        }
#line 1776
        if (offset < end) {
          {
#line 1777
          it_playing_reset_resamplers(playing, (long )offset);
          }
        } else
#line 1778
        if (sigdata->flags & 16) {
          {
#line 1779
          it_playing_reset_resamplers(playing, (long )end);
          }
        }
      }
    }
#line 1783
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1793
    v___10 = entry->effectvalue;
#line 1794
    p = (int )channel->truepan;
#line 1795
    if (sigdata->flags & 64) {
#line 1796
      p >>= 6;
    } else {
#line 1798
      p = (p + 128) >> 8;
#line 1799
      channel->pan = (unsigned char )p;
    }
#line 1801
    if ((int )v___10 == 0) {
#line 1802
      v___10 = channel->lastP;
    }
#line 1803
    channel->lastP = v___10;
#line 1804
    if (((int )v___10 & 15) == 0) {
#line 1805
      channel->panslide = (signed char )((int )v___10 >> 4);
    } else
#line 1806
    if (((int )v___10 & 240) == 0) {
#line 1807
      channel->panslide = (signed char )(- ((int )v___10));
    } else
#line 1808
    if (((int )v___10 & 15) == 15) {
#line 1809
      p += (int )v___10 >> 4;
    } else
#line 1810
    if (((int )v___10 & 240) == 240) {
#line 1811
      p -= (int )v___10 & 15;
    }
#line 1813
    if (sigdata->flags & 64) {
#line 1814
      if (p < 255) {
#line 1814
        tmp___4 = p;
      } else {
#line 1814
        tmp___4 = 255;
      }
#line 1814
      if (0 > tmp___4) {
#line 1814
        tmp___3 = 0;
      } else {
#line 1814
        if (p < 255) {
#line 1814
          tmp___2 = p;
        } else {
#line 1814
          tmp___2 = 255;
        }
#line 1814
        tmp___3 = tmp___2;
      }
#line 1814
      channel->truepan = (unsigned short )(32 + tmp___3 * 64);
    } else
#line 1815
    if (! ((int )channel->pan > 64)) {
#line 1816
      channel->pan = (unsigned char )p;
#line 1817
      channel->truepan = (unsigned short )(p << 8);
    }
#line 1820
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1823
    v___11 = entry->effectvalue;
#line 1824
    if (sigdata->flags & 64) {
#line 1825
      if (((int )v___11 & 15) == 0) {
#line 1825
        v___11 = (unsigned char )((int )v___11 | ((int )channel->lastQ & 15));
      }
#line 1826
      if (((int )v___11 & 240) == 0) {
#line 1826
        v___11 = (unsigned char )((int )v___11 | ((int )channel->lastQ & 240));
      }
    } else
#line 1828
    if ((int )v___11 == 0) {
#line 1829
      v___11 = channel->lastQ;
    }
#line 1831
    channel->lastQ = v___11;
#line 1832
    if (((int )v___11 & 15) == 0) {
#line 1832
      v___11 = (unsigned char )((int )v___11 | 1);
    }
#line 1833
    channel->retrig = v___11;
#line 1834
    if ((int )entry->mask & 1) {
#line 1835
      channel->retrig_tick = (int )v___11 & 15;
#line 1837
      if (sigdata->flags & 64) {
        {
#line 1838
        update_retrig(channel);
        }
      }
    } else {
      {
#line 1840
      update_retrig(channel);
      }
    }
#line 1842
    goto switch_break;
    case_31: /* CIL Label */ 
#line 1844
    tmp___5 = entry->effectvalue;
#line 1844
    channel->xm_retrig = tmp___5;
#line 1844
    channel->retrig_tick = (int )tmp___5;
#line 1845
    if ((int )entry->effectvalue == 0) {
#line 1846
      if (channel->playing) {
        {
#line 1846
        it_playing_reset_resamplers(channel->playing, 0L);
        }
      }
    }
#line 1847
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1850
    speed___0 = (unsigned char )((int )entry->effectvalue >> 4);
#line 1851
    depth___0 = (unsigned char )((int )entry->effectvalue & 15);
#line 1852
    if ((int )speed___0 == 0) {
#line 1853
      speed___0 = channel->lastRspeed;
    }
#line 1854
    channel->lastRspeed = speed___0;
#line 1855
    if ((int )depth___0 == 0) {
#line 1856
      depth___0 = channel->lastRdepth;
    }
#line 1857
    channel->lastRdepth = depth___0;
#line 1858
    if (channel->playing) {
#line 1859
      (channel->playing)->tremolo_speed = speed___0;
#line 1860
      (channel->playing)->tremolo_depth = depth___0;
    }
#line 1863
    goto switch_break;
    case_19: /* CIL Label */ 
#line 1867
    effectvalue = channel->lastS;
    {
#line 1881
    if ((int )effectvalue >> 4 == 6) {
#line 1881
      goto case_6___0;
    }
#line 1885
    if ((int )effectvalue >> 4 == 8) {
#line 1885
      goto case_8___0;
    }
#line 1892
    if ((int )effectvalue >> 4 == 9) {
#line 1892
      goto case_9___0;
    }
#line 1898
    if ((int )effectvalue >> 4 == 10) {
#line 1898
      goto case_10___0;
    }
#line 1902
    if ((int )effectvalue >> 4 == 12) {
#line 1902
      goto case_12___0;
    }
#line 1911
    if ((int )effectvalue >> 4 == 15) {
#line 1911
      goto case_15___0;
    }
#line 1868
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 1882
    sigrenderer->tick += (int )effectvalue & 15;
#line 1883
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 1887
    channel->pan = (unsigned char )((((int )effectvalue & 15) << 2) | (((int )effectvalue & 15) >> 2));
#line 1890
    channel->truepan = (unsigned short )((int )channel->pan << 8);
#line 1891
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
#line 1893
    if (((int )effectvalue & 15) == 1) {
#line 1894
      channel->pan = (unsigned char)100;
#line 1895
      channel->truepan = (unsigned short )((int )channel->pan << 8);
    }
#line 1897
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
#line 1899
    channel->high_offset = (unsigned char )((int )effectvalue & 15);
#line 1900
    goto switch_break___0;
    case_12___0: /* CIL Label */ 
#line 1903
    channel->note_cut_count = (unsigned char )((int )effectvalue & 15);
#line 1904
    if (! channel->note_cut_count) {
#line 1905
      if (sigdata->flags & 64) {
#line 1906
        channel->volume = (unsigned char)0;
      } else {
#line 1908
        channel->note_cut_count = (unsigned char)1;
      }
    }
#line 1910
    goto switch_break___0;
    case_15___0: /* CIL Label */ 
#line 1912
    channel->SFmacro = (unsigned char )((int )effectvalue & 15);
#line 1913
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1916
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1919
    v___12 = entry->effectvalue;
#line 1920
    if ((int )v___12 == 0) {
#line 1921
      v___12 = channel->lastW;
    }
#line 1922
    channel->lastW = v___12;
#line 1923
    if ((int )v___12 < 16) {
#line 1924
      sigrenderer->temposlide = (signed char )(- ((int )v___12));
    } else
#line 1925
    if ((int )v___12 < 32) {
#line 1926
      sigrenderer->temposlide = (signed char )((int )v___12 & 15);
    } else {
#line 1928
      sigrenderer->tempo = v___12;
    }
#line 1930
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1933
    speed___1 = (unsigned char )((int )entry->effectvalue >> 4);
#line 1934
    depth___1 = (unsigned char )((int )entry->effectvalue & 15);
#line 1935
    if ((int )speed___1 == 0) {
#line 1936
      speed___1 = channel->lastHspeed;
    }
#line 1937
    channel->lastHspeed = speed___1;
#line 1938
    if ((int )depth___1 == 0) {
#line 1939
      depth___1 = channel->lastHdepth;
    } else {
#line 1941
      if (sigdata->flags & 16) {
#line 1942
        depth___1 = (unsigned char )((int )depth___1 << 1);
      }
#line 1943
      channel->lastHdepth = depth___1;
    }
#line 1945
    if (channel->playing) {
#line 1946
      (channel->playing)->vibrato_speed = speed___1;
#line 1947
      (channel->playing)->vibrato_depth = depth___1;
#line 1948
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
#line 1951
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1953
    if ((int )entry->effectvalue <= 128) {
#line 1954
      sigrenderer->globalvolume = entry->effectvalue;
    } else {
#line 1957
      sigrenderer->globalvolume = (unsigned char)128;
    }
#line 1959
    goto switch_break;
    case_23: /* CIL Label */ 
#line 1962
    v___13 = entry->effectvalue;
#line 1963
    if ((int )v___13 == 0) {
#line 1964
      v___13 = channel->lastW;
    }
#line 1965
    channel->lastW = v___13;
#line 1966
    if (((int )v___13 & 15) == 0) {
#line 1967
      if (sigdata->flags & 64) {
#line 1967
        sigrenderer->globalvolslide = (signed char )(((int )v___13 >> 4) * 2);
      } else {
#line 1967
        sigrenderer->globalvolslide = (signed char )((int )v___13 >> 4);
      }
    } else
#line 1969
    if (((int )v___13 & 240) == 0) {
#line 1970
      if (sigdata->flags & 64) {
#line 1970
        sigrenderer->globalvolslide = (signed char )(- ((int )v___13) * 2);
      } else {
#line 1970
        sigrenderer->globalvolslide = (signed char )(- ((int )v___13));
      }
    } else
#line 1972
    if (((int )v___13 & 15) == 15) {
#line 1973
      sigrenderer->globalvolume = (unsigned char )((int )sigrenderer->globalvolume + ((int )v___13 >> 4));
#line 1974
      if ((int )sigrenderer->globalvolume > 128) {
#line 1974
        sigrenderer->globalvolume = (unsigned char)128;
      }
    } else
#line 1975
    if (((int )v___13 & 240) == 240) {
#line 1976
      sigrenderer->globalvolume = (unsigned char )((int )sigrenderer->globalvolume - ((int )v___13 & 15));
#line 1977
      if ((int )sigrenderer->globalvolume > 128) {
#line 1977
        sigrenderer->globalvolume = (unsigned char)0;
      }
    }
#line 1980
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1982
    if (sigdata->flags & 64) {
#line 1983
      channel->truepan = (unsigned short )(32 + (int )entry->effectvalue * 64);
    } else {
#line 1985
      channel->pan = (unsigned char )(((int )entry->effectvalue + 2) >> 2);
#line 1986
      channel->truepan = (unsigned short )((int )channel->pan << 8);
    }
#line 1988
    goto switch_break;
    case_26: /* CIL Label */ 
#line 1992
    if (sigdata->midi) {
#line 1992
      tmp___6 = sigdata->midi;
    } else {
#line 1992
      tmp___6 = & default_midi;
    }
#line 1992
    midi = tmp___6;
#line 1993
    if ((int )entry->effectvalue >= 128) {
#line 1994
      n = (int )midi->Zmacrolen[(int )entry->effectvalue - 128];
#line 1996
      i = 0;
      {
#line 1996
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1996
        if (! (i < n)) {
#line 1996
          goto while_break;
        }
        {
#line 1997
        it_send_midi(sigrenderer, channel, midi->Zmacro[(int )entry->effectvalue - 128][i]);
#line 1996
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1999
      n___0 = (int )midi->SFmacrolen[channel->SFmacro];
#line 2001
      i___0 = 0;
#line 2001
      j = 1;
      {
#line 2001
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2001
        if (! (i___0 < n___0)) {
#line 2001
          goto while_break___0;
        }
#line 2002
        if ((int )midi->SFmacroz[channel->SFmacro] & j) {
#line 2002
          tmp___7 = (int )entry->effectvalue;
        } else {
#line 2002
          tmp___7 = (int )midi->SFmacro[channel->SFmacro][i___0];
        }
        {
#line 2002
        it_send_midi(sigrenderer, channel, (unsigned char )tmp___7);
#line 2001
        i___0 ++;
#line 2001
        j <<= 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2007
    goto switch_break;
    case_33: /* CIL Label */ 
#line 2009
    if (channel->playing) {
#line 2009
      if ((channel->playing)->env_instrument) {
#line 2010
        envelope = & ((channel->playing)->env_instrument)->volume_envelope;
#line 2011
        if ((int )envelope->flags & 1) {
#line 2012
          pe = & (channel->playing)->volume_envelope;
#line 2013
          pe->tick = (int )entry->effectvalue;
#line 2014
          if (pe->tick >= (int )envelope->node_t[(int )envelope->n_nodes - 1]) {
#line 2015
            pe->tick = (int )envelope->node_t[(int )envelope->n_nodes - 1];
          }
#line 2016
          pe->next_node = 0;
          {
#line 2017
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2017
            if (! (pe->tick > (int )envelope->node_t[pe->next_node])) {
#line 2017
              goto while_break___1;
            }
#line 2017
            (pe->next_node) ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 2018
          xm_envelope_calculate_value(envelope, pe);
          }
        }
      }
    }
#line 2021
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2025
  if (! (sigdata->flags & 64)) {
    {
#line 2026
    post_process_it_volpan(sigrenderer, entry);
    }
  }
#line 2028
  return (0);
}
}
#line 2086
static int process_it_note_data(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) ;
#line 2086 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static unsigned char const   slidetable[10]  = 
#line 2086
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )8, 
        (unsigned char const   )16,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )96, 
        (unsigned char const   )128,      (unsigned char const   )255};
#line 2033 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_it_note_data(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_CHANNEL *channel ;
  unsigned char note ;
  int slide ;
  unsigned char v ;
  unsigned char v___0 ;
  unsigned char v___1 ;
  unsigned char v___2 ;

  {
#line 2035
  sigdata = sigrenderer->sigdata;
#line 2036
  channel = & sigrenderer->channel[(int )entry->channel];
#line 2049
  if ((int )entry->mask & 3) {
#line 2050
    if ((int )entry->mask & 2) {
#line 2051
      channel->instrument = entry->instrument;
    }
    {
#line 2052
    instrument_to_sample(sigdata, channel);
    }
#line 2053
    if ((int )channel->note < 120) {
#line 2054
      if (sigdata->flags & 4) {
#line 2054
        if ((int )channel->sample == 0) {
#line 2055
          return (1);
        }
      }
#line 2056
      if ((int )entry->mask & 2) {
        {
#line 2057
        get_default_volpan(sigdata, channel);
        }
      }
    } else {
      {
#line 2059
      it_retrigger_note(sigrenderer, channel);
      }
    }
  }
#line 2063
  if ((int )entry->mask & 4) {
#line 2063
    if ((int )entry->volpan >= 193) {
#line 2063
      if ((int )entry->volpan <= 202) {
#line 2063
        goto _L___5;
      } else {
#line 2063
        goto _L___7;
      }
    } else {
#line 2063
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 2063
  if ((int )entry->mask & 8) {
#line 2063
    if ((int )entry->effect == 7) {
#line 2063
      goto _L___5;
    } else
#line 2063
    if ((int )entry->effect == 12) {
      _L___5: /* CIL Label */ 
#line 2066
      if (channel->playing) {
#line 2066
        if ((int )entry->mask & 2) {
#line 2067
          if (sigdata->flags & 32) {
            {
#line 2068
            it_compatible_gxx_retrigger(sigdata, channel);
            }
          } else
#line 2069
          if (! (sigdata->flags & 4)) {
#line 2069
            goto _L;
          } else
#line 2069
          if ((int )channel->instrument >= 1) {
#line 2069
            if ((int )channel->instrument <= sigdata->n_instruments) {
              _L: /* CIL Label */ 
#line 2069
              if ((int )channel->sample != (int )(channel->playing)->sampnum) {
                {
#line 2073
                note = (channel->playing)->note;
#line 2074
                slide = (channel->playing)->slide;
#line 2075
                it_retrigger_note(sigrenderer, channel);
                }
#line 2076
                if (channel->playing) {
#line 2077
                  (channel->playing)->note = note;
#line 2078
                  (channel->playing)->slide = slide;
                }
              }
            }
          }
        }
      }
#line 2084
      if ((int )entry->mask & 4) {
#line 2084
        if ((int )entry->volpan >= 193) {
#line 2084
          if ((int )entry->volpan <= 202) {
#line 2087
            v = (unsigned char )slidetable[(int )entry->volpan - 193];
#line 2088
            if (sigdata->flags & 32) {
#line 2089
              if ((int )v == 0) {
#line 2090
                v = channel->lastG;
              }
#line 2091
              channel->lastG = v;
            } else {
#line 2093
              if ((int )v == 0) {
#line 2094
                v = channel->lastEF;
              }
#line 2095
              channel->lastEF = v;
            }
#line 2097
            if ((int )entry->mask & 1) {
#line 2097
              goto _L___0;
            } else
#line 2097
            if (sigdata->flags & 32) {
#line 2097
              if ((int )entry->mask & 2) {
                _L___0: /* CIL Label */ 
#line 2098
                if (channel->sample) {
#line 2099
                  channel->destnote = channel->truenote;
                } else {
#line 2101
                  channel->destnote = channel->note;
                }
              }
            }
#line 2103
            channel->toneporta = (int )v << 4;
          } else {
#line 2084
            goto _L___3;
          }
        } else {
#line 2084
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 2107
        if ((int )entry->effect == 7) {
#line 2108
          v___0 = entry->effectvalue;
        } else {
#line 2110
          v___0 = (unsigned char)0;
        }
#line 2111
        if (sigdata->flags & 32) {
#line 2112
          if ((int )v___0 == 0) {
#line 2113
            v___0 = channel->lastG;
          }
#line 2114
          channel->lastG = v___0;
        } else {
#line 2116
          if ((int )v___0 == 0) {
#line 2117
            v___0 = channel->lastEF;
          }
#line 2118
          channel->lastEF = v___0;
        }
#line 2120
        if ((int )entry->mask & 1) {
#line 2120
          goto _L___1;
        } else
#line 2120
        if (sigdata->flags & 32) {
#line 2120
          if ((int )entry->mask & 2) {
            _L___1: /* CIL Label */ 
#line 2121
            if (channel->sample) {
#line 2122
              channel->destnote = channel->truenote;
            } else {
#line 2124
              channel->destnote = channel->note;
            }
          }
        }
#line 2126
        channel->toneporta = (int )v___0 << 4;
      }
#line 2128
      if (channel->playing) {
#line 2128
        goto skip_start_note;
      }
    }
  }
#line 2131
  if ((int )entry->mask & 1) {
#line 2131
    goto _L___9;
  } else
#line 2131
  if ((int )entry->mask & 2) {
#line 2131
    if (! channel->playing) {
#line 2131
      goto _L___9;
    } else
#line 2131
    if ((int )entry->instrument != (int )(channel->playing)->instnum) {
      _L___9: /* CIL Label */ 
#line 2134
      if ((int )channel->note < 120) {
        {
#line 2135
        get_true_pan(sigdata, channel);
#line 2136
        it_retrigger_note(sigrenderer, channel);
        }
      }
    }
  }
  skip_start_note: 
#line 2142
  if ((int )entry->mask & 4) {
#line 2143
    if ((int )entry->volpan <= 64) {
#line 2145
      channel->volume = entry->volpan;
    } else
#line 2146
    if ((int )entry->volpan <= 74) {
#line 2148
      v___1 = (unsigned char )((int )entry->volpan - 65);
#line 2149
      if ((int )v___1 == 0) {
#line 2150
        v___1 = (unsigned char )channel->lastvolslide;
      }
#line 2151
      channel->lastvolslide = (signed char )v___1;
#line 2153
      channel->volume = (unsigned char )((int )channel->volume + (int )v___1);
#line 2154
      if ((int )channel->volume > 64) {
#line 2154
        channel->volume = (unsigned char)64;
      }
    } else
#line 2155
    if ((int )entry->volpan <= 84) {
#line 2157
      v___2 = (unsigned char )((int )entry->volpan - 75);
#line 2158
      if ((int )v___2 == 0) {
#line 2159
        v___2 = (unsigned char )channel->lastvolslide;
      }
#line 2160
      channel->lastvolslide = (signed char )v___2;
#line 2162
      channel->volume = (unsigned char )((int )channel->volume - (int )v___2);
#line 2163
      if ((int )channel->volume > 64) {
#line 2163
        channel->volume = (unsigned char)0;
      }
    } else
#line 2164
    if (! ((int )entry->volpan < 128)) {
#line 2169
      if ((int )entry->volpan <= 192) {
#line 2171
        channel->pan = (unsigned char )((int )entry->volpan - 128);
#line 2172
        channel->truepan = (unsigned short )((int )channel->pan << 8);
      }
    }
  }
#line 2178
  return (0);
}
}
#line 2183 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void retrigger_xm_envelopes(IT_PLAYING *playing ) 
{ 


  {
#line 2185
  playing->volume_envelope.next_node = 0;
#line 2186
  playing->volume_envelope.tick = -1;
#line 2187
  playing->pan_envelope.next_node = 0;
#line 2188
  playing->pan_envelope.tick = -1;
#line 2189
  playing->fadeoutcount = 1024;
#line 2190
  return;
}
}
#line 2194 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void process_xm_note_data(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_CHANNEL *channel ;
  void *tmp ;
  unsigned char v ;
  unsigned char v___0 ;
  int effect ;
  int value ;

  {
#line 2196
  sigdata = sigrenderer->sigdata;
#line 2197
  channel = & sigrenderer->channel[(int )entry->channel];
#line 2199
  if ((int )entry->mask & 2) {
    {
#line 2200
    channel->instrument = entry->instrument;
#line 2201
    instrument_to_sample(sigdata, channel);
    }
#line 2202
    if (channel->playing) {
      {
#line 2206
      (channel->playing)->flags &= -7;
#line 2207
      it_playing_update_resamplers(channel->playing);
#line 2209
      channel->volume = ((channel->playing)->sample)->default_volume;
      }
#line 2210
      if (! (sigdata->flags & 128)) {
#line 2211
        channel->truepan = (unsigned short )(32 + (int )((channel->playing)->sample)->default_pan * 64);
      }
      {
#line 2213
      retrigger_xm_envelopes(channel->playing);
      }
    }
  }
#line 2217
  if ((int )entry->mask & 8) {
#line 2217
    if ((int )entry->effect == 32) {
#line 2217
      if (! ((int )entry->effectvalue == 0)) {
#line 2217
        goto _L___4;
      }
    } else {
#line 2217
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2217
  if ((int )entry->mask & 1) {
#line 2220
    if (! ((int )entry->mask & 2)) {
      {
#line 2221
      instrument_to_sample(sigdata, channel);
      }
    }
#line 2223
    if ((int )channel->note >= 120) {
      {
#line 2224
      xm_note_off(sigdata, channel);
      }
    } else
#line 2225
    if ((int )channel->sample == 0) {
#line 2235
      if (channel->playing) {
        {
#line 2236
        free((void *)channel->playing);
#line 2237
        channel->playing = (IT_PLAYING *)((void *)0);
        }
      }
#line 2239
      return;
    } else
#line 2240
    if (channel->playing) {
#line 2240
      if ((int )entry->mask & 4) {
#line 2240
        if (! ((int )entry->volpan >> 4 == 15)) {
#line 2240
          goto _L___2;
        }
      } else {
#line 2240
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2242
    if (channel->playing) {
#line 2242
      if ((int )entry->mask & 8) {
#line 2242
        if (! ((int )entry->effect == 7)) {
#line 2242
          if (! ((int )entry->effect == 12)) {
#line 2242
            goto _L___0;
          }
        }
      } else {
#line 2242
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2248
      channel->destnote = (unsigned char)255;
#line 2250
      if (! channel->playing) {
        {
#line 2251
        tmp = malloc(sizeof(*(channel->playing)));
#line 2251
        channel->playing = (IT_PLAYING *)tmp;
        }
#line 2252
        if (! channel->playing) {
#line 2253
          return;
        }
        {
#line 2255
        retrigger_xm_envelopes(channel->playing);
        }
      }
#line 2258
      (channel->playing)->flags = 0;
#line 2259
      (channel->playing)->channel = channel;
#line 2260
      (channel->playing)->sample = sigdata->sample + ((int )channel->sample - 1);
#line 2261
      if (sigdata->flags & 4) {
#line 2262
        (channel->playing)->instrument = sigdata->instrument + ((int )channel->instrument - 1);
      } else {
#line 2264
        (channel->playing)->instrument = (IT_INSTRUMENT *)((void *)0);
      }
      {
#line 2265
      (channel->playing)->env_instrument = (channel->playing)->instrument;
#line 2266
      (channel->playing)->sampnum = channel->sample;
#line 2267
      (channel->playing)->instnum = channel->instrument;
#line 2268
      (channel->playing)->channel_volume = channel->channelvolume;
#line 2269
      (channel->playing)->note = channel->truenote;
#line 2270
      (channel->playing)->filter_cutoff = (unsigned char)127;
#line 2271
      (channel->playing)->filter_resonance = (unsigned char)0;
#line 2272
      (channel->playing)->true_filter_cutoff = (unsigned short )(127 << 8);
#line 2273
      (channel->playing)->true_filter_resonance = (unsigned char)0;
#line 2274
      (channel->playing)->vibrato_speed = (unsigned char)0;
#line 2275
      (channel->playing)->vibrato_depth = (unsigned char)0;
#line 2276
      (channel->playing)->vibrato_n = (unsigned char)0;
#line 2277
      (channel->playing)->vibrato_time = (unsigned char)0;
#line 2278
      (channel->playing)->tremolo_speed = (unsigned char)0;
#line 2279
      (channel->playing)->tremolo_depth = (unsigned char)0;
#line 2280
      (channel->playing)->tremolo_time = (unsigned char)0;
#line 2281
      (channel->playing)->sample_vibrato_time = (unsigned char)0;
#line 2282
      (channel->playing)->sample_vibrato_depth = 0;
#line 2283
      (channel->playing)->slide = 0;
#line 2284
      it_reset_filter_state(& (channel->playing)->filter_state[0]);
#line 2285
      it_reset_filter_state(& (channel->playing)->filter_state[1]);
#line 2286
      it_playing_reset_resamplers(channel->playing, 0L);
      }
    }
  }
#line 2292
  if ((int )entry->mask & 8) {
#line 2292
    if ((int )entry->effect == 32) {
#line 2292
      if (! ((int )entry->effectvalue == 0)) {
#line 2292
        goto _L___6;
      }
    } else {
#line 2292
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2292
  if (((int )entry->mask & 3) == 3) {
#line 2295
    if (channel->playing) {
      {
#line 2295
      retrigger_xm_envelopes(channel->playing);
      }
    }
    {
#line 2296
    get_default_volpan(sigdata, channel);
    }
  }
#line 2299
  if ((int )entry->mask & 4) {
#line 2299
    if ((int )entry->volpan >> 4 == 15) {
#line 2301
      v = (unsigned char )(((int )entry->volpan & 15) << 4);
#line 2302
      if ((int )v == 0) {
#line 2303
        v = channel->lastG;
      }
#line 2304
      channel->lastG = v;
#line 2305
      if ((int )entry->mask & 1) {
#line 2306
        if (channel->sample) {
#line 2307
          channel->destnote = channel->truenote;
        }
      }
#line 2308
      channel->toneporta = (int )v << 4;
    } else {
#line 2299
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 2309
  if ((int )entry->mask & 8) {
#line 2309
    if ((int )entry->effect == 7) {
#line 2309
      goto _L___7;
    } else
#line 2309
    if ((int )entry->effect == 12) {
      _L___7: /* CIL Label */ 
#line 2313
      if ((int )entry->effect == 7) {
#line 2314
        v___0 = entry->effectvalue;
      } else {
#line 2316
        v___0 = (unsigned char)0;
      }
#line 2317
      if ((int )v___0 == 0) {
#line 2318
        v___0 = channel->lastG;
      }
#line 2319
      channel->lastG = v___0;
#line 2320
      if ((int )entry->mask & 1) {
#line 2321
        if (channel->sample) {
#line 2322
          channel->destnote = channel->truenote;
        }
      }
#line 2323
      channel->toneporta = (int )v___0 << 4;
    }
  }
#line 2326
  if ((int )entry->mask & 4) {
#line 2327
    effect = (int )entry->volpan >> 4;
#line 2328
    value = (int )entry->volpan & 15;
    {
#line 2330
    if (effect == 6) {
#line 2330
      goto case_6;
    }
#line 2333
    if (effect == 7) {
#line 2333
      goto case_7;
    }
#line 2336
    if (effect == 8) {
#line 2336
      goto case_8;
    }
#line 2340
    if (effect == 9) {
#line 2340
      goto case_9;
    }
#line 2344
    if (effect == 10) {
#line 2344
      goto case_10;
    }
#line 2350
    if (effect == 11) {
#line 2350
      goto case_11;
    }
#line 2359
    if (effect == 12) {
#line 2359
      goto case_12;
    }
#line 2362
    if (effect == 13) {
#line 2362
      goto case_13;
    }
#line 2368
    if (effect == 14) {
#line 2368
      goto case_14;
    }
#line 2371
    if (effect == 15) {
#line 2371
      goto case_15;
    }
#line 2373
    goto switch_default;
    case_6: /* CIL Label */ 
#line 2331
    channel->xm_volslide = (signed char )(- value);
#line 2332
    goto switch_break;
    case_7: /* CIL Label */ 
#line 2334
    channel->xm_volslide = (signed char )value;
#line 2335
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2337
    channel->volume = (unsigned char )((int )channel->volume - value);
#line 2338
    if ((int )channel->volume > 64) {
#line 2338
      channel->volume = (unsigned char)0;
    }
#line 2339
    goto switch_break;
    case_9: /* CIL Label */ 
#line 2341
    channel->volume = (unsigned char )((int )channel->volume + value);
#line 2342
    if ((int )channel->volume > 64) {
#line 2342
      channel->volume = (unsigned char)64;
    }
#line 2343
    goto switch_break;
    case_10: /* CIL Label */ 
#line 2345
    if (value) {
#line 2346
      channel->lastHspeed = (unsigned char )value;
    }
#line 2347
    if (channel->playing) {
#line 2348
      (channel->playing)->vibrato_speed = channel->lastHspeed;
    }
#line 2349
    goto switch_break;
    case_11: /* CIL Label */ 
#line 2351
    if (value) {
#line 2352
      channel->lastHdepth = (unsigned char )(value << 2);
    }
#line 2353
    if (channel->playing) {
#line 2354
      (channel->playing)->vibrato_depth = channel->lastHdepth;
#line 2355
      (channel->playing)->vibrato_speed = channel->lastHspeed;
#line 2356
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
#line 2358
    goto switch_break;
    case_12: /* CIL Label */ 
#line 2360
    channel->truepan = (unsigned short )(32 + value * 1088);
#line 2361
    goto switch_break;
    case_13: /* CIL Label */ 
#line 2366
    if (value) {
#line 2366
      channel->panslide = (signed char )(- value);
    } else {
#line 2366
      channel->panslide = (signed char)-128;
    }
#line 2367
    goto switch_break;
    case_14: /* CIL Label */ 
#line 2369
    channel->panslide = (signed char )value;
#line 2370
    goto switch_break;
    case_15: /* CIL Label */ 
#line 2372
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2374
    channel->volume = (unsigned char )((int )entry->volpan - 16);
#line 2375
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2378
  return;
}
}
#line 2383 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_note_data(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ,
                             int ignore_cxx ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int tmp ;
  int tmp___0 ;

  {
#line 2385
  sigdata = sigrenderer->sigdata;
#line 2387
  if (sigdata->flags & 64) {
    {
#line 2388
    process_xm_note_data(sigrenderer, entry);
    }
  } else {
    {
#line 2390
    tmp = process_it_note_data(sigrenderer, entry);
    }
#line 2390
    if (tmp) {
#line 2390
      return (0);
    }
  }
  {
#line 2392
  tmp___0 = process_effects(sigrenderer, entry, ignore_cxx);
  }
#line 2392
  return (tmp___0);
}
}
#line 2397 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_entry(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry , int ignore_cxx ) 
{ 
  IT_CHANNEL *channel ;
  unsigned char effectvalue ;
  int tmp ;

  {
#line 2399
  channel = & sigrenderer->channel[(int )entry->channel];
#line 2401
  if ((int )entry->mask & 1) {
#line 2402
    channel->note = entry->note;
  }
#line 2404
  if ((int )entry->mask & 8) {
#line 2404
    if ((int )entry->effect == 19) {
#line 2406
      effectvalue = channel->lastS;
#line 2407
      if ((int )effectvalue >> 4 == 13) {
#line 2408
        channel->note_delay_count = (unsigned char )((int )effectvalue & 15);
#line 2409
        if ((int )channel->note_delay_count == 0) {
#line 2410
          channel->note_delay_count = (unsigned char)1;
        }
#line 2411
        channel->note_delay_entry = entry;
#line 2412
        return (0);
      }
    }
  }
  {
#line 2416
  tmp = process_note_data(sigrenderer, entry, ignore_cxx);
  }
#line 2416
  return (tmp);
}
}
#line 2421 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_tick_counts(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;

  {
#line 2425
  i = 0;
  {
#line 2425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2425
    if (! (i < 64)) {
#line 2425
      goto while_break;
    }
#line 2426
    channel = & sigrenderer->channel[i];
#line 2428
    if (channel->key_off_count) {
#line 2429
      channel->key_off_count = (unsigned char )((int )channel->key_off_count - 1);
#line 2430
      if ((int )channel->key_off_count == 0) {
        {
#line 2431
        xm_note_off(sigrenderer->sigdata, channel);
        }
      }
    } else
#line 2432
    if (channel->note_cut_count) {
#line 2433
      channel->note_cut_count = (unsigned char )((int )channel->note_cut_count - 1);
#line 2434
      if ((int )channel->note_cut_count == 0) {
#line 2435
        if ((sigrenderer->sigdata)->flags & 64) {
#line 2436
          channel->volume = (unsigned char)0;
        } else
#line 2437
        if (channel->playing) {
          {
#line 2438
          free((void *)channel->playing);
#line 2439
          channel->playing = (IT_PLAYING *)((void *)0);
          }
        }
      }
    } else
#line 2442
    if (channel->note_delay_count) {
#line 2443
      channel->note_delay_count = (unsigned char )((int )channel->note_delay_count - 1);
#line 2444
      if ((int )channel->note_delay_count == 0) {
        {
#line 2445
        process_note_data(sigrenderer, channel->note_delay_entry, 0);
        }
      }
    }
#line 2425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2451
  return;
}
}
#line 2455 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int envelope_get_y(IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 


  {
#line 2459
  return (pe->value);
}
}
#line 2514 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int update_it_envelope(IT_PLAYING *playing , IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 
  int ys ;
  int ts ;
  int te ;
  int ye ;
  int t ;

  {
#line 2516
  if (! ((int )envelope->flags & 1)) {
#line 2517
    return (0);
  }
#line 2521
  if (pe->next_node <= 0) {
#line 2522
    pe->value = (int )envelope->node_y[0] << 8;
  } else
#line 2523
  if (pe->next_node >= (int )envelope->n_nodes) {
#line 2524
    pe->value = (int )envelope->node_y[(int )envelope->n_nodes - 1] << 8;
#line 2525
    return (1);
  } else {
#line 2527
    ys = (int )envelope->node_y[pe->next_node - 1] << 8;
#line 2528
    ts = (int )envelope->node_t[pe->next_node - 1];
#line 2529
    te = (int )envelope->node_t[pe->next_node];
#line 2531
    if (ts == te) {
#line 2532
      pe->value = ys;
    } else {
#line 2534
      ye = (int )envelope->node_y[pe->next_node] << 8;
#line 2535
      t = pe->tick;
#line 2537
      pe->value = ys + ((ye - ys) * (t - ts)) / (te - ts);
    }
  }
#line 2541
  (pe->tick) ++;
  {
#line 2542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2542
    if (! (pe->tick >= (int )envelope->node_t[pe->next_node])) {
#line 2542
      goto while_break;
    }
#line 2543
    (pe->next_node) ++;
#line 2544
    if ((int )envelope->flags & 4) {
#line 2544
      if (! (playing->flags & 2)) {
#line 2545
        if (pe->next_node > (int )envelope->sus_loop_end) {
#line 2546
          pe->next_node = (int )envelope->sus_loop_start;
#line 2548
          pe->tick = (int )envelope->node_t[envelope->sus_loop_start];
#line 2549
          return (0);
        }
      } else {
#line 2544
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2551
    if ((int )envelope->flags & 2) {
#line 2552
      if (pe->next_node > (int )envelope->loop_end) {
#line 2553
        pe->next_node = (int )envelope->loop_start;
#line 2555
        pe->tick = (int )envelope->node_t[envelope->loop_start];
#line 2556
        return (0);
      }
    }
#line 2559
    if (pe->next_node >= (int )envelope->n_nodes) {
#line 2560
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2562
  return (0);
}
}
#line 2567 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_it_envelopes(IT_PLAYING *playing ) 
{ 
  IT_ENVELOPE *envelope ;
  IT_PLAYING_ENVELOPE *pe ;
  int tmp ;

  {
  {
#line 2569
  envelope = & (playing->env_instrument)->volume_envelope;
#line 2570
  pe = & playing->volume_envelope;
#line 2572
  tmp = update_it_envelope(playing, envelope, pe);
  }
#line 2572
  if (tmp) {
#line 2573
    playing->flags |= 4;
#line 2574
    if (pe->value == 0) {
#line 2575
      playing->flags |= 8;
    }
  }
  {
#line 2578
  update_it_envelope(playing, & (playing->env_instrument)->pan_envelope, & playing->pan_envelope);
#line 2579
  update_it_envelope(playing, & (playing->env_instrument)->pitch_envelope, & playing->pitch_envelope);
  }
#line 2580
  return;
}
}
#line 2584 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int xm_envelope_is_sustaining(IT_PLAYING *playing , IT_ENVELOPE *envelope ,
                                     IT_PLAYING_ENVELOPE *pe ) 
{ 


  {
#line 2586
  if ((int )envelope->flags & 4) {
#line 2586
    if (! (playing->flags & 2)) {
#line 2587
      if ((int )envelope->sus_loop_start < (int )envelope->n_nodes) {
#line 2588
        if (pe->tick == (int )envelope->node_t[envelope->sus_loop_start]) {
#line 2589
          return (1);
        }
      }
    }
  }
#line 2590
  return (0);
}
}
#line 2595 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_xm_envelope(IT_PLAYING *playing , IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2597
  if (! ((int )envelope->flags & 1)) {
#line 2598
    return;
  }
  {
#line 2600
  tmp = xm_envelope_is_sustaining(playing, envelope, pe);
  }
#line 2600
  if (tmp) {
#line 2601
    return;
  }
#line 2603
  if (pe->tick >= (int )envelope->node_t[(int )envelope->n_nodes - 1]) {
#line 2604
    return;
  }
#line 2606
  (pe->tick) ++;
  {
#line 2609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2609
    if (! (pe->tick > (int )envelope->node_t[pe->next_node])) {
#line 2609
      goto while_break;
    }
#line 2610
    (pe->next_node) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2612
  if ((int )envelope->flags & 2) {
#line 2612
    if ((int )envelope->loop_end < (int )envelope->n_nodes) {
#line 2613
      if (pe->tick == (int )envelope->node_t[envelope->loop_end]) {
#line 2614
        if ((int )envelope->loop_start < (int )envelope->n_nodes - 1) {
#line 2614
          tmp___2 = (int )envelope->loop_start;
        } else {
#line 2614
          tmp___2 = (int )envelope->n_nodes - 1;
        }
#line 2614
        if (0 > tmp___2) {
#line 2614
          pe->next_node = 0;
        } else {
#line 2614
          if ((int )envelope->loop_start < (int )envelope->n_nodes - 1) {
#line 2614
            tmp___1 = (int )envelope->loop_start;
          } else {
#line 2614
            tmp___1 = (int )envelope->n_nodes - 1;
          }
#line 2614
          pe->next_node = tmp___1;
        }
#line 2615
        pe->tick = (int )envelope->node_t[pe->next_node];
      }
    }
  }
  {
#line 2619
  xm_envelope_calculate_value(envelope, pe);
  }
#line 2620
  return;
}
}
#line 2624 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_xm_envelopes(IT_PLAYING *playing ) 
{ 


  {
  {
#line 2626
  update_xm_envelope(playing, & (playing->env_instrument)->volume_envelope, & playing->volume_envelope);
#line 2627
  update_xm_envelope(playing, & (playing->env_instrument)->pan_envelope, & playing->pan_envelope);
  }
#line 2628
  return;
}
}
#line 2632 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_fadeout(DUMB_IT_SIGDATA *sigdata , IT_PLAYING *playing ) 
{ 


  {
#line 2634
  if (playing->flags & 4) {
#line 2635
    playing->fadeoutcount -= (playing->env_instrument)->fadeout;
#line 2636
    if (playing->fadeoutcount <= 0) {
#line 2637
      playing->fadeoutcount = 0;
#line 2638
      if (! (sigdata->flags & 64)) {
#line 2639
        playing->flags |= 8;
      }
    }
  }
#line 2642
  return;
}
}
#line 2646 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void process_playing(DUMB_IT_SIGDATA *sigdata , IT_PLAYING *playing ) 
{ 


  {
#line 2648
  if (playing->instrument) {
#line 2649
    if (sigdata->flags & 64) {
      {
#line 2650
      update_xm_envelopes(playing);
      }
    } else {
      {
#line 2652
      update_it_envelopes(playing);
      }
    }
    {
#line 2653
    update_fadeout(sigdata, playing);
    }
  }
#line 2659
  if (sigdata->flags & 64) {
#line 2661
    if (playing->sample_vibrato_depth < (int )(playing->sample)->vibrato_rate) {
#line 2662
      (playing->sample_vibrato_depth) ++;
    }
  } else {
#line 2664
    playing->sample_vibrato_depth += (int )(playing->sample)->vibrato_rate;
#line 2665
    if (playing->sample_vibrato_depth > (int )(playing->sample)->vibrato_depth << 8) {
#line 2666
      playing->sample_vibrato_depth = (int )(playing->sample)->vibrato_depth << 8;
    }
  }
#line 2669
  playing->sample_vibrato_time = (unsigned char )((int )playing->sample_vibrato_time + (int )(playing->sample)->vibrato_speed);
#line 2670
  return;
}
}
#line 2674 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void process_all_playing(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int i ;
  IT_CHANNEL *channel ;
  IT_PLAYING *playing ;
  int vibrato_shift ;
  int currpitch ;
  double tmp ;
  int slide ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 2676
  sigdata = sigrenderer->sigdata;
#line 2679
  i = 0;
  {
#line 2679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2679
    if (! (i < 64)) {
#line 2679
      goto while_break;
    }
#line 2680
    channel = & sigrenderer->channel[i];
#line 2681
    playing = channel->playing;
#line 2683
    if (playing) {
#line 2684
      vibrato_shift = (int )it_sine[playing->vibrato_time];
#line 2685
      vibrato_shift *= (int )playing->vibrato_n;
#line 2686
      vibrato_shift *= (int )playing->vibrato_depth;
#line 2687
      vibrato_shift >>= 4;
#line 2689
      if (sigdata->flags & 16) {
#line 2690
        vibrato_shift = - vibrato_shift;
      }
#line 2692
      playing->volume = channel->volume;
#line 2693
      playing->pan = channel->truepan;
#line 2695
      if (sigdata->flags & 8) {
#line 2696
        currpitch = ((((int )playing->note - 60) << 8) + playing->slide) + vibrato_shift;
#line 2703
        if (currpitch < -32768) {
#line 2704
          currpitch = -32768;
        } else
#line 2705
        if (currpitch > 32767) {
#line 2706
          currpitch = 32767;
        }
        {
#line 2708
        tmp = pow(1.000225659305069791926712241547647863626, (double )currpitch);
#line 2708
        playing->delta = (float )tmp;
#line 2709
        playing->delta *= (float )(playing->sample)->C5_speed / 65536.0f;
        }
      } else {
        {
#line 2711
        slide = playing->slide + vibrato_shift;
#line 2713
        tmp___0 = pow(1.059463094359295309843105314939748495817, (double )(60 - (int )playing->note));
#line 2713
        playing->delta = (float )tmp___0;
#line 2716
        playing->delta *= 1.0f / (float )(playing->sample)->C5_speed;
#line 2718
        playing->delta -= (float )slide / (float )(8.0 * 7159090.5);
        }
#line 2720
        if (playing->delta < (1.0f / 65536.0f) / 32768.0f) {
#line 2722
          playing->flags |= 8;
#line 2723
          goto __Cont;
        }
#line 2726
        playing->delta = (1.0f / 65536.0f) / playing->delta;
      }
      {
#line 2729
      tmp___1 = pow(1.059463094359295309843105314939748495817, (double )(channel->arpeggio >> 8));
#line 2729
      playing->delta *= (float )tmp___1;
#line 2731
      playing->filter_cutoff = channel->filter_cutoff;
#line 2732
      playing->filter_resonance = channel->filter_resonance;
      }
    }
    __Cont: /* CIL Label */ 
#line 2679
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2736
  i = 0;
  {
#line 2736
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2736
    if (! (i < 64)) {
#line 2736
      goto while_break___0;
    }
#line 2737
    if (sigrenderer->channel[i].playing) {
      {
#line 2738
      process_playing(sigdata, sigrenderer->channel[i].playing);
      }
#line 2739
      if (! (sigdata->flags & 64)) {
#line 2742
        if ((sigrenderer->channel[i].playing)->flags & 8) {
          {
#line 2743
          free((void *)sigrenderer->channel[i].playing);
#line 2744
          sigrenderer->channel[i].playing = (IT_PLAYING *)((void *)0);
          }
        }
      }
    }
#line 2736
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2750
  i = 0;
  {
#line 2750
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2750
    if (! (i < 192)) {
#line 2750
      goto while_break___1;
    }
#line 2751
    if (sigrenderer->playing[i]) {
      {
#line 2752
      process_playing(sigdata, sigrenderer->playing[i]);
      }
#line 2753
      if ((sigrenderer->playing[i])->flags & 8) {
        {
#line 2754
        free((void *)sigrenderer->playing[i]);
#line 2755
        sigrenderer->playing[i] = (IT_PLAYING *)((void *)0);
        }
      }
    }
#line 2750
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2759
  return;
}
}
#line 2763 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_tick(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_PATTERN *pattern ;
  int n ;
  int processorder ;
  IT_ENTRY *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  IT_ENTRY *entry ;
  int ignore_cxx ;
  IT_ENTRY *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  IT_ENTRY *tmp___5 ;
  int tmp___6 ;
  IT_ENTRY *entry___0 ;
  IT_ENTRY *tmp___7 ;
  long long t ;

  {
#line 2765
  sigdata = sigrenderer->sigdata;
#line 2769
  if (sigrenderer->speed) {
#line 2769
    (sigrenderer->tick) --;
#line 2769
    if (sigrenderer->tick == 0) {
      {
#line 2770
      reset_tick_counts(sigrenderer);
#line 2771
      sigrenderer->tick = sigrenderer->speed;
#line 2772
      (sigrenderer->rowcount) --;
      }
#line 2773
      if (sigrenderer->rowcount == 0) {
#line 2774
        sigrenderer->rowcount = 1;
#line 2776
        (sigrenderer->processrow) ++;
#line 2778
        if (sigrenderer->processrow >= sigrenderer->n_rows) {
#line 2781
          processorder = sigrenderer->processorder;
#line 2783
          if (sigrenderer->processrow == 65535) {
#line 2784
            sigrenderer->processrow = sigrenderer->breakrow;
#line 2785
            sigrenderer->breakrow = 0;
#line 2786
            n = 0;
            {
#line 2786
            while (1) {
              while_continue: /* CIL Label */ ;
#line 2786
              if (! (n < 64)) {
#line 2786
                goto while_break;
              }
#line 2786
              sigrenderer->channel[n].pat_loop_end_row = (unsigned char)0;
#line 2786
              n ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 2788
            sigrenderer->processrow = sigrenderer->breakrow;
          }
#line 2790
          if (sigrenderer->processorder == 65535) {
#line 2791
            sigrenderer->processorder = sigrenderer->order - 1;
          }
          {
#line 2793
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2794
            (sigrenderer->processorder) ++;
#line 2796
            if (sigrenderer->processorder >= sigdata->n_orders) {
#line 2797
              sigrenderer->processorder = (int )sigdata->restart_position;
#line 2798
              if (sigrenderer->processorder >= sigdata->n_orders) {
#line 2800
                sigrenderer->processorder = -1;
#line 2801
                goto __Cont;
              }
            }
#line 2805
            n = (int )*(sigdata->order + sigrenderer->processorder);
#line 2807
            if (n < sigdata->n_patterns) {
#line 2808
              goto while_break___0;
            }
#line 2811
            if (n != 254) {
#line 2812
              sigrenderer->processorder = -1;
            }
            __Cont: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2819
          pattern = sigdata->pattern + n;
#line 2821
          n = sigrenderer->n_rows;
#line 2822
          sigrenderer->n_rows = pattern->n_rows;
#line 2824
          if (sigrenderer->processrow >= sigrenderer->n_rows) {
#line 2825
            sigrenderer->processrow = 0;
          }
#line 2829
          tmp = pattern->entry;
#line 2829
          sigrenderer->entry_start = tmp;
#line 2829
          sigrenderer->entry = tmp;
#line 2830
          sigrenderer->entry_end = sigrenderer->entry + pattern->n_entries;
#line 2833
          if (n) {
#line 2833
            if (processorder == 65535) {
#line 2833
              tmp___1 = sigrenderer->order > sigrenderer->processorder;
            } else {
#line 2833
              tmp___1 = sigrenderer->order >= sigrenderer->processorder;
            }
#line 2833
            if (tmp___1) {
#line 2834
              if ((sigrenderer->callbacks)->loop) {
                {
#line 2835
                tmp___0 = (*((sigrenderer->callbacks)->loop))((sigrenderer->callbacks)->loop_data);
                }
#line 2835
                if (tmp___0) {
#line 2836
                  return (1);
                }
#line 2837
                if (sigrenderer->speed == 0) {
#line 2838
                  goto speed0;
                }
              }
            }
          }
#line 2841
          sigrenderer->order = sigrenderer->processorder;
#line 2843
          n = sigrenderer->processrow;
          {
#line 2844
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2844
            if (! n) {
#line 2844
              goto while_break___1;
            }
            {
#line 2845
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2845
              if (! ((unsigned long )sigrenderer->entry < (unsigned long )sigrenderer->entry_end)) {
#line 2845
                goto while_break___2;
              }
#line 2846
              if ((int )(sigrenderer->entry)->channel >= 64) {
#line 2847
                (sigrenderer->entry) ++;
#line 2848
                goto while_break___2;
              }
#line 2850
              (sigrenderer->entry) ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2852
            n --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2854
          sigrenderer->row = sigrenderer->processrow;
        } else
#line 2856
        if (sigrenderer->entry) {
          {
#line 2857
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2857
            if (! ((unsigned long )sigrenderer->entry < (unsigned long )sigrenderer->entry_end)) {
#line 2857
              goto while_break___3;
            }
#line 2858
            if ((int )(sigrenderer->entry)->channel >= 64) {
#line 2859
              (sigrenderer->entry) ++;
#line 2860
              goto while_break___3;
            }
#line 2862
            (sigrenderer->entry) ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2864
          (sigrenderer->row) ++;
        } else {
#line 2866
          sigrenderer->entry = sigrenderer->entry_start;
#line 2867
          sigrenderer->row = 0;
        }
        {
#line 2871
        reset_effects(sigrenderer);
#line 2874
        entry = sigrenderer->entry;
#line 2875
        ignore_cxx = 0;
        }
        {
#line 2877
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2877
          if ((unsigned long )entry < (unsigned long )sigrenderer->entry_end) {
#line 2877
            if (! (! ((int )entry->channel >= 64))) {
#line 2877
              goto while_break___4;
            }
          } else {
#line 2877
            goto while_break___4;
          }
          {
#line 2878
          tmp___2 = entry;
#line 2878
          entry ++;
#line 2878
          tmp___3 = update_pattern_variables(sigrenderer, tmp___2);
#line 2878
          ignore_cxx |= tmp___3;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2880
        entry = sigrenderer->entry;
        {
#line 2882
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2882
          if ((unsigned long )entry < (unsigned long )sigrenderer->entry_end) {
#line 2882
            if (! (! ((int )entry->channel >= 64))) {
#line 2882
              goto while_break___5;
            }
          } else {
#line 2882
            goto while_break___5;
          }
#line 2883
          if (sigdata->flags & 64) {
#line 2883
            tmp___4 = 0;
          } else {
#line 2883
            tmp___4 = ignore_cxx;
          }
          {
#line 2883
          tmp___5 = entry;
#line 2883
          entry ++;
#line 2883
          tmp___6 = process_entry(sigrenderer, tmp___5, tmp___4);
          }
#line 2883
          if (tmp___6) {
#line 2884
            return (1);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2887
        if (! (sigdata->flags & 16)) {
          {
#line 2888
          update_smooth_effects(sigrenderer);
          }
        }
      } else {
#line 2891
        entry___0 = sigrenderer->entry;
        {
#line 2893
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2893
          if ((unsigned long )entry___0 < (unsigned long )sigrenderer->entry_end) {
#line 2893
            if (! (! ((int )entry___0->channel >= 64))) {
#line 2893
              goto while_break___6;
            }
          } else {
#line 2893
            goto while_break___6;
          }
          {
#line 2894
          tmp___7 = entry___0;
#line 2894
          entry___0 ++;
#line 2894
          process_effects(sigrenderer, tmp___7, 0);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 2900
        update_effects(sigrenderer);
        }
      }
    } else {
#line 2769
      goto speed0;
    }
  } else {
    speed0: 
    {
#line 2904
    update_effects(sigrenderer);
#line 2905
    update_tick_counts(sigrenderer);
    }
  }
  {
#line 2908
  process_all_playing(sigrenderer);
#line 2911
  t = (long long )sigrenderer->sub_time_left + (163840LL << 16) / (long long )sigrenderer->tempo;
#line 2912
  sigrenderer->time_left += (long )((int )(t >> 16));
#line 2913
  sigrenderer->sub_time_left = (int )t & 65535;
  }
#line 2916
  return (0);
}
}
#line 2921 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
int dumb_it_max_to_mix  =    64;
#line 2925 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static float calculate_volume(DUMB_IT_SIGRENDERER *sigrenderer , IT_PLAYING *playing ,
                              float volume ) 
{ 
  int vol ;
  int tmp ;

  {
#line 2927
  if (volume != (float )0) {
#line 2930
    if ((playing->channel)->flags & 1) {
#line 2931
      return ((float )0);
    }
#line 2933
    if (((int )(playing->channel)->tremor_time & 192) == 128) {
#line 2934
      return ((float )0);
    }
#line 2936
    vol = (int )it_sine[playing->tremolo_time];
#line 2937
    vol *= (int )playing->tremolo_depth;
#line 2939
    vol = ((int )playing->volume << 5) + vol;
#line 2941
    if (vol <= 0) {
#line 2942
      return ((float )0);
    }
#line 2944
    if (vol > 64 << 5) {
#line 2945
      vol = 64 << 5;
    }
#line 2947
    volume *= (float )vol;
#line 2948
    volume *= (float )(playing->sample)->global_volume;
#line 2949
    volume *= (float )playing->channel_volume;
#line 2950
    volume *= (float )sigrenderer->globalvolume;
#line 2951
    volume *= (float )(sigrenderer->sigdata)->mixing_volume;
#line 2952
    volume *= 1.0f / (((((float )(64 << 5) * 64.0f) * 64.0f) * 128.0f) * 128.0f);
#line 2954
    if (volume) {
#line 2954
      if (playing->instrument) {
#line 2955
        if ((int )(playing->env_instrument)->volume_envelope.flags & 1) {
          {
#line 2956
          tmp = envelope_get_y(& (playing->env_instrument)->volume_envelope, & playing->volume_envelope);
#line 2956
          volume *= (float )tmp;
#line 2957
          volume *= 1.0f / (float )(64 << 8);
          }
        }
#line 2959
        volume *= (float )(playing->instrument)->global_volume;
#line 2960
        volume *= (float )playing->fadeoutcount;
#line 2961
        volume *= 1.0f / (128.0f * 1024.0f);
      }
    }
  }
#line 2965
  return (volume);
}
}
#line 2970 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int apply_pan_envelope(IT_PLAYING *playing ) 
{ 
  int pan ;
  int p ;
  int tmp ;

  {
#line 2972
  pan = (int )playing->pan;
#line 2973
  if (pan <= 64 << 8) {
#line 2973
    if (playing->env_instrument) {
#line 2973
      if ((int )(playing->env_instrument)->pan_envelope.flags & 1) {
        {
#line 2974
        tmp = envelope_get_y(& (playing->env_instrument)->pan_envelope, & playing->pan_envelope);
#line 2974
        p = tmp;
        }
#line 2975
        if (pan > 32 << 8) {
#line 2976
          p *= (64 << 8) - pan;
        } else {
#line 2978
          p *= pan;
        }
#line 2979
        pan += p >> 13;
      }
    }
  }
#line 2981
  return (pan);
}
}
#line 2989 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static long render_playing(DUMB_IT_SIGRENDERER *sigrenderer , IT_PLAYING *playing ,
                           float volume , float delta , long pos , long size , sample_t **samples ,
                           int store_end_sample , int *left_to_mix ) 
{ 
  int bits ;
  int pan ;
  float span ;
  long size_rendered ;
  float lvol ;
  float rvol ;
  sample_t click[2] ;
  sample_t click___0[2] ;
  sample_t click___1[2] ;
  sample_t click___2[2] ;
  sample_t click___3[2] ;
  sample_t click___4[2] ;
  float lvol___0 ;
  float rvol___0 ;
  sample_t click___5 ;
  sample_t click___6 ;
  sample_t click___7 ;
  sample_t click___8 ;

  {
#line 2998
  if (playing->flags & 8) {
#line 2999
    return (0L);
  }
#line 3001
  if (*left_to_mix <= 0) {
#line 3002
    volume = (float )0;
  }
#line 3004
  if ((int )(playing->sample)->flags & 2) {
#line 3004
    bits = 16;
  } else {
#line 3004
    bits = 8;
  }
  {
#line 3006
  pan = apply_pan_envelope(playing);
#line 3007
  span = (float )((pan - (32 << 8)) * (sigrenderer->sigdata)->pan_separation) * (1.0f / (float )((32 << 8) * 128));
  }
#line 3009
  if (volume == (float )0) {
#line 3010
    if ((int )(playing->sample)->flags & 4) {
      {
#line 3011
      size_rendered = dumb_resample_n_2_1(bits, & playing->resampler, (sample_t *)((void *)0),
                                          size, (float )0, (float )0, delta);
      }
    } else {
      {
#line 3013
      size_rendered = dumb_resample_n_1_1(bits, & playing->resampler, (sample_t *)((void *)0),
                                          size, (float )0, delta);
      }
    }
  } else {
#line 3015
    if (sigrenderer->n_channels == 2) {
#line 3017
      lvol = volume;
#line 3018
      if (! (pan > 64 << 8)) {
#line 3018
        lvol *= 1.0f - span;
      }
#line 3019
      rvol = - lvol;
#line 3020
      if (! (pan > 64 << 8)) {
#line 3020
        rvol += 2.0f * volume;
      }
#line 3021
      if ((int )(playing->sample)->flags & 4) {
#line 3022
        if (sigrenderer->click_remover) {
          {
#line 3024
          dumb_resample_get_current_sample_n_2_2(bits, & playing->resampler, lvol,
                                                 rvol, click);
#line 3025
          dumb_record_click(*(sigrenderer->click_remover + 0), pos, click[0]);
#line 3026
          dumb_record_click(*(sigrenderer->click_remover + 1), pos, click[1]);
          }
        }
        {
#line 3028
        size_rendered = dumb_resample_n_2_2(bits, & playing->resampler, *(samples + 0) + pos * 2L,
                                            size, lvol, rvol, delta);
        }
#line 3029
        if (store_end_sample) {
          {
#line 3031
          dumb_resample_get_current_sample_n_2_2(bits, & playing->resampler, lvol,
                                                 rvol, click___0);
#line 3032
          *(*(samples + 0) + (pos + size_rendered) * 2L) = click___0[0];
#line 3033
          *(*(samples + 0) + ((pos + size_rendered) * 2L + 1L)) = click___0[1];
          }
        }
#line 3035
        if (sigrenderer->click_remover) {
          {
#line 3037
          dumb_resample_get_current_sample_n_2_2(bits, & playing->resampler, lvol,
                                                 rvol, click___1);
#line 3038
          dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                            - click___1[0]);
#line 3039
          dumb_record_click(*(sigrenderer->click_remover + 1), pos + size_rendered,
                            - click___1[1]);
          }
        }
      } else {
#line 3042
        if (sigrenderer->click_remover) {
          {
#line 3044
          dumb_resample_get_current_sample_n_1_2(bits, & playing->resampler, lvol,
                                                 rvol, click___2);
#line 3045
          dumb_record_click(*(sigrenderer->click_remover + 0), pos, click___2[0]);
#line 3046
          dumb_record_click(*(sigrenderer->click_remover + 1), pos, click___2[1]);
          }
        }
        {
#line 3048
        size_rendered = dumb_resample_n_1_2(bits, & playing->resampler, *(samples + 0) + pos * 2L,
                                            size, lvol, rvol, delta);
        }
#line 3049
        if (store_end_sample) {
          {
#line 3051
          dumb_resample_get_current_sample_n_1_2(bits, & playing->resampler, lvol,
                                                 rvol, click___3);
#line 3052
          *(*(samples + 0) + (pos + size_rendered) * 2L) = click___3[0];
#line 3053
          *(*(samples + 0) + ((pos + size_rendered) * 2L + 1L)) = click___3[1];
          }
        }
#line 3055
        if (sigrenderer->click_remover) {
          {
#line 3057
          dumb_resample_get_current_sample_n_1_2(bits, & playing->resampler, lvol,
                                                 rvol, click___4);
#line 3058
          dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                            - click___4[0]);
#line 3059
          dumb_record_click(*(sigrenderer->click_remover + 1), pos + size_rendered,
                            - click___4[1]);
          }
        }
      }
    } else
#line 3063
    if ((int )(playing->sample)->flags & 4) {
#line 3065
      lvol___0 = 0.5f * volume;
#line 3066
      if (! (pan > 64 << 8)) {
#line 3066
        lvol___0 *= 1.0f - span;
      }
#line 3067
      rvol___0 = lvol___0;
#line 3068
      if (! (pan > 64 << 8)) {
#line 3068
        rvol___0 = volume - rvol___0;
      }
#line 3069
      if (sigrenderer->click_remover) {
        {
#line 3071
        dumb_resample_get_current_sample_n_2_1(bits, & playing->resampler, lvol___0,
                                               rvol___0, & click___5);
#line 3072
        dumb_record_click(*(sigrenderer->click_remover + 0), pos, click___5);
        }
      }
      {
#line 3074
      size_rendered = dumb_resample_n_2_1(bits, & playing->resampler, *(samples + 0) + pos,
                                          size, lvol___0, rvol___0, delta);
      }
#line 3075
      if (store_end_sample) {
        {
#line 3076
        dumb_resample_get_current_sample_n_2_1(bits, & playing->resampler, lvol___0,
                                               rvol___0, *(samples + 0) + (pos + size_rendered));
        }
      }
#line 3077
      if (sigrenderer->click_remover) {
        {
#line 3079
        dumb_resample_get_current_sample_n_2_1(bits, & playing->resampler, lvol___0,
                                               rvol___0, & click___6);
#line 3080
        dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                          - click___6);
        }
      }
    } else {
#line 3083
      if (sigrenderer->click_remover) {
        {
#line 3085
        dumb_resample_get_current_sample_n_1_1(bits, & playing->resampler, volume,
                                               & click___7);
#line 3086
        dumb_record_click(*(sigrenderer->click_remover + 0), pos, click___7);
        }
      }
      {
#line 3088
      size_rendered = dumb_resample_n_1_1(bits, & playing->resampler, *(samples + 0) + pos,
                                          size, volume, delta);
      }
#line 3089
      if (store_end_sample) {
        {
#line 3090
        dumb_resample_get_current_sample_n_1_1(bits, & playing->resampler, volume,
                                               *(samples + 0) + (pos + size_rendered));
        }
      }
#line 3091
      if (sigrenderer->click_remover) {
        {
#line 3093
        dumb_resample_get_current_sample_n_1_1(bits, & playing->resampler, volume,
                                               & click___8);
#line 3094
        dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                          - click___8);
        }
      }
    }
#line 3098
    (*left_to_mix) --;
  }
#line 3101
  if (playing->resampler.dir == 0) {
#line 3102
    playing->flags |= 8;
  }
#line 3104
  return (size_rendered);
}
}
#line 3118 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int it_to_mix_compare(void const   *e1 , void const   *e2 ) 
{ 


  {
#line 3120
  if (((IT_TO_MIX const   *)e1)->volume > ((IT_TO_MIX const   *)e2)->volume) {
#line 3121
    return (-1);
  }
#line 3123
  if (((IT_TO_MIX const   *)e1)->volume < ((IT_TO_MIX const   *)e2)->volume) {
#line 3124
    return (1);
  }
#line 3126
  return (0);
}
}
#line 3131 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void apply_pitch_modifications(DUMB_IT_SIGDATA *sigdata , IT_PLAYING *playing ,
                                      float *delta , int *cutoff ) 
{ 
  int sample_vibrato_shift ;
  int depth ;
  double tmp ;
  int p ;
  int tmp___0 ;
  double tmp___1 ;

  {
#line 3134
  sample_vibrato_shift = (int )it_sine[playing->sample_vibrato_time];
#line 3136
  if (sigdata->flags & 64) {
#line 3137
    depth = (int )(playing->sample)->vibrato_depth;
#line 3138
    if ((playing->sample)->vibrato_rate) {
#line 3139
      depth *= playing->sample_vibrato_depth;
#line 3140
      depth /= (int )(playing->sample)->vibrato_rate;
    }
#line 3142
    sample_vibrato_shift *= depth;
  } else {
#line 3144
    sample_vibrato_shift *= playing->sample_vibrato_depth >> 8;
  }
  {
#line 3146
  sample_vibrato_shift >>= 4;
#line 3148
  tmp = pow(1.000225659305069791926712241547647863626, (double )sample_vibrato_shift);
#line 3148
  *delta *= (float )tmp;
  }
#line 3151
  if (playing->env_instrument) {
#line 3151
    if ((int )(playing->env_instrument)->pitch_envelope.flags & 1) {
      {
#line 3154
      tmp___0 = envelope_get_y(& (playing->env_instrument)->pitch_envelope, & playing->pitch_envelope);
#line 3154
      p = tmp___0;
      }
#line 3155
      if ((int )(playing->env_instrument)->pitch_envelope.flags & 128) {
#line 3156
        *cutoff = *cutoff * (p + (32 << 8)) >> 14;
      } else {
        {
#line 3158
        tmp___1 = pow(1.000225659305069791926712241547647863626, (double )(p >> 1));
#line 3158
        *delta *= (float )tmp___1;
        }
      }
    }
  }
#line 3160
  return;
}
}
#line 3164 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void render(DUMB_IT_SIGRENDERER *sigrenderer , float volume , float delta ,
                   long pos , long size , sample_t **samples ) 
{ 
  int i ;
  int n_to_mix ;
  IT_TO_MIX to_mix[256] ;
  int left_to_mix ;
  sample_t **samples_to_filter ;
  float tmp ;
  float tmp___0 ;
  IT_PLAYING *playing ;
  float note_delta ;
  int cutoff ;
  long size_rendered ;
  DUMB_CLICK_REMOVER **cr ;
  DUMB_CLICK_REMOVER *tmp___1 ;
  DUMB_CLICK_REMOVER *tmp___2 ;
  DUMB_CLICK_REMOVER *tmp___3 ;

  {
#line 3168
  n_to_mix = 0;
#line 3170
  left_to_mix = dumb_it_max_to_mix;
#line 3172
  samples_to_filter = (sample_t **)((void *)0);
#line 3174
  i = 0;
  {
#line 3174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3174
    if (! (i < 64)) {
#line 3174
      goto while_break;
    }
#line 3175
    if (sigrenderer->channel[i].playing) {
#line 3175
      if (! ((sigrenderer->channel[i].playing)->flags & 8)) {
#line 3176
        to_mix[n_to_mix].playing = sigrenderer->channel[i].playing;
#line 3177
        if (volume == (float )0) {
#line 3177
          to_mix[n_to_mix].volume = (float )0;
        } else {
          {
#line 3177
          tmp = calculate_volume(sigrenderer, sigrenderer->channel[i].playing, volume);
#line 3177
          to_mix[n_to_mix].volume = tmp;
          }
        }
#line 3178
        n_to_mix ++;
      }
    }
#line 3174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3182
  i = 0;
  {
#line 3182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3182
    if (! (i < 192)) {
#line 3182
      goto while_break___0;
    }
#line 3183
    if (sigrenderer->playing[i]) {
#line 3184
      to_mix[n_to_mix].playing = sigrenderer->playing[i];
#line 3185
      if (volume == (float )0) {
#line 3185
        to_mix[n_to_mix].volume = (float )0;
      } else {
        {
#line 3185
        tmp___0 = calculate_volume(sigrenderer, sigrenderer->playing[i], volume);
#line 3185
        to_mix[n_to_mix].volume = tmp___0;
        }
      }
#line 3186
      n_to_mix ++;
    }
#line 3182
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3190
  if (volume != (float )0) {
    {
#line 3191
    qsort((void *)(to_mix), (size_t )n_to_mix, sizeof(IT_TO_MIX ), & it_to_mix_compare);
    }
  }
#line 3193
  i = 0;
  {
#line 3193
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3193
    if (! (i < n_to_mix)) {
#line 3193
      goto while_break___1;
    }
    {
#line 3194
    playing = to_mix[i].playing;
#line 3195
    note_delta = delta * playing->delta;
#line 3196
    cutoff = (int )playing->filter_cutoff << 8;
#line 3198
    apply_pitch_modifications(sigrenderer->sigdata, playing, & note_delta, & cutoff);
    }
#line 3200
    if (cutoff != 127 << 8) {
#line 3201
      playing->true_filter_cutoff = (unsigned short )cutoff;
#line 3202
      playing->true_filter_resonance = playing->filter_resonance;
    } else
#line 3200
    if ((int )playing->filter_resonance != 0) {
#line 3201
      playing->true_filter_cutoff = (unsigned short )cutoff;
#line 3202
      playing->true_filter_resonance = playing->filter_resonance;
    }
#line 3205
    if (to_mix[i].volume) {
#line 3205
      if ((int )playing->true_filter_cutoff != 127 << 8) {
#line 3205
        goto _L;
      } else
#line 3205
      if ((int )playing->true_filter_resonance != 0) {
        _L: /* CIL Label */ 
#line 3206
        if (! samples_to_filter) {
          {
#line 3207
          samples_to_filter = allocate_sample_buffer(sigrenderer->n_channels, size + 1L);
          }
#line 3208
          if (! samples_to_filter) {
            {
#line 3209
            render_playing(sigrenderer, playing, (float )0, note_delta, pos, size,
                           (sample_t **)((void *)0), 0, & left_to_mix);
            }
#line 3210
            goto __Cont;
          }
        }
        {
#line 3215
        cr = sigrenderer->click_remover;
#line 3216
        dumb_silence(*(samples_to_filter + 0), (long )sigrenderer->n_channels * (size + 1L));
#line 3217
        sigrenderer->click_remover = (DUMB_CLICK_REMOVER **)((void *)0);
#line 3218
        size_rendered = render_playing(sigrenderer, playing, to_mix[i].volume, note_delta,
                                       0L, size, samples_to_filter, 1, & left_to_mix);
#line 3219
        sigrenderer->click_remover = cr;
        }
#line 3220
        if (sigrenderer->n_channels == 2) {
#line 3221
          if (cr) {
#line 3221
            tmp___1 = *(cr + 0);
          } else {
#line 3221
            tmp___1 = (DUMB_CLICK_REMOVER *)((void *)0);
          }
          {
#line 3221
          it_filter(tmp___1, & playing->filter_state[0], *(samples + 0), pos, *(samples_to_filter + 0),
                    size_rendered, 2, (int )(65536.0f / delta), (int )playing->true_filter_cutoff,
                    (int )playing->true_filter_resonance);
          }
#line 3223
          if (cr) {
#line 3223
            tmp___2 = *(cr + 1);
          } else {
#line 3223
            tmp___2 = (DUMB_CLICK_REMOVER *)((void *)0);
          }
          {
#line 3223
          it_filter(tmp___2, & playing->filter_state[1], *(samples + 0) + 1, pos,
                    *(samples_to_filter + 0) + 1, size_rendered, 2, (int )(65536.0f / delta),
                    (int )playing->true_filter_cutoff, (int )playing->true_filter_resonance);
          }
        } else {
#line 3226
          if (cr) {
#line 3226
            tmp___3 = *(cr + 0);
          } else {
#line 3226
            tmp___3 = (DUMB_CLICK_REMOVER *)((void *)0);
          }
          {
#line 3226
          it_filter(tmp___3, & playing->filter_state[0], *(samples + 0), pos, *(samples_to_filter + 0),
                    size_rendered, 1, (int )(65536.0f / delta), (int )playing->true_filter_cutoff,
                    (int )playing->true_filter_resonance);
          }
        }
      } else {
        {
#line 3233
        it_reset_filter_state(& playing->filter_state[0]);
#line 3234
        it_reset_filter_state(& playing->filter_state[1]);
#line 3235
        render_playing(sigrenderer, playing, to_mix[i].volume, note_delta, pos, size,
                       samples, 0, & left_to_mix);
        }
      }
    } else {
      {
#line 3233
      it_reset_filter_state(& playing->filter_state[0]);
#line 3234
      it_reset_filter_state(& playing->filter_state[1]);
#line 3235
      render_playing(sigrenderer, playing, to_mix[i].volume, note_delta, pos, size,
                     samples, 0, & left_to_mix);
      }
    }
    __Cont: /* CIL Label */ 
#line 3193
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3239
  destroy_sample_buffer(samples_to_filter);
#line 3241
  i = 0;
  }
  {
#line 3241
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3241
    if (! (i < 64)) {
#line 3241
      goto while_break___2;
    }
#line 3242
    if (sigrenderer->channel[i].playing) {
#line 3245
      if ((sigrenderer->channel[i].playing)->flags & 8) {
        {
#line 3246
        free((void *)sigrenderer->channel[i].playing);
#line 3247
        sigrenderer->channel[i].playing = (IT_PLAYING *)((void *)0);
        }
      }
    }
#line 3241
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3252
  i = 0;
  {
#line 3252
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3252
    if (! (i < 192)) {
#line 3252
      goto while_break___3;
    }
#line 3253
    if (sigrenderer->playing[i]) {
#line 3254
      if ((sigrenderer->playing[i])->flags & 8) {
        {
#line 3255
        free((void *)sigrenderer->playing[i]);
#line 3256
        sigrenderer->playing[i] = (IT_PLAYING *)((void *)0);
        }
      }
    }
#line 3252
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3260
  return;
}
}
#line 3264 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static DUMB_IT_SIGRENDERER *init_sigrenderer(DUMB_IT_SIGDATA *sigdata , int n_channels ,
                                             int startorder , IT_CALLBACKS *callbacks ,
                                             DUMB_CLICK_REMOVER **cr ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;
  int i ;
  void *tmp ;
  IT_CHANNEL *channel ;
  int order ;
  int n ;

  {
#line 3269
  if (startorder > sigdata->n_orders) {
    {
#line 3270
    free((void *)callbacks);
#line 3271
    dumb_destroy_click_remover_array(n_channels, cr);
    }
#line 3272
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 3275
  tmp = malloc(sizeof(*sigrenderer));
#line 3275
  sigrenderer = (DUMB_IT_SIGRENDERER *)tmp;
  }
#line 3276
  if (! sigrenderer) {
    {
#line 3277
    free((void *)callbacks);
#line 3278
    dumb_destroy_click_remover_array(n_channels, cr);
    }
#line 3279
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
#line 3282
  sigrenderer->callbacks = callbacks;
#line 3283
  sigrenderer->click_remover = cr;
#line 3285
  sigrenderer->sigdata = sigdata;
#line 3286
  sigrenderer->n_channels = n_channels;
#line 3287
  sigrenderer->globalvolume = (unsigned char )sigdata->global_volume;
#line 3288
  sigrenderer->tempo = (unsigned char )sigdata->tempo;
#line 3290
  i = 0;
  {
#line 3290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3290
    if (! (i < 64)) {
#line 3290
      goto while_break;
    }
#line 3291
    channel = & sigrenderer->channel[i];
#line 3295
    channel->flags = (int )sigdata->channel_pan[i] >> 7;
#line 3296
    if (sigdata->flags & 64) {
#line 3296
      channel->volume = (unsigned char)0;
    } else {
#line 3296
      channel->volume = (unsigned char)64;
    }
#line 3297
    channel->pan = (unsigned char )((int )sigdata->channel_pan[i] & 127);
#line 3298
    channel->truepan = (unsigned short )((int )channel->pan << 8);
#line 3299
    channel->channelvolume = sigdata->channel_volume[i];
#line 3300
    channel->instrument = (unsigned char)0;
#line 3301
    channel->note = (unsigned char)0;
#line 3302
    channel->SFmacro = (unsigned char)0;
#line 3303
    channel->filter_cutoff = (unsigned char)127;
#line 3304
    channel->filter_resonance = (unsigned char)0;
#line 3305
    channel->xm_retrig = (unsigned char)0;
#line 3306
    channel->retrig_tick = 0;
#line 3307
    channel->tremor_time = (unsigned char)0;
#line 3308
    channel->midi_state = (unsigned char)0;
#line 3309
    channel->lastvolslide = (signed char)0;
#line 3310
    channel->lastDKL = (unsigned char)0;
#line 3311
    channel->lastEF = (unsigned char)0;
#line 3312
    channel->lastG = (unsigned char)0;
#line 3313
    channel->lastHspeed = (unsigned char)0;
#line 3314
    channel->lastHdepth = (unsigned char)0;
#line 3315
    channel->lastRspeed = (unsigned char)0;
#line 3316
    channel->lastRdepth = (unsigned char)0;
#line 3317
    channel->lastI = (unsigned char)0;
#line 3318
    channel->lastJ = (unsigned char)0;
#line 3319
    channel->lastN = (unsigned char)0;
#line 3320
    channel->lastO = (unsigned char)0;
#line 3321
    channel->high_offset = (unsigned char)0;
#line 3322
    channel->lastP = (unsigned char)0;
#line 3323
    channel->lastQ = (unsigned char)0;
#line 3324
    channel->lastS = (unsigned char)0;
#line 3325
    channel->pat_loop_row = (unsigned char)0;
#line 3326
    channel->pat_loop_count = (unsigned char)0;
#line 3327
    channel->pat_loop_end_row = (unsigned char)0;
#line 3328
    channel->lastW = (unsigned char)0;
#line 3329
    channel->xm_lastE1 = (unsigned char)0;
#line 3330
    channel->xm_lastE2 = (unsigned char)0;
#line 3331
    channel->xm_lastEA = (unsigned char)0;
#line 3332
    channel->xm_lastEB = (unsigned char)0;
#line 3333
    channel->xm_lastX1 = (unsigned char)0;
#line 3334
    channel->xm_lastX2 = (unsigned char)0;
#line 3335
    channel->playing = (IT_PLAYING *)((void *)0);
#line 3290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3338
  i = 0;
  {
#line 3338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3338
    if (! (i < 192)) {
#line 3338
      goto while_break___0;
    }
#line 3339
    sigrenderer->playing[i] = (IT_PLAYING *)((void *)0);
#line 3338
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3341
  sigrenderer->speed = sigdata->speed;
#line 3343
  sigrenderer->processrow = 65534;
#line 3344
  sigrenderer->n_rows = 0;
#line 3345
  sigrenderer->breakrow = 0;
#line 3346
  sigrenderer->pat_loop_row = -1;
#line 3347
  sigrenderer->rowcount = 1;
#line 3348
  sigrenderer->order = startorder;
#line 3349
  sigrenderer->row = 0;
#line 3350
  sigrenderer->processorder = startorder - 1;
#line 3351
  sigrenderer->tick = 1;
#line 3355
  order = 0;
  {
#line 3355
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3355
    if (! (order < sigdata->n_orders)) {
#line 3355
      goto while_break___1;
    }
#line 3356
    n = (int )*(sigdata->order + order);
#line 3357
    if (n < sigdata->n_patterns) {
#line 3357
      goto found_valid_order;
    }
#line 3359
    if (n != 254) {
#line 3363
      goto while_break___1;
    }
#line 3355
    order ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3366
  _dumb_it_end_sigrenderer((sigrenderer_t *)sigrenderer);
  }
#line 3367
  return ((DUMB_IT_SIGRENDERER *)((void *)0));
  found_valid_order: 
#line 3371
  sigrenderer->time_left = 0L;
#line 3372
  sigrenderer->sub_time_left = 0;
#line 3374
  return (sigrenderer);
}
}
#line 3379 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
void dumb_it_set_loop_callback(DUMB_IT_SIGRENDERER *sigrenderer , int (*callback)(void *data ) ,
                               void *data ) 
{ 


  {
#line 3381
  if (sigrenderer) {
#line 3382
    (sigrenderer->callbacks)->loop = callback;
#line 3383
    (sigrenderer->callbacks)->loop_data = data;
  }
#line 3385
  return;
}
}
#line 3389 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
void dumb_it_set_xm_speed_zero_callback(DUMB_IT_SIGRENDERER *sigrenderer , int (*callback)(void *data ) ,
                                        void *data ) 
{ 


  {
#line 3391
  if (sigrenderer) {
#line 3392
    (sigrenderer->callbacks)->xm_speed_zero = callback;
#line 3393
    (sigrenderer->callbacks)->xm_speed_zero_data = data;
  }
#line 3395
  return;
}
}
#line 3399 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
void dumb_it_set_midi_callback(DUMB_IT_SIGRENDERER *sigrenderer , int (*callback)(void *data ,
                                                                                  int channel ,
                                                                                  unsigned char midi_byte ) ,
                               void *data ) 
{ 


  {
#line 3401
  if (sigrenderer) {
#line 3402
    (sigrenderer->callbacks)->midi = callback;
#line 3403
    (sigrenderer->callbacks)->midi_data = data;
  }
#line 3405
  return;
}
}
#line 3409 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static IT_CALLBACKS *create_callbacks(void) 
{ 
  IT_CALLBACKS *callbacks ;
  void *tmp ;

  {
  {
#line 3411
  tmp = malloc(sizeof(*callbacks));
#line 3411
  callbacks = (IT_CALLBACKS *)tmp;
  }
#line 3412
  if (! callbacks) {
#line 3412
    return ((IT_CALLBACKS *)((void *)0));
  }
#line 3413
  callbacks->loop = (int (*)(void *data ))((void *)0);
#line 3414
  callbacks->xm_speed_zero = (int (*)(void *data ))((void *)0);
#line 3415
  callbacks->midi = (int (*)(void *data , int channel , unsigned char byte ))((void *)0);
#line 3416
  return (callbacks);
}
}
#line 3421 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static DUMB_IT_SIGRENDERER *dumb_it_init_sigrenderer(DUMB_IT_SIGDATA *sigdata , int n_channels ,
                                                     int startorder ) 
{ 
  IT_CALLBACKS *callbacks ;
  DUMB_CLICK_REMOVER **tmp ;
  DUMB_IT_SIGRENDERER *tmp___0 ;

  {
#line 3425
  if (! sigdata) {
#line 3425
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 3427
  callbacks = create_callbacks();
  }
#line 3428
  if (! callbacks) {
#line 3428
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 3430
  tmp = dumb_create_click_remover_array(n_channels);
#line 3430
  tmp___0 = init_sigrenderer(sigdata, n_channels, startorder, callbacks, tmp);
  }
#line 3430
  return (tmp___0);
}
}
#line 3436 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
DUH_SIGRENDERER *dumb_it_start_at_order(DUH *duh , int n_channels , int startorder ) 
{ 
  DUMB_IT_SIGDATA *itsd ;
  DUMB_IT_SIGDATA *tmp ;
  DUMB_IT_SIGRENDERER *itsr ;
  DUMB_IT_SIGRENDERER *tmp___0 ;
  DUH_SIGRENDERER *tmp___1 ;

  {
  {
#line 3438
  tmp = duh_get_it_sigdata(duh);
#line 3438
  itsd = tmp;
#line 3439
  tmp___0 = dumb_it_init_sigrenderer(itsd, n_channels, startorder);
#line 3439
  itsr = tmp___0;
#line 3440
  tmp___1 = duh_encapsulate_it_sigrenderer(itsr, n_channels, 0L);
  }
#line 3440
  return (tmp___1);
}
}
#line 3445 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static sigrenderer_t *it_start_sigrenderer(DUH *duh , sigdata_t *vsigdata , int n_channels ,
                                           long pos ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  DUMB_IT_SIGRENDERER *sigrenderer ;
  IT_CALLBACKS *callbacks ;
  IT_CALLBACKS *tmp ;
  IT_CHECKPOINT *checkpoint ;
  DUMB_CLICK_REMOVER **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3447
  sigdata = (DUMB_IT_SIGDATA *)vsigdata;
#line 3453
  tmp = create_callbacks();
#line 3453
  callbacks = tmp;
  }
#line 3454
  if (! callbacks) {
#line 3454
    return ((void *)0);
  }
#line 3456
  if (sigdata->checkpoint) {
#line 3457
    checkpoint = sigdata->checkpoint;
    {
#line 3458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3458
      if (checkpoint->next) {
#line 3458
        if (! ((checkpoint->next)->time < pos)) {
#line 3458
          goto while_break;
        }
      } else {
#line 3458
        goto while_break;
      }
#line 3459
      checkpoint = checkpoint->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3460
    sigrenderer = dup_sigrenderer(checkpoint->sigrenderer, n_channels, callbacks);
    }
#line 3461
    if (! sigrenderer) {
#line 3461
      return ((void *)0);
    }
    {
#line 3462
    sigrenderer->click_remover = dumb_create_click_remover_array(n_channels);
#line 3463
    pos -= checkpoint->time;
    }
  } else {
    {
#line 3465
    tmp___0 = dumb_create_click_remover_array(n_channels);
#line 3465
    sigrenderer = init_sigrenderer(sigdata, n_channels, 0, callbacks, tmp___0);
    }
#line 3467
    if (! sigrenderer) {
#line 3467
      return ((void *)0);
    }
  }
  {
#line 3471
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3471
    if (! (pos >= sigrenderer->time_left)) {
#line 3471
      goto while_break___0;
    }
    {
#line 3472
    render(sigrenderer, (float )0, 1.0f, 0L, sigrenderer->time_left, (sample_t **)((void *)0));
#line 3474
    pos -= sigrenderer->time_left;
#line 3475
    sigrenderer->time_left = 0L;
#line 3477
    tmp___1 = process_tick(sigrenderer);
    }
#line 3477
    if (tmp___1) {
      {
#line 3478
      _dumb_it_end_sigrenderer((sigrenderer_t *)sigrenderer);
      }
#line 3479
      return ((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3483
  render(sigrenderer, (float )0, 1.0f, 0L, pos, (sample_t **)((void *)0));
#line 3484
  sigrenderer->time_left -= pos;
  }
#line 3486
  return ((sigrenderer_t *)sigrenderer);
}
}
#line 3491 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static long it_sigrenderer_get_samples(sigrenderer_t *vsigrenderer , float volume ,
                                       float delta , long size , sample_t **samples ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;
  long pos ;
  int dt ;
  long todo ;
  long long t ;
  int tmp ;

  {
#line 3497
  sigrenderer = (DUMB_IT_SIGRENDERER *)vsigrenderer;
#line 3503
  if (sigrenderer->order < 0) {
#line 3503
    return (0L);
  }
#line 3505
  pos = 0L;
#line 3506
  dt = (int )(delta * 65536.0f + 0.5f);
#line 3511
  if (! samples) {
#line 3511
    volume = (float )0;
  }
  {
#line 3513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3514
    todo = (long )((((long long )sigrenderer->time_left << 16) | (long long )sigrenderer->sub_time_left) / (long long )dt);
#line 3516
    if (todo >= size) {
#line 3517
      goto while_break;
    }
    {
#line 3519
    render(sigrenderer, volume, delta, pos, todo, samples);
#line 3521
    pos += todo;
#line 3522
    size -= todo;
#line 3524
    t = (long long )sigrenderer->sub_time_left - (long long )todo * (long long )dt;
#line 3525
    sigrenderer->sub_time_left = (int )((long )t & 65535L);
#line 3526
    sigrenderer->time_left += (long )(t >> 16);
#line 3528
    tmp = process_tick(sigrenderer);
    }
#line 3528
    if (tmp) {
#line 3529
      sigrenderer->order = -1;
#line 3530
      sigrenderer->row = -1;
#line 3531
      return (pos);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3535
  render(sigrenderer, volume, delta, pos, size, samples);
#line 3537
  pos += size;
#line 3539
  t = (long long )sigrenderer->sub_time_left - (long long )size * (long long )dt;
#line 3540
  sigrenderer->sub_time_left = (int )((long )t & 65535L);
#line 3541
  sigrenderer->time_left += (long )(t >> 16);
  }
#line 3543
  if (samples) {
    {
#line 3544
    dumb_remove_clicks_array(sigrenderer->n_channels, sigrenderer->click_remover,
                             samples, pos, 512.0f / delta);
    }
  }
#line 3546
  return (pos);
}
}
#line 3551 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_sigrenderer_get_current_sample(sigrenderer_t *vsigrenderer , float volume ,
                                              sample_t *samples ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;

  {
  {
#line 3553
  sigrenderer = (DUMB_IT_SIGRENDERER *)vsigrenderer;
#line 3555
  dumb_click_remover_get_offset_array(sigrenderer->n_channels, sigrenderer->click_remover,
                                      samples);
  }
#line 3556
  return;
}
}
#line 3560 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
void _dumb_it_end_sigrenderer(sigrenderer_t *vsigrenderer ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;
  int i ;

  {
#line 3562
  sigrenderer = (DUMB_IT_SIGRENDERER *)vsigrenderer;
#line 3566
  if (sigrenderer) {
#line 3567
    i = 0;
    {
#line 3567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3567
      if (! (i < 64)) {
#line 3567
        goto while_break;
      }
#line 3568
      if (sigrenderer->channel[i].playing) {
        {
#line 3569
        free((void *)sigrenderer->channel[i].playing);
        }
      }
#line 3567
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3571
    i = 0;
    {
#line 3571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3571
      if (! (i < 192)) {
#line 3571
        goto while_break___0;
      }
#line 3572
      if (sigrenderer->playing[i]) {
        {
#line 3573
        free((void *)sigrenderer->playing[i]);
        }
      }
#line 3571
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3575
    dumb_destroy_click_remover_array(sigrenderer->n_channels, sigrenderer->click_remover);
    }
#line 3577
    if (sigrenderer->callbacks) {
      {
#line 3578
      free((void *)sigrenderer->callbacks);
      }
    }
    {
#line 3580
    free(vsigrenderer);
    }
  }
#line 3582
  return;
}
}
#line 3586 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
DUH_SIGTYPE_DESC _dumb_sigtype_it  = 
#line 3586
     {(long )((((73U << 24) | (84U << 16)) | (32U << 8)) | 32U), (sigdata_t *(*)(DUH *duh ,
                                                                               DUMBFILE *file ))((void *)0),
    & it_start_sigrenderer, (void (*)(sigrenderer_t *sigrenderer , unsigned char id ,
                                      long value ))((void *)0), & it_sigrenderer_get_samples,
    & it_sigrenderer_get_current_sample, & _dumb_it_end_sigrenderer, & _dumb_it_unload_sigdata};
#line 3599 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
DUH_SIGRENDERER *duh_encapsulate_it_sigrenderer(DUMB_IT_SIGRENDERER *it_sigrenderer ,
                                                int n_channels , long pos ) 
{ 
  DUH_SIGRENDERER *tmp ;

  {
  {
#line 3601
  tmp = duh_encapsulate_raw_sigrenderer((sigrenderer_t *)it_sigrenderer, & _dumb_sigtype_it,
                                        n_channels, pos);
  }
#line 3601
  return (tmp);
}
}
#line 3606 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
DUMB_IT_SIGRENDERER *duh_get_it_sigrenderer(DUH_SIGRENDERER *sigrenderer ) 
{ 
  sigrenderer_t *tmp ;

  {
  {
#line 3608
  tmp = duh_get_raw_sigrenderer(sigrenderer, (long )((((73U << 24) | (84U << 16)) | (32U << 8)) | 32U));
  }
#line 3608
  return ((DUMB_IT_SIGRENDERER *)tmp);
}
}
#line 3614 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
void dumb_it_sr_get_channel_state(DUMB_IT_SIGRENDERER *sr , int channel , DUMB_IT_CHANNEL_STATE *state ) 
{ 
  IT_PLAYING *playing ;
  int t ;
  float delta ;

  {
#line 3620
  if (! sr) {
#line 3620
    state->sample = 0;
#line 3620
    return;
  }
#line 3621
  if (channel >= 64) {
#line 3622
    playing = sr->playing[channel - 64];
#line 3623
    if (! playing) {
#line 3623
      state->sample = 0;
#line 3623
      return;
    }
  } else {
#line 3625
    playing = sr->channel[channel].playing;
#line 3626
    if (! playing) {
#line 3626
      state->sample = 0;
#line 3626
      return;
    }
  }
#line 3629
  if (playing->flags & 8) {
#line 3629
    state->sample = 0;
#line 3629
    return;
  }
  {
#line 3631
  state->channel = (int )(playing->channel - sr->channel);
#line 3632
  state->sample = (int )playing->sampnum;
#line 3633
  state->volume = calculate_volume(sr, playing, 1.0f);
#line 3635
  t = apply_pan_envelope(playing);
#line 3636
  state->pan = (unsigned char )((t + 128) >> 8);
#line 3637
  state->subpan = (signed char )t;
#line 3639
  delta = playing->delta * 65536.0f;
#line 3640
  t = (int )playing->filter_cutoff << 8;
#line 3641
  apply_pitch_modifications(sr->sigdata, playing, & delta, & t);
#line 3642
  state->freq = (int )delta;
  }
#line 3643
  if (t == 127 << 8) {
#line 3643
    if ((int )playing->filter_resonance == 0) {
#line 3644
      state->filter_resonance = playing->true_filter_resonance;
#line 3645
      t = (int )playing->true_filter_cutoff;
    } else {
#line 3647
      state->filter_resonance = playing->filter_resonance;
    }
  } else {
#line 3647
    state->filter_resonance = playing->filter_resonance;
  }
#line 3648
  state->filter_cutoff = (unsigned char )(t >> 8);
#line 3649
  state->filter_subcutoff = (unsigned char )t;
#line 3650
  return;
}
}
#line 3654 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
int dumb_it_callback_terminate(void *data ) 
{ 


  {
#line 3657
  return (1);
}
}
#line 3662 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
int dumb_it_callback_midi_block(void *data , int channel , unsigned char midi_byte ) 
{ 


  {
#line 3667
  return (1);
}
}
#line 3677 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
long dumb_it_build_checkpoints(DUMB_IT_SIGDATA *sigdata ) 
{ 
  IT_CHECKPOINT *checkpoint ;
  IT_CHECKPOINT *next ;
  void *tmp ;
  long l ;
  DUMB_IT_SIGRENDERER *sigrenderer ;
  DUMB_IT_SIGRENDERER *tmp___0 ;
  void *tmp___1 ;

  {
#line 3680
  if (! sigdata) {
#line 3680
    return (0L);
  }
#line 3681
  checkpoint = sigdata->checkpoint;
  {
#line 3682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3682
    if (! checkpoint) {
#line 3682
      goto while_break;
    }
    {
#line 3683
    next = checkpoint->next;
#line 3684
    _dumb_it_end_sigrenderer((sigrenderer_t *)checkpoint->sigrenderer);
#line 3685
    free((void *)checkpoint);
#line 3686
    checkpoint = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3688
  sigdata->checkpoint = (IT_CHECKPOINT *)((void *)0);
#line 3689
  tmp = malloc(sizeof(*checkpoint));
#line 3689
  checkpoint = (IT_CHECKPOINT *)tmp;
  }
#line 3690
  if (! checkpoint) {
#line 3690
    return (0L);
  }
  {
#line 3691
  checkpoint->time = 0L;
#line 3692
  checkpoint->sigrenderer = dumb_it_init_sigrenderer(sigdata, 0, 0);
  }
#line 3693
  if (! checkpoint->sigrenderer) {
    {
#line 3694
    free((void *)checkpoint);
    }
#line 3695
    return (0L);
  }
#line 3697
  ((checkpoint->sigrenderer)->callbacks)->loop = & dumb_it_callback_terminate;
#line 3698
  ((checkpoint->sigrenderer)->callbacks)->xm_speed_zero = & dumb_it_callback_terminate;
#line 3699
  sigdata->checkpoint = checkpoint;
  {
#line 3701
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3703
    tmp___0 = dup_sigrenderer(checkpoint->sigrenderer, 0, (checkpoint->sigrenderer)->callbacks);
#line 3703
    sigrenderer = tmp___0;
#line 3704
    (checkpoint->sigrenderer)->callbacks = (IT_CALLBACKS *)((void *)0);
    }
#line 3705
    if (! sigrenderer) {
#line 3706
      checkpoint->next = (IT_CHECKPOINT *)((void *)0);
#line 3707
      return (checkpoint->time);
    }
    {
#line 3710
    l = it_sigrenderer_get_samples((sigrenderer_t *)sigrenderer, (float )0, 1.0f,
                                   1966080L, (sample_t **)((void *)0));
    }
#line 3711
    if (l < 1966080L) {
      {
#line 3712
      _dumb_it_end_sigrenderer((sigrenderer_t *)sigrenderer);
#line 3713
      checkpoint->next = (IT_CHECKPOINT *)((void *)0);
      }
#line 3714
      return (checkpoint->time + l);
    }
    {
#line 3717
    tmp___1 = malloc(sizeof(*(checkpoint->next)));
#line 3717
    checkpoint->next = (IT_CHECKPOINT *)tmp___1;
    }
#line 3718
    if (! checkpoint->next) {
      {
#line 3719
      _dumb_it_end_sigrenderer((sigrenderer_t *)sigrenderer);
      }
#line 3720
      return (checkpoint->time + 1966080L);
    }
#line 3723
    (checkpoint->next)->time = checkpoint->time + 1966080L;
#line 3724
    checkpoint = checkpoint->next;
#line 3725
    checkpoint->sigrenderer = sigrenderer;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 3731 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
void dumb_it_do_initial_runthrough(DUH *duh ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  DUMB_IT_SIGDATA *tmp ;
  long tmp___0 ;

  {
#line 3733
  if (duh) {
    {
#line 3734
    tmp = duh_get_it_sigdata(duh);
#line 3734
    sigdata = tmp;
    }
#line 3736
    if (sigdata) {
      {
#line 3737
      tmp___0 = dumb_it_build_checkpoints(sigdata);
#line 3737
      duh_set_length(duh, tmp___0);
      }
    }
  }
#line 3739
  return;
}
}
#line 372 "include/dumb.h"
DUH *dumb_load_mod(char const   *filename ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/loadmod2.c"
DUH *dumb_load_mod(char const   *filename ) 
{ 
  DUH *duh ;
  DUH *tmp ;

  {
  {
#line 26
  tmp = dumb_load_mod_quick(filename);
#line 26
  duh = tmp;
#line 27
  dumb_it_do_initial_runthrough(duh);
  }
#line 28
  return (duh);
}
}
#line 164 "include/dumb.h"
void register_dumbfile_system(DUMBFILE_SYSTEM *dfs ) ;
#line 167
DUMBFILE *dumbfile_open_ex(void *file , DUMBFILE_SYSTEM *dfs ) ;
#line 169
long dumbfile_pos(DUMBFILE *f ) ;
#line 170
int dumbfile_skip(DUMBFILE *f , long n ) ;
#line 172
int dumbfile_getc(DUMBFILE *f ) ;
#line 174
int dumbfile_igetw(DUMBFILE *f ) ;
#line 175
int dumbfile_mgetw(DUMBFILE *f ) ;
#line 177
long dumbfile_igetl(DUMBFILE *f ) ;
#line 178
long dumbfile_mgetl(DUMBFILE *f ) ;
#line 180
unsigned long dumbfile_cgetul(DUMBFILE *f ) ;
#line 181
long dumbfile_cgetsl(DUMBFILE *f ) ;
#line 183
long dumbfile_getnc(char *ptr , long n , DUMBFILE *f ) ;
#line 185
int dumbfile_error(DUMBFILE *f ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
static DUMBFILE_SYSTEM *the_dfs  =    (DUMBFILE_SYSTEM *)((void *)0);
#line 30 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
void register_dumbfile_system(DUMBFILE_SYSTEM *dfs ) 
{ 


  {
#line 36
  the_dfs = dfs;
#line 37
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
DUMBFILE *dumbfile_open(char const   *filename ) 
{ 
  DUMBFILE *f ;
  void *tmp ;

  {
  {
#line 56
  tmp = malloc(sizeof(*f));
#line 56
  f = (DUMBFILE *)tmp;
  }
#line 58
  if (! f) {
#line 59
    return ((DUMBFILE *)((void *)0));
  }
  {
#line 61
  f->dfs = the_dfs;
#line 63
  f->file = (*(the_dfs->open))(filename);
  }
#line 65
  if (! f->file) {
    {
#line 66
    free((void *)f);
    }
#line 67
    return ((DUMBFILE *)((void *)0));
  }
#line 70
  f->pos = 0L;
#line 72
  return (f);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
DUMBFILE *dumbfile_open_ex(void *file , DUMBFILE_SYSTEM *dfs ) 
{ 
  DUMBFILE *f ;
  void *tmp ;

  {
  {
#line 85
  tmp = malloc(sizeof(*f));
#line 85
  f = (DUMBFILE *)tmp;
  }
#line 87
  if (! f) {
#line 88
    if (dfs->close) {
      {
#line 89
      (*(dfs->close))(file);
      }
    }
#line 90
    return ((DUMBFILE *)((void *)0));
  }
#line 93
  f->dfs = dfs;
#line 94
  f->file = file;
#line 96
  f->pos = 0L;
#line 98
  return (f);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
long dumbfile_pos(DUMBFILE *f ) 
{ 


  {
#line 107
  return (f->pos);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
int dumbfile_skip(DUMBFILE *f , long n ) 
{ 
  int rv ;

  {
#line 119
  if (f->pos < 0L) {
#line 120
    return (-1);
  }
#line 122
  f->pos += n;
#line 124
  if ((f->dfs)->skip) {
    {
#line 125
    rv = (*((f->dfs)->skip))(f->file, n);
    }
#line 126
    if (rv) {
#line 127
      f->pos = -1L;
#line 128
      return (rv);
    }
  } else {
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 131
      if (! n) {
#line 131
        goto while_break;
      }
      {
#line 132
      rv = (*((f->dfs)->getc))(f->file);
      }
#line 133
      if (rv < 0) {
#line 134
        f->pos = -1L;
#line 135
        return (rv);
      }
#line 137
      n --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 141
  return (0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
int dumbfile_getc(DUMBFILE *f ) 
{ 
  int rv ;

  {
#line 152
  if (f->pos < 0L) {
#line 153
    return (-1);
  }
  {
#line 155
  rv = (*((f->dfs)->getc))(f->file);
  }
#line 157
  if (rv < 0) {
#line 158
    f->pos = -1L;
#line 159
    return (rv);
  }
#line 162
  (f->pos) ++;
#line 164
  return (rv);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
int dumbfile_igetw(DUMBFILE *f ) 
{ 
  int l ;
  int h ;

  {
#line 175
  if (f->pos < 0L) {
#line 176
    return (-1);
  }
  {
#line 178
  l = (*((f->dfs)->getc))(f->file);
  }
#line 179
  if (l < 0) {
#line 180
    f->pos = -1L;
#line 181
    return (l);
  }
  {
#line 184
  h = (*((f->dfs)->getc))(f->file);
  }
#line 185
  if (h < 0) {
#line 186
    f->pos = -1L;
#line 187
    return (h);
  }
#line 190
  f->pos += 2L;
#line 192
  return (l | (h << 8));
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
int dumbfile_mgetw(DUMBFILE *f ) 
{ 
  int l ;
  int h ;

  {
#line 203
  if (f->pos < 0L) {
#line 204
    return (-1);
  }
  {
#line 206
  h = (*((f->dfs)->getc))(f->file);
  }
#line 207
  if (h < 0) {
#line 208
    f->pos = -1L;
#line 209
    return (h);
  }
  {
#line 212
  l = (*((f->dfs)->getc))(f->file);
  }
#line 213
  if (l < 0) {
#line 214
    f->pos = -1L;
#line 215
    return (l);
  }
#line 218
  f->pos += 2L;
#line 220
  return (l | (h << 8));
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
long dumbfile_igetl(DUMBFILE *f ) 
{ 
  unsigned long rv ;
  unsigned long b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 231
  if (f->pos < 0L) {
#line 232
    return (-1L);
  }
  {
#line 234
  tmp = (*((f->dfs)->getc))(f->file);
#line 234
  rv = (unsigned long )tmp;
  }
#line 235
  if ((long )rv < 0L) {
#line 236
    f->pos = -1L;
#line 237
    return ((long )rv);
  }
  {
#line 240
  tmp___0 = (*((f->dfs)->getc))(f->file);
#line 240
  b = (unsigned long )tmp___0;
  }
#line 241
  if ((long )b < 0L) {
#line 242
    f->pos = -1L;
#line 243
    return ((long )b);
  }
  {
#line 245
  rv |= b << 8;
#line 247
  tmp___1 = (*((f->dfs)->getc))(f->file);
#line 247
  b = (unsigned long )tmp___1;
  }
#line 248
  if ((long )b < 0L) {
#line 249
    f->pos = -1L;
#line 250
    return ((long )b);
  }
  {
#line 252
  rv |= b << 16;
#line 254
  tmp___2 = (*((f->dfs)->getc))(f->file);
#line 254
  b = (unsigned long )tmp___2;
  }
#line 255
  if ((long )b < 0L) {
#line 256
    f->pos = -1L;
#line 257
    return ((long )b);
  }
#line 259
  rv |= b << 24;
#line 261
  f->pos += 4L;
#line 263
  return ((long )rv);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
long dumbfile_mgetl(DUMBFILE *f ) 
{ 
  unsigned long rv ;
  unsigned long b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 274
  if (f->pos < 0L) {
#line 275
    return (-1L);
  }
  {
#line 277
  tmp = (*((f->dfs)->getc))(f->file);
#line 277
  rv = (unsigned long )tmp;
  }
#line 278
  if ((long )rv < 0L) {
#line 279
    f->pos = -1L;
#line 280
    return ((long )rv);
  }
  {
#line 282
  rv <<= 24;
#line 284
  tmp___0 = (*((f->dfs)->getc))(f->file);
#line 284
  b = (unsigned long )tmp___0;
  }
#line 285
  if ((long )b < 0L) {
#line 286
    f->pos = -1L;
#line 287
    return ((long )b);
  }
  {
#line 289
  rv |= b << 16;
#line 291
  tmp___1 = (*((f->dfs)->getc))(f->file);
#line 291
  b = (unsigned long )tmp___1;
  }
#line 292
  if ((long )b < 0L) {
#line 293
    f->pos = -1L;
#line 294
    return ((long )b);
  }
  {
#line 296
  rv |= b << 8;
#line 298
  tmp___2 = (*((f->dfs)->getc))(f->file);
#line 298
  b = (unsigned long )tmp___2;
  }
#line 299
  if ((long )b < 0L) {
#line 300
    f->pos = -1L;
#line 301
    return ((long )b);
  }
#line 303
  rv |= b;
#line 305
  f->pos += 4L;
#line 307
  return ((long )rv);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
unsigned long dumbfile_cgetul(DUMBFILE *f ) 
{ 
  unsigned long rv ;
  int v ;

  {
#line 314
  rv = 0UL;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 318
    v = dumbfile_getc(f);
    }
#line 320
    if (v < 0) {
#line 321
      return ((unsigned long )v);
    }
#line 323
    rv <<= 7;
#line 324
    rv |= (unsigned long )(v & 127);
#line 317
    if (! (v & 128)) {
#line 317
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return (rv);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
long dumbfile_cgetsl(DUMBFILE *f ) 
{ 
  unsigned long rv ;
  unsigned long tmp ;

  {
  {
#line 334
  tmp = dumbfile_cgetul(f);
#line 334
  rv = tmp;
  }
#line 336
  if (f->pos < 0L) {
#line 337
    return ((long )rv);
  }
#line 339
  return ((long )((rv >> 1) | (rv << 31)));
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
long dumbfile_getnc(char *ptr , long n , DUMBFILE *f ) 
{ 
  long rv ;
  long tmp ;
  int c ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 351
  if (f->pos < 0L) {
#line 352
    return (-1L);
  }
#line 354
  if ((f->dfs)->getnc) {
    {
#line 355
    rv = (*((f->dfs)->getnc))(ptr, n, f->file);
    }
#line 356
    if (rv < n) {
#line 357
      f->pos = -1L;
#line 358
      if (rv > 0L) {
#line 358
        tmp = rv;
      } else {
#line 358
        tmp = 0L;
      }
#line 358
      return (tmp);
    }
  } else {
#line 361
    rv = 0L;
    {
#line 361
    while (1) {
      while_continue: /* CIL Label */ ;
#line 361
      if (! (rv < n)) {
#line 361
        goto while_break;
      }
      {
#line 362
      tmp___0 = (*((f->dfs)->getc))(f->file);
#line 362
      c = tmp___0;
      }
#line 363
      if (c < 0) {
#line 364
        f->pos = -1L;
#line 365
        return (rv);
      }
#line 367
      tmp___1 = ptr;
#line 367
      ptr ++;
#line 367
      *tmp___1 = (char )c;
#line 361
      rv ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 371
  f->pos += rv;
#line 373
  return (rv);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
int dumbfile_error(DUMBFILE *f ) 
{ 


  {
#line 382
  return (f->pos < 0L);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
int dumbfile_close(DUMBFILE *f ) 
{ 
  int rv ;

  {
#line 393
  rv = f->pos < 0L;
#line 395
  if ((f->dfs)->close) {
    {
#line 396
    (*((f->dfs)->close))(f->file);
    }
  }
  {
#line 398
  free((void *)f);
  }
#line 400
  return (rv);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itunload.c"
void _dumb_it_unload_sigdata(sigdata_t *vsigdata ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int n ;
  IT_CHECKPOINT *checkpoint ;
  IT_CHECKPOINT *next ;

  {
#line 29
  if (vsigdata) {
#line 30
    sigdata = (DUMB_IT_SIGDATA *)vsigdata;
#line 33
    if (sigdata->song_message) {
      {
#line 34
      free((void *)sigdata->song_message);
      }
    }
#line 36
    if (sigdata->order) {
      {
#line 37
      free((void *)sigdata->order);
      }
    }
#line 39
    if (sigdata->instrument) {
      {
#line 40
      free((void *)sigdata->instrument);
      }
    }
#line 42
    if (sigdata->sample) {
#line 43
      n = 0;
      {
#line 43
      while (1) {
        while_continue: /* CIL Label */ ;
#line 43
        if (! (n < sigdata->n_samples)) {
#line 43
          goto while_break;
        }
#line 44
        if ((sigdata->sample + n)->data) {
          {
#line 45
          free((sigdata->sample + n)->data);
          }
        }
#line 43
        n ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 47
      free((void *)sigdata->sample);
      }
    }
#line 50
    if (sigdata->pattern) {
#line 51
      n = 0;
      {
#line 51
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 51
        if (! (n < sigdata->n_patterns)) {
#line 51
          goto while_break___0;
        }
#line 52
        if ((sigdata->pattern + n)->entry) {
          {
#line 53
          free((void *)(sigdata->pattern + n)->entry);
          }
        }
#line 51
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 54
      free((void *)sigdata->pattern);
      }
    }
#line 57
    if (sigdata->midi) {
      {
#line 58
      free((void *)sigdata->midi);
      }
    }
#line 61
    checkpoint = sigdata->checkpoint;
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 62
      if (! checkpoint) {
#line 62
        goto while_break___1;
      }
      {
#line 63
      next = checkpoint->next;
#line 64
      _dumb_it_end_sigrenderer((sigrenderer_t *)checkpoint->sigrenderer);
#line 65
      free((void *)checkpoint);
#line 66
      checkpoint = next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 70
    free(vsigdata);
    }
  }
#line 72
  return;
}
}
#line 212 "include/dumb.h"
long duh_get_length(DUH *duh ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/duhlen.c"
long duh_get_length(DUH *duh ) 
{ 
  long tmp ;

  {
#line 33
  if (duh) {
#line 33
    tmp = duh->length;
  } else {
#line 33
    tmp = 0L;
  }
#line 33
  return (tmp);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/duhlen.c"
void duh_set_length(DUH *duh , long length ) 
{ 


  {
#line 40
  if (duh) {
#line 41
    duh->length = length;
  }
#line 42
  return;
}
}
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "include/dumb.h"
void dumb_exit(void) ;
#line 191
extern void dumb_register_stdfiles(void) ;
#line 207
extern void unload_duh(DUH *duh ) ;
#line 370
extern DUH *dumb_load_xm(char const   *filename ) ;
#line 371
extern DUH *dumb_load_s3m(char const   *filename ) ;
#line 593
extern int dumb_resampling_quality ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumbout.c"
union __anonunion_buffer_29 buffer  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumbout.c"
int main(int argc , char const   * const  *argv ) 
{ 
  DUH *duh ;
  DUH_SIGRENDERER *sr ;
  char const   *fn ;
  char const   *fn_out ;
  FILE *outf ;
  int depth ;
  int bigendian ;
  int unsign ;
  int freq ;
  int n_channels ;
  float volume ;
  float delay ;
  float delta ;
  int bufsize ;
  clock_t start ;
  clock_t end ;
  int i ;
  long long length ;
  long long done ;
  int dots ;
  char const   *arg ;
  int tmp ;
  char *endptr ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  char *extptr ;
  char *p ;
  char *fn_out___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  DUMB_IT_SIGRENDERER *itsr ;
  DUMB_IT_SIGRENDERER *tmp___15 ;
  long tmp___16 ;
  long l ;
  double tmp___17 ;
  int l___0 ;
  long tmp___18 ;
  short val ;
  short val___0 ;

  {
#line 40
  fn = (char const   *)((void *)0);
#line 41
  fn_out = (char const   *)((void *)0);
#line 44
  depth = 16;
#line 45
  bigendian = 0;
#line 46
  unsign = 0;
#line 47
  freq = 44100;
#line 48
  n_channels = 2;
#line 49
  volume = 1.0f;
#line 50
  delay = 0.0f;
#line 55
  i = 1;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < argc)) {
#line 61
      goto while_break;
    }
#line 62
    tmp = i;
#line 62
    i ++;
#line 62
    arg = (char const   *)*(argv + tmp);
#line 63
    if ((int const   )*arg != 45) {
#line 64
      if (fn) {
        {
#line 65
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot specify multiple filenames!\nSecond filename found: \"%s\"\n",
                arg);
        }
#line 68
        return (1);
      }
#line 70
      fn = arg;
#line 71
      goto while_continue;
    }
#line 73
    arg ++;
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 74
      if (! *arg) {
#line 74
        goto while_break___0;
      }
#line 76
      tmp___0 = arg;
#line 76
      arg ++;
      {
#line 78
      if ((int const   )*tmp___0 == 79) {
#line 78
        goto case_79;
      }
#line 78
      if ((int const   )*tmp___0 == 111) {
#line 78
        goto case_79;
      }
#line 86
      if ((int const   )*tmp___0 == 68) {
#line 86
        goto case_68;
      }
#line 86
      if ((int const   )*tmp___0 == 100) {
#line 86
        goto case_68;
      }
#line 98
      if ((int const   )*tmp___0 == 86) {
#line 98
        goto case_86;
      }
#line 98
      if ((int const   )*tmp___0 == 118) {
#line 98
        goto case_86;
      }
#line 110
      if ((int const   )*tmp___0 == 83) {
#line 110
        goto case_83;
      }
#line 110
      if ((int const   )*tmp___0 == 115) {
#line 110
        goto case_83;
      }
#line 121
      if ((int const   )*tmp___0 == 56) {
#line 121
        goto case_56;
      }
#line 125
      if ((int const   )*tmp___0 == 66) {
#line 125
        goto case_66;
      }
#line 125
      if ((int const   )*tmp___0 == 98) {
#line 125
        goto case_66;
      }
#line 129
      if ((int const   )*tmp___0 == 77) {
#line 129
        goto case_77;
      }
#line 129
      if ((int const   )*tmp___0 == 109) {
#line 129
        goto case_77;
      }
#line 133
      if ((int const   )*tmp___0 == 85) {
#line 133
        goto case_85;
      }
#line 133
      if ((int const   )*tmp___0 == 117) {
#line 133
        goto case_85;
      }
#line 137
      if ((int const   )*tmp___0 == 82) {
#line 137
        goto case_82;
      }
#line 137
      if ((int const   )*tmp___0 == 114) {
#line 137
        goto case_82;
      }
#line 148
      goto switch_default;
      case_79: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 79
      if (i >= argc) {
        {
#line 80
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of arguments; output filename expected!\n");
        }
#line 81
        return (1);
      }
#line 83
      tmp___1 = i;
#line 83
      i ++;
#line 83
      fn_out = (char const   *)*(argv + tmp___1);
#line 84
      goto switch_break;
      case_68: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 87
      if (i >= argc) {
        {
#line 88
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of arguments; delay expected!\n");
        }
#line 89
        return (1);
      }
      {
#line 91
      tmp___2 = i;
#line 91
      i ++;
#line 91
      tmp___3 = strtod((char const   */* __restrict  */)*(argv + tmp___2), (char **/* __restrict  */)(& endptr));
#line 91
      delay = (float )tmp___3;
      }
#line 92
      if ((int )*endptr != 0) {
        {
#line 93
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid delay!\n");
        }
#line 94
        return (1);
      } else
#line 92
      if (delay < 0.0f) {
        {
#line 93
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid delay!\n");
        }
#line 94
        return (1);
      } else
#line 92
      if (delay > 64.0f) {
        {
#line 93
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid delay!\n");
        }
#line 94
        return (1);
      }
#line 96
      goto switch_break;
      case_86: /* CIL Label */ 
      case_118: /* CIL Label */ 
#line 99
      if (i >= argc) {
        {
#line 100
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of arguments; volume expected!\n");
        }
#line 101
        return (1);
      }
      {
#line 103
      tmp___4 = i;
#line 103
      i ++;
#line 103
      tmp___5 = strtod((char const   */* __restrict  */)*(argv + tmp___4), (char **/* __restrict  */)(& endptr));
#line 103
      volume = (float )tmp___5;
      }
#line 104
      if ((int )*endptr != 0) {
        {
#line 105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid volume!\n");
        }
#line 106
        return (1);
      } else
#line 104
      if (volume < - 8.0f) {
        {
#line 105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid volume!\n");
        }
#line 106
        return (1);
      } else
#line 104
      if (volume > 8.0f) {
        {
#line 105
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid volume!\n");
        }
#line 106
        return (1);
      }
#line 108
      goto switch_break;
      case_83: /* CIL Label */ 
      case_115: /* CIL Label */ 
#line 111
      if (i >= argc) {
        {
#line 112
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of arguments; sampling rate expected!\n");
        }
#line 113
        return (1);
      }
      {
#line 115
      tmp___6 = i;
#line 115
      i ++;
#line 115
      tmp___7 = strtol((char const   */* __restrict  */)*(argv + tmp___6), (char **/* __restrict  */)(& endptr),
                       10);
#line 115
      freq = (int )tmp___7;
      }
#line 116
      if ((int )*endptr != 0) {
        {
#line 117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid sampling rate!\n");
        }
#line 118
        return (1);
      } else
#line 116
      if (freq < 1) {
        {
#line 117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid sampling rate!\n");
        }
#line 118
        return (1);
      } else
#line 116
      if (freq > 960000) {
        {
#line 117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid sampling rate!\n");
        }
#line 118
        return (1);
      }
#line 120
      goto switch_break;
      case_56: /* CIL Label */ 
#line 122
      depth = 8;
#line 123
      goto switch_break;
      case_66: /* CIL Label */ 
      case_98: /* CIL Label */ 
#line 126
      bigendian = 1;
#line 127
      goto switch_break;
      case_77: /* CIL Label */ 
      case_109: /* CIL Label */ 
#line 130
      n_channels = 1;
#line 131
      goto switch_break;
      case_85: /* CIL Label */ 
      case_117: /* CIL Label */ 
#line 134
      unsign = 1;
#line 135
      goto switch_break;
      case_82: /* CIL Label */ 
      case_114: /* CIL Label */ 
#line 138
      if (i >= argc) {
        {
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of arguments; resampling quality expected!\n");
        }
#line 140
        return (1);
      }
      {
#line 142
      tmp___8 = i;
#line 142
      i ++;
#line 142
      tmp___9 = strtol((char const   */* __restrict  */)*(argv + tmp___8), (char **/* __restrict  */)(& endptr),
                       10);
#line 142
      dumb_resampling_quality = (int )tmp___9;
      }
#line 143
      if ((int )*endptr != 0) {
        {
#line 144
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid resampling quality!\n");
        }
#line 145
        return (1);
      } else
#line 143
      if (dumb_resampling_quality < 0) {
        {
#line 144
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid resampling quality!\n");
        }
#line 145
        return (1);
      } else
#line 143
      if (dumb_resampling_quality > 2) {
        {
#line 144
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid resampling quality!\n");
        }
#line 145
        return (1);
      }
#line 147
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 149
      tmp___12 = __ctype_b_loc();
      }
#line 149
      if ((int const   )*(*tmp___12 + (int )*(arg + -1)) & 16384) {
#line 149
        tmp___11 = (int const   )*(arg + -1);
      } else {
#line 149
        tmp___11 = (int const   )'?';
      }
      {
#line 149
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid switch - \'%c\'!\n",
              tmp___11);
      }
#line 150
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if (! fn) {
    {
#line 156
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: dumbout [options] module [more-options]\n\nThe module can be any IT, XM, S3M or MOD file. It will be rendered to a .pcm\nfile of the same name, unless you specify otherwise with the -o option.\n\nThe valid options are:\n-o <file>   specify the output filename (defaults to the input filename with\n              the extension replaced with .pcm); use - to write to standard\n              output or . to write nowhere (useful for measuring DUMB\'s\n              performance, and DOS and Windows don\'t have /dev/null!)\n-d <delay>  set the initial delay, in seconds (default 0.0)\n-v <volume> adjust the volume (default 1.0)\n-s <freq>   set the sampling rate in Hz (default 44100)\n-8          generate 8-bit instead of 16-bit\n-b          generate big-endian data instead of little-endian (meaningless when\n              using -8)\n-m          generate mono output instead of stereo left/right pairs\n-u          generated unsigned output instead of signed\n-r <value>  specify the resampling quality to use\n");
    }
#line 176
    return (1);
  }
  {
#line 182
  atexit(& dumb_exit);
#line 183
  dumb_register_stdfiles();
#line 188
  dumb_it_max_to_mix = 256;
#line 193
  duh = load_duh(fn);
  }
#line 194
  if (! duh) {
    {
#line 195
    duh = dumb_load_it(fn);
    }
#line 196
    if (! duh) {
      {
#line 197
      duh = dumb_load_xm(fn);
      }
#line 198
      if (! duh) {
        {
#line 199
        duh = dumb_load_s3m(fn);
        }
#line 200
        if (! duh) {
          {
#line 201
          duh = dumb_load_mod(fn);
          }
#line 202
          if (! duh) {
            {
#line 203
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s!\n",
                    fn);
            }
#line 204
            return (1);
          }
        }
      }
    }
  }
  {
#line 215
  sr = duh_start_sigrenderer(duh, 0, n_channels, 0L);
  }
#line 216
  if (! sr) {
    {
#line 217
    unload_duh(duh);
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to play file!\n");
    }
#line 219
    return (1);
  }
#line 222
  if (fn_out) {
#line 223
    if ((int const   )*(fn_out + 0) == 45) {
#line 223
      if ((int const   )*(fn_out + 1) == 0) {
#line 224
        outf = stdout;
      } else {
#line 223
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 225
    if ((int const   )*(fn_out + 0) == 46) {
#line 225
      if ((int const   )*(fn_out + 1) == 0) {
#line 226
        outf = (FILE *)((void *)0);
      } else {
#line 225
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 228
      outf = fopen((char const   */* __restrict  */)fn_out, (char const   */* __restrict  */)"wb");
      }
#line 229
      if (! outf) {
        {
#line 230
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for writing!\n",
                fn_out);
#line 231
        duh_end_sigrenderer(sr);
#line 232
        unload_duh(duh);
        }
#line 233
        return (1);
      }
    }
  } else {
    {
#line 237
    extptr = (char *)((void *)0);
#line 238
    tmp___13 = strlen(fn);
#line 238
    tmp___14 = malloc(tmp___13 + 5UL);
#line 238
    fn_out___0 = (char *)tmp___14;
    }
#line 239
    if (! fn_out___0) {
      {
#line 240
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory!\n");
#line 241
      duh_end_sigrenderer(sr);
#line 242
      unload_duh(duh);
      }
#line 243
      return (1);
    }
    {
#line 245
    strcpy((char */* __restrict  */)fn_out___0, (char const   */* __restrict  */)fn);
#line 246
    p = fn_out___0;
    }
    {
#line 246
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 246
      if (! *p) {
#line 246
        goto while_break___1;
      }
#line 247
      if ((int )*p == 46) {
#line 247
        extptr = p;
      }
#line 246
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 248
    if (! extptr) {
#line 248
      extptr = p;
    }
    {
#line 249
    strcpy((char */* __restrict  */)extptr, (char const   */* __restrict  */)".pcm");
#line 250
    outf = fopen((char const   */* __restrict  */)fn_out___0, (char const   */* __restrict  */)"wb");
    }
#line 251
    if (! outf) {
      {
#line 252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s for writing!\n",
              fn_out___0);
#line 253
      free((void *)fn_out___0);
#line 254
      duh_end_sigrenderer(sr);
#line 255
      unload_duh(duh);
      }
#line 256
      return (1);
    }
    {
#line 258
    free((void *)fn_out___0);
    }
  }
  {
#line 267
  tmp___15 = duh_get_it_sigrenderer(sr);
#line 267
  itsr = tmp___15;
#line 268
  dumb_it_set_loop_callback(itsr, & dumb_it_callback_terminate, (void *)0);
#line 269
  dumb_it_set_xm_speed_zero_callback(itsr, & dumb_it_callback_terminate, (void *)0);
#line 275
  tmp___16 = duh_get_length(duh);
#line 275
  length = (long long )tmp___16 * (long long )freq >> 16;
#line 276
  done = 0LL;
#line 277
  dots = 0;
#line 278
  delta = 65536.0f / (float )freq;
  }
#line 279
  if (depth == 16) {
#line 279
    bufsize = 8192;
  } else {
#line 279
    bufsize = 16384;
  }
  {
#line 280
  bufsize /= n_channels;
#line 284
  tmp___17 = floor((double )(delay * (float )freq + 0.5f));
#line 284
  l = (long )tmp___17;
#line 285
  l *= (long )(n_channels * (depth >> 3));
  }
#line 286
  if (l) {
#line 287
    if (unsign) {
#line 288
      if (depth == 16) {
#line 289
        if (bigendian) {
#line 290
          i = 0;
          {
#line 290
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 290
            if (! (i < 8192)) {
#line 290
              goto while_break___2;
            }
#line 291
            buffer.s8[i * 2] = (char)-128;
#line 292
            buffer.s8[i * 2 + 1] = (char)0;
#line 290
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 295
          i = 0;
          {
#line 295
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 295
            if (! (i < 8192)) {
#line 295
              goto while_break___3;
            }
#line 296
            buffer.s8[i * 2] = (char)0;
#line 297
            buffer.s8[i * 2 + 1] = (char)-128;
#line 295
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 301
        memset((void *)(buffer.s8), 128, (size_t )16384);
        }
      }
    } else {
      {
#line 303
      memset((void *)(buffer.s8), 0, (size_t )16384);
      }
    }
    {
#line 304
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 304
      if (! (l >= 16384L)) {
#line 304
        goto while_break___4;
      }
#line 305
      if (outf) {
        {
#line 305
        fwrite((void const   */* __restrict  */)(buffer.s8), (size_t )1, (size_t )16384,
               (FILE */* __restrict  */)outf);
        }
      }
#line 306
      l -= 16384L;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 308
    if (l) {
#line 308
      if (outf) {
        {
#line 308
        fwrite((void const   */* __restrict  */)(buffer.s8), (size_t )1, (size_t )l,
               (FILE */* __restrict  */)outf);
        }
      }
    }
  }
  {
#line 315
  start = clock();
#line 317
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"................................................................\n");
  }
  {
#line 318
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 324
    tmp___18 = duh_render(sr, depth, unsign, volume, delta, (long )bufsize, (void *)(& buffer));
#line 324
    l___0 = (int )tmp___18;
    }
#line 325
    if (depth == 16) {
#line 331
      if (bigendian) {
#line 332
        i = 0;
        {
#line 332
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 332
          if (! (i < l___0 * n_channels)) {
#line 332
            goto while_break___6;
          }
#line 333
          val = buffer.s16[i];
#line 334
          buffer.s8[i * 2] = (char )((int )val >> 8);
#line 335
          buffer.s8[i * 2 + 1] = (char )val;
#line 332
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 338
        i = 0;
        {
#line 338
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 338
          if (! (i < l___0 * n_channels)) {
#line 338
            goto while_break___7;
          }
#line 339
          val___0 = buffer.s16[i];
#line 340
          buffer.s8[i * 2] = (char )val___0;
#line 341
          buffer.s8[i * 2 + 1] = (char )((int )val___0 >> 8);
#line 338
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 345
    if (outf) {
      {
#line 345
      fwrite((void const   */* __restrict  */)(buffer.s8), (size_t )1, (size_t )((l___0 * n_channels) * (depth >> 3)),
             (FILE */* __restrict  */)outf);
      }
    }
#line 346
    if (l___0 < bufsize) {
#line 346
      goto while_break___5;
    }
#line 347
    done += (long long )l___0;
#line 348
    l___0 = (int )((done * 64LL) / length);
    {
#line 349
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 349
      if (dots < 64) {
#line 349
        if (! (l___0 > dots)) {
#line 349
          goto while_break___8;
        }
      } else {
#line 349
        goto while_break___8;
      }
      {
#line 350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|");
#line 351
      dots ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 355
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 355
    if (! (64 > dots)) {
#line 355
      goto while_break___9;
    }
    {
#line 356
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|");
#line 357
    dots ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 359
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 361
  end = clock();
#line 364
  duh_end_sigrenderer(sr);
#line 365
  unload_duh(duh);
  }
#line 366
  if (outf) {
#line 366
    if ((unsigned long )outf != (unsigned long )stdout) {
      {
#line 366
      fclose(outf);
      }
    }
  }
  {
#line 368
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Elapsed time: %f seconds\n",
          (double )((float )(end - start) / (float )1000000L));
  }
#line 370
  return (0);
}
}
#line 392 "include/dumb.h"
unsigned char const   *dumb_it_sd_get_song_message(DUMB_IT_SIGDATA *sd ) ;
#line 394
int dumb_it_sd_get_n_orders(DUMB_IT_SIGDATA *sd ) ;
#line 395
int dumb_it_sd_get_n_samples(DUMB_IT_SIGDATA *sd ) ;
#line 396
int dumb_it_sd_get_n_instruments(DUMB_IT_SIGDATA *sd ) ;
#line 398
unsigned char const   *dumb_it_sd_get_sample_name(DUMB_IT_SIGDATA *sd , int i ) ;
#line 399
unsigned char const   *dumb_it_sd_get_sample_filename(DUMB_IT_SIGDATA *sd , int i ) ;
#line 400
unsigned char const   *dumb_it_sd_get_instrument_name(DUMB_IT_SIGDATA *sd , int i ) ;
#line 401
unsigned char const   *dumb_it_sd_get_instrument_filename(DUMB_IT_SIGDATA *sd , int i ) ;
#line 403
int dumb_it_sd_get_initial_global_volume(DUMB_IT_SIGDATA *sd ) ;
#line 404
void dumb_it_sd_set_initial_global_volume(DUMB_IT_SIGDATA *sd , int gv ) ;
#line 406
int dumb_it_sd_get_mixing_volume(DUMB_IT_SIGDATA *sd ) ;
#line 407
void dumb_it_sd_set_mixing_volume(DUMB_IT_SIGDATA *sd , int mv ) ;
#line 409
int dumb_it_sd_get_initial_speed(DUMB_IT_SIGDATA *sd ) ;
#line 410
void dumb_it_sd_set_initial_speed(DUMB_IT_SIGDATA *sd , int speed ) ;
#line 412
int dumb_it_sd_get_initial_tempo(DUMB_IT_SIGDATA *sd ) ;
#line 413
void dumb_it_sd_set_initial_tempo(DUMB_IT_SIGDATA *sd , int tempo ) ;
#line 415
int dumb_it_sd_get_initial_channel_volume(DUMB_IT_SIGDATA *sd , int channel ) ;
#line 416
void dumb_it_sd_set_initial_channel_volume(DUMB_IT_SIGDATA *sd , int channel , int volume ) ;
#line 418
int dumb_it_sr_get_current_order(DUMB_IT_SIGRENDERER *sr ) ;
#line 419
int dumb_it_sr_get_current_row(DUMB_IT_SIGRENDERER *sr ) ;
#line 421
int dumb_it_sr_get_global_volume(DUMB_IT_SIGRENDERER *sr ) ;
#line 422
void dumb_it_sr_set_global_volume(DUMB_IT_SIGRENDERER *sr , int gv ) ;
#line 424
int dumb_it_sr_get_tempo(DUMB_IT_SIGRENDERER *sr ) ;
#line 425
void dumb_it_sr_set_tempo(DUMB_IT_SIGRENDERER *sr , int tempo ) ;
#line 427
int dumb_it_sr_get_speed(DUMB_IT_SIGRENDERER *sr ) ;
#line 428
void dumb_it_sr_set_speed(DUMB_IT_SIGRENDERER *sr , int speed ) ;
#line 435
int dumb_it_sr_get_channel_volume(DUMB_IT_SIGRENDERER *sr , int channel ) ;
#line 436
void dumb_it_sr_set_channel_volume(DUMB_IT_SIGRENDERER *sr , int channel , int volume ) ;
#line 438
int dumb_it_sr_get_channel_muted(DUMB_IT_SIGRENDERER *sr , int channel ) ;
#line 439
void dumb_it_sr_set_channel_muted(DUMB_IT_SIGRENDERER *sr , int channel , int muted ) ;
#line 540
extern sigdata_t *duh_get_raw_sigdata(DUH *duh , int sig , long type ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
DUMB_IT_SIGDATA *duh_get_it_sigdata(DUH *duh ) 
{ 
  sigdata_t *tmp ;

  {
  {
#line 27
  tmp = duh_get_raw_sigdata(duh, 0, (long )((((73U << 24) | (84U << 16)) | (32U << 8)) | 32U));
  }
#line 27
  return ((DUMB_IT_SIGDATA *)tmp);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
unsigned char const   *dumb_it_sd_get_song_message(DUMB_IT_SIGDATA *sd ) 
{ 
  unsigned char *tmp ;

  {
#line 34
  if (sd) {
#line 34
    tmp = sd->song_message;
  } else {
#line 34
    tmp = (unsigned char *)((void *)0);
  }
#line 34
  return ((unsigned char const   *)tmp);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_n_orders(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 41
  if (sd) {
#line 41
    tmp = sd->n_orders;
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_n_samples(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 48
  if (sd) {
#line 48
    tmp = sd->n_samples;
  } else {
#line 48
    tmp = 0;
  }
#line 48
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_n_instruments(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 55
  if (sd) {
#line 55
    tmp = sd->n_instruments;
  } else {
#line 55
    tmp = 0;
  }
#line 55
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
unsigned char const   *dumb_it_sd_get_sample_name(DUMB_IT_SIGDATA *sd , int i ) 
{ 


  {
#line 63
  return ((unsigned char const   *)((sd->sample + i)->name));
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
unsigned char const   *dumb_it_sd_get_sample_filename(DUMB_IT_SIGDATA *sd , int i ) 
{ 


  {
#line 71
  return ((unsigned char const   *)((sd->sample + i)->filename));
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
unsigned char const   *dumb_it_sd_get_instrument_name(DUMB_IT_SIGDATA *sd , int i ) 
{ 


  {
#line 79
  return ((unsigned char const   *)((sd->instrument + i)->name));
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
unsigned char const   *dumb_it_sd_get_instrument_filename(DUMB_IT_SIGDATA *sd , int i ) 
{ 


  {
#line 87
  return ((unsigned char const   *)((sd->instrument + i)->filename));
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_initial_global_volume(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 94
  if (sd) {
#line 94
    tmp = sd->global_volume;
  } else {
#line 94
    tmp = 0;
  }
#line 94
  return (tmp);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sd_set_initial_global_volume(DUMB_IT_SIGDATA *sd , int gv ) 
{ 


  {
#line 101
  if (sd) {
#line 101
    sd->global_volume = gv;
  }
#line 102
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_mixing_volume(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 108
  if (sd) {
#line 108
    tmp = sd->mixing_volume;
  } else {
#line 108
    tmp = 0;
  }
#line 108
  return (tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sd_set_mixing_volume(DUMB_IT_SIGDATA *sd , int mv ) 
{ 


  {
#line 115
  if (sd) {
#line 115
    sd->mixing_volume = mv;
  }
#line 116
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_initial_speed(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 122
  if (sd) {
#line 122
    tmp = sd->speed;
  } else {
#line 122
    tmp = 0;
  }
#line 122
  return (tmp);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sd_set_initial_speed(DUMB_IT_SIGDATA *sd , int speed ) 
{ 


  {
#line 129
  if (sd) {
#line 129
    sd->speed = speed;
  }
#line 130
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_initial_tempo(DUMB_IT_SIGDATA *sd ) 
{ 
  int tmp ;

  {
#line 136
  if (sd) {
#line 136
    tmp = sd->tempo;
  } else {
#line 136
    tmp = 0;
  }
#line 136
  return (tmp);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sd_set_initial_tempo(DUMB_IT_SIGDATA *sd , int tempo ) 
{ 


  {
#line 143
  if (sd) {
#line 143
    sd->tempo = tempo;
  }
#line 144
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sd_get_initial_channel_volume(DUMB_IT_SIGDATA *sd , int channel ) 
{ 
  int tmp ;

  {
#line 151
  if (sd) {
#line 151
    tmp = (int )sd->channel_volume[channel];
  } else {
#line 151
    tmp = 0;
  }
#line 151
  return (tmp);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sd_set_initial_channel_volume(DUMB_IT_SIGDATA *sd , int channel , int volume ) 
{ 


  {
#line 157
  if (sd) {
#line 157
    sd->channel_volume[channel] = (unsigned char )volume;
  }
#line 158
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_current_order(DUMB_IT_SIGRENDERER *sr ) 
{ 
  int tmp ;

  {
#line 164
  if (sr) {
#line 164
    tmp = sr->order;
  } else {
#line 164
    tmp = -1;
  }
#line 164
  return (tmp);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_current_row(DUMB_IT_SIGRENDERER *sr ) 
{ 
  int tmp ;

  {
#line 171
  if (sr) {
#line 171
    tmp = sr->row;
  } else {
#line 171
    tmp = -1;
  }
#line 171
  return (tmp);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_global_volume(DUMB_IT_SIGRENDERER *sr ) 
{ 
  int tmp ;

  {
#line 178
  if (sr) {
#line 178
    tmp = (int )sr->globalvolume;
  } else {
#line 178
    tmp = 0;
  }
#line 178
  return (tmp);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sr_set_global_volume(DUMB_IT_SIGRENDERER *sr , int gv ) 
{ 


  {
#line 185
  if (sr) {
#line 185
    sr->globalvolume = (unsigned char )gv;
  }
#line 186
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_tempo(DUMB_IT_SIGRENDERER *sr ) 
{ 
  int tmp ;

  {
#line 192
  if (sr) {
#line 192
    tmp = (int )sr->tempo;
  } else {
#line 192
    tmp = 0;
  }
#line 192
  return (tmp);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sr_set_tempo(DUMB_IT_SIGRENDERER *sr , int tempo ) 
{ 


  {
#line 199
  if (sr) {
#line 199
    sr->tempo = (unsigned char )tempo;
  }
#line 200
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_speed(DUMB_IT_SIGRENDERER *sr ) 
{ 
  int tmp ;

  {
#line 206
  if (sr) {
#line 206
    tmp = sr->speed;
  } else {
#line 206
    tmp = 0;
  }
#line 206
  return (tmp);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sr_set_speed(DUMB_IT_SIGRENDERER *sr , int speed ) 
{ 


  {
#line 213
  if (sr) {
#line 213
    sr->speed = speed;
  }
#line 214
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_channel_volume(DUMB_IT_SIGRENDERER *sr , int channel ) 
{ 
  int tmp ;

  {
#line 220
  if (sr) {
#line 220
    tmp = (int )sr->channel[channel].channelvolume;
  } else {
#line 220
    tmp = 0;
  }
#line 220
  return (tmp);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sr_set_channel_volume(DUMB_IT_SIGRENDERER *sr , int channel , int volume ) 
{ 


  {
#line 227
  if (sr) {
#line 227
    sr->channel[channel].channelvolume = (unsigned char )volume;
  }
#line 228
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
void dumb_it_sr_set_channel_muted(DUMB_IT_SIGRENDERER *sr , int channel , int muted ) 
{ 


  {
#line 234
  if (sr) {
#line 235
    if (muted) {
#line 236
      sr->channel[channel].flags |= 1;
    } else {
#line 238
      sr->channel[channel].flags &= -2;
    }
  }
#line 240
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itmisc.c"
int dumb_it_sr_get_channel_muted(DUMB_IT_SIGRENDERER *sr , int channel ) 
{ 
  int tmp ;

  {
#line 246
  if (sr) {
#line 246
    tmp = (sr->channel[channel].flags & 1) != 0;
  } else {
#line 246
    tmp = 0;
  }
#line 246
  return (tmp);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 214 "include/dumb.h"
char const   *duh_get_tag(DUH *duh , char const   *key ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/duhtag.c"
char const   *duh_get_tag(DUH *duh , char const   *key ) 
{ 
  int i ;
  int tmp ;

  {
#line 31
  if (! duh) {
#line 31
    return ((char const   *)((void *)0));
  } else
#line 31
  if (! duh->tag) {
#line 31
    return ((char const   *)((void *)0));
  }
#line 33
  i = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (i < duh->n_tags)) {
#line 33
      goto while_break;
    }
    {
#line 34
    tmp = strcmp(key, (char const   *)(*(duh->tag + i))[0]);
    }
#line 34
    if (tmp == 0) {
#line 35
      return ((char const   *)(*(duh->tag + i))[1]);
    }
#line 33
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return ((char const   *)((void *)0));
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 670 "include/dumb.h"
extern DUH *make_duh(long length , int n_tags , char const   * const  (*tag)[2] ,
                     int n_signals , DUH_SIGTYPE_DESC **desc , sigdata_t **sigdata ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_seek(DUMBFILE *f , long offset ) 
{ 
  long pos ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 34
  tmp = dumbfile_pos(f);
#line 34
  pos = tmp;
  }
#line 36
  if (pos > offset) {
#line 37
    return (-1);
  }
#line 39
  if (pos < offset) {
    {
#line 40
    tmp___0 = dumbfile_skip(f, offset - pos);
    }
#line 40
    if (tmp___0) {
#line 41
      return (-1);
    }
  }
#line 43
  return (0);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char *sourcebuf  =    (unsigned char *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char *sourcepos  =    (unsigned char *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char *sourceend  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int rembits  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int readblock(DUMBFILE *f ) 
{ 
  long size ;
  int c ;
  int tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 66
  tmp = dumbfile_igetw(f);
#line 66
  size = (long )tmp;
  }
#line 67
  if (size < 0L) {
#line 68
    return ((int )size);
  }
  {
#line 70
  tmp___0 = malloc((size_t )size);
#line 70
  sourcebuf = (unsigned char *)tmp___0;
  }
#line 71
  if (! sourcebuf) {
#line 72
    return (-1);
  }
  {
#line 74
  tmp___1 = dumbfile_getnc((char *)sourcebuf, size, f);
#line 74
  c = (int )tmp___1;
  }
#line 75
  if ((long )c < size) {
    {
#line 76
    free((void *)sourcebuf);
#line 77
    sourcebuf = (unsigned char *)((void *)0);
    }
#line 78
    return (-1);
  }
#line 81
  sourcepos = sourcebuf;
#line 82
  sourceend = sourcebuf + size;
#line 83
  rembits = 8;
#line 84
  return (0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static void freeblock(void) 
{ 


  {
  {
#line 91
  free((void *)sourcebuf);
#line 92
  sourcebuf = (unsigned char *)((void *)0);
  }
#line 93
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int readbits(int bitwidth ) 
{ 
  int val ;
  int b ;
  unsigned char *tmp ;

  {
#line 99
  val = 0;
#line 100
  b = 0;
#line 102
  if ((unsigned long )sourcepos >= (unsigned long )sourceend) {
#line 102
    return (val);
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (bitwidth > rembits)) {
#line 104
      goto while_break;
    }
#line 105
    tmp = sourcepos;
#line 105
    sourcepos ++;
#line 105
    val |= (int )*tmp << b;
#line 106
    if ((unsigned long )sourcepos >= (unsigned long )sourceend) {
#line 106
      return (val);
    }
#line 107
    b += rembits;
#line 108
    bitwidth -= rembits;
#line 109
    rembits = 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  val |= ((int )*sourcepos & ((1 << bitwidth) - 1)) << b;
#line 113
  *sourcepos = (unsigned char )((int )*sourcepos >> bitwidth);
#line 114
  rembits -= bitwidth;
#line 116
  return (val);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int decompress8(DUMBFILE *f , signed char *data , int len , int cmwt ) 
{ 
  int blocklen ;
  int blockpos ;
  byte bitwidth ;
  word val ;
  char d1 ;
  char d2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  byte border ;
  char v ;
  byte shift ;
  signed char *tmp___2 ;

  {
  {
#line 131
  memset((void *)data, 0, (unsigned long )len * sizeof(*data));
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (len > 0)) {
#line 133
      goto while_break;
    }
    {
#line 135
    tmp = readblock(f);
    }
#line 135
    if (tmp) {
#line 136
      return (-1);
    }
#line 138
    if (len < 32768) {
#line 138
      blocklen = len;
    } else {
#line 138
      blocklen = 32768;
    }
#line 139
    blockpos = 0;
#line 140
    bitwidth = (byte )9;
#line 141
    d2 = (char)0;
#line 141
    d1 = d2;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! (blockpos < blocklen)) {
#line 143
        goto while_break___0;
      }
      {
#line 145
      tmp___0 = readbits((int )bitwidth);
#line 145
      val = (word )tmp___0;
      }
#line 148
      if ((int )bitwidth < 7) {
#line 149
        if ((int )val == 1 << ((int )bitwidth - 1)) {
          {
#line 150
          tmp___1 = readbits(3);
#line 150
          val = (word )((int )((word )tmp___1) + 1);
          }
#line 151
          if ((int )val < (int )bitwidth) {
#line 151
            bitwidth = (byte )val;
          } else {
#line 151
            bitwidth = (byte )((int )val + 1);
          }
#line 152
          goto while_continue___0;
        }
      } else
#line 155
      if ((int )bitwidth < 9) {
#line 156
        border = (byte )((255 >> (9 - (int )bitwidth)) - 4);
#line 158
        if ((int )val > (int )border) {
#line 158
          if ((int )val <= (int )border + 8) {
#line 159
            val = (word )((int )val - (int )border);
#line 160
            if ((int )val < (int )bitwidth) {
#line 160
              bitwidth = (byte )val;
            } else {
#line 160
              bitwidth = (byte )((int )val + 1);
            }
#line 161
            goto while_continue___0;
          }
        }
      } else
#line 164
      if ((int )bitwidth == 9) {
#line 165
        if ((int )val & 256) {
#line 166
          bitwidth = (byte )(((int )val + 1) & 255);
#line 167
          goto while_continue___0;
        }
      } else {
        {
#line 171
        freeblock();
        }
#line 172
        return (-1);
      }
#line 178
      if ((int )bitwidth < 8) {
#line 179
        shift = (byte )(8 - (int )bitwidth);
#line 180
        v = (char )((int )val << (int )shift);
#line 181
        v = (char )((int )v >> (int )shift);
      } else {
#line 184
        v = (char )val;
      }
#line 188
      d1 = (char )((int )d1 + (int )v);
#line 189
      d2 = (char )((int )d2 + (int )d1);
#line 196
      tmp___2 = data;
#line 196
      data ++;
#line 196
      if (cmwt == 533) {
#line 196
        *tmp___2 = (signed char )d2;
      } else {
#line 196
        *tmp___2 = (signed char )d1;
      }
#line 197
      len --;
#line 198
      blockpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 200
    freeblock();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int decompress16(DUMBFILE *f , short *data , int len , int cmwt ) 
{ 
  int blocklen ;
  int blockpos ;
  byte bitwidth ;
  long val ;
  short d1 ;
  short d2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  word border ;
  short v ;
  byte shift ;
  short *tmp___2 ;

  {
  {
#line 214
  memset((void *)data, 0, (unsigned long )len * sizeof(*data));
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (len > 0)) {
#line 216
      goto while_break;
    }
    {
#line 218
    tmp = readblock(f);
    }
#line 218
    if (tmp) {
#line 219
      return (-1);
    }
#line 221
    if (len < 16384) {
#line 221
      blocklen = len;
    } else {
#line 221
      blocklen = 16384;
    }
#line 222
    blockpos = 0;
#line 223
    bitwidth = (byte )17;
#line 224
    d2 = (short)0;
#line 224
    d1 = d2;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (blockpos < blocklen)) {
#line 226
        goto while_break___0;
      }
      {
#line 227
      tmp___0 = readbits((int )bitwidth);
#line 227
      val = (long )tmp___0;
      }
#line 230
      if ((int )bitwidth < 7) {
#line 231
        if (val == (long )(1 << ((int )bitwidth - 1))) {
          {
#line 232
          tmp___1 = readbits(4);
#line 232
          val = (long )(tmp___1 + 1);
          }
#line 233
          if (val < (long )bitwidth) {
#line 233
            bitwidth = (byte )val;
          } else {
#line 233
            bitwidth = (byte )(val + 1L);
          }
#line 234
          goto while_continue___0;
        }
      } else
#line 237
      if ((int )bitwidth < 17) {
#line 238
        border = (word )((65535 >> (17 - (int )bitwidth)) - 8);
#line 240
        if (val > (long )border) {
#line 240
          if (val <= (long )((int )border + 16)) {
#line 241
            val -= (long )border;
#line 242
            if (val < (long )bitwidth) {
#line 242
              bitwidth = (byte )val;
            } else {
#line 242
              bitwidth = (byte )(val + 1L);
            }
#line 243
            goto while_continue___0;
          }
        }
      } else
#line 246
      if ((int )bitwidth == 17) {
#line 247
        if (val & 65536L) {
#line 248
          bitwidth = (byte )((val + 1L) & 255L);
#line 249
          goto while_continue___0;
        }
      } else {
        {
#line 253
        freeblock();
        }
#line 254
        return (-1);
      }
#line 260
      if ((int )bitwidth < 16) {
#line 261
        shift = (byte )(16 - (int )bitwidth);
#line 262
        v = (short )(val << (int )shift);
#line 263
        v = (short )((int )v >> (int )shift);
      } else {
#line 266
        v = (short )val;
      }
#line 270
      d1 = (short )((int )d1 + (int )v);
#line 271
      d2 = (short )((int )d2 + (int )d1);
#line 278
      tmp___2 = data;
#line 278
      data ++;
#line 278
      if (cmwt == 533) {
#line 278
        *tmp___2 = d2;
      } else {
#line 278
        *tmp___2 = d1;
      }
#line 279
      len --;
#line 280
      blockpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 282
    freeblock();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (0);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_envelope(IT_ENVELOPE *envelope , DUMBFILE *f ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 293
  tmp = dumbfile_getc(f);
#line 293
  envelope->flags = (unsigned char )tmp;
#line 294
  tmp___0 = dumbfile_getc(f);
#line 294
  envelope->n_nodes = (unsigned char )tmp___0;
  }
#line 295
  if ((int )envelope->n_nodes > 25) {
#line 297
    envelope->n_nodes = (unsigned char)0;
#line 298
    return (-1);
  }
  {
#line 300
  tmp___1 = dumbfile_getc(f);
#line 300
  envelope->loop_start = (unsigned char )tmp___1;
#line 301
  tmp___2 = dumbfile_getc(f);
#line 301
  envelope->loop_end = (unsigned char )tmp___2;
#line 302
  tmp___3 = dumbfile_getc(f);
#line 302
  envelope->sus_loop_start = (unsigned char )tmp___3;
#line 303
  tmp___4 = dumbfile_getc(f);
#line 303
  envelope->sus_loop_end = (unsigned char )tmp___4;
#line 304
  n = 0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (n < (int )envelope->n_nodes)) {
#line 304
      goto while_break;
    }
    {
#line 305
    tmp___5 = dumbfile_getc(f);
#line 305
    envelope->node_y[n] = (signed char )tmp___5;
#line 306
    tmp___6 = dumbfile_igetw(f);
#line 306
    envelope->node_t[n] = (unsigned short )tmp___6;
#line 304
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  dumbfile_skip(f, (long )((75 - (int )envelope->n_nodes * 3) + 1));
  }
#line 310
  if ((int )envelope->n_nodes <= 0) {
#line 311
    envelope->flags = (unsigned char )((int )envelope->flags & -2);
  } else {
#line 313
    if ((int )envelope->loop_end >= (int )envelope->n_nodes) {
#line 313
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    } else
#line 313
    if ((int )envelope->loop_start > (int )envelope->loop_end) {
#line 313
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    }
#line 314
    if ((int )envelope->sus_loop_end >= (int )envelope->n_nodes) {
#line 314
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    } else
#line 314
    if ((int )envelope->sus_loop_start > (int )envelope->sus_loop_end) {
#line 314
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    }
  }
  {
#line 317
  tmp___7 = dumbfile_error(f);
  }
#line 317
  return (tmp___7);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_old_instrument(IT_INSTRUMENT *instrument , DUMBFILE *f ) 
{ 
  int n ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  IT_ENVELOPE *envelope ;

  {
  {
#line 326
  tmp = dumbfile_mgetl(f);
  }
#line 326
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 73U)) {
#line 327
    return (-1);
  }
  {
#line 329
  dumbfile_getnc((char *)(instrument->filename), 13L, f);
#line 330
  instrument->filename[13] = (unsigned char)0;
#line 332
  tmp___0 = dumbfile_getc(f);
#line 332
  instrument->volume_envelope.flags = (unsigned char )tmp___0;
#line 333
  tmp___1 = dumbfile_getc(f);
#line 333
  instrument->volume_envelope.loop_start = (unsigned char )tmp___1;
#line 334
  tmp___2 = dumbfile_getc(f);
#line 334
  instrument->volume_envelope.loop_end = (unsigned char )tmp___2;
#line 335
  tmp___3 = dumbfile_getc(f);
#line 335
  instrument->volume_envelope.sus_loop_start = (unsigned char )tmp___3;
#line 336
  tmp___4 = dumbfile_getc(f);
#line 336
  instrument->volume_envelope.sus_loop_end = (unsigned char )tmp___4;
#line 339
  dumbfile_skip(f, 2L);
#line 347
  tmp___5 = dumbfile_igetw(f);
#line 347
  instrument->fadeout = tmp___5 << 1;
#line 348
  tmp___6 = dumbfile_getc(f);
#line 348
  instrument->new_note_action = (unsigned char )tmp___6;
#line 349
  tmp___7 = dumbfile_getc(f);
#line 349
  instrument->dup_check_type = (unsigned char )tmp___7;
#line 350
  instrument->dup_check_action = (unsigned char)0;
#line 356
  dumbfile_skip(f, 4L);
#line 358
  dumbfile_getnc((char *)(instrument->name), 26L, f);
#line 359
  instrument->name[26] = (unsigned char)0;
#line 362
  dumbfile_skip(f, 6L);
#line 364
  instrument->pp_separation = (unsigned char)0;
#line 365
  instrument->pp_centre = (unsigned char)60;
#line 366
  instrument->global_volume = (unsigned char)128;
#line 368
  instrument->default_pan = (unsigned char)32;
#line 370
  instrument->random_volume = (unsigned char)0;
#line 371
  instrument->random_pan = (unsigned char)0;
#line 373
  n = 0;
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (n < 120)) {
#line 373
      goto while_break;
    }
    {
#line 374
    tmp___8 = dumbfile_getc(f);
#line 374
    instrument->map_note[n] = (unsigned char )tmp___8;
#line 375
    tmp___9 = dumbfile_getc(f);
#line 375
    instrument->map_sample[n] = (unsigned short )tmp___9;
#line 373
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  dumbfile_skip(f, 200L);
#line 383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Inst %02d Env:",
          n);
#line 386
  n = 0;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (n < 25)) {
#line 386
      goto while_break___0;
    }
    {
#line 388
    tmp___10 = dumbfile_getc(f);
#line 388
    instrument->volume_envelope.node_t[n] = (unsigned short )tmp___10;
#line 389
    tmp___11 = dumbfile_getc(f);
#line 389
    instrument->volume_envelope.node_y[n] = (signed char )tmp___11;
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d,%d",
            (int )instrument->volume_envelope.node_t[n], (int )instrument->volume_envelope.node_y[n]);
#line 386
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  dumbfile_skip(f, (long )(50 - (n << 1)));
#line 402
  instrument->volume_envelope.n_nodes = (unsigned char )n;
#line 405
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 408
  tmp___12 = dumbfile_error(f);
  }
#line 408
  if (tmp___12) {
#line 409
    return (-1);
  }
#line 412
  envelope = & instrument->volume_envelope;
#line 413
  if ((int )envelope->n_nodes <= 0) {
#line 414
    envelope->flags = (unsigned char )((int )envelope->flags & -2);
  } else {
#line 416
    if ((int )envelope->loop_end >= (int )envelope->n_nodes) {
#line 416
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    } else
#line 416
    if ((int )envelope->loop_start > (int )envelope->loop_end) {
#line 416
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    }
#line 417
    if ((int )envelope->sus_loop_end >= (int )envelope->n_nodes) {
#line 417
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    } else
#line 417
    if ((int )envelope->sus_loop_start > (int )envelope->sus_loop_end) {
#line 417
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    }
  }
#line 421
  instrument->filter_cutoff = (unsigned char)127;
#line 422
  instrument->filter_resonance = (unsigned char)0;
#line 424
  instrument->pan_envelope.flags = (unsigned char)0;
#line 425
  instrument->pitch_envelope.flags = (unsigned char)0;
#line 427
  return (0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_instrument(IT_INSTRUMENT *instrument , DUMBFILE *f ) 
{ 
  int n ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 436
  tmp = dumbfile_mgetl(f);
  }
#line 436
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 73U)) {
#line 437
    return (-1);
  }
  {
#line 439
  dumbfile_getnc((char *)(instrument->filename), 13L, f);
#line 440
  instrument->filename[13] = (unsigned char)0;
#line 442
  tmp___0 = dumbfile_getc(f);
#line 442
  instrument->new_note_action = (unsigned char )tmp___0;
#line 443
  tmp___1 = dumbfile_getc(f);
#line 443
  instrument->dup_check_type = (unsigned char )tmp___1;
#line 444
  tmp___2 = dumbfile_getc(f);
#line 444
  instrument->dup_check_action = (unsigned char )tmp___2;
#line 445
  instrument->fadeout = dumbfile_igetw(f);
#line 446
  tmp___3 = dumbfile_getc(f);
#line 446
  instrument->pp_separation = (unsigned char )tmp___3;
#line 447
  tmp___4 = dumbfile_getc(f);
#line 447
  instrument->pp_centre = (unsigned char )tmp___4;
#line 448
  tmp___5 = dumbfile_getc(f);
#line 448
  instrument->global_volume = (unsigned char )tmp___5;
#line 449
  tmp___6 = dumbfile_getc(f);
#line 449
  instrument->default_pan = (unsigned char )tmp___6;
#line 450
  tmp___7 = dumbfile_getc(f);
#line 450
  instrument->random_volume = (unsigned char )tmp___7;
#line 451
  tmp___8 = dumbfile_getc(f);
#line 451
  instrument->random_pan = (unsigned char )tmp___8;
#line 456
  dumbfile_skip(f, 4L);
#line 458
  dumbfile_getnc((char *)(instrument->name), 26L, f);
#line 459
  instrument->name[26] = (unsigned char)0;
#line 461
  tmp___9 = dumbfile_getc(f);
#line 461
  instrument->filter_cutoff = (unsigned char )tmp___9;
#line 462
  tmp___10 = dumbfile_getc(f);
#line 462
  instrument->filter_resonance = (unsigned char )tmp___10;
#line 465
  dumbfile_skip(f, 4L);
#line 467
  n = 0;
  }
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (n < 120)) {
#line 467
      goto while_break;
    }
    {
#line 468
    tmp___11 = dumbfile_getc(f);
#line 468
    instrument->map_note[n] = (unsigned char )tmp___11;
#line 469
    tmp___12 = dumbfile_getc(f);
#line 469
    instrument->map_sample[n] = (unsigned short )tmp___12;
#line 467
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  tmp___13 = dumbfile_error(f);
  }
#line 472
  if (tmp___13) {
#line 473
    return (-1);
  }
  {
#line 475
  tmp___14 = it_read_envelope(& instrument->volume_envelope, f);
  }
#line 475
  if (tmp___14) {
#line 475
    return (-1);
  }
  {
#line 476
  tmp___15 = it_read_envelope(& instrument->pan_envelope, f);
  }
#line 476
  if (tmp___15) {
#line 476
    return (-1);
  }
  {
#line 477
  tmp___16 = it_read_envelope(& instrument->pitch_envelope, f);
  }
#line 477
  if (tmp___16) {
#line 477
    return (-1);
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_sample_header(IT_SAMPLE *sample , unsigned char *convert , long *offset ,
                                 DUMBFILE *f ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 486
  tmp = dumbfile_mgetl(f);
  }
#line 486
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 83U)) {
#line 487
    return (-1);
  }
  {
#line 489
  dumbfile_getnc((char *)(sample->filename), 13L, f);
#line 490
  sample->filename[13] = (unsigned char)0;
#line 492
  tmp___0 = dumbfile_getc(f);
#line 492
  sample->global_volume = (unsigned char )tmp___0;
#line 493
  tmp___1 = dumbfile_getc(f);
#line 493
  sample->flags = (unsigned char )tmp___1;
#line 494
  tmp___2 = dumbfile_getc(f);
#line 494
  sample->default_volume = (unsigned char )tmp___2;
#line 496
  dumbfile_getnc((char *)(sample->name), 26L, f);
#line 497
  sample->name[26] = (unsigned char)0;
#line 499
  tmp___3 = dumbfile_getc(f);
#line 499
  *convert = (unsigned char )tmp___3;
#line 500
  tmp___4 = dumbfile_getc(f);
#line 500
  sample->default_pan = (unsigned char )tmp___4;
#line 501
  sample->length = dumbfile_igetl(f);
#line 502
  sample->loop_start = dumbfile_igetl(f);
#line 503
  sample->loop_end = dumbfile_igetl(f);
#line 504
  sample->C5_speed = dumbfile_igetl(f);
#line 505
  sample->sus_loop_start = dumbfile_igetl(f);
#line 506
  sample->sus_loop_end = dumbfile_igetl(f);
  }
#line 509
  if ((int )sample->flags & 4) {
#line 510
    sample->length >>= 1;
#line 511
    sample->loop_start >>= 1;
#line 512
    sample->loop_end >>= 1;
#line 513
    sample->C5_speed >>= 1;
#line 514
    sample->sus_loop_start >>= 1;
#line 515
    sample->sus_loop_end >>= 1;
  }
#line 519
  if ((int )sample->flags & 1) {
#line 520
    if (sample->length <= 0L) {
#line 521
      sample->flags = (unsigned char )((int )sample->flags & -2);
    } else {
#line 523
      if ((unsigned int )sample->loop_end > (unsigned int )sample->length) {
#line 524
        sample->flags = (unsigned char )((int )sample->flags & -17);
      } else
#line 525
      if ((unsigned int )sample->loop_start >= (unsigned int )sample->loop_end) {
#line 526
        sample->flags = (unsigned char )((int )sample->flags & -17);
      }
#line 528
      if ((unsigned int )sample->sus_loop_end > (unsigned int )sample->length) {
#line 529
        sample->flags = (unsigned char )((int )sample->flags & -33);
      } else
#line 530
      if ((unsigned int )sample->sus_loop_start >= (unsigned int )sample->sus_loop_end) {
#line 531
        sample->flags = (unsigned char )((int )sample->flags & -33);
      }
#line 534
      if ((int )sample->flags & 16) {
#line 535
        if ((int )sample->flags & 32) {
#line 535
          if (sample->sus_loop_end >= sample->loop_end) {
#line 536
            sample->length = sample->sus_loop_end;
          } else {
#line 538
            sample->length = sample->loop_end;
          }
        } else {
#line 538
          sample->length = sample->loop_end;
        }
      }
    }
  }
  {
#line 543
  *offset = dumbfile_igetl(f);
#line 545
  tmp___5 = dumbfile_getc(f);
#line 545
  sample->vibrato_speed = (unsigned char )tmp___5;
#line 546
  tmp___6 = dumbfile_getc(f);
#line 546
  sample->vibrato_depth = (unsigned char )tmp___6;
#line 547
  tmp___7 = dumbfile_getc(f);
#line 547
  sample->vibrato_rate = (unsigned char )tmp___7;
#line 548
  tmp___8 = dumbfile_getc(f);
#line 548
  sample->vibrato_waveform = (unsigned char )tmp___8;
#line 550
  tmp___9 = dumbfile_error(f);
  }
#line 550
  return (tmp___9);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static long it_read_sample_data(int cmwt , IT_SAMPLE *sample , unsigned char convert ,
                                DUMBFILE *f ) 
{ 
  long n ;
  long datasize ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 559
  datasize = sample->length;
#line 560
  if ((int )sample->flags & 4) {
#line 560
    datasize <<= 1;
  }
#line 562
  if ((int )sample->flags & 2) {
#line 562
    tmp = 2;
  } else {
#line 562
    tmp = 1;
  }
  {
#line 562
  sample->data = malloc((size_t )(datasize * (long )tmp));
  }
#line 563
  if (! sample->data) {
#line 564
    return (-1L);
  }
#line 566
  if ((int )sample->flags & 8) {
#line 571
    if ((int )sample->flags & 4) {
      {
#line 572
      exit(37);
      }
    }
#line 579
    if ((int )sample->flags & 2) {
      {
#line 580
      decompress16(f, (short *)sample->data, (int )datasize, cmwt);
      }
    } else {
      {
#line 582
      decompress8(f, (signed char *)sample->data, (int )datasize, cmwt);
      }
    }
  } else
#line 583
  if ((int )sample->flags & 2) {
#line 584
    if ((int )convert & 2) {
#line 585
      n = 0L;
      {
#line 585
      while (1) {
        while_continue: /* CIL Label */ ;
#line 585
        if (! (n < datasize)) {
#line 585
          goto while_break;
        }
        {
#line 586
        tmp___0 = dumbfile_mgetw(f);
#line 586
        *((short *)sample->data + n) = (short )tmp___0;
#line 585
        n ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 588
      n = 0L;
      {
#line 588
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 588
        if (! (n < datasize)) {
#line 588
          goto while_break___0;
        }
        {
#line 589
        tmp___1 = dumbfile_igetw(f);
#line 589
        *((short *)sample->data + n) = (short )tmp___1;
#line 588
        n ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 591
    n = 0L;
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 591
      if (! (n < datasize)) {
#line 591
        goto while_break___1;
      }
      {
#line 592
      tmp___2 = dumbfile_getc(f);
#line 592
      *((signed char *)sample->data + n) = (signed char )tmp___2;
#line 591
      n ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 594
  tmp___3 = dumbfile_error(f);
  }
#line 594
  if (tmp___3) {
#line 595
    return (-1L);
  }
#line 597
  if (! ((int )convert & 1)) {
#line 599
    if ((int )sample->flags & 2) {
#line 600
      n = 0L;
      {
#line 600
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 600
        if (! (n < datasize)) {
#line 600
          goto while_break___2;
        }
#line 601
        *((short *)sample->data + n) = (short )((int )*((short *)sample->data + n) ^ 32768);
#line 600
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 603
      n = 0L;
      {
#line 603
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 603
        if (! (n < datasize)) {
#line 603
          goto while_break___3;
        }
#line 604
        *((signed char *)sample->data + n) = (signed char )((int )*((signed char *)sample->data + n) ^ 128);
#line 603
        n ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 614
  return (0L);
}
}
#line 690
static int it_read_pattern(IT_PATTERN *pattern , DUMBFILE *f , unsigned char *buffer___0 ) ;
#line 690 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char const   used[16]  = 
#line 690
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )5};
#line 623 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_pattern(IT_PATTERN *pattern , DUMBFILE *f , unsigned char *buffer___0 ) 
{ 
  unsigned char cmask[64] ;
  unsigned char cnote[64] ;
  unsigned char cinstrument[64] ;
  unsigned char cvolpan[64] ;
  unsigned char ceffect[64] ;
  unsigned char ceffectvalue[64] ;
  IT_ENTRY *dupentry[64] ;
  int n_entries ;
  int buflen ;
  int bufpos ;
  IT_ENTRY *entry ;
  unsigned char channel ;
  unsigned char mask ;
  int i ;
  int tmp ;
  int tmp___0 ;
  unsigned char b ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned char b___0 ;
  int tmp___4 ;
  int i___0 ;
  int tmp___5 ;
  unsigned char tmp___6 ;
  int tmp___7 ;
  unsigned char tmp___8 ;
  int tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  unsigned char tmp___12 ;
  int tmp___13 ;
  unsigned char tmp___14 ;
  int tmp___15 ;
  FILE *f___0 ;
  FILE *tmp___16 ;

  {
  {
#line 635
  n_entries = 0;
#line 637
  bufpos = 0;
#line 644
  memset((void *)(cmask), 0, sizeof(cmask));
#line 645
  memset((void *)(cnote), 0, sizeof(cnote));
#line 646
  memset((void *)(cinstrument), 0, sizeof(cinstrument));
#line 647
  memset((void *)(cvolpan), 0, sizeof(cvolpan));
#line 648
  memset((void *)(ceffect), 0, sizeof(ceffect));
#line 649
  memset((void *)(ceffectvalue), 0, sizeof(ceffectvalue));
#line 653
  i = 0;
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (i < 64)) {
#line 653
      goto while_break;
    }
#line 653
    dupentry[i] = (IT_ENTRY *)((void *)0);
#line 653
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  buflen = dumbfile_igetw(f);
#line 658
  pattern->n_rows = dumbfile_igetw(f);
#line 661
  dumbfile_skip(f, 4L);
#line 663
  tmp = dumbfile_error(f);
  }
#line 663
  if (tmp) {
#line 664
    return (-1);
  }
  {
#line 667
  dumbfile_getnc((char *)buffer___0, (long )buflen, f);
#line 669
  tmp___0 = dumbfile_error(f);
  }
#line 669
  if (tmp___0) {
#line 670
    return (-1);
  }
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 673
    if (! (bufpos < buflen)) {
#line 673
      goto while_break___0;
    }
#line 674
    tmp___1 = bufpos;
#line 674
    bufpos ++;
#line 674
    b = *(buffer___0 + tmp___1);
#line 676
    if ((int )b == 0) {
#line 678
      n_entries ++;
#line 679
      goto while_continue___0;
    }
#line 682
    channel = (unsigned char )(((int )b - 1) & 63);
#line 684
    if ((int )b & 128) {
#line 685
      tmp___2 = bufpos;
#line 685
      bufpos ++;
#line 685
      mask = *(buffer___0 + tmp___2);
#line 685
      cmask[channel] = mask;
    } else {
#line 687
      mask = cmask[channel];
    }
#line 691
    n_entries += (int )mask != 0;
#line 692
    bufpos += (int )used[(int )mask & 15];
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 696
  pattern->n_entries = n_entries;
#line 698
  tmp___3 = malloc((unsigned long )n_entries * sizeof(*(pattern->entry)));
#line 698
  pattern->entry = (IT_ENTRY *)tmp___3;
  }
#line 700
  if (! pattern->entry) {
#line 701
    return (-1);
  }
  {
#line 703
  bufpos = 0;
#line 704
  memset((void *)(cmask), 0, sizeof(cmask));
#line 706
  entry = pattern->entry;
  }
  {
#line 708
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 708
    if (! (bufpos < buflen)) {
#line 708
      goto while_break___1;
    }
#line 709
    tmp___4 = bufpos;
#line 709
    bufpos ++;
#line 709
    b___0 = *(buffer___0 + tmp___4);
#line 711
    if ((int )b___0 == 0) {
#line 713
      entry->channel = (unsigned char)255;
#line 714
      entry ++;
#line 718
      i___0 = 0;
      {
#line 718
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 718
        if (! (i___0 < 64)) {
#line 718
          goto while_break___2;
        }
#line 718
        dupentry[i___0] = (IT_ENTRY *)((void *)0);
#line 718
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 721
      goto while_continue___1;
    }
#line 724
    channel = (unsigned char )(((int )b___0 - 1) & 63);
#line 726
    if ((int )b___0 & 128) {
#line 727
      tmp___5 = bufpos;
#line 727
      bufpos ++;
#line 727
      mask = *(buffer___0 + tmp___5);
#line 727
      cmask[channel] = mask;
    } else {
#line 729
      mask = cmask[channel];
    }
#line 731
    if (mask) {
#line 732
      entry->mask = (unsigned char )(((int )mask & 15) | ((int )mask >> 4));
#line 733
      entry->channel = channel;
#line 735
      if ((int )mask & 1) {
#line 736
        tmp___7 = bufpos;
#line 736
        bufpos ++;
#line 736
        tmp___6 = *(buffer___0 + tmp___7);
#line 736
        entry->note = tmp___6;
#line 736
        cnote[channel] = tmp___6;
      } else
#line 737
      if ((int )mask & (1 << 4)) {
#line 738
        entry->note = cnote[channel];
      }
#line 740
      if ((int )mask & 2) {
#line 741
        tmp___9 = bufpos;
#line 741
        bufpos ++;
#line 741
        tmp___8 = *(buffer___0 + tmp___9);
#line 741
        entry->instrument = tmp___8;
#line 741
        cinstrument[channel] = tmp___8;
      } else
#line 742
      if ((int )mask & (2 << 4)) {
#line 743
        entry->instrument = cinstrument[channel];
      }
#line 745
      if ((int )mask & 4) {
#line 746
        tmp___11 = bufpos;
#line 746
        bufpos ++;
#line 746
        tmp___10 = *(buffer___0 + tmp___11);
#line 746
        entry->volpan = tmp___10;
#line 746
        cvolpan[channel] = tmp___10;
      } else
#line 747
      if ((int )mask & (4 << 4)) {
#line 748
        entry->volpan = cvolpan[channel];
      }
#line 750
      if ((int )mask & 8) {
#line 751
        tmp___13 = bufpos;
#line 751
        bufpos ++;
#line 751
        tmp___12 = *(buffer___0 + tmp___13);
#line 751
        entry->effect = tmp___12;
#line 751
        ceffect[channel] = tmp___12;
#line 752
        tmp___15 = bufpos;
#line 752
        bufpos ++;
#line 752
        tmp___14 = *(buffer___0 + tmp___15);
#line 752
        entry->effectvalue = tmp___14;
#line 752
        ceffectvalue[channel] = tmp___14;
      } else {
#line 754
        entry->effect = ceffect[channel];
#line 755
        entry->effectvalue = ceffectvalue[channel];
      }
#line 759
      if (dupentry[channel]) {
        {
#line 760
        tmp___16 = fopen((char const   */* __restrict  */)"dupentry.txt", (char const   */* __restrict  */)"a");
#line 760
        f___0 = tmp___16;
        }
#line 761
        if (! f___0) {
          {
#line 761
          abort();
          }
        }
        {
#line 762
        fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Two events on channel %d:",
                (int )channel);
#line 763
        fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"  Event #1:");
        }
#line 764
        if ((int )(dupentry[channel])->mask & 1) {
          {
#line 764
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )(dupentry[channel])->note);
          }
        } else {
          {
#line 764
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 765
        if ((int )(dupentry[channel])->mask & 2) {
          {
#line 765
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )(dupentry[channel])->instrument);
          }
        } else {
          {
#line 765
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 766
        if ((int )(dupentry[channel])->mask & 4) {
          {
#line 766
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )(dupentry[channel])->volpan);
          }
        } else {
          {
#line 766
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 767
        if ((int )(dupentry[channel])->mask & 8) {
          {
#line 767
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %c%02X\n",
                  64 + (int )(dupentry[channel])->effect, (int )(dupentry[channel])->effectvalue);
          }
        } else {
          {
#line 767
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...\n");
          }
        }
        {
#line 768
        fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"  Event #2:");
        }
#line 769
        if ((int )entry->mask & 1) {
          {
#line 769
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )entry->note);
          }
        } else {
          {
#line 769
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 770
        if ((int )entry->mask & 2) {
          {
#line 770
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )entry->instrument);
          }
        } else {
          {
#line 770
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 771
        if ((int )entry->mask & 4) {
          {
#line 771
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )entry->volpan);
          }
        } else {
          {
#line 771
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 772
        if ((int )entry->mask & 8) {
          {
#line 772
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %c%02X\n",
                  64 + (int )entry->effect, (int )entry->effectvalue);
          }
        } else {
          {
#line 772
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...\n");
          }
        }
        {
#line 773
        fclose(f___0);
        }
      }
#line 775
      dupentry[channel] = entry;
#line 778
      entry ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 784
  return (0);
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_component_compare(void const   *e1 , void const   *e2 ) 
{ 


  {
#line 813
  return ((int )(((IT_COMPONENT const   *)e1)->offset - ((IT_COMPONENT const   *)e2)->offset));
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static sigdata_t *it_load_sigdata(DUMBFILE *f ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int cwt ;
  int cmwt ;
  int special ;
  int message_length ;
  int message_offset ;
  IT_COMPONENT *component ;
  int n_components ;
  unsigned char sample_convert[256] ;
  int n ;
  unsigned char *buffer___0 ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  long offset ;
  long tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  unsigned char mididata[32] ;
  int i ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char len ;
  int j ;
  int leftdigit ;
  long tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  unsigned char tmp___19 ;
  unsigned char tmp___20 ;
  unsigned char tmp___21 ;
  unsigned char len___0 ;
  int j___0 ;
  int leftdigit___0 ;
  unsigned char tmp___22 ;
  unsigned char tmp___23 ;
  unsigned char tmp___24 ;
  unsigned char tmp___25 ;
  void *tmp___26 ;
  long offset___0 ;
  int m ;
  int tmp___27 ;
  void *tmp___28 ;
  long tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  short *sample ;
  int tmp___32 ;
  long tmp___33 ;

  {
  {
#line 828
  n_components = 0;
#line 836
  tmp = dumbfile_mgetl(f);
  }
#line 836
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 77U)) {
#line 837
    return ((void *)0);
  }
  {
#line 839
  tmp___0 = malloc(sizeof(*sigdata));
#line 839
  sigdata = (DUMB_IT_SIGDATA *)tmp___0;
  }
#line 841
  if (! sigdata) {
#line 842
    return ((void *)0);
  }
  {
#line 844
  sigdata->song_message = (unsigned char *)((void *)0);
#line 845
  sigdata->order = (unsigned char *)((void *)0);
#line 846
  sigdata->instrument = (IT_INSTRUMENT *)((void *)0);
#line 847
  sigdata->sample = (IT_SAMPLE *)((void *)0);
#line 848
  sigdata->pattern = (IT_PATTERN *)((void *)0);
#line 849
  sigdata->midi = (IT_MIDI *)((void *)0);
#line 850
  sigdata->checkpoint = (IT_CHECKPOINT *)((void *)0);
#line 852
  dumbfile_getnc((char *)(sigdata->name), 26L, f);
#line 853
  sigdata->name[26] = (unsigned char)0;
#line 856
  dumbfile_skip(f, 2L);
#line 858
  sigdata->n_orders = dumbfile_igetw(f);
#line 859
  sigdata->n_instruments = dumbfile_igetw(f);
#line 860
  sigdata->n_samples = dumbfile_igetw(f);
#line 861
  sigdata->n_patterns = dumbfile_igetw(f);
#line 863
  cwt = dumbfile_igetw(f);
#line 864
  cmwt = dumbfile_igetw(f);
#line 866
  sigdata->flags = dumbfile_igetw(f);
#line 867
  special = dumbfile_igetw(f);
#line 869
  sigdata->global_volume = dumbfile_getc(f);
#line 870
  sigdata->mixing_volume = dumbfile_getc(f);
#line 871
  sigdata->speed = dumbfile_getc(f);
  }
#line 872
  if (sigdata->speed == 0) {
#line 872
    sigdata->speed = 6;
  }
  {
#line 873
  sigdata->tempo = dumbfile_getc(f);
#line 874
  sigdata->pan_separation = dumbfile_getc(f);
#line 877
  dumbfile_skip(f, 1L);
#line 879
  message_length = dumbfile_igetw(f);
#line 880
  tmp___1 = dumbfile_igetl(f);
#line 880
  message_offset = (int )tmp___1;
#line 883
  dumbfile_skip(f, 4L);
#line 885
  dumbfile_getnc((char *)(sigdata->channel_pan), 64L, f);
#line 886
  dumbfile_getnc((char *)(sigdata->channel_volume), 64L, f);
#line 888
  tmp___2 = dumbfile_error(f);
  }
#line 888
  if (tmp___2) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_orders <= 0) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_instruments > 256) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_samples > 256) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_patterns > 256) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  }
  {
#line 893
  tmp___3 = malloc((size_t )sigdata->n_orders);
#line 893
  sigdata->order = (unsigned char *)tmp___3;
  }
#line 894
  if (! sigdata->order) {
    {
#line 895
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 896
    return ((void *)0);
  }
#line 899
  if (sigdata->n_instruments) {
    {
#line 900
    tmp___4 = malloc((unsigned long )sigdata->n_instruments * sizeof(*(sigdata->instrument)));
#line 900
    sigdata->instrument = (IT_INSTRUMENT *)tmp___4;
    }
#line 901
    if (! sigdata->instrument) {
      {
#line 902
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 903
      return ((void *)0);
    }
  }
#line 907
  if (sigdata->n_samples) {
    {
#line 908
    tmp___5 = malloc((unsigned long )sigdata->n_samples * sizeof(*(sigdata->sample)));
#line 908
    sigdata->sample = (IT_SAMPLE *)tmp___5;
    }
#line 909
    if (! sigdata->sample) {
      {
#line 910
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 911
      return ((void *)0);
    }
#line 913
    n = 0;
    {
#line 913
    while (1) {
      while_continue: /* CIL Label */ ;
#line 913
      if (! (n < sigdata->n_samples)) {
#line 913
        goto while_break;
      }
#line 914
      (sigdata->sample + n)->data = (void *)0;
#line 913
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 917
  if (sigdata->n_patterns) {
    {
#line 918
    tmp___6 = malloc((unsigned long )sigdata->n_patterns * sizeof(*(sigdata->pattern)));
#line 918
    sigdata->pattern = (IT_PATTERN *)tmp___6;
    }
#line 919
    if (! sigdata->pattern) {
      {
#line 920
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 921
      return ((void *)0);
    }
#line 923
    n = 0;
    {
#line 923
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 923
      if (! (n < sigdata->n_patterns)) {
#line 923
        goto while_break___0;
      }
#line 924
      (sigdata->pattern + n)->entry = (IT_ENTRY *)((void *)0);
#line 923
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 927
  dumbfile_getnc((char *)sigdata->order, (long )sigdata->n_orders, f);
#line 928
  sigdata->restart_position = (unsigned char)0;
#line 930
  tmp___7 = malloc(769UL * sizeof(*component));
#line 930
  component = (IT_COMPONENT *)tmp___7;
  }
#line 931
  if (! component) {
    {
#line 932
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 933
    return ((void *)0);
  }
#line 936
  if (special & 1) {
#line 937
    (component + n_components)->type = (unsigned char)1;
#line 938
    (component + n_components)->offset = (long )message_offset;
#line 939
    (component + n_components)->sampfirst = (short)-1;
#line 940
    n_components ++;
  }
#line 943
  n = 0;
  {
#line 943
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 943
    if (! (n < sigdata->n_instruments)) {
#line 943
      goto while_break___1;
    }
    {
#line 944
    (component + n_components)->type = (unsigned char)2;
#line 945
    (component + n_components)->n = (unsigned char )n;
#line 946
    (component + n_components)->offset = dumbfile_igetl(f);
#line 947
    (component + n_components)->sampfirst = (short)-1;
#line 948
    n_components ++;
#line 943
    n ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 951
  n = 0;
  {
#line 951
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 951
    if (! (n < sigdata->n_samples)) {
#line 951
      goto while_break___2;
    }
    {
#line 952
    (component + n_components)->type = (unsigned char)4;
#line 953
    (component + n_components)->n = (unsigned char )n;
#line 954
    (component + n_components)->offset = dumbfile_igetl(f);
#line 955
    (component + n_components)->sampfirst = (short)-1;
#line 956
    n_components ++;
#line 951
    n ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 959
  n = 0;
  {
#line 959
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 959
    if (! (n < sigdata->n_patterns)) {
#line 959
      goto while_break___3;
    }
    {
#line 960
    tmp___8 = dumbfile_igetl(f);
#line 960
    offset = tmp___8;
    }
#line 961
    if (offset) {
#line 962
      (component + n_components)->type = (unsigned char)3;
#line 963
      (component + n_components)->n = (unsigned char )n;
#line 964
      (component + n_components)->offset = offset;
#line 965
      (component + n_components)->sampfirst = (short)-1;
#line 966
      n_components ++;
    } else {
#line 969
      (sigdata->pattern + n)->n_rows = 64;
#line 970
      (sigdata->pattern + n)->n_entries = 0;
    }
#line 959
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 974
  tmp___9 = dumbfile_error(f);
  }
#line 974
  if (tmp___9) {
    {
#line 975
    free((void *)component);
#line 976
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 977
    return ((void *)0);
  }
#line 980
  if (! (sigdata->flags & 128) != ! (special & 8)) {
#line 981
    if (sigdata->flags & 128) {
#line 981
      tmp___10 = "=SET=";
    } else {
#line 981
      tmp___10 = "clear";
    }
    {
#line 981
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flags   Bit 7 (\"Request embedded MIDI configuration\"): %s\n",
            tmp___10);
    }
#line 982
    if (special & 8) {
#line 982
      tmp___11 = "=SET=";
    } else {
#line 982
      tmp___11 = "clear";
    }
    {
#line 982
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Special Bit 3     (\"MIDI configuration embedded\")    : %s\n",
            tmp___11);
#line 983
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"entheh would like to investigate this IT file.\n");
#line 984
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please contact him! entheh@users.sf.net\n");
    }
  }
#line 987
  if (special & 8) {
    {
#line 991
    tmp___12 = malloc(sizeof(*(sigdata->midi)));
#line 991
    sigdata->midi = (IT_MIDI *)tmp___12;
    }
#line 992
    if (! sigdata->midi) {
      {
#line 993
      free((void *)component);
#line 994
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 995
      return ((void *)0);
    }
    {
#line 999
    i = dumbfile_igetw(f);
#line 1000
    tmp___13 = dumbfile_error(f);
    }
#line 1000
    if (tmp___13) {
      {
#line 1001
      free((void *)component);
#line 1002
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1003
      return ((void *)0);
    } else {
      {
#line 1000
      tmp___14 = dumbfile_skip(f, (long )(8 * i));
      }
#line 1000
      if (tmp___14) {
        {
#line 1001
        free((void *)component);
#line 1002
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1003
        return ((void *)0);
      }
    }
    {
#line 1007
    tmp___15 = dumbfile_skip(f, 288L);
    }
#line 1007
    if (tmp___15) {
      {
#line 1008
      free((void *)component);
#line 1009
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1010
      return ((void *)0);
    }
#line 1012
    i = 0;
    {
#line 1012
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1012
      if (! (i < 16)) {
#line 1012
        goto while_break___4;
      }
      {
#line 1013
      len = (unsigned char)0;
#line 1014
      leftdigit = -1;
#line 1015
      tmp___16 = dumbfile_getnc((char *)(mididata), 32L, f);
      }
#line 1015
      if (tmp___16 < 32L) {
        {
#line 1016
        free((void *)component);
#line 1017
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1018
        return ((void *)0);
      }
#line 1020
      (sigdata->midi)->SFmacroz[i] = (unsigned short)0;
#line 1021
      j = 0;
      {
#line 1021
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1021
        if (! (j < 32)) {
#line 1021
          goto while_break___5;
        }
#line 1022
        if (leftdigit >= 0) {
#line 1023
          if ((int )mididata[j] == 0) {
#line 1024
            tmp___17 = len;
#line 1024
            len = (unsigned char )((int )len + 1);
#line 1024
            (sigdata->midi)->SFmacro[i][tmp___17] = (unsigned char )leftdigit;
#line 1025
            goto while_break___5;
          } else
#line 1026
          if ((int )mididata[j] == 32) {
#line 1027
            tmp___18 = len;
#line 1027
            len = (unsigned char )((int )len + 1);
#line 1027
            (sigdata->midi)->SFmacro[i][tmp___18] = (unsigned char )leftdigit;
          } else
#line 1028
          if ((int )mididata[j] >= 48) {
#line 1028
            if ((int )mididata[j] <= 57) {
#line 1029
              tmp___19 = len;
#line 1029
              len = (unsigned char )((int )len + 1);
#line 1029
              (sigdata->midi)->SFmacro[i][tmp___19] = (unsigned char )((leftdigit << 4) | ((int )mididata[j] - 48));
            } else {
#line 1028
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1030
          if ((int )mididata[j] >= 65) {
#line 1030
            if ((int )mididata[j] <= 70) {
#line 1031
              tmp___20 = len;
#line 1031
              len = (unsigned char )((int )len + 1);
#line 1031
              (sigdata->midi)->SFmacro[i][tmp___20] = (unsigned char )((leftdigit << 4) | (((int )mididata[j] - 65) + 10));
            }
          }
#line 1032
          leftdigit = -1;
        } else
#line 1033
        if ((int )mididata[j] == 0) {
#line 1034
          goto while_break___5;
        } else
#line 1035
        if ((int )mididata[j] == 122) {
#line 1036
          tmp___21 = len;
#line 1036
          len = (unsigned char )((int )len + 1);
#line 1036
          (sigdata->midi)->SFmacroz[i] = (unsigned short )((int )(sigdata->midi)->SFmacroz[i] | (1 << (int )tmp___21));
        } else
#line 1037
        if ((int )mididata[j] >= 48) {
#line 1037
          if ((int )mididata[j] <= 57) {
#line 1038
            leftdigit = (int )mididata[j] - 48;
          } else {
#line 1037
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1039
        if ((int )mididata[j] >= 65) {
#line 1039
          if ((int )mididata[j] <= 70) {
#line 1040
            leftdigit = ((int )mididata[j] - 65) + 10;
          }
        }
#line 1021
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1042
      (sigdata->midi)->SFmacrolen[i] = len;
#line 1012
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1044
    i = 0;
    {
#line 1044
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1044
      if (! (i < 128)) {
#line 1044
        goto while_break___6;
      }
      {
#line 1045
      len___0 = (unsigned char)0;
#line 1046
      leftdigit___0 = -1;
#line 1047
      dumbfile_getnc((char *)(mididata), 32L, f);
#line 1048
      j___0 = 0;
      }
      {
#line 1048
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1048
        if (! (j___0 < 32)) {
#line 1048
          goto while_break___7;
        }
#line 1049
        if (leftdigit___0 >= 0) {
#line 1050
          if ((int )mididata[j___0] == 0) {
#line 1051
            tmp___22 = len___0;
#line 1051
            len___0 = (unsigned char )((int )len___0 + 1);
#line 1051
            (sigdata->midi)->Zmacro[i][tmp___22] = (unsigned char )leftdigit___0;
#line 1052
            goto while_break___7;
          } else
#line 1053
          if ((int )mididata[j___0] == 32) {
#line 1054
            tmp___23 = len___0;
#line 1054
            len___0 = (unsigned char )((int )len___0 + 1);
#line 1054
            (sigdata->midi)->Zmacro[i][tmp___23] = (unsigned char )leftdigit___0;
          } else
#line 1055
          if ((int )mididata[j___0] >= 48) {
#line 1055
            if ((int )mididata[j___0] <= 57) {
#line 1056
              tmp___24 = len___0;
#line 1056
              len___0 = (unsigned char )((int )len___0 + 1);
#line 1056
              (sigdata->midi)->Zmacro[i][tmp___24] = (unsigned char )((leftdigit___0 << 4) | ((int )mididata[j___0] - 48));
            } else {
#line 1055
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1057
          if ((int )mididata[j___0] >= 65) {
#line 1057
            if ((int )mididata[j___0] <= 70) {
#line 1058
              tmp___25 = len___0;
#line 1058
              len___0 = (unsigned char )((int )len___0 + 1);
#line 1058
              (sigdata->midi)->Zmacro[i][tmp___25] = (unsigned char )((leftdigit___0 << 4) | (((int )mididata[j___0] - 65) + 10));
            }
          }
#line 1059
          leftdigit___0 = -1;
        } else
#line 1060
        if ((int )mididata[j___0] == 0) {
#line 1061
          goto while_break___7;
        } else
#line 1062
        if ((int )mididata[j___0] >= 48) {
#line 1062
          if ((int )mididata[j___0] <= 57) {
#line 1063
            leftdigit___0 = (int )mididata[j___0] - 48;
          } else {
#line 1062
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1064
        if ((int )mididata[j___0] >= 65) {
#line 1064
          if ((int )mididata[j___0] <= 70) {
#line 1065
            leftdigit___0 = ((int )mididata[j___0] - 65) + 10;
          }
        }
#line 1048
        j___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1067
      (sigdata->midi)->Zmacrolen[i] = len___0;
#line 1044
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1071
  sigdata->flags &= 63;
#line 1073
  qsort((void *)component, (size_t )n_components, sizeof(IT_COMPONENT ), & it_component_compare);
#line 1075
  tmp___26 = malloc((size_t )65536);
#line 1075
  buffer___0 = (unsigned char *)tmp___26;
  }
#line 1076
  if (! buffer___0) {
    {
#line 1077
    free((void *)component);
#line 1078
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 1079
    return ((void *)0);
  }
#line 1082
  n = 0;
  {
#line 1082
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1082
    if (! (n < n_components)) {
#line 1082
      goto while_break___8;
    }
    {
#line 1086
    tmp___27 = it_seek(f, (component + n)->offset);
    }
#line 1086
    if (tmp___27) {
      {
#line 1087
      free((void *)buffer___0);
#line 1088
      free((void *)component);
#line 1089
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1090
      return ((void *)0);
    }
    {
#line 1095
    if ((int )(component + n)->type == 1) {
#line 1095
      goto case_1;
    }
#line 1108
    if ((int )(component + n)->type == 2) {
#line 1108
      goto case_2;
    }
#line 1122
    if ((int )(component + n)->type == 3) {
#line 1122
      goto case_3;
    }
#line 1131
    if ((int )(component + n)->type == 4) {
#line 1131
      goto case_4;
    }
#line 1093
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1096
    tmp___28 = malloc((size_t )(message_length + 1));
#line 1096
    sigdata->song_message = (unsigned char *)tmp___28;
    }
#line 1097
    if (sigdata->song_message) {
      {
#line 1098
      tmp___29 = dumbfile_getnc((char *)sigdata->song_message, (long )message_length,
                                f);
      }
#line 1098
      if (tmp___29 < (long )message_length) {
        {
#line 1099
        free((void *)buffer___0);
#line 1100
        free((void *)component);
#line 1101
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1102
        return ((void *)0);
      }
#line 1104
      *(sigdata->song_message + message_length) = (unsigned char)0;
    }
#line 1106
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1109
    if (cmwt < 512) {
      {
#line 1110
      m = it_read_old_instrument(sigdata->instrument + (component + n)->n, f);
      }
    } else {
      {
#line 1112
      m = it_read_instrument(sigdata->instrument + (component + n)->n, f);
      }
    }
#line 1114
    if (m) {
      {
#line 1115
      free((void *)buffer___0);
#line 1116
      free((void *)component);
#line 1117
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1118
      return ((void *)0);
    }
#line 1120
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1123
    tmp___30 = it_read_pattern(sigdata->pattern + (component + n)->n, f, buffer___0);
    }
#line 1123
    if (tmp___30) {
      {
#line 1124
      free((void *)buffer___0);
#line 1125
      free((void *)component);
#line 1126
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1127
      return ((void *)0);
    }
#line 1129
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1132
    tmp___31 = it_read_sample_header(sigdata->sample + (component + n)->n, & sample_convert[(component + n)->n],
                                     & offset___0, f);
    }
#line 1132
    if (tmp___31) {
      {
#line 1133
      free((void *)buffer___0);
#line 1134
      free((void *)component);
#line 1135
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1136
      return ((void *)0);
    }
#line 1139
    if ((int )(sigdata->sample + (component + n)->n)->flags & 1) {
#line 1142
      m = n + 1;
      {
#line 1142
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1142
        if (! (m < n_components)) {
#line 1142
          goto while_break___9;
        }
#line 1143
        if ((component + m)->offset > offset___0) {
#line 1144
          goto while_break___9;
        }
#line 1142
        m ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1145
      m --;
#line 1147
      sample = & (component + m)->sampfirst;
      {
#line 1149
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1149
        if ((int )*sample >= 0) {
#line 1149
          if (! ((component + *sample)->offset <= offset___0)) {
#line 1149
            goto while_break___10;
          }
        } else {
#line 1149
          goto while_break___10;
        }
#line 1150
        sample = & (component + *sample)->sampnext;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1152
      (component + n)->sampnext = *sample;
#line 1153
      *sample = (short )n;
#line 1155
      (component + n)->offset = offset___0;
    }
    switch_break: /* CIL Label */ ;
    }
#line 1159
    m = (int )(component + n)->sampfirst;
    {
#line 1161
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1161
      if (! (m >= 0)) {
#line 1161
        goto while_break___11;
      }
      {
#line 1162
      tmp___32 = it_seek(f, (component + m)->offset);
      }
#line 1162
      if (tmp___32) {
        {
#line 1163
        free((void *)buffer___0);
#line 1164
        free((void *)component);
#line 1165
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1166
        return ((void *)0);
      }
      {
#line 1169
      tmp___33 = it_read_sample_data(cmwt, sigdata->sample + (component + m)->n, sample_convert[(component + m)->n],
                                     f);
      }
#line 1169
      if (tmp___33) {
        {
#line 1170
        free((void *)buffer___0);
#line 1171
        free((void *)component);
#line 1172
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1173
        return ((void *)0);
      }
#line 1176
      m = (int )(component + m)->sampnext;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1082
    n ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1180
  free((void *)buffer___0);
#line 1181
  free((void *)component);
#line 1183
  _dumb_it_fix_invalid_orders(sigdata);
  }
#line 1185
  return ((sigdata_t *)sigdata);
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
DUH *dumb_read_it_quick(DUMBFILE *f ) 
{ 
  sigdata_t *sigdata ;
  DUH_SIGTYPE_DESC *descptr ;
  char const   *tag[1][2] ;
  DUH *tmp ;

  {
  {
#line 1194
  descptr = & _dumb_sigtype_it;
#line 1196
  sigdata = it_load_sigdata(f);
  }
#line 1198
  if (! sigdata) {
#line 1199
    return ((DUH *)((void *)0));
  }
  {
#line 1203
  tag[0][0] = "TITLE";
#line 1204
  tag[0][1] = (char const   *)(((DUMB_IT_SIGDATA *)sigdata)->name);
#line 1205
  tmp = make_duh(-1L, 1, (char const   * const  (*)[2])(tag), 1, & descptr, & sigdata);
  }
#line 1205
  return (tmp);
}
}
#line 573 "include/dumb.h"
DUMB_CLICK_REMOVER *dumb_create_click_remover(void) ;
#line 575
void dumb_remove_clicks(DUMB_CLICK_REMOVER *cr , sample_t *samples , long length ,
                        int step , float halflife ) ;
#line 576
sample_t dumb_click_remover_get_offset(DUMB_CLICK_REMOVER *cr ) ;
#line 577
void dumb_destroy_click_remover(DUMB_CLICK_REMOVER *cr ) ;
#line 580
void dumb_record_click_array(int n , DUMB_CLICK_REMOVER **cr , long pos , sample_t *step ) ;
#line 581
void dumb_record_click_negative_array(int n , DUMB_CLICK_REMOVER **cr , long pos ,
                                      sample_t *step ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
DUMB_CLICK_REMOVER *dumb_create_click_remover(void) 
{ 
  DUMB_CLICK_REMOVER *cr ;
  void *tmp ;

  {
  {
#line 49
  tmp = malloc(sizeof(*cr));
#line 49
  cr = (DUMB_CLICK_REMOVER *)tmp;
  }
#line 50
  if (! cr) {
#line 50
    return ((DUMB_CLICK_REMOVER *)((void *)0));
  }
#line 52
  cr->click = (DUMB_CLICK *)((void *)0);
#line 53
  cr->n_clicks = 0;
#line 55
  cr->offset = 0;
#line 57
  return (cr);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_record_click(DUMB_CLICK_REMOVER *cr , long pos , sample_t step ) 
{ 
  DUMB_CLICK *click ;
  void *tmp ;

  {
#line 68
  if (! cr) {
#line 68
    return;
  } else
#line 68
  if (! step) {
#line 68
    return;
  }
#line 70
  if (pos == 0L) {
#line 71
    cr->offset -= step;
#line 72
    return;
  }
  {
#line 75
  tmp = malloc(sizeof(*click));
#line 75
  click = (DUMB_CLICK *)tmp;
  }
#line 76
  if (! click) {
#line 76
    return;
  }
#line 78
  click->pos = pos;
#line 79
  click->step = step;
#line 81
  click->next = cr->click;
#line 82
  cr->click = click;
#line 83
  (cr->n_clicks) ++;
#line 84
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
static DUMB_CLICK *dumb_click_mergesort(DUMB_CLICK *click , int n_clicks ) 
{ 
  int i ;
  DUMB_CLICK *c1 ;
  DUMB_CLICK *c2 ;
  DUMB_CLICK **cp ;

  {
#line 93
  if (n_clicks <= 1) {
#line 93
    return (click);
  }
#line 96
  c1 = click;
#line 97
  cp = & c1;
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < n_clicks)) {
#line 98
      goto while_break;
    }
#line 98
    cp = & (*cp)->next;
#line 98
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  c2 = *cp;
#line 100
  *cp = (DUMB_CLICK *)((void *)0);
#line 103
  c1 = dumb_click_mergesort(c1, (n_clicks + 1) >> 1);
#line 104
  c2 = dumb_click_mergesort(c2, n_clicks >> 1);
#line 107
  cp = & click;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (c1) {
#line 108
      if (! c2) {
#line 108
        goto while_break___0;
      }
    } else {
#line 108
      goto while_break___0;
    }
#line 109
    if (c1->pos > c2->pos) {
#line 110
      *cp = c2;
#line 111
      c2 = c2->next;
    } else {
#line 113
      *cp = c1;
#line 114
      c1 = c1->next;
    }
#line 116
    cp = & (*cp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  if (c2) {
#line 119
    *cp = c2;
  } else {
#line 121
    *cp = c1;
  }
#line 123
  return (click);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_remove_clicks(DUMB_CLICK_REMOVER *cr , sample_t *samples , long length ,
                        int step , float halflife ) 
{ 
  DUMB_CLICK *click ;
  long pos ;
  int offset ;
  int factor ;
  double tmp ;
  double tmp___0 ;
  DUMB_CLICK *next ;
  int end ;

  {
#line 131
  pos = 0L;
#line 135
  if (! cr) {
#line 135
    return;
  }
  {
#line 137
  tmp = pow(0.5, 1.0 / (double )halflife);
#line 137
  tmp___0 = floor(tmp * (double )(1U << 31));
#line 137
  factor = (int )tmp___0;
#line 139
  click = dumb_click_mergesort(cr->click, cr->n_clicks);
#line 140
  cr->click = (DUMB_CLICK *)((void *)0);
#line 141
  cr->n_clicks = 0;
#line 143
  length *= (long )step;
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! click) {
#line 145
      goto while_break;
    }
#line 146
    next = click->next;
#line 147
    end = (int )(click->pos * (long )step);
#line 149
    offset = cr->offset;
#line 150
    if (offset < 0) {
#line 151
      offset = - offset;
      {
#line 152
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 152
        if (! (pos < (long )end)) {
#line 152
          goto while_break___0;
        }
#line 153
        *(samples + pos) -= offset;
#line 154
        offset = (int )((long long )(offset << 1) * (long long )factor >> 32);
#line 155
        pos += (long )step;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 157
      offset = - offset;
    } else {
      {
#line 159
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 159
        if (! (pos < (long )end)) {
#line 159
          goto while_break___1;
        }
#line 160
        *(samples + pos) += offset;
#line 161
        offset = (int )((long long )(offset << 1) * (long long )factor >> 32);
#line 162
        pos += (long )step;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 165
    cr->offset = offset - click->step;
#line 166
    free((void *)click);
#line 167
    click = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  offset = cr->offset;
#line 171
  if (offset < 0) {
#line 172
    offset = - offset;
    {
#line 173
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 173
      if (! (pos < length)) {
#line 173
        goto while_break___2;
      }
#line 174
      *(samples + pos) -= offset;
#line 175
      offset = (int )((long long )(offset << 1) * (long long )factor >> 32);
#line 176
      pos += (long )step;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 178
    offset = - offset;
  } else {
    {
#line 180
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 180
      if (! (pos < length)) {
#line 180
        goto while_break___3;
      }
#line 181
      *(samples + pos) += offset;
#line 182
      offset = (int )((long long )(offset << 1) * (long long )factor >> 32);
#line 183
      pos += (long )step;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 186
  cr->offset = offset;
#line 187
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
sample_t dumb_click_remover_get_offset(DUMB_CLICK_REMOVER *cr ) 
{ 
  int tmp ;

  {
#line 193
  if (cr) {
#line 193
    tmp = cr->offset;
  } else {
#line 193
    tmp = 0;
  }
#line 193
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_destroy_click_remover(DUMB_CLICK_REMOVER *cr ) 
{ 
  DUMB_CLICK *click ;
  DUMB_CLICK *next ;

  {
#line 200
  if (cr) {
#line 201
    click = cr->click;
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (! click) {
#line 202
        goto while_break;
      }
      {
#line 203
      next = click->next;
#line 204
      free((void *)click);
#line 205
      click = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 207
    free((void *)cr);
    }
  }
#line 209
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
DUMB_CLICK_REMOVER **dumb_create_click_remover_array(int n ) 
{ 
  int i ;
  DUMB_CLICK_REMOVER **cr ;
  void *tmp ;

  {
#line 217
  if (n <= 0) {
#line 217
    return ((DUMB_CLICK_REMOVER **)((void *)0));
  }
  {
#line 218
  tmp = malloc((unsigned long )n * sizeof(*cr));
#line 218
  cr = (DUMB_CLICK_REMOVER **)tmp;
  }
#line 219
  if (! cr) {
#line 219
    return ((DUMB_CLICK_REMOVER **)((void *)0));
  }
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < n)) {
#line 220
      goto while_break;
    }
    {
#line 220
    *(cr + i) = dumb_create_click_remover();
#line 220
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (cr);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_record_click_array(int n , DUMB_CLICK_REMOVER **cr , long pos , sample_t *step ) 
{ 
  int i ;

  {
#line 228
  if (cr) {
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! (i < n)) {
#line 230
        goto while_break;
      }
      {
#line 231
      dumb_record_click(*(cr + i), pos, *(step + i));
#line 230
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 233
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_record_click_negative_array(int n , DUMB_CLICK_REMOVER **cr , long pos ,
                                      sample_t *step ) 
{ 
  int i ;

  {
#line 239
  if (cr) {
#line 241
    i = 0;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (i < n)) {
#line 241
        goto while_break;
      }
      {
#line 242
      dumb_record_click(*(cr + i), pos, - *(step + i));
#line 241
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 244
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_remove_clicks_array(int n , DUMB_CLICK_REMOVER **cr , sample_t **samples ,
                              long length , float halflife ) 
{ 
  int i ;

  {
#line 250
  if (cr) {
#line 252
    i = 0;
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 252
      if (! (i < n >> 1)) {
#line 252
        goto while_break;
      }
      {
#line 253
      dumb_remove_clicks(*(cr + (i << 1)), *(samples + i), length, 2, halflife);
#line 254
      dumb_remove_clicks(*(cr + ((i << 1) + 1)), *(samples + i) + 1, length, 2, halflife);
#line 252
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 256
    if (n & 1) {
      {
#line 257
      dumb_remove_clicks(*(cr + (i << 1)), *(samples + i), length, 1, halflife);
      }
    }
  }
#line 259
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_click_remover_get_offset_array(int n , DUMB_CLICK_REMOVER **cr , sample_t *offset ) 
{ 
  int i ;

  {
#line 265
  if (cr) {
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue: /* CIL Label */ ;
#line 267
      if (! (i < n)) {
#line 267
        goto while_break;
      }
#line 268
      if (*(cr + i)) {
#line 268
        *(offset + i) += (*(cr + i))->offset;
      }
#line 267
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 270
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
void dumb_destroy_click_remover_array(int n , DUMB_CLICK_REMOVER **cr ) 
{ 
  int i ;

  {
#line 276
  if (cr) {
#line 278
    i = 0;
    {
#line 278
    while (1) {
      while_continue: /* CIL Label */ ;
#line 278
      if (! (i < n)) {
#line 278
        goto while_break;
      }
      {
#line 278
      dumb_destroy_click_remover(*(cr + i));
#line 278
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 279
    free((void *)cr);
    }
  }
#line 281
  return;
}
}
#line 145 "include/dumb.h"
int dumb_atexit(void (*proc)(void) ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/atexit.c"
static DUMB_ATEXIT_PROC *dumb_atexit_proc  =    (DUMB_ATEXIT_PROC *)((void *)0);
#line 40 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/atexit.c"
int dumb_atexit(void (*proc)(void) ) 
{ 
  DUMB_ATEXIT_PROC *dap ;
  void *tmp ;

  {
#line 42
  dap = dumb_atexit_proc;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! dap) {
#line 44
      goto while_break;
    }
#line 45
    if ((unsigned long )dap->proc == (unsigned long )proc) {
#line 45
      return (0);
    }
#line 46
    dap = dap->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  tmp = malloc(sizeof(*dap));
#line 49
  dap = (DUMB_ATEXIT_PROC *)tmp;
  }
#line 51
  if (! dap) {
#line 52
    return (-1);
  }
#line 54
  dap->next = dumb_atexit_proc;
#line 55
  dap->proc = proc;
#line 56
  dumb_atexit_proc = dap;
#line 58
  return (0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/atexit.c"
void dumb_exit(void) 
{ 
  DUMB_ATEXIT_PROC *next ;

  {
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! dumb_atexit_proc) {
#line 65
      goto while_break;
    }
    {
#line 66
    next = dumb_atexit_proc->next;
#line 67
    (*(dumb_atexit_proc->proc))();
#line 68
    free((void *)dumb_atexit_proc);
#line 69
    dumb_atexit_proc = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static IT_PLAYING *dup_playing___0(IT_PLAYING *src , IT_CHANNEL *dstchannel , IT_CHANNEL *srcchannel ) 
{ 
  IT_PLAYING *dst ;
  void *tmp ;

  {
#line 32
  if (! src) {
#line 32
    return ((IT_PLAYING *)((void *)0));
  }
  {
#line 34
  tmp = malloc(sizeof(*dst));
#line 34
  dst = (IT_PLAYING *)tmp;
  }
#line 35
  if (! dst) {
#line 35
    return ((IT_PLAYING *)((void *)0));
  }
#line 37
  dst->flags = src->flags;
#line 40
  dst->channel = dstchannel + (src->channel - srcchannel);
#line 41
  dst->sample = src->sample;
#line 42
  dst->instrument = src->instrument;
#line 43
  dst->env_instrument = src->env_instrument;
#line 45
  dst->sampnum = src->sampnum;
#line 46
  dst->instnum = src->instnum;
#line 48
  dst->channel_volume = src->channel_volume;
#line 50
  dst->volume = src->volume;
#line 51
  dst->pan = src->pan;
#line 53
  dst->note = src->note;
#line 55
  dst->filter_cutoff = src->filter_cutoff;
#line 56
  dst->filter_resonance = src->filter_resonance;
#line 58
  dst->true_filter_cutoff = src->true_filter_cutoff;
#line 59
  dst->true_filter_resonance = src->true_filter_resonance;
#line 61
  dst->vibrato_speed = src->vibrato_speed;
#line 62
  dst->vibrato_depth = src->vibrato_depth;
#line 63
  dst->vibrato_n = src->vibrato_n;
#line 64
  dst->vibrato_time = src->vibrato_time;
#line 66
  dst->tremolo_speed = src->tremolo_speed;
#line 67
  dst->tremolo_depth = src->tremolo_depth;
#line 68
  dst->tremolo_time = src->tremolo_time;
#line 70
  dst->sample_vibrato_time = src->sample_vibrato_time;
#line 71
  dst->sample_vibrato_depth = src->sample_vibrato_depth;
#line 73
  dst->slide = src->slide;
#line 74
  dst->delta = src->delta;
#line 76
  dst->volume_envelope = src->volume_envelope;
#line 77
  dst->pan_envelope = src->pan_envelope;
#line 78
  dst->pitch_envelope = src->pitch_envelope;
#line 80
  dst->fadeoutcount = src->fadeoutcount;
#line 82
  dst->filter_state[0] = src->filter_state[0];
#line 83
  dst->filter_state[1] = src->filter_state[1];
#line 85
  dst->resampler = src->resampler;
#line 86
  dst->resampler.pickup_data = (void *)dst;
#line 87
  dst->time_lost = src->time_lost;
#line 89
  return (dst);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void dup_channel___0(IT_CHANNEL *dst , IT_CHANNEL *src ) 
{ 


  {
  {
#line 96
  dst->flags = src->flags;
#line 98
  dst->volume = src->volume;
#line 99
  dst->volslide = src->volslide;
#line 100
  dst->xm_volslide = src->xm_volslide;
#line 101
  dst->panslide = src->panslide;
#line 103
  dst->pan = src->pan;
#line 104
  dst->truepan = src->truepan;
#line 106
  dst->channelvolume = src->channelvolume;
#line 107
  dst->channelvolslide = src->channelvolslide;
#line 109
  dst->instrument = src->instrument;
#line 110
  dst->note = src->note;
#line 112
  dst->SFmacro = src->SFmacro;
#line 114
  dst->filter_cutoff = src->filter_cutoff;
#line 115
  dst->filter_resonance = src->filter_resonance;
#line 117
  dst->key_off_count = src->key_off_count;
#line 118
  dst->note_cut_count = src->note_cut_count;
#line 119
  dst->note_delay_count = src->note_delay_count;
#line 120
  dst->note_delay_entry = src->note_delay_entry;
#line 122
  dst->arpeggio = src->arpeggio;
#line 123
  dst->retrig = src->retrig;
#line 124
  dst->xm_retrig = src->xm_retrig;
#line 125
  dst->retrig_tick = src->retrig_tick;
#line 127
  dst->tremor_time = src->tremor_time;
#line 129
  dst->portamento = src->portamento;
#line 130
  dst->toneporta = src->toneporta;
#line 131
  dst->destnote = src->destnote;
#line 133
  dst->sample = src->sample;
#line 134
  dst->truenote = src->truenote;
#line 136
  dst->midi_state = src->midi_state;
#line 138
  dst->lastvolslide = src->lastvolslide;
#line 139
  dst->lastDKL = src->lastDKL;
#line 140
  dst->lastEF = src->lastEF;
#line 141
  dst->lastG = src->lastG;
#line 142
  dst->lastHspeed = src->lastHspeed;
#line 143
  dst->lastHdepth = src->lastHdepth;
#line 144
  dst->lastRspeed = src->lastRspeed;
#line 145
  dst->lastRdepth = src->lastRdepth;
#line 146
  dst->lastI = src->lastI;
#line 147
  dst->lastJ = src->lastJ;
#line 148
  dst->lastN = src->lastN;
#line 149
  dst->lastO = src->lastO;
#line 150
  dst->high_offset = src->high_offset;
#line 151
  dst->lastP = src->lastP;
#line 152
  dst->lastQ = src->lastQ;
#line 153
  dst->lastS = src->lastS;
#line 154
  dst->pat_loop_row = src->pat_loop_row;
#line 155
  dst->pat_loop_count = src->pat_loop_count;
#line 156
  dst->pat_loop_end_row = src->pat_loop_end_row;
#line 157
  dst->lastW = src->lastW;
#line 159
  dst->xm_lastE1 = src->xm_lastE1;
#line 160
  dst->xm_lastE2 = src->xm_lastE2;
#line 161
  dst->xm_lastEA = src->xm_lastEA;
#line 162
  dst->xm_lastEB = src->xm_lastEB;
#line 163
  dst->xm_lastX1 = src->xm_lastX1;
#line 164
  dst->xm_lastX2 = src->xm_lastX2;
#line 166
  dst->playing = dup_playing___0(src->playing, dst, src);
  }
#line 167
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static DUMB_IT_SIGRENDERER *dup_sigrenderer___0(DUMB_IT_SIGRENDERER *src , int n_channels ,
                                                IT_CALLBACKS *callbacks ) 
{ 
  DUMB_IT_SIGRENDERER *dst ;
  int i ;
  void *tmp ;

  {
#line 179
  if (! src) {
#line 180
    if (callbacks) {
      {
#line 180
      free((void *)callbacks);
      }
    }
#line 181
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 184
  tmp = malloc(sizeof(*dst));
#line 184
  dst = (DUMB_IT_SIGRENDERER *)tmp;
  }
#line 185
  if (! dst) {
#line 186
    if (callbacks) {
      {
#line 186
      free((void *)callbacks);
      }
    }
#line 187
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
#line 190
  dst->sigdata = src->sigdata;
#line 192
  dst->n_channels = n_channels;
#line 194
  dst->globalvolume = src->globalvolume;
#line 195
  dst->globalvolslide = src->globalvolslide;
#line 197
  dst->tempo = src->tempo;
#line 198
  dst->temposlide = src->temposlide;
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < 64)) {
#line 200
      goto while_break;
    }
    {
#line 201
    dup_channel___0(& dst->channel[i], & src->channel[i]);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! (i < 192)) {
#line 203
      goto while_break___0;
    }
    {
#line 204
    dst->playing[i] = dup_playing___0(src->playing[i], dst->channel, src->channel);
#line 203
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 206
  dst->tick = src->tick;
#line 207
  dst->speed = src->speed;
#line 208
  dst->rowcount = src->rowcount;
#line 210
  dst->order = src->order;
#line 211
  dst->row = src->row;
#line 212
  dst->processorder = src->processorder;
#line 213
  dst->processrow = src->processrow;
#line 214
  dst->breakrow = src->breakrow;
#line 215
  dst->pat_loop_row = src->pat_loop_row;
#line 217
  dst->n_rows = src->n_rows;
#line 219
  dst->entry_start = src->entry_start;
#line 220
  dst->entry = src->entry;
#line 221
  dst->entry_end = src->entry_end;
#line 223
  dst->time_left = src->time_left;
#line 224
  dst->sub_time_left = src->sub_time_left;
#line 226
  dst->click_remover = (DUMB_CLICK_REMOVER **)((void *)0);
#line 228
  dst->callbacks = callbacks;
#line 230
  return (dst);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static IT_MIDI default_midi___0  =    {{{(unsigned char)240, (unsigned char)240, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                            (unsigned char)0}, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                          (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0}}, {(unsigned char)4, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    {(unsigned short)8, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, {{(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0}, {(unsigned char)240, (unsigned char)240,
                                               (unsigned char)1, (unsigned char)8,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0,
                                               (unsigned char)0, (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)16, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)24,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)32, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)40,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)48, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)56,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)64, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)72,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)80, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)88,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)96, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)104,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)240, (unsigned char)240, (unsigned char)1,
                           (unsigned char)112, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0}, {(unsigned char)240,
                                                                 (unsigned char)240,
                                                                 (unsigned char)1,
                                                                 (unsigned char)120,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
                          {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
    {(unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4,
     (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4,
     (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4, (unsigned char)4,
     (unsigned char)4, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0}};
#line 416 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_reset_filter_state___0(IT_FILTER_STATE *state ) 
{ 


  {
#line 418
  state->currsample = 0;
#line 419
  state->prevsample = 0;
#line 420
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_filter___0(DUMB_CLICK_REMOVER *cr , IT_FILTER_STATE *state , sample_t *dst ,
                          long pos , sample_t *src , long size , int step , int sampfreq ,
                          int cutoff , int resonance ) 
{ 
  sample_t currsample ;
  sample_t prevsample ;
  float a ;
  float b ;
  float c ;
  long datasize ;
  float inv_angle ;
  double tmp ;
  float loss ;
  double tmp___0 ;
  float d ;
  float e ;
  int ai ;
  int bi ;
  int ci ;
  int i ;
  sample_t startstep ;
  sample_t newsample ;
  sample_t endstep ;

  {
  {
#line 433
  currsample = state->currsample;
#line 434
  prevsample = state->prevsample;
#line 441
  tmp = pow(0.5, 0.25 + (double )cutoff * (1.0 / (double )(24 << 8)));
#line 441
  inv_angle = (float )(((double )sampfreq * tmp) * (1.0 / (((double )2 * 3.14159265358979323846) * 110.0)));
#line 442
  tmp___0 = exp((double )resonance * ((- 2.30258509299 * 1.2) / 128.0));
#line 442
  loss = (float )tmp___0;
#line 449
  d = (1.0f - loss) / inv_angle;
  }
#line 450
  if (d > 2.0f) {
#line 450
    d = 2.0f;
  }
#line 451
  d = (loss - d) * inv_angle;
#line 452
  e = inv_angle * inv_angle;
#line 453
  a = 1.0f / ((1.0f + d) + e);
#line 454
  c = - e * a;
#line 455
  b = (1.0f - a) - c;
#line 463
  dst += pos * (long )step;
#line 464
  datasize = size * (long )step;
#line 471
  ai = (int )(a * (float )(1 << 28));
#line 472
  bi = (int )(b * (float )(1 << 28));
#line 473
  ci = (int )(c * (float )(1 << 28));
#line 476
  if (cr) {
    {
#line 477
    startstep = ((int )((long long )(*(src + 0) << 4) * (long long )ai >> 32) + (int )((long long )(currsample << 4) * (long long )bi >> 32)) + (int )((long long )(prevsample << 4) * (long long )ci >> 32);
#line 478
    dumb_record_click(cr, pos, startstep);
    }
  }
#line 481
  i = 0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((long )i < datasize)) {
#line 481
      goto while_break;
    }
#line 483
    newsample = ((int )((long long )(*(src + i) << 4) * (long long )ai >> 32) + (int )((long long )(currsample << 4) * (long long )bi >> 32)) + (int )((long long )(prevsample << 4) * (long long )ci >> 32);
#line 484
    prevsample = currsample;
#line 485
    currsample = newsample;
#line 487
    *(dst + i) += currsample;
#line 481
    i += step;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  if (cr) {
    {
#line 491
    endstep = ((int )((long long )(*(src + datasize) << 4) * (long long )ai >> 32) + (int )((long long )(currsample << 4) * (long long )bi >> 32)) + (int )((long long )(prevsample << 4) * (long long )ci >> 32);
#line 492
    dumb_record_click(cr, pos + size, - endstep);
    }
  }
#line 530
  state->currsample = currsample;
#line 531
  state->prevsample = prevsample;
#line 532
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static signed char it_sine___0[256]  = 
#line 538
  {      (signed char)0,      (signed char)2,      (signed char)3,      (signed char)5, 
        (signed char)6,      (signed char)8,      (signed char)9,      (signed char)11, 
        (signed char)12,      (signed char)14,      (signed char)16,      (signed char)17, 
        (signed char)19,      (signed char)20,      (signed char)22,      (signed char)23, 
        (signed char)24,      (signed char)26,      (signed char)27,      (signed char)29, 
        (signed char)30,      (signed char)32,      (signed char)33,      (signed char)34, 
        (signed char)36,      (signed char)37,      (signed char)38,      (signed char)39, 
        (signed char)41,      (signed char)42,      (signed char)43,      (signed char)44, 
        (signed char)45,      (signed char)46,      (signed char)47,      (signed char)48, 
        (signed char)49,      (signed char)50,      (signed char)51,      (signed char)52, 
        (signed char)53,      (signed char)54,      (signed char)55,      (signed char)56, 
        (signed char)56,      (signed char)57,      (signed char)58,      (signed char)59, 
        (signed char)59,      (signed char)60,      (signed char)60,      (signed char)61, 
        (signed char)61,      (signed char)62,      (signed char)62,      (signed char)62, 
        (signed char)63,      (signed char)63,      (signed char)63,      (signed char)64, 
        (signed char)64,      (signed char)64,      (signed char)64,      (signed char)64, 
        (signed char)64,      (signed char)64,      (signed char)64,      (signed char)64, 
        (signed char)64,      (signed char)64,      (signed char)63,      (signed char)63, 
        (signed char)63,      (signed char)62,      (signed char)62,      (signed char)62, 
        (signed char)61,      (signed char)61,      (signed char)60,      (signed char)60, 
        (signed char)59,      (signed char)59,      (signed char)58,      (signed char)57, 
        (signed char)56,      (signed char)56,      (signed char)55,      (signed char)54, 
        (signed char)53,      (signed char)52,      (signed char)51,      (signed char)50, 
        (signed char)49,      (signed char)48,      (signed char)47,      (signed char)46, 
        (signed char)45,      (signed char)44,      (signed char)43,      (signed char)42, 
        (signed char)41,      (signed char)39,      (signed char)38,      (signed char)37, 
        (signed char)36,      (signed char)34,      (signed char)33,      (signed char)32, 
        (signed char)30,      (signed char)29,      (signed char)27,      (signed char)26, 
        (signed char)24,      (signed char)23,      (signed char)22,      (signed char)20, 
        (signed char)19,      (signed char)17,      (signed char)16,      (signed char)14, 
        (signed char)12,      (signed char)11,      (signed char)9,      (signed char)8, 
        (signed char)6,      (signed char)5,      (signed char)3,      (signed char)2, 
        (signed char)0,      (signed char)-2,      (signed char)-3,      (signed char)-5, 
        (signed char)-6,      (signed char)-8,      (signed char)-9,      (signed char)-11, 
        (signed char)-12,      (signed char)-14,      (signed char)-16,      (signed char)-17, 
        (signed char)-19,      (signed char)-20,      (signed char)-22,      (signed char)-23, 
        (signed char)-24,      (signed char)-26,      (signed char)-27,      (signed char)-29, 
        (signed char)-30,      (signed char)-32,      (signed char)-33,      (signed char)-34, 
        (signed char)-36,      (signed char)-37,      (signed char)-38,      (signed char)-39, 
        (signed char)-41,      (signed char)-42,      (signed char)-43,      (signed char)-44, 
        (signed char)-45,      (signed char)-46,      (signed char)-47,      (signed char)-48, 
        (signed char)-49,      (signed char)-50,      (signed char)-51,      (signed char)-52, 
        (signed char)-53,      (signed char)-54,      (signed char)-55,      (signed char)-56, 
        (signed char)-56,      (signed char)-57,      (signed char)-58,      (signed char)-59, 
        (signed char)-59,      (signed char)-60,      (signed char)-60,      (signed char)-61, 
        (signed char)-61,      (signed char)-62,      (signed char)-62,      (signed char)-62, 
        (signed char)-63,      (signed char)-63,      (signed char)-63,      (signed char)-64, 
        (signed char)-64,      (signed char)-64,      (signed char)-64,      (signed char)-64, 
        (signed char)-64,      (signed char)-64,      (signed char)-64,      (signed char)-64, 
        (signed char)-64,      (signed char)-64,      (signed char)-63,      (signed char)-63, 
        (signed char)-63,      (signed char)-62,      (signed char)-62,      (signed char)-62, 
        (signed char)-61,      (signed char)-61,      (signed char)-60,      (signed char)-60, 
        (signed char)-59,      (signed char)-59,      (signed char)-58,      (signed char)-57, 
        (signed char)-56,      (signed char)-56,      (signed char)-55,      (signed char)-54, 
        (signed char)-53,      (signed char)-52,      (signed char)-51,      (signed char)-50, 
        (signed char)-49,      (signed char)-48,      (signed char)-47,      (signed char)-46, 
        (signed char)-45,      (signed char)-44,      (signed char)-43,      (signed char)-42, 
        (signed char)-41,      (signed char)-39,      (signed char)-38,      (signed char)-37, 
        (signed char)-36,      (signed char)-34,      (signed char)-33,      (signed char)-32, 
        (signed char)-30,      (signed char)-29,      (signed char)-27,      (signed char)-26, 
        (signed char)-24,      (signed char)-23,      (signed char)-22,      (signed char)-20, 
        (signed char)-19,      (signed char)-17,      (signed char)-16,      (signed char)-14, 
        (signed char)-12,      (signed char)-11,      (signed char)-9,      (signed char)-8, 
        (signed char)-6,      (signed char)-5,      (signed char)-3,      (signed char)-2};
#line 614 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void reset_tick_counts___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;

  {
#line 618
  i = 0;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (i < 64)) {
#line 618
      goto while_break;
    }
#line 619
    channel = & sigrenderer->channel[i];
#line 620
    channel->key_off_count = (unsigned char)0;
#line 621
    channel->note_cut_count = (unsigned char)0;
#line 622
    channel->note_delay_count = (unsigned char)0;
#line 618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 624
  return;
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void reset_effects___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;

  {
#line 632
  sigrenderer->globalvolslide = (signed char)0;
#line 633
  sigrenderer->temposlide = (signed char)0;
#line 635
  i = 0;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < 64)) {
#line 635
      goto while_break;
    }
#line 636
    channel = & sigrenderer->channel[i];
#line 637
    channel->volslide = (signed char)0;
#line 638
    channel->xm_volslide = (signed char)0;
#line 639
    channel->panslide = (signed char)0;
#line 640
    channel->channelvolslide = (signed char)0;
#line 641
    channel->arpeggio = 0;
#line 642
    channel->retrig = (unsigned char)0;
#line 643
    if (channel->xm_retrig) {
#line 644
      channel->xm_retrig = (unsigned char)0;
#line 645
      channel->retrig_tick = 0;
    }
#line 647
    channel->tremor_time = (unsigned char )((int )channel->tremor_time & 127);
#line 648
    channel->portamento = 0;
#line 649
    channel->toneporta = 0;
#line 650
    if (channel->playing) {
#line 651
      (channel->playing)->vibrato_n = (unsigned char)0;
#line 652
      (channel->playing)->tremolo_speed = (unsigned char)0;
#line 653
      (channel->playing)->tremolo_depth = (unsigned char)0;
    }
#line 635
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return;
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_tremor___0(IT_CHANNEL *channel ) 
{ 


  {
#line 662
  if ((int )channel->tremor_time & 128) {
#line 662
    if (channel->playing) {
#line 663
      if ((int )channel->tremor_time == 128) {
#line 664
        channel->tremor_time = (unsigned char )(((int )channel->lastI >> 4) | 192);
      } else
#line 665
      if ((int )channel->tremor_time == 192) {
#line 666
        channel->tremor_time = (unsigned char )(((int )channel->lastI & 15) | 128);
      } else {
#line 668
        channel->tremor_time = (unsigned char )((int )channel->tremor_time - 1);
      }
    }
  }
#line 670
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_pickup_loop___0(DUMB_RESAMPLER *resampler , void *data ) 
{ 


  {
#line 676
  resampler->pos -= resampler->end - resampler->start;
#line 677
  ((IT_PLAYING *)data)->time_lost += resampler->end - resampler->start;
#line 678
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_pickup_pingpong_loop___0(DUMB_RESAMPLER *resampler , void *data ) 
{ 


  {
#line 684
  if (resampler->dir < 0) {
#line 685
    resampler->pos = ((resampler->start << 1) - 1L) - resampler->pos;
#line 686
    resampler->subpos ^= 65535;
#line 687
    resampler->dir = 1;
#line 688
    ((IT_PLAYING *)data)->time_lost += (resampler->end - resampler->start) << 1;
  } else {
#line 690
    resampler->pos = ((resampler->end << 1) - 1L) - resampler->pos;
#line 691
    resampler->subpos ^= 65535;
#line 692
    resampler->dir = -1;
  }
#line 694
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_pickup_stop_at_end___0(DUMB_RESAMPLER *resampler , void *data ) 
{ 


  {
#line 702
  if (resampler->dir < 0) {
#line 703
    resampler->pos = ((resampler->start << 1) - 1L) - resampler->pos;
#line 704
    resampler->subpos ^= 65535;
#line 710
    resampler->dir = 1;
  } else {
#line 712
    resampler->dir = 0;
  }
#line 713
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_playing_update_resamplers___0(IT_PLAYING *playing ) 
{ 


  {
#line 719
  if ((int )(playing->sample)->flags & 32) {
#line 719
    if (! (playing->flags & 2)) {
#line 720
      playing->resampler.start = (playing->sample)->sus_loop_start;
#line 721
      playing->resampler.end = (playing->sample)->sus_loop_end;
#line 722
      if ((int )(playing->sample)->flags & 128) {
#line 723
        playing->resampler.pickup = & it_pickup_pingpong_loop___0;
      } else {
#line 725
        playing->resampler.pickup = & it_pickup_loop___0;
      }
    } else {
#line 719
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 726
  if ((int )(playing->sample)->flags & 16) {
#line 727
    playing->resampler.start = (playing->sample)->loop_start;
#line 728
    playing->resampler.end = (playing->sample)->loop_end;
#line 729
    if ((int )(playing->sample)->flags & 64) {
#line 730
      playing->resampler.pickup = & it_pickup_pingpong_loop___0;
    } else {
#line 732
      playing->resampler.pickup = & it_pickup_loop___0;
    }
  } else {
#line 734
    if ((int )(playing->sample)->flags & 32) {
#line 735
      playing->resampler.start = (playing->sample)->sus_loop_start;
    } else {
#line 737
      playing->resampler.start = 0L;
    }
#line 738
    playing->resampler.end = (playing->sample)->length;
#line 739
    playing->resampler.pickup = & it_pickup_stop_at_end___0;
  }
#line 742
  return;
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_playing_reset_resamplers___0(IT_PLAYING *playing , long pos ) 
{ 
  int bits ;
  int tmp ;
  int channels ;
  int tmp___0 ;

  {
#line 749
  if ((int )(playing->sample)->flags & 2) {
#line 749
    tmp = 16;
  } else {
#line 749
    tmp = 8;
  }
#line 749
  bits = tmp;
#line 750
  if ((int )(playing->sample)->flags & 4) {
#line 750
    tmp___0 = 2;
  } else {
#line 750
    tmp___0 = 1;
  }
  {
#line 750
  channels = tmp___0;
#line 751
  dumb_reset_resampler_n(bits, & playing->resampler, (playing->sample)->data, channels,
                         pos, 0L, 0L);
#line 752
  playing->resampler.pickup_data = (void *)playing;
#line 753
  playing->time_lost = 0L;
#line 754
  playing->flags &= -9;
#line 755
  it_playing_update_resamplers___0(playing);
  }
#line 756
  return;
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_retrig___0(IT_CHANNEL *channel ) 
{ 


  {
#line 762
  if (channel->xm_retrig) {
#line 763
    (channel->retrig_tick) --;
#line 764
    if (channel->retrig_tick <= 0) {
#line 765
      if (channel->playing) {
        {
#line 765
        it_playing_reset_resamplers___0(channel->playing, 0L);
        }
      }
#line 766
      channel->retrig_tick = (int )channel->xm_retrig;
    }
  } else
#line 768
  if ((int )channel->retrig & 15) {
#line 769
    (channel->retrig_tick) --;
#line 770
    if (channel->retrig_tick <= 0) {
#line 771
      if (! ((int )channel->retrig < 16)) {
#line 772
        if ((int )channel->retrig < 32) {
#line 773
          channel->volume = (unsigned char )((int )channel->volume - 1);
#line 774
          if ((int )channel->volume > 64) {
#line 774
            channel->volume = (unsigned char)0;
          }
        } else
#line 775
        if ((int )channel->retrig < 48) {
#line 776
          channel->volume = (unsigned char )((int )channel->volume - 2);
#line 777
          if ((int )channel->volume > 64) {
#line 777
            channel->volume = (unsigned char)0;
          }
        } else
#line 778
        if ((int )channel->retrig < 64) {
#line 779
          channel->volume = (unsigned char )((int )channel->volume - 4);
#line 780
          if ((int )channel->volume > 64) {
#line 780
            channel->volume = (unsigned char)0;
          }
        } else
#line 781
        if ((int )channel->retrig < 80) {
#line 782
          channel->volume = (unsigned char )((int )channel->volume - 8);
#line 783
          if ((int )channel->volume > 64) {
#line 783
            channel->volume = (unsigned char)0;
          }
        } else
#line 784
        if ((int )channel->retrig < 96) {
#line 785
          channel->volume = (unsigned char )((int )channel->volume - 16);
#line 786
          if ((int )channel->volume > 64) {
#line 786
            channel->volume = (unsigned char)0;
          }
        } else
#line 787
        if ((int )channel->retrig < 112) {
#line 788
          channel->volume = (unsigned char )((int )channel->volume << 1);
#line 789
          channel->volume = (unsigned char )((int )channel->volume / 3);
        } else
#line 790
        if ((int )channel->retrig < 128) {
#line 791
          channel->volume = (unsigned char )((int )channel->volume >> 1);
        } else
#line 792
        if (! ((int )channel->retrig < 144)) {
#line 793
          if ((int )channel->retrig < 160) {
#line 794
            channel->volume = (unsigned char )((int )channel->volume + 1);
#line 795
            if ((int )channel->volume > 64) {
#line 795
              channel->volume = (unsigned char)64;
            }
          } else
#line 796
          if ((int )channel->retrig < 176) {
#line 797
            channel->volume = (unsigned char )((int )channel->volume + 2);
#line 798
            if ((int )channel->volume > 64) {
#line 798
              channel->volume = (unsigned char)64;
            }
          } else
#line 799
          if ((int )channel->retrig < 192) {
#line 800
            channel->volume = (unsigned char )((int )channel->volume + 4);
#line 801
            if ((int )channel->volume > 64) {
#line 801
              channel->volume = (unsigned char)64;
            }
          } else
#line 802
          if ((int )channel->retrig < 208) {
#line 803
            channel->volume = (unsigned char )((int )channel->volume + 8);
#line 804
            if ((int )channel->volume > 64) {
#line 804
              channel->volume = (unsigned char)64;
            }
          } else
#line 805
          if ((int )channel->retrig < 224) {
#line 806
            channel->volume = (unsigned char )((int )channel->volume + 16);
#line 807
            if ((int )channel->volume > 64) {
#line 807
              channel->volume = (unsigned char)64;
            }
          } else
#line 808
          if ((int )channel->retrig < 240) {
#line 809
            channel->volume = (unsigned char )((int )channel->volume * 3);
#line 810
            channel->volume = (unsigned char )((int )channel->volume >> 1);
#line 811
            if ((int )channel->volume > 64) {
#line 811
              channel->volume = (unsigned char)64;
            }
          } else {
#line 813
            channel->volume = (unsigned char )((int )channel->volume << 1);
#line 814
            if ((int )channel->volume > 64) {
#line 814
              channel->volume = (unsigned char)64;
            }
          }
        }
      }
#line 816
      if (channel->playing) {
        {
#line 816
        it_playing_reset_resamplers___0(channel->playing, 0L);
        }
      }
#line 817
      channel->retrig_tick = (int )channel->retrig & 15;
    }
  }
#line 820
  return;
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_smooth_effects___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;
  IT_PLAYING *playing ;

  {
#line 828
  i = 0;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! (i < 64)) {
#line 828
      goto while_break;
    }
#line 829
    channel = & sigrenderer->channel[i];
#line 830
    playing = channel->playing;
#line 832
    if (playing) {
#line 833
      playing->vibrato_time = (unsigned char )((int )playing->vibrato_time + (int )playing->vibrato_n * ((int )playing->vibrato_speed << 2));
#line 835
      playing->tremolo_time = (unsigned char )((int )playing->tremolo_time + ((int )playing->tremolo_speed << 2));
    }
#line 828
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  return;
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_effects___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;
  IT_PLAYING *playing ;
  int tmp___0 ;
  int tmp___1 ;
  int currpitch ;
  int destpitch ;
  float amiga_multiplier ;
  float deltanote ;
  double tmp___2 ;
  float deltaslid ;
  float destdelta ;
  double tmp___3 ;

  {
#line 846
  if (sigrenderer->globalvolslide) {
#line 847
    sigrenderer->globalvolume = (unsigned char )((int )sigrenderer->globalvolume + (int )sigrenderer->globalvolslide);
#line 848
    if ((int )sigrenderer->globalvolume > 128) {
#line 849
      if ((int )sigrenderer->globalvolslide >= 0) {
#line 850
        sigrenderer->globalvolume = (unsigned char)128;
      } else {
#line 852
        sigrenderer->globalvolume = (unsigned char)0;
      }
    }
  }
#line 856
  if (sigrenderer->temposlide) {
#line 857
    sigrenderer->tempo = (unsigned char )((int )sigrenderer->tempo + (int )sigrenderer->temposlide);
#line 858
    if ((int )sigrenderer->tempo < 32) {
#line 859
      if ((int )sigrenderer->temposlide >= 0) {
#line 860
        sigrenderer->tempo = (unsigned char)255;
      } else {
#line 862
        sigrenderer->tempo = (unsigned char)32;
      }
    }
  }
#line 866
  i = 0;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (i < 64)) {
#line 866
      goto while_break;
    }
#line 867
    channel = & sigrenderer->channel[i];
#line 868
    playing = channel->playing;
#line 870
    if (channel->xm_volslide) {
#line 871
      channel->volume = (unsigned char )((int )channel->volume + (int )channel->xm_volslide);
#line 872
      if ((int )channel->volume > 64) {
#line 873
        if ((int )channel->xm_volslide >= 0) {
#line 874
          channel->volume = (unsigned char)64;
        } else {
#line 876
          channel->volume = (unsigned char)0;
        }
      }
    }
#line 880
    if (channel->volslide) {
#line 881
      channel->volume = (unsigned char )((int )channel->volume + (int )channel->volslide);
#line 882
      if ((int )channel->volume > 64) {
#line 883
        if ((int )channel->volslide >= 0) {
#line 884
          channel->volume = (unsigned char)64;
        } else {
#line 886
          channel->volume = (unsigned char)0;
        }
      }
    }
#line 890
    if (channel->panslide) {
#line 890
      if (! ((int )channel->pan > 64)) {
#line 891
        if ((sigrenderer->sigdata)->flags & 64) {
#line 892
          if ((int )channel->panslide == -128) {
#line 893
            channel->truepan = (unsigned short)32;
          } else {
#line 895
            if ((int )channel->truepan + (int )channel->panslide * 64 < 16352) {
#line 895
              tmp___1 = (int )channel->truepan + (int )channel->panslide * 64;
            } else {
#line 895
              tmp___1 = 16352;
            }
#line 895
            if (32 > tmp___1) {
#line 895
              channel->truepan = (unsigned short)32;
            } else {
#line 895
              if ((int )channel->truepan + (int )channel->panslide * 64 < 16352) {
#line 895
                tmp___0 = (int )channel->truepan + (int )channel->panslide * 64;
              } else {
#line 895
                tmp___0 = 16352;
              }
#line 895
              channel->truepan = (unsigned short )tmp___0;
            }
          }
        } else {
#line 897
          channel->pan = (unsigned char )((int )channel->pan + (int )channel->panslide);
#line 898
          if ((int )channel->pan > 64) {
#line 899
            if ((int )channel->panslide >= 0) {
#line 900
              channel->pan = (unsigned char)64;
            } else {
#line 902
              channel->pan = (unsigned char)0;
            }
          }
#line 904
          channel->truepan = (unsigned short )((int )channel->pan << 8);
        }
      }
    }
#line 908
    if (channel->channelvolslide) {
#line 909
      channel->channelvolume = (unsigned char )((int )channel->channelvolume + (int )channel->channelvolslide);
#line 910
      if ((int )channel->channelvolume > 64) {
#line 911
        if ((int )channel->channelvolslide >= 0) {
#line 912
          channel->channelvolume = (unsigned char)64;
        } else {
#line 914
          channel->channelvolume = (unsigned char)0;
        }
      }
#line 916
      if (channel->playing) {
#line 917
        (channel->playing)->channel_volume = channel->channelvolume;
      }
    }
    {
#line 920
    update_tremor___0(channel);
#line 922
    channel->arpeggio = (channel->arpeggio << 4) | (channel->arpeggio >> 8);
#line 923
    channel->arpeggio &= 4095;
#line 925
    update_retrig___0(channel);
    }
#line 927
    if (playing) {
#line 928
      playing->slide += channel->portamento;
#line 930
      if ((sigrenderer->sigdata)->flags & 8) {
#line 931
        if (channel->toneporta) {
#line 931
          if ((int )channel->destnote < 120) {
#line 932
            currpitch = (((int )playing->note - 60) << 8) + playing->slide;
#line 933
            destpitch = ((int )channel->destnote - 60) << 8;
#line 934
            if (currpitch > destpitch) {
#line 935
              currpitch -= channel->toneporta;
#line 936
              if (currpitch < destpitch) {
#line 937
                currpitch = destpitch;
#line 938
                channel->destnote = (unsigned char)255;
              }
            } else
#line 940
            if (currpitch < destpitch) {
#line 941
              currpitch += channel->toneporta;
#line 942
              if (currpitch > destpitch) {
#line 943
                currpitch = destpitch;
#line 944
                channel->destnote = (unsigned char)255;
              }
            }
#line 947
            playing->slide = currpitch - (((int )playing->note - 60) << 8);
          }
        }
      } else
#line 950
      if (channel->toneporta) {
#line 950
        if ((int )channel->destnote < 120) {
          {
#line 951
          amiga_multiplier = (float )(playing->sample)->C5_speed * (1.0f / (float )(8.0 * 7159090.5));
#line 953
          tmp___2 = pow(1.059463094359295309843105314939748495817, (double )(60 - (int )playing->note));
#line 953
          deltanote = (float )tmp___2;
#line 956
          deltaslid = deltanote - (float )playing->slide * amiga_multiplier;
#line 958
          tmp___3 = pow(1.059463094359295309843105314939748495817, (double )(60 - (int )channel->destnote));
#line 958
          destdelta = (float )tmp___3;
          }
#line 959
          if (deltaslid < destdelta) {
#line 960
            playing->slide -= channel->toneporta;
#line 961
            deltaslid = deltanote - (float )playing->slide * amiga_multiplier;
#line 962
            if (deltaslid > destdelta) {
#line 963
              playing->note = channel->destnote;
#line 964
              playing->slide = 0;
#line 965
              channel->destnote = (unsigned char)255;
            }
          } else {
#line 968
            playing->slide += channel->toneporta;
#line 969
            deltaslid = deltanote - (float )playing->slide * amiga_multiplier;
#line 970
            if (deltaslid < destdelta) {
#line 971
              playing->note = channel->destnote;
#line 972
              playing->slide = 0;
#line 973
              channel->destnote = (unsigned char)255;
            }
          }
        }
      }
    }
#line 866
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  update_smooth_effects___0(sigrenderer);
  }
#line 982
  return;
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int update_pattern_variables___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  IT_CHANNEL *channel ;
  unsigned char effectvalue ;
  unsigned char v ;

  {
#line 990
  channel = & sigrenderer->channel[(int )entry->channel];
#line 992
  if ((int )entry->mask & 8) {
    {
#line 994
    if ((int )entry->effect == 2) {
#line 994
      goto case_2;
    }
#line 1000
    if ((int )entry->effect == 19) {
#line 1000
      goto case_19;
    }
#line 993
    goto switch_break;
    case_2: /* CIL Label */ 
#line 995
    sigrenderer->breakrow = 0;
#line 996
    sigrenderer->processorder = (int )entry->effectvalue - 1;
#line 997
    sigrenderer->processrow = 65534;
#line 998
    goto switch_break;
    case_19: /* CIL Label */ 
#line 1002
    effectvalue = entry->effectvalue;
#line 1003
    if ((int )effectvalue == 0) {
#line 1004
      effectvalue = channel->lastS;
    }
#line 1005
    channel->lastS = effectvalue;
    {
#line 1008
    if ((int )effectvalue >> 4 == 11) {
#line 1008
      goto case_11;
    }
#line 1071
    if ((int )effectvalue >> 4 == 14) {
#line 1071
      goto case_14;
    }
#line 1006
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 1010
    v = (unsigned char )((int )effectvalue & 15);
#line 1011
    if ((int )v == 0) {
#line 1012
      channel->pat_loop_row = (unsigned char )sigrenderer->processrow;
    } else
#line 1014
    if ((int )channel->pat_loop_count == 0) {
#line 1015
      channel->pat_loop_count = v;
#line 1016
      sigrenderer->breakrow = (int )channel->pat_loop_row;
#line 1017
      if ((sigrenderer->sigdata)->flags & 64) {
#line 1019
        if (sigrenderer->processrow < 65534) {
#line 1021
          if (sigrenderer->processrow < (int )channel->pat_loop_end_row) {
#line 1022
            sigrenderer->processorder = 65534;
          } else {
#line 1024
            sigrenderer->processorder = 65535;
          }
#line 1025
          channel->pat_loop_end_row = (unsigned char )sigrenderer->processrow;
#line 1026
          sigrenderer->processrow = 65535;
        }
      } else {
#line 1030
        sigrenderer->processorder = 65535;
#line 1031
        sigrenderer->processrow = 65534;
      }
#line 1033
      return (1);
    } else {
#line 1034
      channel->pat_loop_count = (unsigned char )((int )channel->pat_loop_count - 1);
#line 1034
      if (channel->pat_loop_count) {
#line 1035
        sigrenderer->breakrow = (int )channel->pat_loop_row;
#line 1036
        if ((sigrenderer->sigdata)->flags & 64) {
#line 1038
          if (sigrenderer->processrow < 65534) {
#line 1040
            if (sigrenderer->processrow < (int )channel->pat_loop_end_row) {
#line 1041
              sigrenderer->processorder = 65534;
            } else {
#line 1043
              sigrenderer->processorder = 65535;
            }
#line 1044
            channel->pat_loop_end_row = (unsigned char )sigrenderer->processrow;
#line 1045
            sigrenderer->processrow = 65535;
          }
        } else {
#line 1049
          sigrenderer->processorder = 65535;
#line 1050
          sigrenderer->processrow = 65534;
        }
#line 1052
        return (1);
      } else
#line 1053
      if ((sigrenderer->sigdata)->flags & 64) {
#line 1054
        channel->pat_loop_end_row = (unsigned char)0;
      } else {
#line 1067
        channel->pat_loop_row = (unsigned char )(sigrenderer->processrow + 1);
      }
    }
#line 1070
    goto switch_break___0;
    case_14: /* CIL Label */ 
#line 1072
    sigrenderer->rowcount = 1 + ((int )effectvalue & 15);
#line 1073
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 1079
  return (0);
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void instrument_to_sample___0(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 


  {
#line 1090
  if (sigdata->flags & 4) {
#line 1091
    if ((int )channel->instrument >= 1) {
#line 1091
      if ((int )channel->instrument <= sigdata->n_instruments) {
#line 1092
        if ((int )channel->note < 120) {
#line 1093
          channel->sample = (sigdata->instrument + ((int )channel->instrument - 1))->map_sample[channel->note];
#line 1094
          channel->truenote = (sigdata->instrument + ((int )channel->instrument - 1))->map_note[channel->note];
        } else {
#line 1096
          channel->sample = (unsigned short)0;
        }
      } else {
#line 1098
        channel->sample = (unsigned short)0;
      }
    } else {
#line 1098
      channel->sample = (unsigned short)0;
    }
  } else {
#line 1100
    channel->sample = (unsigned short )channel->instrument;
#line 1101
    channel->truenote = channel->note;
  }
#line 1103
  if ((int )channel->sample >= 1) {
#line 1103
    if ((int )channel->sample <= sigdata->n_samples) {
#line 1103
      if (! ((int )(sigdata->sample + ((int )channel->sample - 1))->flags & 1)) {
#line 1104
        channel->sample = (unsigned short)0;
      }
    } else {
#line 1104
      channel->sample = (unsigned short)0;
    }
  } else {
#line 1104
    channel->sample = (unsigned short)0;
  }
#line 1105
  return;
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void fix_sample_looping___0(IT_PLAYING *playing ) 
{ 


  {
#line 1111
  if (((int )(playing->sample)->flags & 48) == 48) {
#line 1113
    if (playing->resampler.dir < 0) {
#line 1114
      playing->resampler.pos = (((playing->sample)->sus_loop_end << 1) - 1L) - playing->resampler.pos;
#line 1115
      playing->resampler.subpos ^= 65535;
#line 1116
      playing->resampler.dir = 1;
    }
#line 1119
    playing->resampler.pos += playing->time_lost;
  }
#line 1121
  return;
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_compatible_gxx_retrigger___0(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 


  {
  {
#line 1127
  (channel->playing)->volume_envelope.next_node = 0;
#line 1128
  (channel->playing)->volume_envelope.tick = 0;
#line 1129
  (channel->playing)->pan_envelope.next_node = 0;
#line 1130
  (channel->playing)->pan_envelope.tick = 0;
#line 1131
  (channel->playing)->pitch_envelope.next_node = 0;
#line 1132
  (channel->playing)->pitch_envelope.tick = 0;
#line 1133
  (channel->playing)->fadeoutcount = 1024;
#line 1135
  (channel->playing)->flags &= -16;
#line 1136
  it_playing_update_resamplers___0(channel->playing);
  }
#line 1138
  if (channel->sample) {
#line 1139
    if (sigdata->flags & 4) {
#line 1140
      (channel->playing)->env_instrument = sigdata->instrument + ((int )channel->instrument - 1);
    }
  }
#line 1141
  return;
}
}
#line 1145 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_note_off___0(IT_PLAYING *playing ) 
{ 


  {
#line 1147
  if (playing) {
    {
#line 1148
    playing->flags |= 3;
#line 1149
    fix_sample_looping___0(playing);
#line 1150
    it_playing_update_resamplers___0(playing);
    }
#line 1151
    if (playing->instrument) {
#line 1152
      if (((int )(playing->instrument)->volume_envelope.flags & 3) != 1) {
#line 1153
        playing->flags |= 4;
      }
    }
  }
#line 1155
  return;
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void xm_note_off___0(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 


  {
#line 1161
  if (channel->playing) {
#line 1162
    if (! ((int )(sigdata->instrument + ((int )channel->instrument - 1))->volume_envelope.flags & 1)) {
#line 1165
      channel->volume = (unsigned char)0;
    }
    {
#line 1166
    (channel->playing)->flags |= 6;
#line 1167
    it_playing_update_resamplers___0(channel->playing);
    }
  }
#line 1169
  return;
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_retrigger_note___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_CHANNEL *channel ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  unsigned char nna ;
  int i ;
  void *tmp ;

  {
#line 1175
  sigdata = sigrenderer->sigdata;
#line 1179
  if (channel->playing) {
#line 1181
    if ((int )channel->note == 255) {
#line 1182
      nna = (unsigned char)2;
    } else
#line 1183
    if ((int )channel->note >= 120) {
#line 1184
      nna = (unsigned char)0;
    } else
#line 1183
    if (! (channel->playing)->instrument) {
#line 1184
      nna = (unsigned char)0;
    } else
#line 1183
    if ((channel->playing)->flags & 8) {
#line 1184
      nna = (unsigned char)0;
    } else {
#line 1186
      nna = ((channel->playing)->instrument)->new_note_action;
    }
    {
#line 1199
    if ((int )nna == 0) {
#line 1199
      goto case_0;
    }
#line 1203
    if ((int )nna == 2) {
#line 1203
      goto case_2;
    }
#line 1206
    if ((int )nna == 3) {
#line 1206
      goto case_3;
    }
#line 1198
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1200
    free((void *)channel->playing);
#line 1201
    channel->playing = (IT_PLAYING *)((void *)0);
    }
#line 1202
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1204
    it_note_off___0(channel->playing);
    }
#line 1205
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1207
    (channel->playing)->flags |= 5;
#line 1208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1212
  if ((int )channel->sample == 0) {
#line 1213
    return;
  } else
#line 1212
  if ((int )channel->note >= 120) {
#line 1213
    return;
  }
#line 1215
  channel->destnote = (unsigned char)255;
#line 1217
  if (channel->playing) {
#line 1218
    i = 0;
    {
#line 1218
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1218
      if (! (i < 192)) {
#line 1218
        goto while_break;
      }
#line 1219
      if (! sigrenderer->playing[i]) {
#line 1220
        sigrenderer->playing[i] = channel->playing;
#line 1221
        channel->playing = (IT_PLAYING *)((void *)0);
#line 1222
        goto while_break;
      }
#line 1218
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1241
  if (channel->playing) {
    {
#line 1242
    free((void *)channel->playing);
    }
  }
  {
#line 1244
  tmp = malloc(sizeof(*(channel->playing)));
#line 1244
  channel->playing = (IT_PLAYING *)tmp;
  }
#line 1246
  if (! channel->playing) {
#line 1247
    return;
  }
#line 1249
  (channel->playing)->flags = 0;
#line 1250
  (channel->playing)->channel = channel;
#line 1251
  (channel->playing)->sample = sigdata->sample + ((int )channel->sample - 1);
#line 1252
  if (sigdata->flags & 4) {
#line 1253
    (channel->playing)->instrument = sigdata->instrument + ((int )channel->instrument - 1);
  } else {
#line 1255
    (channel->playing)->instrument = (IT_INSTRUMENT *)((void *)0);
  }
  {
#line 1256
  (channel->playing)->env_instrument = (channel->playing)->instrument;
#line 1257
  (channel->playing)->sampnum = channel->sample;
#line 1258
  (channel->playing)->instnum = channel->instrument;
#line 1259
  (channel->playing)->channel_volume = channel->channelvolume;
#line 1260
  (channel->playing)->note = channel->truenote;
#line 1261
  (channel->playing)->filter_cutoff = (unsigned char)127;
#line 1262
  (channel->playing)->filter_resonance = (unsigned char)0;
#line 1263
  (channel->playing)->true_filter_cutoff = (unsigned short )(127 << 8);
#line 1264
  (channel->playing)->true_filter_resonance = (unsigned char)0;
#line 1265
  (channel->playing)->vibrato_speed = (unsigned char)0;
#line 1266
  (channel->playing)->vibrato_depth = (unsigned char)0;
#line 1267
  (channel->playing)->vibrato_n = (unsigned char)0;
#line 1268
  (channel->playing)->vibrato_time = (unsigned char)0;
#line 1269
  (channel->playing)->tremolo_speed = (unsigned char)0;
#line 1270
  (channel->playing)->tremolo_depth = (unsigned char)0;
#line 1271
  (channel->playing)->tremolo_time = (unsigned char)0;
#line 1272
  (channel->playing)->sample_vibrato_time = (unsigned char)0;
#line 1273
  (channel->playing)->sample_vibrato_depth = 0;
#line 1274
  (channel->playing)->slide = 0;
#line 1275
  (channel->playing)->volume_envelope.next_node = 0;
#line 1276
  (channel->playing)->volume_envelope.tick = 0;
#line 1277
  (channel->playing)->pan_envelope.next_node = 0;
#line 1278
  (channel->playing)->pan_envelope.tick = 0;
#line 1279
  (channel->playing)->pitch_envelope.next_node = 0;
#line 1280
  (channel->playing)->pitch_envelope.tick = 0;
#line 1281
  (channel->playing)->fadeoutcount = 1024;
#line 1282
  it_reset_filter_state___0(& (channel->playing)->filter_state[0]);
#line 1283
  it_reset_filter_state___0(& (channel->playing)->filter_state[1]);
#line 1284
  it_playing_reset_resamplers___0(channel->playing, 0L);
  }
#line 1287
  return;
}
}
#line 1291 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void get_default_volpan___0(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 
  int pan ;
  IT_INSTRUMENT *instrument ;

  {
#line 1293
  if ((int )channel->sample == 0) {
#line 1294
    return;
  }
#line 1296
  channel->volume = (sigdata->sample + ((int )channel->sample - 1))->default_volume;
#line 1298
  if (sigdata->flags & 64) {
#line 1299
    if (! (sigdata->flags & 128)) {
#line 1300
      channel->truepan = (unsigned short )(32 + (int )(sigdata->sample + ((int )channel->sample - 1))->default_pan * 64);
    }
#line 1301
    return;
  }
#line 1305
  pan = (int )(sigdata->sample + ((int )channel->sample - 1))->default_pan;
#line 1306
  if (pan >= 128) {
#line 1306
    if (pan <= 192) {
#line 1307
      channel->pan = (unsigned char )(pan - 128);
#line 1308
      return;
    }
  }
#line 1312
  if (sigdata->flags & 4) {
#line 1313
    instrument = sigdata->instrument + ((int )channel->instrument - 1);
#line 1314
    if ((int )instrument->default_pan <= 64) {
#line 1315
      channel->pan = instrument->default_pan;
    }
#line 1316
    if ((int )instrument->filter_cutoff >= 128) {
#line 1317
      channel->filter_cutoff = (unsigned char )((int )instrument->filter_cutoff - 128);
    }
#line 1318
    if ((int )instrument->filter_resonance >= 128) {
#line 1319
      channel->filter_resonance = (unsigned char )((int )instrument->filter_resonance - 128);
    }
  }
#line 1321
  return;
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void get_true_pan___0(DUMB_IT_SIGDATA *sigdata , IT_CHANNEL *channel ) 
{ 
  IT_INSTRUMENT *instrument ;
  int truepan ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1327
  channel->truepan = (unsigned short )((int )channel->pan << 8);
#line 1329
  if (! ((int )channel->truepan > 64 << 8)) {
#line 1329
    if (sigdata->flags & 4) {
#line 1330
      instrument = sigdata->instrument + ((int )channel->instrument - 1);
#line 1331
      truepan = (int )channel->truepan;
#line 1332
      truepan += ((int )channel->note - (int )instrument->pp_centre) * (int )instrument->pp_separation << 5;
#line 1333
      if (truepan < 64 << 8) {
#line 1333
        tmp___2 = truepan;
      } else {
#line 1333
        tmp___2 = 64 << 8;
      }
#line 1333
      if (0 > tmp___2) {
#line 1333
        tmp___1 = 0;
      } else {
#line 1333
        if (truepan < 64 << 8) {
#line 1333
          tmp___0 = truepan;
        } else {
#line 1333
          tmp___0 = 64 << 8;
        }
#line 1333
        tmp___1 = tmp___0;
      }
#line 1333
      channel->truepan = (unsigned short )tmp___1;
    }
  }
#line 1335
  return;
}
}
#line 1339 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void post_process_it_volpan___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  IT_CHANNEL *channel ;
  unsigned char v ;
  unsigned char v___0 ;
  unsigned char v___1 ;
  unsigned char v___2 ;
  unsigned char v___3 ;

  {
#line 1341
  channel = & sigrenderer->channel[(int )entry->channel];
#line 1343
  if ((int )entry->mask & 4) {
#line 1344
    if (! ((int )entry->volpan <= 84)) {
#line 1348
      if ((int )entry->volpan <= 94) {
#line 1350
        v = (unsigned char )((int )entry->volpan - 85);
#line 1351
        if ((int )v == 0) {
#line 1352
          v = (unsigned char )channel->lastvolslide;
        }
#line 1353
        channel->lastvolslide = (signed char )v;
#line 1355
        channel->volslide = (signed char )v;
      } else
#line 1356
      if ((int )entry->volpan <= 104) {
#line 1358
        v___0 = (unsigned char )((int )entry->volpan - 95);
#line 1359
        if ((int )v___0 == 0) {
#line 1360
          v___0 = (unsigned char )channel->lastvolslide;
        }
#line 1361
        channel->lastvolslide = (signed char )v___0;
#line 1363
        channel->volslide = (signed char )(- ((int )v___0));
      } else
#line 1364
      if ((int )entry->volpan <= 114) {
#line 1366
        v___1 = (unsigned char )(((int )entry->volpan - 105) << 2);
#line 1367
        if ((int )v___1 == 0) {
#line 1368
          v___1 = channel->lastEF;
        }
#line 1369
        channel->lastEF = v___1;
#line 1370
        channel->portamento -= (int )v___1 << 4;
      } else
#line 1371
      if ((int )entry->volpan <= 124) {
#line 1373
        v___2 = (unsigned char )(((int )entry->volpan - 115) << 2);
#line 1374
        if ((int )v___2 == 0) {
#line 1375
          v___2 = channel->lastEF;
        }
#line 1376
        channel->lastEF = v___2;
#line 1377
        channel->portamento += (int )v___2 << 4;
      } else
#line 1378
      if (! ((int )entry->volpan <= 202)) {
#line 1381
        if ((int )entry->volpan <= 212) {
#line 1384
          v___3 = (unsigned char )((int )entry->volpan - 203);
#line 1385
          if ((int )v___3 == 0) {
#line 1386
            v___3 = channel->lastHdepth;
          } else {
#line 1388
            v___3 = (unsigned char )((int )v___3 << 2);
#line 1389
            channel->lastHdepth = v___3;
          }
#line 1391
          if (channel->playing) {
#line 1392
            (channel->playing)->vibrato_speed = channel->lastHspeed;
#line 1393
            (channel->playing)->vibrato_depth = v___3;
#line 1394
            (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
          }
        }
      }
    }
  }
#line 1398
  return;
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_send_midi___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_CHANNEL *channel ,
                             unsigned char midi_byte ) 
{ 
  int tmp ;
  int i ;

  {
#line 1404
  if ((sigrenderer->callbacks)->midi) {
    {
#line 1405
    tmp = (*((sigrenderer->callbacks)->midi))((sigrenderer->callbacks)->midi_data,
                                              (int )(channel - sigrenderer->channel),
                                              midi_byte);
    }
#line 1405
    if (tmp) {
#line 1406
      return;
    }
  }
  {
#line 1409
  if ((int )channel->midi_state == 4) {
#line 1409
    goto case_4;
  }
#line 1413
  if ((int )channel->midi_state == 3) {
#line 1413
    goto case_3;
  }
#line 1417
  if ((int )channel->midi_state == 2) {
#line 1417
    goto case_2;
  }
#line 1425
  goto switch_default;
  case_4: /* CIL Label */ 
#line 1410
  if ((int )midi_byte < 128) {
#line 1410
    channel->filter_resonance = midi_byte;
  }
#line 1411
  channel->midi_state = (unsigned char)0;
#line 1412
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1414
  if ((int )midi_byte < 128) {
#line 1414
    channel->filter_cutoff = midi_byte;
  }
#line 1415
  channel->midi_state = (unsigned char)0;
#line 1416
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1418
  if ((int )midi_byte == 0) {
#line 1419
    channel->midi_state = (unsigned char)3;
  } else
#line 1420
  if ((int )midi_byte == 1) {
#line 1421
    channel->midi_state = (unsigned char)4;
  } else {
#line 1423
    channel->midi_state = (unsigned char)0;
  }
#line 1424
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1427
  if ((int )midi_byte == 240) {
#line 1427
    goto case_240;
  }
#line 1432
  if ((int )midi_byte == 255) {
#line 1432
    goto case_255;
  }
#line 1432
  if ((int )midi_byte == 252) {
#line 1432
    goto case_255;
  }
#line 1432
  if ((int )midi_byte == 250) {
#line 1432
    goto case_255;
  }
#line 1443
  goto switch_default___0;
  case_240: /* CIL Label */ 
#line 1428
  channel->midi_state = (unsigned char )((int )channel->midi_state + 1);
#line 1429
  goto switch_break___0;
  case_255: /* CIL Label */ 
  case_252: /* CIL Label */ 
  case_250: /* CIL Label */ 
#line 1436
  i = 0;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! (i < 64)) {
#line 1436
      goto while_break;
    }
#line 1437
    sigrenderer->channel[i].filter_cutoff = (unsigned char)127;
#line 1438
    sigrenderer->channel[i].filter_resonance = (unsigned char)0;
#line 1436
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 1444
  channel->midi_state = (unsigned char)0;
#line 1445
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1448
  return;
}
}
#line 1452 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void xm_envelope_calculate_value___0(IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 
  int ys ;
  int ts ;
  int te ;
  int ye ;
  int t ;

  {
#line 1454
  if (pe->next_node <= 0) {
#line 1455
    pe->value = (int )envelope->node_y[0] << 8;
  } else
#line 1456
  if (pe->next_node >= (int )envelope->n_nodes) {
#line 1457
    pe->value = (int )envelope->node_y[(int )envelope->n_nodes - 1] << 8;
  } else {
#line 1459
    ys = (int )envelope->node_y[pe->next_node - 1] << 8;
#line 1460
    ts = (int )envelope->node_t[pe->next_node - 1];
#line 1461
    te = (int )envelope->node_t[pe->next_node];
#line 1463
    if (ts == te) {
#line 1464
      pe->value = ys;
    } else {
#line 1466
      ye = (int )envelope->node_y[pe->next_node] << 8;
#line 1467
      t = pe->tick;
#line 1469
      pe->value = ys + ((ye - ys) * (t - ts)) / (te - ts);
    }
  }
#line 1472
  return;
}
}
#line 1477 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_effects___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ,
                               int ignore_cxx ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_CHANNEL *channel ;
  int tmp ;
  int tmp___0 ;
  unsigned char v ;
  unsigned char v___0 ;
  unsigned char v___1 ;
  unsigned char v___2 ;
  unsigned char v___3 ;
  unsigned char v___4 ;
  unsigned char v___5 ;
  unsigned char speed ;
  unsigned char depth ;
  unsigned char v___6 ;
  unsigned char v___7 ;
  unsigned char v___8 ;
  unsigned char v___9 ;
  int offset ;
  IT_PLAYING *playing ;
  IT_SAMPLE *sample ;
  int end ;
  unsigned char v___10 ;
  int p ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char v___11 ;
  unsigned char tmp___5 ;
  unsigned char speed___0 ;
  unsigned char depth___0 ;
  unsigned char effectvalue ;
  unsigned char v___12 ;
  unsigned char speed___1 ;
  unsigned char depth___1 ;
  unsigned char v___13 ;
  IT_MIDI *midi ;
  IT_MIDI *tmp___6 ;
  int n ;
  int i ;
  int n___0 ;
  int i___0 ;
  int j ;
  int tmp___7 ;
  IT_ENVELOPE *envelope ;
  IT_PLAYING_ENVELOPE *pe ;

  {
#line 1479
  sigdata = sigrenderer->sigdata;
#line 1481
  channel = & sigrenderer->channel[(int )entry->channel];
#line 1483
  if ((int )entry->mask & 8) {
    {
#line 1504
    if ((int )entry->effect == 1) {
#line 1504
      goto case_1;
    }
#line 1514
    if ((int )entry->effect == 3) {
#line 1514
      goto case_3;
    }
#line 1520
    if ((int )entry->effect == 11) {
#line 1520
      goto case_11;
    }
#line 1528
    if ((int )entry->effect == 12) {
#line 1528
      goto case_12;
    }
#line 1528
    if ((int )entry->effect == 4) {
#line 1528
      goto case_12;
    }
#line 1558
    if ((int )entry->effect == 29) {
#line 1558
      goto case_29;
    }
#line 1568
    if ((int )entry->effect == 30) {
#line 1568
      goto case_30;
    }
#line 1578
    if ((int )entry->effect == 5) {
#line 1578
      goto case_5;
    }
#line 1607
    if ((int )entry->effect == 6) {
#line 1607
      goto case_6;
    }
#line 1636
    if ((int )entry->effect == 27) {
#line 1636
      goto case_27;
    }
#line 1648
    if ((int )entry->effect == 28) {
#line 1648
      goto case_28;
    }
#line 1660
    if ((int )entry->effect == 32) {
#line 1660
      goto case_32;
    }
#line 1664
    if ((int )entry->effect == 8) {
#line 1664
      goto case_8;
    }
#line 1687
    if ((int )entry->effect == 9) {
#line 1687
      goto case_9;
    }
#line 1701
    if ((int )entry->effect == 10) {
#line 1701
      goto case_10;
    }
#line 1715
    if ((int )entry->effect == 13) {
#line 1715
      goto case_13;
    }
#line 1727
    if ((int )entry->effect == 14) {
#line 1727
      goto case_14;
    }
#line 1751
    if ((int )entry->effect == 15) {
#line 1751
      goto case_15;
    }
#line 1784
    if ((int )entry->effect == 16) {
#line 1784
      goto case_16;
    }
#line 1821
    if ((int )entry->effect == 17) {
#line 1821
      goto case_17;
    }
#line 1843
    if ((int )entry->effect == 31) {
#line 1843
      goto case_31;
    }
#line 1848
    if ((int )entry->effect == 18) {
#line 1848
      goto case_18;
    }
#line 1864
    if ((int )entry->effect == 19) {
#line 1864
      goto case_19;
    }
#line 1917
    if ((int )entry->effect == 20) {
#line 1917
      goto case_20;
    }
#line 1931
    if ((int )entry->effect == 21) {
#line 1931
      goto case_21;
    }
#line 1952
    if ((int )entry->effect == 22) {
#line 1952
      goto case_22;
    }
#line 1960
    if ((int )entry->effect == 23) {
#line 1960
      goto case_23;
    }
#line 1981
    if ((int )entry->effect == 24) {
#line 1981
      goto case_24;
    }
#line 1990
    if ((int )entry->effect == 26) {
#line 1990
      goto case_26;
    }
#line 2008
    if ((int )entry->effect == 33) {
#line 2008
      goto case_33;
    }
#line 1484
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1505
    if (entry->effectvalue) {
#line 1506
      tmp = (int )entry->effectvalue;
#line 1506
      sigrenderer->speed = tmp;
#line 1506
      sigrenderer->tick = tmp;
    } else
#line 1507
    if (sigdata->flags & 64) {
#line 1508
      sigrenderer->speed = 0;
#line 1509
      if ((sigrenderer->callbacks)->xm_speed_zero) {
        {
#line 1509
        tmp___0 = (*((sigrenderer->callbacks)->xm_speed_zero))((sigrenderer->callbacks)->xm_speed_zero_data);
        }
#line 1509
        if (tmp___0) {
#line 1510
          return (1);
        }
      }
    }
#line 1512
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1515
    if (ignore_cxx) {
#line 1515
      goto switch_break;
    }
#line 1516
    sigrenderer->breakrow = (int )entry->effectvalue;
#line 1517
    sigrenderer->processrow = 65534;
#line 1518
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1521
    if (channel->playing) {
#line 1522
      (channel->playing)->vibrato_speed = channel->lastHspeed;
#line 1523
      (channel->playing)->vibrato_depth = channel->lastHdepth;
#line 1524
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
    case_12: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1531
    v = entry->effectvalue;
#line 1532
    if (! (sigdata->flags & 128)) {
#line 1533
      if ((int )v == 0) {
#line 1534
        v = channel->lastDKL;
      }
#line 1535
      channel->lastDKL = v;
    }
#line 1537
    if (((int )v & 15) == 0) {
#line 1538
      channel->volslide = (signed char )((int )v >> 4);
#line 1539
      if ((int )channel->volslide == 15) {
#line 1539
        if (! (sigdata->flags & 64)) {
#line 1540
          channel->volume = (unsigned char )((int )channel->volume + 15);
#line 1541
          if ((int )channel->volume > 64) {
#line 1541
            channel->volume = (unsigned char)64;
          }
        }
      }
    } else
#line 1543
    if (((int )v & 240) == 0) {
#line 1544
      channel->volslide = (signed char )(- ((int )v));
#line 1545
      if ((int )channel->volslide == -15) {
#line 1545
        if (! (sigdata->flags & 64)) {
#line 1546
          channel->volume = (unsigned char )((int )channel->volume - 15);
#line 1547
          if ((int )channel->volume > 64) {
#line 1547
            channel->volume = (unsigned char)0;
          }
        }
      }
    } else
#line 1549
    if (((int )v & 15) == 15) {
#line 1550
      channel->volume = (unsigned char )((int )channel->volume + ((int )v >> 4));
#line 1551
      if ((int )channel->volume > 64) {
#line 1551
        channel->volume = (unsigned char)64;
      }
    } else
#line 1552
    if (((int )v & 240) == 240) {
#line 1553
      channel->volume = (unsigned char )((int )channel->volume - ((int )v & 15));
#line 1554
      if ((int )channel->volume > 64) {
#line 1554
        channel->volume = (unsigned char)0;
      }
    }
#line 1557
    goto switch_break;
    case_29: /* CIL Label */ 
#line 1560
    v___0 = entry->effectvalue;
#line 1561
    if ((int )v___0 == 0) {
#line 1562
      v___0 = channel->xm_lastEB;
    }
#line 1563
    channel->xm_lastEB = v___0;
#line 1564
    channel->volume = (unsigned char )((int )channel->volume - (int )v___0);
#line 1565
    if ((int )channel->volume > 64) {
#line 1565
      channel->volume = (unsigned char)0;
    }
#line 1567
    goto switch_break;
    case_30: /* CIL Label */ 
#line 1570
    v___1 = entry->effectvalue;
#line 1571
    if ((int )v___1 == 0) {
#line 1572
      v___1 = channel->xm_lastEA;
    }
#line 1573
    channel->xm_lastEA = v___1;
#line 1574
    channel->volume = (unsigned char )((int )channel->volume + (int )v___1);
#line 1575
    if ((int )channel->volume > 64) {
#line 1575
      channel->volume = (unsigned char)64;
    }
#line 1577
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1580
    v___2 = entry->effectvalue;
#line 1581
    if (sigdata->flags & 64) {
#line 1582
      if (! (sigdata->flags & 128)) {
#line 1583
        if ((int )v___2 == 240) {
#line 1584
          v___2 = (unsigned char )((int )v___2 | (int )channel->xm_lastE2);
        } else
#line 1585
        if ((int )v___2 >= 240) {
#line 1586
          channel->xm_lastE2 = (unsigned char )((int )v___2 & 15);
        } else
#line 1587
        if ((int )v___2 == 224) {
#line 1588
          v___2 = (unsigned char )((int )v___2 | (int )channel->xm_lastX2);
        } else {
#line 1590
          channel->xm_lastX2 = (unsigned char )((int )v___2 & 15);
        }
      }
    } else {
#line 1593
      if ((int )v___2 == 0) {
#line 1594
        v___2 = channel->lastEF;
      }
#line 1595
      channel->lastEF = v___2;
    }
#line 1597
    if (channel->playing) {
#line 1598
      if (((int )v___2 & 240) == 240) {
#line 1599
        (channel->playing)->slide -= ((int )v___2 & 15) << 4;
      } else
#line 1600
      if (((int )v___2 & 240) == 224) {
#line 1601
        (channel->playing)->slide -= ((int )v___2 & 15) << 2;
      } else {
#line 1603
        channel->portamento -= (int )v___2 << 4;
      }
    }
#line 1606
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1609
    v___3 = entry->effectvalue;
#line 1610
    if (sigdata->flags & 64) {
#line 1611
      if (! (sigdata->flags & 128)) {
#line 1612
        if ((int )v___3 == 240) {
#line 1613
          v___3 = (unsigned char )((int )v___3 | (int )channel->xm_lastE1);
        } else
#line 1614
        if ((int )v___3 >= 240) {
#line 1615
          channel->xm_lastE1 = (unsigned char )((int )v___3 & 15);
        } else
#line 1616
        if ((int )v___3 == 224) {
#line 1617
          v___3 = (unsigned char )((int )v___3 | (int )channel->xm_lastX1);
        } else {
#line 1619
          channel->xm_lastX1 = (unsigned char )((int )v___3 & 15);
        }
      }
    } else {
#line 1622
      if ((int )v___3 == 0) {
#line 1623
        v___3 = channel->lastEF;
      }
#line 1624
      channel->lastEF = v___3;
    }
#line 1626
    if (channel->playing) {
#line 1627
      if (((int )v___3 & 240) == 240) {
#line 1628
        (channel->playing)->slide += ((int )v___3 & 15) << 4;
      } else
#line 1629
      if (((int )v___3 & 240) == 224) {
#line 1630
        (channel->playing)->slide += ((int )v___3 & 15) << 2;
      } else {
#line 1632
        channel->portamento += (int )v___3 << 4;
      }
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1638
    v___4 = entry->effectvalue;
#line 1639
    if (! (sigdata->flags & 128)) {
#line 1640
      if ((int )v___4 == 0) {
#line 1641
        v___4 = channel->lastJ;
      }
#line 1642
      channel->lastJ = v___4;
    }
#line 1644
    if (channel->playing) {
#line 1645
      channel->portamento -= (int )v___4 << 4;
    }
#line 1647
    goto switch_break;
    case_28: /* CIL Label */ 
#line 1650
    v___5 = entry->effectvalue;
#line 1651
    if (! (sigdata->flags & 128)) {
#line 1652
      if ((int )v___5 == 0) {
#line 1653
        v___5 = channel->lastEF;
      }
#line 1654
      channel->lastEF = v___5;
    }
#line 1656
    if (channel->playing) {
#line 1657
      channel->portamento += (int )v___5 << 4;
    }
#line 1659
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1661
    channel->key_off_count = entry->effectvalue;
#line 1662
    if (! channel->key_off_count) {
      {
#line 1662
      xm_note_off___0(sigdata, channel);
      }
    }
#line 1663
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1666
    speed = (unsigned char )((int )entry->effectvalue >> 4);
#line 1667
    depth = (unsigned char )((int )entry->effectvalue & 15);
#line 1668
    if ((int )speed == 0) {
#line 1669
      speed = channel->lastHspeed;
    }
#line 1670
    channel->lastHspeed = speed;
#line 1671
    if ((int )depth == 0) {
#line 1672
      depth = channel->lastHdepth;
    } else {
#line 1674
      if (sigdata->flags & 16) {
#line 1675
        depth = (unsigned char )((int )depth << 3);
      } else {
#line 1677
        depth = (unsigned char )((int )depth << 2);
      }
#line 1678
      channel->lastHdepth = depth;
    }
#line 1680
    if (channel->playing) {
#line 1681
      (channel->playing)->vibrato_speed = speed;
#line 1682
      (channel->playing)->vibrato_depth = depth;
#line 1683
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
#line 1686
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1689
    v___6 = entry->effectvalue;
#line 1690
    if ((int )v___6 == 0) {
#line 1691
      v___6 = channel->lastI;
    } else
#line 1692
    if (! (sigdata->flags & 16)) {
#line 1693
      if ((int )v___6 & 240) {
#line 1693
        v___6 = (unsigned char )((int )v___6 - 16);
      }
#line 1694
      if ((int )v___6 & 15) {
#line 1694
        v___6 = (unsigned char )((int )v___6 - 1);
      }
    }
    {
#line 1696
    channel->lastI = v___6;
#line 1697
    channel->tremor_time = (unsigned char )((int )channel->tremor_time | 128);
#line 1699
    update_tremor___0(channel);
    }
#line 1700
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1703
    v___7 = entry->effectvalue;
#line 1707
    if (! (sigdata->flags & 64)) {
#line 1708
      if ((int )v___7 == 0) {
#line 1709
        v___7 = channel->lastJ;
      }
#line 1710
      channel->lastJ = v___7;
    }
#line 1712
    channel->arpeggio = (int )v___7;
#line 1714
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1716
    if (sigdata->flags & 64) {
#line 1717
      if ((int )entry->effectvalue < 64) {
#line 1717
        channel->volume = entry->effectvalue;
      } else {
#line 1717
        channel->volume = (unsigned char)64;
      }
    } else
#line 1718
    if ((int )entry->effectvalue <= 64) {
#line 1719
      channel->channelvolume = entry->effectvalue;
    } else {
#line 1722
      channel->channelvolume = (unsigned char)64;
    }
#line 1724
    if (channel->playing) {
#line 1725
      (channel->playing)->channel_volume = channel->channelvolume;
    }
#line 1726
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1729
    v___8 = entry->effectvalue;
#line 1730
    if ((int )v___8 == 0) {
#line 1731
      v___8 = channel->lastN;
    }
#line 1732
    channel->lastN = v___8;
#line 1733
    if (((int )v___8 & 15) == 0) {
#line 1734
      channel->channelvolslide = (signed char )((int )v___8 >> 4);
    } else
#line 1735
    if (((int )v___8 & 240) == 0) {
#line 1736
      channel->channelvolslide = (signed char )(- ((int )v___8));
    } else {
#line 1738
      if (((int )v___8 & 15) == 15) {
#line 1739
        channel->channelvolume = (unsigned char )((int )channel->channelvolume + ((int )v___8 >> 4));
#line 1740
        if ((int )channel->channelvolume > 64) {
#line 1740
          channel->channelvolume = (unsigned char)64;
        }
      } else
#line 1741
      if (((int )v___8 & 240) == 240) {
#line 1742
        channel->channelvolume = (unsigned char )((int )channel->channelvolume - ((int )v___8 & 15));
#line 1743
        if ((int )channel->channelvolume > 64) {
#line 1743
          channel->channelvolume = (unsigned char)0;
        }
      } else {
#line 1745
        goto switch_break;
      }
#line 1746
      if (channel->playing) {
#line 1747
        (channel->playing)->channel_volume = channel->channelvolume;
      }
    }
#line 1750
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1753
    v___9 = entry->effectvalue;
#line 1754
    if (sigdata->flags & 128) {
#line 1755
      if ((int )v___9 == 0) {
#line 1755
        goto switch_break;
      }
    } else {
#line 1757
      if ((int )v___9 == 0) {
#line 1758
        v___9 = channel->lastO;
      }
#line 1759
      channel->lastO = v___9;
    }
#line 1764
    if ((int )entry->mask & 1) {
#line 1765
      if (channel->playing) {
#line 1766
        offset = ((int )channel->high_offset << 16) | ((int )v___9 << 8);
#line 1767
        playing = channel->playing;
#line 1768
        sample = playing->sample;
#line 1770
        if ((int )sample->flags & 32) {
#line 1770
          if (! (playing->flags & 2)) {
#line 1771
            end = (int )sample->sus_loop_end;
          } else {
#line 1770
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1772
        if ((int )sample->flags & 16) {
#line 1773
          end = (int )sample->loop_end;
        } else {
#line 1775
          end = (int )sample->length;
        }
#line 1776
        if (offset < end) {
          {
#line 1777
          it_playing_reset_resamplers___0(playing, (long )offset);
          }
        } else
#line 1778
        if (sigdata->flags & 16) {
          {
#line 1779
          it_playing_reset_resamplers___0(playing, (long )end);
          }
        }
      }
    }
#line 1783
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1793
    v___10 = entry->effectvalue;
#line 1794
    p = (int )channel->truepan;
#line 1795
    if (sigdata->flags & 64) {
#line 1796
      p >>= 6;
    } else {
#line 1798
      p = (p + 128) >> 8;
#line 1799
      channel->pan = (unsigned char )p;
    }
#line 1801
    if ((int )v___10 == 0) {
#line 1802
      v___10 = channel->lastP;
    }
#line 1803
    channel->lastP = v___10;
#line 1804
    if (((int )v___10 & 15) == 0) {
#line 1805
      channel->panslide = (signed char )((int )v___10 >> 4);
    } else
#line 1806
    if (((int )v___10 & 240) == 0) {
#line 1807
      channel->panslide = (signed char )(- ((int )v___10));
    } else
#line 1808
    if (((int )v___10 & 15) == 15) {
#line 1809
      p += (int )v___10 >> 4;
    } else
#line 1810
    if (((int )v___10 & 240) == 240) {
#line 1811
      p -= (int )v___10 & 15;
    }
#line 1813
    if (sigdata->flags & 64) {
#line 1814
      if (p < 255) {
#line 1814
        tmp___4 = p;
      } else {
#line 1814
        tmp___4 = 255;
      }
#line 1814
      if (0 > tmp___4) {
#line 1814
        tmp___3 = 0;
      } else {
#line 1814
        if (p < 255) {
#line 1814
          tmp___2 = p;
        } else {
#line 1814
          tmp___2 = 255;
        }
#line 1814
        tmp___3 = tmp___2;
      }
#line 1814
      channel->truepan = (unsigned short )(32 + tmp___3 * 64);
    } else
#line 1815
    if (! ((int )channel->pan > 64)) {
#line 1816
      channel->pan = (unsigned char )p;
#line 1817
      channel->truepan = (unsigned short )(p << 8);
    }
#line 1820
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1823
    v___11 = entry->effectvalue;
#line 1824
    if (sigdata->flags & 64) {
#line 1825
      if (((int )v___11 & 15) == 0) {
#line 1825
        v___11 = (unsigned char )((int )v___11 | ((int )channel->lastQ & 15));
      }
#line 1826
      if (((int )v___11 & 240) == 0) {
#line 1826
        v___11 = (unsigned char )((int )v___11 | ((int )channel->lastQ & 240));
      }
    } else
#line 1828
    if ((int )v___11 == 0) {
#line 1829
      v___11 = channel->lastQ;
    }
#line 1831
    channel->lastQ = v___11;
#line 1832
    if (((int )v___11 & 15) == 0) {
#line 1832
      v___11 = (unsigned char )((int )v___11 | 1);
    }
#line 1833
    channel->retrig = v___11;
#line 1834
    if ((int )entry->mask & 1) {
#line 1835
      channel->retrig_tick = (int )v___11 & 15;
#line 1837
      if (sigdata->flags & 64) {
        {
#line 1838
        update_retrig___0(channel);
        }
      }
    } else {
      {
#line 1840
      update_retrig___0(channel);
      }
    }
#line 1842
    goto switch_break;
    case_31: /* CIL Label */ 
#line 1844
    tmp___5 = entry->effectvalue;
#line 1844
    channel->xm_retrig = tmp___5;
#line 1844
    channel->retrig_tick = (int )tmp___5;
#line 1845
    if ((int )entry->effectvalue == 0) {
#line 1846
      if (channel->playing) {
        {
#line 1846
        it_playing_reset_resamplers___0(channel->playing, 0L);
        }
      }
    }
#line 1847
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1850
    speed___0 = (unsigned char )((int )entry->effectvalue >> 4);
#line 1851
    depth___0 = (unsigned char )((int )entry->effectvalue & 15);
#line 1852
    if ((int )speed___0 == 0) {
#line 1853
      speed___0 = channel->lastRspeed;
    }
#line 1854
    channel->lastRspeed = speed___0;
#line 1855
    if ((int )depth___0 == 0) {
#line 1856
      depth___0 = channel->lastRdepth;
    }
#line 1857
    channel->lastRdepth = depth___0;
#line 1858
    if (channel->playing) {
#line 1859
      (channel->playing)->tremolo_speed = speed___0;
#line 1860
      (channel->playing)->tremolo_depth = depth___0;
    }
#line 1863
    goto switch_break;
    case_19: /* CIL Label */ 
#line 1867
    effectvalue = channel->lastS;
    {
#line 1881
    if ((int )effectvalue >> 4 == 6) {
#line 1881
      goto case_6___0;
    }
#line 1885
    if ((int )effectvalue >> 4 == 8) {
#line 1885
      goto case_8___0;
    }
#line 1892
    if ((int )effectvalue >> 4 == 9) {
#line 1892
      goto case_9___0;
    }
#line 1898
    if ((int )effectvalue >> 4 == 10) {
#line 1898
      goto case_10___0;
    }
#line 1902
    if ((int )effectvalue >> 4 == 12) {
#line 1902
      goto case_12___0;
    }
#line 1911
    if ((int )effectvalue >> 4 == 15) {
#line 1911
      goto case_15___0;
    }
#line 1868
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 1882
    sigrenderer->tick += (int )effectvalue & 15;
#line 1883
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 1887
    channel->pan = (unsigned char )((((int )effectvalue & 15) << 2) | (((int )effectvalue & 15) >> 2));
#line 1890
    channel->truepan = (unsigned short )((int )channel->pan << 8);
#line 1891
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
#line 1893
    if (((int )effectvalue & 15) == 1) {
#line 1894
      channel->pan = (unsigned char)100;
#line 1895
      channel->truepan = (unsigned short )((int )channel->pan << 8);
    }
#line 1897
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
#line 1899
    channel->high_offset = (unsigned char )((int )effectvalue & 15);
#line 1900
    goto switch_break___0;
    case_12___0: /* CIL Label */ 
#line 1903
    channel->note_cut_count = (unsigned char )((int )effectvalue & 15);
#line 1904
    if (! channel->note_cut_count) {
#line 1905
      if (sigdata->flags & 64) {
#line 1906
        channel->volume = (unsigned char)0;
      } else {
#line 1908
        channel->note_cut_count = (unsigned char)1;
      }
    }
#line 1910
    goto switch_break___0;
    case_15___0: /* CIL Label */ 
#line 1912
    channel->SFmacro = (unsigned char )((int )effectvalue & 15);
#line 1913
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1916
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1919
    v___12 = entry->effectvalue;
#line 1920
    if ((int )v___12 == 0) {
#line 1921
      v___12 = channel->lastW;
    }
#line 1922
    channel->lastW = v___12;
#line 1923
    if ((int )v___12 < 16) {
#line 1924
      sigrenderer->temposlide = (signed char )(- ((int )v___12));
    } else
#line 1925
    if ((int )v___12 < 32) {
#line 1926
      sigrenderer->temposlide = (signed char )((int )v___12 & 15);
    } else {
#line 1928
      sigrenderer->tempo = v___12;
    }
#line 1930
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1933
    speed___1 = (unsigned char )((int )entry->effectvalue >> 4);
#line 1934
    depth___1 = (unsigned char )((int )entry->effectvalue & 15);
#line 1935
    if ((int )speed___1 == 0) {
#line 1936
      speed___1 = channel->lastHspeed;
    }
#line 1937
    channel->lastHspeed = speed___1;
#line 1938
    if ((int )depth___1 == 0) {
#line 1939
      depth___1 = channel->lastHdepth;
    } else {
#line 1941
      if (sigdata->flags & 16) {
#line 1942
        depth___1 = (unsigned char )((int )depth___1 << 1);
      }
#line 1943
      channel->lastHdepth = depth___1;
    }
#line 1945
    if (channel->playing) {
#line 1946
      (channel->playing)->vibrato_speed = speed___1;
#line 1947
      (channel->playing)->vibrato_depth = depth___1;
#line 1948
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
#line 1951
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1953
    if ((int )entry->effectvalue <= 128) {
#line 1954
      sigrenderer->globalvolume = entry->effectvalue;
    } else {
#line 1957
      sigrenderer->globalvolume = (unsigned char)128;
    }
#line 1959
    goto switch_break;
    case_23: /* CIL Label */ 
#line 1962
    v___13 = entry->effectvalue;
#line 1963
    if ((int )v___13 == 0) {
#line 1964
      v___13 = channel->lastW;
    }
#line 1965
    channel->lastW = v___13;
#line 1966
    if (((int )v___13 & 15) == 0) {
#line 1967
      if (sigdata->flags & 64) {
#line 1967
        sigrenderer->globalvolslide = (signed char )(((int )v___13 >> 4) * 2);
      } else {
#line 1967
        sigrenderer->globalvolslide = (signed char )((int )v___13 >> 4);
      }
    } else
#line 1969
    if (((int )v___13 & 240) == 0) {
#line 1970
      if (sigdata->flags & 64) {
#line 1970
        sigrenderer->globalvolslide = (signed char )(- ((int )v___13) * 2);
      } else {
#line 1970
        sigrenderer->globalvolslide = (signed char )(- ((int )v___13));
      }
    } else
#line 1972
    if (((int )v___13 & 15) == 15) {
#line 1973
      sigrenderer->globalvolume = (unsigned char )((int )sigrenderer->globalvolume + ((int )v___13 >> 4));
#line 1974
      if ((int )sigrenderer->globalvolume > 128) {
#line 1974
        sigrenderer->globalvolume = (unsigned char)128;
      }
    } else
#line 1975
    if (((int )v___13 & 240) == 240) {
#line 1976
      sigrenderer->globalvolume = (unsigned char )((int )sigrenderer->globalvolume - ((int )v___13 & 15));
#line 1977
      if ((int )sigrenderer->globalvolume > 128) {
#line 1977
        sigrenderer->globalvolume = (unsigned char)0;
      }
    }
#line 1980
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1982
    if (sigdata->flags & 64) {
#line 1983
      channel->truepan = (unsigned short )(32 + (int )entry->effectvalue * 64);
    } else {
#line 1985
      channel->pan = (unsigned char )(((int )entry->effectvalue + 2) >> 2);
#line 1986
      channel->truepan = (unsigned short )((int )channel->pan << 8);
    }
#line 1988
    goto switch_break;
    case_26: /* CIL Label */ 
#line 1992
    if (sigdata->midi) {
#line 1992
      tmp___6 = sigdata->midi;
    } else {
#line 1992
      tmp___6 = & default_midi___0;
    }
#line 1992
    midi = tmp___6;
#line 1993
    if ((int )entry->effectvalue >= 128) {
#line 1994
      n = (int )midi->Zmacrolen[(int )entry->effectvalue - 128];
#line 1996
      i = 0;
      {
#line 1996
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1996
        if (! (i < n)) {
#line 1996
          goto while_break;
        }
        {
#line 1997
        it_send_midi___0(sigrenderer, channel, midi->Zmacro[(int )entry->effectvalue - 128][i]);
#line 1996
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1999
      n___0 = (int )midi->SFmacrolen[channel->SFmacro];
#line 2001
      i___0 = 0;
#line 2001
      j = 1;
      {
#line 2001
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2001
        if (! (i___0 < n___0)) {
#line 2001
          goto while_break___0;
        }
#line 2002
        if ((int )midi->SFmacroz[channel->SFmacro] & j) {
#line 2002
          tmp___7 = (int )entry->effectvalue;
        } else {
#line 2002
          tmp___7 = (int )midi->SFmacro[channel->SFmacro][i___0];
        }
        {
#line 2002
        it_send_midi___0(sigrenderer, channel, (unsigned char )tmp___7);
#line 2001
        i___0 ++;
#line 2001
        j <<= 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2007
    goto switch_break;
    case_33: /* CIL Label */ 
#line 2009
    if (channel->playing) {
#line 2009
      if ((channel->playing)->env_instrument) {
#line 2010
        envelope = & ((channel->playing)->env_instrument)->volume_envelope;
#line 2011
        if ((int )envelope->flags & 1) {
#line 2012
          pe = & (channel->playing)->volume_envelope;
#line 2013
          pe->tick = (int )entry->effectvalue;
#line 2014
          if (pe->tick >= (int )envelope->node_t[(int )envelope->n_nodes - 1]) {
#line 2015
            pe->tick = (int )envelope->node_t[(int )envelope->n_nodes - 1];
          }
#line 2016
          pe->next_node = 0;
          {
#line 2017
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2017
            if (! (pe->tick > (int )envelope->node_t[pe->next_node])) {
#line 2017
              goto while_break___1;
            }
#line 2017
            (pe->next_node) ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 2018
          xm_envelope_calculate_value___0(envelope, pe);
          }
        }
      }
    }
#line 2021
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2025
  if (! (sigdata->flags & 64)) {
    {
#line 2026
    post_process_it_volpan___0(sigrenderer, entry);
    }
  }
#line 2028
  return (0);
}
}
#line 2086
static int process_it_note_data___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) ;
#line 2086 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static unsigned char const   slidetable___0[10]  = 
#line 2086
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )8, 
        (unsigned char const   )16,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )96, 
        (unsigned char const   )128,      (unsigned char const   )255};
#line 2033 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_it_note_data___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_CHANNEL *channel ;
  unsigned char note ;
  int slide ;
  unsigned char v ;
  unsigned char v___0 ;
  unsigned char v___1 ;
  unsigned char v___2 ;

  {
#line 2035
  sigdata = sigrenderer->sigdata;
#line 2036
  channel = & sigrenderer->channel[(int )entry->channel];
#line 2049
  if ((int )entry->mask & 3) {
#line 2050
    if ((int )entry->mask & 2) {
#line 2051
      channel->instrument = entry->instrument;
    }
    {
#line 2052
    instrument_to_sample___0(sigdata, channel);
    }
#line 2053
    if ((int )channel->note < 120) {
#line 2054
      if (sigdata->flags & 4) {
#line 2054
        if ((int )channel->sample == 0) {
#line 2055
          return (1);
        }
      }
#line 2056
      if ((int )entry->mask & 2) {
        {
#line 2057
        get_default_volpan___0(sigdata, channel);
        }
      }
    } else {
      {
#line 2059
      it_retrigger_note___0(sigrenderer, channel);
      }
    }
  }
#line 2063
  if ((int )entry->mask & 4) {
#line 2063
    if ((int )entry->volpan >= 193) {
#line 2063
      if ((int )entry->volpan <= 202) {
#line 2063
        goto _L___5;
      } else {
#line 2063
        goto _L___7;
      }
    } else {
#line 2063
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 2063
  if ((int )entry->mask & 8) {
#line 2063
    if ((int )entry->effect == 7) {
#line 2063
      goto _L___5;
    } else
#line 2063
    if ((int )entry->effect == 12) {
      _L___5: /* CIL Label */ 
#line 2066
      if (channel->playing) {
#line 2066
        if ((int )entry->mask & 2) {
#line 2067
          if (sigdata->flags & 32) {
            {
#line 2068
            it_compatible_gxx_retrigger___0(sigdata, channel);
            }
          } else
#line 2069
          if (! (sigdata->flags & 4)) {
#line 2069
            goto _L;
          } else
#line 2069
          if ((int )channel->instrument >= 1) {
#line 2069
            if ((int )channel->instrument <= sigdata->n_instruments) {
              _L: /* CIL Label */ 
#line 2069
              if ((int )channel->sample != (int )(channel->playing)->sampnum) {
                {
#line 2073
                note = (channel->playing)->note;
#line 2074
                slide = (channel->playing)->slide;
#line 2075
                it_retrigger_note___0(sigrenderer, channel);
                }
#line 2076
                if (channel->playing) {
#line 2077
                  (channel->playing)->note = note;
#line 2078
                  (channel->playing)->slide = slide;
                }
              }
            }
          }
        }
      }
#line 2084
      if ((int )entry->mask & 4) {
#line 2084
        if ((int )entry->volpan >= 193) {
#line 2084
          if ((int )entry->volpan <= 202) {
#line 2087
            v = (unsigned char )slidetable___0[(int )entry->volpan - 193];
#line 2088
            if (sigdata->flags & 32) {
#line 2089
              if ((int )v == 0) {
#line 2090
                v = channel->lastG;
              }
#line 2091
              channel->lastG = v;
            } else {
#line 2093
              if ((int )v == 0) {
#line 2094
                v = channel->lastEF;
              }
#line 2095
              channel->lastEF = v;
            }
#line 2097
            if ((int )entry->mask & 1) {
#line 2097
              goto _L___0;
            } else
#line 2097
            if (sigdata->flags & 32) {
#line 2097
              if ((int )entry->mask & 2) {
                _L___0: /* CIL Label */ 
#line 2098
                if (channel->sample) {
#line 2099
                  channel->destnote = channel->truenote;
                } else {
#line 2101
                  channel->destnote = channel->note;
                }
              }
            }
#line 2103
            channel->toneporta = (int )v << 4;
          } else {
#line 2084
            goto _L___3;
          }
        } else {
#line 2084
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 2107
        if ((int )entry->effect == 7) {
#line 2108
          v___0 = entry->effectvalue;
        } else {
#line 2110
          v___0 = (unsigned char)0;
        }
#line 2111
        if (sigdata->flags & 32) {
#line 2112
          if ((int )v___0 == 0) {
#line 2113
            v___0 = channel->lastG;
          }
#line 2114
          channel->lastG = v___0;
        } else {
#line 2116
          if ((int )v___0 == 0) {
#line 2117
            v___0 = channel->lastEF;
          }
#line 2118
          channel->lastEF = v___0;
        }
#line 2120
        if ((int )entry->mask & 1) {
#line 2120
          goto _L___1;
        } else
#line 2120
        if (sigdata->flags & 32) {
#line 2120
          if ((int )entry->mask & 2) {
            _L___1: /* CIL Label */ 
#line 2121
            if (channel->sample) {
#line 2122
              channel->destnote = channel->truenote;
            } else {
#line 2124
              channel->destnote = channel->note;
            }
          }
        }
#line 2126
        channel->toneporta = (int )v___0 << 4;
      }
#line 2128
      if (channel->playing) {
#line 2128
        goto skip_start_note;
      }
    }
  }
#line 2131
  if ((int )entry->mask & 1) {
#line 2131
    goto _L___9;
  } else
#line 2131
  if ((int )entry->mask & 2) {
#line 2131
    if (! channel->playing) {
#line 2131
      goto _L___9;
    } else
#line 2131
    if ((int )entry->instrument != (int )(channel->playing)->instnum) {
      _L___9: /* CIL Label */ 
#line 2134
      if ((int )channel->note < 120) {
        {
#line 2135
        get_true_pan___0(sigdata, channel);
#line 2136
        it_retrigger_note___0(sigrenderer, channel);
        }
      }
    }
  }
  skip_start_note: 
#line 2142
  if ((int )entry->mask & 4) {
#line 2143
    if ((int )entry->volpan <= 64) {
#line 2145
      channel->volume = entry->volpan;
    } else
#line 2146
    if ((int )entry->volpan <= 74) {
#line 2148
      v___1 = (unsigned char )((int )entry->volpan - 65);
#line 2149
      if ((int )v___1 == 0) {
#line 2150
        v___1 = (unsigned char )channel->lastvolslide;
      }
#line 2151
      channel->lastvolslide = (signed char )v___1;
#line 2153
      channel->volume = (unsigned char )((int )channel->volume + (int )v___1);
#line 2154
      if ((int )channel->volume > 64) {
#line 2154
        channel->volume = (unsigned char)64;
      }
    } else
#line 2155
    if ((int )entry->volpan <= 84) {
#line 2157
      v___2 = (unsigned char )((int )entry->volpan - 75);
#line 2158
      if ((int )v___2 == 0) {
#line 2159
        v___2 = (unsigned char )channel->lastvolslide;
      }
#line 2160
      channel->lastvolslide = (signed char )v___2;
#line 2162
      channel->volume = (unsigned char )((int )channel->volume - (int )v___2);
#line 2163
      if ((int )channel->volume > 64) {
#line 2163
        channel->volume = (unsigned char)0;
      }
    } else
#line 2164
    if (! ((int )entry->volpan < 128)) {
#line 2169
      if ((int )entry->volpan <= 192) {
#line 2171
        channel->pan = (unsigned char )((int )entry->volpan - 128);
#line 2172
        channel->truepan = (unsigned short )((int )channel->pan << 8);
      }
    }
  }
#line 2178
  return (0);
}
}
#line 2183 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void retrigger_xm_envelopes___0(IT_PLAYING *playing ) 
{ 


  {
#line 2185
  playing->volume_envelope.next_node = 0;
#line 2186
  playing->volume_envelope.tick = -1;
#line 2187
  playing->pan_envelope.next_node = 0;
#line 2188
  playing->pan_envelope.tick = -1;
#line 2189
  playing->fadeoutcount = 1024;
#line 2190
  return;
}
}
#line 2194 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void process_xm_note_data___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_CHANNEL *channel ;
  void *tmp ;
  unsigned char v ;
  unsigned char v___0 ;
  int effect ;
  int value ;

  {
#line 2196
  sigdata = sigrenderer->sigdata;
#line 2197
  channel = & sigrenderer->channel[(int )entry->channel];
#line 2199
  if ((int )entry->mask & 2) {
    {
#line 2200
    channel->instrument = entry->instrument;
#line 2201
    instrument_to_sample___0(sigdata, channel);
    }
#line 2202
    if (channel->playing) {
      {
#line 2206
      (channel->playing)->flags &= -7;
#line 2207
      it_playing_update_resamplers___0(channel->playing);
#line 2209
      channel->volume = ((channel->playing)->sample)->default_volume;
      }
#line 2210
      if (! (sigdata->flags & 128)) {
#line 2211
        channel->truepan = (unsigned short )(32 + (int )((channel->playing)->sample)->default_pan * 64);
      }
      {
#line 2213
      retrigger_xm_envelopes___0(channel->playing);
      }
    }
  }
#line 2217
  if ((int )entry->mask & 8) {
#line 2217
    if ((int )entry->effect == 32) {
#line 2217
      if (! ((int )entry->effectvalue == 0)) {
#line 2217
        goto _L___4;
      }
    } else {
#line 2217
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2217
  if ((int )entry->mask & 1) {
#line 2220
    if (! ((int )entry->mask & 2)) {
      {
#line 2221
      instrument_to_sample___0(sigdata, channel);
      }
    }
#line 2223
    if ((int )channel->note >= 120) {
      {
#line 2224
      xm_note_off___0(sigdata, channel);
      }
    } else
#line 2225
    if ((int )channel->sample == 0) {
#line 2235
      if (channel->playing) {
        {
#line 2236
        free((void *)channel->playing);
#line 2237
        channel->playing = (IT_PLAYING *)((void *)0);
        }
      }
#line 2239
      return;
    } else
#line 2240
    if (channel->playing) {
#line 2240
      if ((int )entry->mask & 4) {
#line 2240
        if (! ((int )entry->volpan >> 4 == 15)) {
#line 2240
          goto _L___2;
        }
      } else {
#line 2240
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2242
    if (channel->playing) {
#line 2242
      if ((int )entry->mask & 8) {
#line 2242
        if (! ((int )entry->effect == 7)) {
#line 2242
          if (! ((int )entry->effect == 12)) {
#line 2242
            goto _L___0;
          }
        }
      } else {
#line 2242
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2248
      channel->destnote = (unsigned char)255;
#line 2250
      if (! channel->playing) {
        {
#line 2251
        tmp = malloc(sizeof(*(channel->playing)));
#line 2251
        channel->playing = (IT_PLAYING *)tmp;
        }
#line 2252
        if (! channel->playing) {
#line 2253
          return;
        }
        {
#line 2255
        retrigger_xm_envelopes___0(channel->playing);
        }
      }
#line 2258
      (channel->playing)->flags = 0;
#line 2259
      (channel->playing)->channel = channel;
#line 2260
      (channel->playing)->sample = sigdata->sample + ((int )channel->sample - 1);
#line 2261
      if (sigdata->flags & 4) {
#line 2262
        (channel->playing)->instrument = sigdata->instrument + ((int )channel->instrument - 1);
      } else {
#line 2264
        (channel->playing)->instrument = (IT_INSTRUMENT *)((void *)0);
      }
      {
#line 2265
      (channel->playing)->env_instrument = (channel->playing)->instrument;
#line 2266
      (channel->playing)->sampnum = channel->sample;
#line 2267
      (channel->playing)->instnum = channel->instrument;
#line 2268
      (channel->playing)->channel_volume = channel->channelvolume;
#line 2269
      (channel->playing)->note = channel->truenote;
#line 2270
      (channel->playing)->filter_cutoff = (unsigned char)127;
#line 2271
      (channel->playing)->filter_resonance = (unsigned char)0;
#line 2272
      (channel->playing)->true_filter_cutoff = (unsigned short )(127 << 8);
#line 2273
      (channel->playing)->true_filter_resonance = (unsigned char)0;
#line 2274
      (channel->playing)->vibrato_speed = (unsigned char)0;
#line 2275
      (channel->playing)->vibrato_depth = (unsigned char)0;
#line 2276
      (channel->playing)->vibrato_n = (unsigned char)0;
#line 2277
      (channel->playing)->vibrato_time = (unsigned char)0;
#line 2278
      (channel->playing)->tremolo_speed = (unsigned char)0;
#line 2279
      (channel->playing)->tremolo_depth = (unsigned char)0;
#line 2280
      (channel->playing)->tremolo_time = (unsigned char)0;
#line 2281
      (channel->playing)->sample_vibrato_time = (unsigned char)0;
#line 2282
      (channel->playing)->sample_vibrato_depth = 0;
#line 2283
      (channel->playing)->slide = 0;
#line 2284
      it_reset_filter_state___0(& (channel->playing)->filter_state[0]);
#line 2285
      it_reset_filter_state___0(& (channel->playing)->filter_state[1]);
#line 2286
      it_playing_reset_resamplers___0(channel->playing, 0L);
      }
    }
  }
#line 2292
  if ((int )entry->mask & 8) {
#line 2292
    if ((int )entry->effect == 32) {
#line 2292
      if (! ((int )entry->effectvalue == 0)) {
#line 2292
        goto _L___6;
      }
    } else {
#line 2292
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2292
  if (((int )entry->mask & 3) == 3) {
#line 2295
    if (channel->playing) {
      {
#line 2295
      retrigger_xm_envelopes___0(channel->playing);
      }
    }
    {
#line 2296
    get_default_volpan___0(sigdata, channel);
    }
  }
#line 2299
  if ((int )entry->mask & 4) {
#line 2299
    if ((int )entry->volpan >> 4 == 15) {
#line 2301
      v = (unsigned char )(((int )entry->volpan & 15) << 4);
#line 2302
      if ((int )v == 0) {
#line 2303
        v = channel->lastG;
      }
#line 2304
      channel->lastG = v;
#line 2305
      if ((int )entry->mask & 1) {
#line 2306
        if (channel->sample) {
#line 2307
          channel->destnote = channel->truenote;
        }
      }
#line 2308
      channel->toneporta = (int )v << 4;
    } else {
#line 2299
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 2309
  if ((int )entry->mask & 8) {
#line 2309
    if ((int )entry->effect == 7) {
#line 2309
      goto _L___7;
    } else
#line 2309
    if ((int )entry->effect == 12) {
      _L___7: /* CIL Label */ 
#line 2313
      if ((int )entry->effect == 7) {
#line 2314
        v___0 = entry->effectvalue;
      } else {
#line 2316
        v___0 = (unsigned char)0;
      }
#line 2317
      if ((int )v___0 == 0) {
#line 2318
        v___0 = channel->lastG;
      }
#line 2319
      channel->lastG = v___0;
#line 2320
      if ((int )entry->mask & 1) {
#line 2321
        if (channel->sample) {
#line 2322
          channel->destnote = channel->truenote;
        }
      }
#line 2323
      channel->toneporta = (int )v___0 << 4;
    }
  }
#line 2326
  if ((int )entry->mask & 4) {
#line 2327
    effect = (int )entry->volpan >> 4;
#line 2328
    value = (int )entry->volpan & 15;
    {
#line 2330
    if (effect == 6) {
#line 2330
      goto case_6;
    }
#line 2333
    if (effect == 7) {
#line 2333
      goto case_7;
    }
#line 2336
    if (effect == 8) {
#line 2336
      goto case_8;
    }
#line 2340
    if (effect == 9) {
#line 2340
      goto case_9;
    }
#line 2344
    if (effect == 10) {
#line 2344
      goto case_10;
    }
#line 2350
    if (effect == 11) {
#line 2350
      goto case_11;
    }
#line 2359
    if (effect == 12) {
#line 2359
      goto case_12;
    }
#line 2362
    if (effect == 13) {
#line 2362
      goto case_13;
    }
#line 2368
    if (effect == 14) {
#line 2368
      goto case_14;
    }
#line 2371
    if (effect == 15) {
#line 2371
      goto case_15;
    }
#line 2373
    goto switch_default;
    case_6: /* CIL Label */ 
#line 2331
    channel->xm_volslide = (signed char )(- value);
#line 2332
    goto switch_break;
    case_7: /* CIL Label */ 
#line 2334
    channel->xm_volslide = (signed char )value;
#line 2335
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2337
    channel->volume = (unsigned char )((int )channel->volume - value);
#line 2338
    if ((int )channel->volume > 64) {
#line 2338
      channel->volume = (unsigned char)0;
    }
#line 2339
    goto switch_break;
    case_9: /* CIL Label */ 
#line 2341
    channel->volume = (unsigned char )((int )channel->volume + value);
#line 2342
    if ((int )channel->volume > 64) {
#line 2342
      channel->volume = (unsigned char)64;
    }
#line 2343
    goto switch_break;
    case_10: /* CIL Label */ 
#line 2345
    if (value) {
#line 2346
      channel->lastHspeed = (unsigned char )value;
    }
#line 2347
    if (channel->playing) {
#line 2348
      (channel->playing)->vibrato_speed = channel->lastHspeed;
    }
#line 2349
    goto switch_break;
    case_11: /* CIL Label */ 
#line 2351
    if (value) {
#line 2352
      channel->lastHdepth = (unsigned char )(value << 2);
    }
#line 2353
    if (channel->playing) {
#line 2354
      (channel->playing)->vibrato_depth = channel->lastHdepth;
#line 2355
      (channel->playing)->vibrato_speed = channel->lastHspeed;
#line 2356
      (channel->playing)->vibrato_n = (unsigned char )((int )(channel->playing)->vibrato_n + 1);
    }
#line 2358
    goto switch_break;
    case_12: /* CIL Label */ 
#line 2360
    channel->truepan = (unsigned short )(32 + value * 1088);
#line 2361
    goto switch_break;
    case_13: /* CIL Label */ 
#line 2366
    if (value) {
#line 2366
      channel->panslide = (signed char )(- value);
    } else {
#line 2366
      channel->panslide = (signed char)-128;
    }
#line 2367
    goto switch_break;
    case_14: /* CIL Label */ 
#line 2369
    channel->panslide = (signed char )value;
#line 2370
    goto switch_break;
    case_15: /* CIL Label */ 
#line 2372
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2374
    channel->volume = (unsigned char )((int )entry->volpan - 16);
#line 2375
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2378
  return;
}
}
#line 2383 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_note_data___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ,
                                 int ignore_cxx ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int tmp ;
  int tmp___0 ;

  {
#line 2385
  sigdata = sigrenderer->sigdata;
#line 2387
  if (sigdata->flags & 64) {
    {
#line 2388
    process_xm_note_data___0(sigrenderer, entry);
    }
  } else {
    {
#line 2390
    tmp = process_it_note_data___0(sigrenderer, entry);
    }
#line 2390
    if (tmp) {
#line 2390
      return (0);
    }
  }
  {
#line 2392
  tmp___0 = process_effects___0(sigrenderer, entry, ignore_cxx);
  }
#line 2392
  return (tmp___0);
}
}
#line 2397 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_entry___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_ENTRY *entry ,
                             int ignore_cxx ) 
{ 
  IT_CHANNEL *channel ;
  unsigned char effectvalue ;
  int tmp ;

  {
#line 2399
  channel = & sigrenderer->channel[(int )entry->channel];
#line 2401
  if ((int )entry->mask & 1) {
#line 2402
    channel->note = entry->note;
  }
#line 2404
  if ((int )entry->mask & 8) {
#line 2404
    if ((int )entry->effect == 19) {
#line 2406
      effectvalue = channel->lastS;
#line 2407
      if ((int )effectvalue >> 4 == 13) {
#line 2408
        channel->note_delay_count = (unsigned char )((int )effectvalue & 15);
#line 2409
        if ((int )channel->note_delay_count == 0) {
#line 2410
          channel->note_delay_count = (unsigned char)1;
        }
#line 2411
        channel->note_delay_entry = entry;
#line 2412
        return (0);
      }
    }
  }
  {
#line 2416
  tmp = process_note_data___0(sigrenderer, entry, ignore_cxx);
  }
#line 2416
  return (tmp);
}
}
#line 2421 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_tick_counts___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  int i ;
  IT_CHANNEL *channel ;

  {
#line 2425
  i = 0;
  {
#line 2425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2425
    if (! (i < 64)) {
#line 2425
      goto while_break;
    }
#line 2426
    channel = & sigrenderer->channel[i];
#line 2428
    if (channel->key_off_count) {
#line 2429
      channel->key_off_count = (unsigned char )((int )channel->key_off_count - 1);
#line 2430
      if ((int )channel->key_off_count == 0) {
        {
#line 2431
        xm_note_off___0(sigrenderer->sigdata, channel);
        }
      }
    } else
#line 2432
    if (channel->note_cut_count) {
#line 2433
      channel->note_cut_count = (unsigned char )((int )channel->note_cut_count - 1);
#line 2434
      if ((int )channel->note_cut_count == 0) {
#line 2435
        if ((sigrenderer->sigdata)->flags & 64) {
#line 2436
          channel->volume = (unsigned char)0;
        } else
#line 2437
        if (channel->playing) {
          {
#line 2438
          free((void *)channel->playing);
#line 2439
          channel->playing = (IT_PLAYING *)((void *)0);
          }
        }
      }
    } else
#line 2442
    if (channel->note_delay_count) {
#line 2443
      channel->note_delay_count = (unsigned char )((int )channel->note_delay_count - 1);
#line 2444
      if ((int )channel->note_delay_count == 0) {
        {
#line 2445
        process_note_data___0(sigrenderer, channel->note_delay_entry, 0);
        }
      }
    }
#line 2425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2451
  return;
}
}
#line 2455 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int envelope_get_y___0(IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 


  {
#line 2459
  return (pe->value);
}
}
#line 2514 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int update_it_envelope___0(IT_PLAYING *playing , IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 
  int ys ;
  int ts ;
  int te ;
  int ye ;
  int t ;

  {
#line 2516
  if (! ((int )envelope->flags & 1)) {
#line 2517
    return (0);
  }
#line 2521
  if (pe->next_node <= 0) {
#line 2522
    pe->value = (int )envelope->node_y[0] << 8;
  } else
#line 2523
  if (pe->next_node >= (int )envelope->n_nodes) {
#line 2524
    pe->value = (int )envelope->node_y[(int )envelope->n_nodes - 1] << 8;
#line 2525
    return (1);
  } else {
#line 2527
    ys = (int )envelope->node_y[pe->next_node - 1] << 8;
#line 2528
    ts = (int )envelope->node_t[pe->next_node - 1];
#line 2529
    te = (int )envelope->node_t[pe->next_node];
#line 2531
    if (ts == te) {
#line 2532
      pe->value = ys;
    } else {
#line 2534
      ye = (int )envelope->node_y[pe->next_node] << 8;
#line 2535
      t = pe->tick;
#line 2537
      pe->value = ys + ((ye - ys) * (t - ts)) / (te - ts);
    }
  }
#line 2541
  (pe->tick) ++;
  {
#line 2542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2542
    if (! (pe->tick >= (int )envelope->node_t[pe->next_node])) {
#line 2542
      goto while_break;
    }
#line 2543
    (pe->next_node) ++;
#line 2544
    if ((int )envelope->flags & 4) {
#line 2544
      if (! (playing->flags & 2)) {
#line 2545
        if (pe->next_node > (int )envelope->sus_loop_end) {
#line 2546
          pe->next_node = (int )envelope->sus_loop_start;
#line 2548
          pe->tick = (int )envelope->node_t[envelope->sus_loop_start];
#line 2549
          return (0);
        }
      } else {
#line 2544
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2551
    if ((int )envelope->flags & 2) {
#line 2552
      if (pe->next_node > (int )envelope->loop_end) {
#line 2553
        pe->next_node = (int )envelope->loop_start;
#line 2555
        pe->tick = (int )envelope->node_t[envelope->loop_start];
#line 2556
        return (0);
      }
    }
#line 2559
    if (pe->next_node >= (int )envelope->n_nodes) {
#line 2560
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2562
  return (0);
}
}
#line 2567 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_it_envelopes___0(IT_PLAYING *playing ) 
{ 
  IT_ENVELOPE *envelope ;
  IT_PLAYING_ENVELOPE *pe ;
  int tmp ;

  {
  {
#line 2569
  envelope = & (playing->env_instrument)->volume_envelope;
#line 2570
  pe = & playing->volume_envelope;
#line 2572
  tmp = update_it_envelope___0(playing, envelope, pe);
  }
#line 2572
  if (tmp) {
#line 2573
    playing->flags |= 4;
#line 2574
    if (pe->value == 0) {
#line 2575
      playing->flags |= 8;
    }
  }
  {
#line 2578
  update_it_envelope___0(playing, & (playing->env_instrument)->pan_envelope, & playing->pan_envelope);
#line 2579
  update_it_envelope___0(playing, & (playing->env_instrument)->pitch_envelope, & playing->pitch_envelope);
  }
#line 2580
  return;
}
}
#line 2584 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int xm_envelope_is_sustaining___0(IT_PLAYING *playing , IT_ENVELOPE *envelope ,
                                         IT_PLAYING_ENVELOPE *pe ) 
{ 


  {
#line 2586
  if ((int )envelope->flags & 4) {
#line 2586
    if (! (playing->flags & 2)) {
#line 2587
      if ((int )envelope->sus_loop_start < (int )envelope->n_nodes) {
#line 2588
        if (pe->tick == (int )envelope->node_t[envelope->sus_loop_start]) {
#line 2589
          return (1);
        }
      }
    }
  }
#line 2590
  return (0);
}
}
#line 2595 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_xm_envelope___0(IT_PLAYING *playing , IT_ENVELOPE *envelope , IT_PLAYING_ENVELOPE *pe ) 
{ 
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2597
  if (! ((int )envelope->flags & 1)) {
#line 2598
    return;
  }
  {
#line 2600
  tmp = xm_envelope_is_sustaining___0(playing, envelope, pe);
  }
#line 2600
  if (tmp) {
#line 2601
    return;
  }
#line 2603
  if (pe->tick >= (int )envelope->node_t[(int )envelope->n_nodes - 1]) {
#line 2604
    return;
  }
#line 2606
  (pe->tick) ++;
  {
#line 2609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2609
    if (! (pe->tick > (int )envelope->node_t[pe->next_node])) {
#line 2609
      goto while_break;
    }
#line 2610
    (pe->next_node) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2612
  if ((int )envelope->flags & 2) {
#line 2612
    if ((int )envelope->loop_end < (int )envelope->n_nodes) {
#line 2613
      if (pe->tick == (int )envelope->node_t[envelope->loop_end]) {
#line 2614
        if ((int )envelope->loop_start < (int )envelope->n_nodes - 1) {
#line 2614
          tmp___2 = (int )envelope->loop_start;
        } else {
#line 2614
          tmp___2 = (int )envelope->n_nodes - 1;
        }
#line 2614
        if (0 > tmp___2) {
#line 2614
          pe->next_node = 0;
        } else {
#line 2614
          if ((int )envelope->loop_start < (int )envelope->n_nodes - 1) {
#line 2614
            tmp___1 = (int )envelope->loop_start;
          } else {
#line 2614
            tmp___1 = (int )envelope->n_nodes - 1;
          }
#line 2614
          pe->next_node = tmp___1;
        }
#line 2615
        pe->tick = (int )envelope->node_t[pe->next_node];
      }
    }
  }
  {
#line 2619
  xm_envelope_calculate_value___0(envelope, pe);
  }
#line 2620
  return;
}
}
#line 2624 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_xm_envelopes___0(IT_PLAYING *playing ) 
{ 


  {
  {
#line 2626
  update_xm_envelope___0(playing, & (playing->env_instrument)->volume_envelope, & playing->volume_envelope);
#line 2627
  update_xm_envelope___0(playing, & (playing->env_instrument)->pan_envelope, & playing->pan_envelope);
  }
#line 2628
  return;
}
}
#line 2632 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void update_fadeout___0(DUMB_IT_SIGDATA *sigdata , IT_PLAYING *playing ) 
{ 


  {
#line 2634
  if (playing->flags & 4) {
#line 2635
    playing->fadeoutcount -= (playing->env_instrument)->fadeout;
#line 2636
    if (playing->fadeoutcount <= 0) {
#line 2637
      playing->fadeoutcount = 0;
#line 2638
      if (! (sigdata->flags & 64)) {
#line 2639
        playing->flags |= 8;
      }
    }
  }
#line 2642
  return;
}
}
#line 2646 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void process_playing___0(DUMB_IT_SIGDATA *sigdata , IT_PLAYING *playing ) 
{ 


  {
#line 2648
  if (playing->instrument) {
#line 2649
    if (sigdata->flags & 64) {
      {
#line 2650
      update_xm_envelopes___0(playing);
      }
    } else {
      {
#line 2652
      update_it_envelopes___0(playing);
      }
    }
    {
#line 2653
    update_fadeout___0(sigdata, playing);
    }
  }
#line 2659
  if (sigdata->flags & 64) {
#line 2661
    if (playing->sample_vibrato_depth < (int )(playing->sample)->vibrato_rate) {
#line 2662
      (playing->sample_vibrato_depth) ++;
    }
  } else {
#line 2664
    playing->sample_vibrato_depth += (int )(playing->sample)->vibrato_rate;
#line 2665
    if (playing->sample_vibrato_depth > (int )(playing->sample)->vibrato_depth << 8) {
#line 2666
      playing->sample_vibrato_depth = (int )(playing->sample)->vibrato_depth << 8;
    }
  }
#line 2669
  playing->sample_vibrato_time = (unsigned char )((int )playing->sample_vibrato_time + (int )(playing->sample)->vibrato_speed);
#line 2670
  return;
}
}
#line 2674 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void process_all_playing___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int i ;
  IT_CHANNEL *channel ;
  IT_PLAYING *playing ;
  int vibrato_shift ;
  int currpitch ;
  double tmp ;
  int slide ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 2676
  sigdata = sigrenderer->sigdata;
#line 2679
  i = 0;
  {
#line 2679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2679
    if (! (i < 64)) {
#line 2679
      goto while_break;
    }
#line 2680
    channel = & sigrenderer->channel[i];
#line 2681
    playing = channel->playing;
#line 2683
    if (playing) {
#line 2684
      vibrato_shift = (int )it_sine___0[playing->vibrato_time];
#line 2685
      vibrato_shift *= (int )playing->vibrato_n;
#line 2686
      vibrato_shift *= (int )playing->vibrato_depth;
#line 2687
      vibrato_shift >>= 4;
#line 2689
      if (sigdata->flags & 16) {
#line 2690
        vibrato_shift = - vibrato_shift;
      }
#line 2692
      playing->volume = channel->volume;
#line 2693
      playing->pan = channel->truepan;
#line 2695
      if (sigdata->flags & 8) {
#line 2696
        currpitch = ((((int )playing->note - 60) << 8) + playing->slide) + vibrato_shift;
#line 2703
        if (currpitch < -32768) {
#line 2704
          currpitch = -32768;
        } else
#line 2705
        if (currpitch > 32767) {
#line 2706
          currpitch = 32767;
        }
        {
#line 2708
        tmp = pow(1.000225659305069791926712241547647863626, (double )currpitch);
#line 2708
        playing->delta = (float )tmp;
#line 2709
        playing->delta *= (float )(playing->sample)->C5_speed / 65536.0f;
        }
      } else {
        {
#line 2711
        slide = playing->slide + vibrato_shift;
#line 2713
        tmp___0 = pow(1.059463094359295309843105314939748495817, (double )(60 - (int )playing->note));
#line 2713
        playing->delta = (float )tmp___0;
#line 2716
        playing->delta *= 1.0f / (float )(playing->sample)->C5_speed;
#line 2718
        playing->delta -= (float )slide / (float )(8.0 * 7159090.5);
        }
#line 2720
        if (playing->delta < (1.0f / 65536.0f) / 32768.0f) {
#line 2722
          playing->flags |= 8;
#line 2723
          goto __Cont;
        }
#line 2726
        playing->delta = (1.0f / 65536.0f) / playing->delta;
      }
      {
#line 2729
      tmp___1 = pow(1.059463094359295309843105314939748495817, (double )(channel->arpeggio >> 8));
#line 2729
      playing->delta *= (float )tmp___1;
#line 2731
      playing->filter_cutoff = channel->filter_cutoff;
#line 2732
      playing->filter_resonance = channel->filter_resonance;
      }
    }
    __Cont: /* CIL Label */ 
#line 2679
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2736
  i = 0;
  {
#line 2736
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2736
    if (! (i < 64)) {
#line 2736
      goto while_break___0;
    }
#line 2737
    if (sigrenderer->channel[i].playing) {
      {
#line 2738
      process_playing___0(sigdata, sigrenderer->channel[i].playing);
      }
#line 2739
      if (! (sigdata->flags & 64)) {
#line 2742
        if ((sigrenderer->channel[i].playing)->flags & 8) {
          {
#line 2743
          free((void *)sigrenderer->channel[i].playing);
#line 2744
          sigrenderer->channel[i].playing = (IT_PLAYING *)((void *)0);
          }
        }
      }
    }
#line 2736
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2750
  i = 0;
  {
#line 2750
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2750
    if (! (i < 192)) {
#line 2750
      goto while_break___1;
    }
#line 2751
    if (sigrenderer->playing[i]) {
      {
#line 2752
      process_playing___0(sigdata, sigrenderer->playing[i]);
      }
#line 2753
      if ((sigrenderer->playing[i])->flags & 8) {
        {
#line 2754
        free((void *)sigrenderer->playing[i]);
#line 2755
        sigrenderer->playing[i] = (IT_PLAYING *)((void *)0);
        }
      }
    }
#line 2750
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2759
  return;
}
}
#line 2763 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int process_tick___0(DUMB_IT_SIGRENDERER *sigrenderer ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  IT_PATTERN *pattern ;
  int n ;
  int processorder ;
  IT_ENTRY *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  IT_ENTRY *entry ;
  int ignore_cxx ;
  IT_ENTRY *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  IT_ENTRY *tmp___5 ;
  int tmp___6 ;
  IT_ENTRY *entry___0 ;
  IT_ENTRY *tmp___7 ;
  long long t ;

  {
#line 2765
  sigdata = sigrenderer->sigdata;
#line 2769
  if (sigrenderer->speed) {
#line 2769
    (sigrenderer->tick) --;
#line 2769
    if (sigrenderer->tick == 0) {
      {
#line 2770
      reset_tick_counts___0(sigrenderer);
#line 2771
      sigrenderer->tick = sigrenderer->speed;
#line 2772
      (sigrenderer->rowcount) --;
      }
#line 2773
      if (sigrenderer->rowcount == 0) {
#line 2774
        sigrenderer->rowcount = 1;
#line 2776
        (sigrenderer->processrow) ++;
#line 2778
        if (sigrenderer->processrow >= sigrenderer->n_rows) {
#line 2781
          processorder = sigrenderer->processorder;
#line 2783
          if (sigrenderer->processrow == 65535) {
#line 2784
            sigrenderer->processrow = sigrenderer->breakrow;
#line 2785
            sigrenderer->breakrow = 0;
#line 2786
            n = 0;
            {
#line 2786
            while (1) {
              while_continue: /* CIL Label */ ;
#line 2786
              if (! (n < 64)) {
#line 2786
                goto while_break;
              }
#line 2786
              sigrenderer->channel[n].pat_loop_end_row = (unsigned char)0;
#line 2786
              n ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 2788
            sigrenderer->processrow = sigrenderer->breakrow;
          }
#line 2790
          if (sigrenderer->processorder == 65535) {
#line 2791
            sigrenderer->processorder = sigrenderer->order - 1;
          }
          {
#line 2793
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2794
            (sigrenderer->processorder) ++;
#line 2796
            if (sigrenderer->processorder >= sigdata->n_orders) {
#line 2797
              sigrenderer->processorder = (int )sigdata->restart_position;
#line 2798
              if (sigrenderer->processorder >= sigdata->n_orders) {
#line 2800
                sigrenderer->processorder = -1;
#line 2801
                goto __Cont;
              }
            }
#line 2805
            n = (int )*(sigdata->order + sigrenderer->processorder);
#line 2807
            if (n < sigdata->n_patterns) {
#line 2808
              goto while_break___0;
            }
#line 2811
            if (n != 254) {
#line 2812
              sigrenderer->processorder = -1;
            }
            __Cont: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2819
          pattern = sigdata->pattern + n;
#line 2821
          n = sigrenderer->n_rows;
#line 2822
          sigrenderer->n_rows = pattern->n_rows;
#line 2824
          if (sigrenderer->processrow >= sigrenderer->n_rows) {
#line 2825
            sigrenderer->processrow = 0;
          }
#line 2829
          tmp = pattern->entry;
#line 2829
          sigrenderer->entry_start = tmp;
#line 2829
          sigrenderer->entry = tmp;
#line 2830
          sigrenderer->entry_end = sigrenderer->entry + pattern->n_entries;
#line 2833
          if (n) {
#line 2833
            if (processorder == 65535) {
#line 2833
              tmp___1 = sigrenderer->order > sigrenderer->processorder;
            } else {
#line 2833
              tmp___1 = sigrenderer->order >= sigrenderer->processorder;
            }
#line 2833
            if (tmp___1) {
#line 2834
              if ((sigrenderer->callbacks)->loop) {
                {
#line 2835
                tmp___0 = (*((sigrenderer->callbacks)->loop))((sigrenderer->callbacks)->loop_data);
                }
#line 2835
                if (tmp___0) {
#line 2836
                  return (1);
                }
#line 2837
                if (sigrenderer->speed == 0) {
#line 2838
                  goto speed0;
                }
              }
            }
          }
#line 2841
          sigrenderer->order = sigrenderer->processorder;
#line 2843
          n = sigrenderer->processrow;
          {
#line 2844
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2844
            if (! n) {
#line 2844
              goto while_break___1;
            }
            {
#line 2845
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2845
              if (! ((unsigned long )sigrenderer->entry < (unsigned long )sigrenderer->entry_end)) {
#line 2845
                goto while_break___2;
              }
#line 2846
              if ((int )(sigrenderer->entry)->channel >= 64) {
#line 2847
                (sigrenderer->entry) ++;
#line 2848
                goto while_break___2;
              }
#line 2850
              (sigrenderer->entry) ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2852
            n --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2854
          sigrenderer->row = sigrenderer->processrow;
        } else
#line 2856
        if (sigrenderer->entry) {
          {
#line 2857
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2857
            if (! ((unsigned long )sigrenderer->entry < (unsigned long )sigrenderer->entry_end)) {
#line 2857
              goto while_break___3;
            }
#line 2858
            if ((int )(sigrenderer->entry)->channel >= 64) {
#line 2859
              (sigrenderer->entry) ++;
#line 2860
              goto while_break___3;
            }
#line 2862
            (sigrenderer->entry) ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2864
          (sigrenderer->row) ++;
        } else {
#line 2866
          sigrenderer->entry = sigrenderer->entry_start;
#line 2867
          sigrenderer->row = 0;
        }
        {
#line 2871
        reset_effects___0(sigrenderer);
#line 2874
        entry = sigrenderer->entry;
#line 2875
        ignore_cxx = 0;
        }
        {
#line 2877
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2877
          if ((unsigned long )entry < (unsigned long )sigrenderer->entry_end) {
#line 2877
            if (! (! ((int )entry->channel >= 64))) {
#line 2877
              goto while_break___4;
            }
          } else {
#line 2877
            goto while_break___4;
          }
          {
#line 2878
          tmp___2 = entry;
#line 2878
          entry ++;
#line 2878
          tmp___3 = update_pattern_variables___0(sigrenderer, tmp___2);
#line 2878
          ignore_cxx |= tmp___3;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2880
        entry = sigrenderer->entry;
        {
#line 2882
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2882
          if ((unsigned long )entry < (unsigned long )sigrenderer->entry_end) {
#line 2882
            if (! (! ((int )entry->channel >= 64))) {
#line 2882
              goto while_break___5;
            }
          } else {
#line 2882
            goto while_break___5;
          }
#line 2883
          if (sigdata->flags & 64) {
#line 2883
            tmp___4 = 0;
          } else {
#line 2883
            tmp___4 = ignore_cxx;
          }
          {
#line 2883
          tmp___5 = entry;
#line 2883
          entry ++;
#line 2883
          tmp___6 = process_entry___0(sigrenderer, tmp___5, tmp___4);
          }
#line 2883
          if (tmp___6) {
#line 2884
            return (1);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2887
        if (! (sigdata->flags & 16)) {
          {
#line 2888
          update_smooth_effects___0(sigrenderer);
          }
        }
      } else {
#line 2891
        entry___0 = sigrenderer->entry;
        {
#line 2893
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2893
          if ((unsigned long )entry___0 < (unsigned long )sigrenderer->entry_end) {
#line 2893
            if (! (! ((int )entry___0->channel >= 64))) {
#line 2893
              goto while_break___6;
            }
          } else {
#line 2893
            goto while_break___6;
          }
          {
#line 2894
          tmp___7 = entry___0;
#line 2894
          entry___0 ++;
#line 2894
          process_effects___0(sigrenderer, tmp___7, 0);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 2900
        update_effects___0(sigrenderer);
        }
      }
    } else {
#line 2769
      goto speed0;
    }
  } else {
    speed0: 
    {
#line 2904
    update_effects___0(sigrenderer);
#line 2905
    update_tick_counts___0(sigrenderer);
    }
  }
  {
#line 2908
  process_all_playing___0(sigrenderer);
#line 2911
  t = (long long )sigrenderer->sub_time_left + (163840LL << 16) / (long long )sigrenderer->tempo;
#line 2912
  sigrenderer->time_left += (long )((int )(t >> 16));
#line 2913
  sigrenderer->sub_time_left = (int )t & 65535;
  }
#line 2916
  return (0);
}
}
#line 2925 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static float calculate_volume___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_PLAYING *playing ,
                                  float volume ) 
{ 
  int vol ;
  int tmp ;

  {
#line 2927
  if (volume != (float )0) {
#line 2930
    if ((playing->channel)->flags & 1) {
#line 2931
      return ((float )0);
    }
#line 2933
    if (((int )(playing->channel)->tremor_time & 192) == 128) {
#line 2934
      return ((float )0);
    }
#line 2936
    vol = (int )it_sine___0[playing->tremolo_time];
#line 2937
    vol *= (int )playing->tremolo_depth;
#line 2939
    vol = ((int )playing->volume << 5) + vol;
#line 2941
    if (vol <= 0) {
#line 2942
      return ((float )0);
    }
#line 2944
    if (vol > 64 << 5) {
#line 2945
      vol = 64 << 5;
    }
#line 2947
    volume *= (float )vol;
#line 2948
    volume *= (float )(playing->sample)->global_volume;
#line 2949
    volume *= (float )playing->channel_volume;
#line 2950
    volume *= (float )sigrenderer->globalvolume;
#line 2951
    volume *= (float )(sigrenderer->sigdata)->mixing_volume;
#line 2952
    volume *= 1.0f / (((((float )(64 << 5) * 64.0f) * 64.0f) * 128.0f) * 128.0f);
#line 2954
    if (volume) {
#line 2954
      if (playing->instrument) {
#line 2955
        if ((int )(playing->env_instrument)->volume_envelope.flags & 1) {
          {
#line 2956
          tmp = envelope_get_y___0(& (playing->env_instrument)->volume_envelope, & playing->volume_envelope);
#line 2956
          volume *= (float )tmp;
#line 2957
          volume *= 1.0f / (float )(64 << 8);
          }
        }
#line 2959
        volume *= (float )(playing->instrument)->global_volume;
#line 2960
        volume *= (float )playing->fadeoutcount;
#line 2961
        volume *= 1.0f / (128.0f * 1024.0f);
      }
    }
  }
#line 2965
  return (volume);
}
}
#line 2970 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int apply_pan_envelope___0(IT_PLAYING *playing ) 
{ 
  int pan ;
  int p ;
  int tmp ;

  {
#line 2972
  pan = (int )playing->pan;
#line 2973
  if (pan <= 64 << 8) {
#line 2973
    if (playing->env_instrument) {
#line 2973
      if ((int )(playing->env_instrument)->pan_envelope.flags & 1) {
        {
#line 2974
        tmp = envelope_get_y___0(& (playing->env_instrument)->pan_envelope, & playing->pan_envelope);
#line 2974
        p = tmp;
        }
#line 2975
        if (pan > 32 << 8) {
#line 2976
          p *= (64 << 8) - pan;
        } else {
#line 2978
          p *= pan;
        }
#line 2979
        pan += p >> 13;
      }
    }
  }
#line 2981
  return (pan);
}
}
#line 2989 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static long render_playing___0(DUMB_IT_SIGRENDERER *sigrenderer , IT_PLAYING *playing ,
                               float volume , float delta , long pos , long size ,
                               sample_t **samples , int store_end_sample , int *left_to_mix ) 
{ 
  int bits ;
  int pan ;
  float span ;
  long size_rendered ;
  float lvol ;
  float rvol ;
  sample_t click[2] ;
  sample_t click___0[2] ;
  sample_t click___1[2] ;
  sample_t click___2[2] ;
  sample_t click___3[2] ;
  sample_t click___4[2] ;
  float lvol___0 ;
  float rvol___0 ;
  sample_t click___5 ;
  sample_t click___6 ;
  sample_t click___7 ;
  sample_t click___8 ;

  {
#line 2998
  if (playing->flags & 8) {
#line 2999
    return (0L);
  }
#line 3001
  if (*left_to_mix <= 0) {
#line 3002
    volume = (float )0;
  }
#line 3004
  if ((int )(playing->sample)->flags & 2) {
#line 3004
    bits = 16;
  } else {
#line 3004
    bits = 8;
  }
  {
#line 3006
  pan = apply_pan_envelope___0(playing);
#line 3007
  span = (float )((pan - (32 << 8)) * (sigrenderer->sigdata)->pan_separation) * (1.0f / (float )((32 << 8) * 128));
  }
#line 3009
  if (volume == (float )0) {
#line 3010
    if ((int )(playing->sample)->flags & 4) {
      {
#line 3011
      size_rendered = dumb_resample_n_2_1(bits, & playing->resampler, (sample_t *)((void *)0),
                                          size, (float )0, (float )0, delta);
      }
    } else {
      {
#line 3013
      size_rendered = dumb_resample_n_1_1(bits, & playing->resampler, (sample_t *)((void *)0),
                                          size, (float )0, delta);
      }
    }
  } else {
#line 3015
    if (sigrenderer->n_channels == 2) {
#line 3017
      lvol = volume;
#line 3018
      if (! (pan > 64 << 8)) {
#line 3018
        lvol *= 1.0f - span;
      }
#line 3019
      rvol = - lvol;
#line 3020
      if (! (pan > 64 << 8)) {
#line 3020
        rvol += 2.0f * volume;
      }
#line 3021
      if ((int )(playing->sample)->flags & 4) {
#line 3022
        if (sigrenderer->click_remover) {
          {
#line 3024
          dumb_resample_get_current_sample_n_2_2(bits, & playing->resampler, lvol,
                                                 rvol, click);
#line 3025
          dumb_record_click(*(sigrenderer->click_remover + 0), pos, click[0]);
#line 3026
          dumb_record_click(*(sigrenderer->click_remover + 1), pos, click[1]);
          }
        }
        {
#line 3028
        size_rendered = dumb_resample_n_2_2(bits, & playing->resampler, *(samples + 0) + pos * 2L,
                                            size, lvol, rvol, delta);
        }
#line 3029
        if (store_end_sample) {
          {
#line 3031
          dumb_resample_get_current_sample_n_2_2(bits, & playing->resampler, lvol,
                                                 rvol, click___0);
#line 3032
          *(*(samples + 0) + (pos + size_rendered) * 2L) = click___0[0];
#line 3033
          *(*(samples + 0) + ((pos + size_rendered) * 2L + 1L)) = click___0[1];
          }
        }
#line 3035
        if (sigrenderer->click_remover) {
          {
#line 3037
          dumb_resample_get_current_sample_n_2_2(bits, & playing->resampler, lvol,
                                                 rvol, click___1);
#line 3038
          dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                            - click___1[0]);
#line 3039
          dumb_record_click(*(sigrenderer->click_remover + 1), pos + size_rendered,
                            - click___1[1]);
          }
        }
      } else {
#line 3042
        if (sigrenderer->click_remover) {
          {
#line 3044
          dumb_resample_get_current_sample_n_1_2(bits, & playing->resampler, lvol,
                                                 rvol, click___2);
#line 3045
          dumb_record_click(*(sigrenderer->click_remover + 0), pos, click___2[0]);
#line 3046
          dumb_record_click(*(sigrenderer->click_remover + 1), pos, click___2[1]);
          }
        }
        {
#line 3048
        size_rendered = dumb_resample_n_1_2(bits, & playing->resampler, *(samples + 0) + pos * 2L,
                                            size, lvol, rvol, delta);
        }
#line 3049
        if (store_end_sample) {
          {
#line 3051
          dumb_resample_get_current_sample_n_1_2(bits, & playing->resampler, lvol,
                                                 rvol, click___3);
#line 3052
          *(*(samples + 0) + (pos + size_rendered) * 2L) = click___3[0];
#line 3053
          *(*(samples + 0) + ((pos + size_rendered) * 2L + 1L)) = click___3[1];
          }
        }
#line 3055
        if (sigrenderer->click_remover) {
          {
#line 3057
          dumb_resample_get_current_sample_n_1_2(bits, & playing->resampler, lvol,
                                                 rvol, click___4);
#line 3058
          dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                            - click___4[0]);
#line 3059
          dumb_record_click(*(sigrenderer->click_remover + 1), pos + size_rendered,
                            - click___4[1]);
          }
        }
      }
    } else
#line 3063
    if ((int )(playing->sample)->flags & 4) {
#line 3065
      lvol___0 = 0.5f * volume;
#line 3066
      if (! (pan > 64 << 8)) {
#line 3066
        lvol___0 *= 1.0f - span;
      }
#line 3067
      rvol___0 = lvol___0;
#line 3068
      if (! (pan > 64 << 8)) {
#line 3068
        rvol___0 = volume - rvol___0;
      }
#line 3069
      if (sigrenderer->click_remover) {
        {
#line 3071
        dumb_resample_get_current_sample_n_2_1(bits, & playing->resampler, lvol___0,
                                               rvol___0, & click___5);
#line 3072
        dumb_record_click(*(sigrenderer->click_remover + 0), pos, click___5);
        }
      }
      {
#line 3074
      size_rendered = dumb_resample_n_2_1(bits, & playing->resampler, *(samples + 0) + pos,
                                          size, lvol___0, rvol___0, delta);
      }
#line 3075
      if (store_end_sample) {
        {
#line 3076
        dumb_resample_get_current_sample_n_2_1(bits, & playing->resampler, lvol___0,
                                               rvol___0, *(samples + 0) + (pos + size_rendered));
        }
      }
#line 3077
      if (sigrenderer->click_remover) {
        {
#line 3079
        dumb_resample_get_current_sample_n_2_1(bits, & playing->resampler, lvol___0,
                                               rvol___0, & click___6);
#line 3080
        dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                          - click___6);
        }
      }
    } else {
#line 3083
      if (sigrenderer->click_remover) {
        {
#line 3085
        dumb_resample_get_current_sample_n_1_1(bits, & playing->resampler, volume,
                                               & click___7);
#line 3086
        dumb_record_click(*(sigrenderer->click_remover + 0), pos, click___7);
        }
      }
      {
#line 3088
      size_rendered = dumb_resample_n_1_1(bits, & playing->resampler, *(samples + 0) + pos,
                                          size, volume, delta);
      }
#line 3089
      if (store_end_sample) {
        {
#line 3090
        dumb_resample_get_current_sample_n_1_1(bits, & playing->resampler, volume,
                                               *(samples + 0) + (pos + size_rendered));
        }
      }
#line 3091
      if (sigrenderer->click_remover) {
        {
#line 3093
        dumb_resample_get_current_sample_n_1_1(bits, & playing->resampler, volume,
                                               & click___8);
#line 3094
        dumb_record_click(*(sigrenderer->click_remover + 0), pos + size_rendered,
                          - click___8);
        }
      }
    }
#line 3098
    (*left_to_mix) --;
  }
#line 3101
  if (playing->resampler.dir == 0) {
#line 3102
    playing->flags |= 8;
  }
#line 3104
  return (size_rendered);
}
}
#line 3118 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static int it_to_mix_compare___0(void const   *e1 , void const   *e2 ) 
{ 


  {
#line 3120
  if (((IT_TO_MIX const   *)e1)->volume > ((IT_TO_MIX const   *)e2)->volume) {
#line 3121
    return (-1);
  }
#line 3123
  if (((IT_TO_MIX const   *)e1)->volume < ((IT_TO_MIX const   *)e2)->volume) {
#line 3124
    return (1);
  }
#line 3126
  return (0);
}
}
#line 3131 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void apply_pitch_modifications___0(DUMB_IT_SIGDATA *sigdata , IT_PLAYING *playing ,
                                          float *delta , int *cutoff ) 
{ 
  int sample_vibrato_shift ;
  int depth ;
  double tmp ;
  int p ;
  int tmp___0 ;
  double tmp___1 ;

  {
#line 3134
  sample_vibrato_shift = (int )it_sine___0[playing->sample_vibrato_time];
#line 3136
  if (sigdata->flags & 64) {
#line 3137
    depth = (int )(playing->sample)->vibrato_depth;
#line 3138
    if ((playing->sample)->vibrato_rate) {
#line 3139
      depth *= playing->sample_vibrato_depth;
#line 3140
      depth /= (int )(playing->sample)->vibrato_rate;
    }
#line 3142
    sample_vibrato_shift *= depth;
  } else {
#line 3144
    sample_vibrato_shift *= playing->sample_vibrato_depth >> 8;
  }
  {
#line 3146
  sample_vibrato_shift >>= 4;
#line 3148
  tmp = pow(1.000225659305069791926712241547647863626, (double )sample_vibrato_shift);
#line 3148
  *delta *= (float )tmp;
  }
#line 3151
  if (playing->env_instrument) {
#line 3151
    if ((int )(playing->env_instrument)->pitch_envelope.flags & 1) {
      {
#line 3154
      tmp___0 = envelope_get_y___0(& (playing->env_instrument)->pitch_envelope, & playing->pitch_envelope);
#line 3154
      p = tmp___0;
      }
#line 3155
      if ((int )(playing->env_instrument)->pitch_envelope.flags & 128) {
#line 3156
        *cutoff = *cutoff * (p + (32 << 8)) >> 14;
      } else {
        {
#line 3158
        tmp___1 = pow(1.000225659305069791926712241547647863626, (double )(p >> 1));
#line 3158
        *delta *= (float )tmp___1;
        }
      }
    }
  }
#line 3160
  return;
}
}
#line 3164 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void render___0(DUMB_IT_SIGRENDERER *sigrenderer , float volume , float delta ,
                       long pos , long size , sample_t **samples ) 
{ 
  int i ;
  int n_to_mix ;
  IT_TO_MIX to_mix[256] ;
  int left_to_mix ;
  sample_t **samples_to_filter ;
  float tmp ;
  float tmp___0 ;
  IT_PLAYING *playing ;
  float note_delta ;
  int cutoff ;
  long size_rendered ;
  DUMB_CLICK_REMOVER **cr ;
  DUMB_CLICK_REMOVER *tmp___1 ;
  DUMB_CLICK_REMOVER *tmp___2 ;
  DUMB_CLICK_REMOVER *tmp___3 ;

  {
#line 3168
  n_to_mix = 0;
#line 3170
  left_to_mix = dumb_it_max_to_mix;
#line 3172
  samples_to_filter = (sample_t **)((void *)0);
#line 3174
  i = 0;
  {
#line 3174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3174
    if (! (i < 64)) {
#line 3174
      goto while_break;
    }
#line 3175
    if (sigrenderer->channel[i].playing) {
#line 3175
      if (! ((sigrenderer->channel[i].playing)->flags & 8)) {
#line 3176
        to_mix[n_to_mix].playing = sigrenderer->channel[i].playing;
#line 3177
        if (volume == (float )0) {
#line 3177
          to_mix[n_to_mix].volume = (float )0;
        } else {
          {
#line 3177
          tmp = calculate_volume___0(sigrenderer, sigrenderer->channel[i].playing,
                                     volume);
#line 3177
          to_mix[n_to_mix].volume = tmp;
          }
        }
#line 3178
        n_to_mix ++;
      }
    }
#line 3174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3182
  i = 0;
  {
#line 3182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3182
    if (! (i < 192)) {
#line 3182
      goto while_break___0;
    }
#line 3183
    if (sigrenderer->playing[i]) {
#line 3184
      to_mix[n_to_mix].playing = sigrenderer->playing[i];
#line 3185
      if (volume == (float )0) {
#line 3185
        to_mix[n_to_mix].volume = (float )0;
      } else {
        {
#line 3185
        tmp___0 = calculate_volume___0(sigrenderer, sigrenderer->playing[i], volume);
#line 3185
        to_mix[n_to_mix].volume = tmp___0;
        }
      }
#line 3186
      n_to_mix ++;
    }
#line 3182
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3190
  if (volume != (float )0) {
    {
#line 3191
    qsort((void *)(to_mix), (size_t )n_to_mix, sizeof(IT_TO_MIX ), & it_to_mix_compare___0);
    }
  }
#line 3193
  i = 0;
  {
#line 3193
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3193
    if (! (i < n_to_mix)) {
#line 3193
      goto while_break___1;
    }
    {
#line 3194
    playing = to_mix[i].playing;
#line 3195
    note_delta = delta * playing->delta;
#line 3196
    cutoff = (int )playing->filter_cutoff << 8;
#line 3198
    apply_pitch_modifications___0(sigrenderer->sigdata, playing, & note_delta, & cutoff);
    }
#line 3200
    if (cutoff != 127 << 8) {
#line 3201
      playing->true_filter_cutoff = (unsigned short )cutoff;
#line 3202
      playing->true_filter_resonance = playing->filter_resonance;
    } else
#line 3200
    if ((int )playing->filter_resonance != 0) {
#line 3201
      playing->true_filter_cutoff = (unsigned short )cutoff;
#line 3202
      playing->true_filter_resonance = playing->filter_resonance;
    }
#line 3205
    if (to_mix[i].volume) {
#line 3205
      if ((int )playing->true_filter_cutoff != 127 << 8) {
#line 3205
        goto _L;
      } else
#line 3205
      if ((int )playing->true_filter_resonance != 0) {
        _L: /* CIL Label */ 
#line 3206
        if (! samples_to_filter) {
          {
#line 3207
          samples_to_filter = allocate_sample_buffer(sigrenderer->n_channels, size + 1L);
          }
#line 3208
          if (! samples_to_filter) {
            {
#line 3209
            render_playing___0(sigrenderer, playing, (float )0, note_delta, pos, size,
                               (sample_t **)((void *)0), 0, & left_to_mix);
            }
#line 3210
            goto __Cont;
          }
        }
        {
#line 3215
        cr = sigrenderer->click_remover;
#line 3216
        dumb_silence(*(samples_to_filter + 0), (long )sigrenderer->n_channels * (size + 1L));
#line 3217
        sigrenderer->click_remover = (DUMB_CLICK_REMOVER **)((void *)0);
#line 3218
        size_rendered = render_playing___0(sigrenderer, playing, to_mix[i].volume,
                                           note_delta, 0L, size, samples_to_filter,
                                           1, & left_to_mix);
#line 3219
        sigrenderer->click_remover = cr;
        }
#line 3220
        if (sigrenderer->n_channels == 2) {
#line 3221
          if (cr) {
#line 3221
            tmp___1 = *(cr + 0);
          } else {
#line 3221
            tmp___1 = (DUMB_CLICK_REMOVER *)((void *)0);
          }
          {
#line 3221
          it_filter___0(tmp___1, & playing->filter_state[0], *(samples + 0), pos,
                        *(samples_to_filter + 0), size_rendered, 2, (int )(65536.0f / delta),
                        (int )playing->true_filter_cutoff, (int )playing->true_filter_resonance);
          }
#line 3223
          if (cr) {
#line 3223
            tmp___2 = *(cr + 1);
          } else {
#line 3223
            tmp___2 = (DUMB_CLICK_REMOVER *)((void *)0);
          }
          {
#line 3223
          it_filter___0(tmp___2, & playing->filter_state[1], *(samples + 0) + 1, pos,
                        *(samples_to_filter + 0) + 1, size_rendered, 2, (int )(65536.0f / delta),
                        (int )playing->true_filter_cutoff, (int )playing->true_filter_resonance);
          }
        } else {
#line 3226
          if (cr) {
#line 3226
            tmp___3 = *(cr + 0);
          } else {
#line 3226
            tmp___3 = (DUMB_CLICK_REMOVER *)((void *)0);
          }
          {
#line 3226
          it_filter___0(tmp___3, & playing->filter_state[0], *(samples + 0), pos,
                        *(samples_to_filter + 0), size_rendered, 1, (int )(65536.0f / delta),
                        (int )playing->true_filter_cutoff, (int )playing->true_filter_resonance);
          }
        }
      } else {
        {
#line 3233
        it_reset_filter_state___0(& playing->filter_state[0]);
#line 3234
        it_reset_filter_state___0(& playing->filter_state[1]);
#line 3235
        render_playing___0(sigrenderer, playing, to_mix[i].volume, note_delta, pos,
                           size, samples, 0, & left_to_mix);
        }
      }
    } else {
      {
#line 3233
      it_reset_filter_state___0(& playing->filter_state[0]);
#line 3234
      it_reset_filter_state___0(& playing->filter_state[1]);
#line 3235
      render_playing___0(sigrenderer, playing, to_mix[i].volume, note_delta, pos,
                         size, samples, 0, & left_to_mix);
      }
    }
    __Cont: /* CIL Label */ 
#line 3193
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3239
  destroy_sample_buffer(samples_to_filter);
#line 3241
  i = 0;
  }
  {
#line 3241
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3241
    if (! (i < 64)) {
#line 3241
      goto while_break___2;
    }
#line 3242
    if (sigrenderer->channel[i].playing) {
#line 3245
      if ((sigrenderer->channel[i].playing)->flags & 8) {
        {
#line 3246
        free((void *)sigrenderer->channel[i].playing);
#line 3247
        sigrenderer->channel[i].playing = (IT_PLAYING *)((void *)0);
        }
      }
    }
#line 3241
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3252
  i = 0;
  {
#line 3252
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3252
    if (! (i < 192)) {
#line 3252
      goto while_break___3;
    }
#line 3253
    if (sigrenderer->playing[i]) {
#line 3254
      if ((sigrenderer->playing[i])->flags & 8) {
        {
#line 3255
        free((void *)sigrenderer->playing[i]);
#line 3256
        sigrenderer->playing[i] = (IT_PLAYING *)((void *)0);
        }
      }
    }
#line 3252
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3260
  return;
}
}
#line 3264 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static DUMB_IT_SIGRENDERER *init_sigrenderer___0(DUMB_IT_SIGDATA *sigdata , int n_channels ,
                                                 int startorder , IT_CALLBACKS *callbacks ,
                                                 DUMB_CLICK_REMOVER **cr ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;
  int i ;
  void *tmp ;
  IT_CHANNEL *channel ;
  int order ;
  int n ;

  {
#line 3269
  if (startorder > sigdata->n_orders) {
    {
#line 3270
    free((void *)callbacks);
#line 3271
    dumb_destroy_click_remover_array(n_channels, cr);
    }
#line 3272
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 3275
  tmp = malloc(sizeof(*sigrenderer));
#line 3275
  sigrenderer = (DUMB_IT_SIGRENDERER *)tmp;
  }
#line 3276
  if (! sigrenderer) {
    {
#line 3277
    free((void *)callbacks);
#line 3278
    dumb_destroy_click_remover_array(n_channels, cr);
    }
#line 3279
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
#line 3282
  sigrenderer->callbacks = callbacks;
#line 3283
  sigrenderer->click_remover = cr;
#line 3285
  sigrenderer->sigdata = sigdata;
#line 3286
  sigrenderer->n_channels = n_channels;
#line 3287
  sigrenderer->globalvolume = (unsigned char )sigdata->global_volume;
#line 3288
  sigrenderer->tempo = (unsigned char )sigdata->tempo;
#line 3290
  i = 0;
  {
#line 3290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3290
    if (! (i < 64)) {
#line 3290
      goto while_break;
    }
#line 3291
    channel = & sigrenderer->channel[i];
#line 3295
    channel->flags = (int )sigdata->channel_pan[i] >> 7;
#line 3296
    if (sigdata->flags & 64) {
#line 3296
      channel->volume = (unsigned char)0;
    } else {
#line 3296
      channel->volume = (unsigned char)64;
    }
#line 3297
    channel->pan = (unsigned char )((int )sigdata->channel_pan[i] & 127);
#line 3298
    channel->truepan = (unsigned short )((int )channel->pan << 8);
#line 3299
    channel->channelvolume = sigdata->channel_volume[i];
#line 3300
    channel->instrument = (unsigned char)0;
#line 3301
    channel->note = (unsigned char)0;
#line 3302
    channel->SFmacro = (unsigned char)0;
#line 3303
    channel->filter_cutoff = (unsigned char)127;
#line 3304
    channel->filter_resonance = (unsigned char)0;
#line 3305
    channel->xm_retrig = (unsigned char)0;
#line 3306
    channel->retrig_tick = 0;
#line 3307
    channel->tremor_time = (unsigned char)0;
#line 3308
    channel->midi_state = (unsigned char)0;
#line 3309
    channel->lastvolslide = (signed char)0;
#line 3310
    channel->lastDKL = (unsigned char)0;
#line 3311
    channel->lastEF = (unsigned char)0;
#line 3312
    channel->lastG = (unsigned char)0;
#line 3313
    channel->lastHspeed = (unsigned char)0;
#line 3314
    channel->lastHdepth = (unsigned char)0;
#line 3315
    channel->lastRspeed = (unsigned char)0;
#line 3316
    channel->lastRdepth = (unsigned char)0;
#line 3317
    channel->lastI = (unsigned char)0;
#line 3318
    channel->lastJ = (unsigned char)0;
#line 3319
    channel->lastN = (unsigned char)0;
#line 3320
    channel->lastO = (unsigned char)0;
#line 3321
    channel->high_offset = (unsigned char)0;
#line 3322
    channel->lastP = (unsigned char)0;
#line 3323
    channel->lastQ = (unsigned char)0;
#line 3324
    channel->lastS = (unsigned char)0;
#line 3325
    channel->pat_loop_row = (unsigned char)0;
#line 3326
    channel->pat_loop_count = (unsigned char)0;
#line 3327
    channel->pat_loop_end_row = (unsigned char)0;
#line 3328
    channel->lastW = (unsigned char)0;
#line 3329
    channel->xm_lastE1 = (unsigned char)0;
#line 3330
    channel->xm_lastE2 = (unsigned char)0;
#line 3331
    channel->xm_lastEA = (unsigned char)0;
#line 3332
    channel->xm_lastEB = (unsigned char)0;
#line 3333
    channel->xm_lastX1 = (unsigned char)0;
#line 3334
    channel->xm_lastX2 = (unsigned char)0;
#line 3335
    channel->playing = (IT_PLAYING *)((void *)0);
#line 3290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3338
  i = 0;
  {
#line 3338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3338
    if (! (i < 192)) {
#line 3338
      goto while_break___0;
    }
#line 3339
    sigrenderer->playing[i] = (IT_PLAYING *)((void *)0);
#line 3338
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3341
  sigrenderer->speed = sigdata->speed;
#line 3343
  sigrenderer->processrow = 65534;
#line 3344
  sigrenderer->n_rows = 0;
#line 3345
  sigrenderer->breakrow = 0;
#line 3346
  sigrenderer->pat_loop_row = -1;
#line 3347
  sigrenderer->rowcount = 1;
#line 3348
  sigrenderer->order = startorder;
#line 3349
  sigrenderer->row = 0;
#line 3350
  sigrenderer->processorder = startorder - 1;
#line 3351
  sigrenderer->tick = 1;
#line 3355
  order = 0;
  {
#line 3355
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3355
    if (! (order < sigdata->n_orders)) {
#line 3355
      goto while_break___1;
    }
#line 3356
    n = (int )*(sigdata->order + order);
#line 3357
    if (n < sigdata->n_patterns) {
#line 3357
      goto found_valid_order;
    }
#line 3359
    if (n != 254) {
#line 3363
      goto while_break___1;
    }
#line 3355
    order ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3366
  _dumb_it_end_sigrenderer((sigrenderer_t *)sigrenderer);
  }
#line 3367
  return ((DUMB_IT_SIGRENDERER *)((void *)0));
  found_valid_order: 
#line 3371
  sigrenderer->time_left = 0L;
#line 3372
  sigrenderer->sub_time_left = 0;
#line 3374
  return (sigrenderer);
}
}
#line 3409 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static IT_CALLBACKS *create_callbacks___0(void) 
{ 
  IT_CALLBACKS *callbacks ;
  void *tmp ;

  {
  {
#line 3411
  tmp = malloc(sizeof(*callbacks));
#line 3411
  callbacks = (IT_CALLBACKS *)tmp;
  }
#line 3412
  if (! callbacks) {
#line 3412
    return ((IT_CALLBACKS *)((void *)0));
  }
#line 3413
  callbacks->loop = (int (*)(void *data ))((void *)0);
#line 3414
  callbacks->xm_speed_zero = (int (*)(void *data ))((void *)0);
#line 3415
  callbacks->midi = (int (*)(void *data , int channel , unsigned char byte ))((void *)0);
#line 3416
  return (callbacks);
}
}
#line 3421 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static DUMB_IT_SIGRENDERER *dumb_it_init_sigrenderer___0(DUMB_IT_SIGDATA *sigdata ,
                                                         int n_channels , int startorder ) 
{ 
  IT_CALLBACKS *callbacks ;
  DUMB_CLICK_REMOVER **tmp ;
  DUMB_IT_SIGRENDERER *tmp___0 ;

  {
#line 3425
  if (! sigdata) {
#line 3425
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 3427
  callbacks = create_callbacks___0();
  }
#line 3428
  if (! callbacks) {
#line 3428
    return ((DUMB_IT_SIGRENDERER *)((void *)0));
  }
  {
#line 3430
  tmp = dumb_create_click_remover_array(n_channels);
#line 3430
  tmp___0 = init_sigrenderer___0(sigdata, n_channels, startorder, callbacks, tmp);
  }
#line 3430
  return (tmp___0);
}
}
#line 3445 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static sigrenderer_t *it_start_sigrenderer___0(DUH *duh , sigdata_t *vsigdata , int n_channels ,
                                               long pos ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  DUMB_IT_SIGRENDERER *sigrenderer ;
  IT_CALLBACKS *callbacks ;
  IT_CALLBACKS *tmp ;
  IT_CHECKPOINT *checkpoint ;
  DUMB_CLICK_REMOVER **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3447
  sigdata = (DUMB_IT_SIGDATA *)vsigdata;
#line 3453
  tmp = create_callbacks___0();
#line 3453
  callbacks = tmp;
  }
#line 3454
  if (! callbacks) {
#line 3454
    return ((void *)0);
  }
#line 3456
  if (sigdata->checkpoint) {
#line 3457
    checkpoint = sigdata->checkpoint;
    {
#line 3458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3458
      if (checkpoint->next) {
#line 3458
        if (! ((checkpoint->next)->time < pos)) {
#line 3458
          goto while_break;
        }
      } else {
#line 3458
        goto while_break;
      }
#line 3459
      checkpoint = checkpoint->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3460
    sigrenderer = dup_sigrenderer___0(checkpoint->sigrenderer, n_channels, callbacks);
    }
#line 3461
    if (! sigrenderer) {
#line 3461
      return ((void *)0);
    }
    {
#line 3462
    sigrenderer->click_remover = dumb_create_click_remover_array(n_channels);
#line 3463
    pos -= checkpoint->time;
    }
  } else {
    {
#line 3465
    tmp___0 = dumb_create_click_remover_array(n_channels);
#line 3465
    sigrenderer = init_sigrenderer___0(sigdata, n_channels, 0, callbacks, tmp___0);
    }
#line 3467
    if (! sigrenderer) {
#line 3467
      return ((void *)0);
    }
  }
  {
#line 3471
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3471
    if (! (pos >= sigrenderer->time_left)) {
#line 3471
      goto while_break___0;
    }
    {
#line 3472
    render___0(sigrenderer, (float )0, 1.0f, 0L, sigrenderer->time_left, (sample_t **)((void *)0));
#line 3474
    pos -= sigrenderer->time_left;
#line 3475
    sigrenderer->time_left = 0L;
#line 3477
    tmp___1 = process_tick___0(sigrenderer);
    }
#line 3477
    if (tmp___1) {
      {
#line 3478
      _dumb_it_end_sigrenderer((sigrenderer_t *)sigrenderer);
      }
#line 3479
      return ((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3483
  render___0(sigrenderer, (float )0, 1.0f, 0L, pos, (sample_t **)((void *)0));
#line 3484
  sigrenderer->time_left -= pos;
  }
#line 3486
  return ((sigrenderer_t *)sigrenderer);
}
}
#line 3491 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static long it_sigrenderer_get_samples___0(sigrenderer_t *vsigrenderer , float volume ,
                                           float delta , long size , sample_t **samples ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;
  long pos ;
  int dt ;
  long todo ;
  long long t ;
  int tmp ;

  {
#line 3497
  sigrenderer = (DUMB_IT_SIGRENDERER *)vsigrenderer;
#line 3503
  if (sigrenderer->order < 0) {
#line 3503
    return (0L);
  }
#line 3505
  pos = 0L;
#line 3506
  dt = (int )(delta * 65536.0f + 0.5f);
#line 3511
  if (! samples) {
#line 3511
    volume = (float )0;
  }
  {
#line 3513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3514
    todo = (long )((((long long )sigrenderer->time_left << 16) | (long long )sigrenderer->sub_time_left) / (long long )dt);
#line 3516
    if (todo >= size) {
#line 3517
      goto while_break;
    }
    {
#line 3519
    render___0(sigrenderer, volume, delta, pos, todo, samples);
#line 3521
    pos += todo;
#line 3522
    size -= todo;
#line 3524
    t = (long long )sigrenderer->sub_time_left - (long long )todo * (long long )dt;
#line 3525
    sigrenderer->sub_time_left = (int )((long )t & 65535L);
#line 3526
    sigrenderer->time_left += (long )(t >> 16);
#line 3528
    tmp = process_tick___0(sigrenderer);
    }
#line 3528
    if (tmp) {
#line 3529
      sigrenderer->order = -1;
#line 3530
      sigrenderer->row = -1;
#line 3531
      return (pos);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3535
  render___0(sigrenderer, volume, delta, pos, size, samples);
#line 3537
  pos += size;
#line 3539
  t = (long long )sigrenderer->sub_time_left - (long long )size * (long long )dt;
#line 3540
  sigrenderer->sub_time_left = (int )((long )t & 65535L);
#line 3541
  sigrenderer->time_left += (long )(t >> 16);
  }
#line 3543
  if (samples) {
    {
#line 3544
    dumb_remove_clicks_array(sigrenderer->n_channels, sigrenderer->click_remover,
                             samples, pos, 512.0f / delta);
    }
  }
#line 3546
  return (pos);
}
}
#line 3551 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itrender.c"
static void it_sigrenderer_get_current_sample___0(sigrenderer_t *vsigrenderer , float volume ,
                                                  sample_t *samples ) 
{ 
  DUMB_IT_SIGRENDERER *sigrenderer ;

  {
  {
#line 3553
  sigrenderer = (DUMB_IT_SIGRENDERER *)vsigrenderer;
#line 3555
  dumb_click_remover_get_offset_array(sigrenderer->n_channels, sigrenderer->click_remover,
                                      samples);
  }
#line 3556
  return;
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumb2wav.c"
static int loop_count  =    1;
#line 37 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumb2wav.c"
static int write32_le(FILE *outf , unsigned int value ) 
{ 
  int total ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 38
  total = 0;
#line 39
  tmp = fputc((int )(value & 255U), outf);
#line 39
  total += tmp;
#line 40
  tmp___0 = fputc((int )((value >> 8) & 255U), outf);
#line 40
  total += tmp___0;
#line 41
  tmp___1 = fputc((int )((value >> 16) & 255U), outf);
#line 41
  total += tmp___1;
#line 42
  tmp___2 = fputc((int )((value >> 24) & 255U), outf);
#line 42
  total += tmp___2;
  }
#line 43
  return (total);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumb2wav.c"
static int write16_le(FILE *outf , unsigned int value ) 
{ 
  int total ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 47
  total = 0;
#line 48
  tmp = fputc((int )(value & 255U), outf);
#line 48
  total += tmp;
#line 49
  tmp___0 = fputc((int )((value >> 8) & 255U), outf);
#line 49
  total += tmp___0;
  }
#line 50
  return (total);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/examples/dumb2wav.c"
static int loop_callback(void *data ) 
{ 


  {
#line 56
  loop_count --;
#line 56
  return (loop_count <= 0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/dumbfile.c"
static DUMBFILE_SYSTEM *the_dfs___0  =    (DUMBFILE_SYSTEM *)((void *)0);
#line 32 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_seek___0(DUMBFILE *f , long offset ) 
{ 
  long pos ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 34
  tmp = dumbfile_pos(f);
#line 34
  pos = tmp;
  }
#line 36
  if (pos > offset) {
#line 37
    return (-1);
  }
#line 39
  if (pos < offset) {
    {
#line 40
    tmp___0 = dumbfile_skip(f, offset - pos);
    }
#line 40
    if (tmp___0) {
#line 41
      return (-1);
    }
  }
#line 43
  return (0);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char *sourcebuf___0  =    (unsigned char *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char *sourcepos___0  =    (unsigned char *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char *sourceend___0  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int rembits___0  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int readblock___0(DUMBFILE *f ) 
{ 
  long size ;
  int c ;
  int tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 66
  tmp = dumbfile_igetw(f);
#line 66
  size = (long )tmp;
  }
#line 67
  if (size < 0L) {
#line 68
    return ((int )size);
  }
  {
#line 70
  tmp___0 = malloc((size_t )size);
#line 70
  sourcebuf___0 = (unsigned char *)tmp___0;
  }
#line 71
  if (! sourcebuf___0) {
#line 72
    return (-1);
  }
  {
#line 74
  tmp___1 = dumbfile_getnc((char *)sourcebuf___0, size, f);
#line 74
  c = (int )tmp___1;
  }
#line 75
  if ((long )c < size) {
    {
#line 76
    free((void *)sourcebuf___0);
#line 77
    sourcebuf___0 = (unsigned char *)((void *)0);
    }
#line 78
    return (-1);
  }
#line 81
  sourcepos___0 = sourcebuf___0;
#line 82
  sourceend___0 = sourcebuf___0 + size;
#line 83
  rembits___0 = 8;
#line 84
  return (0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static void freeblock___0(void) 
{ 


  {
  {
#line 91
  free((void *)sourcebuf___0);
#line 92
  sourcebuf___0 = (unsigned char *)((void *)0);
  }
#line 93
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int readbits___0(int bitwidth ) 
{ 
  int val ;
  int b ;
  unsigned char *tmp ;

  {
#line 99
  val = 0;
#line 100
  b = 0;
#line 102
  if ((unsigned long )sourcepos___0 >= (unsigned long )sourceend___0) {
#line 102
    return (val);
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (bitwidth > rembits___0)) {
#line 104
      goto while_break;
    }
#line 105
    tmp = sourcepos___0;
#line 105
    sourcepos___0 ++;
#line 105
    val |= (int )*tmp << b;
#line 106
    if ((unsigned long )sourcepos___0 >= (unsigned long )sourceend___0) {
#line 106
      return (val);
    }
#line 107
    b += rembits___0;
#line 108
    bitwidth -= rembits___0;
#line 109
    rembits___0 = 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  val |= ((int )*sourcepos___0 & ((1 << bitwidth) - 1)) << b;
#line 113
  *sourcepos___0 = (unsigned char )((int )*sourcepos___0 >> bitwidth);
#line 114
  rembits___0 -= bitwidth;
#line 116
  return (val);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int decompress8___0(DUMBFILE *f , signed char *data , int len , int cmwt ) 
{ 
  int blocklen ;
  int blockpos ;
  byte bitwidth ;
  word val ;
  char d1 ;
  char d2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  byte border ;
  char v ;
  byte shift ;
  signed char *tmp___2 ;

  {
  {
#line 131
  memset((void *)data, 0, (unsigned long )len * sizeof(*data));
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (len > 0)) {
#line 133
      goto while_break;
    }
    {
#line 135
    tmp = readblock___0(f);
    }
#line 135
    if (tmp) {
#line 136
      return (-1);
    }
#line 138
    if (len < 32768) {
#line 138
      blocklen = len;
    } else {
#line 138
      blocklen = 32768;
    }
#line 139
    blockpos = 0;
#line 140
    bitwidth = (byte )9;
#line 141
    d2 = (char)0;
#line 141
    d1 = d2;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! (blockpos < blocklen)) {
#line 143
        goto while_break___0;
      }
      {
#line 145
      tmp___0 = readbits___0((int )bitwidth);
#line 145
      val = (word )tmp___0;
      }
#line 148
      if ((int )bitwidth < 7) {
#line 149
        if ((int )val == 1 << ((int )bitwidth - 1)) {
          {
#line 150
          tmp___1 = readbits___0(3);
#line 150
          val = (word )((int )((word )tmp___1) + 1);
          }
#line 151
          if ((int )val < (int )bitwidth) {
#line 151
            bitwidth = (byte )val;
          } else {
#line 151
            bitwidth = (byte )((int )val + 1);
          }
#line 152
          goto while_continue___0;
        }
      } else
#line 155
      if ((int )bitwidth < 9) {
#line 156
        border = (byte )((255 >> (9 - (int )bitwidth)) - 4);
#line 158
        if ((int )val > (int )border) {
#line 158
          if ((int )val <= (int )border + 8) {
#line 159
            val = (word )((int )val - (int )border);
#line 160
            if ((int )val < (int )bitwidth) {
#line 160
              bitwidth = (byte )val;
            } else {
#line 160
              bitwidth = (byte )((int )val + 1);
            }
#line 161
            goto while_continue___0;
          }
        }
      } else
#line 164
      if ((int )bitwidth == 9) {
#line 165
        if ((int )val & 256) {
#line 166
          bitwidth = (byte )(((int )val + 1) & 255);
#line 167
          goto while_continue___0;
        }
      } else {
        {
#line 171
        freeblock___0();
        }
#line 172
        return (-1);
      }
#line 178
      if ((int )bitwidth < 8) {
#line 179
        shift = (byte )(8 - (int )bitwidth);
#line 180
        v = (char )((int )val << (int )shift);
#line 181
        v = (char )((int )v >> (int )shift);
      } else {
#line 184
        v = (char )val;
      }
#line 188
      d1 = (char )((int )d1 + (int )v);
#line 189
      d2 = (char )((int )d2 + (int )d1);
#line 196
      tmp___2 = data;
#line 196
      data ++;
#line 196
      if (cmwt == 533) {
#line 196
        *tmp___2 = (signed char )d2;
      } else {
#line 196
        *tmp___2 = (signed char )d1;
      }
#line 197
      len --;
#line 198
      blockpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 200
    freeblock___0();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int decompress16___0(DUMBFILE *f , short *data , int len , int cmwt ) 
{ 
  int blocklen ;
  int blockpos ;
  byte bitwidth ;
  long val ;
  short d1 ;
  short d2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  word border ;
  short v ;
  byte shift ;
  short *tmp___2 ;

  {
  {
#line 214
  memset((void *)data, 0, (unsigned long )len * sizeof(*data));
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (len > 0)) {
#line 216
      goto while_break;
    }
    {
#line 218
    tmp = readblock___0(f);
    }
#line 218
    if (tmp) {
#line 219
      return (-1);
    }
#line 221
    if (len < 16384) {
#line 221
      blocklen = len;
    } else {
#line 221
      blocklen = 16384;
    }
#line 222
    blockpos = 0;
#line 223
    bitwidth = (byte )17;
#line 224
    d2 = (short)0;
#line 224
    d1 = d2;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (blockpos < blocklen)) {
#line 226
        goto while_break___0;
      }
      {
#line 227
      tmp___0 = readbits___0((int )bitwidth);
#line 227
      val = (long )tmp___0;
      }
#line 230
      if ((int )bitwidth < 7) {
#line 231
        if (val == (long )(1 << ((int )bitwidth - 1))) {
          {
#line 232
          tmp___1 = readbits___0(4);
#line 232
          val = (long )(tmp___1 + 1);
          }
#line 233
          if (val < (long )bitwidth) {
#line 233
            bitwidth = (byte )val;
          } else {
#line 233
            bitwidth = (byte )(val + 1L);
          }
#line 234
          goto while_continue___0;
        }
      } else
#line 237
      if ((int )bitwidth < 17) {
#line 238
        border = (word )((65535 >> (17 - (int )bitwidth)) - 8);
#line 240
        if (val > (long )border) {
#line 240
          if (val <= (long )((int )border + 16)) {
#line 241
            val -= (long )border;
#line 242
            if (val < (long )bitwidth) {
#line 242
              bitwidth = (byte )val;
            } else {
#line 242
              bitwidth = (byte )(val + 1L);
            }
#line 243
            goto while_continue___0;
          }
        }
      } else
#line 246
      if ((int )bitwidth == 17) {
#line 247
        if (val & 65536L) {
#line 248
          bitwidth = (byte )((val + 1L) & 255L);
#line 249
          goto while_continue___0;
        }
      } else {
        {
#line 253
        freeblock___0();
        }
#line 254
        return (-1);
      }
#line 260
      if ((int )bitwidth < 16) {
#line 261
        shift = (byte )(16 - (int )bitwidth);
#line 262
        v = (short )(val << (int )shift);
#line 263
        v = (short )((int )v >> (int )shift);
      } else {
#line 266
        v = (short )val;
      }
#line 270
      d1 = (short )((int )d1 + (int )v);
#line 271
      d2 = (short )((int )d2 + (int )d1);
#line 278
      tmp___2 = data;
#line 278
      data ++;
#line 278
      if (cmwt == 533) {
#line 278
        *tmp___2 = d2;
      } else {
#line 278
        *tmp___2 = d1;
      }
#line 279
      len --;
#line 280
      blockpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 282
    freeblock___0();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (0);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_envelope___0(IT_ENVELOPE *envelope , DUMBFILE *f ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 293
  tmp = dumbfile_getc(f);
#line 293
  envelope->flags = (unsigned char )tmp;
#line 294
  tmp___0 = dumbfile_getc(f);
#line 294
  envelope->n_nodes = (unsigned char )tmp___0;
  }
#line 295
  if ((int )envelope->n_nodes > 25) {
#line 297
    envelope->n_nodes = (unsigned char)0;
#line 298
    return (-1);
  }
  {
#line 300
  tmp___1 = dumbfile_getc(f);
#line 300
  envelope->loop_start = (unsigned char )tmp___1;
#line 301
  tmp___2 = dumbfile_getc(f);
#line 301
  envelope->loop_end = (unsigned char )tmp___2;
#line 302
  tmp___3 = dumbfile_getc(f);
#line 302
  envelope->sus_loop_start = (unsigned char )tmp___3;
#line 303
  tmp___4 = dumbfile_getc(f);
#line 303
  envelope->sus_loop_end = (unsigned char )tmp___4;
#line 304
  n = 0;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (n < (int )envelope->n_nodes)) {
#line 304
      goto while_break;
    }
    {
#line 305
    tmp___5 = dumbfile_getc(f);
#line 305
    envelope->node_y[n] = (signed char )tmp___5;
#line 306
    tmp___6 = dumbfile_igetw(f);
#line 306
    envelope->node_t[n] = (unsigned short )tmp___6;
#line 304
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  dumbfile_skip(f, (long )((75 - (int )envelope->n_nodes * 3) + 1));
  }
#line 310
  if ((int )envelope->n_nodes <= 0) {
#line 311
    envelope->flags = (unsigned char )((int )envelope->flags & -2);
  } else {
#line 313
    if ((int )envelope->loop_end >= (int )envelope->n_nodes) {
#line 313
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    } else
#line 313
    if ((int )envelope->loop_start > (int )envelope->loop_end) {
#line 313
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    }
#line 314
    if ((int )envelope->sus_loop_end >= (int )envelope->n_nodes) {
#line 314
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    } else
#line 314
    if ((int )envelope->sus_loop_start > (int )envelope->sus_loop_end) {
#line 314
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    }
  }
  {
#line 317
  tmp___7 = dumbfile_error(f);
  }
#line 317
  return (tmp___7);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_old_instrument___0(IT_INSTRUMENT *instrument , DUMBFILE *f ) 
{ 
  int n ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  IT_ENVELOPE *envelope ;

  {
  {
#line 326
  tmp = dumbfile_mgetl(f);
  }
#line 326
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 73U)) {
#line 327
    return (-1);
  }
  {
#line 329
  dumbfile_getnc((char *)(instrument->filename), 13L, f);
#line 330
  instrument->filename[13] = (unsigned char)0;
#line 332
  tmp___0 = dumbfile_getc(f);
#line 332
  instrument->volume_envelope.flags = (unsigned char )tmp___0;
#line 333
  tmp___1 = dumbfile_getc(f);
#line 333
  instrument->volume_envelope.loop_start = (unsigned char )tmp___1;
#line 334
  tmp___2 = dumbfile_getc(f);
#line 334
  instrument->volume_envelope.loop_end = (unsigned char )tmp___2;
#line 335
  tmp___3 = dumbfile_getc(f);
#line 335
  instrument->volume_envelope.sus_loop_start = (unsigned char )tmp___3;
#line 336
  tmp___4 = dumbfile_getc(f);
#line 336
  instrument->volume_envelope.sus_loop_end = (unsigned char )tmp___4;
#line 339
  dumbfile_skip(f, 2L);
#line 347
  tmp___5 = dumbfile_igetw(f);
#line 347
  instrument->fadeout = tmp___5 << 1;
#line 348
  tmp___6 = dumbfile_getc(f);
#line 348
  instrument->new_note_action = (unsigned char )tmp___6;
#line 349
  tmp___7 = dumbfile_getc(f);
#line 349
  instrument->dup_check_type = (unsigned char )tmp___7;
#line 350
  instrument->dup_check_action = (unsigned char)0;
#line 356
  dumbfile_skip(f, 4L);
#line 358
  dumbfile_getnc((char *)(instrument->name), 26L, f);
#line 359
  instrument->name[26] = (unsigned char)0;
#line 362
  dumbfile_skip(f, 6L);
#line 364
  instrument->pp_separation = (unsigned char)0;
#line 365
  instrument->pp_centre = (unsigned char)60;
#line 366
  instrument->global_volume = (unsigned char)128;
#line 368
  instrument->default_pan = (unsigned char)32;
#line 370
  instrument->random_volume = (unsigned char)0;
#line 371
  instrument->random_pan = (unsigned char)0;
#line 373
  n = 0;
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (n < 120)) {
#line 373
      goto while_break;
    }
    {
#line 374
    tmp___8 = dumbfile_getc(f);
#line 374
    instrument->map_note[n] = (unsigned char )tmp___8;
#line 375
    tmp___9 = dumbfile_getc(f);
#line 375
    instrument->map_sample[n] = (unsigned short )tmp___9;
#line 373
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  dumbfile_skip(f, 200L);
#line 383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Inst %02d Env:",
          n);
#line 386
  n = 0;
  }
  {
#line 386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 386
    if (! (n < 25)) {
#line 386
      goto while_break___0;
    }
    {
#line 388
    tmp___10 = dumbfile_getc(f);
#line 388
    instrument->volume_envelope.node_t[n] = (unsigned short )tmp___10;
#line 389
    tmp___11 = dumbfile_getc(f);
#line 389
    instrument->volume_envelope.node_y[n] = (signed char )tmp___11;
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d,%d",
            (int )instrument->volume_envelope.node_t[n], (int )instrument->volume_envelope.node_y[n]);
#line 386
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  dumbfile_skip(f, (long )(50 - (n << 1)));
#line 402
  instrument->volume_envelope.n_nodes = (unsigned char )n;
#line 405
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 408
  tmp___12 = dumbfile_error(f);
  }
#line 408
  if (tmp___12) {
#line 409
    return (-1);
  }
#line 412
  envelope = & instrument->volume_envelope;
#line 413
  if ((int )envelope->n_nodes <= 0) {
#line 414
    envelope->flags = (unsigned char )((int )envelope->flags & -2);
  } else {
#line 416
    if ((int )envelope->loop_end >= (int )envelope->n_nodes) {
#line 416
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    } else
#line 416
    if ((int )envelope->loop_start > (int )envelope->loop_end) {
#line 416
      envelope->flags = (unsigned char )((int )envelope->flags & -3);
    }
#line 417
    if ((int )envelope->sus_loop_end >= (int )envelope->n_nodes) {
#line 417
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    } else
#line 417
    if ((int )envelope->sus_loop_start > (int )envelope->sus_loop_end) {
#line 417
      envelope->flags = (unsigned char )((int )envelope->flags & -5);
    }
  }
#line 421
  instrument->filter_cutoff = (unsigned char)127;
#line 422
  instrument->filter_resonance = (unsigned char)0;
#line 424
  instrument->pan_envelope.flags = (unsigned char)0;
#line 425
  instrument->pitch_envelope.flags = (unsigned char)0;
#line 427
  return (0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_instrument___0(IT_INSTRUMENT *instrument , DUMBFILE *f ) 
{ 
  int n ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 436
  tmp = dumbfile_mgetl(f);
  }
#line 436
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 73U)) {
#line 437
    return (-1);
  }
  {
#line 439
  dumbfile_getnc((char *)(instrument->filename), 13L, f);
#line 440
  instrument->filename[13] = (unsigned char)0;
#line 442
  tmp___0 = dumbfile_getc(f);
#line 442
  instrument->new_note_action = (unsigned char )tmp___0;
#line 443
  tmp___1 = dumbfile_getc(f);
#line 443
  instrument->dup_check_type = (unsigned char )tmp___1;
#line 444
  tmp___2 = dumbfile_getc(f);
#line 444
  instrument->dup_check_action = (unsigned char )tmp___2;
#line 445
  instrument->fadeout = dumbfile_igetw(f);
#line 446
  tmp___3 = dumbfile_getc(f);
#line 446
  instrument->pp_separation = (unsigned char )tmp___3;
#line 447
  tmp___4 = dumbfile_getc(f);
#line 447
  instrument->pp_centre = (unsigned char )tmp___4;
#line 448
  tmp___5 = dumbfile_getc(f);
#line 448
  instrument->global_volume = (unsigned char )tmp___5;
#line 449
  tmp___6 = dumbfile_getc(f);
#line 449
  instrument->default_pan = (unsigned char )tmp___6;
#line 450
  tmp___7 = dumbfile_getc(f);
#line 450
  instrument->random_volume = (unsigned char )tmp___7;
#line 451
  tmp___8 = dumbfile_getc(f);
#line 451
  instrument->random_pan = (unsigned char )tmp___8;
#line 456
  dumbfile_skip(f, 4L);
#line 458
  dumbfile_getnc((char *)(instrument->name), 26L, f);
#line 459
  instrument->name[26] = (unsigned char)0;
#line 461
  tmp___9 = dumbfile_getc(f);
#line 461
  instrument->filter_cutoff = (unsigned char )tmp___9;
#line 462
  tmp___10 = dumbfile_getc(f);
#line 462
  instrument->filter_resonance = (unsigned char )tmp___10;
#line 465
  dumbfile_skip(f, 4L);
#line 467
  n = 0;
  }
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (n < 120)) {
#line 467
      goto while_break;
    }
    {
#line 468
    tmp___11 = dumbfile_getc(f);
#line 468
    instrument->map_note[n] = (unsigned char )tmp___11;
#line 469
    tmp___12 = dumbfile_getc(f);
#line 469
    instrument->map_sample[n] = (unsigned short )tmp___12;
#line 467
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  tmp___13 = dumbfile_error(f);
  }
#line 472
  if (tmp___13) {
#line 473
    return (-1);
  }
  {
#line 475
  tmp___14 = it_read_envelope___0(& instrument->volume_envelope, f);
  }
#line 475
  if (tmp___14) {
#line 475
    return (-1);
  }
  {
#line 476
  tmp___15 = it_read_envelope___0(& instrument->pan_envelope, f);
  }
#line 476
  if (tmp___15) {
#line 476
    return (-1);
  }
  {
#line 477
  tmp___16 = it_read_envelope___0(& instrument->pitch_envelope, f);
  }
#line 477
  if (tmp___16) {
#line 477
    return (-1);
  }
#line 479
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_sample_header___0(IT_SAMPLE *sample , unsigned char *convert ,
                                     long *offset , DUMBFILE *f ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 486
  tmp = dumbfile_mgetl(f);
  }
#line 486
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 83U)) {
#line 487
    return (-1);
  }
  {
#line 489
  dumbfile_getnc((char *)(sample->filename), 13L, f);
#line 490
  sample->filename[13] = (unsigned char)0;
#line 492
  tmp___0 = dumbfile_getc(f);
#line 492
  sample->global_volume = (unsigned char )tmp___0;
#line 493
  tmp___1 = dumbfile_getc(f);
#line 493
  sample->flags = (unsigned char )tmp___1;
#line 494
  tmp___2 = dumbfile_getc(f);
#line 494
  sample->default_volume = (unsigned char )tmp___2;
#line 496
  dumbfile_getnc((char *)(sample->name), 26L, f);
#line 497
  sample->name[26] = (unsigned char)0;
#line 499
  tmp___3 = dumbfile_getc(f);
#line 499
  *convert = (unsigned char )tmp___3;
#line 500
  tmp___4 = dumbfile_getc(f);
#line 500
  sample->default_pan = (unsigned char )tmp___4;
#line 501
  sample->length = dumbfile_igetl(f);
#line 502
  sample->loop_start = dumbfile_igetl(f);
#line 503
  sample->loop_end = dumbfile_igetl(f);
#line 504
  sample->C5_speed = dumbfile_igetl(f);
#line 505
  sample->sus_loop_start = dumbfile_igetl(f);
#line 506
  sample->sus_loop_end = dumbfile_igetl(f);
  }
#line 509
  if ((int )sample->flags & 4) {
#line 510
    sample->length >>= 1;
#line 511
    sample->loop_start >>= 1;
#line 512
    sample->loop_end >>= 1;
#line 513
    sample->C5_speed >>= 1;
#line 514
    sample->sus_loop_start >>= 1;
#line 515
    sample->sus_loop_end >>= 1;
  }
#line 519
  if ((int )sample->flags & 1) {
#line 520
    if (sample->length <= 0L) {
#line 521
      sample->flags = (unsigned char )((int )sample->flags & -2);
    } else {
#line 523
      if ((unsigned int )sample->loop_end > (unsigned int )sample->length) {
#line 524
        sample->flags = (unsigned char )((int )sample->flags & -17);
      } else
#line 525
      if ((unsigned int )sample->loop_start >= (unsigned int )sample->loop_end) {
#line 526
        sample->flags = (unsigned char )((int )sample->flags & -17);
      }
#line 528
      if ((unsigned int )sample->sus_loop_end > (unsigned int )sample->length) {
#line 529
        sample->flags = (unsigned char )((int )sample->flags & -33);
      } else
#line 530
      if ((unsigned int )sample->sus_loop_start >= (unsigned int )sample->sus_loop_end) {
#line 531
        sample->flags = (unsigned char )((int )sample->flags & -33);
      }
#line 534
      if ((int )sample->flags & 16) {
#line 535
        if ((int )sample->flags & 32) {
#line 535
          if (sample->sus_loop_end >= sample->loop_end) {
#line 536
            sample->length = sample->sus_loop_end;
          } else {
#line 538
            sample->length = sample->loop_end;
          }
        } else {
#line 538
          sample->length = sample->loop_end;
        }
      }
    }
  }
  {
#line 543
  *offset = dumbfile_igetl(f);
#line 545
  tmp___5 = dumbfile_getc(f);
#line 545
  sample->vibrato_speed = (unsigned char )tmp___5;
#line 546
  tmp___6 = dumbfile_getc(f);
#line 546
  sample->vibrato_depth = (unsigned char )tmp___6;
#line 547
  tmp___7 = dumbfile_getc(f);
#line 547
  sample->vibrato_rate = (unsigned char )tmp___7;
#line 548
  tmp___8 = dumbfile_getc(f);
#line 548
  sample->vibrato_waveform = (unsigned char )tmp___8;
#line 550
  tmp___9 = dumbfile_error(f);
  }
#line 550
  return (tmp___9);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static long it_read_sample_data___0(int cmwt , IT_SAMPLE *sample , unsigned char convert ,
                                    DUMBFILE *f ) 
{ 
  long n ;
  long datasize ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 559
  datasize = sample->length;
#line 560
  if ((int )sample->flags & 4) {
#line 560
    datasize <<= 1;
  }
#line 562
  if ((int )sample->flags & 2) {
#line 562
    tmp = 2;
  } else {
#line 562
    tmp = 1;
  }
  {
#line 562
  sample->data = malloc((size_t )(datasize * (long )tmp));
  }
#line 563
  if (! sample->data) {
#line 564
    return (-1L);
  }
#line 566
  if ((int )sample->flags & 8) {
#line 571
    if ((int )sample->flags & 4) {
      {
#line 572
      exit(37);
      }
    }
#line 579
    if ((int )sample->flags & 2) {
      {
#line 580
      decompress16___0(f, (short *)sample->data, (int )datasize, cmwt);
      }
    } else {
      {
#line 582
      decompress8___0(f, (signed char *)sample->data, (int )datasize, cmwt);
      }
    }
  } else
#line 583
  if ((int )sample->flags & 2) {
#line 584
    if ((int )convert & 2) {
#line 585
      n = 0L;
      {
#line 585
      while (1) {
        while_continue: /* CIL Label */ ;
#line 585
        if (! (n < datasize)) {
#line 585
          goto while_break;
        }
        {
#line 586
        tmp___0 = dumbfile_mgetw(f);
#line 586
        *((short *)sample->data + n) = (short )tmp___0;
#line 585
        n ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 588
      n = 0L;
      {
#line 588
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 588
        if (! (n < datasize)) {
#line 588
          goto while_break___0;
        }
        {
#line 589
        tmp___1 = dumbfile_igetw(f);
#line 589
        *((short *)sample->data + n) = (short )tmp___1;
#line 588
        n ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 591
    n = 0L;
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 591
      if (! (n < datasize)) {
#line 591
        goto while_break___1;
      }
      {
#line 592
      tmp___2 = dumbfile_getc(f);
#line 592
      *((signed char *)sample->data + n) = (signed char )tmp___2;
#line 591
      n ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 594
  tmp___3 = dumbfile_error(f);
  }
#line 594
  if (tmp___3) {
#line 595
    return (-1L);
  }
#line 597
  if (! ((int )convert & 1)) {
#line 599
    if ((int )sample->flags & 2) {
#line 600
      n = 0L;
      {
#line 600
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 600
        if (! (n < datasize)) {
#line 600
          goto while_break___2;
        }
#line 601
        *((short *)sample->data + n) = (short )((int )*((short *)sample->data + n) ^ 32768);
#line 600
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 603
      n = 0L;
      {
#line 603
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 603
        if (! (n < datasize)) {
#line 603
          goto while_break___3;
        }
#line 604
        *((signed char *)sample->data + n) = (signed char )((int )*((signed char *)sample->data + n) ^ 128);
#line 603
        n ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 614
  return (0L);
}
}
#line 690
static int it_read_pattern___0(IT_PATTERN *pattern , DUMBFILE *f , unsigned char *buffer___0 ) ;
#line 690 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static unsigned char const   used___0[16]  = 
#line 690
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )5};
#line 623 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_read_pattern___0(IT_PATTERN *pattern , DUMBFILE *f , unsigned char *buffer___0 ) 
{ 
  unsigned char cmask[64] ;
  unsigned char cnote[64] ;
  unsigned char cinstrument[64] ;
  unsigned char cvolpan[64] ;
  unsigned char ceffect[64] ;
  unsigned char ceffectvalue[64] ;
  IT_ENTRY *dupentry[64] ;
  int n_entries ;
  int buflen ;
  int bufpos ;
  IT_ENTRY *entry ;
  unsigned char channel ;
  unsigned char mask ;
  int i ;
  int tmp ;
  int tmp___0 ;
  unsigned char b ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned char b___0 ;
  int tmp___4 ;
  int i___0 ;
  int tmp___5 ;
  unsigned char tmp___6 ;
  int tmp___7 ;
  unsigned char tmp___8 ;
  int tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  unsigned char tmp___12 ;
  int tmp___13 ;
  unsigned char tmp___14 ;
  int tmp___15 ;
  FILE *f___0 ;
  FILE *tmp___16 ;

  {
  {
#line 635
  n_entries = 0;
#line 637
  bufpos = 0;
#line 644
  memset((void *)(cmask), 0, sizeof(cmask));
#line 645
  memset((void *)(cnote), 0, sizeof(cnote));
#line 646
  memset((void *)(cinstrument), 0, sizeof(cinstrument));
#line 647
  memset((void *)(cvolpan), 0, sizeof(cvolpan));
#line 648
  memset((void *)(ceffect), 0, sizeof(ceffect));
#line 649
  memset((void *)(ceffectvalue), 0, sizeof(ceffectvalue));
#line 653
  i = 0;
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (i < 64)) {
#line 653
      goto while_break;
    }
#line 653
    dupentry[i] = (IT_ENTRY *)((void *)0);
#line 653
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  buflen = dumbfile_igetw(f);
#line 658
  pattern->n_rows = dumbfile_igetw(f);
#line 661
  dumbfile_skip(f, 4L);
#line 663
  tmp = dumbfile_error(f);
  }
#line 663
  if (tmp) {
#line 664
    return (-1);
  }
  {
#line 667
  dumbfile_getnc((char *)buffer___0, (long )buflen, f);
#line 669
  tmp___0 = dumbfile_error(f);
  }
#line 669
  if (tmp___0) {
#line 670
    return (-1);
  }
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 673
    if (! (bufpos < buflen)) {
#line 673
      goto while_break___0;
    }
#line 674
    tmp___1 = bufpos;
#line 674
    bufpos ++;
#line 674
    b = *(buffer___0 + tmp___1);
#line 676
    if ((int )b == 0) {
#line 678
      n_entries ++;
#line 679
      goto while_continue___0;
    }
#line 682
    channel = (unsigned char )(((int )b - 1) & 63);
#line 684
    if ((int )b & 128) {
#line 685
      tmp___2 = bufpos;
#line 685
      bufpos ++;
#line 685
      mask = *(buffer___0 + tmp___2);
#line 685
      cmask[channel] = mask;
    } else {
#line 687
      mask = cmask[channel];
    }
#line 691
    n_entries += (int )mask != 0;
#line 692
    bufpos += (int )used___0[(int )mask & 15];
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 696
  pattern->n_entries = n_entries;
#line 698
  tmp___3 = malloc((unsigned long )n_entries * sizeof(*(pattern->entry)));
#line 698
  pattern->entry = (IT_ENTRY *)tmp___3;
  }
#line 700
  if (! pattern->entry) {
#line 701
    return (-1);
  }
  {
#line 703
  bufpos = 0;
#line 704
  memset((void *)(cmask), 0, sizeof(cmask));
#line 706
  entry = pattern->entry;
  }
  {
#line 708
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 708
    if (! (bufpos < buflen)) {
#line 708
      goto while_break___1;
    }
#line 709
    tmp___4 = bufpos;
#line 709
    bufpos ++;
#line 709
    b___0 = *(buffer___0 + tmp___4);
#line 711
    if ((int )b___0 == 0) {
#line 713
      entry->channel = (unsigned char)255;
#line 714
      entry ++;
#line 718
      i___0 = 0;
      {
#line 718
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 718
        if (! (i___0 < 64)) {
#line 718
          goto while_break___2;
        }
#line 718
        dupentry[i___0] = (IT_ENTRY *)((void *)0);
#line 718
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 721
      goto while_continue___1;
    }
#line 724
    channel = (unsigned char )(((int )b___0 - 1) & 63);
#line 726
    if ((int )b___0 & 128) {
#line 727
      tmp___5 = bufpos;
#line 727
      bufpos ++;
#line 727
      mask = *(buffer___0 + tmp___5);
#line 727
      cmask[channel] = mask;
    } else {
#line 729
      mask = cmask[channel];
    }
#line 731
    if (mask) {
#line 732
      entry->mask = (unsigned char )(((int )mask & 15) | ((int )mask >> 4));
#line 733
      entry->channel = channel;
#line 735
      if ((int )mask & 1) {
#line 736
        tmp___7 = bufpos;
#line 736
        bufpos ++;
#line 736
        tmp___6 = *(buffer___0 + tmp___7);
#line 736
        entry->note = tmp___6;
#line 736
        cnote[channel] = tmp___6;
      } else
#line 737
      if ((int )mask & (1 << 4)) {
#line 738
        entry->note = cnote[channel];
      }
#line 740
      if ((int )mask & 2) {
#line 741
        tmp___9 = bufpos;
#line 741
        bufpos ++;
#line 741
        tmp___8 = *(buffer___0 + tmp___9);
#line 741
        entry->instrument = tmp___8;
#line 741
        cinstrument[channel] = tmp___8;
      } else
#line 742
      if ((int )mask & (2 << 4)) {
#line 743
        entry->instrument = cinstrument[channel];
      }
#line 745
      if ((int )mask & 4) {
#line 746
        tmp___11 = bufpos;
#line 746
        bufpos ++;
#line 746
        tmp___10 = *(buffer___0 + tmp___11);
#line 746
        entry->volpan = tmp___10;
#line 746
        cvolpan[channel] = tmp___10;
      } else
#line 747
      if ((int )mask & (4 << 4)) {
#line 748
        entry->volpan = cvolpan[channel];
      }
#line 750
      if ((int )mask & 8) {
#line 751
        tmp___13 = bufpos;
#line 751
        bufpos ++;
#line 751
        tmp___12 = *(buffer___0 + tmp___13);
#line 751
        entry->effect = tmp___12;
#line 751
        ceffect[channel] = tmp___12;
#line 752
        tmp___15 = bufpos;
#line 752
        bufpos ++;
#line 752
        tmp___14 = *(buffer___0 + tmp___15);
#line 752
        entry->effectvalue = tmp___14;
#line 752
        ceffectvalue[channel] = tmp___14;
      } else {
#line 754
        entry->effect = ceffect[channel];
#line 755
        entry->effectvalue = ceffectvalue[channel];
      }
#line 759
      if (dupentry[channel]) {
        {
#line 760
        tmp___16 = fopen((char const   */* __restrict  */)"dupentry.txt", (char const   */* __restrict  */)"a");
#line 760
        f___0 = tmp___16;
        }
#line 761
        if (! f___0) {
          {
#line 761
          abort();
          }
        }
        {
#line 762
        fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"Two events on channel %d:",
                (int )channel);
#line 763
        fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"  Event #1:");
        }
#line 764
        if ((int )(dupentry[channel])->mask & 1) {
          {
#line 764
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )(dupentry[channel])->note);
          }
        } else {
          {
#line 764
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 765
        if ((int )(dupentry[channel])->mask & 2) {
          {
#line 765
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )(dupentry[channel])->instrument);
          }
        } else {
          {
#line 765
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 766
        if ((int )(dupentry[channel])->mask & 4) {
          {
#line 766
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )(dupentry[channel])->volpan);
          }
        } else {
          {
#line 766
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 767
        if ((int )(dupentry[channel])->mask & 8) {
          {
#line 767
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %c%02X\n",
                  64 + (int )(dupentry[channel])->effect, (int )(dupentry[channel])->effectvalue);
          }
        } else {
          {
#line 767
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...\n");
          }
        }
        {
#line 768
        fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"  Event #2:");
        }
#line 769
        if ((int )entry->mask & 1) {
          {
#line 769
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )entry->note);
          }
        } else {
          {
#line 769
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 770
        if ((int )entry->mask & 2) {
          {
#line 770
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )entry->instrument);
          }
        } else {
          {
#line 770
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 771
        if ((int )entry->mask & 4) {
          {
#line 771
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %03d",
                  (int )entry->volpan);
          }
        } else {
          {
#line 771
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...");
          }
        }
#line 772
        if ((int )entry->mask & 8) {
          {
#line 772
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" %c%02X\n",
                  64 + (int )entry->effect, (int )entry->effectvalue);
          }
        } else {
          {
#line 772
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)" ...\n");
          }
        }
        {
#line 773
        fclose(f___0);
        }
      }
#line 775
      dupentry[channel] = entry;
#line 778
      entry ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 784
  return (0);
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static int it_component_compare___0(void const   *e1 , void const   *e2 ) 
{ 


  {
#line 813
  return ((int )(((IT_COMPONENT const   *)e1)->offset - ((IT_COMPONENT const   *)e2)->offset));
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/it/itread.c"
static sigdata_t *it_load_sigdata___0(DUMBFILE *f ) 
{ 
  DUMB_IT_SIGDATA *sigdata ;
  int cwt ;
  int cmwt ;
  int special ;
  int message_length ;
  int message_offset ;
  IT_COMPONENT *component ;
  int n_components ;
  unsigned char sample_convert[256] ;
  int n ;
  unsigned char *buffer___0 ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  long offset ;
  long tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  unsigned char mididata[32] ;
  int i ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char len ;
  int j ;
  int leftdigit ;
  long tmp___16 ;
  unsigned char tmp___17 ;
  unsigned char tmp___18 ;
  unsigned char tmp___19 ;
  unsigned char tmp___20 ;
  unsigned char tmp___21 ;
  unsigned char len___0 ;
  int j___0 ;
  int leftdigit___0 ;
  unsigned char tmp___22 ;
  unsigned char tmp___23 ;
  unsigned char tmp___24 ;
  unsigned char tmp___25 ;
  void *tmp___26 ;
  long offset___0 ;
  int m ;
  int tmp___27 ;
  void *tmp___28 ;
  long tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  short *sample ;
  int tmp___32 ;
  long tmp___33 ;

  {
  {
#line 828
  n_components = 0;
#line 836
  tmp = dumbfile_mgetl(f);
  }
#line 836
  if (tmp != (long )((((73U << 24) | (77U << 16)) | (80U << 8)) | 77U)) {
#line 837
    return ((void *)0);
  }
  {
#line 839
  tmp___0 = malloc(sizeof(*sigdata));
#line 839
  sigdata = (DUMB_IT_SIGDATA *)tmp___0;
  }
#line 841
  if (! sigdata) {
#line 842
    return ((void *)0);
  }
  {
#line 844
  sigdata->song_message = (unsigned char *)((void *)0);
#line 845
  sigdata->order = (unsigned char *)((void *)0);
#line 846
  sigdata->instrument = (IT_INSTRUMENT *)((void *)0);
#line 847
  sigdata->sample = (IT_SAMPLE *)((void *)0);
#line 848
  sigdata->pattern = (IT_PATTERN *)((void *)0);
#line 849
  sigdata->midi = (IT_MIDI *)((void *)0);
#line 850
  sigdata->checkpoint = (IT_CHECKPOINT *)((void *)0);
#line 852
  dumbfile_getnc((char *)(sigdata->name), 26L, f);
#line 853
  sigdata->name[26] = (unsigned char)0;
#line 856
  dumbfile_skip(f, 2L);
#line 858
  sigdata->n_orders = dumbfile_igetw(f);
#line 859
  sigdata->n_instruments = dumbfile_igetw(f);
#line 860
  sigdata->n_samples = dumbfile_igetw(f);
#line 861
  sigdata->n_patterns = dumbfile_igetw(f);
#line 863
  cwt = dumbfile_igetw(f);
#line 864
  cmwt = dumbfile_igetw(f);
#line 866
  sigdata->flags = dumbfile_igetw(f);
#line 867
  special = dumbfile_igetw(f);
#line 869
  sigdata->global_volume = dumbfile_getc(f);
#line 870
  sigdata->mixing_volume = dumbfile_getc(f);
#line 871
  sigdata->speed = dumbfile_getc(f);
  }
#line 872
  if (sigdata->speed == 0) {
#line 872
    sigdata->speed = 6;
  }
  {
#line 873
  sigdata->tempo = dumbfile_getc(f);
#line 874
  sigdata->pan_separation = dumbfile_getc(f);
#line 877
  dumbfile_skip(f, 1L);
#line 879
  message_length = dumbfile_igetw(f);
#line 880
  tmp___1 = dumbfile_igetl(f);
#line 880
  message_offset = (int )tmp___1;
#line 883
  dumbfile_skip(f, 4L);
#line 885
  dumbfile_getnc((char *)(sigdata->channel_pan), 64L, f);
#line 886
  dumbfile_getnc((char *)(sigdata->channel_volume), 64L, f);
#line 888
  tmp___2 = dumbfile_error(f);
  }
#line 888
  if (tmp___2) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_orders <= 0) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_instruments > 256) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_samples > 256) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  } else
#line 888
  if (sigdata->n_patterns > 256) {
    {
#line 889
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 890
    return ((void *)0);
  }
  {
#line 893
  tmp___3 = malloc((size_t )sigdata->n_orders);
#line 893
  sigdata->order = (unsigned char *)tmp___3;
  }
#line 894
  if (! sigdata->order) {
    {
#line 895
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 896
    return ((void *)0);
  }
#line 899
  if (sigdata->n_instruments) {
    {
#line 900
    tmp___4 = malloc((unsigned long )sigdata->n_instruments * sizeof(*(sigdata->instrument)));
#line 900
    sigdata->instrument = (IT_INSTRUMENT *)tmp___4;
    }
#line 901
    if (! sigdata->instrument) {
      {
#line 902
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 903
      return ((void *)0);
    }
  }
#line 907
  if (sigdata->n_samples) {
    {
#line 908
    tmp___5 = malloc((unsigned long )sigdata->n_samples * sizeof(*(sigdata->sample)));
#line 908
    sigdata->sample = (IT_SAMPLE *)tmp___5;
    }
#line 909
    if (! sigdata->sample) {
      {
#line 910
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 911
      return ((void *)0);
    }
#line 913
    n = 0;
    {
#line 913
    while (1) {
      while_continue: /* CIL Label */ ;
#line 913
      if (! (n < sigdata->n_samples)) {
#line 913
        goto while_break;
      }
#line 914
      (sigdata->sample + n)->data = (void *)0;
#line 913
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 917
  if (sigdata->n_patterns) {
    {
#line 918
    tmp___6 = malloc((unsigned long )sigdata->n_patterns * sizeof(*(sigdata->pattern)));
#line 918
    sigdata->pattern = (IT_PATTERN *)tmp___6;
    }
#line 919
    if (! sigdata->pattern) {
      {
#line 920
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 921
      return ((void *)0);
    }
#line 923
    n = 0;
    {
#line 923
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 923
      if (! (n < sigdata->n_patterns)) {
#line 923
        goto while_break___0;
      }
#line 924
      (sigdata->pattern + n)->entry = (IT_ENTRY *)((void *)0);
#line 923
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 927
  dumbfile_getnc((char *)sigdata->order, (long )sigdata->n_orders, f);
#line 928
  sigdata->restart_position = (unsigned char)0;
#line 930
  tmp___7 = malloc(769UL * sizeof(*component));
#line 930
  component = (IT_COMPONENT *)tmp___7;
  }
#line 931
  if (! component) {
    {
#line 932
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 933
    return ((void *)0);
  }
#line 936
  if (special & 1) {
#line 937
    (component + n_components)->type = (unsigned char)1;
#line 938
    (component + n_components)->offset = (long )message_offset;
#line 939
    (component + n_components)->sampfirst = (short)-1;
#line 940
    n_components ++;
  }
#line 943
  n = 0;
  {
#line 943
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 943
    if (! (n < sigdata->n_instruments)) {
#line 943
      goto while_break___1;
    }
    {
#line 944
    (component + n_components)->type = (unsigned char)2;
#line 945
    (component + n_components)->n = (unsigned char )n;
#line 946
    (component + n_components)->offset = dumbfile_igetl(f);
#line 947
    (component + n_components)->sampfirst = (short)-1;
#line 948
    n_components ++;
#line 943
    n ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 951
  n = 0;
  {
#line 951
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 951
    if (! (n < sigdata->n_samples)) {
#line 951
      goto while_break___2;
    }
    {
#line 952
    (component + n_components)->type = (unsigned char)4;
#line 953
    (component + n_components)->n = (unsigned char )n;
#line 954
    (component + n_components)->offset = dumbfile_igetl(f);
#line 955
    (component + n_components)->sampfirst = (short)-1;
#line 956
    n_components ++;
#line 951
    n ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 959
  n = 0;
  {
#line 959
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 959
    if (! (n < sigdata->n_patterns)) {
#line 959
      goto while_break___3;
    }
    {
#line 960
    tmp___8 = dumbfile_igetl(f);
#line 960
    offset = tmp___8;
    }
#line 961
    if (offset) {
#line 962
      (component + n_components)->type = (unsigned char)3;
#line 963
      (component + n_components)->n = (unsigned char )n;
#line 964
      (component + n_components)->offset = offset;
#line 965
      (component + n_components)->sampfirst = (short)-1;
#line 966
      n_components ++;
    } else {
#line 969
      (sigdata->pattern + n)->n_rows = 64;
#line 970
      (sigdata->pattern + n)->n_entries = 0;
    }
#line 959
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 974
  tmp___9 = dumbfile_error(f);
  }
#line 974
  if (tmp___9) {
    {
#line 975
    free((void *)component);
#line 976
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 977
    return ((void *)0);
  }
#line 980
  if (! (sigdata->flags & 128) != ! (special & 8)) {
#line 981
    if (sigdata->flags & 128) {
#line 981
      tmp___10 = "=SET=";
    } else {
#line 981
      tmp___10 = "clear";
    }
    {
#line 981
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Flags   Bit 7 (\"Request embedded MIDI configuration\"): %s\n",
            tmp___10);
    }
#line 982
    if (special & 8) {
#line 982
      tmp___11 = "=SET=";
    } else {
#line 982
      tmp___11 = "clear";
    }
    {
#line 982
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Special Bit 3     (\"MIDI configuration embedded\")    : %s\n",
            tmp___11);
#line 983
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"entheh would like to investigate this IT file.\n");
#line 984
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please contact him! entheh@users.sf.net\n");
    }
  }
#line 987
  if (special & 8) {
    {
#line 991
    tmp___12 = malloc(sizeof(*(sigdata->midi)));
#line 991
    sigdata->midi = (IT_MIDI *)tmp___12;
    }
#line 992
    if (! sigdata->midi) {
      {
#line 993
      free((void *)component);
#line 994
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 995
      return ((void *)0);
    }
    {
#line 999
    i = dumbfile_igetw(f);
#line 1000
    tmp___13 = dumbfile_error(f);
    }
#line 1000
    if (tmp___13) {
      {
#line 1001
      free((void *)component);
#line 1002
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1003
      return ((void *)0);
    } else {
      {
#line 1000
      tmp___14 = dumbfile_skip(f, (long )(8 * i));
      }
#line 1000
      if (tmp___14) {
        {
#line 1001
        free((void *)component);
#line 1002
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1003
        return ((void *)0);
      }
    }
    {
#line 1007
    tmp___15 = dumbfile_skip(f, 288L);
    }
#line 1007
    if (tmp___15) {
      {
#line 1008
      free((void *)component);
#line 1009
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1010
      return ((void *)0);
    }
#line 1012
    i = 0;
    {
#line 1012
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1012
      if (! (i < 16)) {
#line 1012
        goto while_break___4;
      }
      {
#line 1013
      len = (unsigned char)0;
#line 1014
      leftdigit = -1;
#line 1015
      tmp___16 = dumbfile_getnc((char *)(mididata), 32L, f);
      }
#line 1015
      if (tmp___16 < 32L) {
        {
#line 1016
        free((void *)component);
#line 1017
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1018
        return ((void *)0);
      }
#line 1020
      (sigdata->midi)->SFmacroz[i] = (unsigned short)0;
#line 1021
      j = 0;
      {
#line 1021
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1021
        if (! (j < 32)) {
#line 1021
          goto while_break___5;
        }
#line 1022
        if (leftdigit >= 0) {
#line 1023
          if ((int )mididata[j] == 0) {
#line 1024
            tmp___17 = len;
#line 1024
            len = (unsigned char )((int )len + 1);
#line 1024
            (sigdata->midi)->SFmacro[i][tmp___17] = (unsigned char )leftdigit;
#line 1025
            goto while_break___5;
          } else
#line 1026
          if ((int )mididata[j] == 32) {
#line 1027
            tmp___18 = len;
#line 1027
            len = (unsigned char )((int )len + 1);
#line 1027
            (sigdata->midi)->SFmacro[i][tmp___18] = (unsigned char )leftdigit;
          } else
#line 1028
          if ((int )mididata[j] >= 48) {
#line 1028
            if ((int )mididata[j] <= 57) {
#line 1029
              tmp___19 = len;
#line 1029
              len = (unsigned char )((int )len + 1);
#line 1029
              (sigdata->midi)->SFmacro[i][tmp___19] = (unsigned char )((leftdigit << 4) | ((int )mididata[j] - 48));
            } else {
#line 1028
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1030
          if ((int )mididata[j] >= 65) {
#line 1030
            if ((int )mididata[j] <= 70) {
#line 1031
              tmp___20 = len;
#line 1031
              len = (unsigned char )((int )len + 1);
#line 1031
              (sigdata->midi)->SFmacro[i][tmp___20] = (unsigned char )((leftdigit << 4) | (((int )mididata[j] - 65) + 10));
            }
          }
#line 1032
          leftdigit = -1;
        } else
#line 1033
        if ((int )mididata[j] == 0) {
#line 1034
          goto while_break___5;
        } else
#line 1035
        if ((int )mididata[j] == 122) {
#line 1036
          tmp___21 = len;
#line 1036
          len = (unsigned char )((int )len + 1);
#line 1036
          (sigdata->midi)->SFmacroz[i] = (unsigned short )((int )(sigdata->midi)->SFmacroz[i] | (1 << (int )tmp___21));
        } else
#line 1037
        if ((int )mididata[j] >= 48) {
#line 1037
          if ((int )mididata[j] <= 57) {
#line 1038
            leftdigit = (int )mididata[j] - 48;
          } else {
#line 1037
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1039
        if ((int )mididata[j] >= 65) {
#line 1039
          if ((int )mididata[j] <= 70) {
#line 1040
            leftdigit = ((int )mididata[j] - 65) + 10;
          }
        }
#line 1021
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1042
      (sigdata->midi)->SFmacrolen[i] = len;
#line 1012
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1044
    i = 0;
    {
#line 1044
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1044
      if (! (i < 128)) {
#line 1044
        goto while_break___6;
      }
      {
#line 1045
      len___0 = (unsigned char)0;
#line 1046
      leftdigit___0 = -1;
#line 1047
      dumbfile_getnc((char *)(mididata), 32L, f);
#line 1048
      j___0 = 0;
      }
      {
#line 1048
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1048
        if (! (j___0 < 32)) {
#line 1048
          goto while_break___7;
        }
#line 1049
        if (leftdigit___0 >= 0) {
#line 1050
          if ((int )mididata[j___0] == 0) {
#line 1051
            tmp___22 = len___0;
#line 1051
            len___0 = (unsigned char )((int )len___0 + 1);
#line 1051
            (sigdata->midi)->Zmacro[i][tmp___22] = (unsigned char )leftdigit___0;
#line 1052
            goto while_break___7;
          } else
#line 1053
          if ((int )mididata[j___0] == 32) {
#line 1054
            tmp___23 = len___0;
#line 1054
            len___0 = (unsigned char )((int )len___0 + 1);
#line 1054
            (sigdata->midi)->Zmacro[i][tmp___23] = (unsigned char )leftdigit___0;
          } else
#line 1055
          if ((int )mididata[j___0] >= 48) {
#line 1055
            if ((int )mididata[j___0] <= 57) {
#line 1056
              tmp___24 = len___0;
#line 1056
              len___0 = (unsigned char )((int )len___0 + 1);
#line 1056
              (sigdata->midi)->Zmacro[i][tmp___24] = (unsigned char )((leftdigit___0 << 4) | ((int )mididata[j___0] - 48));
            } else {
#line 1055
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1057
          if ((int )mididata[j___0] >= 65) {
#line 1057
            if ((int )mididata[j___0] <= 70) {
#line 1058
              tmp___25 = len___0;
#line 1058
              len___0 = (unsigned char )((int )len___0 + 1);
#line 1058
              (sigdata->midi)->Zmacro[i][tmp___25] = (unsigned char )((leftdigit___0 << 4) | (((int )mididata[j___0] - 65) + 10));
            }
          }
#line 1059
          leftdigit___0 = -1;
        } else
#line 1060
        if ((int )mididata[j___0] == 0) {
#line 1061
          goto while_break___7;
        } else
#line 1062
        if ((int )mididata[j___0] >= 48) {
#line 1062
          if ((int )mididata[j___0] <= 57) {
#line 1063
            leftdigit___0 = (int )mididata[j___0] - 48;
          } else {
#line 1062
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1064
        if ((int )mididata[j___0] >= 65) {
#line 1064
          if ((int )mididata[j___0] <= 70) {
#line 1065
            leftdigit___0 = ((int )mididata[j___0] - 65) + 10;
          }
        }
#line 1048
        j___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1067
      (sigdata->midi)->Zmacrolen[i] = len___0;
#line 1044
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1071
  sigdata->flags &= 63;
#line 1073
  qsort((void *)component, (size_t )n_components, sizeof(IT_COMPONENT ), & it_component_compare___0);
#line 1075
  tmp___26 = malloc((size_t )65536);
#line 1075
  buffer___0 = (unsigned char *)tmp___26;
  }
#line 1076
  if (! buffer___0) {
    {
#line 1077
    free((void *)component);
#line 1078
    _dumb_it_unload_sigdata((sigdata_t *)sigdata);
    }
#line 1079
    return ((void *)0);
  }
#line 1082
  n = 0;
  {
#line 1082
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1082
    if (! (n < n_components)) {
#line 1082
      goto while_break___8;
    }
    {
#line 1086
    tmp___27 = it_seek___0(f, (component + n)->offset);
    }
#line 1086
    if (tmp___27) {
      {
#line 1087
      free((void *)buffer___0);
#line 1088
      free((void *)component);
#line 1089
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1090
      return ((void *)0);
    }
    {
#line 1095
    if ((int )(component + n)->type == 1) {
#line 1095
      goto case_1;
    }
#line 1108
    if ((int )(component + n)->type == 2) {
#line 1108
      goto case_2;
    }
#line 1122
    if ((int )(component + n)->type == 3) {
#line 1122
      goto case_3;
    }
#line 1131
    if ((int )(component + n)->type == 4) {
#line 1131
      goto case_4;
    }
#line 1093
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1096
    tmp___28 = malloc((size_t )(message_length + 1));
#line 1096
    sigdata->song_message = (unsigned char *)tmp___28;
    }
#line 1097
    if (sigdata->song_message) {
      {
#line 1098
      tmp___29 = dumbfile_getnc((char *)sigdata->song_message, (long )message_length,
                                f);
      }
#line 1098
      if (tmp___29 < (long )message_length) {
        {
#line 1099
        free((void *)buffer___0);
#line 1100
        free((void *)component);
#line 1101
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1102
        return ((void *)0);
      }
#line 1104
      *(sigdata->song_message + message_length) = (unsigned char)0;
    }
#line 1106
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1109
    if (cmwt < 512) {
      {
#line 1110
      m = it_read_old_instrument___0(sigdata->instrument + (component + n)->n, f);
      }
    } else {
      {
#line 1112
      m = it_read_instrument___0(sigdata->instrument + (component + n)->n, f);
      }
    }
#line 1114
    if (m) {
      {
#line 1115
      free((void *)buffer___0);
#line 1116
      free((void *)component);
#line 1117
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1118
      return ((void *)0);
    }
#line 1120
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1123
    tmp___30 = it_read_pattern___0(sigdata->pattern + (component + n)->n, f, buffer___0);
    }
#line 1123
    if (tmp___30) {
      {
#line 1124
      free((void *)buffer___0);
#line 1125
      free((void *)component);
#line 1126
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1127
      return ((void *)0);
    }
#line 1129
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1132
    tmp___31 = it_read_sample_header___0(sigdata->sample + (component + n)->n, & sample_convert[(component + n)->n],
                                         & offset___0, f);
    }
#line 1132
    if (tmp___31) {
      {
#line 1133
      free((void *)buffer___0);
#line 1134
      free((void *)component);
#line 1135
      _dumb_it_unload_sigdata((sigdata_t *)sigdata);
      }
#line 1136
      return ((void *)0);
    }
#line 1139
    if ((int )(sigdata->sample + (component + n)->n)->flags & 1) {
#line 1142
      m = n + 1;
      {
#line 1142
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1142
        if (! (m < n_components)) {
#line 1142
          goto while_break___9;
        }
#line 1143
        if ((component + m)->offset > offset___0) {
#line 1144
          goto while_break___9;
        }
#line 1142
        m ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1145
      m --;
#line 1147
      sample = & (component + m)->sampfirst;
      {
#line 1149
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1149
        if ((int )*sample >= 0) {
#line 1149
          if (! ((component + *sample)->offset <= offset___0)) {
#line 1149
            goto while_break___10;
          }
        } else {
#line 1149
          goto while_break___10;
        }
#line 1150
        sample = & (component + *sample)->sampnext;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1152
      (component + n)->sampnext = *sample;
#line 1153
      *sample = (short )n;
#line 1155
      (component + n)->offset = offset___0;
    }
    switch_break: /* CIL Label */ ;
    }
#line 1159
    m = (int )(component + n)->sampfirst;
    {
#line 1161
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1161
      if (! (m >= 0)) {
#line 1161
        goto while_break___11;
      }
      {
#line 1162
      tmp___32 = it_seek___0(f, (component + m)->offset);
      }
#line 1162
      if (tmp___32) {
        {
#line 1163
        free((void *)buffer___0);
#line 1164
        free((void *)component);
#line 1165
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1166
        return ((void *)0);
      }
      {
#line 1169
      tmp___33 = it_read_sample_data___0(cmwt, sigdata->sample + (component + m)->n,
                                         sample_convert[(component + m)->n], f);
      }
#line 1169
      if (tmp___33) {
        {
#line 1170
        free((void *)buffer___0);
#line 1171
        free((void *)component);
#line 1172
        _dumb_it_unload_sigdata((sigdata_t *)sigdata);
        }
#line 1173
        return ((void *)0);
      }
#line 1176
      m = (int )(component + m)->sampnext;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1082
    n ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1180
  free((void *)buffer___0);
#line 1181
  free((void *)component);
#line 1183
  _dumb_it_fix_invalid_orders(sigdata);
  }
#line 1185
  return ((sigdata_t *)sigdata);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/helpers/clickrem.c"
static DUMB_CLICK *dumb_click_mergesort___0(DUMB_CLICK *click , int n_clicks ) 
{ 
  int i ;
  DUMB_CLICK *c1 ;
  DUMB_CLICK *c2 ;
  DUMB_CLICK **cp ;

  {
#line 93
  if (n_clicks <= 1) {
#line 93
    return (click);
  }
#line 96
  c1 = click;
#line 97
  cp = & c1;
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < n_clicks)) {
#line 98
      goto while_break;
    }
#line 98
    cp = & (*cp)->next;
#line 98
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  c2 = *cp;
#line 100
  *cp = (DUMB_CLICK *)((void *)0);
#line 103
  c1 = dumb_click_mergesort___0(c1, (n_clicks + 1) >> 1);
#line 104
  c2 = dumb_click_mergesort___0(c2, n_clicks >> 1);
#line 107
  cp = & click;
  }
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (c1) {
#line 108
      if (! c2) {
#line 108
        goto while_break___0;
      }
    } else {
#line 108
      goto while_break___0;
    }
#line 109
    if (c1->pos > c2->pos) {
#line 110
      *cp = c2;
#line 111
      c2 = c2->next;
    } else {
#line 113
      *cp = c1;
#line 114
      c1 = c1->next;
    }
#line 116
    cp = & (*cp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  if (c2) {
#line 119
    *cp = c2;
  } else {
#line 121
    *cp = c1;
  }
#line 123
  return (click);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/libdumb-0.9.3/src/core/atexit.c"
static DUMB_ATEXIT_PROC *dumb_atexit_proc___0  =    (DUMB_ATEXIT_PROC *)((void *)0);
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern int getchar(void) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
