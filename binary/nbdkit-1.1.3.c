/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 47 "../../include/nbdkit-plugin.h"
struct nbdkit_plugin {
   uint64_t _struct_size ;
   int _api_version ;
   int _thread_model ;
   char const   *name ;
   char const   *longname ;
   char const   *version ;
   char const   *description ;
   void (*load)(void) ;
   void (*unload)(void) ;
   int (*config)(char const   *key , char const   *value ) ;
   int (*config_complete)(void) ;
   char const   *config_help ;
   void *(*open)(int readonly ) ;
   void (*close)(void *handle ) ;
   int64_t (*get_size)(void *handle ) ;
   int (*can_write)(void *handle ) ;
   int (*can_flush)(void *handle ) ;
   int (*is_rotational)(void *handle ) ;
   int (*can_trim)(void *handle ) ;
   int (*pread)(void *handle , void *buf , uint32_t count , uint64_t offset ) ;
   int (*pwrite)(void *handle , void const   *buf , uint32_t count , uint64_t offset ) ;
   int (*flush)(void *handle ) ;
   int (*trim)(void *handle , uint32_t count , uint64_t offset ) ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 82 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
struct example3_handle {
   int fd ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 90 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
struct handle {
   int fd ;
};
#line 95 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
struct example2_handle {
   int fd ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_16 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_16 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_17 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_17 pthread_mutexattr_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 68 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
struct connection {
   int sockin ;
   int sockout ;
   pthread_mutex_t request_lock ;
   void *handle ;
   uint64_t exportsize ;
   int readonly ;
   int can_flush ;
   int is_rotational ;
   int can_trim ;
};
#line 40 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/protocol.h"
struct old_handshake {
   char nbdmagic[8] ;
   uint64_t version ;
   uint64_t exportsize ;
   uint16_t gflags ;
   uint16_t eflags ;
   char zeroes[124] ;
} __attribute__((__packed__)) ;
#line 63 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/protocol.h"
struct request {
   uint32_t magic ;
   uint32_t type ;
   uint64_t handle ;
   uint64_t offset ;
   uint32_t count ;
} __attribute__((__packed__)) ;
#line 72 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/protocol.h"
struct reply {
   uint32_t magic ;
   uint32_t error ;
   uint64_t handle ;
} __attribute__((__packed__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 54 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
struct tls {
   char const   *name ;
   size_t instance_num ;
   struct sockaddr *addr ;
   socklen_t addrlen ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 201 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
struct thread_data {
   int sock ;
   size_t instance_num ;
   struct sockaddr addr ;
   socklen_t addrlen ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 49 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static unsigned char bootsector[512]  = 
#line 49 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
  {      (unsigned char)250,      (unsigned char)184,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)142,      (unsigned char)208,      (unsigned char)188,      (unsigned char)0, 
        (unsigned char)176,      (unsigned char)184,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)142,      (unsigned char)216,      (unsigned char)142,      (unsigned char)192, 
        (unsigned char)251,      (unsigned char)190,      (unsigned char)0,      (unsigned char)124, 
        (unsigned char)191,      (unsigned char)0,      (unsigned char)6,      (unsigned char)185, 
        (unsigned char)0,      (unsigned char)2,      (unsigned char)243,      (unsigned char)164, 
        (unsigned char)234,      (unsigned char)33,      (unsigned char)6,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)190,      (unsigned char)190,      (unsigned char)7, 
        (unsigned char)56,      (unsigned char)4,      (unsigned char)117,      (unsigned char)11, 
        (unsigned char)131,      (unsigned char)198,      (unsigned char)16,      (unsigned char)129, 
        (unsigned char)254,      (unsigned char)254,      (unsigned char)7,      (unsigned char)117, 
        (unsigned char)243,      (unsigned char)235,      (unsigned char)22,      (unsigned char)180, 
        (unsigned char)2,      (unsigned char)176,      (unsigned char)1,      (unsigned char)187, 
        (unsigned char)0,      (unsigned char)124,      (unsigned char)178,      (unsigned char)128, 
        (unsigned char)138,      (unsigned char)116,      (unsigned char)1,      (unsigned char)139, 
        (unsigned char)76,      (unsigned char)2,      (unsigned char)205,      (unsigned char)19, 
        (unsigned char)234,      (unsigned char)0,      (unsigned char)124,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)235,      (unsigned char)254,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)225,      (unsigned char)91,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)0,      (unsigned char)131,      (unsigned char)188, 
        (unsigned char)49,      (unsigned char)12,      (unsigned char)128,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)31, 
        (unsigned char)3,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)85,      (unsigned char)170};
#line 115 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static unsigned char data[104857600]  ;
#line 121 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static void example1_load(void) 
{ 


  {
  {
#line 124
  memcpy((void */* __restrict  */)(data), (void const   */* __restrict  */)(bootsector),
         sizeof(bootsector));
  }
#line 125
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static void *example1_open(int readonly___0 ) 
{ 


  {
#line 138
  return ((void *)(data));
}
}
#line 142 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static int64_t example1_get_size(void *handle ) 
{ 


  {
#line 145
  return ((int64_t )sizeof(data));
}
}
#line 157 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static int example1_pread(void *handle , void *buf , uint32_t count , uint64_t offset ) 
{ 


  {
  {
#line 160
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(data + offset),
         (size_t )count);
  }
#line 161
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
static struct nbdkit_plugin plugin  = 
#line 164
     {0UL, 0, 0, "example1", (char const   *)0, "1.1.3", (char const   *)0, & example1_load,
    (void (*)(void))0, (int (*)(char const   *key , char const   *value ))0, (int (*)(void))0,
    (char const   *)0, & example1_open, (void (*)(void *handle ))0, & example1_get_size,
    (int (*)(void *handle ))0, (int (*)(void *handle ))0, (int (*)(void *handle ))0,
    (int (*)(void *handle ))0, & example1_pread, (int (*)(void *handle , void const   *buf ,
                                                          uint32_t count , uint64_t offset ))0,
    (int (*)(void *handle ))0, (int (*)(void *handle , uint32_t count , uint64_t offset ))0};
#line 173 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example1/example1.c"
struct nbdkit_plugin *plugin_init(void) 
{ 


  {
#line 173
  plugin._struct_size = sizeof(plugin);
#line 173
  plugin._api_version = 1;
#line 173
  plugin._thread_model = 1;
#line 173
  return (& plugin);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 82 "../../include/nbdkit-plugin.h"
void ( /* format attribute */  nbdkit_error)(char const   *fs  , ...) ;
#line 90
int64_t nbdkit_parse_size(char const   *str ) ;
#line 54 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static uint64_t size  =    (uint64_t )104857600;
#line 59 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static int example3_config(char const   *key , char const   *value ) 
{ 
  int64_t r ;
  int tmp ;

  {
  {
#line 64
  tmp = strcmp(key, "size");
  }
#line 64
  if (tmp == 0) {
    {
#line 65
    r = nbdkit_parse_size(value);
    }
#line 66
    if (r == -1L) {
#line 67
      return (-1);
    }
#line 68
    size = (uint64_t )r;
  } else {
    {
#line 71
    nbdkit_error("unknown parameter \'%s\'", key);
    }
#line 72
    return (-1);
  }
#line 75
  return (0);
}
}
#line 92 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static void *example3_open(int readonly___0 ) 
{ 
  struct example3_handle *h ;
  char template[20] ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 96
  template[0] = (char )'/';
#line 96
  template[1] = (char )'v';
#line 96
  template[2] = (char )'a';
#line 96
  template[3] = (char )'r';
#line 96
  template[4] = (char )'/';
#line 96
  template[5] = (char )'t';
#line 96
  template[6] = (char )'m';
#line 96
  template[7] = (char )'p';
#line 96
  template[8] = (char )'/';
#line 96
  template[9] = (char )'d';
#line 96
  template[10] = (char )'i';
#line 96
  template[11] = (char )'s';
#line 96
  template[12] = (char )'k';
#line 96
  template[13] = (char )'X';
#line 96
  template[14] = (char )'X';
#line 96
  template[15] = (char )'X';
#line 96
  template[16] = (char )'X';
#line 96
  template[17] = (char )'X';
#line 96
  template[18] = (char )'X';
#line 96
  template[19] = (char )'\000';
#line 98
  tmp = malloc(sizeof(*h));
#line 98
  h = (struct example3_handle *)tmp;
  }
#line 99
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 100
    nbdkit_error("malloc: %m");
    }
#line 101
    return ((void *)0);
  }
  {
#line 104
  h->fd = mkstemp(template);
  }
#line 105
  if (h->fd == -1) {
    {
#line 106
    nbdkit_error("mkstemp: %s: %m", template);
#line 107
    free((void *)h);
    }
#line 108
    return ((void *)0);
  }
  {
#line 111
  unlink((char const   *)(template));
#line 114
  tmp___0 = ftruncate(h->fd, (__off_t )size);
  }
#line 114
  if (tmp___0 == -1) {
    {
#line 115
    nbdkit_error("ftruncate: %m");
#line 116
    close(h->fd);
#line 117
    free((void *)h);
    }
#line 118
    return ((void *)0);
  }
#line 121
  return ((void *)h);
}
}
#line 125 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static void example3_close(void *handle ) 
{ 
  struct example3_handle *h ;

  {
  {
#line 128
  h = (struct example3_handle *)handle;
#line 130
  close(h->fd);
#line 131
  free((void *)h);
  }
#line 132
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static int64_t example3_get_size(void *handle ) 
{ 


  {
#line 145
  return ((int64_t )size);
}
}
#line 149 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static int example3_pread(void *handle , void *buf , uint32_t count , uint64_t offset ) 
{ 
  struct example3_handle *h ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 152
  h = (struct example3_handle *)handle;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (count > 0U)) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp = pread(h->fd, buf, (size_t )count, (__off_t )offset);
#line 155
    r = tmp;
    }
#line 156
    if (r == -1L) {
      {
#line 157
      nbdkit_error("pead: %m");
      }
#line 158
      return (-1);
    }
#line 160
    if (r == 0L) {
      {
#line 161
      nbdkit_error("pread: unexpected end of file");
      }
#line 162
      return (-1);
    }
#line 164
    buf += r;
#line 165
    count = (uint32_t )((ssize_t )count - r);
#line 166
    offset += (uint64_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static int example3_pwrite(void *handle , void const   *buf , uint32_t count , uint64_t offset ) 
{ 
  struct example3_handle *h ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 176
  h = (struct example3_handle *)handle;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (count > 0U)) {
#line 178
      goto while_break;
    }
    {
#line 179
    tmp = pwrite(h->fd, buf, (size_t )count, (__off_t )offset);
#line 179
    r = tmp;
    }
#line 180
    if (r == -1L) {
      {
#line 181
      nbdkit_error("pwrite: %m");
      }
#line 182
      return (-1);
    }
#line 184
    buf += r;
#line 185
    count = (uint32_t )((ssize_t )count - r);
#line 186
    offset += (uint64_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 193 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static int example3_flush(void *handle ) 
{ 
  struct example3_handle *h ;
  int tmp ;

  {
  {
#line 196
  h = (struct example3_handle *)handle;
#line 198
  tmp = fdatasync(h->fd);
  }
#line 198
  if (tmp == -1) {
    {
#line 199
    nbdkit_error("fdatasync: %m");
    }
#line 200
    return (-1);
  }
#line 203
  return (0);
}
}
#line 206 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example3/example3.c"
static struct nbdkit_plugin plugin___0  = 
#line 206
     {0UL, 0, 0, "example3", (char const   *)0, "1.1.3", (char const   *)0, (void (*)(void))0,
    (void (*)(void))0, & example3_config, (int (*)(void))0, "size=<SIZE>  (optional) Size of the backing disk (default: 100M)",
    & example3_open, & example3_close, & example3_get_size, (int (*)(void *handle ))0,
    (int (*)(void *handle ))0, (int (*)(void *handle ))0, (int (*)(void *handle ))0,
    & example3_pread, & example3_pwrite, & example3_flush, (int (*)(void *handle ,
                                                                    uint32_t count ,
                                                                    uint64_t offset ))0};
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 89 "../../include/nbdkit-plugin.h"
char *nbdkit_absolute_path(char const   *path ) ;
#line 46 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static char *filename  =    (char *)((void *)0);
#line 48 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static void file_unload(void) 
{ 


  {
  {
#line 51
  free((void *)filename);
  }
#line 52
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static int file_config(char const   *key , char const   *value ) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = strcmp(key, "file");
  }
#line 60
  if (tmp == 0) {
    {
#line 62
    filename = nbdkit_absolute_path(value);
    }
#line 63
    if (! filename) {
#line 64
      return (-1);
    }
  } else {
    {
#line 67
    nbdkit_error("unknown parameter \'%s\'", key);
    }
#line 68
    return (-1);
  }
#line 71
  return (0);
}
}
#line 75 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static int file_config_complete(void) 
{ 


  {
#line 78
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 79
    nbdkit_error("you must supply the file=<FILENAME> parameter after the plugin name on the command line");
    }
#line 80
    return (-1);
  }
#line 83
  return (0);
}
}
#line 95 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static void *file_open(int readonly___0 ) 
{ 
  struct handle *h ;
  int flags ;
  void *tmp ;

  {
  {
#line 101
  tmp = malloc(sizeof(*h));
#line 101
  h = (struct handle *)tmp;
  }
#line 102
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 103
    nbdkit_error("malloc: %m");
    }
#line 104
    return ((void *)0);
  }
#line 107
  flags = 524544;
#line 108
  if (readonly___0) {
#line 109
    flags = flags;
  } else {
#line 111
    flags |= 2;
  }
  {
#line 113
  h->fd = open((char const   *)filename, flags);
  }
#line 114
  if (h->fd == -1) {
    {
#line 115
    nbdkit_error("open: %s: %m", filename);
#line 116
    free((void *)h);
    }
#line 117
    return ((void *)0);
  }
#line 120
  return ((void *)h);
}
}
#line 124 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static void file_close(void *handle ) 
{ 
  struct handle *h ;

  {
  {
#line 127
  h = (struct handle *)handle;
#line 129
  close(h->fd);
#line 130
  free((void *)h);
  }
#line 131
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static int64_t file_get_size(void *handle ) 
{ 
  struct handle *h ;
  struct stat statbuf ;
  int tmp ;

  {
  {
#line 139
  h = (struct handle *)handle;
#line 142
  tmp = fstat(h->fd, & statbuf);
  }
#line 142
  if (tmp == -1) {
    {
#line 143
    nbdkit_error("stat: %m");
    }
#line 144
    return ((int64_t )-1);
  }
#line 147
  return (statbuf.st_size);
}
}
#line 151 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static int file_pread(void *handle , void *buf , uint32_t count , uint64_t offset ) 
{ 
  struct handle *h ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 154
  h = (struct handle *)handle;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (count > 0U)) {
#line 156
      goto while_break;
    }
    {
#line 157
    tmp = pread(h->fd, buf, (size_t )count, (__off_t )offset);
#line 157
    r = tmp;
    }
#line 158
    if (r == -1L) {
      {
#line 159
      nbdkit_error("pread: %m");
      }
#line 160
      return (-1);
    }
#line 162
    if (r == 0L) {
      {
#line 163
      nbdkit_error("pread: unexpected end of file");
      }
#line 164
      return (-1);
    }
#line 166
    buf += r;
#line 167
    count = (uint32_t )((ssize_t )count - r);
#line 168
    offset += (uint64_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return (0);
}
}
#line 175 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static int file_pwrite(void *handle , void const   *buf , uint32_t count , uint64_t offset ) 
{ 
  struct handle *h ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 178
  h = (struct handle *)handle;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (count > 0U)) {
#line 180
      goto while_break;
    }
    {
#line 181
    tmp = pwrite(h->fd, buf, (size_t )count, (__off_t )offset);
#line 181
    r = tmp;
    }
#line 182
    if (r == -1L) {
      {
#line 183
      nbdkit_error("pwrite: %m");
      }
#line 184
      return (-1);
    }
#line 186
    buf += r;
#line 187
    count = (uint32_t )((ssize_t )count - r);
#line 188
    offset += (uint64_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (0);
}
}
#line 195 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static int file_flush(void *handle ) 
{ 
  struct handle *h ;
  int tmp ;

  {
  {
#line 198
  h = (struct handle *)handle;
#line 200
  tmp = fdatasync(h->fd);
  }
#line 200
  if (tmp == -1) {
    {
#line 201
    nbdkit_error("fdatasync: %m");
    }
#line 202
    return (-1);
  }
#line 205
  return (0);
}
}
#line 208 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/file/file.c"
static struct nbdkit_plugin plugin___1  = 
#line 208
     {0UL, 0, 0, "file", "nbdkit file plugin", "1.1.3", (char const   *)0, (void (*)(void))0,
    & file_unload, & file_config, & file_config_complete, "file=<FILENAME>     (required) The filename to serve.",
    & file_open, & file_close, & file_get_size, (int (*)(void *handle ))0, (int (*)(void *handle ))0,
    (int (*)(void *handle ))0, (int (*)(void *handle ))0, & file_pread, & file_pwrite,
    & file_flush, (int (*)(void *handle , uint32_t count , uint64_t offset ))0};
#line 51 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static char *filename___0  =    (char *)((void *)0);
#line 53 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static void example2_unload(void) 
{ 


  {
  {
#line 56
  free((void *)filename___0);
  }
#line 57
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static int example2_config(char const   *key , char const   *value ) 
{ 
  int tmp ;

  {
  {
#line 65
  tmp = strcmp(key, "file");
  }
#line 65
  if (tmp == 0) {
    {
#line 67
    filename___0 = nbdkit_absolute_path(value);
    }
#line 68
    if (! filename___0) {
#line 69
      return (-1);
    }
  } else {
    {
#line 72
    nbdkit_error("unknown parameter \'%s\'", key);
    }
#line 73
    return (-1);
  }
#line 76
  return (0);
}
}
#line 80 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static int example2_config_complete(void) 
{ 


  {
#line 83
  if ((unsigned long )filename___0 == (unsigned long )((void *)0)) {
    {
#line 84
    nbdkit_error("you must supply the file=<FILENAME> parameter after the plugin name on the command line");
    }
#line 85
    return (-1);
  }
#line 88
  return (0);
}
}
#line 104 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static void *example2_open(int readonly___0 ) 
{ 
  struct example2_handle *h ;
  void *tmp ;

  {
  {
#line 109
  tmp = malloc(sizeof(*h));
#line 109
  h = (struct example2_handle *)tmp;
  }
#line 110
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 111
    nbdkit_error("malloc: %m");
    }
#line 112
    return ((void *)0);
  }
  {
#line 115
  h->fd = open((char const   *)filename___0, 524288);
  }
#line 116
  if (h->fd == -1) {
    {
#line 117
    nbdkit_error("open: %s: %m", filename___0);
#line 118
    free((void *)h);
    }
#line 119
    return ((void *)0);
  }
#line 122
  return ((void *)h);
}
}
#line 126 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static void example2_close(void *handle ) 
{ 
  struct example2_handle *h ;

  {
  {
#line 129
  h = (struct example2_handle *)handle;
#line 131
  close(h->fd);
#line 132
  free((void *)h);
  }
#line 133
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static int64_t example2_get_size(void *handle ) 
{ 
  struct example2_handle *h ;
  struct stat statbuf ;
  int tmp ;

  {
  {
#line 146
  h = (struct example2_handle *)handle;
#line 149
  tmp = fstat(h->fd, & statbuf);
  }
#line 149
  if (tmp == -1) {
    {
#line 150
    nbdkit_error("stat: %m");
    }
#line 151
    return ((int64_t )-1);
  }
#line 154
  return (statbuf.st_size);
}
}
#line 158 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static int example2_pread(void *handle , void *buf , uint32_t count , uint64_t offset ) 
{ 
  struct example2_handle *h ;
  ssize_t r ;
  ssize_t tmp ;

  {
#line 161
  h = (struct example2_handle *)handle;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (count > 0U)) {
#line 163
      goto while_break;
    }
    {
#line 164
    tmp = pread(h->fd, buf, (size_t )count, (__off_t )offset);
#line 164
    r = tmp;
    }
#line 165
    if (r == -1L) {
      {
#line 166
      nbdkit_error("pread: %m");
      }
#line 167
      return (-1);
    }
#line 169
    if (r == 0L) {
      {
#line 170
      nbdkit_error("pread: unexpected end of file");
      }
#line 171
      return (-1);
    }
#line 173
    buf += r;
#line 174
    count = (uint32_t )((ssize_t )count - r);
#line 175
    offset += (uint64_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (0);
}
}
#line 181 "/home/wheatley/newnew/temp/nbdkit-1.1.3/plugins/example2/example2.c"
static struct nbdkit_plugin plugin___2  = 
#line 181
     {0UL, 0, 0, "example2", (char const   *)0, "1.1.3", (char const   *)0, (void (*)(void))0,
    & example2_unload, & example2_config, & example2_config_complete, "file=<FILENAME>     (required) The filename to serve.",
    & example2_open, & example2_close, & example2_get_size, (int (*)(void *handle ))0,
    (int (*)(void *handle ))0, (int (*)(void *handle ))0, (int (*)(void *handle ))0,
    & example2_pread, (int (*)(void *handle , void const   *buf , uint32_t count ,
                               uint64_t offset ))0, (int (*)(void *handle ))0, (int (*)(void *handle ,
                                                                                        uint32_t count ,
                                                                                        uint64_t offset ))0};
#line 60 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
void cleanup_free(void *ptr ) ;
#line 44 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/cleanup.c"
void cleanup_free(void *ptr ) 
{ 


  {
  {
#line 47
  free(*((void **)ptr));
  }
#line 48
  return;
}
}
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
  }
#line 47
  return ((unsigned int )tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long tmp ;

  {
  {
#line 111
  tmp = __builtin_bswap64((long )__bsx);
  }
#line 111
  return ((__uint64_t )tmp);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 85 "../include/nbdkit-plugin.h"
void ( /* format attribute */  nbdkit_debug)(char const   *fs  , ...) ;
#line 53 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
int readonly ;
#line 57
int volatile   quit ;
#line 79
int handle_single_connection(int sockin , int sockout ) ;
#line 87
char const   *plugin_name(void) ;
#line 92
void plugin_lock_connection(void) ;
#line 93
void plugin_unlock_connection(void) ;
#line 94
void plugin_lock_request(struct connection *conn ) ;
#line 95
void plugin_unlock_request(struct connection *conn ) ;
#line 96
int plugin_open(struct connection *conn , int readonly___0 ) ;
#line 97
void plugin_close(struct connection *conn ) ;
#line 98
int64_t plugin_get_size(struct connection *conn ) ;
#line 99
int plugin_can_write(struct connection *conn ) ;
#line 100
int plugin_can_flush(struct connection *conn ) ;
#line 101
int plugin_is_rotational(struct connection *conn ) ;
#line 102
int plugin_can_trim(struct connection *conn ) ;
#line 103
int plugin_pread(struct connection *conn , void *buf , uint32_t count , uint64_t offset ) ;
#line 104
int plugin_pwrite(struct connection *conn , void *buf , uint32_t count , uint64_t offset ) ;
#line 105
int plugin_flush(struct connection *conn ) ;
#line 106
int plugin_trim(struct connection *conn , uint32_t count , uint64_t offset ) ;
#line 117
void tls_set_name(char const   *name ) ;
#line 125
int xread(int sock , void *vbuf , size_t len ) ;
#line 126
int xwrite(int sock , void const   *vbuf , size_t len ) ;
#line 55 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static struct connection *new_connection(int sockin , int sockout ) ;
#line 56
static void free_connection(struct connection *conn ) ;
#line 57
static int negotiate_handshake(struct connection *conn ) ;
#line 58
static int recv_request_send_reply(struct connection *conn ) ;
#line 60 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int _handle_single_connection(int sockin , int sockout ) 
{ 
  int r ;
  struct connection *conn ;
  struct connection *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 64
  tmp = new_connection(sockin, sockout);
#line 64
  conn = tmp;
  }
#line 66
  if (! conn) {
#line 67
    goto err;
  }
  {
#line 69
  tmp___0 = plugin_open(conn, readonly);
  }
#line 69
  if (tmp___0 == -1) {
#line 70
    goto err;
  }
  {
#line 72
  tmp___1 = plugin_name();
#line 72
  tls_set_name(tmp___1);
#line 75
  tmp___2 = negotiate_handshake(conn);
  }
#line 75
  if (tmp___2 == -1) {
#line 76
    goto err;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (! quit)) {
#line 81
      goto while_break;
    }
    {
#line 82
    r = recv_request_send_reply(conn);
    }
#line 83
    if (r == -1) {
#line 84
      goto err;
    }
#line 85
    if (r == 0) {
#line 86
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  free_connection(conn);
  }
#line 90
  return (0);
  err: 
  {
#line 93
  free_connection(conn);
  }
#line 94
  return (-1);
}
}
#line 97 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
int handle_single_connection(int sockin , int sockout ) 
{ 
  int r ;

  {
  {
#line 102
  plugin_lock_connection();
#line 103
  r = _handle_single_connection(sockin, sockout);
#line 104
  plugin_unlock_connection();
  }
#line 106
  return (r);
}
}
#line 109 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static struct connection *new_connection(int sockin , int sockout ) 
{ 
  struct connection *conn ;
  void *tmp ;

  {
  {
#line 114
  tmp = calloc((size_t )1, sizeof(*conn));
#line 114
  conn = (struct connection *)tmp;
  }
#line 115
  if ((unsigned long )conn == (unsigned long )((void *)0)) {
    {
#line 116
    perror("malloc");
    }
#line 117
    return ((struct connection *)((void *)0));
  }
  {
#line 120
  conn->sockin = sockin;
#line 121
  conn->sockout = sockout;
#line 122
  pthread_mutex_init(& conn->request_lock, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 124
  return (conn);
}
}
#line 127 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static void free_connection(struct connection *conn ) 
{ 


  {
#line 130
  if (! conn) {
#line 131
    return;
  }
#line 133
  if (conn->sockin >= 0) {
    {
#line 134
    close(conn->sockin);
    }
  }
#line 135
  if (conn->sockout >= 0) {
#line 135
    if (conn->sockin != conn->sockout) {
      {
#line 136
      close(conn->sockout);
      }
    }
  }
  {
#line 138
  pthread_mutex_destroy(& conn->request_lock);
  }
#line 140
  if (conn->handle) {
    {
#line 141
    plugin_close(conn);
    }
  }
  {
#line 143
  free((void *)conn);
  }
#line 144
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int _negotiate_handshake(struct connection *conn ) 
{ 
  struct old_handshake handshake ;
  int64_t r ;
  uint64_t exportsize ;
  uint16_t gflags ;
  uint16_t eflags ;
  int fl ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  int tmp ;

  {
  {
#line 158
  r = plugin_get_size(conn);
  }
#line 159
  if (r == -1L) {
#line 160
    return (-1);
  }
#line 161
  if (r < 0L) {
    {
#line 162
    nbdkit_error(".get_size function returned invalid value (%li)", r);
    }
#line 164
    return (-1);
  }
  {
#line 166
  exportsize = (uint64_t )r;
#line 167
  conn->exportsize = exportsize;
#line 169
  gflags = (uint16_t )0;
#line 170
  eflags = (uint16_t )1;
#line 172
  fl = plugin_can_write(conn);
  }
#line 173
  if (fl == -1) {
#line 174
    return (-1);
  }
#line 175
  if (readonly) {
#line 176
    eflags = (uint16_t )((int )eflags | 2);
#line 177
    conn->readonly = 1;
  } else
#line 175
  if (! fl) {
#line 176
    eflags = (uint16_t )((int )eflags | 2);
#line 177
    conn->readonly = 1;
  }
  {
#line 180
  fl = plugin_can_flush(conn);
  }
#line 181
  if (fl == -1) {
#line 182
    return (-1);
  }
#line 183
  if (fl) {
#line 184
    eflags = (uint16_t )((int )eflags | 12);
#line 185
    conn->can_flush = 1;
  }
  {
#line 188
  fl = plugin_is_rotational(conn);
  }
#line 189
  if (fl == -1) {
#line 190
    return (-1);
  }
#line 191
  if (fl) {
#line 192
    eflags = (uint16_t )((int )eflags | 16);
#line 193
    conn->is_rotational = 1;
  }
  {
#line 196
  fl = plugin_can_trim(conn);
  }
#line 197
  if (fl == -1) {
#line 198
    return (-1);
  }
#line 199
  if (fl) {
#line 200
    eflags = (uint16_t )((int )eflags | 32);
#line 201
    conn->can_trim = 1;
  }
  {
#line 204
  nbdkit_debug("flags: global 0x%x export 0x%x", (int )gflags, (int )eflags);
#line 206
  memset((void *)(& handshake), 0, sizeof(handshake));
#line 207
  memcpy((void */* __restrict  */)(handshake.nbdmagic), (void const   */* __restrict  */)"NBDMAGIC",
         (size_t )8);
#line 208
  handshake.version = __bswap_64(72578530415187UL);
#line 209
  handshake.exportsize = __bswap_64(exportsize);
#line 210
  __x = gflags;
#line 210
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 210
  handshake.gflags = __v;
#line 211
  __x___0 = eflags;
#line 211
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 211
  handshake.eflags = __v___0;
#line 213
  tmp = xwrite(conn->sockout, (void const   *)(& handshake), sizeof(handshake));
  }
#line 213
  if (tmp == -1) {
    {
#line 214
    nbdkit_error("write: %m");
    }
#line 215
    return (-1);
  }
#line 218
  return (0);
}
}
#line 221 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int negotiate_handshake(struct connection *conn ) 
{ 
  int r ;

  {
  {
#line 226
  plugin_lock_request(conn);
#line 227
  r = _negotiate_handshake(conn);
#line 228
  plugin_unlock_request(conn);
  }
#line 230
  return (r);
}
}
#line 233 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int valid_range(struct connection *conn , uint64_t offset , uint32_t count ) 
{ 
  uint64_t exportsize ;
  int tmp ;

  {
#line 236
  exportsize = conn->exportsize;
#line 238
  if (count > 0U) {
#line 238
    if (offset <= exportsize) {
#line 238
      if (offset + (uint64_t )count <= exportsize) {
#line 238
        tmp = 1;
      } else {
#line 238
        tmp = 0;
      }
    } else {
#line 238
      tmp = 0;
    }
  } else {
#line 238
    tmp = 0;
  }
#line 238
  return (tmp);
}
}
#line 241 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int validate_request(struct connection *conn , uint32_t cmd , uint32_t flags ,
                            uint64_t offset , uint32_t count , uint32_t *error ) 
{ 
  int r ;

  {
  {
#line 252
  if (cmd == 4U) {
#line 252
    goto case_4;
  }
#line 252
  if (cmd == 1U) {
#line 252
    goto case_4;
  }
#line 252
  if (cmd == 0U) {
#line 252
    goto case_4;
  }
#line 264
  if (cmd == 3U) {
#line 264
    goto case_3;
  }
#line 272
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 253
  r = valid_range(conn, offset, count);
  }
#line 254
  if (r == -1) {
#line 255
    return (-1);
  }
#line 256
  if (r == 0) {
    {
#line 258
    nbdkit_error("invalid request: offset and length are out of range");
#line 259
    *error = (uint32_t )5;
    }
#line 260
    return (0);
  }
#line 262
  goto switch_break;
  case_3: /* CIL Label */ 
#line 265
  if (offset != 0UL) {
    {
#line 266
    nbdkit_error("invalid flush request: expecting offset and length == 0");
#line 267
    *error = (uint32_t )22;
    }
#line 268
    return (0);
  } else
#line 265
  if (count != 0U) {
    {
#line 266
    nbdkit_error("invalid flush request: expecting offset and length == 0");
#line 267
    *error = (uint32_t )22;
    }
#line 268
    return (0);
  }
#line 270
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 273
  nbdkit_error("invalid request: unknown command (%u) ignored", cmd);
#line 275
  *error = (uint32_t )22;
  }
#line 276
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 280
  if (cmd == 1U) {
#line 280
    goto _L;
  } else
#line 280
  if (cmd == 0U) {
    _L: /* CIL Label */ 
#line 280
    if (count > 67108864U) {
      {
#line 282
      nbdkit_error("invalid request: data request is too large (%u > %d)", count,
                   67108864);
#line 284
      *error = (uint32_t )12;
      }
#line 285
      return (0);
    }
  }
#line 289
  if (conn->readonly) {
#line 289
    if (cmd == 1U) {
      {
#line 292
      nbdkit_error("invalid request: write request on readonly connection");
#line 293
      *error = (uint32_t )30;
      }
#line 294
      return (0);
    } else
#line 289
    if (cmd == 3U) {
      {
#line 292
      nbdkit_error("invalid request: write request on readonly connection");
#line 293
      *error = (uint32_t )30;
      }
#line 294
      return (0);
    } else
#line 289
    if (cmd == 4U) {
      {
#line 292
      nbdkit_error("invalid request: write request on readonly connection");
#line 293
      *error = (uint32_t )30;
      }
#line 294
      return (0);
    }
  }
#line 298
  if (! conn->can_flush) {
#line 298
    if (cmd == 3U) {
      {
#line 299
      nbdkit_error("invalid request: flush operation not supported");
#line 300
      *error = (uint32_t )22;
      }
#line 301
      return (0);
    }
  }
#line 305
  if (! conn->can_trim) {
#line 305
    if (cmd == 4U) {
      {
#line 306
      nbdkit_error("invalid request: trim operation not supported");
#line 307
      *error = (uint32_t )22;
      }
#line 308
      return (0);
    }
  }
#line 311
  return (1);
}
}
#line 326 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int _handle_request(struct connection *conn , uint32_t cmd , uint32_t flags ,
                           uint64_t offset , uint32_t count , void *buf , uint32_t *error ) 
{ 
  _Bool flush_after_command ;
  int r ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___12 ;
  int *tmp___13 ;

  {
#line 336
  flush_after_command = (_Bool )((flags & (unsigned int )(1 << 16)) != 0U);
#line 337
  if (! conn->can_flush) {
#line 338
    flush_after_command = (_Bool)0;
  } else
#line 337
  if (conn->readonly) {
#line 338
    flush_after_command = (_Bool)0;
  }
  {
#line 341
  if (cmd == 0U) {
#line 341
    goto case_0;
  }
#line 349
  if (cmd == 1U) {
#line 349
    goto case_1;
  }
#line 357
  if (cmd == 3U) {
#line 357
    goto case_3;
  }
#line 365
  if (cmd == 4U) {
#line 365
    goto case_4;
  }
#line 373
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 342
  r = plugin_pread(conn, buf, count, offset);
  }
#line 343
  if (r == -1) {
    {
#line 344
    tmp___1 = __errno_location();
    }
#line 344
    if (*tmp___1) {
      {
#line 344
      tmp___0 = __errno_location();
#line 344
      *error = (uint32_t )*tmp___0;
      }
    } else {
#line 344
      *error = (uint32_t )5;
    }
#line 345
    return (0);
  }
#line 347
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 350
  r = plugin_pwrite(conn, buf, count, offset);
  }
#line 351
  if (r == -1) {
    {
#line 352
    tmp___4 = __errno_location();
    }
#line 352
    if (*tmp___4) {
      {
#line 352
      tmp___3 = __errno_location();
#line 352
      *error = (uint32_t )*tmp___3;
      }
    } else {
#line 352
      *error = (uint32_t )5;
    }
#line 353
    return (0);
  }
#line 355
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 358
  r = plugin_flush(conn);
  }
#line 359
  if (r == -1) {
    {
#line 360
    tmp___7 = __errno_location();
    }
#line 360
    if (*tmp___7) {
      {
#line 360
      tmp___6 = __errno_location();
#line 360
      *error = (uint32_t )*tmp___6;
      }
    } else {
#line 360
      *error = (uint32_t )5;
    }
#line 361
    return (0);
  }
#line 363
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 366
  r = plugin_trim(conn, count, offset);
  }
#line 367
  if (r == -1) {
    {
#line 368
    tmp___10 = __errno_location();
    }
#line 368
    if (*tmp___10) {
      {
#line 368
      tmp___9 = __errno_location();
#line 368
      *error = (uint32_t )*tmp___9;
      }
    } else {
#line 368
      *error = (uint32_t )5;
    }
#line 369
    return (0);
  }
#line 371
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 374
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 377
  if (flush_after_command) {
    {
#line 378
    r = plugin_flush(conn);
    }
#line 379
    if (r == -1) {
      {
#line 380
      tmp___13 = __errno_location();
      }
#line 380
      if (*tmp___13) {
        {
#line 380
        tmp___12 = __errno_location();
#line 380
        *error = (uint32_t )*tmp___12;
        }
      } else {
#line 380
        *error = (uint32_t )5;
      }
#line 381
      return (0);
    }
  }
#line 385
  return (0);
}
}
#line 388 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int handle_request(struct connection *conn , uint32_t cmd , uint32_t flags ,
                          uint64_t offset , uint32_t count , void *buf , uint32_t *error ) 
{ 
  int r ;

  {
  {
#line 396
  plugin_lock_request(conn);
#line 397
  r = _handle_request(conn, cmd, flags, offset, count, buf, error);
#line 398
  plugin_unlock_request(conn);
  }
#line 400
  return (r);
}
}
#line 403 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static void skip_over_write_buffer(int sock , size_t count ) 
{ 
  char buf[8192] ;
  ssize_t r ;
  size_t tmp ;

  {
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! (count > 0UL)) {
#line 409
      goto while_break;
    }
#line 410
    if (count > 8192UL) {
#line 410
      tmp = (size_t )8192;
    } else {
#line 410
      tmp = count;
    }
    {
#line 410
    r = read(sock, (void *)(buf), tmp);
    }
#line 411
    if (r == -1L) {
      {
#line 412
      nbdkit_error("skipping write buffer: %m");
      }
#line 413
      return;
    }
#line 415
    if (r == 0L) {
#line 416
      return;
    }
#line 417
    count -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return;
}
}
#line 421 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/connections.c"
static int recv_request_send_reply(struct connection *conn ) 
{ 
  int r ;
  struct request request ;
  struct reply reply ;
  uint32_t magic ;
  uint32_t cmd ;
  uint32_t flags ;
  uint32_t count ;
  uint32_t error ;
  uint64_t offset ;
  char __attribute__((__cleanup__(cleanup_free)))  *buf ;
  void *tmp ;

  {
  {
#line 427
  error = (uint32_t )0;
#line 429
  buf = (char __attribute__((__cleanup__(cleanup_free)))  *)((void *)0);
#line 432
  r = xread(conn->sockin, (void *)(& request), sizeof(request));
  }
#line 433
  if (r == -1) {
    {
#line 434
    nbdkit_error("read request: %m");
    }
#line 435
    return (-1);
  }
#line 437
  if (r == 0) {
    {
#line 438
    nbdkit_debug("client closed input socket, closing connection");
    }
#line 439
    return (0);
  }
  {
#line 442
  magic = __bswap_32(request.magic);
  }
#line 443
  if (magic != 627086611U) {
    {
#line 444
    nbdkit_error("invalid request: \'magic\' field is incorrect (0x%x)", magic);
    }
#line 445
    return (-1);
  }
  {
#line 448
  cmd = __bswap_32(request.type);
#line 449
  flags = cmd;
#line 450
  cmd &= 65535U;
#line 452
  offset = __bswap_64(request.offset);
#line 453
  count = __bswap_32(request.count);
  }
#line 455
  if (cmd == 2U) {
    {
#line 456
    nbdkit_debug("client sent disconnect command, closing connection");
    }
#line 457
    return (0);
  }
  {
#line 461
  r = validate_request(conn, cmd, flags, offset, count, & error);
  }
#line 462
  if (r == -1) {
#line 463
    return (-1);
  }
#line 464
  if (r == 0) {
#line 465
    if (cmd == 1U) {
      {
#line 466
      skip_over_write_buffer(conn->sockin, (size_t )count);
      }
    }
#line 467
    goto send_reply;
  }
#line 471
  if (cmd == 0U) {
#line 471
    goto _L;
  } else
#line 471
  if (cmd == 1U) {
    _L: /* CIL Label */ 
    {
#line 472
    tmp = malloc((size_t )count);
#line 472
    buf = (char __attribute__((__cleanup__(cleanup_free)))  *)tmp;
    }
#line 473
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 474
      perror("malloc");
#line 475
      error = (uint32_t )12;
      }
#line 476
      if (cmd == 1U) {
        {
#line 477
        skip_over_write_buffer(conn->sockin, (size_t )count);
        }
      }
#line 478
      goto send_reply;
    }
  }
#line 483
  if (cmd == 1U) {
    {
#line 484
    r = xread(conn->sockin, (void *)buf, (size_t )count);
    }
#line 485
    if (r == -1) {
      {
#line 486
      nbdkit_error("read data: %m");
      }
#line 487
      return (-1);
    }
#line 489
    if (r == 0) {
      {
#line 490
      nbdkit_debug("client closed input unexpectedly, closing connection");
      }
#line 491
      return (0);
    }
  }
  {
#line 496
  r = handle_request(conn, cmd, flags, offset, count, (void *)buf, & error);
  }
#line 497
  if (r == -1) {
#line 498
    return (-1);
  }
  send_reply: 
  {
#line 502
  reply.magic = __bswap_32(1732535960U);
#line 503
  reply.handle = request.handle;
#line 504
  reply.error = __bswap_32(error);
#line 506
  r = xwrite(conn->sockout, (void const   *)(& reply), sizeof(reply));
  }
#line 507
  if (r == -1) {
    {
#line 508
    nbdkit_error("write reply: %m");
    }
#line 509
    return (-1);
  }
#line 513
  if (cmd == 0U) {
    {
#line 514
    r = xwrite(conn->sockout, (void const   *)buf, (size_t )count);
    }
#line 515
    if (r == -1) {
      {
#line 516
      nbdkit_error("write data: %m");
      }
#line 517
      return (-1);
    }
  }
#line 521
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 54 "/usr/include/errno.h"
extern char *program_invocation_short_name ;
#line 84 "../include/nbdkit-plugin.h"
void nbdkit_verror(char const   *fs , va_list args ) ;
#line 87
void nbdkit_vdebug(char const   *fs , va_list args ) ;
#line 55 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
int verbose ;
#line 120
char const   *tls_get_name(void) ;
#line 121
size_t tls_get_instance_num(void) ;
#line 45 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/errors.c"
static void prologue(char const   *type ) 
{ 
  char const   *name ;
  char const   *tmp ;
  size_t instance_num___0 ;
  size_t tmp___0 ;

  {
  {
#line 48
  tmp = tls_get_name();
#line 48
  name = tmp;
#line 49
  tmp___0 = tls_get_instance_num();
#line 49
  instance_num___0 = tmp___0;
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          program_invocation_short_name);
  }
#line 53
  if (name) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            name);
    }
#line 55
    if (instance_num___0 > 0UL) {
      {
#line 56
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%zu]",
              instance_num___0);
      }
    }
    {
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": ");
    }
  }
  {
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          type);
  }
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/errors.c"
void nbdkit_vdebug(char const   *fs , va_list args ) 
{ 
  int err ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 67
  tmp = __errno_location();
#line 67
  err = *tmp;
  }
#line 69
  if (! verbose) {
#line 70
    return;
  }
  {
#line 72
  prologue("debug");
#line 74
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fs, args);
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 78
  tmp___0 = __errno_location();
#line 78
  *tmp___0 = err;
  }
#line 79
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/errors.c"
void ( /* format attribute */  nbdkit_debug)(char const   *fs  , ...) 
{ 
  va_list args ;
  int err ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 86
  tmp = __errno_location();
#line 86
  err = *tmp;
  }
#line 88
  if (! verbose) {
#line 89
    return;
  }
  {
#line 91
  prologue("debug");
#line 93
  __builtin_va_start(args, fs);
#line 94
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fs, args);
#line 95
  __builtin_va_end(args);
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 99
  tmp___0 = __errno_location();
#line 99
  *tmp___0 = err;
  }
#line 100
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/errors.c"
void nbdkit_verror(char const   *fs , va_list args ) 
{ 
  int err ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 106
  tmp = __errno_location();
#line 106
  err = *tmp;
#line 108
  prologue("error");
#line 110
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fs, args);
#line 112
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 114
  tmp___0 = __errno_location();
#line 114
  *tmp___0 = err;
  }
#line 115
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/errors.c"
void ( /* format attribute */  nbdkit_error)(char const   *fs  , ...) 
{ 
  va_list args ;
  int err ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 122
  tmp = __errno_location();
#line 122
  err = *tmp;
#line 124
  prologue("error");
#line 126
  __builtin_va_start(args, fs);
#line 127
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fs, args);
#line 128
  __builtin_va_end(args);
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 132
  tmp___0 = __errno_location();
#line 132
  *tmp___0 = err;
  }
#line 133
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 60 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 85 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
void plugin_register(char const   *_filename , void *_dl , struct nbdkit_plugin *(*plugin_init___0)(void) ) ;
#line 86
void plugin_cleanup(void) ;
#line 88
void plugin_usage(void) ;
#line 89
void plugin_version(void) ;
#line 90
void plugin_config(char const   *key , char const   *value ) ;
#line 91
void plugin_config_complete(void) ;
#line 48 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
static pthread_mutex_t connection_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 49 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
static pthread_mutex_t all_requests_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 54 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
static char const   *filename___1  ;
#line 55 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
static void *dl  ;
#line 56 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
static struct nbdkit_plugin plugin___3  ;
#line 58 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_register(char const   *_filename , void *_dl , struct nbdkit_plugin *(*plugin_init___0)(void) ) 
{ 
  struct nbdkit_plugin  const  *_plugin ;
  size_t i ;
  size_t len ;
  size_t size___0 ;
  struct nbdkit_plugin *tmp ;

  {
  {
#line 65
  filename___1 = _filename;
#line 66
  dl = _dl;
#line 68
  nbdkit_debug("registering %s", filename___1);
#line 73
  tmp = (*plugin_init___0)();
#line 73
  _plugin = (struct nbdkit_plugin  const  *)tmp;
  }
#line 74
  if (! _plugin) {
    {
#line 75
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin registration function failed\n",
            program_invocation_short_name, filename___1);
#line 77
    exit(1);
    }
  }
#line 81
  if (_plugin->_api_version != 1) {
    {
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin is incompatible with this version of nbdkit (_api_version = %d)\n",
            program_invocation_short_name, filename___1, _plugin->_api_version);
#line 84
    exit(1);
    }
  }
  {
#line 92
  size___0 = sizeof(plugin___3);
#line 93
  memset((void *)(& plugin___3), 0, size___0);
  }
#line 94
  if (size___0 > (size_t )_plugin->_struct_size) {
#line 95
    size___0 = (size_t )_plugin->_struct_size;
  }
  {
#line 96
  memcpy((void */* __restrict  */)(& plugin___3), (void const   */* __restrict  */)_plugin,
         size___0);
  }
#line 101
  if ((unsigned long )plugin___3.name == (unsigned long )((void *)0)) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin must have a .name field\n",
            program_invocation_short_name, filename___1);
#line 104
    exit(1);
    }
  }
#line 106
  if ((unsigned long )plugin___3.open == (unsigned long )((void *)0)) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin must have a .open callback\n",
            program_invocation_short_name, filename___1);
#line 109
    exit(1);
    }
  }
#line 111
  if ((unsigned long )plugin___3.get_size == (unsigned long )((void *)0)) {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin must have a .get_size callback\n",
            program_invocation_short_name, filename___1);
#line 114
    exit(1);
    }
  }
#line 116
  if ((unsigned long )plugin___3.pread == (unsigned long )((void *)0)) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin must have a .pread callback\n",
            program_invocation_short_name, filename___1);
#line 119
    exit(1);
    }
  }
  {
#line 122
  len = strlen(plugin___3.name);
  }
#line 123
  if (len == 0UL) {
    {
#line 124
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin.name field must not be empty\n",
            program_invocation_short_name, filename___1);
#line 126
    exit(1);
    }
  }
#line 128
  i = (size_t )0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < len)) {
#line 128
      goto while_break;
    }
#line 129
    if ((int const   )*(plugin___3.name + i) >= 48) {
#line 129
      if (! ((int const   )*(plugin___3.name + i) <= 57)) {
#line 129
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 129
    if ((int const   )*(plugin___3.name + i) >= 97) {
#line 129
      if (! ((int const   )*(plugin___3.name + i) <= 122)) {
#line 129
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 129
    if ((int const   )*(plugin___3.name + i) >= 65) {
#line 129
      if (! ((int const   )*(plugin___3.name + i) <= 90)) {
        {
#line 132
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin.name (\'%s\') field must contain only ASCII alphanumeric characters\n",
                program_invocation_short_name, filename___1, plugin___3.name);
#line 134
        exit(1);
        }
      }
    } else {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: plugin.name (\'%s\') field must contain only ASCII alphanumeric characters\n",
              program_invocation_short_name, filename___1, plugin___3.name);
#line 134
      exit(1);
      }
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  nbdkit_debug("registered %s (name %s)", filename___1, plugin___3.name);
#line 141
  nbdkit_debug("%s: load", filename___1);
  }
#line 142
  if (plugin___3.load) {
    {
#line 143
    (*(plugin___3.load))();
    }
  }
#line 144
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_cleanup(void) 
{ 


  {
#line 149
  if (dl) {
    {
#line 150
    nbdkit_debug("%s: unload", filename___1);
    }
#line 151
    if (plugin___3.unload) {
      {
#line 152
      (*(plugin___3.unload))();
      }
    }
    {
#line 154
    dlclose(dl);
#line 155
    dl = (void *)0;
    }
  }
#line 157
  return;
}
}
#line 159 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
char const   *plugin_name(void) 
{ 


  {
#line 162
  if (! dl) {
    {
#line 162
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 162U,
                  "plugin_name");
    }
  }
#line 164
  return (plugin___3.name);
}
}
#line 167 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_usage(void) 
{ 


  {
#line 170
  if (! dl) {
    {
#line 170
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 170U,
                  "plugin_usage");
    }
  }
  {
#line 172
  printf((char const   */* __restrict  */)"%s", plugin___3.name);
  }
#line 173
  if (plugin___3.longname) {
    {
#line 174
    printf((char const   */* __restrict  */)" (%s)", plugin___3.longname);
    }
  }
  {
#line 175
  printf((char const   */* __restrict  */)"\n");
  }
#line 176
  if (plugin___3.description) {
    {
#line 177
    printf((char const   */* __restrict  */)"\n");
#line 178
    printf((char const   */* __restrict  */)"%s\n", plugin___3.description);
    }
  }
#line 180
  if (plugin___3.config_help) {
    {
#line 181
    printf((char const   */* __restrict  */)"\n");
#line 182
    printf((char const   */* __restrict  */)"%s\n", plugin___3.config_help);
    }
  }
#line 184
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_version(void) 
{ 


  {
#line 189
  if (! dl) {
    {
#line 189
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 189U,
                  "plugin_version");
    }
  }
  {
#line 191
  printf((char const   */* __restrict  */)"%s", plugin___3.name);
  }
#line 192
  if (plugin___3.version) {
    {
#line 193
    printf((char const   */* __restrict  */)" %s", plugin___3.version);
    }
  }
  {
#line 194
  printf((char const   */* __restrict  */)"\n");
  }
#line 195
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_config(char const   *key , char const   *value ) 
{ 
  int tmp ;

  {
#line 200
  if (! dl) {
    {
#line 200
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 200U,
                  "plugin_config");
    }
  }
  {
#line 202
  nbdkit_debug("%s: config key=%s, value=%s", filename___1, key, value);
  }
#line 205
  if ((unsigned long )plugin___3.config == (unsigned long )((void *)0)) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: this plugin does not need command line configuration\nTry using: %s --help %s\n",
            program_invocation_short_name, filename___1, program_invocation_short_name,
            filename___1);
#line 210
    exit(1);
    }
  }
  {
#line 213
  tmp = (*(plugin___3.config))(key, value);
  }
#line 213
  if (tmp == -1) {
    {
#line 214
    exit(1);
    }
  }
#line 215
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_config_complete(void) 
{ 
  int tmp ;

  {
#line 220
  if (! dl) {
    {
#line 220
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 220U,
                  "plugin_config_complete");
    }
  }
  {
#line 222
  nbdkit_debug("%s: config_complete", filename___1);
  }
#line 224
  if (! plugin___3.config_complete) {
#line 225
    return;
  }
  {
#line 227
  tmp = (*(plugin___3.config_complete))();
  }
#line 227
  if (tmp == -1) {
    {
#line 228
    exit(1);
    }
  }
#line 229
  return;
}
}
#line 232 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_lock_connection(void) 
{ 


  {
#line 235
  if (! dl) {
    {
#line 235
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 235U,
                  "plugin_lock_connection");
    }
  }
#line 237
  if (plugin___3._thread_model <= 0) {
    {
#line 238
    nbdkit_debug("%s: acquire connection lock", filename___1);
#line 239
    pthread_mutex_lock(& connection_lock);
    }
  }
#line 241
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_unlock_connection(void) 
{ 


  {
#line 246
  if (! dl) {
    {
#line 246
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 246U,
                  "plugin_unlock_connection");
    }
  }
#line 248
  if (plugin___3._thread_model <= 0) {
    {
#line 249
    nbdkit_debug("%s: release connection lock", filename___1);
#line 250
    pthread_mutex_unlock(& connection_lock);
    }
  }
#line 252
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_lock_request(struct connection *conn ) 
{ 


  {
#line 257
  if (! dl) {
    {
#line 257
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 257U,
                  "plugin_lock_request");
    }
  }
#line 259
  if (plugin___3._thread_model <= 1) {
    {
#line 260
    nbdkit_debug("acquire global request lock");
#line 261
    pthread_mutex_lock(& all_requests_lock);
    }
  }
#line 264
  if (plugin___3._thread_model <= 2) {
    {
#line 265
    nbdkit_debug("acquire per-connection request lock");
#line 266
    pthread_mutex_lock(& conn->request_lock);
    }
  }
#line 268
  return;
}
}
#line 270 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_unlock_request(struct connection *conn ) 
{ 


  {
#line 273
  if (! dl) {
    {
#line 273
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 273U,
                  "plugin_unlock_request");
    }
  }
#line 275
  if (plugin___3._thread_model <= 2) {
    {
#line 276
    nbdkit_debug("release per-connection request lock");
#line 277
    pthread_mutex_unlock(& conn->request_lock);
    }
  }
#line 280
  if (plugin___3._thread_model <= 1) {
    {
#line 281
    nbdkit_debug("release global request lock");
#line 282
    pthread_mutex_unlock(& all_requests_lock);
    }
  }
#line 284
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_open(struct connection *conn , int readonly___0 ) 
{ 
  void *handle ;

  {
#line 291
  if (! dl) {
    {
#line 291
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 291U,
                  "plugin_open");
    }
  }
#line 292
  if (! ((unsigned long )conn->handle == (unsigned long )((void *)0))) {
    {
#line 292
    __assert_fail("conn->handle == ((void *)0)", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  292U, "plugin_open");
    }
  }
#line 293
  if (! ((unsigned long )plugin___3.open != (unsigned long )((void *)0))) {
    {
#line 293
    __assert_fail("plugin.open != ((void *)0)", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  293U, "plugin_open");
    }
  }
  {
#line 295
  nbdkit_debug("%s: open readonly=%d", filename___1, readonly___0);
#line 297
  handle = (*(plugin___3.open))(readonly___0);
  }
#line 298
  if (! handle) {
#line 299
    return (-1);
  }
#line 301
  conn->handle = handle;
#line 302
  return (0);
}
}
#line 305 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
void plugin_close(struct connection *conn ) 
{ 


  {
#line 308
  if (! dl) {
    {
#line 308
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 308U,
                  "plugin_close");
    }
  }
#line 309
  if (! conn->handle) {
    {
#line 309
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  309U, "plugin_close");
    }
  }
  {
#line 311
  nbdkit_debug("close");
  }
#line 313
  if (plugin___3.close) {
    {
#line 314
    (*(plugin___3.close))(conn->handle);
    }
  }
#line 316
  conn->handle = (void *)0;
#line 317
  return;
}
}
#line 319 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int64_t plugin_get_size(struct connection *conn ) 
{ 
  int64_t tmp ;

  {
#line 322
  if (! dl) {
    {
#line 322
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 322U,
                  "plugin_get_size");
    }
  }
#line 323
  if (! conn->handle) {
    {
#line 323
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  323U, "plugin_get_size");
    }
  }
#line 324
  if (! ((unsigned long )plugin___3.get_size != (unsigned long )((void *)0))) {
    {
#line 324
    __assert_fail("plugin.get_size != ((void *)0)", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  324U, "plugin_get_size");
    }
  }
  {
#line 326
  nbdkit_debug("get_size");
#line 328
  tmp = (*(plugin___3.get_size))(conn->handle);
  }
#line 328
  return (tmp);
}
}
#line 331 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_can_write(struct connection *conn ) 
{ 
  int tmp ;

  {
#line 334
  if (! dl) {
    {
#line 334
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 334U,
                  "plugin_can_write");
    }
  }
#line 335
  if (! conn->handle) {
    {
#line 335
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  335U, "plugin_can_write");
    }
  }
  {
#line 337
  nbdkit_debug("can_write");
  }
#line 339
  if (plugin___3.can_write) {
    {
#line 340
    tmp = (*(plugin___3.can_write))(conn->handle);
    }
#line 340
    return (tmp);
  } else {
#line 342
    return ((unsigned long )plugin___3.pwrite != (unsigned long )((void *)0));
  }
}
}
#line 345 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_can_flush(struct connection *conn ) 
{ 
  int tmp ;

  {
#line 348
  if (! dl) {
    {
#line 348
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 348U,
                  "plugin_can_flush");
    }
  }
#line 349
  if (! conn->handle) {
    {
#line 349
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  349U, "plugin_can_flush");
    }
  }
  {
#line 351
  nbdkit_debug("can_flush");
  }
#line 353
  if (plugin___3.can_flush) {
    {
#line 354
    tmp = (*(plugin___3.can_flush))(conn->handle);
    }
#line 354
    return (tmp);
  } else {
#line 356
    return ((unsigned long )plugin___3.flush != (unsigned long )((void *)0));
  }
}
}
#line 359 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_is_rotational(struct connection *conn ) 
{ 
  int tmp ;

  {
#line 362
  if (! dl) {
    {
#line 362
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 362U,
                  "plugin_is_rotational");
    }
  }
#line 363
  if (! conn->handle) {
    {
#line 363
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  363U, "plugin_is_rotational");
    }
  }
  {
#line 365
  nbdkit_debug("is_rotational");
  }
#line 367
  if (plugin___3.is_rotational) {
    {
#line 368
    tmp = (*(plugin___3.is_rotational))(conn->handle);
    }
#line 368
    return (tmp);
  } else {
#line 370
    return (0);
  }
}
}
#line 373 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_can_trim(struct connection *conn ) 
{ 
  int tmp ;

  {
#line 376
  if (! dl) {
    {
#line 376
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 376U,
                  "plugin_can_trim");
    }
  }
#line 377
  if (! conn->handle) {
    {
#line 377
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  377U, "plugin_can_trim");
    }
  }
  {
#line 379
  nbdkit_debug("can_trim");
  }
#line 381
  if (plugin___3.can_trim) {
    {
#line 382
    tmp = (*(plugin___3.can_trim))(conn->handle);
    }
#line 382
    return (tmp);
  } else {
#line 384
    return ((unsigned long )plugin___3.trim != (unsigned long )((void *)0));
  }
}
}
#line 387 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_pread(struct connection *conn , void *buf , uint32_t count , uint64_t offset ) 
{ 
  int tmp ;

  {
#line 391
  if (! dl) {
    {
#line 391
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 391U,
                  "plugin_pread");
    }
  }
#line 392
  if (! conn->handle) {
    {
#line 392
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  392U, "plugin_pread");
    }
  }
#line 393
  if (! ((unsigned long )plugin___3.pread != (unsigned long )((void *)0))) {
    {
#line 393
    __assert_fail("plugin.pread != ((void *)0)", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  393U, "plugin_pread");
    }
  }
  {
#line 395
  nbdkit_debug("pread count=%u offset=%lu", count, offset);
#line 397
  tmp = (*(plugin___3.pread))(conn->handle, buf, count, offset);
  }
#line 397
  return (tmp);
}
}
#line 400 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_pwrite(struct connection *conn , void *buf , uint32_t count , uint64_t offset ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
#line 404
  if (! dl) {
    {
#line 404
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 404U,
                  "plugin_pwrite");
    }
  }
#line 405
  if (! conn->handle) {
    {
#line 405
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  405U, "plugin_pwrite");
    }
  }
  {
#line 407
  nbdkit_debug("pwrite count=%u offset=%lu", count, offset);
  }
#line 409
  if ((unsigned long )plugin___3.pwrite != (unsigned long )((void *)0)) {
    {
#line 410
    tmp = (*(plugin___3.pwrite))(conn->handle, (void const   *)buf, count, offset);
    }
#line 410
    return (tmp);
  } else {
    {
#line 412
    tmp___0 = __errno_location();
#line 412
    *tmp___0 = 30;
    }
#line 413
    return (-1);
  }
}
}
#line 417 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_flush(struct connection *conn ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
#line 420
  if (! dl) {
    {
#line 420
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 420U,
                  "plugin_flush");
    }
  }
#line 421
  if (! conn->handle) {
    {
#line 421
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  421U, "plugin_flush");
    }
  }
  {
#line 423
  nbdkit_debug("flush");
  }
#line 425
  if ((unsigned long )plugin___3.flush != (unsigned long )((void *)0)) {
    {
#line 426
    tmp = (*(plugin___3.flush))(conn->handle);
    }
#line 426
    return (tmp);
  } else {
    {
#line 428
    tmp___0 = __errno_location();
#line 428
    *tmp___0 = 22;
    }
#line 429
    return (-1);
  }
}
}
#line 433 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c"
int plugin_trim(struct connection *conn , uint32_t count , uint64_t offset ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
#line 436
  if (! dl) {
    {
#line 436
    __assert_fail("dl", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c", 436U,
                  "plugin_trim");
    }
  }
#line 437
  if (! conn->handle) {
    {
#line 437
    __assert_fail("conn->handle", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/plugins.c",
                  437U, "plugin_trim");
    }
  }
  {
#line 439
  nbdkit_debug("trim count=%u offset=%lu", count, offset);
  }
#line 441
  if ((unsigned long )plugin___3.trim != (unsigned long )((void *)0)) {
    {
#line 442
    tmp = (*(plugin___3.trim))(conn->handle, count, offset);
    }
#line 442
    return (tmp);
  } else {
    {
#line 444
    tmp___0 = __errno_location();
#line 444
    *tmp___0 = 22;
    }
#line 445
    return (-1);
  }
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 51 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
char const   *ipaddr  ;
#line 52 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
char const   *port  ;
#line 53 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
int readonly  ;
#line 54 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
char *unixsocket  ;
#line 55 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
int verbose  ;
#line 57 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
int volatile   quit  ;
#line 109
int *bind_unix_socket(size_t *nr_socks ) ;
#line 110
int *bind_tcpip_socket(size_t *nr_socks ) ;
#line 111
void accept_incoming_connections(int *socks , size_t nr_socks ) ;
#line 112
void free_listening_sockets(int *socks , size_t nr_socks ) ;
#line 115
void tls_init(void) ;
#line 116
void tls_new_server_thread(void) ;
#line 56 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void start_serving(void) ;
#line 57
static void set_up_signals(void) ;
#line 58
static void change_user(void) ;
#line 59
static void write_pidfile(void) ;
#line 60
static void fork_into_background(void) ;
#line 61
static uid_t parseuser(char const   *id ) ;
#line 62
static gid_t parsegroup(char const   *id ) ;
#line 64 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
int foreground  ;
#line 66 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
int listen_stdin  ;
#line 67 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
char *pidfile  ;
#line 71 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
char const   *user  ;
#line 71 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
char const   *group  ;
#line 78 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static char const   *short_options  =    "fg:i:p:P:rsu:U:vV";
#line 79 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static struct option  const  long_options[17]  = 
#line 79
  {      {"help", 0, (int *)((void *)0), 128}, 
        {"foreground", 0, (int *)((void *)0), 'f'}, 
        {"no-fork", 0, (int *)((void *)0), 'f'}, 
        {"group", 1, (int *)((void *)0), 'g'}, 
        {"ip-addr", 1, (int *)((void *)0), 'i'}, 
        {"ipaddr", 1, (int *)((void *)0), 'i'}, 
        {"pid-file", 1, (int *)((void *)0), 'P'}, 
        {"pidfile", 1, (int *)((void *)0), 'P'}, 
        {"port", 1, (int *)((void *)0), 'p'}, 
        {"read-only", 0, (int *)((void *)0), 'r'}, 
        {"readonly", 0, (int *)((void *)0), 'r'}, 
        {"single", 0, (int *)((void *)0), 's'}, 
        {"stdin", 0, (int *)((void *)0), 's'}, 
        {"unix", 1, (int *)((void *)0), 'U'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}};
#line 99 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void usage(void) 
{ 


  {
  {
#line 102
  printf((char const   */* __restrict  */)"nbdkit [-f] [-g GROUP] [-i IPADDR] [-P PIDFILE] [-p PORT]\n       [-r] [-s] [-U SOCKET] [-u USER] [-v] [-V]\n       PLUGIN.so [key=value [key=value [...]]]\n\nPlease read the nbdkit(1) manual page for full usage.\n");
  }
#line 107
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void display_version(void) 
{ 


  {
  {
#line 112
  printf((char const   */* __restrict  */)"%s %s\n", "nbdkit", "1.1.3");
  }
#line 113
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int option_index ;
  int help ;
  int version ;
  char const   *filename___2 ;
  void *dl___0 ;
  struct nbdkit_plugin *(*plugin_init___0)(void) ;
  char *error ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 120
  help = 0;
#line 120
  version = 0;
#line 122
  tls_init();
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    c = getopt_long(argc, (char * const  *)argv, short_options, long_options, & option_index);
    }
#line 126
    if (c == -1) {
#line 127
      goto while_break;
    }
    {
#line 130
    if (c == 0) {
#line 130
      goto case_0;
    }
#line 135
    if (c == 102) {
#line 135
      goto case_102;
    }
#line 139
    if (c == 103) {
#line 139
      goto case_103;
    }
#line 143
    if (c == 105) {
#line 143
      goto case_105;
    }
#line 147
    if (c == 80) {
#line 147
      goto case_80;
    }
#line 153
    if (c == 112) {
#line 153
      goto case_112;
    }
#line 157
    if (c == 114) {
#line 157
      goto case_114;
    }
#line 161
    if (c == 115) {
#line 161
      goto case_115;
    }
#line 165
    if (c == 85) {
#line 165
      goto case_85;
    }
#line 171
    if (c == 117) {
#line 171
      goto case_117;
    }
#line 175
    if (c == 118) {
#line 175
      goto case_118;
    }
#line 179
    if (c == 86) {
#line 179
      goto case_86;
    }
#line 183
    if (c == 128) {
#line 183
      goto case_128;
    }
#line 187
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown long option: %s (%d)\n",
            program_invocation_short_name, long_options[option_index].name, option_index);
#line 133
    exit(1);
    }
    case_102: /* CIL Label */ 
#line 136
    foreground = 1;
#line 137
    goto switch_break;
    case_103: /* CIL Label */ 
#line 140
    group = (char const   *)optarg;
#line 141
    goto switch_break;
    case_105: /* CIL Label */ 
#line 144
    ipaddr = (char const   *)optarg;
#line 145
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 148
    pidfile = nbdkit_absolute_path((char const   *)optarg);
    }
#line 149
    if ((unsigned long )pidfile == (unsigned long )((void *)0)) {
      {
#line 150
      exit(1);
      }
    }
#line 151
    goto switch_break;
    case_112: /* CIL Label */ 
#line 154
    port = (char const   *)optarg;
#line 155
    goto switch_break;
    case_114: /* CIL Label */ 
#line 158
    readonly = 1;
#line 159
    goto switch_break;
    case_115: /* CIL Label */ 
#line 162
    listen_stdin = 1;
#line 163
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 166
    unixsocket = nbdkit_absolute_path((char const   *)optarg);
    }
#line 167
    if ((unsigned long )unixsocket == (unsigned long )((void *)0)) {
      {
#line 168
      exit(1);
      }
    }
#line 169
    goto switch_break;
    case_117: /* CIL Label */ 
#line 172
    user = (char const   *)optarg;
#line 173
    goto switch_break;
    case_118: /* CIL Label */ 
#line 176
    verbose = 1;
#line 177
    goto switch_break;
    case_86: /* CIL Label */ 
#line 180
    version = 1;
#line 181
    goto switch_break;
    case_128: /* CIL Label */ 
#line 184
    help = 1;
#line 185
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 188
    usage();
#line 189
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (optind >= argc) {
#line 195
    if (help) {
      {
#line 196
      usage();
#line 197
      exit(0);
      }
    }
#line 199
    if (version) {
      {
#line 200
      display_version();
#line 201
      exit(0);
      }
    }
    {
#line 205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no plugins given on the command line.\nRead nbdkit(1) for documentation.\n",
            program_invocation_short_name);
#line 208
    exit(1);
    }
  }
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    if (! (optind < argc)) {
#line 218
      goto while_break___0;
    }
    {
#line 219
    filename___2 = (char const   *)*(argv + optind);
#line 225
    dl___0 = dlopen(filename___2, 2);
    }
#line 226
    if ((unsigned long )dl___0 == (unsigned long )((void *)0)) {
      {
#line 227
      tmp = dlerror();
#line 227
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program_invocation_short_name, filename___2, tmp);
#line 228
      exit(1);
      }
    }
    {
#line 232
    dlerror();
#line 233
    *((void **)(& plugin_init___0)) = dlsym((void */* __restrict  */)dl___0, (char const   */* __restrict  */)"plugin_init");
#line 234
    error = dlerror();
    }
#line 234
    if ((unsigned long )error != (unsigned long )((void *)0)) {
      {
#line 235
      tmp___0 = dlerror();
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program_invocation_short_name, filename___2, tmp___0);
#line 236
      exit(1);
      }
    }
#line 238
    if (! plugin_init___0) {
      {
#line 239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: invalid plugin_init\n",
              program_invocation_short_name, filename___2);
#line 240
      exit(1);
      }
    }
    {
#line 244
    plugin_register(filename___2, dl___0, plugin_init___0);
#line 247
    optind ++;
    }
    {
#line 248
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 248
      if (optind < argc) {
        {
#line 248
        p = strchr((char const   *)*(argv + optind), '=');
        }
#line 248
        if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 248
          goto while_break___1;
        }
      } else {
#line 248
        goto while_break___1;
      }
#line 249
      if (help) {
#line 250
        goto while_continue___1;
      } else
#line 249
      if (version) {
#line 250
        goto while_continue___1;
      }
      {
#line 252
      *p = (char )'\000';
#line 253
      plugin_config((char const   *)*(argv + optind), (char const   *)(p + 1));
#line 255
      optind ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 258
    if (help) {
      {
#line 259
      usage();
#line 260
      printf((char const   */* __restrict  */)"\n%s:\n\n", filename___2);
#line 261
      plugin_usage();
#line 262
      exit(0);
      }
    }
#line 265
    if (version) {
      {
#line 266
      display_version();
#line 267
      plugin_version();
#line 268
      exit(0);
      }
    }
    {
#line 271
    plugin_config_complete();
#line 277
    optind ++;
    }
#line 278
    if (optind < argc) {
      {
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: this server only supports a single plugin\n",
              program_invocation_short_name);
#line 281
      exit(1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 285
  start_serving();
#line 287
  plugin_cleanup();
#line 289
  free((void *)unixsocket);
#line 290
  free((void *)pidfile);
#line 292
  exit(0);
  }
}
}
#line 295 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void start_serving(void) 
{ 
  int *socks ;
  size_t nr_socks ;
  int tmp ;

  {
#line 306
  if (port) {
#line 306
    if (unixsocket) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -p, -U and -s options cannot appear at the same time\n",
              program_invocation_short_name);
#line 310
      exit(1);
      }
    } else {
#line 306
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 306
  if (port) {
#line 306
    if (listen_stdin) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -p, -U and -s options cannot appear at the same time\n",
              program_invocation_short_name);
#line 310
      exit(1);
      }
    } else {
#line 306
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 306
  if (unixsocket) {
#line 306
    if (listen_stdin) {
      {
#line 308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -p, -U and -s options cannot appear at the same time\n",
              program_invocation_short_name);
#line 310
      exit(1);
      }
    }
  }
  {
#line 313
  set_up_signals();
  }
#line 316
  if (listen_stdin) {
    {
#line 317
    change_user();
#line 318
    write_pidfile();
#line 319
    tls_new_server_thread();
#line 320
    tmp = handle_single_connection(0, 1);
    }
#line 320
    if (tmp == -1) {
      {
#line 321
      exit(1);
      }
    }
#line 322
    return;
  }
#line 326
  if (unixsocket) {
    {
#line 327
    socks = bind_unix_socket(& nr_socks);
    }
  } else {
    {
#line 329
    socks = bind_tcpip_socket(& nr_socks);
    }
  }
  {
#line 331
  change_user();
#line 332
  fork_into_background();
#line 333
  write_pidfile();
#line 334
  accept_incoming_connections(socks, nr_socks);
#line 336
  free_listening_sockets(socks, nr_socks);
  }
#line 337
  return;
}
}
#line 339 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void handle_quit(int sig ) 
{ 


  {
#line 342
  quit = (int volatile   )1;
#line 343
  return;
}
}
#line 345 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void set_up_signals(void) 
{ 
  struct sigaction sa ;

  {
  {
#line 350
  memset((void *)(& sa), 0, sizeof(sa));
#line 351
  sa.sa_flags = 268435456;
#line 352
  sa.__sigaction_handler.sa_handler = & handle_quit;
#line 353
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 354
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 355
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 356
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 358
  memset((void *)(& sa), 0, sizeof(sa));
#line 359
  sa.sa_flags = 268435456;
#line 360
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 361
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 362
  return;
}
}
#line 364 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void change_user(void) 
{ 
  gid_t gid ;
  gid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uid_t uid ;
  uid_t tmp___2 ;
  int tmp___3 ;

  {
#line 367
  if (group) {
    {
#line 368
    tmp = parsegroup(group);
#line 368
    gid = tmp;
#line 370
    tmp___0 = setgid(gid);
    }
#line 370
    if (tmp___0 == -1) {
      {
#line 371
      perror("setgid");
#line 372
      exit(1);
      }
    }
    {
#line 376
    tmp___1 = setgroups((size_t )1, (__gid_t const   *)(& gid));
    }
#line 376
    if (tmp___1 == -1) {
      {
#line 377
      perror("setgroups");
#line 378
      exit(1);
      }
    }
    {
#line 381
    nbdkit_debug("changed group to %s", group);
    }
  }
#line 384
  if (user) {
    {
#line 385
    tmp___2 = parseuser(user);
#line 385
    uid = tmp___2;
#line 387
    tmp___3 = setuid(uid);
    }
#line 387
    if (tmp___3 == -1) {
      {
#line 388
      perror("setuid");
#line 389
      exit(1);
      }
    }
    {
#line 392
    nbdkit_debug("changed user to %s", user);
    }
  }
#line 394
  return;
}
}
#line 396 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void write_pidfile(void) 
{ 
  int fd ;
  pid_t pid ;
  char pidstr[64] ;
  size_t len ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 404
  if (! pidfile) {
#line 405
    return;
  }
  {
#line 407
  pid = getpid();
#line 408
  snprintf((char */* __restrict  */)(pidstr), sizeof(pidstr), (char const   */* __restrict  */)"%d\n",
           pid);
#line 409
  len = strlen((char const   *)(pidstr));
#line 411
  fd = open((char const   *)pidfile, 525121, 420);
  }
#line 412
  if (fd == -1) {
    {
#line 413
    perror((char const   *)pidfile);
#line 414
    exit(1);
    }
  }
  {
#line 417
  tmp = write(fd, (void const   *)(pidstr), len);
  }
#line 417
  if ((size_t )tmp < len) {
    {
#line 419
    perror((char const   *)pidfile);
#line 420
    exit(1);
    }
  } else {
    {
#line 417
    tmp___0 = close(fd);
    }
#line 417
    if (tmp___0 == -1) {
      {
#line 419
      perror((char const   *)pidfile);
#line 420
      exit(1);
      }
    }
  }
  {
#line 423
  nbdkit_debug("written pidfile %s", pidfile);
  }
#line 424
  return;
}
}
#line 426 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static void fork_into_background(void) 
{ 
  pid_t pid ;
  __pid_t tmp ;

  {
#line 431
  if (foreground) {
#line 432
    return;
  }
  {
#line 434
  pid = fork();
  }
#line 435
  if (pid == -1) {
    {
#line 436
    perror("fork");
#line 437
    exit(1);
    }
  }
#line 440
  if (pid > 0) {
    {
#line 441
    exit(0);
    }
  }
  {
#line 443
  chdir("/");
#line 446
  close(0);
#line 447
  close(1);
#line 448
  open("/dev/null", 0);
#line 449
  open("/dev/null", 1);
  }
#line 452
  if (! verbose) {
    {
#line 453
    dup2(1, 2);
    }
  }
  {
#line 455
  tmp = getpid();
#line 455
  nbdkit_debug("forked into background (new pid = %d)", tmp);
  }
#line 456
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static uid_t parseuser(char const   *id ) 
{ 
  struct passwd *pwd ;
  int saved_errno ;
  int *tmp ;
  int val ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 464
  tmp = __errno_location();
#line 464
  *tmp = 0;
#line 465
  pwd = getpwnam(id);
  }
#line 467
  if ((unsigned long )((void *)0) == (unsigned long )pwd) {
    {
#line 470
    tmp___0 = __errno_location();
#line 470
    saved_errno = *tmp___0;
#line 472
    tmp___1 = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%d",
                     & val);
    }
#line 472
    if (tmp___1 == 1) {
#line 473
      return ((uid_t )val);
    }
    {
#line 475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -u option: %s is not a valid user name or uid",
            program_invocation_short_name, id);
    }
#line 477
    if (saved_errno != 0) {
      {
#line 478
      tmp___2 = strerror(saved_errno);
#line 478
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (getpwnam error: %s)",
              tmp___2);
      }
    }
    {
#line 479
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 480
    exit(1);
    }
  }
#line 483
  return (pwd->pw_uid);
}
}
#line 486 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/main.c"
static gid_t parsegroup(char const   *id ) 
{ 
  struct group *grp ;
  int saved_errno ;
  int *tmp ;
  int val ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 492
  tmp = __errno_location();
#line 492
  *tmp = 0;
#line 493
  grp = getgrnam(id);
  }
#line 495
  if ((unsigned long )((void *)0) == (unsigned long )grp) {
    {
#line 498
    tmp___0 = __errno_location();
#line 498
    saved_errno = *tmp___0;
#line 500
    tmp___1 = sscanf((char const   */* __restrict  */)id, (char const   */* __restrict  */)"%d",
                     & val);
    }
#line 500
    if (tmp___1 == 1) {
#line 501
      return ((gid_t )val);
    }
    {
#line 503
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -g option: %s is not a valid group name or gid",
            program_invocation_short_name, id);
    }
#line 505
    if (saved_errno != 0) {
      {
#line 506
      tmp___2 = strerror(saved_errno);
#line 506
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (getgrnam error: %s)",
              tmp___2);
      }
    }
    {
#line 507
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 508
    exit(1);
    }
  }
#line 511
  return (grp->gr_gid);
}
}
#line 1122 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                                                         void (*__destr_function)(void * ) ) ;
#line 1130
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) ;
#line 1133
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                                                          void const   *__pointer ) ;
#line 118 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/internal.h"
void tls_set_instance_num(size_t instance_num___0 ) ;
#line 119
void tls_set_sockaddr(struct sockaddr *addr , socklen_t addrlen ) ;
#line 61 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
static pthread_key_t tls_key  ;
#line 63 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
static void free_tls(void *tlsv ) 
{ 
  struct tls *tls ;

  {
  {
#line 66
  tls = (struct tls *)tlsv;
#line 68
  free((void *)tls->addr);
#line 69
  free((void *)tls);
  }
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
void tls_init(void) 
{ 
  int err ;
  char *tmp ;

  {
  {
#line 77
  err = pthread_key_create(& tls_key, & free_tls);
  }
#line 78
  if (err != 0) {
    {
#line 79
    tmp = strerror(err);
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: pthread_key_create: %s\n",
            program_invocation_short_name, tmp);
#line 81
    exit(1);
    }
  }
#line 83
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
void tls_new_server_thread(void) 
{ 
  struct tls *tls ;
  void *tmp ;

  {
  {
#line 90
  tmp = calloc((size_t )1, sizeof(*tls));
#line 90
  tls = (struct tls *)tmp;
  }
#line 91
  if ((unsigned long )tls == (unsigned long )((void *)0)) {
    {
#line 92
    perror("malloc");
#line 93
    exit(1);
    }
  }
  {
#line 95
  pthread_setspecific(tls_key, (void const   *)tls);
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
void tls_set_name(char const   *name ) 
{ 
  struct tls *tls ;
  void *tmp ;

  {
  {
#line 101
  tmp = pthread_getspecific(tls_key);
#line 101
  tls = (struct tls *)tmp;
  }
#line 103
  if (tls) {
#line 104
    tls->name = name;
  }
#line 105
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
void tls_set_instance_num(size_t instance_num___0 ) 
{ 
  struct tls *tls ;
  void *tmp ;

  {
  {
#line 110
  tmp = pthread_getspecific(tls_key);
#line 110
  tls = (struct tls *)tmp;
  }
#line 112
  if (tls) {
#line 113
    tls->instance_num = instance_num___0;
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
void tls_set_sockaddr(struct sockaddr *addr , socklen_t addrlen ) 
{ 
  struct tls *tls ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 119
  tmp = pthread_getspecific(tls_key);
#line 119
  tls = (struct tls *)tmp;
  }
#line 121
  if (tls) {
    {
#line 122
    free((void *)tls->addr);
#line 123
    tmp___0 = calloc((size_t )1, (size_t )addrlen);
#line 123
    tls->addr = (struct sockaddr *)tmp___0;
    }
#line 124
    if ((unsigned long )tls->addr == (unsigned long )((void *)0)) {
      {
#line 125
      perror("calloc");
#line 126
      exit(1);
      }
    }
    {
#line 128
    memcpy((void */* __restrict  */)tls->addr, (void const   */* __restrict  */)addr,
           (size_t )addrlen);
    }
  }
#line 130
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
char const   *tls_get_name(void) 
{ 
  struct tls *tls ;
  void *tmp ;

  {
  {
#line 135
  tmp = pthread_getspecific(tls_key);
#line 135
  tls = (struct tls *)tmp;
  }
#line 137
  if (! tls) {
#line 138
    return ((char const   *)((void *)0));
  }
#line 140
  return (tls->name);
}
}
#line 143 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/tls.c"
size_t tls_get_instance_num(void) 
{ 
  struct tls *tls ;
  void *tmp ;

  {
  {
#line 146
  tmp = pthread_getspecific(tls_key);
#line 146
  tls = (struct tls *)tmp;
  }
#line 148
  if (! tls) {
#line 149
    return ((size_t )0);
  }
#line 151
  return (tls->instance_num);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 301
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 310
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 54 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
int *bind_unix_socket(size_t *nr_socks ) 
{ 
  size_t len ;
  int sock ;
  struct sockaddr_un addr ;
  int *ret ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 62
  if (! unixsocket) {
    {
#line 62
    __assert_fail("unixsocket", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c",
                  62U, "bind_unix_socket");
    }
  }
#line 63
  if (! ((int )*(unixsocket + 0) == 47)) {
    {
#line 63
    __assert_fail("unixsocket[0] == \'/\'", "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c",
                  63U, "bind_unix_socket");
    }
  }
  {
#line 65
  len = strlen((char const   *)unixsocket);
  }
#line 66
  if (len >= 108UL) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -U option: path too long (max is %d) bytes",
            program_invocation_short_name, 107);
#line 69
    exit(1);
    }
  }
  {
#line 72
  sock = socket(1, 524289, 0);
  }
#line 73
  if (sock == -1) {
    {
#line 74
    perror("socket");
#line 75
    exit(1);
    }
  }
  {
#line 78
  addr.sun_family = (sa_family_t )1;
#line 79
  memcpy((void */* __restrict  */)(addr.sun_path), (void const   */* __restrict  */)unixsocket,
         len + 1UL);
#line 81
  tmp = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
             (socklen_t )sizeof(addr));
  }
#line 81
  if (tmp == -1) {
    {
#line 82
    perror((char const   *)unixsocket);
#line 83
    exit(1);
    }
  }
  {
#line 86
  tmp___0 = listen(sock, 128);
  }
#line 86
  if (tmp___0 == -1) {
    {
#line 87
    perror("listen");
#line 88
    exit(1);
    }
  }
  {
#line 91
  tmp___1 = malloc(sizeof(int ));
#line 91
  ret = (int *)tmp___1;
  }
#line 92
  if (! ret) {
    {
#line 93
    perror("malloc");
#line 94
    exit(1);
    }
  }
  {
#line 96
  *(ret + 0) = sock;
#line 97
  *nr_socks = (size_t )1;
#line 99
  nbdkit_debug("bound to unix socket %s", unixsocket);
  }
#line 101
  return (ret);
}
}
#line 104 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
int *bind_tcpip_socket(size_t *nr_socks ) 
{ 
  struct addrinfo *ai ;
  struct addrinfo hints ;
  struct addrinfo *a ;
  int err ;
  int opt ;
  int *socks ;
  _Bool addr_in_use ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int sock ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 107
  ai = (struct addrinfo *)((void *)0);
#line 111
  socks = (int *)((void *)0);
#line 114
  if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 115
    port = "10809";
  }
  {
#line 117
  memset((void *)(& hints), 0, sizeof(hints));
#line 118
  hints.ai_flags = 33;
#line 119
  hints.ai_socktype = 1;
#line 121
  err = getaddrinfo((char const   */* __restrict  */)ipaddr, (char const   */* __restrict  */)port,
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 122
  if (err != 0) {
    {
#line 123
    tmp = gai_strerror(err);
    }
#line 123
    if (ipaddr) {
#line 123
      tmp___0 = ipaddr;
    } else {
#line 123
      tmp___0 = "<any>";
    }
    {
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: getaddrinfo: %s: %s: %s",
            program_invocation_short_name, tmp___0, port, tmp);
#line 128
    exit(1);
    }
  }
#line 131
  *nr_socks = (size_t )0;
#line 133
  a = ai;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 133
      goto while_break;
    }
    {
#line 136
    sock = socket(a->ai_family, a->ai_socktype, a->ai_protocol);
    }
#line 137
    if (sock == -1) {
      {
#line 138
      perror("socket");
#line 139
      exit(1);
      }
    }
    {
#line 142
    opt = 1;
#line 143
    tmp___1 = setsockopt(sock, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
    }
#line 143
    if (tmp___1 == -1) {
      {
#line 144
      perror("setsockopt: SO_REUSEADDR");
      }
    }
#line 147
    if (a->ai_family == 10) {
      {
#line 148
      tmp___2 = setsockopt(sock, 41, 26, (void const   *)(& opt), (socklen_t )sizeof(opt));
      }
#line 148
      if (tmp___2 == -1) {
        {
#line 149
        perror("setsockopt: IPv6 only");
        }
      }
    }
    {
#line 153
    tmp___4 = bind(sock, (struct sockaddr  const  */* __restrict  */)a->ai_addr, a->ai_addrlen);
    }
#line 153
    if (tmp___4 == -1) {
      {
#line 154
      tmp___3 = __errno_location();
      }
#line 154
      if (*tmp___3 == 98) {
        {
#line 155
        addr_in_use = (_Bool)1;
#line 156
        close(sock);
        }
#line 157
        goto __Cont;
      }
      {
#line 159
      perror("bind");
#line 160
      exit(1);
      }
    }
    {
#line 163
    tmp___5 = listen(sock, 128);
    }
#line 163
    if (tmp___5 == -1) {
      {
#line 164
      perror("listen");
#line 165
      exit(1);
      }
    }
    {
#line 168
    (*nr_socks) ++;
#line 169
    tmp___6 = realloc((void *)socks, sizeof(int ) * *nr_socks);
#line 169
    socks = (int *)tmp___6;
    }
#line 170
    if (! socks) {
      {
#line 171
      perror("realloc");
#line 172
      exit(1);
      }
    }
#line 174
    *(socks + (*nr_socks - 1UL)) = sock;
    __Cont: /* CIL Label */ 
#line 133
    a = a->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  freeaddrinfo(ai);
  }
#line 179
  if (*nr_socks == 0UL) {
#line 179
    if (addr_in_use) {
      {
#line 180
      tmp___7 = strerror(98);
#line 180
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to bind to any sockets: %s\n",
              program_invocation_short_name, tmp___7);
#line 182
      exit(1);
      }
    }
  }
#line 185
  if (ipaddr) {
#line 185
    tmp___8 = ipaddr;
  } else {
#line 185
    tmp___8 = "<any>";
  }
  {
#line 185
  nbdkit_debug("bound to IP address %s:%s (%zu socket(s))", tmp___8, port, *nr_socks);
  }
#line 188
  return (socks);
}
}
#line 191 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
void free_listening_sockets(int *socks , size_t nr_socks ) 
{ 
  size_t i ;

  {
#line 196
  i = (size_t )0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < nr_socks)) {
#line 196
      goto while_break;
    }
    {
#line 197
    close(*(socks + i));
#line 196
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  free((void *)socks);
  }
#line 199
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
static void *start_thread(void *datav ) 
{ 
  struct thread_data *data___0 ;

  {
  {
#line 211
  data___0 = (struct thread_data *)datav;
#line 213
  nbdkit_debug("accepted connection");
#line 216
  tls_new_server_thread();
#line 217
  tls_set_instance_num(data___0->instance_num);
#line 218
  tls_set_sockaddr(& data___0->addr, data___0->addrlen);
#line 220
  handle_single_connection(data___0->sock, data___0->sock);
  }
#line 222
  return ((void *)0);
}
}
#line 232
static void accept_connection(int listen_sock ) ;
#line 232 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
static size_t instance_num  =    (size_t )1;
#line 225 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
static void accept_connection(int listen_sock ) 
{ 
  int err ;
  pthread_attr_t attrs ;
  pthread_t thread ;
  struct thread_data thread_data ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 234
  tmp = instance_num;
#line 234
  instance_num ++;
#line 234
  thread_data.instance_num = tmp;
#line 235
  thread_data.addrlen = (socklen_t )sizeof(thread_data.addr);
  again: 
  {
#line 237
  thread_data.sock = accept(listen_sock, (struct sockaddr */* __restrict  */)(& thread_data.addr),
                            (socklen_t */* __restrict  */)(& thread_data.addrlen));
  }
#line 239
  if (thread_data.sock == -1) {
    {
#line 240
    tmp___0 = __errno_location();
    }
#line 240
    if (*tmp___0 == 4) {
#line 241
      goto again;
    } else {
      {
#line 240
      tmp___1 = __errno_location();
      }
#line 240
      if (*tmp___1 == 11) {
#line 241
        goto again;
      }
    }
    {
#line 242
    perror("accept");
    }
#line 243
    return;
  }
  {
#line 250
  pthread_attr_init(& attrs);
#line 251
  pthread_attr_setdetachstate(& attrs, 1);
#line 252
  err = pthread_create((pthread_t */* __restrict  */)(& thread), (pthread_attr_t const   */* __restrict  */)(& attrs),
                       & start_thread, (void */* __restrict  */)(& thread_data));
#line 253
  pthread_attr_destroy(& attrs);
  }
#line 254
  if (err != 0) {
    {
#line 255
    tmp___2 = strerror(err);
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: pthread_create: %s\n",
            program_invocation_short_name, tmp___2);
#line 256
    close(thread_data.sock);
    }
#line 257
    return;
  }
#line 263
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/sockets.c"
void accept_incoming_connections(int *socks , size_t nr_socks ) 
{ 
  struct pollfd *fds ;
  unsigned long __lengthoffds ;
  void *tmp ;
  size_t i ;
  int r ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 268
  __lengthoffds = nr_socks;
#line 268
  tmp = __builtin_alloca(sizeof(*fds) * __lengthoffds);
#line 268
  fds = (struct pollfd *)tmp;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (! quit)) {
#line 272
      goto while_break;
    }
#line 273
    i = (size_t )0;
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (! (i < nr_socks)) {
#line 273
        goto while_break___0;
      }
#line 274
      (fds + i)->fd = *(socks + i);
#line 275
      (fds + i)->events = (short)1;
#line 276
      (fds + i)->revents = (short)0;
#line 273
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 279
    r = poll(fds, nr_socks, -1);
    }
#line 280
    if (r == -1) {
      {
#line 281
      tmp___0 = __errno_location();
      }
#line 281
      if (*tmp___0 == 4) {
#line 282
        goto while_continue;
      } else {
        {
#line 281
        tmp___1 = __errno_location();
        }
#line 281
        if (*tmp___1 == 11) {
#line 282
          goto while_continue;
        }
      }
      {
#line 283
      perror("poll");
#line 284
      exit(1);
      }
    }
#line 287
    i = (size_t )0;
    {
#line 287
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 287
      if (! (i < nr_socks)) {
#line 287
        goto while_break___1;
      }
#line 288
      if ((int )(fds + i)->revents & 1) {
        {
#line 289
        accept_connection((fds + i)->fd);
        }
      }
#line 287
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 517 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) get_current_dir_name)(void) ;
#line 48 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/utils.c"
char *nbdkit_absolute_path(char const   *path ) 
{ 
  char __attribute__((__cleanup__(cleanup_free)))  *pwd ;
  char *ret ;
  char *tmp ;
  int tmp___0 ;

  {
#line 51
  pwd = (char __attribute__((__cleanup__(cleanup_free)))  *)((void *)0);
#line 54
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 55
    nbdkit_error("cannot convert null or empty path to an absolute path");
    }
#line 56
    return ((char *)((void *)0));
  } else
#line 54
  if ((int const   )*path == 0) {
    {
#line 55
    nbdkit_error("cannot convert null or empty path to an absolute path");
    }
#line 56
    return ((char *)((void *)0));
  }
#line 59
  if ((int const   )*path == 47) {
    {
#line 60
    ret = strdup(path);
    }
#line 61
    if (! ret) {
      {
#line 62
      nbdkit_error("strdup: %m");
      }
#line 63
      return ((char *)((void *)0));
    }
#line 65
    return (ret);
  }
  {
#line 68
  tmp = get_current_dir_name();
#line 68
  pwd = (char __attribute__((__cleanup__(cleanup_free)))  *)tmp;
  }
#line 69
  if ((unsigned long )pwd == (unsigned long )((void *)0)) {
    {
#line 70
    nbdkit_error("get_current_dir_name: %m");
    }
#line 71
    return ((char *)((void *)0));
  }
  {
#line 74
  tmp___0 = asprintf((char **/* __restrict  */)(& ret), (char const   */* __restrict  */)"%s/%s",
                     pwd, path);
  }
#line 74
  if (tmp___0 == -1) {
    {
#line 75
    nbdkit_error("asprintf: %m");
    }
#line 76
    return ((char *)((void *)0));
  }
#line 79
  return (ret);
}
}
#line 85 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/utils.c"
int64_t nbdkit_parse_size(char const   *str ) 
{ 
  uint64_t size___0 ;
  char t ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 91
  tmp = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%lu%c",
               & size___0, & t);
  }
#line 91
  if (tmp == 2) {
    {
#line 93
    if ((int )t == 66) {
#line 93
      goto case_66;
    }
#line 93
    if ((int )t == 98) {
#line 93
      goto case_66;
    }
#line 95
    if ((int )t == 75) {
#line 95
      goto case_75;
    }
#line 95
    if ((int )t == 107) {
#line 95
      goto case_75;
    }
#line 97
    if ((int )t == 77) {
#line 97
      goto case_77;
    }
#line 97
    if ((int )t == 109) {
#line 97
      goto case_77;
    }
#line 99
    if ((int )t == 71) {
#line 99
      goto case_71;
    }
#line 99
    if ((int )t == 103) {
#line 99
      goto case_71;
    }
#line 101
    if ((int )t == 84) {
#line 101
      goto case_84;
    }
#line 101
    if ((int )t == 116) {
#line 101
      goto case_84;
    }
#line 103
    if ((int )t == 80) {
#line 103
      goto case_80;
    }
#line 103
    if ((int )t == 112) {
#line 103
      goto case_80;
    }
#line 105
    if ((int )t == 69) {
#line 105
      goto case_69;
    }
#line 105
    if ((int )t == 101) {
#line 105
      goto case_69;
    }
#line 108
    if ((int )t == 83) {
#line 108
      goto case_83;
    }
#line 108
    if ((int )t == 115) {
#line 108
      goto case_83;
    }
#line 113
    goto switch_default;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 94
    return ((int64_t )size___0);
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 96
    return ((int64_t )size___0 * 1024L);
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 98
    return (((int64_t )size___0 * 1024L) * 1024L);
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
#line 100
    return ((((int64_t )size___0 * 1024L) * 1024L) * 1024L);
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 102
    return (((((int64_t )size___0 * 1024L) * 1024L) * 1024L) * 1024L);
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
#line 104
    return ((((((int64_t )size___0 * 1024L) * 1024L) * 1024L) * 1024L) * 1024L);
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 106
    return (((((((int64_t )size___0 * 1024L) * 1024L) * 1024L) * 1024L) * 1024L) * 1024L);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 111
    return ((int64_t )size___0 * 512L);
    switch_default: /* CIL Label */ 
    {
#line 114
    nbdkit_error("could not parse size: unknown specifier \'%c\'", (int )t);
    }
#line 115
    return ((int64_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 120
  tmp___0 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%lu",
                   & size___0);
  }
#line 120
  if (tmp___0 == 1) {
#line 121
    return ((int64_t )size___0);
  }
  {
#line 123
  nbdkit_error("could not parse size string (%s)", str);
  }
#line 124
  return ((int64_t )-1);
}
}
#line 130 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/utils.c"
int xwrite(int sock , void const   *vbuf , size_t len ) 
{ 
  char const   *buf ;
  ssize_t r ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 133
  buf = (char const   *)vbuf;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (len > 0UL)) {
#line 136
      goto while_break;
    }
    {
#line 137
    r = write(sock, (void const   *)buf, len);
    }
#line 138
    if (r == -1L) {
      {
#line 139
      tmp = __errno_location();
      }
#line 139
      if (*tmp == 4) {
#line 140
        goto while_continue;
      } else {
        {
#line 139
        tmp___0 = __errno_location();
        }
#line 139
        if (*tmp___0 == 11) {
#line 140
          goto while_continue;
        }
      }
#line 141
      return (-1);
    }
#line 143
    buf += r;
#line 144
    len -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (0);
}
}
#line 153 "/home/wheatley/newnew/temp/nbdkit-1.1.3/src/utils.c"
int xread(int sock , void *vbuf , size_t len ) 
{ 
  char *buf ;
  ssize_t r ;
  _Bool first_read ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 156
  buf = (char *)vbuf;
#line 158
  first_read = (_Bool)1;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (len > 0UL)) {
#line 160
      goto while_break;
    }
    {
#line 161
    r = read(sock, (void *)buf, len);
    }
#line 162
    if (r == -1L) {
      {
#line 163
      tmp = __errno_location();
      }
#line 163
      if (*tmp == 4) {
#line 164
        goto while_continue;
      } else {
        {
#line 163
        tmp___0 = __errno_location();
        }
#line 163
        if (*tmp___0 == 11) {
#line 164
          goto while_continue;
        }
      }
#line 165
      return (-1);
    }
#line 167
    if (r == 0L) {
#line 168
      if (first_read) {
#line 169
        return (0);
      }
      {
#line 171
      tmp___1 = __errno_location();
#line 171
      *tmp___1 = 74;
      }
#line 172
      return (-1);
    }
#line 174
    first_read = (_Bool)0;
#line 175
    buf += r;
#line 176
    len -= (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (1);
}
}
