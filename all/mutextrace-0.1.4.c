/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_3 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_3 pthread_mutex_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_6 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_5 {
   struct __anonstruct___data_6 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_5 pthread_cond_t;
#line 6 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.h"
enum state {
    uninitialized = 0,
    unlocked = 1,
    locked = 2,
    destroyed = 3
} ;
#line 14
struct mutex;
#line 16 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.h"
struct thread {
   pthread_t thread ;
   struct thread *left ;
   struct thread *right ;
   unsigned int num ;
   struct mutex *owns ;
};
#line 28 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.h"
struct mutex {
   pthread_mutex_t *mutex ;
   struct mutex *left ;
   struct mutex *right ;
   pthread_mutex_t lock ;
   pthread_cond_t cond ;
   unsigned int num ;
   enum state state ;
   int kind ;
   struct thread *owner ;
   struct mutex *owns_next ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_4 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_4 pthread_mutexattr_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_7 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_7 pthread_condattr_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 37 "/usr/include/elf.h"
typedef uint32_t Elf64_Word;
#line 43 "/usr/include/elf.h"
typedef uint64_t Elf64_Xword;
#line 44 "/usr/include/elf.h"
typedef int64_t Elf64_Sxword;
#line 48 "/usr/include/elf.h"
typedef uint64_t Elf64_Addr;
#line 56 "/usr/include/elf.h"
typedef uint16_t Elf64_Section;
#line 391 "/usr/include/elf.h"
struct __anonstruct_Elf64_Sym_39 {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Section st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 391 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Sym_39 Elf64_Sym;
#line 662 "/usr/include/elf.h"
union __anonunion_d_un_51 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
#line 662 "/usr/include/elf.h"
struct __anonstruct_Elf64_Dyn_50 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_51 d_un ;
};
#line 662 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Dyn_50 Elf64_Dyn;
#line 42 "/usr/include/link.h"
struct link_map;
#line 42
enum __anonenum_r_state_82 {
    RT_CONSISTENT = 0,
    RT_ADD = 1,
    RT_DELETE = 2
} ;
#line 42 "/usr/include/link.h"
struct r_debug {
   int r_version ;
   struct link_map *r_map ;
   Elf64_Addr r_brk ;
   enum __anonenum_r_state_82 r_state ;
   Elf64_Addr r_ldbase ;
};
#line 84 "/usr/include/link.h"
struct link_map {
   Elf64_Addr l_addr ;
   char *l_name ;
   Elf64_Dyn *l_ld ;
   struct link_map *l_next ;
   struct link_map *l_prev ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 534 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_24 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 534 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_23 {
   struct __anonstruct___cancel_jmp_buf_24 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 534 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_23  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 753
struct __jmp_buf_tag;
#line 12 "/home/wheatley/newnew/temp/mutextrace-0.1.4/thread_create.c"
struct startupinfo {
   void *(*start_routine)(void * ) ;
   void *arg ;
   pthread_cond_t cond ;
   pthread_mutex_t mutex ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutextrace.c"
int main(int argc , char **argv , char **envp ) 
{ 
  unsigned int max_args ;
  unsigned int max_envs ;
  unsigned int max_preload ;
  char **new_argv ;
  unsigned long __lengthofnew_argv ;
  void *tmp ;
  char **new_envp ;
  unsigned long __lengthofnew_envp ;
  void *tmp___0 ;
  char *new_preload ;
  unsigned long __lengthofnew_preload ;
  void *tmp___1 ;
  char *path ;
  char **i ;
  char **o ;
  char *ii ;
  char *oo ;
  char added_preloadlib ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char **tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  size_t cmdlen ;
  size_t tmp___8 ;
  size_t pathbuf_size ;
  char *pathbuf ;
  void *tmp___9 ;
  char *old_pathbuf ;
  void *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 16
  max_args = 512U;
#line 17
  max_envs = 512U;
#line 18
  max_preload = 512U;
#line 20
  __lengthofnew_argv = (unsigned long )max_args;
#line 20
  tmp = __builtin_alloca(sizeof(*new_argv) * __lengthofnew_argv);
#line 20
  new_argv = (char **)tmp;
#line 21
  __lengthofnew_envp = (unsigned long )max_envs;
#line 21
  tmp___0 = __builtin_alloca(sizeof(*new_envp) * __lengthofnew_envp);
#line 21
  new_envp = (char **)tmp___0;
#line 22
  __lengthofnew_preload = (unsigned long )max_preload;
#line 22
  tmp___1 = __builtin_alloca(sizeof(*new_preload) * __lengthofnew_preload);
#line 22
  new_preload = (char *)tmp___1;
#line 24
  path = (char *)0;
#line 29
  added_preloadlib = (char)0;
  }
#line 31
  if (argc == 1) {
    {
#line 33
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s command [args...]\n",
            *(argv + 0));
    }
#line 34
    return (1);
  }
#line 37
  i = argv + 1;
#line 38
  o = new_argv;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! argc) {
#line 40
      goto while_break;
    }
#line 41
    *o = *i;
#line 40
    argc --;
#line 40
    i ++;
#line 40
    o ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  *o = (char *)0;
#line 44
  i = envp;
#line 45
  o = new_envp;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! *i) {
#line 47
      goto while_break___0;
    }
    {
#line 49
    tmp___4 = strncmp((char const   *)*i, "LD_PRELOAD=", (size_t )11);
    }
#line 49
    if (tmp___4) {
      {
#line 51
      *o = *i;
#line 52
      tmp___2 = strncmp((char const   *)*i, "PATH=", (size_t )5);
      }
#line 52
      if (! tmp___2) {
#line 53
        path = *i + 5;
      }
    } else {
#line 57
      ii = *i;
#line 58
      oo = new_preload;
      {
#line 60
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 60
        if (! *ii) {
#line 60
          goto while_break___1;
        }
#line 61
        *oo = *ii;
#line 60
        ii ++;
#line 60
        oo ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 63
      tmp___3 = oo;
#line 63
      oo ++;
#line 63
      *tmp___3 = (char )' ';
#line 64
      strcpy((char */* __restrict  */)oo, (char const   */* __restrict  */)"/usr/local/lib/mutextrace/mutextrace.so");
#line 65
      *o = new_preload;
#line 67
      added_preloadlib = (char)1;
      }
    }
#line 47
    i ++;
#line 47
    o ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  if (! added_preloadlib) {
    {
#line 73
    strcpy((char */* __restrict  */)new_preload, (char const   */* __restrict  */)"LD_PRELOAD=/usr/local/lib/mutextrace/mutextrace.so");
#line 74
    tmp___5 = o;
#line 74
    o ++;
#line 74
    *tmp___5 = new_preload;
    }
  }
#line 77
  *o = (char *)0;
#line 79
  if (! path) {
    {
#line 81
    execve((char const   *)*(argv + 1), (char * const  *)new_argv, (char * const  *)new_envp);
#line 82
    tmp___6 = __errno_location();
#line 82
    tmp___7 = strerror(*tmp___6);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to run %s: %s\n",
            *(argv + 1), tmp___7);
    }
#line 83
    return (1);
  } else {
    {
#line 79
    tmp___15 = strchr((char const   *)*(argv + 1), '/');
    }
#line 79
    if (tmp___15) {
      {
#line 81
      execve((char const   *)*(argv + 1), (char * const  *)new_argv, (char * const  *)new_envp);
#line 82
      tmp___6 = __errno_location();
#line 82
      tmp___7 = strerror(*tmp___6);
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to run %s: %s\n",
              *(argv + 1), tmp___7);
      }
#line 83
      return (1);
    } else {
      {
#line 87
      ii = path;
#line 89
      tmp___8 = strlen((char const   *)*(argv + 1));
#line 89
      cmdlen = tmp___8 + 2UL;
#line 91
      pathbuf_size = (size_t )1024;
#line 92
      tmp___9 = malloc(pathbuf_size);
#line 92
      pathbuf = (char *)tmp___9;
      }
#line 93
      if (! pathbuf) {
        {
#line 95
        perror("malloc()");
        }
#line 96
        return (1);
      }
      {
#line 99
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 99
        if (! *ii) {
#line 99
          goto while_break___2;
        }
#line 101
        oo = pathbuf;
        {
#line 102
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 102
          if (*ii) {
#line 102
            if (! ((int )*ii != 58)) {
#line 102
              goto while_break___3;
            }
          } else {
#line 102
            goto while_break___3;
          }
#line 104
          if ((unsigned long )oo == (unsigned long )((pathbuf + pathbuf_size) - cmdlen)) {
            {
#line 106
            old_pathbuf = pathbuf;
#line 107
            pathbuf_size <<= 1;
#line 108
            tmp___10 = realloc((void *)pathbuf, pathbuf_size);
#line 108
            pathbuf = (char *)tmp___10;
            }
#line 109
            if (! pathbuf) {
              {
#line 111
              perror("realloc()");
              }
#line 112
              return (1);
            }
#line 114
            oo = pathbuf + (oo - old_pathbuf);
          }
#line 116
          *oo = *ii;
#line 102
          ii ++;
#line 102
          oo ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 119
        if ((unsigned long )oo == (unsigned long )pathbuf) {
          {
#line 121
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Empty element in PATH\n");
#line 122
          free((void *)pathbuf);
          }
#line 123
          return (1);
        }
        {
#line 126
        tmp___11 = oo;
#line 126
        oo ++;
#line 126
        *tmp___11 = (char )'/';
#line 128
        strcpy((char */* __restrict  */)oo, (char const   */* __restrict  */)*(argv + 1));
#line 129
        tmp___14 = access((char const   *)pathbuf, 1);
        }
#line 129
        if (! tmp___14) {
          {
#line 131
          execve((char const   *)pathbuf, (char * const  *)new_argv, (char * const  *)new_envp);
#line 132
          tmp___12 = __errno_location();
#line 132
          tmp___13 = strerror(*tmp___12);
#line 132
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to run %s: %s\n",
                  pathbuf, tmp___13);
#line 133
          free((void *)pathbuf);
          }
#line 134
          return (1);
        }
#line 137
        ii ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 140
      free((void *)pathbuf);
      }
    }
  }
  {
#line 143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not find %s in PATH\n",
          *(argv + 1));
  }
#line 144
  return (1);
}
}
#line 286 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 773
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *mutex ) ;
#line 47 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.h"
struct thread *find_thread(pthread_t thread ) ;
#line 48
struct mutex *find_mutex(pthread_mutex_t *mutex ) ;
#line 10 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_mutex_lock)(pthread_mutex_t * ) ;
#line 11
int (*real_mutex_unlock)(pthread_mutex_t * ) ;
#line 14
int (*real_cond_wait)(pthread_cond_t * , pthread_mutex_t * ) ;
#line 17
void init(void) ;
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_lock.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *mutex ) ;
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_lock.c"
int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *mutex ) 
{ 
  struct thread *t ;
  pthread_t tmp ;
  struct thread *tmp___0 ;
  struct mutex *n ;
  struct mutex *tmp___1 ;
  struct thread *owner ;
  int ret ;
  int tmp___2 ;

  {
  {
#line 16
  init();
#line 18
  tmp = pthread_self();
#line 18
  tmp___0 = find_thread(tmp);
#line 18
  t = tmp___0;
#line 19
  tmp___1 = find_mutex(mutex);
#line 19
  n = tmp___1;
#line 21
  (*real_mutex_lock)(& n->lock);
#line 22
  owner = n->owner;
  }
#line 23
  if (owner) {
    {
#line 25
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] mutex_lock(%u) <waiting for thread %u> ...\n",
            t->num, n->num, owner->num);
#line 26
    (*real_cond_wait)(& n->cond, & n->lock);
    }
  }
  {
#line 28
  tmp___2 = (*real_mutex_lock)(mutex);
#line 28
  ret = tmp___2;
#line 30
  n->owner = t;
#line 31
  t->owns = n;
#line 33
  (*real_mutex_unlock)(& n->lock);
  }
#line 35
  if (owner) {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] ... mutex_lock(%u)\n",
            t->num, n->num);
    }
  } else {
    {
#line 38
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] mutex_lock(%u)\n",
            t->num, n->num);
    }
  }
#line 40
  return (ret);
}
}
#line 784 "/usr/include/pthread.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *mutex ) ;
#line 15 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_cond_signal)(pthread_cond_t * ) ;
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_unlock.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *mutex ) ;
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_unlock.c"
int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *mutex ) 
{ 
  struct thread *t ;
  pthread_t tmp ;
  struct thread *tmp___0 ;
  struct mutex *n ;
  struct mutex *tmp___1 ;
  int res ;
  int tmp___2 ;

  {
  {
#line 16
  init();
#line 18
  tmp = pthread_self();
#line 18
  tmp___0 = find_thread(tmp);
#line 18
  t = tmp___0;
#line 19
  tmp___1 = find_mutex(mutex);
#line 19
  n = tmp___1;
#line 21
  (*real_mutex_lock)(& n->lock);
#line 22
  n->owner = (struct thread *)0;
#line 23
  (*real_cond_signal)(& n->cond);
#line 24
  tmp___2 = (*real_mutex_unlock)(mutex);
#line 24
  res = tmp___2;
#line 25
  (*real_mutex_unlock)(& n->lock);
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] mutex_unlock(%u)\n",
          t->num, n->num);
  }
#line 29
  return (res);
}
}
#line 6 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_create)(pthread_t * , pthread_attr_t const   * , void *(*)(void * ) , void * )  ;
#line 8 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_mutex_init)(pthread_mutex_t * , pthread_mutexattr_t const   * )  ;
#line 9 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_mutex_destroy)(pthread_mutex_t * )  ;
#line 10 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_mutex_lock)(pthread_mutex_t * )  ;
#line 11 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_mutex_unlock)(pthread_mutex_t * )  ;
#line 13 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_cond_init)(pthread_cond_t * , pthread_condattr_t const   * )  ;
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_cond_wait)(pthread_cond_t * , pthread_mutex_t * )  ;
#line 15 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.h"
int (*real_cond_signal)(pthread_cond_t * )  ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 67 "/usr/include/link.h"
extern struct r_debug _r_debug ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 33 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.c"
static int initialized  =    0;
#line 31 "/home/wheatley/newnew/temp/mutextrace-0.1.4/real.c"
void init(void) 
{ 
  struct link_map *map ;
  Elf64_Dyn *dyn ;
  Elf64_Sym *symtab ;
  char const   *strtab ;
  unsigned int nsymbols ;
  char const   *name ;
  void *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 34
  if (initialized) {
#line 35
    return;
  }
#line 37
  initialized = 1;
#line 39
  map = _r_debug.r_map;
#line 41
  if (! map) {
    {
#line 42
    abort();
    }
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! map) {
#line 44
      goto while_break;
    }
    {
#line 46
    tmp___7 = strstr((char const   *)map->l_name, "libpthread.so");
    }
#line 46
    if (tmp___7) {
#line 49
      symtab = (Elf64_Sym *)0;
#line 50
      strtab = (char const   *)0;
#line 51
      nsymbols = 0U;
#line 53
      dyn = map->l_ld;
      {
#line 53
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 53
        if (! (dyn->d_tag != 0L)) {
#line 53
          goto while_break___0;
        }
#line 55
        if (dyn->d_tag == 6L) {
#line 56
          symtab = (Elf64_Sym *)dyn->d_un.d_ptr;
        } else
#line 57
        if (dyn->d_tag == 5L) {
#line 58
          strtab = (char const   *)dyn->d_un.d_ptr;
        } else
#line 59
        if (dyn->d_tag == 4L) {
#line 60
          nsymbols = *((unsigned int *)dyn->d_un.d_ptr + 1);
        }
#line 53
        dyn ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 63
      if (! symtab) {
        {
#line 64
        abort();
        }
      } else
#line 63
      if (! strtab) {
        {
#line 64
        abort();
        }
      } else
#line 63
      if (! nsymbols) {
        {
#line 64
        abort();
        }
      }
      {
#line 66
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 66
        if (! nsymbols) {
#line 66
          goto while_break___1;
        }
        {
#line 68
        name = strtab + symtab->st_name;
#line 69
        value = (void *)symtab->st_value + map->l_addr;
#line 70
        tmp___6 = strcmp(name, "pthread_create");
        }
#line 70
        if (tmp___6) {
          {
#line 72
          tmp___5 = strcmp(name, "pthread_mutex_init");
          }
#line 72
          if (tmp___5) {
            {
#line 74
            tmp___4 = strcmp(name, "pthread_mutex_destroy");
            }
#line 74
            if (tmp___4) {
              {
#line 76
              tmp___3 = strcmp(name, "pthread_mutex_lock");
              }
#line 76
              if (tmp___3) {
                {
#line 78
                tmp___2 = strcmp(name, "pthread_mutex_unlock");
                }
#line 78
                if (tmp___2) {
                  {
#line 80
                  tmp___1 = strcmp(name, "pthread_cond_init");
                  }
#line 80
                  if (tmp___1) {
                    {
#line 82
                    tmp___0 = strcmp(name, "pthread_cond_wait");
                    }
#line 82
                    if (tmp___0) {
                      {
#line 84
                      tmp = strcmp(name, "pthread_cond_signal");
                      }
#line 84
                      if (! tmp) {
#line 85
                        real_cond_signal = (int (*)(pthread_cond_t * ))value;
                      }
                    } else {
#line 83
                      real_cond_wait = (int (*)(pthread_cond_t * , pthread_mutex_t * ))value;
                    }
                  } else {
#line 81
                    real_cond_init = (int (*)(pthread_cond_t * , pthread_condattr_t const   * ))value;
                  }
                } else {
#line 79
                  real_mutex_unlock = (int (*)(pthread_mutex_t * ))value;
                }
              } else {
#line 77
                real_mutex_lock = (int (*)(pthread_mutex_t * ))value;
              }
            } else {
#line 75
              real_mutex_destroy = (int (*)(pthread_mutex_t * ))value;
            }
          } else {
#line 73
            real_mutex_init = (int (*)(pthread_mutex_t * , pthread_mutexattr_t const   * ))value;
          }
        } else {
#line 71
          real_create = (int (*)(pthread_t * , pthread_attr_t const   * , void *(*)(void * ) ,
                                 void * ))value;
        }
#line 66
        symtab ++;
#line 66
        nsymbols --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 44
    map = map->l_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 765 "/usr/include/pthread.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *mutex ) ;
#line 12 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_destroy.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *mutex ) ;
#line 12 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_destroy.c"
int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *mutex ) 
{ 
  struct thread *t ;
  pthread_t tmp ;
  struct thread *tmp___0 ;
  struct mutex *n ;
  struct mutex *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 14
  init();
#line 16
  tmp = pthread_self();
#line 16
  tmp___0 = find_thread(tmp);
#line 16
  t = tmp___0;
#line 17
  tmp___1 = find_mutex(mutex);
#line 17
  n = tmp___1;
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] mutex_destroy(%u)\n",
          t->num, n->num);
#line 21
  tmp___2 = (*real_mutex_destroy)(mutex);
  }
#line 21
  return (tmp___2);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 244 "/usr/include/pthread.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  thread ,
                                                                                      pthread_attr_t const   * __restrict  attr ,
                                                                                      void *(*start_routine)(void * ) ,
                                                                                      void * __restrict  arg ) ;
#line 691
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 703
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 744
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 754
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 20 "/home/wheatley/newnew/temp/mutextrace-0.1.4/thread_create.c"
static void cleanup(void *thread ) 
{ 
  struct thread *t ;

  {
  {
#line 22
  t = (struct thread *)thread;
#line 24
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] finished (normal exit)\n",
          t->num);
  }
#line 25
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/mutextrace-0.1.4/thread_create.c"
static void *startup(void *startupinfo ) 
{ 
  struct startupinfo *sui ;
  void *(*start_routine)(void * ) ;
  void *arg ;
  struct thread *t ;
  pthread_t tmp ;
  struct thread *tmp___0 ;
  void *res ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 29
  sui = (struct startupinfo *)startupinfo;
#line 31
  start_routine = sui->start_routine;
#line 32
  arg = sui->arg;
#line 34
  (*real_mutex_lock)(& sui->mutex);
#line 35
  (*real_cond_signal)(& sui->cond);
#line 36
  (*real_mutex_unlock)(& sui->mutex);
#line 38
  tmp = pthread_self();
#line 38
  tmp___0 = find_thread(tmp);
#line 38
  t = tmp___0;
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] started\n",
          t->num);
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    __cancel_routine = & cleanup;
#line 44
    __cancel_arg = (void *)t;
#line 44
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
#line 44
    __not_first_call = tmp___1;
#line 44
    tmp___2 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 44
    if (tmp___2) {
      {
#line 44
      (*__cancel_routine)(__cancel_arg);
#line 44
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 44
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 44
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 46
      res = (*start_routine)(arg);
      }
      {
#line 48
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 48
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 44
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 48
    __pthread_unregister_cancel(& __cancel_buf);
#line 48
    (*__cancel_routine)(__cancel_arg);
    }
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (res);
}
}
#line 53
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  thread ,
                                                                                      pthread_attr_t const   * __restrict  attr ,
                                                                                      void *(*start_routine)(void * ) ,
                                                                                      void * __restrict  arg ) ;
#line 53 "/home/wheatley/newnew/temp/mutextrace-0.1.4/thread_create.c"
int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  thread ,
                                                        pthread_attr_t const   * __restrict  attr ,
                                                        void *(*start_routine)(void * ) ,
                                                        void * __restrict  arg ) 
{ 
  struct startupinfo sui ;
  int res ;
  int tmp ;

  {
  {
#line 59
  init();
#line 61
  sui.start_routine = start_routine;
#line 61
  sui.arg = (void *)arg;
#line 61
  sui.cond.__data.__lock = 0;
#line 61
  sui.cond.__data.__futex = 0U;
#line 61
  sui.cond.__data.__total_seq = 0ULL;
#line 61
  sui.cond.__data.__wakeup_seq = 0ULL;
#line 61
  sui.cond.__data.__woken_seq = 0ULL;
#line 61
  sui.cond.__data.__mutex = (void *)0;
#line 61
  sui.cond.__data.__nwaiters = 0U;
#line 61
  sui.cond.__data.__broadcast_seq = 0U;
#line 61
  sui.mutex.__data.__lock = 0;
#line 61
  sui.mutex.__data.__count = 0U;
#line 61
  sui.mutex.__data.__owner = 0;
#line 61
  sui.mutex.__data.__nusers = 0U;
#line 61
  sui.mutex.__data.__kind = 0;
#line 61
  sui.mutex.__data.__spins = (short)0;
#line 61
  sui.mutex.__data.__elision = (short)0;
#line 61
  sui.mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 61
  sui.mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 62
  (*real_cond_init)(& sui.cond, (pthread_condattr_t const   *)0);
#line 63
  (*real_mutex_init)(& sui.mutex, (pthread_mutexattr_t const   *)0);
#line 65
  (*real_mutex_lock)(& sui.mutex);
#line 67
  tmp = (*real_create)((pthread_t *)thread, (pthread_attr_t const   *)attr, & startup,
                       (void *)(& sui));
#line 67
  res = tmp;
#line 69
  (*real_cond_wait)(& sui.cond, & sui.mutex);
#line 71
  (*real_mutex_unlock)(& sui.mutex);
  }
#line 73
  return (res);
}
}
#line 760 "/usr/include/pthread.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *mutex ,
                                                                                                  pthread_mutexattr_t const   *attr ) ;
#line 837
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_mutexattr_gettype)(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                                                                  int * __restrict  __kind ) ;
#line 15 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_init.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *mutex ,
                                                                                                  pthread_mutexattr_t const   *attr ) ;
#line 15 "/home/wheatley/newnew/temp/mutextrace-0.1.4/mutex_init.c"
int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *mutex ,
                                                                    pthread_mutexattr_t const   *attr ) 
{ 
  struct thread *t ;
  pthread_t tmp ;
  struct thread *tmp___0 ;
  struct mutex *n ;
  struct mutex *tmp___1 ;
  int kind ;
  char const   *kind_str ;
  int res ;
  int tmp___2 ;

  {
  {
#line 17
  init();
#line 19
  tmp = pthread_self();
#line 19
  tmp___0 = find_thread(tmp);
#line 19
  t = tmp___0;
#line 20
  tmp___1 = find_mutex(mutex);
#line 20
  n = tmp___1;
#line 22
  kind = 0;
  }
#line 23
  if (attr) {
    {
#line 24
    pthread_mutexattr_gettype((pthread_mutexattr_t const   */* __restrict  */)attr,
                              (int */* __restrict  */)(& kind));
    }
  }
  {
#line 29
  if (kind == 0) {
#line 29
    goto case_0;
  }
#line 32
  if (kind == 1) {
#line 32
    goto case_1;
  }
#line 35
  if (kind == 2) {
#line 35
    goto case_2;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  kind_str = "FAST";
#line 31
  goto switch_break;
  case_1: /* CIL Label */ 
#line 33
  kind_str = "RECURSIVE";
#line 34
  goto switch_break;
  case_2: /* CIL Label */ 
#line 36
  kind_str = "ERRORCHECK";
#line 37
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 39
  kind_str = "INVALID";
  switch_break: /* CIL Label */ ;
  }
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%u] mutex_init(%u, %s)\n",
          t->num, n->num, kind_str);
#line 43
  (*real_mutex_lock)(& n->lock);
#line 44
  n->state = (enum state )1;
#line 45
  n->kind = kind;
#line 47
  tmp___2 = (*real_mutex_init)(mutex, attr);
#line 47
  res = tmp___2;
#line 49
  (*real_mutex_unlock)(& n->lock);
  }
#line 51
  return (res);
}
}
#line 14 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
static unsigned int num  ;
#line 12 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
struct thread *create_thread(void) 
{ 
  struct thread *new_thread ;
  void *tmp ;

  {
  {
#line 16
  tmp = malloc(sizeof(struct thread ));
#line 16
  new_thread = (struct thread *)tmp;
#line 17
  new_thread->left = (struct thread *)0;
#line 18
  new_thread->right = (struct thread *)0;
#line 19
  num ++;
#line 19
  new_thread->num = num;
#line 20
  new_thread->owns = (struct mutex *)0;
  }
#line 22
  return (new_thread);
}
}
#line 27 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
static struct thread *root  ;
#line 25 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
struct thread *find_thread(pthread_t thread ) 
{ 
  struct thread *current ;

  {
#line 29
  if (! root) {
    {
#line 31
    root = create_thread();
#line 32
    root->thread = thread;
    }
#line 33
    return (root);
  }
#line 36
  current = root;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (current->thread == thread) {
#line 41
      return (current);
    }
#line 43
    if (current->thread > thread) {
#line 45
      if (! current->left) {
        {
#line 47
        current->left = create_thread();
#line 48
        (current->left)->thread = thread;
        }
      }
#line 50
      current = current->left;
    } else {
#line 54
      if (! current->right) {
        {
#line 56
        current->right = create_thread();
#line 57
        (current->right)->thread = thread;
        }
      }
#line 59
      current = current->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 68 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
static unsigned int num___0  ;
#line 64 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
struct mutex *create_mutex(void) 
{ 
  struct mutex *new_mutex ;
  void *tmp ;

  {
  {
#line 66
  init();
#line 70
  tmp = malloc(sizeof(struct mutex ));
#line 70
  new_mutex = (struct mutex *)tmp;
#line 71
  new_mutex->left = (struct mutex *)0;
#line 72
  new_mutex->right = (struct mutex *)0;
#line 73
  (*real_mutex_init)(& new_mutex->lock, (pthread_mutexattr_t const   *)0);
#line 74
  (*real_cond_init)(& new_mutex->cond, (pthread_condattr_t const   *)0);
#line 75
  num___0 ++;
#line 75
  new_mutex->num = num___0;
#line 76
  new_mutex->state = (enum state )0;
#line 77
  new_mutex->owner = (struct thread *)0;
#line 78
  new_mutex->owns_next = (struct mutex *)0;
  }
#line 80
  return (new_mutex);
}
}
#line 85 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
static struct mutex *root___0  ;
#line 83 "/home/wheatley/newnew/temp/mutextrace-0.1.4/store.c"
struct mutex *find_mutex(pthread_mutex_t *mutex ) 
{ 
  struct mutex *current ;

  {
#line 87
  if (! root___0) {
    {
#line 89
    root___0 = create_mutex();
#line 90
    root___0->mutex = mutex;
    }
#line 91
    return (root___0);
  }
#line 94
  current = root___0;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if ((unsigned long )current->mutex == (unsigned long )mutex) {
#line 99
      return (current);
    }
#line 101
    if ((unsigned long )current->mutex > (unsigned long )mutex) {
#line 103
      if (! current->left) {
        {
#line 105
        current->left = create_mutex();
#line 106
        (current->left)->mutex = mutex;
        }
      }
#line 108
      current = current->left;
    } else {
#line 112
      if (! current->right) {
        {
#line 114
        current->right = create_mutex();
#line 115
        (current->right)->mutex = mutex;
        }
      }
#line 117
      current = current->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
