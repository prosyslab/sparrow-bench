/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 61 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
struct mem_node {
   uint32_t *head_sig ;
   char const   *file ;
   int line ;
   char const   *function ;
   void *data ;
   uint32_t *tail_sig ;
   size_t size ;
   struct mem_node *next ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
typedef struct mem_node mem_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 69 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
struct _code {
   char *c_name ;
   int c_val ;
};
#line 69 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
typedef struct _code CODE;
#line 78 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
struct cache {
   int fd ;
   char *cache ;
   int hits ;
   char buf[256] ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
struct log_private {
   int level ;
   int flags ;
   char *str ;
   char *filename ;
   int fd ;
   struct cache cache ;
   char *ident ;
   int syslvl ;
};
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 146 "../include/debug/log.h"
int log_puts_stub(char const   *filename , int line , char const   *function , int level ,
                  char const   *str ) ;
#line 39 "../include/debug/hex.h"
void hexdump_stub(char const   *filename , int line , char const   *function , int level ,
                  void const   *ptr , size_t size ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/hex.c"
__inline static int printable(int c ) 
{ 
  int tmp ;

  {
#line 40
  if (c >= 32) {
#line 40
    if (c <= 126) {
#line 40
      tmp = 1;
    } else {
#line 40
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 40
  if (c >= 174) {
#line 40
    if (c <= 223) {
#line 40
      tmp = 1;
    } else {
#line 40
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 40
  if (c >= 242) {
#line 40
    if (c <= 243) {
#line 40
      tmp = 1;
    } else {
#line 40
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 40
  if (c >= 252) {
#line 40
    if (c <= 253) {
#line 40
      tmp = 1;
    } else {
#line 40
      tmp = 0;
    }
  } else {
#line 40
    tmp = 0;
  }
#line 40
  return (tmp);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/hex.c"
static void dump16(char *buf , uint8_t const   *s , uintptr_t offset , size_t len ) 
{ 
  size_t i ;
  size_t n ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
#line 48
  if (len) {
    {
#line 52
    tmp = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%08x - ",
                  offset);
#line 52
    n = (size_t )tmp;
#line 54
    i = (size_t )0;
    }
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
#line 54
      if (! (i < len)) {
#line 54
        goto while_break;
      }
#line 56
      if (i) {
#line 56
        if (! (i & 3UL)) {
#line 57
          tmp___0 = n;
#line 57
          n ++;
#line 57
          *(buf + tmp___0) = (char )' ';
        }
      }
      {
#line 59
      tmp___1 = sprintf((char */* __restrict  */)(buf + n), (char const   */* __restrict  */)"%02x ",
                        (int const   )*(s + i));
#line 59
      n += (size_t )tmp___1;
#line 54
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (i < 16UL)) {
#line 62
        goto while_break___0;
      }
#line 64
      if (i) {
#line 64
        if (! (i & 3UL)) {
#line 65
          tmp___2 = n;
#line 65
          n ++;
#line 65
          *(buf + tmp___2) = (char )' ';
        }
      }
#line 67
      tmp___3 = n;
#line 67
      n ++;
#line 67
      *(buf + tmp___3) = (char )' ';
#line 68
      tmp___4 = n;
#line 68
      n ++;
#line 68
      *(buf + tmp___4) = (char )' ';
#line 69
      tmp___5 = n;
#line 69
      n ++;
#line 69
      *(buf + tmp___5) = (char )' ';
#line 62
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    tmp___6 = n;
#line 72
    n ++;
#line 72
    *(buf + tmp___6) = (char )' ';
#line 74
    i = (size_t )0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (i < len)) {
#line 74
        goto while_break___1;
      }
      {
#line 75
      tmp___7 = n;
#line 75
      n ++;
#line 75
      tmp___9 = printable((int )*(s + i));
      }
#line 75
      if (tmp___9) {
#line 75
        *(buf + tmp___7) = (char )*(s + i);
      } else {
#line 75
        *(buf + tmp___7) = (char )'.';
      }
#line 74
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 77
    tmp___10 = n;
#line 77
    n ++;
#line 77
    *(buf + tmp___10) = (char )'\n';
#line 78
    *(buf + n) = (char )'\000';
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/hex.c"
void hexdump_stub(char const   *filename , int line , char const   *function , int level ,
                  void const   *ptr , size_t size ) 
{ 
  char buf[81] ;
  uint8_t const   *s ;
  size_t i ;

  {
#line 86
  s = (uint8_t const   *)ptr;
#line 89
  i = (size_t )0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < size >> 4)) {
#line 89
      goto while_break;
    }
    {
#line 91
    dump16(buf, s, (uintptr_t )s - (uintptr_t )ptr, (size_t )16);
#line 92
    log_puts_stub(filename, line, function, level, (char const   *)(buf));
#line 89
    i ++;
#line 89
    s += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  dump16(buf, s, (uintptr_t )s - (uintptr_t )ptr, size & 15UL);
#line 96
  log_puts_stub(filename, line, function, level, (char const   *)(buf));
  }
#line 97
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 41 "../include/debug/memory.h"
void mem_open(void (*fail___0)(char const   *fmt  , ...) ) ;
#line 49
void mem_check_stub(char const   *file , int line , char const   *function ) ;
#line 55
void *mem_alloc_stub(size_t size , char const   *file , int line , char const   *function )  __attribute__((__malloc__)) ;
#line 62
void *mem_realloc_stub(void *ptr , size_t size , char const   *file , int line , char const   *function )  __attribute__((__malloc__)) ;
#line 69
void mem_free_stub(void *ptr , char const   *file , int line , char const   *function ) ;
#line 74
void mem_close(void) ;
#line 118 "../include/debug/log.h"
int ( /* format attribute */  log_printf_stub)(char const   *filename , int line ,
                                               char const   *function , int level ,
                                               char const   *format  , ...) ;
#line 128
int log_vprintf_stub(char const   *filename , int line , char const   *function ,
                     int level , char const   *format , va_list ap ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static mem_t *mem_areas  =    (mem_t *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void (*fail_stub)(char const   *fmt  , ...)  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static char const   header[59]  = 
#line 76
  {      (char const   )'M',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'a',      (char const   )'k',      (char const   )' ', 
        (char const   )'D',      (char const   )'e',      (char const   )'t',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'S',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )'\n',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'\n',      (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xmalloc(char const   *file , int line , char const   *function , size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 84
  ptr = malloc(size);
  }
#line 84
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 85
    (*fail_stub)("malloc(size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                 size, file, line, function);
    }
  }
#line 90
  return (ptr);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xrealloc(char const   *file , int line , char const   *function , void *ptr ,
                      size_t size ) 
{ 
  void *ptr2 ;

  {
  {
#line 98
  ptr2 = realloc(ptr, size);
  }
#line 98
  if ((unsigned long )ptr2 == (unsigned long )((void *)0)) {
    {
#line 99
    (*fail_stub)("realloc(ptr: %p, size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                 ptr, size, file, line, function);
    }
  }
#line 104
  return (ptr2);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort1(char const   *msg , mem_t *area , char const   *file , int line ,
                       char const   *function ) 
{ 


  {
  {
#line 110
  (*fail_stub)("%s%s\nAllocated in file \"%s\" at line %d in function %s()\nDiscovered in file \"%s\" at line %d in function %s()\n",
               header, msg, area->file, area->line, area->function, file, line, function);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort2(char const   *msg , char const   *file , int line , char const   *function ) 
{ 


  {
  {
#line 120
  (*fail_stub)("%s%s\nDiscovered in file \"%s\" at line %d in function %s()\n", header,
               msg, file, line, function);
  }
#line 124
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
void mem_check_stub(char const   *file , int line , char const   *function ) 
{ 
  char str[100] ;
  mem_t *tmp ;

  {
#line 136
  tmp = mem_areas;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 136
      goto while_break;
    }
#line 138
    if (*(tmp->head_sig) != (uint32_t )((((77 << 24) | (76 << 16)) | (68 << 8)) | 83)) {
      {
#line 140
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"Overwrite error: Bad head signature in area %p\n",
              tmp->data);
#line 141
      mem_abort1((char const   *)(str), tmp, file, line, function);
      }
    }
#line 144
    if (*(tmp->tail_sig) != (uint32_t )((((77 << 24) | (76 << 16)) | (68 << 8)) | 83)) {
      {
#line 146
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"Overwrite error: Bad tail signature in area %p\n",
              tmp->data);
#line 147
      mem_abort1((char const   *)(str), tmp, file, line, function);
      }
    }
#line 136
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 155
void *mem_alloc_stub(size_t size , char const   *file , int line , char const   *function )  __attribute__((__malloc__)) ;
#line 155 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
void *mem_alloc_stub(size_t size , char const   *file , int line , char const   *function ) 
{ 
  char *area ;
  mem_t *tmp ;
  size_t old_size ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 159
  old_size = size;
#line 163
  mem_check_stub(file, line, function);
#line 165
  size = (size + 3UL) & 0xfffffffffffffffcUL;
#line 166
  tmp___0 = xmalloc(file, line, function, size + 2UL * sizeof(uint32_t ));
#line 166
  area = (char *)tmp___0;
#line 168
  tmp___1 = xmalloc(file, line, function, sizeof(mem_t ));
#line 168
  tmp = (mem_t *)tmp___1;
#line 169
  tmp->head_sig = (uint32_t *)area;
#line 170
  tmp->data = (void *)(area + sizeof(uint32_t ));
#line 171
  tmp->tail_sig = (uint32_t *)((area + size) + sizeof(uint32_t ));
#line 172
  tmp___2 = (uint32_t )((((77 << 24) | (76 << 16)) | (68 << 8)) | 83);
#line 172
  *(tmp->tail_sig) = tmp___2;
#line 172
  *(tmp->head_sig) = tmp___2;
#line 173
  tmp->file = file;
#line 174
  tmp->line = line;
#line 175
  tmp->function = function;
#line 176
  tmp->size = old_size;
#line 177
  tmp->next = mem_areas;
#line 178
  mem_areas = tmp;
  }
#line 180
  return (tmp->data);
}
}
#line 186
void *mem_realloc_stub(void *ptr , size_t size , char const   *file , int line , char const   *function )  __attribute__((__malloc__)) ;
#line 186 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
void *mem_realloc_stub(void *ptr , size_t size , char const   *file , int line , char const   *function ) 
{ 
  mem_t *tmp ;
  char str[100] ;
  char *area ;
  size_t old_size ;
  void *tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 195
  old_size = size;
#line 199
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 199
    tmp___0 = mem_alloc_stub(size, file, line, function);
    }
#line 199
    return (tmp___0);
  }
  {
#line 201
  mem_check_stub(file, line, function);
#line 203
  tmp = mem_areas;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 203
      if (! ((unsigned long )tmp->data != (unsigned long )ptr)) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 207
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"Attempted to realloc unallocated pointer: %p\n",
            ptr);
#line 208
    mem_abort2((char const   *)(str), file, line, function);
    }
  }
  {
#line 212
  size = (size + 3UL) & 0xfffffffffffffffcUL;
#line 213
  tmp___1 = xrealloc(file, line, function, (void *)tmp->head_sig, size + 2UL * sizeof(uint32_t ));
#line 213
  area = (char *)tmp___1;
#line 215
  tmp->head_sig = (uint32_t *)area;
#line 216
  tmp->data = (void *)(area + sizeof(uint32_t ));
#line 217
  tmp->tail_sig = (uint32_t *)((area + size) + sizeof(uint32_t ));
#line 218
  tmp___2 = (uint32_t )((((77 << 24) | (76 << 16)) | (68 << 8)) | 83);
#line 218
  *(tmp->tail_sig) = tmp___2;
#line 218
  *(tmp->head_sig) = tmp___2;
#line 219
  tmp->file = file;
#line 220
  tmp->line = line;
#line 221
  tmp->function = function;
#line 222
  tmp->size = old_size;
  }
#line 224
  return (tmp->data);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
void mem_free_stub(void *ptr , char const   *file , int line , char const   *function ) 
{ 
  char str[100] ;
  mem_t *prev ;
  mem_t *cur ;

  {
  {
#line 249
  mem_check_stub(file, line, function);
  }
#line 251
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 252
    mem_abort2("Attempted to free a NULL pointer\n", file, line, function);
    }
  }
#line 254
  cur = mem_areas;
#line 254
  prev = (mem_t *)((void *)0);
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 254
      if (! ((unsigned long )cur->data != (unsigned long )ptr)) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
#line 254
    prev = cur;
#line 254
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
    {
#line 258
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"Attempted to free an unallocated pointer: %p\n",
            ptr);
#line 259
    mem_abort2((char const   *)(str), file, line, function);
    }
  }
  {
#line 262
  free((void *)cur->head_sig);
  }
#line 267
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 267
    if ((unsigned long )cur->next != (unsigned long )((void *)0)) {
#line 268
      prev->next = cur->next;
    } else {
#line 267
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 271
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 272
    mem_areas = cur->next;
  } else {
#line 276
    prev->next = (struct mem_node *)((void *)0);
  }
  {
#line 278
  free((void *)cur);
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void fail_default_stub(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 284
  __builtin_va_start(ap, fmt);
  }
#line 285
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    {
#line 285
    log_vprintf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                     285, "fail_default_stub", 1, fmt, ap);
    }
  }
  {
#line 286
  __builtin_va_end(ap);
#line 287
  exit(1);
  }
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
void mem_open(void (*fail___0)(char const   *fmt  , ...) ) 
{ 


  {
#line 298
  if ((unsigned long )fail___0 != (unsigned long )((void *)0)) {
#line 298
    fail_stub = fail___0;
  } else {
#line 298
    fail_stub = & fail_default_stub;
  }
#line 299
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
void mem_close(void) 
{ 
  mem_t *tmp ;

  {
  {
#line 308
  mem_check_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                 308, "mem_close");
  }
#line 310
  if ((unsigned long )mem_areas != (unsigned long )((void *)0)) {
    {
#line 312
    log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                    312, "mem_close", 1, header);
    }
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      if (! ((unsigned long )mem_areas != (unsigned long )((void *)0))) {
#line 314
        goto while_break;
      }
      {
#line 316
      log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                      320, "mem_close", 1, "Unfreed pointer: %p\n   Allocated in file \"%s\" at line %d in function %s()\n",
                      mem_areas->data, mem_areas->file, mem_areas->line, mem_areas->function);
#line 321
      tmp = mem_areas->next;
#line 322
      free((void *)mem_areas);
#line 323
      mem_areas = tmp;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 326
    (*fail_stub)((char const   *)((void *)0));
    }
  }
#line 328
  return;
}
}
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 84 "../include/debug/log.h"
int log_open(char const   *logfile , int loglevel , int flags ) ;
#line 90
void log_close(void) ;
#line 109
int log_flush_stub(char const   *filename , int line , char const   *function ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c"
static void fail(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 51
  __builtin_va_start(ap, fmt);
  }
#line 53
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    {
#line 53
    log_vprintf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                     53, "fail", 1, fmt, ap);
    }
  }
  {
#line 61
  __builtin_va_end(ap);
#line 62
  exit(1);
  }
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c"
static void repeat(void) 
{ 


  {
  {
#line 68
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  68, "repeat", 5, "this is one of the repeated messages\n");
  }
#line 69
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c"
int main(void) 
{ 
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 74
  mem_open(& fail);
#line 78
  tmp = log_open((char const   *)((void *)0), 6, 30);
  }
#line 78
  if (tmp) {
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"log_open failed: %m\n");
#line 82
    exit(1);
    }
  }
  {
#line 84
  atexit(& mem_close);
#line 85
  atexit(& log_close);
#line 88
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  88, "main", 3, "1, 1\n1, 2%c1, 3\n", 10);
#line 89
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  89, "main", 3, "2, 1%c2, 2\n2, 3%c\n", '\n', 10);
#line 93
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  93, "main", 3, "hello ");
#line 94
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  94, "main", 3, "brave new ");
#line 95
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  95, "main", 3, "world\n");
#line 99
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  99, "main", 0, "this shouldn\'t be printed\n");
#line 100
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  100, "main", 1, "error");
#line 101
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  101, "main", 2, "warning");
#line 102
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  102, "main", 3, "normal");
#line 103
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  103, "main", 4, "verbose\n");
#line 104
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  104, "main", 5, "debug");
#line 105
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  105, "main", 6, "noisy\n");
#line 109
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  109, "main", 4, "i\'m going to repeat 3 identical messages and then quit.\n");
#line 110
  repeat();
#line 111
  repeat();
#line 112
  repeat();
#line 116
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  116, "main", 3, "> ");
#line 117
  log_flush_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                 117, "main");
#line 118
  tmp___0 = write(1, (void const   *)"this should be after the \'>\'", (size_t )28);
  }
#line 118
  if (tmp___0 != 28L) {
    {
#line 119
    perror("write");
#line 120
    exit(1);
    }
  }
  {
#line 122
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  122, "main", 3, " and this is the trailer\n");
#line 123
  log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                  123, "main", 3, "newline\n");
#line 125
  repeat();
#line 126
  repeat();
#line 127
  repeat();
#line 128
  log_flush_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_log.c",
                 128, "main");
#line 129
  repeat();
#line 132
  exit(0);
  }
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 74 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
CODE prioritynames[13]  = 
#line 74 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
  {      {(char *)"alert", 1}, 
        {(char *)"crit", 2}, 
        {(char *)"debug", 7}, 
        {(char *)"emerg", 0}, 
        {(char *)"err", 3}, 
        {(char *)"error", 3}, 
        {(char *)"info", 6}, 
        {(char *)"none", 16}, 
        {(char *)"notice", 5}, 
        {(char *)"panic", 0}, 
        {(char *)"warn", 4}, 
        {(char *)"warning", 4}, 
        {(char *)((void *)0), -1}};
#line 122 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
CODE facilitynames[23]  = 
#line 122
  {      {(char *)"auth", 4 << 3}, 
        {(char *)"authpriv", 10 << 3}, 
        {(char *)"cron", 9 << 3}, 
        {(char *)"daemon", 3 << 3}, 
        {(char *)"ftp", 11 << 3}, 
        {(char *)"kern", 0}, 
        {(char *)"lpr", 6 << 3}, 
        {(char *)"mail", 2 << 3}, 
        {(char *)"mark", 24 << 3}, 
        {(char *)"news", 7 << 3}, 
        {(char *)"security", 4 << 3}, 
        {(char *)"syslog", 5 << 3}, 
        {(char *)"user", 1 << 3}, 
        {(char *)"uucp", 8 << 3}, 
        {(char *)"local0", 16 << 3}, 
        {(char *)"local1", 17 << 3}, 
        {(char *)"local2", 18 << 3}, 
        {(char *)"local3", 19 << 3}, 
        {(char *)"local4", 20 << 3}, 
        {(char *)"local5", 21 << 3}, 
        {(char *)"local6", 22 << 3}, 
        {(char *)"local7", 23 << 3}, 
        {(char *)((void *)0), -1}};
#line 175
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 100 "../include/debug/log.h"
int log_reset_stub(char const   *filename , int line , char const   *function ) ;
#line 137
int log_putc_stub(char const   *filename , int line , char const   *function , int level ,
                  int c ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *vbprintf(char const   *fmt , va_list ap ) 
{ 
  int n ;
  int size ;
  char *buf ;
  char *ptr ;
  va_list ap_copy ;
  void *tmp ;
  void *tmp___0 ;
  int saved ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 110
  size = 100;
#line 114
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 114
    return ((char *)((void *)0));
  }
#line 116
  if ((int const   )*fmt == 0) {
    {
#line 118
    tmp = malloc(sizeof(char ));
#line 118
    buf = (char *)tmp;
    }
#line 118
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 119
      return ((char *)((void *)0));
    }
#line 120
    *buf = (char )'\000';
#line 121
    return (buf);
  }
  {
#line 124
  tmp___0 = malloc((unsigned long )size * sizeof(char ));
#line 124
  buf = (char *)tmp___0;
  }
#line 124
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 125
    return ((char *)((void *)0));
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    __builtin_va_copy(ap_copy, ap);
#line 131
    n = vsnprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)fmt,
                  ap_copy);
#line 132
    __builtin_va_end(ap_copy);
    }
#line 135
    if (n > -1) {
#line 135
      if (n < size) {
#line 135
        goto while_break;
      }
    }
#line 138
    if (n > -1) {
#line 139
      size = n + 1;
    } else {
#line 141
      size *= 2;
    }
    {
#line 143
    tmp___3 = realloc((void *)buf, (unsigned long )size * sizeof(char ));
#line 143
    ptr = (char *)tmp___3;
    }
#line 143
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___1 = __errno_location();
#line 145
      saved = *tmp___1;
#line 146
      free((void *)buf);
#line 147
      tmp___2 = __errno_location();
#line 147
      *tmp___2 = saved;
      }
#line 148
      return ((char *)((void *)0));
    } else {
#line 150
      buf = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (buf);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *bprintf(char const   *fmt  , ...) 
{ 
  char *buf ;
  va_list ap ;

  {
  {
#line 165
  __builtin_va_start(ap, fmt);
#line 166
  buf = vbprintf(fmt, ap);
#line 167
  __builtin_va_end(ap);
  }
#line 168
  return (buf);
}
}
#line 173
static char *prefix(struct log_private *priv , char const   *filename , int line ,
                    char const   *function , int level ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *colors[7]  = {      (char const   *)((void *)0),      "1;31",      "1;37",      (char const   *)((void *)0), 
        "1;32",      "40;33",      "1;33"};
#line 174 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *levels[7]  = {      "  QUIET",      "  ERROR",      "WARNING",      " NORMAL", 
        "VERBOSE",      "  DEBUG",      "  NOISY"};
#line 184 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int const   syslvl[7]  = {      (int const   )0,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )7};
#line 171 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *prefix(struct log_private *priv , char const   *filename , int line ,
                    char const   *function , int level ) 
{ 
  int have_prefix ;
  int tmp ;
  int i ;
  int n ;
  char *buf[5] ;
  size_t len ;
  int tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  time_t tc ;
  time_t tmp___5 ;
  struct tm *tv ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int saved ;
  int *tmp___12 ;
  int *tmp___13 ;
  size_t tmp___14 ;
  int saved___0 ;
  int *tmp___15 ;
  int *tmp___16 ;
  void *tmp___17 ;

  {
#line 194
  if (! (priv->flags & 8)) {
#line 194
    if (priv->level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 194
  if (priv->flags & 8) {
#line 194
    if (level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      tmp = 0;
    }
  } else {
#line 194
    tmp = 0;
  }
#line 194
  have_prefix = tmp;
#line 195
  n = 0;
#line 197
  len = (size_t )0;
#line 199
  if (have_prefix) {
#line 201
    tmp___0 = n;
#line 201
    n ++;
#line 201
    if (priv->flags & 2) {
#line 201
      if (priv->flags & 64) {
#line 201
        goto _L___0;
      } else {
        {
#line 201
        tmp___4 = isatty(priv->fd);
        }
#line 201
        if (tmp___4) {
          _L___0: /* CIL Label */ 
#line 201
          if ((unsigned long )colors[level] != (unsigned long )((void *)0)) {
            {
#line 201
            tmp___2 = bprintf("\033[%sm%s: \033[0m", colors[level], levels[level]);
#line 201
            buf[tmp___0] = tmp___2;
            }
          } else {
            {
#line 201
            tmp___3 = bprintf("%s: ", levels[level]);
#line 201
            buf[tmp___0] = tmp___3;
            }
          }
        } else {
          {
#line 201
          tmp___3 = bprintf("%s: ", levels[level]);
#line 201
          buf[tmp___0] = tmp___3;
          }
        }
      }
    } else {
      {
#line 201
      tmp___3 = bprintf("%s: ", levels[level]);
#line 201
      buf[tmp___0] = tmp___3;
      }
    }
  }
#line 208
  if (priv->flags & 1) {
    {
#line 210
    tmp___5 = time((time_t *)((void *)0));
#line 210
    tc = tmp___5;
#line 211
    tmp___6 = localtime((time_t const   *)(& tc));
#line 211
    tv = tmp___6;
#line 213
    tmp___7 = n;
#line 213
    n ++;
#line 213
    buf[tmp___7] = bprintf("%.4d-%.2d-%.2d %.2d:%.2d:%.2d ", tv->tm_year + 1900, tv->tm_mon + 1,
                           tv->tm_mday, tv->tm_hour, tv->tm_min, tv->tm_sec);
    }
  }
#line 218
  if (have_prefix) {
    {
#line 220
    tmp___8 = n;
#line 220
    n ++;
#line 220
    buf[tmp___8] = bprintf("%s:%d:", filename, line);
#line 221
    tmp___9 = n;
#line 221
    n ++;
    }
#line 221
    if (priv->flags & 4) {
      {
#line 221
      tmp___10 = bprintf("%s(): ", function);
#line 221
      buf[tmp___9] = tmp___10;
      }
    } else {
      {
#line 221
      tmp___11 = bprintf(" ");
#line 221
      buf[tmp___9] = tmp___11;
      }
    }
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < n)) {
#line 224
      goto while_break;
    }
#line 226
    if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
      {
#line 228
      tmp___12 = __errno_location();
#line 228
      saved = *tmp___12;
#line 230
      i = 0;
      }
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (! (i < n)) {
#line 230
          goto while_break___0;
        }
#line 231
        if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
          {
#line 232
          free((void *)buf[i]);
          }
        }
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 234
      tmp___13 = __errno_location();
#line 234
      *tmp___13 = saved;
      }
#line 236
      return ((char *)((void *)0));
    }
    {
#line 239
    tmp___14 = strlen((char const   *)buf[i]);
#line 239
    len += tmp___14;
#line 224
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp___17 = malloc((len + 1UL) * sizeof(char ));
#line 242
  buf[4] = (char *)tmp___17;
  }
#line 242
  if ((unsigned long )buf[4] == (unsigned long )((void *)0)) {
    {
#line 244
    tmp___15 = __errno_location();
#line 244
    saved___0 = *tmp___15;
#line 245
    i = 0;
    }
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___1;
      }
#line 246
      if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
        {
#line 247
        free((void *)buf[i]);
        }
      }
#line 245
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 248
    tmp___16 = __errno_location();
#line 248
    *tmp___16 = saved___0;
    }
#line 249
    return ((char *)((void *)0));
  }
#line 252
  *(buf[4]) = (char )'\000';
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 254
    if (! (i < n)) {
#line 254
      goto while_break___2;
    }
    {
#line 256
    strcat((char */* __restrict  */)buf[4], (char const   */* __restrict  */)buf[i]);
#line 257
    free((void *)buf[i]);
#line 254
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 260
  priv->syslvl = (int )syslvl[level];
#line 262
  return (buf[4]);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_append(struct log_private *priv , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  char *ptr ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 271
  tmp = strlen(str);
#line 271
  len = tmp + 1UL;
  }
#line 274
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 276
    tmp___0 = strlen((char const   *)priv->str);
#line 276
    tmp___1 = realloc((void *)priv->str, (len + tmp___0) * sizeof(char ));
#line 276
    ptr = (char *)tmp___1;
    }
#line 276
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 277
      return (-1);
    }
    {
#line 279
    priv->str = ptr;
#line 280
    strcat((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  } else {
    {
#line 284
    tmp___3 = malloc(len * sizeof(char ));
#line 284
    tmp___2 = (char *)tmp___3;
#line 284
    priv->str = tmp___2;
    }
#line 284
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 285
      return (-1);
    }
    {
#line 286
    strcpy((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_begin(struct log_private *priv , char const   *filename , int line ,
                      char const   *function , int level , char const   *str ) 
{ 
  char *tmp ;
  int saved ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 296
  tmp = prefix(priv, filename, line, function, level);
  }
#line 296
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 297
    return (-1);
  }
  {
#line 299
  tmp___2 = line_append(priv, (char const   *)tmp);
  }
#line 299
  if (tmp___2 < 0) {
    {
#line 301
    tmp___0 = __errno_location();
#line 301
    saved = *tmp___0;
#line 302
    free((void *)tmp);
#line 303
    tmp___1 = __errno_location();
#line 303
    *tmp___1 = saved;
    }
#line 304
    return (-1);
  }
  {
#line 307
  free((void *)tmp);
#line 309
  tmp___3 = line_append(priv, str);
  }
#line 309
  return (tmp___3);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int savetodisk(int fd , char const   *str ) 
{ 
  ssize_t n ;
  ssize_t len ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 314
  tmp = strlen(str);
#line 314
  len = (ssize_t )tmp;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (len) {
      {
#line 316
      n = write(fd, (void const   *)str, (size_t )len);
      }
#line 316
      if (! (n != len)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 318
    if (n < 0L) {
#line 318
      return (-1);
    }
#line 320
    if (! n) {
      {
#line 322
      tmp___0 = __errno_location();
#line 322
      *tmp___0 = 5;
      }
#line 323
      return (-1);
    }
#line 326
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int flush_cache(struct log_private *priv , char const   *filename , int line ,
                       char const   *function ) 
{ 
  int saved ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *buf ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 336
  if ((unsigned long )priv->cache.cache == (unsigned long )((void *)0)) {
#line 337
    return (0);
  } else
#line 336
  if (! (priv->flags & 16)) {
#line 337
    return (0);
  }
  {
#line 339
  tmp___1 = savetodisk(priv->cache.fd, (char const   *)priv->cache.cache);
  }
#line 339
  if (tmp___1 < 0) {
    error: 
    {
#line 342
    tmp = __errno_location();
#line 342
    saved = *tmp;
#line 343
    free((void *)priv->cache.cache);
#line 344
    priv->cache.cache = (char *)((void *)0);
#line 345
    tmp___0 = __errno_location();
#line 345
    *tmp___0 = saved;
    }
#line 346
    return (-1);
  }
#line 349
  if (priv->cache.hits) {
    {
#line 351
    tmp___2 = prefix(priv, filename, line, function, 2);
#line 351
    buf = tmp___2;
    }
#line 353
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 354
      goto error;
    }
    {
#line 356
    tmp___5 = savetodisk(priv->cache.fd, (char const   *)buf);
    }
#line 356
    if (tmp___5 < 0) {
      {
#line 358
      tmp___3 = __errno_location();
#line 358
      saved = *tmp___3;
#line 359
      free((void *)buf);
#line 360
      tmp___4 = __errno_location();
#line 360
      *tmp___4 = saved;
      }
#line 361
      goto error;
    }
    {
#line 364
    free((void *)buf);
#line 366
    sprintf((char */* __restrict  */)(priv->cache.buf), (char const   */* __restrict  */)"Message repeated %d times\n",
            priv->cache.hits + 1);
#line 368
    tmp___6 = savetodisk(priv->cache.fd, (char const   *)(priv->cache.buf));
    }
#line 368
    if (tmp___6 < 0) {
#line 369
      goto error;
    }
  }
  {
#line 372
  free((void *)priv->cache.cache);
#line 373
  priv->cache.cache = (char *)((void *)0);
  }
#line 375
  return (0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static void save_to_cache(struct log_private *priv ) 
{ 


  {
#line 380
  priv->cache.fd = priv->fd;
#line 381
  priv->cache.hits = 0;
#line 382
  priv->cache.cache = priv->str;
#line 383
  priv->str = (char *)((void *)0);
#line 384
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_end(struct log_private *priv , char const   *filename , int line ,
                    char const   *function ) 
{ 
  int saved ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 390
  if (priv->flags & 64) {
    {
#line 392
    syslog(priv->syslvl, "%s", priv->str);
#line 393
    free((void *)priv->str);
#line 394
    priv->str = (char *)((void *)0);
    }
#line 395
    return (0);
  }
  {
#line 398
  tmp = line_append(priv, "\n");
  }
#line 398
  if (tmp < 0) {
#line 399
    return (-1);
  }
#line 401
  if (priv->flags & 16) {
#line 403
    if ((unsigned long )priv->cache.cache != (unsigned long )((void *)0)) {
      {
#line 405
      tmp___1 = strcmp((char const   *)priv->str, (char const   *)priv->cache.cache);
      }
#line 405
      if (tmp___1) {
        {
#line 407
        tmp___0 = flush_cache(priv, filename, line, function);
        }
#line 407
        if (tmp___0 < 0) {
#line 408
          goto error;
        }
        {
#line 410
        save_to_cache(priv);
        }
      } else {
        {
#line 414
        free((void *)priv->str);
#line 415
        priv->str = (char *)((void *)0);
#line 416
        (priv->cache.hits) ++;
        }
      }
    } else {
      {
#line 419
      save_to_cache(priv);
      }
    }
  } else {
    {
#line 423
    tmp___4 = savetodisk(priv->fd, (char const   *)priv->str);
    }
#line 423
    if (tmp___4 < 0) {
      error: 
      {
#line 426
      tmp___2 = __errno_location();
#line 426
      saved = *tmp___2;
#line 427
      free((void *)priv->str);
#line 428
      priv->str = (char *)((void *)0);
#line 429
      tmp___3 = __errno_location();
#line 429
      *tmp___3 = saved;
      }
#line 430
      return (-1);
    }
    {
#line 433
    free((void *)priv->str);
#line 434
    priv->str = (char *)((void *)0);
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int newline  =    1;
#line 442 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
__inline static void fd_update(struct log_private *priv , int level ) 
{ 


  {
#line 444
  if (! (priv->flags & 65)) {
#line 445
    if (level <= 2) {
#line 445
      priv->fd = 2;
    } else {
#line 445
      priv->fd = 1;
    }
  }
#line 446
  return;
}
}
#line 451
static int write_string(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level , char *str ) ;
#line 451 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int prevlevel  =    0;
#line 448 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int write_string(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level , char *str ) 
{ 
  char *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 453
  if (level != prevlevel) {
    {
#line 455
    fd_update(priv, prevlevel);
    }
#line 456
    if (! newline) {
      {
#line 456
      tmp___0 = line_end(priv, filename, line, function);
      }
#line 456
      if (tmp___0 < 0) {
#line 456
        goto error;
      }
    }
#line 457
    newline = 1;
#line 458
    prevlevel = level;
  }
  {
#line 461
  fd_update(priv, level);
#line 463
  s = str;
  }
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 463
    tmp = strchr((char const   *)s, '\n');
    }
#line 463
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 463
      goto while_break;
    }
#line 465
    *tmp = (char )'\000';
#line 467
    if ((unsigned long )s == (unsigned long )str) {
#line 467
      if (! newline) {
        {
#line 469
        newline = 1;
#line 470
        tmp___1 = line_append(priv, (char const   *)s);
        }
#line 470
        if (tmp___1 < 0) {
#line 470
          goto error;
        }
      } else {
#line 467
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 472
      tmp___2 = line_begin(priv, filename, line, function, level, (char const   *)s);
      }
#line 472
      if (tmp___2 < 0) {
#line 473
        goto error;
      }
    }
    {
#line 475
    tmp___3 = line_end(priv, filename, line, function);
    }
#line 475
    if (tmp___3 < 0) {
#line 475
      goto error;
    }
#line 463
    s = tmp + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (*s) {
#line 480
    if (newline) {
      {
#line 482
      tmp___4 = line_begin(priv, filename, line, function, level, (char const   *)s);
      }
#line 482
      if (tmp___4 < 0) {
#line 483
        goto error;
      }
    } else {
      {
#line 485
      tmp___5 = line_append(priv, (char const   *)s);
      }
#line 485
      if (tmp___5 < 0) {
#line 486
        goto error;
      }
    }
#line 488
    newline = 0;
  }
#line 491
  return (0);
  error: 
#line 494
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 496
    free((void *)priv->str);
#line 497
    priv->str = (char *)((void *)0);
    }
  }
#line 499
  return (-1);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int print_one_line(struct log_private *priv , char const   *filename , int line ,
                          char const   *function , int level , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (level != 0) {
#line 504
      if (priv->level != 0) {
#line 504
        if (! (level <= priv->level)) {
#line 504
          goto while_break;
        }
      } else {
#line 504
        goto while_break;
      }
    } else {
#line 504
      goto while_break;
    }
    {
#line 506
    fd_update(priv, level);
    }
#line 508
    if (! newline) {
      {
#line 508
      tmp = line_end(priv, filename, line, function);
      }
#line 508
      if (tmp < 0) {
#line 509
        goto while_break;
      }
    }
    {
#line 511
    newline = 1;
#line 513
    tmp___0 = line_begin(priv, filename, line, function, level, str);
    }
#line 513
    if (tmp___0 < 0) {
#line 514
      goto while_break;
    } else {
      {
#line 513
      tmp___1 = line_end(priv, filename, line, function);
      }
#line 513
      if (tmp___1 < 0) {
#line 514
        goto while_break;
      }
    }
    {
#line 516
    tmp___2 = flush_cache(priv, filename, line, function);
    }
#line 516
    return (tmp___2);
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 521
    free((void *)priv->str);
#line 522
    priv->str = (char *)((void *)0);
    }
  }
#line 525
  return (-1);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static struct log_private log_private  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int initialized  =    0;
#line 535 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int log_open_syslog(char const   *str ) 
{ 
  char *facility ;
  size_t i ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 540
  tmp = strlen(str);
#line 540
  tmp___0 = malloc(tmp + 1UL);
#line 540
  log_private.ident = (char *)tmp___0;
  }
#line 540
  if ((unsigned long )log_private.ident == (unsigned long )((void *)0)) {
#line 541
    return (-1);
  }
  {
#line 543
  strcpy((char */* __restrict  */)log_private.ident, (char const   */* __restrict  */)str);
#line 545
  facility = strchr((char const   *)log_private.ident, '.');
  }
#line 545
  if ((unsigned long )facility == (unsigned long )((void *)0)) {
#line 546
    return (-1);
  }
#line 548
  tmp___1 = facility;
#line 548
  facility ++;
#line 548
  *tmp___1 = (char )'\000';
#line 550
  i = (size_t )0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! ((unsigned long )facilitynames[i].c_name != (unsigned long )((void *)0))) {
#line 550
      goto while_break;
    }
    {
#line 551
    tmp___2 = strcmp((char const   *)facility, (char const   *)facilitynames[i].c_name);
    }
#line 551
    if (! tmp___2) {
      {
#line 553
      openlog((char const   *)log_private.ident, 1, facilitynames[i].c_val);
      }
#line 554
      return (0);
    }
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (-1);
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int log_open(char const   *logfile , int loglevel , int flags ) 
{ 
  int *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int saved ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 562
  if (initialized) {
    {
#line 564
    tmp = __errno_location();
#line 564
    *tmp = 16;
    }
#line 565
    return (-1);
  }
#line 568
  if ((unsigned long )logfile != (unsigned long )((void *)0)) {
    {
#line 570
    flags &= -68;
#line 571
    tmp___2 = log_open_syslog(logfile);
    }
#line 571
    if (tmp___2) {
#line 571
      tmp___1 = 1;
    } else {
#line 571
      tmp___1 = 64;
    }
#line 571
    flags |= tmp___1;
#line 573
    if (flags & 64) {
#line 574
      flags &= -17;
    }
  } else {
#line 576
    flags &= -66;
  }
#line 578
  if (flags & 1) {
    {
#line 582
    tmp___3 = strlen(logfile);
#line 582
    tmp___4 = malloc((tmp___3 + 1UL) * sizeof(char ));
#line 582
    log_private.filename = (char *)tmp___4;
    }
#line 582
    if ((unsigned long )log_private.filename == (unsigned long )((void *)0)) {
#line 583
      return (-1);
    }
    {
#line 585
    log_private.fd = open(logfile, 1089, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    }
#line 585
    if (log_private.fd < 0) {
      {
#line 587
      tmp___5 = __errno_location();
#line 587
      saved = *tmp___5;
#line 588
      free((void *)log_private.filename);
#line 589
      tmp___6 = __errno_location();
#line 589
      *tmp___6 = saved;
      }
#line 590
      return (-1);
    }
    {
#line 593
    strcpy((char */* __restrict  */)log_private.filename, (char const   */* __restrict  */)logfile);
    }
  }
#line 596
  log_private.level = loglevel;
#line 597
  log_private.flags = flags;
#line 598
  log_private.str = (char *)((void *)0);
#line 600
  if (flags & 16) {
#line 601
    log_private.cache.cache = (char *)((void *)0);
  }
  {
#line 603
  print_one_line(& log_private, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c",
                 603, "log_open", 4, "Starting to log output.");
#line 605
  initialized = 1;
  }
#line 607
  return (0);
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
void log_close(void) 
{ 


  {
#line 612
  if (initialized) {
    {
#line 614
    initialized = 0;
#line 616
    print_one_line(& log_private, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c",
                   616, "log_close", 4, "Stopped logging output.");
    }
#line 618
    if (log_private.flags & 1) {
      {
#line 620
      close(log_private.fd);
#line 621
      free((void *)log_private.filename);
      }
    }
#line 624
    if (log_private.flags & 64) {
      {
#line 626
      closelog();
#line 627
      free((void *)log_private.ident);
      }
    }
  }
#line 630
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int log_reset_stub(char const   *filename , int line , char const   *function ) 
{ 
  int *tmp ;
  int saved ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 634
  if (! initialized) {
    {
#line 636
    tmp = __errno_location();
#line 636
    *tmp = 22;
    }
#line 637
    return (-1);
  } else
#line 634
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 636
    tmp = __errno_location();
#line 636
    *tmp = 22;
    }
#line 637
    return (-1);
  } else
#line 634
  if ((unsigned long )function == (unsigned long )((void *)0)) {
    {
#line 636
    tmp = __errno_location();
#line 636
    *tmp = 22;
    }
#line 637
    return (-1);
  }
#line 640
  if (log_private.flags & 1) {
    {
#line 642
    print_one_line(& log_private, filename, line, function, 4, "Attempting to reload log file.");
#line 643
    print_one_line(& log_private, filename, line, function, 4, "Stopped logging output.");
#line 645
    close(log_private.fd);
#line 647
    log_private.fd = open((char const   *)log_private.filename, 1089, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    }
#line 647
    if (log_private.fd < 0) {
      {
#line 649
      tmp___0 = __errno_location();
#line 649
      saved = *tmp___0;
#line 650
      free((void *)log_private.filename);
#line 651
      tmp___1 = __errno_location();
#line 651
      *tmp___1 = saved;
      }
#line 652
      return (-1);
    }
    {
#line 655
    print_one_line(& log_private, filename, line, function, 4, "Starting to log output again.");
#line 656
    print_one_line(& log_private, filename, line, function, 4, "Reload succeeded.");
    }
  }
#line 659
  return (0);
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int log_vprintf_stub(char const   *filename , int line , char const   *function ,
                     int level , char const   *format , va_list ap ) 
{ 
  int result ;
  char *buf ;
  int *tmp ;

  {
#line 667
  if (! initialized) {
    {
#line 669
    tmp = __errno_location();
#line 669
    *tmp = 22;
    }
#line 670
    return (-1);
  } else
#line 667
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 669
    tmp = __errno_location();
#line 669
    *tmp = 22;
    }
#line 670
    return (-1);
  } else
#line 667
  if ((unsigned long )function == (unsigned long )((void *)0)) {
    {
#line 669
    tmp = __errno_location();
#line 669
    *tmp = 22;
    }
#line 670
    return (-1);
  }
#line 673
  if (level == 0) {
#line 674
    return (0);
  } else
#line 673
  if (log_private.level == 0) {
#line 674
    return (0);
  } else
#line 673
  if (level > log_private.level) {
#line 674
    return (0);
  }
  {
#line 676
  buf = vbprintf(format, ap);
  }
#line 676
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 677
    return (-1);
  }
  {
#line 679
  result = write_string(& log_private, filename, line, function, level, buf);
#line 681
  free((void *)buf);
  }
#line 683
  return (result);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int ( /* format attribute */  log_printf_stub)(char const   *filename , int line ,
                                               char const   *function , int level ,
                                               char const   *format  , ...) 
{ 
  va_list ap ;
  int result ;

  {
  {
#line 691
  __builtin_va_start(ap, format);
#line 692
  result = log_vprintf_stub(filename, line, function, level, format, ap);
#line 693
  __builtin_va_end(ap);
  }
#line 695
  return (result);
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int log_putc_stub(char const   *filename , int line , char const   *function , int level ,
                  int c ) 
{ 
  char s[2] ;
  int *tmp ;
  int tmp___0 ;

  {
#line 700
  s[0] = (char )c;
#line 700
  s[1] = (char )'\000';
#line 702
  if (! initialized) {
    {
#line 704
    tmp = __errno_location();
#line 704
    *tmp = 22;
    }
#line 705
    return (-1);
  } else
#line 702
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 704
    tmp = __errno_location();
#line 704
    *tmp = 22;
    }
#line 705
    return (-1);
  } else
#line 702
  if ((unsigned long )function == (unsigned long )((void *)0)) {
    {
#line 704
    tmp = __errno_location();
#line 704
    *tmp = 22;
    }
#line 705
    return (-1);
  }
#line 708
  if (level == 0) {
#line 709
    return (0);
  } else
#line 708
  if (log_private.level == 0) {
#line 709
    return (0);
  } else
#line 708
  if (level > log_private.level) {
#line 709
    return (0);
  }
  {
#line 711
  tmp___0 = write_string(& log_private, filename, line, function, level, s);
  }
#line 711
  return (tmp___0);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int log_puts_stub(char const   *filename , int line , char const   *function , int level ,
                  char const   *str ) 
{ 
  char *s ;
  int result ;
  int *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 719
  if (! initialized) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 722
    return (-1);
  } else
#line 719
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 722
    return (-1);
  } else
#line 719
  if ((unsigned long )function == (unsigned long )((void *)0)) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 722
    return (-1);
  }
#line 725
  if (level == 0) {
#line 726
    return (0);
  } else
#line 725
  if (log_private.level == 0) {
#line 726
    return (0);
  } else
#line 725
  if (level > log_private.level) {
#line 726
    return (0);
  }
  {
#line 728
  tmp___0 = strlen(str);
#line 728
  tmp___1 = malloc(sizeof(char ) * (tmp___0 + 1UL));
#line 728
  s = (char *)tmp___1;
  }
#line 728
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 729
    return (-1);
  }
  {
#line 731
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)str);
#line 732
  result = write_string(& log_private, filename, line, function, level, s);
#line 733
  free((void *)s);
  }
#line 735
  return (result);
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
int log_flush_stub(char const   *filename , int line , char const   *function ) 
{ 
  int saved ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 742
  if (! initialized) {
    {
#line 744
    tmp = __errno_location();
#line 744
    *tmp = 22;
    }
#line 745
    return (-1);
  } else
#line 742
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 744
    tmp = __errno_location();
#line 744
    *tmp = 22;
    }
#line 745
    return (-1);
  } else
#line 742
  if ((unsigned long )function == (unsigned long )((void *)0)) {
    {
#line 744
    tmp = __errno_location();
#line 744
    *tmp = 22;
    }
#line 745
    return (-1);
  }
#line 748
  if (log_private.flags & 64) {
#line 749
    return (0);
  }
  {
#line 751
  tmp___0 = flush_cache(& log_private, filename, line, function);
  }
#line 751
  if (tmp___0) {
#line 752
    return (-1);
  }
#line 754
  if ((unsigned long )log_private.str != (unsigned long )((void *)0)) {
    {
#line 756
    tmp___3 = savetodisk(log_private.fd, (char const   *)log_private.str);
    }
#line 756
    if (tmp___3) {
      {
#line 758
      tmp___1 = __errno_location();
#line 758
      saved = *tmp___1;
#line 759
      free((void *)log_private.str);
#line 760
      log_private.str = (char *)((void *)0);
#line 761
      tmp___2 = __errno_location();
#line 761
      *tmp___2 = saved;
      }
#line 762
      return (-1);
    }
    {
#line 765
    free((void *)log_private.str);
#line 766
    log_private.str = (char *)((void *)0);
    }
#line 768
    if (log_private.flags & 16) {
      {
#line 769
      save_to_cache(& log_private);
      }
    }
  }
#line 772
  return (0);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/hex.c"
static void dump16___0(char *buf , uint8_t const   *s , uintptr_t offset , size_t len ) 
{ 
  size_t i ;
  size_t n ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
#line 48
  if (len) {
    {
#line 52
    tmp = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%08x - ",
                  offset);
#line 52
    n = (size_t )tmp;
#line 54
    i = (size_t )0;
    }
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
#line 54
      if (! (i < len)) {
#line 54
        goto while_break;
      }
#line 56
      if (i) {
#line 56
        if (! (i & 3UL)) {
#line 57
          tmp___0 = n;
#line 57
          n ++;
#line 57
          *(buf + tmp___0) = (char )' ';
        }
      }
      {
#line 59
      tmp___1 = sprintf((char */* __restrict  */)(buf + n), (char const   */* __restrict  */)"%02x ",
                        (int const   )*(s + i));
#line 59
      n += (size_t )tmp___1;
#line 54
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (i < 16UL)) {
#line 62
        goto while_break___0;
      }
#line 64
      if (i) {
#line 64
        if (! (i & 3UL)) {
#line 65
          tmp___2 = n;
#line 65
          n ++;
#line 65
          *(buf + tmp___2) = (char )' ';
        }
      }
#line 67
      tmp___3 = n;
#line 67
      n ++;
#line 67
      *(buf + tmp___3) = (char )' ';
#line 68
      tmp___4 = n;
#line 68
      n ++;
#line 68
      *(buf + tmp___4) = (char )' ';
#line 69
      tmp___5 = n;
#line 69
      n ++;
#line 69
      *(buf + tmp___5) = (char )' ';
#line 62
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    tmp___6 = n;
#line 72
    n ++;
#line 72
    *(buf + tmp___6) = (char )' ';
#line 74
    i = (size_t )0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (i < len)) {
#line 74
        goto while_break___1;
      }
      {
#line 75
      tmp___7 = n;
#line 75
      n ++;
#line 75
      tmp___9 = printable((int )*(s + i));
      }
#line 75
      if (tmp___9) {
#line 75
        *(buf + tmp___7) = (char )*(s + i);
      } else {
#line 75
        *(buf + tmp___7) = (char )'.';
      }
#line 74
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 77
    tmp___10 = n;
#line 77
    n ++;
#line 77
    *(buf + tmp___10) = (char )'\n';
#line 78
    *(buf + n) = (char )'\000';
  }
#line 80
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static mem_t *mem_areas___0  =    (mem_t *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void (*fail_stub___0)(char const   *fmt  , ...)  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static char const   header___0[59]  = 
#line 76
  {      (char const   )'M',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'a',      (char const   )'k',      (char const   )' ', 
        (char const   )'D',      (char const   )'e',      (char const   )'t',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'S',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )'\n',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'\n',      (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xmalloc___0(char const   *file , int line , char const   *function ,
                         size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 84
  ptr = malloc(size);
  }
#line 84
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 85
    (*fail_stub___0)("malloc(size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                     size, file, line, function);
    }
  }
#line 90
  return (ptr);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xrealloc___0(char const   *file , int line , char const   *function ,
                          void *ptr , size_t size ) 
{ 
  void *ptr2 ;

  {
  {
#line 98
  ptr2 = realloc(ptr, size);
  }
#line 98
  if ((unsigned long )ptr2 == (unsigned long )((void *)0)) {
    {
#line 99
    (*fail_stub___0)("realloc(ptr: %p, size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                     ptr, size, file, line, function);
    }
  }
#line 104
  return (ptr2);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort1___0(char const   *msg , mem_t *area , char const   *file ,
                           int line , char const   *function ) 
{ 


  {
  {
#line 110
  (*fail_stub___0)("%s%s\nAllocated in file \"%s\" at line %d in function %s()\nDiscovered in file \"%s\" at line %d in function %s()\n",
                   header___0, msg, area->file, area->line, area->function, file,
                   line, function);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort2___0(char const   *msg , char const   *file , int line , char const   *function ) 
{ 


  {
  {
#line 120
  (*fail_stub___0)("%s%s\nDiscovered in file \"%s\" at line %d in function %s()\n",
                   header___0, msg, file, line, function);
  }
#line 124
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void fail_default_stub___0(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 284
  __builtin_va_start(ap, fmt);
  }
#line 285
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    {
#line 285
    log_vprintf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                     285, "fail_default_stub", 1, fmt, ap);
    }
  }
  {
#line 286
  __builtin_va_end(ap);
#line 287
  exit(1);
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *vbprintf___0(char const   *fmt , va_list ap ) 
{ 
  int n ;
  int size ;
  char *buf ;
  char *ptr ;
  va_list ap_copy ;
  void *tmp ;
  void *tmp___0 ;
  int saved ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 110
  size = 100;
#line 114
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 114
    return ((char *)((void *)0));
  }
#line 116
  if ((int const   )*fmt == 0) {
    {
#line 118
    tmp = malloc(sizeof(char ));
#line 118
    buf = (char *)tmp;
    }
#line 118
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 119
      return ((char *)((void *)0));
    }
#line 120
    *buf = (char )'\000';
#line 121
    return (buf);
  }
  {
#line 124
  tmp___0 = malloc((unsigned long )size * sizeof(char ));
#line 124
  buf = (char *)tmp___0;
  }
#line 124
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 125
    return ((char *)((void *)0));
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    __builtin_va_copy(ap_copy, ap);
#line 131
    n = vsnprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)fmt,
                  ap_copy);
#line 132
    __builtin_va_end(ap_copy);
    }
#line 135
    if (n > -1) {
#line 135
      if (n < size) {
#line 135
        goto while_break;
      }
    }
#line 138
    if (n > -1) {
#line 139
      size = n + 1;
    } else {
#line 141
      size *= 2;
    }
    {
#line 143
    tmp___3 = realloc((void *)buf, (unsigned long )size * sizeof(char ));
#line 143
    ptr = (char *)tmp___3;
    }
#line 143
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___1 = __errno_location();
#line 145
      saved = *tmp___1;
#line 146
      free((void *)buf);
#line 147
      tmp___2 = __errno_location();
#line 147
      *tmp___2 = saved;
      }
#line 148
      return ((char *)((void *)0));
    } else {
#line 150
      buf = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (buf);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *bprintf___0(char const   *fmt  , ...) 
{ 
  char *buf ;
  va_list ap ;

  {
  {
#line 165
  __builtin_va_start(ap, fmt);
#line 166
  buf = vbprintf___0(fmt, ap);
#line 167
  __builtin_va_end(ap);
  }
#line 168
  return (buf);
}
}
#line 173
static char *prefix___0(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *colors___0[7]  = {      (char const   *)((void *)0),      "1;31",      "1;37",      (char const   *)((void *)0), 
        "1;32",      "40;33",      "1;33"};
#line 174 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *levels___0[7]  = {      "  QUIET",      "  ERROR",      "WARNING",      " NORMAL", 
        "VERBOSE",      "  DEBUG",      "  NOISY"};
#line 184 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int const   syslvl___0[7]  = {      (int const   )0,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )7};
#line 171 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *prefix___0(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level ) 
{ 
  int have_prefix ;
  int tmp ;
  int i ;
  int n ;
  char *buf[5] ;
  size_t len ;
  int tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  time_t tc ;
  time_t tmp___5 ;
  struct tm *tv ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int saved ;
  int *tmp___12 ;
  int *tmp___13 ;
  size_t tmp___14 ;
  int saved___0 ;
  int *tmp___15 ;
  int *tmp___16 ;
  void *tmp___17 ;

  {
#line 194
  if (! (priv->flags & 8)) {
#line 194
    if (priv->level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 194
  if (priv->flags & 8) {
#line 194
    if (level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      tmp = 0;
    }
  } else {
#line 194
    tmp = 0;
  }
#line 194
  have_prefix = tmp;
#line 195
  n = 0;
#line 197
  len = (size_t )0;
#line 199
  if (have_prefix) {
#line 201
    tmp___0 = n;
#line 201
    n ++;
#line 201
    if (priv->flags & 2) {
#line 201
      if (priv->flags & 64) {
#line 201
        goto _L___0;
      } else {
        {
#line 201
        tmp___4 = isatty(priv->fd);
        }
#line 201
        if (tmp___4) {
          _L___0: /* CIL Label */ 
#line 201
          if ((unsigned long )colors___0[level] != (unsigned long )((void *)0)) {
            {
#line 201
            tmp___2 = bprintf___0("\033[%sm%s: \033[0m", colors___0[level], levels___0[level]);
#line 201
            buf[tmp___0] = tmp___2;
            }
          } else {
            {
#line 201
            tmp___3 = bprintf___0("%s: ", levels___0[level]);
#line 201
            buf[tmp___0] = tmp___3;
            }
          }
        } else {
          {
#line 201
          tmp___3 = bprintf___0("%s: ", levels___0[level]);
#line 201
          buf[tmp___0] = tmp___3;
          }
        }
      }
    } else {
      {
#line 201
      tmp___3 = bprintf___0("%s: ", levels___0[level]);
#line 201
      buf[tmp___0] = tmp___3;
      }
    }
  }
#line 208
  if (priv->flags & 1) {
    {
#line 210
    tmp___5 = time((time_t *)((void *)0));
#line 210
    tc = tmp___5;
#line 211
    tmp___6 = localtime((time_t const   *)(& tc));
#line 211
    tv = tmp___6;
#line 213
    tmp___7 = n;
#line 213
    n ++;
#line 213
    buf[tmp___7] = bprintf___0("%.4d-%.2d-%.2d %.2d:%.2d:%.2d ", tv->tm_year + 1900,
                               tv->tm_mon + 1, tv->tm_mday, tv->tm_hour, tv->tm_min,
                               tv->tm_sec);
    }
  }
#line 218
  if (have_prefix) {
    {
#line 220
    tmp___8 = n;
#line 220
    n ++;
#line 220
    buf[tmp___8] = bprintf___0("%s:%d:", filename, line);
#line 221
    tmp___9 = n;
#line 221
    n ++;
    }
#line 221
    if (priv->flags & 4) {
      {
#line 221
      tmp___10 = bprintf___0("%s(): ", function);
#line 221
      buf[tmp___9] = tmp___10;
      }
    } else {
      {
#line 221
      tmp___11 = bprintf___0(" ");
#line 221
      buf[tmp___9] = tmp___11;
      }
    }
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < n)) {
#line 224
      goto while_break;
    }
#line 226
    if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
      {
#line 228
      tmp___12 = __errno_location();
#line 228
      saved = *tmp___12;
#line 230
      i = 0;
      }
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (! (i < n)) {
#line 230
          goto while_break___0;
        }
#line 231
        if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
          {
#line 232
          free((void *)buf[i]);
          }
        }
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 234
      tmp___13 = __errno_location();
#line 234
      *tmp___13 = saved;
      }
#line 236
      return ((char *)((void *)0));
    }
    {
#line 239
    tmp___14 = strlen((char const   *)buf[i]);
#line 239
    len += tmp___14;
#line 224
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp___17 = malloc((len + 1UL) * sizeof(char ));
#line 242
  buf[4] = (char *)tmp___17;
  }
#line 242
  if ((unsigned long )buf[4] == (unsigned long )((void *)0)) {
    {
#line 244
    tmp___15 = __errno_location();
#line 244
    saved___0 = *tmp___15;
#line 245
    i = 0;
    }
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___1;
      }
#line 246
      if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
        {
#line 247
        free((void *)buf[i]);
        }
      }
#line 245
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 248
    tmp___16 = __errno_location();
#line 248
    *tmp___16 = saved___0;
    }
#line 249
    return ((char *)((void *)0));
  }
#line 252
  *(buf[4]) = (char )'\000';
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 254
    if (! (i < n)) {
#line 254
      goto while_break___2;
    }
    {
#line 256
    strcat((char */* __restrict  */)buf[4], (char const   */* __restrict  */)buf[i]);
#line 257
    free((void *)buf[i]);
#line 254
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 260
  priv->syslvl = (int )syslvl___0[level];
#line 262
  return (buf[4]);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_append___0(struct log_private *priv , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  char *ptr ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 271
  tmp = strlen(str);
#line 271
  len = tmp + 1UL;
  }
#line 274
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 276
    tmp___0 = strlen((char const   *)priv->str);
#line 276
    tmp___1 = realloc((void *)priv->str, (len + tmp___0) * sizeof(char ));
#line 276
    ptr = (char *)tmp___1;
    }
#line 276
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 277
      return (-1);
    }
    {
#line 279
    priv->str = ptr;
#line 280
    strcat((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  } else {
    {
#line 284
    tmp___3 = malloc(len * sizeof(char ));
#line 284
    tmp___2 = (char *)tmp___3;
#line 284
    priv->str = tmp___2;
    }
#line 284
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 285
      return (-1);
    }
    {
#line 286
    strcpy((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_begin___0(struct log_private *priv , char const   *filename , int line ,
                          char const   *function , int level , char const   *str ) 
{ 
  char *tmp ;
  int saved ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 296
  tmp = prefix___0(priv, filename, line, function, level);
  }
#line 296
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 297
    return (-1);
  }
  {
#line 299
  tmp___2 = line_append___0(priv, (char const   *)tmp);
  }
#line 299
  if (tmp___2 < 0) {
    {
#line 301
    tmp___0 = __errno_location();
#line 301
    saved = *tmp___0;
#line 302
    free((void *)tmp);
#line 303
    tmp___1 = __errno_location();
#line 303
    *tmp___1 = saved;
    }
#line 304
    return (-1);
  }
  {
#line 307
  free((void *)tmp);
#line 309
  tmp___3 = line_append___0(priv, str);
  }
#line 309
  return (tmp___3);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int savetodisk___0(int fd , char const   *str ) 
{ 
  ssize_t n ;
  ssize_t len ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 314
  tmp = strlen(str);
#line 314
  len = (ssize_t )tmp;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (len) {
      {
#line 316
      n = write(fd, (void const   *)str, (size_t )len);
      }
#line 316
      if (! (n != len)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 318
    if (n < 0L) {
#line 318
      return (-1);
    }
#line 320
    if (! n) {
      {
#line 322
      tmp___0 = __errno_location();
#line 322
      *tmp___0 = 5;
      }
#line 323
      return (-1);
    }
#line 326
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int flush_cache___0(struct log_private *priv , char const   *filename , int line ,
                           char const   *function ) 
{ 
  int saved ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *buf ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 336
  if ((unsigned long )priv->cache.cache == (unsigned long )((void *)0)) {
#line 337
    return (0);
  } else
#line 336
  if (! (priv->flags & 16)) {
#line 337
    return (0);
  }
  {
#line 339
  tmp___1 = savetodisk___0(priv->cache.fd, (char const   *)priv->cache.cache);
  }
#line 339
  if (tmp___1 < 0) {
    error: 
    {
#line 342
    tmp = __errno_location();
#line 342
    saved = *tmp;
#line 343
    free((void *)priv->cache.cache);
#line 344
    priv->cache.cache = (char *)((void *)0);
#line 345
    tmp___0 = __errno_location();
#line 345
    *tmp___0 = saved;
    }
#line 346
    return (-1);
  }
#line 349
  if (priv->cache.hits) {
    {
#line 351
    tmp___2 = prefix___0(priv, filename, line, function, 2);
#line 351
    buf = tmp___2;
    }
#line 353
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 354
      goto error;
    }
    {
#line 356
    tmp___5 = savetodisk___0(priv->cache.fd, (char const   *)buf);
    }
#line 356
    if (tmp___5 < 0) {
      {
#line 358
      tmp___3 = __errno_location();
#line 358
      saved = *tmp___3;
#line 359
      free((void *)buf);
#line 360
      tmp___4 = __errno_location();
#line 360
      *tmp___4 = saved;
      }
#line 361
      goto error;
    }
    {
#line 364
    free((void *)buf);
#line 366
    sprintf((char */* __restrict  */)(priv->cache.buf), (char const   */* __restrict  */)"Message repeated %d times\n",
            priv->cache.hits + 1);
#line 368
    tmp___6 = savetodisk___0(priv->cache.fd, (char const   *)(priv->cache.buf));
    }
#line 368
    if (tmp___6 < 0) {
#line 369
      goto error;
    }
  }
  {
#line 372
  free((void *)priv->cache.cache);
#line 373
  priv->cache.cache = (char *)((void *)0);
  }
#line 375
  return (0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static void save_to_cache___0(struct log_private *priv ) 
{ 


  {
#line 380
  priv->cache.fd = priv->fd;
#line 381
  priv->cache.hits = 0;
#line 382
  priv->cache.cache = priv->str;
#line 383
  priv->str = (char *)((void *)0);
#line 384
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_end___0(struct log_private *priv , char const   *filename , int line ,
                        char const   *function ) 
{ 
  int saved ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 390
  if (priv->flags & 64) {
    {
#line 392
    syslog(priv->syslvl, "%s", priv->str);
#line 393
    free((void *)priv->str);
#line 394
    priv->str = (char *)((void *)0);
    }
#line 395
    return (0);
  }
  {
#line 398
  tmp = line_append___0(priv, "\n");
  }
#line 398
  if (tmp < 0) {
#line 399
    return (-1);
  }
#line 401
  if (priv->flags & 16) {
#line 403
    if ((unsigned long )priv->cache.cache != (unsigned long )((void *)0)) {
      {
#line 405
      tmp___1 = strcmp((char const   *)priv->str, (char const   *)priv->cache.cache);
      }
#line 405
      if (tmp___1) {
        {
#line 407
        tmp___0 = flush_cache___0(priv, filename, line, function);
        }
#line 407
        if (tmp___0 < 0) {
#line 408
          goto error;
        }
        {
#line 410
        save_to_cache___0(priv);
        }
      } else {
        {
#line 414
        free((void *)priv->str);
#line 415
        priv->str = (char *)((void *)0);
#line 416
        (priv->cache.hits) ++;
        }
      }
    } else {
      {
#line 419
      save_to_cache___0(priv);
      }
    }
  } else {
    {
#line 423
    tmp___4 = savetodisk___0(priv->fd, (char const   *)priv->str);
    }
#line 423
    if (tmp___4 < 0) {
      error: 
      {
#line 426
      tmp___2 = __errno_location();
#line 426
      saved = *tmp___2;
#line 427
      free((void *)priv->str);
#line 428
      priv->str = (char *)((void *)0);
#line 429
      tmp___3 = __errno_location();
#line 429
      *tmp___3 = saved;
      }
#line 430
      return (-1);
    }
    {
#line 433
    free((void *)priv->str);
#line 434
    priv->str = (char *)((void *)0);
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int newline___0  =    1;
#line 451
static int write_string___0(struct log_private *priv , char const   *filename , int line ,
                            char const   *function , int level , char *str ) ;
#line 451 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int prevlevel___0  =    0;
#line 448 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int write_string___0(struct log_private *priv , char const   *filename , int line ,
                            char const   *function , int level , char *str ) 
{ 
  char *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 453
  if (level != prevlevel___0) {
    {
#line 455
    fd_update(priv, prevlevel___0);
    }
#line 456
    if (! newline___0) {
      {
#line 456
      tmp___0 = line_end___0(priv, filename, line, function);
      }
#line 456
      if (tmp___0 < 0) {
#line 456
        goto error;
      }
    }
#line 457
    newline___0 = 1;
#line 458
    prevlevel___0 = level;
  }
  {
#line 461
  fd_update(priv, level);
#line 463
  s = str;
  }
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 463
    tmp = strchr((char const   *)s, '\n');
    }
#line 463
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 463
      goto while_break;
    }
#line 465
    *tmp = (char )'\000';
#line 467
    if ((unsigned long )s == (unsigned long )str) {
#line 467
      if (! newline___0) {
        {
#line 469
        newline___0 = 1;
#line 470
        tmp___1 = line_append___0(priv, (char const   *)s);
        }
#line 470
        if (tmp___1 < 0) {
#line 470
          goto error;
        }
      } else {
#line 467
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 472
      tmp___2 = line_begin___0(priv, filename, line, function, level, (char const   *)s);
      }
#line 472
      if (tmp___2 < 0) {
#line 473
        goto error;
      }
    }
    {
#line 475
    tmp___3 = line_end___0(priv, filename, line, function);
    }
#line 475
    if (tmp___3 < 0) {
#line 475
      goto error;
    }
#line 463
    s = tmp + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (*s) {
#line 480
    if (newline___0) {
      {
#line 482
      tmp___4 = line_begin___0(priv, filename, line, function, level, (char const   *)s);
      }
#line 482
      if (tmp___4 < 0) {
#line 483
        goto error;
      }
    } else {
      {
#line 485
      tmp___5 = line_append___0(priv, (char const   *)s);
      }
#line 485
      if (tmp___5 < 0) {
#line 486
        goto error;
      }
    }
#line 488
    newline___0 = 0;
  }
#line 491
  return (0);
  error: 
#line 494
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 496
    free((void *)priv->str);
#line 497
    priv->str = (char *)((void *)0);
    }
  }
#line 499
  return (-1);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int print_one_line___0(struct log_private *priv , char const   *filename ,
                              int line , char const   *function , int level , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (level != 0) {
#line 504
      if (priv->level != 0) {
#line 504
        if (! (level <= priv->level)) {
#line 504
          goto while_break;
        }
      } else {
#line 504
        goto while_break;
      }
    } else {
#line 504
      goto while_break;
    }
    {
#line 506
    fd_update(priv, level);
    }
#line 508
    if (! newline___0) {
      {
#line 508
      tmp = line_end___0(priv, filename, line, function);
      }
#line 508
      if (tmp < 0) {
#line 509
        goto while_break;
      }
    }
    {
#line 511
    newline___0 = 1;
#line 513
    tmp___0 = line_begin___0(priv, filename, line, function, level, str);
    }
#line 513
    if (tmp___0 < 0) {
#line 514
      goto while_break;
    } else {
      {
#line 513
      tmp___1 = line_end___0(priv, filename, line, function);
      }
#line 513
      if (tmp___1 < 0) {
#line 514
        goto while_break;
      }
    }
    {
#line 516
    tmp___2 = flush_cache___0(priv, filename, line, function);
    }
#line 516
    return (tmp___2);
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 521
    free((void *)priv->str);
#line 522
    priv->str = (char *)((void *)0);
    }
  }
#line 525
  return (-1);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static struct log_private log_private___0  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int initialized___0  =    0;
#line 535 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int log_open_syslog___0(char const   *str ) 
{ 
  char *facility ;
  size_t i ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 540
  tmp = strlen(str);
#line 540
  tmp___0 = malloc(tmp + 1UL);
#line 540
  log_private___0.ident = (char *)tmp___0;
  }
#line 540
  if ((unsigned long )log_private___0.ident == (unsigned long )((void *)0)) {
#line 541
    return (-1);
  }
  {
#line 543
  strcpy((char */* __restrict  */)log_private___0.ident, (char const   */* __restrict  */)str);
#line 545
  facility = strchr((char const   *)log_private___0.ident, '.');
  }
#line 545
  if ((unsigned long )facility == (unsigned long )((void *)0)) {
#line 546
    return (-1);
  }
#line 548
  tmp___1 = facility;
#line 548
  facility ++;
#line 548
  *tmp___1 = (char )'\000';
#line 550
  i = (size_t )0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! ((unsigned long )facilitynames[i].c_name != (unsigned long )((void *)0))) {
#line 550
      goto while_break;
    }
    {
#line 551
    tmp___2 = strcmp((char const   *)facility, (char const   *)facilitynames[i].c_name);
    }
#line 551
    if (! tmp___2) {
      {
#line 553
      openlog((char const   *)log_private___0.ident, 1, facilitynames[i].c_val);
      }
#line 554
      return (0);
    }
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (-1);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c"
static void *xalloc(size_t count ) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = mem_alloc_stub(count, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                       45, "xalloc");
  }
#line 45
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 47
    log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                    47, "xalloc", 1, "alloc failed: %m\n");
#line 48
    exit(1);
    }
  }
#line 51
  return (tmp);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c"
static void *xrealloc___1(void *ptr , size_t count ) 
{ 
  void *tmp ;

  {
  {
#line 60
  tmp = mem_realloc_stub(ptr, count, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                         60, "xrealloc");
  }
#line 60
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 62
    log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                    62, "xrealloc", 1, "realloc failed: %m\n");
#line 63
    mem_free_stub(ptr, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                  63, "xrealloc");
#line 64
    exit(1);
    }
  }
#line 67
  return (tmp);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c"
static void test_alloc(void) 
{ 
  void *tmp ;
  int i ;

  {
#line 77
  i = 1;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 1048576)) {
#line 77
      goto while_break;
    }
    {
#line 79
    tmp = xalloc((size_t )i);
#line 80
    memset(tmp, 85, (size_t )i);
#line 81
    memset(tmp, 170, (size_t )i);
#line 82
    mem_free_stub(tmp, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                  82, "test_alloc");
#line 77
    i += 1025;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c"
static void test_realloc(void) 
{ 
  unsigned char *tmp ;
  unsigned char pattern ;
  int i ;
  int j ;
  int k ;
  void *tmp___0 ;

  {
#line 90
  tmp = (unsigned char *)((void *)0);
#line 90
  pattern = (unsigned char)85;
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < 16)) {
#line 93
      goto while_break;
    }
    {
#line 95
    tmp___0 = xrealloc___1((void *)tmp, (size_t )((i + 1) * 1025));
#line 95
    tmp = (unsigned char *)tmp___0;
#line 96
    memset((void *)(tmp + i * 1025), (int )pattern, (size_t )1025);
#line 98
    j = 0;
    }
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (j < i + 1)) {
#line 98
        goto while_break___0;
      }
#line 99
      k = 0;
      {
#line 99
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 99
        if (! (k < 1025)) {
#line 99
          goto while_break___1;
        }
#line 99
        if ((int )*(tmp + (k + j * 1025)) != (int )pattern) {
          {
#line 101
          mem_free_stub((void *)tmp, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                        101, "test_realloc");
#line 102
          log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                          102, "test_realloc", 1, "realloc test failed on round %d at position %d\n",
                          i, j);
#line 103
          exit(1);
          }
        }
#line 99
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 98
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 106
    log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                    106, "test_realloc", 3, "round %d succeeded\n", i);
#line 93
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  mem_free_stub((void *)tmp, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_memory.c",
                109, "test_realloc");
  }
#line 110
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/hex.c"
static void dump16___1(char *buf , uint8_t const   *s , uintptr_t offset , size_t len ) 
{ 
  size_t i ;
  size_t n ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
#line 48
  if (len) {
    {
#line 52
    tmp = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%08x - ",
                  offset);
#line 52
    n = (size_t )tmp;
#line 54
    i = (size_t )0;
    }
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
#line 54
      if (! (i < len)) {
#line 54
        goto while_break;
      }
#line 56
      if (i) {
#line 56
        if (! (i & 3UL)) {
#line 57
          tmp___0 = n;
#line 57
          n ++;
#line 57
          *(buf + tmp___0) = (char )' ';
        }
      }
      {
#line 59
      tmp___1 = sprintf((char */* __restrict  */)(buf + n), (char const   */* __restrict  */)"%02x ",
                        (int const   )*(s + i));
#line 59
      n += (size_t )tmp___1;
#line 54
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (i < 16UL)) {
#line 62
        goto while_break___0;
      }
#line 64
      if (i) {
#line 64
        if (! (i & 3UL)) {
#line 65
          tmp___2 = n;
#line 65
          n ++;
#line 65
          *(buf + tmp___2) = (char )' ';
        }
      }
#line 67
      tmp___3 = n;
#line 67
      n ++;
#line 67
      *(buf + tmp___3) = (char )' ';
#line 68
      tmp___4 = n;
#line 68
      n ++;
#line 68
      *(buf + tmp___4) = (char )' ';
#line 69
      tmp___5 = n;
#line 69
      n ++;
#line 69
      *(buf + tmp___5) = (char )' ';
#line 62
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    tmp___6 = n;
#line 72
    n ++;
#line 72
    *(buf + tmp___6) = (char )' ';
#line 74
    i = (size_t )0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (i < len)) {
#line 74
        goto while_break___1;
      }
      {
#line 75
      tmp___7 = n;
#line 75
      n ++;
#line 75
      tmp___9 = printable((int )*(s + i));
      }
#line 75
      if (tmp___9) {
#line 75
        *(buf + tmp___7) = (char )*(s + i);
      } else {
#line 75
        *(buf + tmp___7) = (char )'.';
      }
#line 74
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 77
    tmp___10 = n;
#line 77
    n ++;
#line 77
    *(buf + tmp___10) = (char )'\n';
#line 78
    *(buf + n) = (char )'\000';
  }
#line 80
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static mem_t *mem_areas___1  =    (mem_t *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void (*fail_stub___1)(char const   *fmt  , ...)  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static char const   header___1[59]  = 
#line 76
  {      (char const   )'M',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'a',      (char const   )'k',      (char const   )' ', 
        (char const   )'D',      (char const   )'e',      (char const   )'t',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'S',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )'\n',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'\n',      (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xmalloc___1(char const   *file , int line , char const   *function ,
                         size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 84
  ptr = malloc(size);
  }
#line 84
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 85
    (*fail_stub___1)("malloc(size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                     size, file, line, function);
    }
  }
#line 90
  return (ptr);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xrealloc___2(char const   *file , int line , char const   *function ,
                          void *ptr , size_t size ) 
{ 
  void *ptr2 ;

  {
  {
#line 98
  ptr2 = realloc(ptr, size);
  }
#line 98
  if ((unsigned long )ptr2 == (unsigned long )((void *)0)) {
    {
#line 99
    (*fail_stub___1)("realloc(ptr: %p, size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                     ptr, size, file, line, function);
    }
  }
#line 104
  return (ptr2);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort1___1(char const   *msg , mem_t *area , char const   *file ,
                           int line , char const   *function ) 
{ 


  {
  {
#line 110
  (*fail_stub___1)("%s%s\nAllocated in file \"%s\" at line %d in function %s()\nDiscovered in file \"%s\" at line %d in function %s()\n",
                   header___1, msg, area->file, area->line, area->function, file,
                   line, function);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort2___1(char const   *msg , char const   *file , int line , char const   *function ) 
{ 


  {
  {
#line 120
  (*fail_stub___1)("%s%s\nDiscovered in file \"%s\" at line %d in function %s()\n",
                   header___1, msg, file, line, function);
  }
#line 124
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void fail_default_stub___1(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 284
  __builtin_va_start(ap, fmt);
  }
#line 285
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    {
#line 285
    log_vprintf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                     285, "fail_default_stub", 1, fmt, ap);
    }
  }
  {
#line 286
  __builtin_va_end(ap);
#line 287
  exit(1);
  }
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c"
static void *getfile(int fd , size_t *length ) 
{ 
  size_t size ;
  char *buf ;
  ssize_t result ;
  void *tmp ;
  void *ptr ;

  {
  {
#line 44
  size = (size_t )8192;
#line 48
  tmp = mem_alloc_stub(size, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                       48, "getfile");
#line 48
  buf = (char *)tmp;
  }
#line 48
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 50
    log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                    50, "getfile", 1, "failed to allocate memory: %m\n");
    }
#line 51
    return ((void *)0);
  }
#line 54
  *length = (size_t )0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    result = read(fd, (void *)(buf + *length), size - *length);
    }
#line 56
    if (! (result > 0L)) {
#line 56
      goto while_break;
    }
#line 58
    *length += (size_t )result;
#line 60
    if (*length == size) {
      {
#line 64
      size += 8192UL;
#line 66
      ptr = mem_realloc_stub((void *)buf, size, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                             66, "getfile");
      }
#line 66
      if ((unsigned long )ptr == (unsigned long )((void *)0)) {
        {
#line 68
        log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                        68, "getfile", 1, "failed to allocate memory: %m\n");
#line 69
        mem_free_stub((void *)buf, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                      69, "getfile");
        }
#line 70
        return ((void *)0);
      }
#line 73
      buf = (char *)ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (result < 0L) {
    {
#line 79
    log_printf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                    79, "getfile", 1, "read: %m\n");
#line 80
    mem_free_stub((void *)buf, "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/tests/test_hex.c",
                  80, "getfile");
    }
#line 81
    return ((void *)0);
  }
#line 84
  return ((void *)buf);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *vbprintf___1(char const   *fmt , va_list ap ) 
{ 
  int n ;
  int size ;
  char *buf ;
  char *ptr ;
  va_list ap_copy ;
  void *tmp ;
  void *tmp___0 ;
  int saved ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 110
  size = 100;
#line 114
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 114
    return ((char *)((void *)0));
  }
#line 116
  if ((int const   )*fmt == 0) {
    {
#line 118
    tmp = malloc(sizeof(char ));
#line 118
    buf = (char *)tmp;
    }
#line 118
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 119
      return ((char *)((void *)0));
    }
#line 120
    *buf = (char )'\000';
#line 121
    return (buf);
  }
  {
#line 124
  tmp___0 = malloc((unsigned long )size * sizeof(char ));
#line 124
  buf = (char *)tmp___0;
  }
#line 124
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 125
    return ((char *)((void *)0));
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    __builtin_va_copy(ap_copy, ap);
#line 131
    n = vsnprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)fmt,
                  ap_copy);
#line 132
    __builtin_va_end(ap_copy);
    }
#line 135
    if (n > -1) {
#line 135
      if (n < size) {
#line 135
        goto while_break;
      }
    }
#line 138
    if (n > -1) {
#line 139
      size = n + 1;
    } else {
#line 141
      size *= 2;
    }
    {
#line 143
    tmp___3 = realloc((void *)buf, (unsigned long )size * sizeof(char ));
#line 143
    ptr = (char *)tmp___3;
    }
#line 143
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___1 = __errno_location();
#line 145
      saved = *tmp___1;
#line 146
      free((void *)buf);
#line 147
      tmp___2 = __errno_location();
#line 147
      *tmp___2 = saved;
      }
#line 148
      return ((char *)((void *)0));
    } else {
#line 150
      buf = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (buf);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *bprintf___1(char const   *fmt  , ...) 
{ 
  char *buf ;
  va_list ap ;

  {
  {
#line 165
  __builtin_va_start(ap, fmt);
#line 166
  buf = vbprintf___1(fmt, ap);
#line 167
  __builtin_va_end(ap);
  }
#line 168
  return (buf);
}
}
#line 173
static char *prefix___1(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *colors___1[7]  = {      (char const   *)((void *)0),      "1;31",      "1;37",      (char const   *)((void *)0), 
        "1;32",      "40;33",      "1;33"};
#line 174 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *levels___1[7]  = {      "  QUIET",      "  ERROR",      "WARNING",      " NORMAL", 
        "VERBOSE",      "  DEBUG",      "  NOISY"};
#line 184 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int const   syslvl___1[7]  = {      (int const   )0,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )7};
#line 171 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *prefix___1(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level ) 
{ 
  int have_prefix ;
  int tmp ;
  int i ;
  int n ;
  char *buf[5] ;
  size_t len ;
  int tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  time_t tc ;
  time_t tmp___5 ;
  struct tm *tv ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int saved ;
  int *tmp___12 ;
  int *tmp___13 ;
  size_t tmp___14 ;
  int saved___0 ;
  int *tmp___15 ;
  int *tmp___16 ;
  void *tmp___17 ;

  {
#line 194
  if (! (priv->flags & 8)) {
#line 194
    if (priv->level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 194
  if (priv->flags & 8) {
#line 194
    if (level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      tmp = 0;
    }
  } else {
#line 194
    tmp = 0;
  }
#line 194
  have_prefix = tmp;
#line 195
  n = 0;
#line 197
  len = (size_t )0;
#line 199
  if (have_prefix) {
#line 201
    tmp___0 = n;
#line 201
    n ++;
#line 201
    if (priv->flags & 2) {
#line 201
      if (priv->flags & 64) {
#line 201
        goto _L___0;
      } else {
        {
#line 201
        tmp___4 = isatty(priv->fd);
        }
#line 201
        if (tmp___4) {
          _L___0: /* CIL Label */ 
#line 201
          if ((unsigned long )colors___1[level] != (unsigned long )((void *)0)) {
            {
#line 201
            tmp___2 = bprintf___1("\033[%sm%s: \033[0m", colors___1[level], levels___1[level]);
#line 201
            buf[tmp___0] = tmp___2;
            }
          } else {
            {
#line 201
            tmp___3 = bprintf___1("%s: ", levels___1[level]);
#line 201
            buf[tmp___0] = tmp___3;
            }
          }
        } else {
          {
#line 201
          tmp___3 = bprintf___1("%s: ", levels___1[level]);
#line 201
          buf[tmp___0] = tmp___3;
          }
        }
      }
    } else {
      {
#line 201
      tmp___3 = bprintf___1("%s: ", levels___1[level]);
#line 201
      buf[tmp___0] = tmp___3;
      }
    }
  }
#line 208
  if (priv->flags & 1) {
    {
#line 210
    tmp___5 = time((time_t *)((void *)0));
#line 210
    tc = tmp___5;
#line 211
    tmp___6 = localtime((time_t const   *)(& tc));
#line 211
    tv = tmp___6;
#line 213
    tmp___7 = n;
#line 213
    n ++;
#line 213
    buf[tmp___7] = bprintf___1("%.4d-%.2d-%.2d %.2d:%.2d:%.2d ", tv->tm_year + 1900,
                               tv->tm_mon + 1, tv->tm_mday, tv->tm_hour, tv->tm_min,
                               tv->tm_sec);
    }
  }
#line 218
  if (have_prefix) {
    {
#line 220
    tmp___8 = n;
#line 220
    n ++;
#line 220
    buf[tmp___8] = bprintf___1("%s:%d:", filename, line);
#line 221
    tmp___9 = n;
#line 221
    n ++;
    }
#line 221
    if (priv->flags & 4) {
      {
#line 221
      tmp___10 = bprintf___1("%s(): ", function);
#line 221
      buf[tmp___9] = tmp___10;
      }
    } else {
      {
#line 221
      tmp___11 = bprintf___1(" ");
#line 221
      buf[tmp___9] = tmp___11;
      }
    }
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < n)) {
#line 224
      goto while_break;
    }
#line 226
    if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
      {
#line 228
      tmp___12 = __errno_location();
#line 228
      saved = *tmp___12;
#line 230
      i = 0;
      }
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (! (i < n)) {
#line 230
          goto while_break___0;
        }
#line 231
        if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
          {
#line 232
          free((void *)buf[i]);
          }
        }
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 234
      tmp___13 = __errno_location();
#line 234
      *tmp___13 = saved;
      }
#line 236
      return ((char *)((void *)0));
    }
    {
#line 239
    tmp___14 = strlen((char const   *)buf[i]);
#line 239
    len += tmp___14;
#line 224
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp___17 = malloc((len + 1UL) * sizeof(char ));
#line 242
  buf[4] = (char *)tmp___17;
  }
#line 242
  if ((unsigned long )buf[4] == (unsigned long )((void *)0)) {
    {
#line 244
    tmp___15 = __errno_location();
#line 244
    saved___0 = *tmp___15;
#line 245
    i = 0;
    }
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___1;
      }
#line 246
      if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
        {
#line 247
        free((void *)buf[i]);
        }
      }
#line 245
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 248
    tmp___16 = __errno_location();
#line 248
    *tmp___16 = saved___0;
    }
#line 249
    return ((char *)((void *)0));
  }
#line 252
  *(buf[4]) = (char )'\000';
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 254
    if (! (i < n)) {
#line 254
      goto while_break___2;
    }
    {
#line 256
    strcat((char */* __restrict  */)buf[4], (char const   */* __restrict  */)buf[i]);
#line 257
    free((void *)buf[i]);
#line 254
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 260
  priv->syslvl = (int )syslvl___1[level];
#line 262
  return (buf[4]);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_append___1(struct log_private *priv , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  char *ptr ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 271
  tmp = strlen(str);
#line 271
  len = tmp + 1UL;
  }
#line 274
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 276
    tmp___0 = strlen((char const   *)priv->str);
#line 276
    tmp___1 = realloc((void *)priv->str, (len + tmp___0) * sizeof(char ));
#line 276
    ptr = (char *)tmp___1;
    }
#line 276
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 277
      return (-1);
    }
    {
#line 279
    priv->str = ptr;
#line 280
    strcat((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  } else {
    {
#line 284
    tmp___3 = malloc(len * sizeof(char ));
#line 284
    tmp___2 = (char *)tmp___3;
#line 284
    priv->str = tmp___2;
    }
#line 284
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 285
      return (-1);
    }
    {
#line 286
    strcpy((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_begin___1(struct log_private *priv , char const   *filename , int line ,
                          char const   *function , int level , char const   *str ) 
{ 
  char *tmp ;
  int saved ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 296
  tmp = prefix___1(priv, filename, line, function, level);
  }
#line 296
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 297
    return (-1);
  }
  {
#line 299
  tmp___2 = line_append___1(priv, (char const   *)tmp);
  }
#line 299
  if (tmp___2 < 0) {
    {
#line 301
    tmp___0 = __errno_location();
#line 301
    saved = *tmp___0;
#line 302
    free((void *)tmp);
#line 303
    tmp___1 = __errno_location();
#line 303
    *tmp___1 = saved;
    }
#line 304
    return (-1);
  }
  {
#line 307
  free((void *)tmp);
#line 309
  tmp___3 = line_append___1(priv, str);
  }
#line 309
  return (tmp___3);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int savetodisk___1(int fd , char const   *str ) 
{ 
  ssize_t n ;
  ssize_t len ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 314
  tmp = strlen(str);
#line 314
  len = (ssize_t )tmp;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (len) {
      {
#line 316
      n = write(fd, (void const   *)str, (size_t )len);
      }
#line 316
      if (! (n != len)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 318
    if (n < 0L) {
#line 318
      return (-1);
    }
#line 320
    if (! n) {
      {
#line 322
      tmp___0 = __errno_location();
#line 322
      *tmp___0 = 5;
      }
#line 323
      return (-1);
    }
#line 326
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int flush_cache___1(struct log_private *priv , char const   *filename , int line ,
                           char const   *function ) 
{ 
  int saved ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *buf ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 336
  if ((unsigned long )priv->cache.cache == (unsigned long )((void *)0)) {
#line 337
    return (0);
  } else
#line 336
  if (! (priv->flags & 16)) {
#line 337
    return (0);
  }
  {
#line 339
  tmp___1 = savetodisk___1(priv->cache.fd, (char const   *)priv->cache.cache);
  }
#line 339
  if (tmp___1 < 0) {
    error: 
    {
#line 342
    tmp = __errno_location();
#line 342
    saved = *tmp;
#line 343
    free((void *)priv->cache.cache);
#line 344
    priv->cache.cache = (char *)((void *)0);
#line 345
    tmp___0 = __errno_location();
#line 345
    *tmp___0 = saved;
    }
#line 346
    return (-1);
  }
#line 349
  if (priv->cache.hits) {
    {
#line 351
    tmp___2 = prefix___1(priv, filename, line, function, 2);
#line 351
    buf = tmp___2;
    }
#line 353
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 354
      goto error;
    }
    {
#line 356
    tmp___5 = savetodisk___1(priv->cache.fd, (char const   *)buf);
    }
#line 356
    if (tmp___5 < 0) {
      {
#line 358
      tmp___3 = __errno_location();
#line 358
      saved = *tmp___3;
#line 359
      free((void *)buf);
#line 360
      tmp___4 = __errno_location();
#line 360
      *tmp___4 = saved;
      }
#line 361
      goto error;
    }
    {
#line 364
    free((void *)buf);
#line 366
    sprintf((char */* __restrict  */)(priv->cache.buf), (char const   */* __restrict  */)"Message repeated %d times\n",
            priv->cache.hits + 1);
#line 368
    tmp___6 = savetodisk___1(priv->cache.fd, (char const   *)(priv->cache.buf));
    }
#line 368
    if (tmp___6 < 0) {
#line 369
      goto error;
    }
  }
  {
#line 372
  free((void *)priv->cache.cache);
#line 373
  priv->cache.cache = (char *)((void *)0);
  }
#line 375
  return (0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static void save_to_cache___1(struct log_private *priv ) 
{ 


  {
#line 380
  priv->cache.fd = priv->fd;
#line 381
  priv->cache.hits = 0;
#line 382
  priv->cache.cache = priv->str;
#line 383
  priv->str = (char *)((void *)0);
#line 384
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_end___1(struct log_private *priv , char const   *filename , int line ,
                        char const   *function ) 
{ 
  int saved ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 390
  if (priv->flags & 64) {
    {
#line 392
    syslog(priv->syslvl, "%s", priv->str);
#line 393
    free((void *)priv->str);
#line 394
    priv->str = (char *)((void *)0);
    }
#line 395
    return (0);
  }
  {
#line 398
  tmp = line_append___1(priv, "\n");
  }
#line 398
  if (tmp < 0) {
#line 399
    return (-1);
  }
#line 401
  if (priv->flags & 16) {
#line 403
    if ((unsigned long )priv->cache.cache != (unsigned long )((void *)0)) {
      {
#line 405
      tmp___1 = strcmp((char const   *)priv->str, (char const   *)priv->cache.cache);
      }
#line 405
      if (tmp___1) {
        {
#line 407
        tmp___0 = flush_cache___1(priv, filename, line, function);
        }
#line 407
        if (tmp___0 < 0) {
#line 408
          goto error;
        }
        {
#line 410
        save_to_cache___1(priv);
        }
      } else {
        {
#line 414
        free((void *)priv->str);
#line 415
        priv->str = (char *)((void *)0);
#line 416
        (priv->cache.hits) ++;
        }
      }
    } else {
      {
#line 419
      save_to_cache___1(priv);
      }
    }
  } else {
    {
#line 423
    tmp___4 = savetodisk___1(priv->fd, (char const   *)priv->str);
    }
#line 423
    if (tmp___4 < 0) {
      error: 
      {
#line 426
      tmp___2 = __errno_location();
#line 426
      saved = *tmp___2;
#line 427
      free((void *)priv->str);
#line 428
      priv->str = (char *)((void *)0);
#line 429
      tmp___3 = __errno_location();
#line 429
      *tmp___3 = saved;
      }
#line 430
      return (-1);
    }
    {
#line 433
    free((void *)priv->str);
#line 434
    priv->str = (char *)((void *)0);
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int newline___1  =    1;
#line 451
static int write_string___1(struct log_private *priv , char const   *filename , int line ,
                            char const   *function , int level , char *str ) ;
#line 451 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int prevlevel___1  =    0;
#line 448 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int write_string___1(struct log_private *priv , char const   *filename , int line ,
                            char const   *function , int level , char *str ) 
{ 
  char *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 453
  if (level != prevlevel___1) {
    {
#line 455
    fd_update(priv, prevlevel___1);
    }
#line 456
    if (! newline___1) {
      {
#line 456
      tmp___0 = line_end___1(priv, filename, line, function);
      }
#line 456
      if (tmp___0 < 0) {
#line 456
        goto error;
      }
    }
#line 457
    newline___1 = 1;
#line 458
    prevlevel___1 = level;
  }
  {
#line 461
  fd_update(priv, level);
#line 463
  s = str;
  }
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 463
    tmp = strchr((char const   *)s, '\n');
    }
#line 463
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 463
      goto while_break;
    }
#line 465
    *tmp = (char )'\000';
#line 467
    if ((unsigned long )s == (unsigned long )str) {
#line 467
      if (! newline___1) {
        {
#line 469
        newline___1 = 1;
#line 470
        tmp___1 = line_append___1(priv, (char const   *)s);
        }
#line 470
        if (tmp___1 < 0) {
#line 470
          goto error;
        }
      } else {
#line 467
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 472
      tmp___2 = line_begin___1(priv, filename, line, function, level, (char const   *)s);
      }
#line 472
      if (tmp___2 < 0) {
#line 473
        goto error;
      }
    }
    {
#line 475
    tmp___3 = line_end___1(priv, filename, line, function);
    }
#line 475
    if (tmp___3 < 0) {
#line 475
      goto error;
    }
#line 463
    s = tmp + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (*s) {
#line 480
    if (newline___1) {
      {
#line 482
      tmp___4 = line_begin___1(priv, filename, line, function, level, (char const   *)s);
      }
#line 482
      if (tmp___4 < 0) {
#line 483
        goto error;
      }
    } else {
      {
#line 485
      tmp___5 = line_append___1(priv, (char const   *)s);
      }
#line 485
      if (tmp___5 < 0) {
#line 486
        goto error;
      }
    }
#line 488
    newline___1 = 0;
  }
#line 491
  return (0);
  error: 
#line 494
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 496
    free((void *)priv->str);
#line 497
    priv->str = (char *)((void *)0);
    }
  }
#line 499
  return (-1);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int print_one_line___1(struct log_private *priv , char const   *filename ,
                              int line , char const   *function , int level , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (level != 0) {
#line 504
      if (priv->level != 0) {
#line 504
        if (! (level <= priv->level)) {
#line 504
          goto while_break;
        }
      } else {
#line 504
        goto while_break;
      }
    } else {
#line 504
      goto while_break;
    }
    {
#line 506
    fd_update(priv, level);
    }
#line 508
    if (! newline___1) {
      {
#line 508
      tmp = line_end___1(priv, filename, line, function);
      }
#line 508
      if (tmp < 0) {
#line 509
        goto while_break;
      }
    }
    {
#line 511
    newline___1 = 1;
#line 513
    tmp___0 = line_begin___1(priv, filename, line, function, level, str);
    }
#line 513
    if (tmp___0 < 0) {
#line 514
      goto while_break;
    } else {
      {
#line 513
      tmp___1 = line_end___1(priv, filename, line, function);
      }
#line 513
      if (tmp___1 < 0) {
#line 514
        goto while_break;
      }
    }
    {
#line 516
    tmp___2 = flush_cache___1(priv, filename, line, function);
    }
#line 516
    return (tmp___2);
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 521
    free((void *)priv->str);
#line 522
    priv->str = (char *)((void *)0);
    }
  }
#line 525
  return (-1);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static struct log_private log_private___1  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int initialized___1  =    0;
#line 535 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int log_open_syslog___1(char const   *str ) 
{ 
  char *facility ;
  size_t i ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 540
  tmp = strlen(str);
#line 540
  tmp___0 = malloc(tmp + 1UL);
#line 540
  log_private___1.ident = (char *)tmp___0;
  }
#line 540
  if ((unsigned long )log_private___1.ident == (unsigned long )((void *)0)) {
#line 541
    return (-1);
  }
  {
#line 543
  strcpy((char */* __restrict  */)log_private___1.ident, (char const   */* __restrict  */)str);
#line 545
  facility = strchr((char const   *)log_private___1.ident, '.');
  }
#line 545
  if ((unsigned long )facility == (unsigned long )((void *)0)) {
#line 546
    return (-1);
  }
#line 548
  tmp___1 = facility;
#line 548
  facility ++;
#line 548
  *tmp___1 = (char )'\000';
#line 550
  i = (size_t )0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! ((unsigned long )facilitynames[i].c_name != (unsigned long )((void *)0))) {
#line 550
      goto while_break;
    }
    {
#line 551
    tmp___2 = strcmp((char const   *)facility, (char const   *)facilitynames[i].c_name);
    }
#line 551
    if (! tmp___2) {
      {
#line 553
      openlog((char const   *)log_private___1.ident, 1, facilitynames[i].c_val);
      }
#line 554
      return (0);
    }
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (-1);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *vbprintf___2(char const   *fmt , va_list ap ) 
{ 
  int n ;
  int size ;
  char *buf ;
  char *ptr ;
  va_list ap_copy ;
  void *tmp ;
  void *tmp___0 ;
  int saved ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 110
  size = 100;
#line 114
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 114
    return ((char *)((void *)0));
  }
#line 116
  if ((int const   )*fmt == 0) {
    {
#line 118
    tmp = malloc(sizeof(char ));
#line 118
    buf = (char *)tmp;
    }
#line 118
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 119
      return ((char *)((void *)0));
    }
#line 120
    *buf = (char )'\000';
#line 121
    return (buf);
  }
  {
#line 124
  tmp___0 = malloc((unsigned long )size * sizeof(char ));
#line 124
  buf = (char *)tmp___0;
  }
#line 124
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 125
    return ((char *)((void *)0));
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    __builtin_va_copy(ap_copy, ap);
#line 131
    n = vsnprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)fmt,
                  ap_copy);
#line 132
    __builtin_va_end(ap_copy);
    }
#line 135
    if (n > -1) {
#line 135
      if (n < size) {
#line 135
        goto while_break;
      }
    }
#line 138
    if (n > -1) {
#line 139
      size = n + 1;
    } else {
#line 141
      size *= 2;
    }
    {
#line 143
    tmp___3 = realloc((void *)buf, (unsigned long )size * sizeof(char ));
#line 143
    ptr = (char *)tmp___3;
    }
#line 143
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___1 = __errno_location();
#line 145
      saved = *tmp___1;
#line 146
      free((void *)buf);
#line 147
      tmp___2 = __errno_location();
#line 147
      *tmp___2 = saved;
      }
#line 148
      return ((char *)((void *)0));
    } else {
#line 150
      buf = ptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (buf);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *bprintf___2(char const   *fmt  , ...) 
{ 
  char *buf ;
  va_list ap ;

  {
  {
#line 165
  __builtin_va_start(ap, fmt);
#line 166
  buf = vbprintf___2(fmt, ap);
#line 167
  __builtin_va_end(ap);
  }
#line 168
  return (buf);
}
}
#line 173
static char *prefix___2(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level ) ;
#line 173 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *colors___2[7]  = {      (char const   *)((void *)0),      "1;31",      "1;37",      (char const   *)((void *)0), 
        "1;32",      "40;33",      "1;33"};
#line 174 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char const   *levels___2[7]  = {      "  QUIET",      "  ERROR",      "WARNING",      " NORMAL", 
        "VERBOSE",      "  DEBUG",      "  NOISY"};
#line 184 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int const   syslvl___2[7]  = {      (int const   )0,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )7};
#line 171 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static char *prefix___2(struct log_private *priv , char const   *filename , int line ,
                        char const   *function , int level ) 
{ 
  int have_prefix ;
  int tmp ;
  int i ;
  int n ;
  char *buf[5] ;
  size_t len ;
  int tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  time_t tc ;
  time_t tmp___5 ;
  struct tm *tv ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int saved ;
  int *tmp___12 ;
  int *tmp___13 ;
  size_t tmp___14 ;
  int saved___0 ;
  int *tmp___15 ;
  int *tmp___16 ;
  void *tmp___17 ;

  {
#line 194
  if (! (priv->flags & 8)) {
#line 194
    if (priv->level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 194
  if (priv->flags & 8) {
#line 194
    if (level >= 5) {
#line 194
      tmp = 1;
    } else {
#line 194
      tmp = 0;
    }
  } else {
#line 194
    tmp = 0;
  }
#line 194
  have_prefix = tmp;
#line 195
  n = 0;
#line 197
  len = (size_t )0;
#line 199
  if (have_prefix) {
#line 201
    tmp___0 = n;
#line 201
    n ++;
#line 201
    if (priv->flags & 2) {
#line 201
      if (priv->flags & 64) {
#line 201
        goto _L___0;
      } else {
        {
#line 201
        tmp___4 = isatty(priv->fd);
        }
#line 201
        if (tmp___4) {
          _L___0: /* CIL Label */ 
#line 201
          if ((unsigned long )colors___2[level] != (unsigned long )((void *)0)) {
            {
#line 201
            tmp___2 = bprintf___2("\033[%sm%s: \033[0m", colors___2[level], levels___2[level]);
#line 201
            buf[tmp___0] = tmp___2;
            }
          } else {
            {
#line 201
            tmp___3 = bprintf___2("%s: ", levels___2[level]);
#line 201
            buf[tmp___0] = tmp___3;
            }
          }
        } else {
          {
#line 201
          tmp___3 = bprintf___2("%s: ", levels___2[level]);
#line 201
          buf[tmp___0] = tmp___3;
          }
        }
      }
    } else {
      {
#line 201
      tmp___3 = bprintf___2("%s: ", levels___2[level]);
#line 201
      buf[tmp___0] = tmp___3;
      }
    }
  }
#line 208
  if (priv->flags & 1) {
    {
#line 210
    tmp___5 = time((time_t *)((void *)0));
#line 210
    tc = tmp___5;
#line 211
    tmp___6 = localtime((time_t const   *)(& tc));
#line 211
    tv = tmp___6;
#line 213
    tmp___7 = n;
#line 213
    n ++;
#line 213
    buf[tmp___7] = bprintf___2("%.4d-%.2d-%.2d %.2d:%.2d:%.2d ", tv->tm_year + 1900,
                               tv->tm_mon + 1, tv->tm_mday, tv->tm_hour, tv->tm_min,
                               tv->tm_sec);
    }
  }
#line 218
  if (have_prefix) {
    {
#line 220
    tmp___8 = n;
#line 220
    n ++;
#line 220
    buf[tmp___8] = bprintf___2("%s:%d:", filename, line);
#line 221
    tmp___9 = n;
#line 221
    n ++;
    }
#line 221
    if (priv->flags & 4) {
      {
#line 221
      tmp___10 = bprintf___2("%s(): ", function);
#line 221
      buf[tmp___9] = tmp___10;
      }
    } else {
      {
#line 221
      tmp___11 = bprintf___2(" ");
#line 221
      buf[tmp___9] = tmp___11;
      }
    }
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < n)) {
#line 224
      goto while_break;
    }
#line 226
    if ((unsigned long )buf[i] == (unsigned long )((void *)0)) {
      {
#line 228
      tmp___12 = __errno_location();
#line 228
      saved = *tmp___12;
#line 230
      i = 0;
      }
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if (! (i < n)) {
#line 230
          goto while_break___0;
        }
#line 231
        if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
          {
#line 232
          free((void *)buf[i]);
          }
        }
#line 230
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 234
      tmp___13 = __errno_location();
#line 234
      *tmp___13 = saved;
      }
#line 236
      return ((char *)((void *)0));
    }
    {
#line 239
    tmp___14 = strlen((char const   *)buf[i]);
#line 239
    len += tmp___14;
#line 224
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp___17 = malloc((len + 1UL) * sizeof(char ));
#line 242
  buf[4] = (char *)tmp___17;
  }
#line 242
  if ((unsigned long )buf[4] == (unsigned long )((void *)0)) {
    {
#line 244
    tmp___15 = __errno_location();
#line 244
    saved___0 = *tmp___15;
#line 245
    i = 0;
    }
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___1;
      }
#line 246
      if ((unsigned long )buf[i] != (unsigned long )((void *)0)) {
        {
#line 247
        free((void *)buf[i]);
        }
      }
#line 245
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 248
    tmp___16 = __errno_location();
#line 248
    *tmp___16 = saved___0;
    }
#line 249
    return ((char *)((void *)0));
  }
#line 252
  *(buf[4]) = (char )'\000';
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 254
    if (! (i < n)) {
#line 254
      goto while_break___2;
    }
    {
#line 256
    strcat((char */* __restrict  */)buf[4], (char const   */* __restrict  */)buf[i]);
#line 257
    free((void *)buf[i]);
#line 254
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 260
  priv->syslvl = (int )syslvl___2[level];
#line 262
  return (buf[4]);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_append___2(struct log_private *priv , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  char *ptr ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 271
  tmp = strlen(str);
#line 271
  len = tmp + 1UL;
  }
#line 274
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 276
    tmp___0 = strlen((char const   *)priv->str);
#line 276
    tmp___1 = realloc((void *)priv->str, (len + tmp___0) * sizeof(char ));
#line 276
    ptr = (char *)tmp___1;
    }
#line 276
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 277
      return (-1);
    }
    {
#line 279
    priv->str = ptr;
#line 280
    strcat((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  } else {
    {
#line 284
    tmp___3 = malloc(len * sizeof(char ));
#line 284
    tmp___2 = (char *)tmp___3;
#line 284
    priv->str = tmp___2;
    }
#line 284
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 285
      return (-1);
    }
    {
#line 286
    strcpy((char */* __restrict  */)priv->str, (char const   */* __restrict  */)str);
    }
  }
#line 289
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_begin___2(struct log_private *priv , char const   *filename , int line ,
                          char const   *function , int level , char const   *str ) 
{ 
  char *tmp ;
  int saved ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 296
  tmp = prefix___2(priv, filename, line, function, level);
  }
#line 296
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 297
    return (-1);
  }
  {
#line 299
  tmp___2 = line_append___2(priv, (char const   *)tmp);
  }
#line 299
  if (tmp___2 < 0) {
    {
#line 301
    tmp___0 = __errno_location();
#line 301
    saved = *tmp___0;
#line 302
    free((void *)tmp);
#line 303
    tmp___1 = __errno_location();
#line 303
    *tmp___1 = saved;
    }
#line 304
    return (-1);
  }
  {
#line 307
  free((void *)tmp);
#line 309
  tmp___3 = line_append___2(priv, str);
  }
#line 309
  return (tmp___3);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int savetodisk___2(int fd , char const   *str ) 
{ 
  ssize_t n ;
  ssize_t len ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 314
  tmp = strlen(str);
#line 314
  len = (ssize_t )tmp;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (len) {
      {
#line 316
      n = write(fd, (void const   *)str, (size_t )len);
      }
#line 316
      if (! (n != len)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 318
    if (n < 0L) {
#line 318
      return (-1);
    }
#line 320
    if (! n) {
      {
#line 322
      tmp___0 = __errno_location();
#line 322
      *tmp___0 = 5;
      }
#line 323
      return (-1);
    }
#line 326
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int flush_cache___2(struct log_private *priv , char const   *filename , int line ,
                           char const   *function ) 
{ 
  int saved ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *buf ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 336
  if ((unsigned long )priv->cache.cache == (unsigned long )((void *)0)) {
#line 337
    return (0);
  } else
#line 336
  if (! (priv->flags & 16)) {
#line 337
    return (0);
  }
  {
#line 339
  tmp___1 = savetodisk___2(priv->cache.fd, (char const   *)priv->cache.cache);
  }
#line 339
  if (tmp___1 < 0) {
    error: 
    {
#line 342
    tmp = __errno_location();
#line 342
    saved = *tmp;
#line 343
    free((void *)priv->cache.cache);
#line 344
    priv->cache.cache = (char *)((void *)0);
#line 345
    tmp___0 = __errno_location();
#line 345
    *tmp___0 = saved;
    }
#line 346
    return (-1);
  }
#line 349
  if (priv->cache.hits) {
    {
#line 351
    tmp___2 = prefix___2(priv, filename, line, function, 2);
#line 351
    buf = tmp___2;
    }
#line 353
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 354
      goto error;
    }
    {
#line 356
    tmp___5 = savetodisk___2(priv->cache.fd, (char const   *)buf);
    }
#line 356
    if (tmp___5 < 0) {
      {
#line 358
      tmp___3 = __errno_location();
#line 358
      saved = *tmp___3;
#line 359
      free((void *)buf);
#line 360
      tmp___4 = __errno_location();
#line 360
      *tmp___4 = saved;
      }
#line 361
      goto error;
    }
    {
#line 364
    free((void *)buf);
#line 366
    sprintf((char */* __restrict  */)(priv->cache.buf), (char const   */* __restrict  */)"Message repeated %d times\n",
            priv->cache.hits + 1);
#line 368
    tmp___6 = savetodisk___2(priv->cache.fd, (char const   *)(priv->cache.buf));
    }
#line 368
    if (tmp___6 < 0) {
#line 369
      goto error;
    }
  }
  {
#line 372
  free((void *)priv->cache.cache);
#line 373
  priv->cache.cache = (char *)((void *)0);
  }
#line 375
  return (0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static void save_to_cache___2(struct log_private *priv ) 
{ 


  {
#line 380
  priv->cache.fd = priv->fd;
#line 381
  priv->cache.hits = 0;
#line 382
  priv->cache.cache = priv->str;
#line 383
  priv->str = (char *)((void *)0);
#line 384
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int line_end___2(struct log_private *priv , char const   *filename , int line ,
                        char const   *function ) 
{ 
  int saved ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 390
  if (priv->flags & 64) {
    {
#line 392
    syslog(priv->syslvl, "%s", priv->str);
#line 393
    free((void *)priv->str);
#line 394
    priv->str = (char *)((void *)0);
    }
#line 395
    return (0);
  }
  {
#line 398
  tmp = line_append___2(priv, "\n");
  }
#line 398
  if (tmp < 0) {
#line 399
    return (-1);
  }
#line 401
  if (priv->flags & 16) {
#line 403
    if ((unsigned long )priv->cache.cache != (unsigned long )((void *)0)) {
      {
#line 405
      tmp___1 = strcmp((char const   *)priv->str, (char const   *)priv->cache.cache);
      }
#line 405
      if (tmp___1) {
        {
#line 407
        tmp___0 = flush_cache___2(priv, filename, line, function);
        }
#line 407
        if (tmp___0 < 0) {
#line 408
          goto error;
        }
        {
#line 410
        save_to_cache___2(priv);
        }
      } else {
        {
#line 414
        free((void *)priv->str);
#line 415
        priv->str = (char *)((void *)0);
#line 416
        (priv->cache.hits) ++;
        }
      }
    } else {
      {
#line 419
      save_to_cache___2(priv);
      }
    }
  } else {
    {
#line 423
    tmp___4 = savetodisk___2(priv->fd, (char const   *)priv->str);
    }
#line 423
    if (tmp___4 < 0) {
      error: 
      {
#line 426
      tmp___2 = __errno_location();
#line 426
      saved = *tmp___2;
#line 427
      free((void *)priv->str);
#line 428
      priv->str = (char *)((void *)0);
#line 429
      tmp___3 = __errno_location();
#line 429
      *tmp___3 = saved;
      }
#line 430
      return (-1);
    }
    {
#line 433
    free((void *)priv->str);
#line 434
    priv->str = (char *)((void *)0);
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int newline___2  =    1;
#line 451
static int write_string___2(struct log_private *priv , char const   *filename , int line ,
                            char const   *function , int level , char *str ) ;
#line 451 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int prevlevel___2  =    0;
#line 448 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int write_string___2(struct log_private *priv , char const   *filename , int line ,
                            char const   *function , int level , char *str ) 
{ 
  char *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 453
  if (level != prevlevel___2) {
    {
#line 455
    fd_update(priv, prevlevel___2);
    }
#line 456
    if (! newline___2) {
      {
#line 456
      tmp___0 = line_end___2(priv, filename, line, function);
      }
#line 456
      if (tmp___0 < 0) {
#line 456
        goto error;
      }
    }
#line 457
    newline___2 = 1;
#line 458
    prevlevel___2 = level;
  }
  {
#line 461
  fd_update(priv, level);
#line 463
  s = str;
  }
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 463
    tmp = strchr((char const   *)s, '\n');
    }
#line 463
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 463
      goto while_break;
    }
#line 465
    *tmp = (char )'\000';
#line 467
    if ((unsigned long )s == (unsigned long )str) {
#line 467
      if (! newline___2) {
        {
#line 469
        newline___2 = 1;
#line 470
        tmp___1 = line_append___2(priv, (char const   *)s);
        }
#line 470
        if (tmp___1 < 0) {
#line 470
          goto error;
        }
      } else {
#line 467
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 472
      tmp___2 = line_begin___2(priv, filename, line, function, level, (char const   *)s);
      }
#line 472
      if (tmp___2 < 0) {
#line 473
        goto error;
      }
    }
    {
#line 475
    tmp___3 = line_end___2(priv, filename, line, function);
    }
#line 475
    if (tmp___3 < 0) {
#line 475
      goto error;
    }
#line 463
    s = tmp + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (*s) {
#line 480
    if (newline___2) {
      {
#line 482
      tmp___4 = line_begin___2(priv, filename, line, function, level, (char const   *)s);
      }
#line 482
      if (tmp___4 < 0) {
#line 483
        goto error;
      }
    } else {
      {
#line 485
      tmp___5 = line_append___2(priv, (char const   *)s);
      }
#line 485
      if (tmp___5 < 0) {
#line 486
        goto error;
      }
    }
#line 488
    newline___2 = 0;
  }
#line 491
  return (0);
  error: 
#line 494
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 496
    free((void *)priv->str);
#line 497
    priv->str = (char *)((void *)0);
    }
  }
#line 499
  return (-1);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int print_one_line___2(struct log_private *priv , char const   *filename ,
                              int line , char const   *function , int level , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (level != 0) {
#line 504
      if (priv->level != 0) {
#line 504
        if (! (level <= priv->level)) {
#line 504
          goto while_break;
        }
      } else {
#line 504
        goto while_break;
      }
    } else {
#line 504
      goto while_break;
    }
    {
#line 506
    fd_update(priv, level);
    }
#line 508
    if (! newline___2) {
      {
#line 508
      tmp = line_end___2(priv, filename, line, function);
      }
#line 508
      if (tmp < 0) {
#line 509
        goto while_break;
      }
    }
    {
#line 511
    newline___2 = 1;
#line 513
    tmp___0 = line_begin___2(priv, filename, line, function, level, str);
    }
#line 513
    if (tmp___0 < 0) {
#line 514
      goto while_break;
    } else {
      {
#line 513
      tmp___1 = line_end___2(priv, filename, line, function);
      }
#line 513
      if (tmp___1 < 0) {
#line 514
        goto while_break;
      }
    }
    {
#line 516
    tmp___2 = flush_cache___2(priv, filename, line, function);
    }
#line 516
    return (tmp___2);
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if ((unsigned long )priv->str != (unsigned long )((void *)0)) {
    {
#line 521
    free((void *)priv->str);
#line 522
    priv->str = (char *)((void *)0);
    }
  }
#line 525
  return (-1);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static struct log_private log_private___2  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int initialized___2  =    0;
#line 535 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/log.c"
static int log_open_syslog___2(char const   *str ) 
{ 
  char *facility ;
  size_t i ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 540
  tmp = strlen(str);
#line 540
  tmp___0 = malloc(tmp + 1UL);
#line 540
  log_private___2.ident = (char *)tmp___0;
  }
#line 540
  if ((unsigned long )log_private___2.ident == (unsigned long )((void *)0)) {
#line 541
    return (-1);
  }
  {
#line 543
  strcpy((char */* __restrict  */)log_private___2.ident, (char const   */* __restrict  */)str);
#line 545
  facility = strchr((char const   *)log_private___2.ident, '.');
  }
#line 545
  if ((unsigned long )facility == (unsigned long )((void *)0)) {
#line 546
    return (-1);
  }
#line 548
  tmp___1 = facility;
#line 548
  facility ++;
#line 548
  *tmp___1 = (char )'\000';
#line 550
  i = (size_t )0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! ((unsigned long )facilitynames[i].c_name != (unsigned long )((void *)0))) {
#line 550
      goto while_break;
    }
    {
#line 551
    tmp___2 = strcmp((char const   *)facility, (char const   *)facilitynames[i].c_name);
    }
#line 551
    if (! tmp___2) {
      {
#line 553
      openlog((char const   *)log_private___2.ident, 1, facilitynames[i].c_val);
      }
#line 554
      return (0);
    }
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (-1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static mem_t *mem_areas___2  =    (mem_t *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void (*fail_stub___2)(char const   *fmt  , ...)  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static char const   header___2[59]  = 
#line 76
  {      (char const   )'M',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'a',      (char const   )'k',      (char const   )' ', 
        (char const   )'D',      (char const   )'e',      (char const   )'t',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'S',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'m', 
        (char const   )'\n',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'-',      (char const   )'-',      (char const   )'-', 
        (char const   )'-',      (char const   )'\n',      (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xmalloc___2(char const   *file , int line , char const   *function ,
                         size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 84
  ptr = malloc(size);
  }
#line 84
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 85
    (*fail_stub___2)("malloc(size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                     size, file, line, function);
    }
  }
#line 90
  return (ptr);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void *xrealloc___3(char const   *file , int line , char const   *function ,
                          void *ptr , size_t size ) 
{ 
  void *ptr2 ;

  {
  {
#line 98
  ptr2 = realloc(ptr, size);
  }
#line 98
  if ((unsigned long )ptr2 == (unsigned long )((void *)0)) {
    {
#line 99
    (*fail_stub___2)("realloc(ptr: %p, size: %u): %m\nAttempted allocation in file \"%s\" at line %d in function %s()\n",
                     ptr, size, file, line, function);
    }
  }
#line 104
  return (ptr2);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort1___2(char const   *msg , mem_t *area , char const   *file ,
                           int line , char const   *function ) 
{ 


  {
  {
#line 110
  (*fail_stub___2)("%s%s\nAllocated in file \"%s\" at line %d in function %s()\nDiscovered in file \"%s\" at line %d in function %s()\n",
                   header___2, msg, area->file, area->line, area->function, file,
                   line, function);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void mem_abort2___2(char const   *msg , char const   *file , int line , char const   *function ) 
{ 


  {
  {
#line 120
  (*fail_stub___2)("%s%s\nDiscovered in file \"%s\" at line %d in function %s()\n",
                   header___2, msg, file, line, function);
  }
#line 124
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c"
static void fail_default_stub___2(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 284
  __builtin_va_start(ap, fmt);
  }
#line 285
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    {
#line 285
    log_vprintf_stub("/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/memory.c",
                     285, "fail_default_stub", 1, fmt, ap);
    }
  }
  {
#line 286
  __builtin_va_end(ap);
#line 287
  exit(1);
  }
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libdebug-0.4.4/src/hex.c"
static void dump16___2(char *buf , uint8_t const   *s , uintptr_t offset , size_t len ) 
{ 
  size_t i ;
  size_t n ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___9 ;
  size_t tmp___10 ;

  {
#line 48
  if (len) {
    {
#line 52
    tmp = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%08x - ",
                  offset);
#line 52
    n = (size_t )tmp;
#line 54
    i = (size_t )0;
    }
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
#line 54
      if (! (i < len)) {
#line 54
        goto while_break;
      }
#line 56
      if (i) {
#line 56
        if (! (i & 3UL)) {
#line 57
          tmp___0 = n;
#line 57
          n ++;
#line 57
          *(buf + tmp___0) = (char )' ';
        }
      }
      {
#line 59
      tmp___1 = sprintf((char */* __restrict  */)(buf + n), (char const   */* __restrict  */)"%02x ",
                        (int const   )*(s + i));
#line 59
      n += (size_t )tmp___1;
#line 54
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (i < 16UL)) {
#line 62
        goto while_break___0;
      }
#line 64
      if (i) {
#line 64
        if (! (i & 3UL)) {
#line 65
          tmp___2 = n;
#line 65
          n ++;
#line 65
          *(buf + tmp___2) = (char )' ';
        }
      }
#line 67
      tmp___3 = n;
#line 67
      n ++;
#line 67
      *(buf + tmp___3) = (char )' ';
#line 68
      tmp___4 = n;
#line 68
      n ++;
#line 68
      *(buf + tmp___4) = (char )' ';
#line 69
      tmp___5 = n;
#line 69
      n ++;
#line 69
      *(buf + tmp___5) = (char )' ';
#line 62
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    tmp___6 = n;
#line 72
    n ++;
#line 72
    *(buf + tmp___6) = (char )' ';
#line 74
    i = (size_t )0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (i < len)) {
#line 74
        goto while_break___1;
      }
      {
#line 75
      tmp___7 = n;
#line 75
      n ++;
#line 75
      tmp___9 = printable((int )*(s + i));
      }
#line 75
      if (tmp___9) {
#line 75
        *(buf + tmp___7) = (char )*(s + i);
      } else {
#line 75
        *(buf + tmp___7) = (char )'.';
      }
#line 74
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 77
    tmp___10 = n;
#line 77
    n ++;
#line 77
    *(buf + tmp___10) = (char )'\n';
#line 78
    *(buf + n) = (char )'\000';
  }
#line 80
  return;
}
}
